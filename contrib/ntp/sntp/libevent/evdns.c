begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2006-2007 Niels Provos  * Copyright 2007-2012 Nick Mathewson and Niels Provos  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* Based on software by Adam Langly. Adam's original message:  *  * Async DNS Library  * Adam Langley<agl@imperialviolet.org>  * http://www.imperialviolet.org/eventdns.html  * Public Domain code  *  * This software is Public Domain. To view a copy of the public domain dedication,  * visit http://creativecommons.org/licenses/publicdomain/ or send a letter to  * Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.  *  * I ask and expect, but do not require, that all derivative works contain an  * attribution similar to:  *	Parts developed by Adam Langley<agl@imperialviolet.org>  *  * You may wish to replace the word "Parts" with something else depending on  * the amount of original code.  *  * (Derivative works does not include programs which link against, run or include  * the source verbatim in their source distributions)  *  * Version: 0.1b  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_FORTIFY_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_FORTIFY_SOURCE
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_STDINT_H
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<ws2tcpip.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32_IE
end_ifndef

begin_define
define|#
directive|define
name|_WIN32_IE
value|0x400
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<shlobj.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/dns.h"
end_include

begin_include
include|#
directive|include
file|"event2/dns_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/dns_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/thread.h"
end_include

begin_include
include|#
directive|include
file|"defer-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"strlcpy-internal.h"
end_include

begin_include
include|#
directive|include
file|"ipv6-internal.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<iphlpapi.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_NETINET_IN6_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EVDNS_LOG_DEBUG
value|EVENT_LOG_DEBUG
end_define

begin_define
define|#
directive|define
name|EVDNS_LOG_WARN
value|EVENT_LOG_WARN
end_define

begin_define
define|#
directive|define
name|EVDNS_LOG_MSG
value|EVENT_LOG_MSG
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_NAME_MAX
end_ifndef

begin_define
define|#
directive|define
name|HOST_NAME_MAX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b)?(a):(b))
end_define

begin_define
define|#
directive|define
name|ASSERT_VALID_REQUEST
parameter_list|(
name|req
parameter_list|)
define|\
value|EVUTIL_ASSERT((req)->handle&& (req)->handle->current_req == (req))
end_define

begin_define
define|#
directive|define
name|u64
value|ev_uint64_t
end_define

begin_define
define|#
directive|define
name|u32
value|ev_uint32_t
end_define

begin_define
define|#
directive|define
name|u16
value|ev_uint16_t
end_define

begin_define
define|#
directive|define
name|u8
value|ev_uint8_t
end_define

begin_comment
comment|/* maximum number of addresses from a single packet */
end_comment

begin_comment
comment|/* that we bother recording */
end_comment

begin_define
define|#
directive|define
name|MAX_V4_ADDRS
value|32
end_define

begin_define
define|#
directive|define
name|MAX_V6_ADDRS
value|32
end_define

begin_define
define|#
directive|define
name|TYPE_A
value|EVDNS_TYPE_A
end_define

begin_define
define|#
directive|define
name|TYPE_CNAME
value|5
end_define

begin_define
define|#
directive|define
name|TYPE_PTR
value|EVDNS_TYPE_PTR
end_define

begin_define
define|#
directive|define
name|TYPE_SOA
value|EVDNS_TYPE_SOA
end_define

begin_define
define|#
directive|define
name|TYPE_AAAA
value|EVDNS_TYPE_AAAA
end_define

begin_define
define|#
directive|define
name|CLASS_INET
value|EVDNS_CLASS_INET
end_define

begin_comment
comment|/* Persistent handle.  We keep this separate from 'struct request' since we  * need some object to last for as long as an evdns_request is outstanding so  * that it can be canceled, whereas a search request can lead to multiple  * 'struct request' instances being created over its lifetime. */
end_comment

begin_struct
struct|struct
name|evdns_request
block|{
name|struct
name|request
modifier|*
name|current_req
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|base
decl_stmt|;
name|int
name|pending_cb
decl_stmt|;
comment|/* Waiting for its callback to be invoked; not 			 * owned by event base any more. */
comment|/* elements used by the searching code */
name|int
name|search_index
decl_stmt|;
name|struct
name|search_state
modifier|*
name|search_state
decl_stmt|;
name|char
modifier|*
name|search_origname
decl_stmt|;
comment|/* needs to be free()ed */
name|int
name|search_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|request
block|{
name|u8
modifier|*
name|request
decl_stmt|;
comment|/* the dns packet data */
name|u8
name|request_type
decl_stmt|;
comment|/* TYPE_PTR or TYPE_A or TYPE_AAAA */
name|unsigned
name|int
name|request_len
decl_stmt|;
name|int
name|reissue_count
decl_stmt|;
name|int
name|tx_count
decl_stmt|;
comment|/* the number of times that this packet has been sent */
name|void
modifier|*
name|user_pointer
decl_stmt|;
comment|/* the pointer given to us for this request */
name|evdns_callback_type
name|user_callback
decl_stmt|;
name|struct
name|nameserver
modifier|*
name|ns
decl_stmt|;
comment|/* the server which we last sent it */
comment|/* these objects are kept in a circular list */
comment|/* XXX We could turn this into a CIRCLEQ. */
name|struct
name|request
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|event
name|timeout_event
decl_stmt|;
name|u16
name|trans_id
decl_stmt|;
comment|/* the transaction id */
name|unsigned
name|request_appended
range|:
literal|1
decl_stmt|;
comment|/* true if the request pointer is data which follows this struct */
name|unsigned
name|transmit_me
range|:
literal|1
decl_stmt|;
comment|/* needs to be transmitted */
comment|/* XXXX This is a horrible hack. */
name|char
modifier|*
modifier|*
name|put_cname_in_ptr
decl_stmt|;
comment|/* store the cname here if we get one. */
name|struct
name|evdns_base
modifier|*
name|base
decl_stmt|;
name|struct
name|evdns_request
modifier|*
name|handle
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|reply
block|{
name|unsigned
name|int
name|type
decl_stmt|;
name|unsigned
name|int
name|have_answer
range|:
literal|1
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|u32
name|addrcount
decl_stmt|;
name|u32
name|addresses
index|[
name|MAX_V4_ADDRS
index|]
decl_stmt|;
block|}
name|a
struct|;
struct|struct
block|{
name|u32
name|addrcount
decl_stmt|;
name|struct
name|in6_addr
name|addresses
index|[
name|MAX_V6_ADDRS
index|]
decl_stmt|;
block|}
name|aaaa
struct|;
struct|struct
block|{
name|char
name|name
index|[
name|HOST_NAME_MAX
index|]
decl_stmt|;
block|}
name|ptr
struct|;
block|}
name|data
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nameserver
block|{
name|evutil_socket_t
name|socket
decl_stmt|;
comment|/* a connected UDP socket */
name|struct
name|sockaddr_storage
name|address
decl_stmt|;
name|ev_socklen_t
name|addrlen
decl_stmt|;
name|int
name|failed_times
decl_stmt|;
comment|/* number of times which we have given this server a chance */
name|int
name|timedout
decl_stmt|;
comment|/* number of times in a row a request has timed out */
name|struct
name|event
name|event
decl_stmt|;
comment|/* these objects are kept in a circular list */
name|struct
name|nameserver
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|event
name|timeout_event
decl_stmt|;
comment|/* used to keep the timeout for */
comment|/* when we next probe this server. */
comment|/* Valid if state == 0 */
comment|/* Outstanding probe request for this nameserver, if any */
name|struct
name|evdns_request
modifier|*
name|probe_request
decl_stmt|;
name|char
name|state
decl_stmt|;
comment|/* zero if we think that this server is down */
name|char
name|choked
decl_stmt|;
comment|/* true if we have an EAGAIN from this server's socket */
name|char
name|write_waiting
decl_stmt|;
comment|/* true if we are waiting for EV_WRITE events */
name|struct
name|evdns_base
modifier|*
name|base
decl_stmt|;
comment|/* Number of currently inflight requests: used 	 * to track when we should add/del the event. */
name|int
name|requests_inflight
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Represents a local port where we're listening for DNS requests. Right now, */
end_comment

begin_comment
comment|/* only UDP is supported. */
end_comment

begin_struct
struct|struct
name|evdns_server_port
block|{
name|evutil_socket_t
name|socket
decl_stmt|;
comment|/* socket we use to read queries and write replies. */
name|int
name|refcnt
decl_stmt|;
comment|/* reference count. */
name|char
name|choked
decl_stmt|;
comment|/* Are we currently blocked from writing? */
name|char
name|closing
decl_stmt|;
comment|/* Are we trying to close this port, pending writes? */
name|evdns_request_callback_fn_type
name|user_callback
decl_stmt|;
comment|/* Fn to handle requests */
name|void
modifier|*
name|user_data
decl_stmt|;
comment|/* Opaque pointer passed to user_callback */
name|struct
name|event
name|event
decl_stmt|;
comment|/* Read/write event */
comment|/* circular list of replies that we want to write. */
name|struct
name|server_request
modifier|*
name|pending_replies
decl_stmt|;
name|struct
name|event_base
modifier|*
name|event_base
decl_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
name|void
modifier|*
name|lock
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* Represents part of a reply being built.	(That is, a single RR.) */
end_comment

begin_struct
struct|struct
name|server_reply_item
block|{
name|struct
name|server_reply_item
modifier|*
name|next
decl_stmt|;
comment|/* next item in sequence. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name part of the RR */
name|u16
name|type
decl_stmt|;
comment|/* The RR type */
name|u16
name|class
decl_stmt|;
comment|/* The RR class (usually CLASS_INET) */
name|u32
name|ttl
decl_stmt|;
comment|/* The RR TTL */
name|char
name|is_name
decl_stmt|;
comment|/* True iff data is a label */
name|u16
name|datalen
decl_stmt|;
comment|/* Length of data; -1 if data is a label */
name|void
modifier|*
name|data
decl_stmt|;
comment|/* The contents of the RR */
block|}
struct|;
end_struct

begin_comment
comment|/* Represents a request that we've received as a DNS server, and holds */
end_comment

begin_comment
comment|/* the components of the reply as we're constructing it. */
end_comment

begin_struct
struct|struct
name|server_request
block|{
comment|/* Pointers to the next and previous entries on the list of replies */
comment|/* that we're waiting to write.	 Only set if we have tried to respond */
comment|/* and gotten EAGAIN. */
name|struct
name|server_request
modifier|*
name|next_pending
decl_stmt|;
name|struct
name|server_request
modifier|*
name|prev_pending
decl_stmt|;
name|u16
name|trans_id
decl_stmt|;
comment|/* Transaction id. */
name|struct
name|evdns_server_port
modifier|*
name|port
decl_stmt|;
comment|/* Which port received this request on? */
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
comment|/* Where to send the response */
name|ev_socklen_t
name|addrlen
decl_stmt|;
comment|/* length of addr */
name|int
name|n_answer
decl_stmt|;
comment|/* how many answer RRs have been set? */
name|int
name|n_authority
decl_stmt|;
comment|/* how many authority RRs have been set? */
name|int
name|n_additional
decl_stmt|;
comment|/* how many additional RRs have been set? */
name|struct
name|server_reply_item
modifier|*
name|answer
decl_stmt|;
comment|/* linked list of answer RRs */
name|struct
name|server_reply_item
modifier|*
name|authority
decl_stmt|;
comment|/* linked list of authority RRs */
name|struct
name|server_reply_item
modifier|*
name|additional
decl_stmt|;
comment|/* linked list of additional RRs */
comment|/* Constructed response.  Only set once we're ready to send a reply. */
comment|/* Once this is set, the RR fields are cleared, and no more should be set. */
name|char
modifier|*
name|response
decl_stmt|;
name|size_t
name|response_len
decl_stmt|;
comment|/* Caller-visible fields: flags, questions. */
name|struct
name|evdns_server_request
name|base
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|evdns_base
block|{
comment|/* An array of n_req_heads circular lists for inflight requests. 	 * Each inflight request req is in req_heads[req->trans_id % n_req_heads]. 	 */
name|struct
name|request
modifier|*
modifier|*
name|req_heads
decl_stmt|;
comment|/* A circular list of requests that we're waiting to send, but haven't 	 * sent yet because there are too many requests inflight */
name|struct
name|request
modifier|*
name|req_waiting_head
decl_stmt|;
comment|/* A circular list of nameservers. */
name|struct
name|nameserver
modifier|*
name|server_head
decl_stmt|;
name|int
name|n_req_heads
decl_stmt|;
name|struct
name|event_base
modifier|*
name|event_base
decl_stmt|;
comment|/* The number of good nameservers that we have */
name|int
name|global_good_nameservers
decl_stmt|;
comment|/* inflight requests are contained in the req_head list */
comment|/* and are actually going out across the network */
name|int
name|global_requests_inflight
decl_stmt|;
comment|/* requests which aren't inflight are in the waiting list */
comment|/* and are counted here */
name|int
name|global_requests_waiting
decl_stmt|;
name|int
name|global_max_requests_inflight
decl_stmt|;
name|struct
name|timeval
name|global_timeout
decl_stmt|;
comment|/* 5 seconds by default */
name|int
name|global_max_reissues
decl_stmt|;
comment|/* a reissue occurs when we get some errors from the server */
name|int
name|global_max_retransmits
decl_stmt|;
comment|/* number of times we'll retransmit a request which timed out */
comment|/* number of timeouts in a row before we consider this server to be down */
name|int
name|global_max_nameserver_timeout
decl_stmt|;
comment|/* true iff we will use the 0x20 hack to prevent poisoning attacks. */
name|int
name|global_randomize_case
decl_stmt|;
comment|/* The first time that a nameserver fails, how long do we wait before 	 * probing to see if it has returned?  */
name|struct
name|timeval
name|global_nameserver_probe_initial_timeout
decl_stmt|;
comment|/** Port to bind to for outgoing DNS packets. */
name|struct
name|sockaddr_storage
name|global_outgoing_address
decl_stmt|;
comment|/** ev_socklen_t for global_outgoing_address. 0 if it isn't set. */
name|ev_socklen_t
name|global_outgoing_addrlen
decl_stmt|;
name|struct
name|timeval
name|global_getaddrinfo_allow_skew
decl_stmt|;
name|int
name|getaddrinfo_ipv4_timeouts
decl_stmt|;
name|int
name|getaddrinfo_ipv6_timeouts
decl_stmt|;
name|int
name|getaddrinfo_ipv4_answered
decl_stmt|;
name|int
name|getaddrinfo_ipv6_answered
decl_stmt|;
name|struct
name|search_state
modifier|*
name|global_search_state
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument|hosts_list
argument_list|,
argument|hosts_entry
argument_list|)
name|hostsdb
expr_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
name|void
modifier|*
name|lock
decl_stmt|;
endif|#
directive|endif
name|int
name|disable_when_inactive
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hosts_entry
block|{
name|TAILQ_ENTRY
argument_list|(
argument|hosts_entry
argument_list|)
name|next
expr_stmt|;
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
block|}
name|addr
union|;
name|int
name|addrlen
decl_stmt|;
name|char
name|hostname
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|evdns_base
modifier|*
name|current_base
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|evdns_base
modifier|*
name|evdns_get_global_base
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_base
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an evdns_server_request, get the corresponding */
end_comment

begin_comment
comment|/* server_request. */
end_comment

begin_define
define|#
directive|define
name|TO_SERVER_REQUEST
parameter_list|(
name|base_ptr
parameter_list|)
define|\
value|((struct server_request*)					\ 	  (((char*)(base_ptr) - evutil_offsetof(struct server_request, base))))
end_define

begin_define
define|#
directive|define
name|REQ_HEAD
parameter_list|(
name|base
parameter_list|,
name|id
parameter_list|)
value|((base)->req_heads[id % (base)->n_req_heads])
end_define

begin_function_decl
specifier|static
name|struct
name|nameserver
modifier|*
name|nameserver_pick
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evdns_request_insert
parameter_list|(
name|struct
name|request
modifier|*
name|req
parameter_list|,
name|struct
name|request
modifier|*
modifier|*
name|head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evdns_request_remove
parameter_list|(
name|struct
name|request
modifier|*
name|req
parameter_list|,
name|struct
name|request
modifier|*
modifier|*
name|head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nameserver_ready_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evdns_transmit
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evdns_request_transmit
parameter_list|(
name|struct
name|request
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nameserver_send_probe
parameter_list|(
name|struct
name|nameserver
modifier|*
specifier|const
name|ns
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|search_request_finished
parameter_list|(
name|struct
name|evdns_request
modifier|*
specifier|const
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|search_try_next
parameter_list|(
name|struct
name|evdns_request
modifier|*
specifier|const
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|request
modifier|*
name|search_request_new
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|struct
name|evdns_request
modifier|*
name|handle
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|user_callback
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evdns_requests_pump_waiting_queue
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u16
name|transaction_id_pick
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|request
modifier|*
name|request_new
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|struct
name|evdns_request
modifier|*
name|handle
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|callback
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|request_submit
parameter_list|(
name|struct
name|request
modifier|*
specifier|const
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|server_request_free
parameter_list|(
name|struct
name|server_request
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|server_request_free_answers
parameter_list|(
name|struct
name|server_request
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|server_port_free
parameter_list|(
name|struct
name|evdns_server_port
modifier|*
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|server_port_ready_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evdns_base_resolv_conf_parse_impl
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evdns_base_set_option_impl
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evdns_base_free_and_unlock
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|int
name|fail_requests
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evdns_request_timeout_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|strtoint
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__DISABLE_THREAD_SUPPORT
end_ifdef

begin_define
define|#
directive|define
name|EVDNS_LOCK
parameter_list|(
name|base
parameter_list|)
value|EVUTIL_NIL_STMT_
end_define

begin_define
define|#
directive|define
name|EVDNS_UNLOCK
parameter_list|(
name|base
parameter_list|)
value|EVUTIL_NIL_STMT_
end_define

begin_define
define|#
directive|define
name|ASSERT_LOCKED
parameter_list|(
name|base
parameter_list|)
value|EVUTIL_NIL_STMT_
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EVDNS_LOCK
parameter_list|(
name|base
parameter_list|)
define|\
value|EVLOCK_LOCK((base)->lock, 0)
end_define

begin_define
define|#
directive|define
name|EVDNS_UNLOCK
parameter_list|(
name|base
parameter_list|)
define|\
value|EVLOCK_UNLOCK((base)->lock, 0)
end_define

begin_define
define|#
directive|define
name|ASSERT_LOCKED
parameter_list|(
name|base
parameter_list|)
define|\
value|EVLOCK_ASSERT_LOCKED((base)->lock)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|evdns_debug_log_fn_type
name|evdns_log_fn
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|evdns_set_log_fn
parameter_list|(
name|evdns_debug_log_fn_type
name|fn
parameter_list|)
block|{
name|evdns_log_fn
operator|=
name|fn
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|EVDNS_LOG_CHECK
value|__attribute__ ((format(printf, 2, 3)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EVDNS_LOG_CHECK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|evdns_log_
argument_list|(
name|int
name|severity
argument_list|,
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
name|EVDNS_LOG_CHECK
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|evdns_log_
parameter_list|(
name|int
name|severity
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdns_log_fn
condition|)
block|{
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|int
name|is_warn
init|=
operator|(
name|severity
operator|==
name|EVDNS_LOG_WARN
operator|)
decl_stmt|;
name|evutil_vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|evdns_log_fn
argument_list|(
name|is_warn
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_logv_
argument_list|(
name|severity
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|log
value|evdns_log_
end_define

begin_comment
comment|/* This walks the list of inflight requests to find the */
end_comment

begin_comment
comment|/* one with a matching transaction id. Returns NULL on */
end_comment

begin_comment
comment|/* failure */
end_comment

begin_function
specifier|static
name|struct
name|request
modifier|*
name|request_find_from_trans_id
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|u16
name|trans_id
parameter_list|)
block|{
name|struct
name|request
modifier|*
name|req
init|=
name|REQ_HEAD
argument_list|(
name|base
argument_list|,
name|trans_id
argument_list|)
decl_stmt|;
name|struct
name|request
modifier|*
specifier|const
name|started_at
init|=
name|req
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
block|{
do|do
block|{
if|if
condition|(
name|req
operator|->
name|trans_id
operator|==
name|trans_id
condition|)
return|return
name|req
return|;
name|req
operator|=
name|req
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|req
operator|!=
name|started_at
condition|)
do|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* a libevent callback function which is called when a nameserver */
end_comment

begin_comment
comment|/* has gone down and we want to test if it has came back to life yet */
end_comment

begin_function
specifier|static
name|void
name|nameserver_prod_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nameserver
modifier|*
specifier|const
name|ns
init|=
operator|(
expr|struct
name|nameserver
operator|*
operator|)
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|events
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
name|nameserver_send_probe
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* a libevent callback which is called when a nameserver probe (to see if */
end_comment

begin_comment
comment|/* it has come back to life) times out. We increment the count of failed_times */
end_comment

begin_comment
comment|/* and wait longer to send the next probe packet. */
end_comment

begin_function
specifier|static
name|void
name|nameserver_probe_failed
parameter_list|(
name|struct
name|nameserver
modifier|*
specifier|const
name|ns
parameter_list|)
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|evtimer_del
argument_list|(
operator|&
name|ns
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|state
operator|==
literal|1
condition|)
block|{
comment|/* This can happen if the nameserver acts in a way which makes us mark */
comment|/* it as bad and then starts sending good replies. */
return|return;
block|}
define|#
directive|define
name|MAX_PROBE_TIMEOUT
value|3600
define|#
directive|define
name|TIMEOUT_BACKOFF_FACTOR
value|3
name|memcpy
argument_list|(
operator|&
name|timeout
argument_list|,
operator|&
name|ns
operator|->
name|base
operator|->
name|global_nameserver_probe_initial_timeout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ns
operator|->
name|failed_times
init|;
name|i
operator|>
literal|0
operator|&&
name|timeout
operator|.
name|tv_sec
operator|<
name|MAX_PROBE_TIMEOUT
condition|;
operator|--
name|i
control|)
block|{
name|timeout
operator|.
name|tv_sec
operator|*=
name|TIMEOUT_BACKOFF_FACTOR
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|*=
name|TIMEOUT_BACKOFF_FACTOR
expr_stmt|;
if|if
condition|(
name|timeout
operator|.
name|tv_usec
operator|>
literal|1000000
condition|)
block|{
name|timeout
operator|.
name|tv_sec
operator|+=
name|timeout
operator|.
name|tv_usec
operator|/
literal|1000000
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|%=
literal|1000000
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timeout
operator|.
name|tv_sec
operator|>
name|MAX_PROBE_TIMEOUT
condition|)
block|{
name|timeout
operator|.
name|tv_sec
operator|=
name|MAX_PROBE_TIMEOUT
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
name|ns
operator|->
name|failed_times
operator|++
expr_stmt|;
if|if
condition|(
name|evtimer_add
argument_list|(
operator|&
name|ns
operator|->
name|timeout_event
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|addrbuf
index|[
literal|128
index|]
decl_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Error from libevent when adding timer event for %s"
argument_list|,
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ns
operator|->
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|request_swap_ns
parameter_list|(
name|struct
name|request
modifier|*
name|req
parameter_list|,
name|struct
name|nameserver
modifier|*
name|ns
parameter_list|)
block|{
if|if
condition|(
name|ns
operator|&&
name|req
operator|->
name|ns
operator|!=
name|ns
condition|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|req
operator|->
name|ns
operator|->
name|requests_inflight
operator|>
literal|0
argument_list|)
expr_stmt|;
name|req
operator|->
name|ns
operator|->
name|requests_inflight
operator|--
expr_stmt|;
name|ns
operator|->
name|requests_inflight
operator|++
expr_stmt|;
name|req
operator|->
name|ns
operator|=
name|ns
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* called when a nameserver has been deemed to have failed. For example, too */
end_comment

begin_comment
comment|/* many packets have timed out etc */
end_comment

begin_function
specifier|static
name|void
name|nameserver_failed
parameter_list|(
name|struct
name|nameserver
modifier|*
specifier|const
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|request
modifier|*
name|req
decl_stmt|,
modifier|*
name|started_at
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|base
init|=
name|ns
operator|->
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|addrbuf
index|[
literal|128
index|]
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* if this nameserver has already been marked as failed */
comment|/* then don't do anything */
if|if
condition|(
operator|!
name|ns
operator|->
name|state
condition|)
return|return;
name|log
argument_list|(
name|EVDNS_LOG_MSG
argument_list|,
literal|"Nameserver %s has failed: %s"
argument_list|,
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ns
operator|->
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|base
operator|->
name|global_good_nameservers
operator|--
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|base
operator|->
name|global_good_nameservers
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|global_good_nameservers
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_MSG
argument_list|,
literal|"All nameservers have failed"
argument_list|)
expr_stmt|;
block|}
name|ns
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|ns
operator|->
name|failed_times
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|evtimer_add
argument_list|(
operator|&
name|ns
operator|->
name|timeout_event
argument_list|,
operator|&
name|base
operator|->
name|global_nameserver_probe_initial_timeout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Error from libevent when adding timer event for %s"
argument_list|,
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ns
operator|->
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ???? Do more? */
block|}
comment|/* walk the list of inflight requests to see if any can be reassigned to */
comment|/* a different server. Requests in the waiting queue don't have a */
comment|/* nameserver assigned yet */
comment|/* if we don't have *any* good nameservers then there's no point */
comment|/* trying to reassign requests to one */
if|if
condition|(
operator|!
name|base
operator|->
name|global_good_nameservers
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|n_req_heads
condition|;
operator|++
name|i
control|)
block|{
name|req
operator|=
name|started_at
operator|=
name|base
operator|->
name|req_heads
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|req
condition|)
block|{
do|do
block|{
if|if
condition|(
name|req
operator|->
name|tx_count
operator|==
literal|0
operator|&&
name|req
operator|->
name|ns
operator|==
name|ns
condition|)
block|{
comment|/* still waiting to go out, can be moved */
comment|/* to another server */
name|request_swap_ns
argument_list|(
name|req
argument_list|,
name|nameserver_pick
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|req
operator|=
name|req
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|req
operator|!=
name|started_at
condition|)
do|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nameserver_up
parameter_list|(
name|struct
name|nameserver
modifier|*
specifier|const
name|ns
parameter_list|)
block|{
name|char
name|addrbuf
index|[
literal|128
index|]
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|state
condition|)
return|return;
name|log
argument_list|(
name|EVDNS_LOG_MSG
argument_list|,
literal|"Nameserver %s is back up"
argument_list|,
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ns
operator|->
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|evtimer_del
argument_list|(
operator|&
name|ns
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|probe_request
condition|)
block|{
name|evdns_cancel_request
argument_list|(
name|ns
operator|->
name|base
argument_list|,
name|ns
operator|->
name|probe_request
argument_list|)
expr_stmt|;
name|ns
operator|->
name|probe_request
operator|=
name|NULL
expr_stmt|;
block|}
name|ns
operator|->
name|state
operator|=
literal|1
expr_stmt|;
name|ns
operator|->
name|failed_times
operator|=
literal|0
expr_stmt|;
name|ns
operator|->
name|timedout
operator|=
literal|0
expr_stmt|;
name|ns
operator|->
name|base
operator|->
name|global_good_nameservers
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|request_trans_id_set
parameter_list|(
name|struct
name|request
modifier|*
specifier|const
name|req
parameter_list|,
specifier|const
name|u16
name|trans_id
parameter_list|)
block|{
name|req
operator|->
name|trans_id
operator|=
name|trans_id
expr_stmt|;
operator|*
operator|(
operator|(
name|u16
operator|*
operator|)
name|req
operator|->
name|request
operator|)
operator|=
name|htons
argument_list|(
name|trans_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to remove a request from a list and dealloc it. */
end_comment

begin_comment
comment|/* head is a pointer to the head of the list it should be */
end_comment

begin_comment
comment|/* removed from or NULL if the request isn't in a list. */
end_comment

begin_comment
comment|/* when free_handle is one, free the handle as well. */
end_comment

begin_function
specifier|static
name|void
name|request_finished
parameter_list|(
name|struct
name|request
modifier|*
specifier|const
name|req
parameter_list|,
name|struct
name|request
modifier|*
modifier|*
name|head
parameter_list|,
name|int
name|free_handle
parameter_list|)
block|{
name|struct
name|evdns_base
modifier|*
name|base
init|=
name|req
operator|->
name|base
decl_stmt|;
name|int
name|was_inflight
init|=
operator|(
name|head
operator|!=
operator|&
name|base
operator|->
name|req_waiting_head
operator|)
decl_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|ASSERT_VALID_REQUEST
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
condition|)
name|evdns_request_remove
argument_list|(
name|req
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Removing timeout for request %p"
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_inflight
condition|)
block|{
name|evtimer_del
argument_list|(
operator|&
name|req
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
name|base
operator|->
name|global_requests_inflight
operator|--
expr_stmt|;
name|req
operator|->
name|ns
operator|->
name|requests_inflight
operator|--
expr_stmt|;
block|}
else|else
block|{
name|base
operator|->
name|global_requests_waiting
operator|--
expr_stmt|;
block|}
comment|/* it was initialized during request_new / evtimer_assign */
name|event_debug_unassign
argument_list|(
operator|&
name|req
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|ns
operator|&&
name|req
operator|->
name|ns
operator|->
name|requests_inflight
operator|==
literal|0
operator|&&
name|req
operator|->
name|base
operator|->
name|disable_when_inactive
condition|)
block|{
name|event_del
argument_list|(
operator|&
name|req
operator|->
name|ns
operator|->
name|event
argument_list|)
expr_stmt|;
name|evtimer_del
argument_list|(
operator|&
name|req
operator|->
name|ns
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|req
operator|->
name|request_appended
condition|)
block|{
comment|/* need to free the request data on it's own */
name|mm_free
argument_list|(
name|req
operator|->
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the request data is appended onto the header */
comment|/* so everything gets free()ed when we: */
block|}
if|if
condition|(
name|req
operator|->
name|handle
condition|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|req
operator|->
name|handle
operator|->
name|current_req
operator|==
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_handle
condition|)
block|{
name|search_request_finished
argument_list|(
name|req
operator|->
name|handle
argument_list|)
expr_stmt|;
name|req
operator|->
name|handle
operator|->
name|current_req
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|req
operator|->
name|handle
operator|->
name|pending_cb
condition|)
block|{
comment|/* If we're planning to run the callback, 				 * don't free the handle until later. */
name|mm_free
argument_list|(
name|req
operator|->
name|handle
argument_list|)
expr_stmt|;
block|}
name|req
operator|->
name|handle
operator|=
name|NULL
expr_stmt|;
comment|/* If we have a bug, let's crash 					     * early */
block|}
else|else
block|{
name|req
operator|->
name|handle
operator|->
name|current_req
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|mm_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|evdns_requests_pump_waiting_queue
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called when a server returns a funny error code. */
end_comment

begin_comment
comment|/* We try the request again with another server. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* return: */
end_comment

begin_comment
comment|/*   0 ok */
end_comment

begin_comment
comment|/*   1 failed/reissue is pointless */
end_comment

begin_function
specifier|static
name|int
name|request_reissue
parameter_list|(
name|struct
name|request
modifier|*
name|req
parameter_list|)
block|{
specifier|const
name|struct
name|nameserver
modifier|*
specifier|const
name|last_ns
init|=
name|req
operator|->
name|ns
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|req
operator|->
name|base
argument_list|)
expr_stmt|;
name|ASSERT_VALID_REQUEST
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* the last nameserver should have been marked as failing */
comment|/* by the caller of this function, therefore pick will try */
comment|/* not to return it */
name|request_swap_ns
argument_list|(
name|req
argument_list|,
name|nameserver_pick
argument_list|(
name|req
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|ns
operator|==
name|last_ns
condition|)
block|{
comment|/* ... but pick did return it */
comment|/* not a lot of point in trying again with the */
comment|/* same server */
return|return
literal|1
return|;
block|}
name|req
operator|->
name|reissue_count
operator|++
expr_stmt|;
name|req
operator|->
name|tx_count
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|transmit_me
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* this function looks for space on the inflight queue and promotes */
end_comment

begin_comment
comment|/* requests from the waiting queue if it can. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* TODO: */
end_comment

begin_comment
comment|/* add return code, see at nameserver_pick() and other functions. */
end_comment

begin_function
specifier|static
name|void
name|evdns_requests_pump_waiting_queue
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
name|base
operator|->
name|global_requests_inflight
operator|<
name|base
operator|->
name|global_max_requests_inflight
operator|&&
name|base
operator|->
name|global_requests_waiting
condition|)
block|{
name|struct
name|request
modifier|*
name|req
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|base
operator|->
name|req_waiting_head
argument_list|)
expr_stmt|;
name|req
operator|=
name|base
operator|->
name|req_waiting_head
expr_stmt|;
name|req
operator|->
name|ns
operator|=
name|nameserver_pick
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
operator|->
name|ns
condition|)
return|return;
comment|/* move a request from the waiting queue to the inflight queue */
name|req
operator|->
name|ns
operator|->
name|requests_inflight
operator|++
expr_stmt|;
name|evdns_request_remove
argument_list|(
name|req
argument_list|,
operator|&
name|base
operator|->
name|req_waiting_head
argument_list|)
expr_stmt|;
name|base
operator|->
name|global_requests_waiting
operator|--
expr_stmt|;
name|base
operator|->
name|global_requests_inflight
operator|++
expr_stmt|;
name|request_trans_id_set
argument_list|(
name|req
argument_list|,
name|transaction_id_pick
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_request_insert
argument_list|(
name|req
argument_list|,
operator|&
name|REQ_HEAD
argument_list|(
name|base
argument_list|,
name|req
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_request_transmit
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|evdns_transmit
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* TODO(nickm) document */
end_comment

begin_struct
struct|struct
name|deferred_reply_callback
block|{
name|struct
name|event_callback
name|deferred
decl_stmt|;
name|struct
name|evdns_request
modifier|*
name|handle
decl_stmt|;
name|u8
name|request_type
decl_stmt|;
name|u8
name|have_reply
decl_stmt|;
name|u32
name|ttl
decl_stmt|;
name|u32
name|err
decl_stmt|;
name|evdns_callback_type
name|user_callback
decl_stmt|;
name|struct
name|reply
name|reply
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|reply_run_callback
parameter_list|(
name|struct
name|event_callback
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|user_pointer
parameter_list|)
block|{
name|struct
name|deferred_reply_callback
modifier|*
name|cb
init|=
name|EVUTIL_UPCAST
argument_list|(
name|d
argument_list|,
expr|struct
name|deferred_reply_callback
argument_list|,
name|deferred
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cb
operator|->
name|request_type
condition|)
block|{
case|case
name|TYPE_A
case|:
if|if
condition|(
name|cb
operator|->
name|have_reply
condition|)
name|cb
operator|->
name|user_callback
argument_list|(
name|DNS_ERR_NONE
argument_list|,
name|DNS_IPv4_A
argument_list|,
name|cb
operator|->
name|reply
operator|.
name|data
operator|.
name|a
operator|.
name|addrcount
argument_list|,
name|cb
operator|->
name|ttl
argument_list|,
name|cb
operator|->
name|reply
operator|.
name|data
operator|.
name|a
operator|.
name|addresses
argument_list|,
name|user_pointer
argument_list|)
expr_stmt|;
else|else
name|cb
operator|->
name|user_callback
argument_list|(
name|cb
operator|->
name|err
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cb
operator|->
name|ttl
argument_list|,
name|NULL
argument_list|,
name|user_pointer
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_PTR
case|:
if|if
condition|(
name|cb
operator|->
name|have_reply
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|cb
operator|->
name|reply
operator|.
name|data
operator|.
name|ptr
operator|.
name|name
decl_stmt|;
name|cb
operator|->
name|user_callback
argument_list|(
name|DNS_ERR_NONE
argument_list|,
name|DNS_PTR
argument_list|,
literal|1
argument_list|,
name|cb
operator|->
name|ttl
argument_list|,
operator|&
name|name
argument_list|,
name|user_pointer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|user_callback
argument_list|(
name|cb
operator|->
name|err
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cb
operator|->
name|ttl
argument_list|,
name|NULL
argument_list|,
name|user_pointer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_AAAA
case|:
if|if
condition|(
name|cb
operator|->
name|have_reply
condition|)
name|cb
operator|->
name|user_callback
argument_list|(
name|DNS_ERR_NONE
argument_list|,
name|DNS_IPv6_AAAA
argument_list|,
name|cb
operator|->
name|reply
operator|.
name|data
operator|.
name|aaaa
operator|.
name|addrcount
argument_list|,
name|cb
operator|->
name|ttl
argument_list|,
name|cb
operator|->
name|reply
operator|.
name|data
operator|.
name|aaaa
operator|.
name|addresses
argument_list|,
name|user_pointer
argument_list|)
expr_stmt|;
else|else
name|cb
operator|->
name|user_callback
argument_list|(
name|cb
operator|->
name|err
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cb
operator|->
name|ttl
argument_list|,
name|NULL
argument_list|,
name|user_pointer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|EVUTIL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|handle
operator|&&
name|cb
operator|->
name|handle
operator|->
name|pending_cb
condition|)
block|{
name|mm_free
argument_list|(
name|cb
operator|->
name|handle
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reply_schedule_callback
parameter_list|(
name|struct
name|request
modifier|*
specifier|const
name|req
parameter_list|,
name|u32
name|ttl
parameter_list|,
name|u32
name|err
parameter_list|,
name|struct
name|reply
modifier|*
name|reply
parameter_list|)
block|{
name|struct
name|deferred_reply_callback
modifier|*
name|d
init|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: Couldn't allocate space for deferred callback."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT_LOCKED
argument_list|(
name|req
operator|->
name|base
argument_list|)
expr_stmt|;
name|d
operator|->
name|request_type
operator|=
name|req
operator|->
name|request_type
expr_stmt|;
name|d
operator|->
name|user_callback
operator|=
name|req
operator|->
name|user_callback
expr_stmt|;
name|d
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
name|d
operator|->
name|err
operator|=
name|err
expr_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
name|d
operator|->
name|have_reply
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|d
operator|->
name|reply
argument_list|,
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reply
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|->
name|handle
condition|)
block|{
name|req
operator|->
name|handle
operator|->
name|pending_cb
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|handle
operator|=
name|req
operator|->
name|handle
expr_stmt|;
block|}
name|event_deferred_cb_init_
argument_list|(
operator|&
name|d
operator|->
name|deferred
argument_list|,
name|event_get_priority
argument_list|(
operator|&
name|req
operator|->
name|timeout_event
argument_list|)
argument_list|,
name|reply_run_callback
argument_list|,
name|req
operator|->
name|user_pointer
argument_list|)
expr_stmt|;
name|event_deferred_cb_schedule_
argument_list|(
name|req
operator|->
name|base
operator|->
name|event_base
argument_list|,
operator|&
name|d
operator|->
name|deferred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* this processes a parsed reply packet */
end_comment

begin_function
specifier|static
name|void
name|reply_handle
parameter_list|(
name|struct
name|request
modifier|*
specifier|const
name|req
parameter_list|,
name|u16
name|flags
parameter_list|,
name|u32
name|ttl
parameter_list|,
name|struct
name|reply
modifier|*
name|reply
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
name|addrbuf
index|[
literal|128
index|]
decl_stmt|;
specifier|static
specifier|const
name|int
name|error_codes
index|[]
init|=
block|{
name|DNS_ERR_FORMAT
block|,
name|DNS_ERR_SERVERFAILED
block|,
name|DNS_ERR_NOTEXIST
block|,
name|DNS_ERR_NOTIMPL
block|,
name|DNS_ERR_REFUSED
block|}
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|req
operator|->
name|base
argument_list|)
expr_stmt|;
name|ASSERT_VALID_REQUEST
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x020f
operator|||
operator|!
name|reply
operator|||
operator|!
name|reply
operator|->
name|have_answer
condition|)
block|{
comment|/* there was an error */
if|if
condition|(
name|flags
operator|&
literal|0x0200
condition|)
block|{
name|error
operator|=
name|DNS_ERR_TRUNCATED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
literal|0x000f
condition|)
block|{
name|u16
name|error_code
init|=
operator|(
name|flags
operator|&
literal|0x000f
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|error_code
operator|>
literal|4
condition|)
block|{
name|error
operator|=
name|DNS_ERR_UNKNOWN
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|error_codes
index|[
name|error_code
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reply
operator|&&
operator|!
name|reply
operator|->
name|have_answer
condition|)
block|{
name|error
operator|=
name|DNS_ERR_NODATA
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|DNS_ERR_UNKNOWN
expr_stmt|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|DNS_ERR_NOTIMPL
case|:
case|case
name|DNS_ERR_REFUSED
case|:
comment|/* we regard these errors as marking a bad nameserver */
if|if
condition|(
name|req
operator|->
name|reissue_count
operator|<
name|req
operator|->
name|base
operator|->
name|global_max_reissues
condition|)
block|{
name|char
name|msg
index|[
literal|64
index|]
decl_stmt|;
name|evutil_snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Bad response %d (%s)"
argument_list|,
name|error
argument_list|,
name|evdns_err_to_string
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|nameserver_failed
argument_list|(
name|req
operator|->
name|ns
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|request_reissue
argument_list|(
name|req
argument_list|)
condition|)
return|return;
block|}
break|break;
case|case
name|DNS_ERR_SERVERFAILED
case|:
comment|/* rcode 2 (servfailed) sometimes means "we 			 * are broken" and sometimes (with some binds) 			 * means "that request was very confusing." 			 * Treat this as a timeout, not a failure. 			 */
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Got a SERVERFAILED from nameserver"
literal|"at %s; will allow the request to time out."
argument_list|,
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|req
operator|->
name|ns
operator|->
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the timeout function */
name|evdns_request_timeout_callback
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* we got a good reply from the nameserver: it is up. */
if|if
condition|(
name|req
operator|->
name|handle
operator|==
name|req
operator|->
name|ns
operator|->
name|probe_request
condition|)
block|{
comment|/* Avoid double-free */
name|req
operator|->
name|ns
operator|->
name|probe_request
operator|=
name|NULL
expr_stmt|;
block|}
name|nameserver_up
argument_list|(
name|req
operator|->
name|ns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|->
name|handle
operator|->
name|search_state
operator|&&
name|req
operator|->
name|request_type
operator|!=
name|TYPE_PTR
condition|)
block|{
comment|/* if we have a list of domains to search in, 			 * try the next one */
if|if
condition|(
operator|!
name|search_try_next
argument_list|(
name|req
operator|->
name|handle
argument_list|)
condition|)
block|{
comment|/* a new request was issued so this 				 * request is finished and */
comment|/* the user callback will be made when 				 * that request (or a */
comment|/* child of it) finishes. */
return|return;
block|}
block|}
comment|/* all else failed. Pass the failure up */
name|reply_schedule_callback
argument_list|(
name|req
argument_list|,
name|ttl
argument_list|,
name|error
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|request_finished
argument_list|(
name|req
argument_list|,
operator|&
name|REQ_HEAD
argument_list|(
name|req
operator|->
name|base
argument_list|,
name|req
operator|->
name|trans_id
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* all ok, tell the user */
name|reply_schedule_callback
argument_list|(
name|req
argument_list|,
name|ttl
argument_list|,
literal|0
argument_list|,
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|handle
operator|==
name|req
operator|->
name|ns
operator|->
name|probe_request
condition|)
name|req
operator|->
name|ns
operator|->
name|probe_request
operator|=
name|NULL
expr_stmt|;
comment|/* Avoid double-free */
name|nameserver_up
argument_list|(
name|req
operator|->
name|ns
argument_list|)
expr_stmt|;
name|request_finished
argument_list|(
name|req
argument_list|,
operator|&
name|REQ_HEAD
argument_list|(
name|req
operator|->
name|base
argument_list|,
name|req
operator|->
name|trans_id
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|name_parse
parameter_list|(
name|u8
modifier|*
name|packet
parameter_list|,
name|int
name|length
parameter_list|,
name|int
modifier|*
name|idx
parameter_list|,
name|char
modifier|*
name|name_out
parameter_list|,
name|int
name|name_out_len
parameter_list|)
block|{
name|int
name|name_end
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|j
init|=
operator|*
name|idx
decl_stmt|;
name|int
name|ptr_count
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|GET32
parameter_list|(
name|x
parameter_list|)
value|do { if (j + 4> length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)
define|#
directive|define
name|GET16
parameter_list|(
name|x
parameter_list|)
value|do { if (j + 2> length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)
define|#
directive|define
name|GET8
parameter_list|(
name|x
parameter_list|)
value|do { if (j>= length) goto err; x = packet[j++]; } while (0)
name|char
modifier|*
name|cp
init|=
name|name_out
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|end
init|=
name|name_out
operator|+
name|name_out_len
decl_stmt|;
comment|/* Normally, names are a series of length prefixed strings terminated */
comment|/* with a length of 0 (the lengths are u8's< 63). */
comment|/* However, the length can start with a pair of 1 bits and that */
comment|/* means that the next 14 bits are a pointer within the current */
comment|/* packet. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|u8
name|label_len
decl_stmt|;
if|if
condition|(
name|j
operator|>=
name|length
condition|)
return|return
operator|-
literal|1
return|;
name|GET8
argument_list|(
name|label_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|label_len
condition|)
break|break;
if|if
condition|(
name|label_len
operator|&
literal|0xc0
condition|)
block|{
name|u8
name|ptr_low
decl_stmt|;
name|GET8
argument_list|(
name|ptr_low
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_end
operator|<
literal|0
condition|)
name|name_end
operator|=
name|j
expr_stmt|;
name|j
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|label_len
operator|&
literal|0x3f
operator|)
operator|<<
literal|8
operator|)
operator|+
name|ptr_low
expr_stmt|;
comment|/* Make sure that the target offset is in-bounds. */
if|if
condition|(
name|j
operator|<
literal|0
operator|||
name|j
operator|>=
name|length
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If we've jumped more times than there are characters in the 			 * message, we must have a loop. */
if|if
condition|(
operator|++
name|ptr_count
operator|>
name|length
condition|)
return|return
operator|-
literal|1
return|;
continue|continue;
block|}
if|if
condition|(
name|label_len
operator|>
literal|63
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|cp
operator|!=
name|name_out
condition|)
block|{
if|if
condition|(
name|cp
operator|+
literal|1
operator|>=
name|end
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|+
name|label_len
operator|>=
name|end
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|packet
operator|+
name|j
argument_list|,
name|label_len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|label_len
expr_stmt|;
name|j
operator|+=
name|label_len
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|>=
name|end
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|name_end
operator|<
literal|0
condition|)
operator|*
name|idx
operator|=
name|j
expr_stmt|;
else|else
operator|*
name|idx
operator|=
name|name_end
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* parses a raw request from a nameserver */
end_comment

begin_function
specifier|static
name|int
name|reply_parse
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|u8
modifier|*
name|packet
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|;
comment|/* index into packet */
name|u16
name|t_
decl_stmt|;
comment|/* used by the macros */
name|u32
name|t32_
decl_stmt|;
comment|/* used by the macros */
name|char
name|tmp_name
index|[
literal|256
index|]
decl_stmt|,
name|cmp_name
index|[
literal|256
index|]
decl_stmt|;
comment|/* used by the macros */
name|int
name|name_matches
init|=
literal|0
decl_stmt|;
name|u16
name|trans_id
decl_stmt|,
name|questions
decl_stmt|,
name|answers
decl_stmt|,
name|authority
decl_stmt|,
name|additional
decl_stmt|,
name|datalength
decl_stmt|;
name|u16
name|flags
init|=
literal|0
decl_stmt|;
name|u32
name|ttl
decl_stmt|,
name|ttl_r
init|=
literal|0xffffffff
decl_stmt|;
name|struct
name|reply
name|reply
decl_stmt|;
name|struct
name|request
modifier|*
name|req
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|trans_id
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|questions
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|answers
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|authority
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|additional
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|authority
expr_stmt|;
comment|/* suppress "unused variable" warnings. */
operator|(
name|void
operator|)
name|additional
expr_stmt|;
comment|/* suppress "unused variable" warnings. */
name|req
operator|=
name|request_find_from_trans_id
argument_list|(
name|base
argument_list|,
name|trans_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
return|return
operator|-
literal|1
return|;
name|EVUTIL_ASSERT
argument_list|(
name|req
operator|->
name|base
operator|==
name|base
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If it's not an answer, it doesn't correspond to any request. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
literal|0x8000
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* must be an answer */
if|if
condition|(
operator|(
name|flags
operator|&
literal|0x020f
operator|)
operator|&&
operator|(
name|flags
operator|&
literal|0x020f
operator|)
operator|!=
name|DNS_ERR_NOTEXIST
condition|)
block|{
comment|/* there was an error and it's not NXDOMAIN */
goto|goto
name|err
goto|;
block|}
comment|/* if (!answers) return; */
comment|/* must have an answer of some form */
comment|/* This macro skips a name in the DNS reply. */
define|#
directive|define
name|SKIP_NAME
define|\
value|do { tmp_name[0] = '\0';				\ 		if (name_parse(packet, length,&j, tmp_name,	\ 			sizeof(tmp_name))<0)			\ 			goto err;				\ 	} while (0)
define|#
directive|define
name|TEST_NAME
define|\
value|do { tmp_name[0] = '\0';					\ 		cmp_name[0] = '\0';					\ 		k = j;							\ 		if (name_parse(packet, length,&j, tmp_name,		\ 			sizeof(tmp_name))<0)				\ 			goto err;					\ 		if (name_parse(req->request, req->request_len,&k,	\ 			cmp_name, sizeof(cmp_name))<0)			\ 			goto err;					\ 		if (base->global_randomize_case) {			\ 			if (strcmp(tmp_name, cmp_name) == 0)		\ 				name_matches = 1;			\ 		} else {						\ 			if (evutil_ascii_strcasecmp(tmp_name, cmp_name) == 0) \ 				name_matches = 1;			\ 		}							\ 	} while (0)
name|reply
operator|.
name|type
operator|=
name|req
operator|->
name|request_type
expr_stmt|;
comment|/* skip over each question in the reply */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|questions
condition|;
operator|++
name|i
control|)
block|{
comment|/* the question looks like 		 *<label:name><u16:type><u16:class> 		 */
name|TEST_NAME
expr_stmt|;
name|j
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|length
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|name_matches
condition|)
goto|goto
name|err
goto|;
comment|/* now we have the answer section which looks like 	 *<label:name><u16:type><u16:class><u32:ttl><u16:len><data...> 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|answers
condition|;
operator|++
name|i
control|)
block|{
name|u16
name|type
decl_stmt|,
name|class
decl_stmt|;
name|SKIP_NAME
expr_stmt|;
name|GET16
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|GET32
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|datalength
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_A
operator|&&
name|class
operator|==
name|CLASS_INET
condition|)
block|{
name|int
name|addrcount
decl_stmt|,
name|addrtocopy
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|request_type
operator|!=
name|TYPE_A
condition|)
block|{
name|j
operator|+=
name|datalength
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|datalength
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
comment|/* not an even number of As. */
goto|goto
name|err
goto|;
name|addrcount
operator|=
name|datalength
operator|>>
literal|2
expr_stmt|;
name|addrtocopy
operator|=
name|MIN
argument_list|(
name|MAX_V4_ADDRS
operator|-
name|reply
operator|.
name|data
operator|.
name|a
operator|.
name|addrcount
argument_list|,
operator|(
name|unsigned
operator|)
name|addrcount
argument_list|)
expr_stmt|;
name|ttl_r
operator|=
name|MIN
argument_list|(
name|ttl_r
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
comment|/* we only bother with the first four addresses. */
if|if
condition|(
name|j
operator|+
literal|4
operator|*
name|addrtocopy
operator|>
name|length
condition|)
goto|goto
name|err
goto|;
name|memcpy
argument_list|(
operator|&
name|reply
operator|.
name|data
operator|.
name|a
operator|.
name|addresses
index|[
name|reply
operator|.
name|data
operator|.
name|a
operator|.
name|addrcount
index|]
argument_list|,
name|packet
operator|+
name|j
argument_list|,
literal|4
operator|*
name|addrtocopy
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|4
operator|*
name|addrtocopy
expr_stmt|;
name|reply
operator|.
name|data
operator|.
name|a
operator|.
name|addrcount
operator|+=
name|addrtocopy
expr_stmt|;
name|reply
operator|.
name|have_answer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reply
operator|.
name|data
operator|.
name|a
operator|.
name|addrcount
operator|==
name|MAX_V4_ADDRS
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TYPE_PTR
operator|&&
name|class
operator|==
name|CLASS_INET
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|request_type
operator|!=
name|TYPE_PTR
condition|)
block|{
name|j
operator|+=
name|datalength
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|name_parse
argument_list|(
name|packet
argument_list|,
name|length
argument_list|,
operator|&
name|j
argument_list|,
name|reply
operator|.
name|data
operator|.
name|ptr
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
operator|.
name|data
operator|.
name|ptr
operator|.
name|name
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|ttl_r
operator|=
name|MIN
argument_list|(
name|ttl_r
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|reply
operator|.
name|have_answer
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TYPE_CNAME
condition|)
block|{
name|char
name|cname
index|[
name|HOST_NAME_MAX
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|req
operator|->
name|put_cname_in_ptr
operator|||
operator|*
name|req
operator|->
name|put_cname_in_ptr
condition|)
block|{
name|j
operator|+=
name|datalength
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|name_parse
argument_list|(
name|packet
argument_list|,
name|length
argument_list|,
operator|&
name|j
argument_list|,
name|cname
argument_list|,
sizeof|sizeof
argument_list|(
name|cname
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
operator|*
name|req
operator|->
name|put_cname_in_ptr
operator|=
name|mm_strdup
argument_list|(
name|cname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TYPE_AAAA
operator|&&
name|class
operator|==
name|CLASS_INET
condition|)
block|{
name|int
name|addrcount
decl_stmt|,
name|addrtocopy
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|request_type
operator|!=
name|TYPE_AAAA
condition|)
block|{
name|j
operator|+=
name|datalength
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|datalength
operator|&
literal|15
operator|)
operator|!=
literal|0
condition|)
comment|/* not an even number of AAAAs. */
goto|goto
name|err
goto|;
name|addrcount
operator|=
name|datalength
operator|>>
literal|4
expr_stmt|;
comment|/* each address is 16 bytes long */
name|addrtocopy
operator|=
name|MIN
argument_list|(
name|MAX_V6_ADDRS
operator|-
name|reply
operator|.
name|data
operator|.
name|aaaa
operator|.
name|addrcount
argument_list|,
operator|(
name|unsigned
operator|)
name|addrcount
argument_list|)
expr_stmt|;
name|ttl_r
operator|=
name|MIN
argument_list|(
name|ttl_r
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
comment|/* we only bother with the first four addresses. */
if|if
condition|(
name|j
operator|+
literal|16
operator|*
name|addrtocopy
operator|>
name|length
condition|)
goto|goto
name|err
goto|;
name|memcpy
argument_list|(
operator|&
name|reply
operator|.
name|data
operator|.
name|aaaa
operator|.
name|addresses
index|[
name|reply
operator|.
name|data
operator|.
name|aaaa
operator|.
name|addrcount
index|]
argument_list|,
name|packet
operator|+
name|j
argument_list|,
literal|16
operator|*
name|addrtocopy
argument_list|)
expr_stmt|;
name|reply
operator|.
name|data
operator|.
name|aaaa
operator|.
name|addrcount
operator|+=
name|addrtocopy
expr_stmt|;
name|j
operator|+=
literal|16
operator|*
name|addrtocopy
expr_stmt|;
name|reply
operator|.
name|have_answer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reply
operator|.
name|data
operator|.
name|aaaa
operator|.
name|addrcount
operator|==
name|MAX_V6_ADDRS
condition|)
break|break;
block|}
else|else
block|{
comment|/* skip over any other type of resource */
name|j
operator|+=
name|datalength
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|reply
operator|.
name|have_answer
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|authority
condition|;
operator|++
name|i
control|)
block|{
name|u16
name|type
decl_stmt|,
name|class
decl_stmt|;
name|SKIP_NAME
expr_stmt|;
name|GET16
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|GET32
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|datalength
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_SOA
operator|&&
name|class
operator|==
name|CLASS_INET
condition|)
block|{
name|u32
name|serial
decl_stmt|,
name|refresh
decl_stmt|,
name|retry
decl_stmt|,
name|expire
decl_stmt|,
name|minimum
decl_stmt|;
name|SKIP_NAME
expr_stmt|;
name|SKIP_NAME
expr_stmt|;
name|GET32
argument_list|(
name|serial
argument_list|)
expr_stmt|;
name|GET32
argument_list|(
name|refresh
argument_list|)
expr_stmt|;
name|GET32
argument_list|(
name|retry
argument_list|)
expr_stmt|;
name|GET32
argument_list|(
name|expire
argument_list|)
expr_stmt|;
name|GET32
argument_list|(
name|minimum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|expire
expr_stmt|;
operator|(
name|void
operator|)
name|retry
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
expr_stmt|;
operator|(
name|void
operator|)
name|serial
expr_stmt|;
name|ttl_r
operator|=
name|MIN
argument_list|(
name|ttl_r
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|ttl_r
operator|=
name|MIN
argument_list|(
name|ttl_r
argument_list|,
name|minimum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* skip over any other type of resource */
name|j
operator|+=
name|datalength
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ttl_r
operator|==
literal|0xffffffff
condition|)
name|ttl_r
operator|=
literal|0
expr_stmt|;
name|reply_handle
argument_list|(
name|req
argument_list|,
name|flags
argument_list|,
name|ttl_r
argument_list|,
operator|&
name|reply
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
if|if
condition|(
name|req
condition|)
name|reply_handle
argument_list|(
name|req
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse a raw request (packet,length) sent to a nameserver port (port) from */
end_comment

begin_comment
comment|/* a DNS client (addr,addrlen), and if it's well-formed, call the corresponding */
end_comment

begin_comment
comment|/* callback. */
end_comment

begin_function
specifier|static
name|int
name|request_parse
parameter_list|(
name|u8
modifier|*
name|packet
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|evdns_server_port
modifier|*
name|port
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|ev_socklen_t
name|addrlen
parameter_list|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
comment|/* index into packet */
name|u16
name|t_
decl_stmt|;
comment|/* used by the macros */
name|char
name|tmp_name
index|[
literal|256
index|]
decl_stmt|;
comment|/* used by the macros */
name|int
name|i
decl_stmt|;
name|u16
name|trans_id
decl_stmt|,
name|flags
decl_stmt|,
name|questions
decl_stmt|,
name|answers
decl_stmt|,
name|authority
decl_stmt|,
name|additional
decl_stmt|;
name|struct
name|server_request
modifier|*
name|server_req
init|=
name|NULL
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|port
argument_list|)
expr_stmt|;
comment|/* Get the header fields */
name|GET16
argument_list|(
name|trans_id
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|questions
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|answers
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|authority
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|additional
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|answers
expr_stmt|;
operator|(
name|void
operator|)
name|additional
expr_stmt|;
operator|(
name|void
operator|)
name|authority
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x8000
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Must not be an answer. */
name|flags
operator|&=
literal|0x0110
expr_stmt|;
comment|/* Only RD and CD get preserved. */
name|server_req
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|server_request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_req
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|server_req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|server_request
argument_list|)
argument_list|)
expr_stmt|;
name|server_req
operator|->
name|trans_id
operator|=
name|trans_id
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|server_req
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|server_req
operator|->
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|server_req
operator|->
name|base
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|server_req
operator|->
name|base
operator|.
name|nquestions
operator|=
literal|0
expr_stmt|;
name|server_req
operator|->
name|base
operator|.
name|questions
operator|=
name|mm_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evdns_server_question
operator|*
argument_list|)
argument_list|,
name|questions
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_req
operator|->
name|base
operator|.
name|questions
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|questions
condition|;
operator|++
name|i
control|)
block|{
name|u16
name|type
decl_stmt|,
name|class
decl_stmt|;
name|struct
name|evdns_server_question
modifier|*
name|q
decl_stmt|;
name|int
name|namelen
decl_stmt|;
if|if
condition|(
name|name_parse
argument_list|(
name|packet
argument_list|,
name|length
argument_list|,
operator|&
name|j
argument_list|,
name|tmp_name
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_name
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|GET16
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|GET16
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|namelen
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|q
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evdns_server_question
argument_list|)
operator|+
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
goto|goto
name|err
goto|;
name|q
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|q
operator|->
name|dns_question_class
operator|=
name|class
expr_stmt|;
name|memcpy
argument_list|(
name|q
operator|->
name|name
argument_list|,
name|tmp_name
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|server_req
operator|->
name|base
operator|.
name|questions
index|[
name|server_req
operator|->
name|base
operator|.
name|nquestions
operator|++
index|]
operator|=
name|q
expr_stmt|;
block|}
comment|/* Ignore answers, authority, and additional. */
name|server_req
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|port
operator|->
name|refcnt
operator|++
expr_stmt|;
comment|/* Only standard queries are supported. */
if|if
condition|(
name|flags
operator|&
literal|0x7800
condition|)
block|{
name|evdns_server_request_respond
argument_list|(
operator|&
operator|(
name|server_req
operator|->
name|base
operator|)
argument_list|,
name|DNS_ERR_NOTIMPL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|port
operator|->
name|user_callback
argument_list|(
operator|&
operator|(
name|server_req
operator|->
name|base
operator|)
argument_list|,
name|port
operator|->
name|user_data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
if|if
condition|(
name|server_req
condition|)
block|{
if|if
condition|(
name|server_req
operator|->
name|base
operator|.
name|questions
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|server_req
operator|->
name|base
operator|.
name|nquestions
condition|;
operator|++
name|i
control|)
name|mm_free
argument_list|(
name|server_req
operator|->
name|base
operator|.
name|questions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|server_req
operator|->
name|base
operator|.
name|questions
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|server_req
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|SKIP_NAME
undef|#
directive|undef
name|GET32
undef|#
directive|undef
name|GET16
undef|#
directive|undef
name|GET8
block|}
end_function

begin_function
name|void
name|evdns_set_transaction_id_fn
parameter_list|(
name|ev_uint16_t
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|evdns_set_random_bytes_fn
parameter_list|(
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Try to choose a strong transaction id which isn't already in flight */
end_comment

begin_function
specifier|static
name|u16
name|transaction_id_pick
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|u16
name|trans_id
decl_stmt|;
name|evutil_secure_rng_get_bytes
argument_list|(
operator|&
name|trans_id
argument_list|,
sizeof|sizeof
argument_list|(
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans_id
operator|==
literal|0xffff
condition|)
continue|continue;
comment|/* now check to see if that id is already inflight */
if|if
condition|(
name|request_find_from_trans_id
argument_list|(
name|base
argument_list|,
name|trans_id
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|trans_id
return|;
block|}
block|}
end_function

begin_comment
comment|/* choose a namesever to use. This function will try to ignore */
end_comment

begin_comment
comment|/* nameservers which we think are down and load balance across the rest */
end_comment

begin_comment
comment|/* by updating the server_head global each time. */
end_comment

begin_function
specifier|static
name|struct
name|nameserver
modifier|*
name|nameserver_pick
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|nameserver
modifier|*
name|started_at
init|=
name|base
operator|->
name|server_head
decl_stmt|,
modifier|*
name|picked
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|server_head
condition|)
return|return
name|NULL
return|;
comment|/* if we don't have any good nameservers then there's no */
comment|/* point in trying to find one. */
if|if
condition|(
operator|!
name|base
operator|->
name|global_good_nameservers
condition|)
block|{
name|base
operator|->
name|server_head
operator|=
name|base
operator|->
name|server_head
operator|->
name|next
expr_stmt|;
return|return
name|base
operator|->
name|server_head
return|;
block|}
comment|/* remember that nameservers are in a circular list */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|base
operator|->
name|server_head
operator|->
name|state
condition|)
block|{
comment|/* we think this server is currently good */
name|picked
operator|=
name|base
operator|->
name|server_head
expr_stmt|;
name|base
operator|->
name|server_head
operator|=
name|base
operator|->
name|server_head
operator|->
name|next
expr_stmt|;
return|return
name|picked
return|;
block|}
name|base
operator|->
name|server_head
operator|=
name|base
operator|->
name|server_head
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|server_head
operator|==
name|started_at
condition|)
block|{
comment|/* all the nameservers seem to be down */
comment|/* so we just return this one and hope for the */
comment|/* best */
name|EVUTIL_ASSERT
argument_list|(
name|base
operator|->
name|global_good_nameservers
operator|==
literal|0
argument_list|)
expr_stmt|;
name|picked
operator|=
name|base
operator|->
name|server_head
expr_stmt|;
name|base
operator|->
name|server_head
operator|=
name|base
operator|->
name|server_head
operator|->
name|next
expr_stmt|;
return|return
name|picked
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* this is called when a namesever socket is ready for reading */
end_comment

begin_function
specifier|static
name|void
name|nameserver_read
parameter_list|(
name|struct
name|nameserver
modifier|*
name|ns
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|ev_socklen_t
name|addrlen
init|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
decl_stmt|;
name|u8
name|packet
index|[
literal|1500
index|]
decl_stmt|;
name|char
name|addrbuf
index|[
literal|128
index|]
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|int
name|r
init|=
name|recvfrom
argument_list|(
name|ns
operator|->
name|socket
argument_list|,
operator|(
name|void
operator|*
operator|)
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|addrlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|int
name|err
init|=
name|evutil_socket_geterror
argument_list|(
name|ns
operator|->
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|err
argument_list|)
condition|)
return|return;
name|nameserver_failed
argument_list|(
name|ns
argument_list|,
name|evutil_socket_error_to_string
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|evutil_sockaddr_cmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ns
operator|->
name|address
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Address mismatch on received "
literal|"DNS packet.  Apparent source was %s"
argument_list|,
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ns
operator|->
name|timedout
operator|=
literal|0
expr_stmt|;
name|reply_parse
argument_list|(
name|ns
operator|->
name|base
argument_list|,
name|packet
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read a packet from a DNS client on a server port s, parse it, and */
end_comment

begin_comment
comment|/* act accordingly. */
end_comment

begin_function
specifier|static
name|void
name|server_port_read
parameter_list|(
name|struct
name|evdns_server_port
modifier|*
name|s
parameter_list|)
block|{
name|u8
name|packet
index|[
literal|1500
index|]
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|ev_socklen_t
name|addrlen
decl_stmt|;
name|int
name|r
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
name|r
operator|=
name|recvfrom
argument_list|(
name|s
operator|->
name|socket
argument_list|,
operator|(
name|void
operator|*
operator|)
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|int
name|err
init|=
name|evutil_socket_geterror
argument_list|(
name|s
operator|->
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|err
argument_list|)
condition|)
return|return;
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Error %s (%d) while reading request."
argument_list|,
name|evutil_socket_error_to_string
argument_list|(
name|err
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
name|request_parse
argument_list|(
name|packet
argument_list|,
name|r
argument_list|,
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to write all pending replies on a given DNS server port. */
end_comment

begin_function
specifier|static
name|void
name|server_port_flush
parameter_list|(
name|struct
name|evdns_server_port
modifier|*
name|port
parameter_list|)
block|{
name|struct
name|server_request
modifier|*
name|req
init|=
name|port
operator|->
name|pending_replies
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|port
argument_list|)
expr_stmt|;
while|while
condition|(
name|req
condition|)
block|{
name|int
name|r
init|=
name|sendto
argument_list|(
name|port
operator|->
name|socket
argument_list|,
name|req
operator|->
name|response
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|response_len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|req
operator|->
name|addr
argument_list|,
operator|(
name|ev_socklen_t
operator|)
name|req
operator|->
name|addrlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|int
name|err
init|=
name|evutil_socket_geterror
argument_list|(
name|port
operator|->
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|err
argument_list|)
condition|)
return|return;
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Error %s (%d) while writing response to port; dropping"
argument_list|,
name|evutil_socket_error_to_string
argument_list|(
name|err
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|server_request_free
argument_list|(
name|req
argument_list|)
condition|)
block|{
comment|/* we released the last reference to req->port. */
return|return;
block|}
else|else
block|{
name|EVUTIL_ASSERT
argument_list|(
name|req
operator|!=
name|port
operator|->
name|pending_replies
argument_list|)
expr_stmt|;
name|req
operator|=
name|port
operator|->
name|pending_replies
expr_stmt|;
block|}
block|}
comment|/* We have no more pending requests; stop listening for 'writeable' events. */
operator|(
name|void
operator|)
name|event_del
argument_list|(
operator|&
name|port
operator|->
name|event
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|port
operator|->
name|event
argument_list|,
name|port
operator|->
name|event_base
argument_list|,
name|port
operator|->
name|socket
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|server_port_ready_callback
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|port
operator|->
name|event
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Error from libevent when adding event for DNS server."
argument_list|)
expr_stmt|;
comment|/* ???? Do more? */
block|}
block|}
end_function

begin_comment
comment|/* set if we are waiting for the ability to write to this server. */
end_comment

begin_comment
comment|/* if waiting is true then we ask libevent for EV_WRITE events, otherwise */
end_comment

begin_comment
comment|/* we stop these events. */
end_comment

begin_function
specifier|static
name|void
name|nameserver_write_waiting
parameter_list|(
name|struct
name|nameserver
modifier|*
name|ns
parameter_list|,
name|char
name|waiting
parameter_list|)
block|{
name|ASSERT_LOCKED
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|write_waiting
operator|==
name|waiting
condition|)
return|return;
name|ns
operator|->
name|write_waiting
operator|=
name|waiting
expr_stmt|;
operator|(
name|void
operator|)
name|event_del
argument_list|(
operator|&
name|ns
operator|->
name|event
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|ns
operator|->
name|event
argument_list|,
name|ns
operator|->
name|base
operator|->
name|event_base
argument_list|,
name|ns
operator|->
name|socket
argument_list|,
name|EV_READ
operator||
operator|(
name|waiting
condition|?
name|EV_WRITE
else|:
literal|0
operator|)
operator||
name|EV_PERSIST
argument_list|,
name|nameserver_ready_callback
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ns
operator|->
name|event
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|addrbuf
index|[
literal|128
index|]
decl_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Error from libevent when adding event for %s"
argument_list|,
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ns
operator|->
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ???? Do more? */
block|}
block|}
end_function

begin_comment
comment|/* a callback function. Called by libevent when the kernel says that */
end_comment

begin_comment
comment|/* a nameserver socket is ready for writing or reading */
end_comment

begin_function
specifier|static
name|void
name|nameserver_ready_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nameserver
modifier|*
name|ns
init|=
operator|(
expr|struct
name|nameserver
operator|*
operator|)
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|EV_WRITE
condition|)
block|{
name|ns
operator|->
name|choked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|evdns_transmit
argument_list|(
name|ns
operator|->
name|base
argument_list|)
condition|)
block|{
name|nameserver_write_waiting
argument_list|(
name|ns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|events
operator|&
name|EV_READ
condition|)
block|{
name|nameserver_read
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* a callback function. Called by libevent when the kernel says that */
end_comment

begin_comment
comment|/* a server socket is ready for writing or reading. */
end_comment

begin_function
specifier|static
name|void
name|server_port_ready_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evdns_server_port
modifier|*
name|port
init|=
operator|(
expr|struct
name|evdns_server_port
operator|*
operator|)
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|EV_WRITE
condition|)
block|{
name|port
operator|->
name|choked
operator|=
literal|0
expr_stmt|;
name|server_port_flush
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|EV_READ
condition|)
block|{
name|server_port_read
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is an inefficient representation; only use it via the dnslabel_table_*  * functions, so that is can be safely replaced with something smarter later. */
end_comment

begin_define
define|#
directive|define
name|MAX_LABELS
value|128
end_define

begin_comment
comment|/* Structures used to implement name compression */
end_comment

begin_struct
struct|struct
name|dnslabel_entry
block|{
name|char
modifier|*
name|v
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dnslabel_table
block|{
name|int
name|n_labels
decl_stmt|;
comment|/* number of current entries */
comment|/* map from name to position in message */
name|struct
name|dnslabel_entry
name|labels
index|[
name|MAX_LABELS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Initialize dnslabel_table. */
end_comment

begin_function
specifier|static
name|void
name|dnslabel_table_init
parameter_list|(
name|struct
name|dnslabel_table
modifier|*
name|table
parameter_list|)
block|{
name|table
operator|->
name|n_labels
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all storage held by table, but not the table itself. */
end_comment

begin_function
specifier|static
name|void
name|dnslabel_clear
parameter_list|(
name|struct
name|dnslabel_table
modifier|*
name|table
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|n_labels
condition|;
operator|++
name|i
control|)
name|mm_free
argument_list|(
name|table
operator|->
name|labels
index|[
name|i
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
name|table
operator|->
name|n_labels
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return the position of the label in the current message, or -1 if the label */
end_comment

begin_comment
comment|/* hasn't been used yet. */
end_comment

begin_function
specifier|static
name|int
name|dnslabel_table_get_pos
parameter_list|(
specifier|const
name|struct
name|dnslabel_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|n_labels
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|label
argument_list|,
name|table
operator|->
name|labels
index|[
name|i
index|]
operator|.
name|v
argument_list|)
condition|)
return|return
name|table
operator|->
name|labels
index|[
name|i
index|]
operator|.
name|pos
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* remember that we've used the label at position pos */
end_comment

begin_function
specifier|static
name|int
name|dnslabel_table_add
parameter_list|(
name|struct
name|dnslabel_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|off_t
name|pos
parameter_list|)
block|{
name|char
modifier|*
name|v
decl_stmt|;
name|int
name|p
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|n_labels
operator|==
name|MAX_LABELS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|v
operator|=
name|mm_strdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|table
operator|->
name|n_labels
operator|++
expr_stmt|;
name|table
operator|->
name|labels
index|[
name|p
index|]
operator|.
name|v
operator|=
name|v
expr_stmt|;
name|table
operator|->
name|labels
index|[
name|p
index|]
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Converts a string to a length-prefixed set of DNS labels, starting */
end_comment

begin_comment
comment|/* at buf[j]. name and buf must not overlap. name_len should be the length */
end_comment

begin_comment
comment|/* of name.	 table is optional, and is used for compression. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* Input: abc.def */
end_comment

begin_comment
comment|/* Output:<3>abc<3>def<0> */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* Returns the first index after the encoded name, or negative on error. */
end_comment

begin_comment
comment|/*	 -1	 label was> 63 bytes */
end_comment

begin_comment
comment|/*	 -2	 name too long to fit in buffer. */
end_comment

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|off_t
name|dnsname_to_labels
parameter_list|(
name|u8
modifier|*
specifier|const
name|buf
parameter_list|,
name|size_t
name|buf_len
parameter_list|,
name|off_t
name|j
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|size_t
name|name_len
parameter_list|,
name|struct
name|dnslabel_table
modifier|*
name|table
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|name
operator|+
name|name_len
decl_stmt|;
name|int
name|ref
init|=
literal|0
decl_stmt|;
name|u16
name|t_
decl_stmt|;
define|#
directive|define
name|APPEND16
parameter_list|(
name|x
parameter_list|)
value|do {						\ 		if (j + 2> (off_t)buf_len)				\ 			goto overflow;					\ 		t_ = htons(x);						\ 		memcpy(buf + j,&t_, 2);				\ 		j += 2;							\ 	} while (0)
define|#
directive|define
name|APPEND32
parameter_list|(
name|x
parameter_list|)
value|do {						\ 		if (j + 4> (off_t)buf_len)				\ 			goto overflow;					\ 		t32_ = htonl(x);					\ 		memcpy(buf + j,&t32_, 4);				\ 		j += 4;							\ 	} while (0)
if|if
condition|(
name|name_len
operator|>
literal|255
condition|)
return|return
operator|-
literal|2
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|start
init|=
name|name
decl_stmt|;
if|if
condition|(
name|table
operator|&&
operator|(
name|ref
operator|=
name|dnslabel_table_get_pos
argument_list|(
name|table
argument_list|,
name|name
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|APPEND16
argument_list|(
name|ref
operator||
literal|0xc000
argument_list|)
expr_stmt|;
return|return
name|j
return|;
block|}
name|name
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
specifier|const
name|size_t
name|label_len
init|=
name|end
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|label_len
operator|>
literal|63
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|j
operator|+
name|label_len
operator|+
literal|1
argument_list|)
operator|>
name|buf_len
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|table
condition|)
name|dnslabel_table_add
argument_list|(
name|table
argument_list|,
name|start
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|ev_uint8_t
operator|)
name|label_len
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|j
argument_list|,
name|start
argument_list|,
name|label_len
argument_list|)
expr_stmt|;
name|j
operator|+=
operator|(
name|int
operator|)
name|label_len
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* append length of the label. */
specifier|const
name|size_t
name|label_len
init|=
name|name
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|label_len
operator|>
literal|63
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|j
operator|+
name|label_len
operator|+
literal|1
argument_list|)
operator|>
name|buf_len
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|table
condition|)
name|dnslabel_table_add
argument_list|(
name|table
argument_list|,
name|start
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|ev_uint8_t
operator|)
name|label_len
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|j
argument_list|,
name|start
argument_list|,
name|label_len
argument_list|)
expr_stmt|;
name|j
operator|+=
operator|(
name|int
operator|)
name|label_len
expr_stmt|;
comment|/* hop over the '.' */
name|name
operator|++
expr_stmt|;
block|}
block|}
comment|/* the labels must be terminated by a 0. */
comment|/* It's possible that the name ended in a . */
comment|/* in which case the zero is already there */
if|if
condition|(
operator|!
name|j
operator|||
name|buf
index|[
name|j
operator|-
literal|1
index|]
condition|)
name|buf
index|[
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|j
return|;
name|overflow
label|:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finds the length of a dns request for a DNS name of the given */
end_comment

begin_comment
comment|/* length. The actual request may be smaller than the value returned */
end_comment

begin_comment
comment|/* here */
end_comment

begin_function
specifier|static
name|size_t
name|evdns_request_len
parameter_list|(
specifier|const
name|size_t
name|name_len
parameter_list|)
block|{
return|return
literal|96
operator|+
comment|/* length of the DNS standard header */
name|name_len
operator|+
literal|2
operator|+
literal|4
return|;
comment|/* space for the resource type */
block|}
end_function

begin_comment
comment|/* build a dns request packet into buf. buf should be at least as long */
end_comment

begin_comment
comment|/* as evdns_request_len told you it should be. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* Returns the amount of space used. Negative on error. */
end_comment

begin_function
specifier|static
name|int
name|evdns_request_data_build
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|name
parameter_list|,
specifier|const
name|size_t
name|name_len
parameter_list|,
specifier|const
name|u16
name|trans_id
parameter_list|,
specifier|const
name|u16
name|type
parameter_list|,
specifier|const
name|u16
name|class
parameter_list|,
name|u8
modifier|*
specifier|const
name|buf
parameter_list|,
name|size_t
name|buf_len
parameter_list|)
block|{
name|off_t
name|j
init|=
literal|0
decl_stmt|;
comment|/* current offset into buf */
name|u16
name|t_
decl_stmt|;
comment|/* used by the macros */
name|APPEND16
argument_list|(
name|trans_id
argument_list|)
expr_stmt|;
name|APPEND16
argument_list|(
literal|0x0100
argument_list|)
expr_stmt|;
comment|/* standard query, recusion needed */
name|APPEND16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* one question */
name|APPEND16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* no answers */
name|APPEND16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* no authority */
name|APPEND16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* no additional */
name|j
operator|=
name|dnsname_to_labels
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|j
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|j
return|;
block|}
name|APPEND16
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|APPEND16
argument_list|(
name|class
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|j
return|;
name|overflow
label|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|struct
name|evdns_server_port
modifier|*
name|evdns_add_server_port_with_base
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evutil_socket_t
name|socket
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_request_callback_fn_type
name|cb
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|struct
name|evdns_server_port
modifier|*
name|port
decl_stmt|;
if|if
condition|(
name|flags
condition|)
return|return
name|NULL
return|;
comment|/* flags not yet implemented */
if|if
condition|(
operator|!
operator|(
name|port
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evdns_server_port
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|port
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evdns_server_port
argument_list|)
argument_list|)
expr_stmt|;
name|port
operator|->
name|socket
operator|=
name|socket
expr_stmt|;
name|port
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|port
operator|->
name|choked
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|closing
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|user_callback
operator|=
name|cb
expr_stmt|;
name|port
operator|->
name|user_data
operator|=
name|user_data
expr_stmt|;
name|port
operator|->
name|pending_replies
operator|=
name|NULL
expr_stmt|;
name|port
operator|->
name|event_base
operator|=
name|base
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|port
operator|->
name|event
argument_list|,
name|port
operator|->
name|event_base
argument_list|,
name|port
operator|->
name|socket
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|server_port_ready_callback
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|port
operator|->
name|event
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|mm_free
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|port
operator|->
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
return|return
name|port
return|;
block|}
end_function

begin_function
name|struct
name|evdns_server_port
modifier|*
name|evdns_add_server_port
parameter_list|(
name|evutil_socket_t
name|socket
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_request_callback_fn_type
name|cb
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
return|return
name|evdns_add_server_port_with_base
argument_list|(
name|NULL
argument_list|,
name|socket
argument_list|,
name|flags
argument_list|,
name|cb
argument_list|,
name|user_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|void
name|evdns_close_server_port
parameter_list|(
name|struct
name|evdns_server_port
modifier|*
name|port
parameter_list|)
block|{
name|EVDNS_LOCK
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|port
operator|->
name|refcnt
operator|==
literal|0
condition|)
block|{
name|EVDNS_UNLOCK
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|server_port_free
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|port
operator|->
name|closing
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_server_request_add_reply
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req_
parameter_list|,
name|int
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|ttl
parameter_list|,
name|int
name|datalen
parameter_list|,
name|int
name|is_name
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|server_request
modifier|*
name|req
init|=
name|TO_SERVER_REQUEST
argument_list|(
name|req_
argument_list|)
decl_stmt|;
name|struct
name|server_reply_item
modifier|*
modifier|*
name|itemp
decl_stmt|,
modifier|*
name|item
decl_stmt|;
name|int
modifier|*
name|countp
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|EVDNS_LOCK
argument_list|(
name|req
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|response
condition|)
comment|/* have we already answered? */
goto|goto
name|done
goto|;
switch|switch
condition|(
name|section
condition|)
block|{
case|case
name|EVDNS_ANSWER_SECTION
case|:
name|itemp
operator|=
operator|&
name|req
operator|->
name|answer
expr_stmt|;
name|countp
operator|=
operator|&
name|req
operator|->
name|n_answer
expr_stmt|;
break|break;
case|case
name|EVDNS_AUTHORITY_SECTION
case|:
name|itemp
operator|=
operator|&
name|req
operator|->
name|authority
expr_stmt|;
name|countp
operator|=
operator|&
name|req
operator|->
name|n_authority
expr_stmt|;
break|break;
case|case
name|EVDNS_ADDITIONAL_SECTION
case|:
name|itemp
operator|=
operator|&
name|req
operator|->
name|additional
expr_stmt|;
name|countp
operator|=
operator|&
name|req
operator|->
name|n_additional
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
while|while
condition|(
operator|*
name|itemp
condition|)
block|{
name|itemp
operator|=
operator|&
operator|(
operator|(
operator|*
name|itemp
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
name|item
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|server_reply_item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
goto|goto
name|done
goto|;
name|item
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|item
operator|->
name|name
operator|=
name|mm_strdup
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|mm_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|item
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|item
operator|->
name|dns_question_class
operator|=
name|class
expr_stmt|;
name|item
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
name|item
operator|->
name|is_name
operator|=
name|is_name
operator|!=
literal|0
expr_stmt|;
name|item
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|is_name
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|item
operator|->
name|data
operator|=
name|mm_strdup
argument_list|(
name|data
argument_list|)
operator|)
condition|)
block|{
name|mm_free
argument_list|(
name|item
operator|->
name|name
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|item
operator|->
name|datalen
operator|=
operator|(
name|u16
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|item
operator|->
name|data
operator|=
name|mm_malloc
argument_list|(
name|datalen
argument_list|)
operator|)
condition|)
block|{
name|mm_free
argument_list|(
name|item
operator|->
name|name
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|item
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|memcpy
argument_list|(
name|item
operator|->
name|data
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|itemp
operator|=
name|item
expr_stmt|;
operator|++
operator|(
operator|*
name|countp
operator|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|EVDNS_UNLOCK
argument_list|(
name|req
operator|->
name|port
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_server_request_add_a_reply
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|addrs
parameter_list|,
name|int
name|ttl
parameter_list|)
block|{
return|return
name|evdns_server_request_add_reply
argument_list|(
name|req
argument_list|,
name|EVDNS_ANSWER_SECTION
argument_list|,
name|name
argument_list|,
name|TYPE_A
argument_list|,
name|CLASS_INET
argument_list|,
name|ttl
argument_list|,
name|n
operator|*
literal|4
argument_list|,
literal|0
argument_list|,
name|addrs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_server_request_add_aaaa_reply
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|addrs
parameter_list|,
name|int
name|ttl
parameter_list|)
block|{
return|return
name|evdns_server_request_add_reply
argument_list|(
name|req
argument_list|,
name|EVDNS_ANSWER_SECTION
argument_list|,
name|name
argument_list|,
name|TYPE_AAAA
argument_list|,
name|CLASS_INET
argument_list|,
name|ttl
argument_list|,
name|n
operator|*
literal|16
argument_list|,
literal|0
argument_list|,
name|addrs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_server_request_add_ptr_reply
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req
parameter_list|,
name|struct
name|in_addr
modifier|*
name|in
parameter_list|,
specifier|const
name|char
modifier|*
name|inaddr_name
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|ttl
parameter_list|)
block|{
name|u32
name|a
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|in
operator|&&
name|inaddr_name
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|in
operator|&&
operator|!
name|inaddr_name
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|in
condition|)
block|{
name|a
operator|=
name|ntohl
argument_list|(
name|in
operator|->
name|s_addr
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d.%d.%d.%d.in-addr.arpa"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|u8
argument_list|)
argument_list|(
operator|(
name|a
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|u8
argument_list|)
argument_list|(
operator|(
name|a
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|u8
argument_list|)
argument_list|(
operator|(
name|a
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|u8
argument_list|)
argument_list|(
operator|(
name|a
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|inaddr_name
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|evdns_server_request_add_reply
argument_list|(
name|req
argument_list|,
name|EVDNS_ANSWER_SECTION
argument_list|,
name|inaddr_name
argument_list|,
name|TYPE_PTR
argument_list|,
name|CLASS_INET
argument_list|,
name|ttl
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|hostname
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_server_request_add_cname_reply
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|cname
parameter_list|,
name|int
name|ttl
parameter_list|)
block|{
return|return
name|evdns_server_request_add_reply
argument_list|(
name|req
argument_list|,
name|EVDNS_ANSWER_SECTION
argument_list|,
name|name
argument_list|,
name|TYPE_CNAME
argument_list|,
name|CLASS_INET
argument_list|,
name|ttl
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|cname
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|void
name|evdns_server_request_set_flags
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|exreq
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|server_request
modifier|*
name|req
init|=
name|TO_SERVER_REQUEST
argument_list|(
name|exreq
argument_list|)
decl_stmt|;
name|req
operator|->
name|base
operator|.
name|flags
operator|&=
operator|~
operator|(
name|EVDNS_FLAGS_AA
operator||
name|EVDNS_FLAGS_RD
operator|)
expr_stmt|;
name|req
operator|->
name|base
operator|.
name|flags
operator||=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdns_server_request_format_response
parameter_list|(
name|struct
name|server_request
modifier|*
name|req
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|1500
index|]
decl_stmt|;
name|size_t
name|buf_len
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|off_t
name|j
init|=
literal|0
decl_stmt|,
name|r
decl_stmt|;
name|u16
name|t_
decl_stmt|;
name|u32
name|t32_
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u16
name|flags
decl_stmt|;
name|struct
name|dnslabel_table
name|table
decl_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
operator|||
name|err
operator|>
literal|15
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set response bit and error code; copy OPCODE and RD fields from 	 * question; copy RA and AA if set by caller. */
name|flags
operator|=
name|req
operator|->
name|base
operator|.
name|flags
expr_stmt|;
name|flags
operator||=
operator|(
literal|0x8000
operator||
name|err
operator|)
expr_stmt|;
name|dnslabel_table_init
argument_list|(
operator|&
name|table
argument_list|)
expr_stmt|;
name|APPEND16
argument_list|(
name|req
operator|->
name|trans_id
argument_list|)
expr_stmt|;
name|APPEND16
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|APPEND16
argument_list|(
name|req
operator|->
name|base
operator|.
name|nquestions
argument_list|)
expr_stmt|;
name|APPEND16
argument_list|(
name|req
operator|->
name|n_answer
argument_list|)
expr_stmt|;
name|APPEND16
argument_list|(
name|req
operator|->
name|n_authority
argument_list|)
expr_stmt|;
name|APPEND16
argument_list|(
name|req
operator|->
name|n_additional
argument_list|)
expr_stmt|;
comment|/* Add questions. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|req
operator|->
name|base
operator|.
name|nquestions
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|req
operator|->
name|base
operator|.
name|questions
index|[
name|i
index|]
operator|->
name|name
decl_stmt|;
name|j
operator|=
name|dnsname_to_labels
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|j
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
operator|&
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|dnslabel_clear
argument_list|(
operator|&
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|j
return|;
block|}
name|APPEND16
argument_list|(
name|req
operator|->
name|base
operator|.
name|questions
index|[
name|i
index|]
operator|->
name|type
argument_list|)
expr_stmt|;
name|APPEND16
argument_list|(
name|req
operator|->
name|base
operator|.
name|questions
index|[
name|i
index|]
operator|->
name|dns_question_class
argument_list|)
expr_stmt|;
block|}
comment|/* Add answer, authority, and additional sections. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|server_reply_item
modifier|*
name|item
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|item
operator|=
name|req
operator|->
name|answer
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|item
operator|=
name|req
operator|->
name|authority
expr_stmt|;
else|else
name|item
operator|=
name|req
operator|->
name|additional
expr_stmt|;
while|while
condition|(
name|item
condition|)
block|{
name|r
operator|=
name|dnsname_to_labels
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|j
argument_list|,
name|item
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|item
operator|->
name|name
argument_list|)
argument_list|,
operator|&
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|overflow
goto|;
name|j
operator|=
name|r
expr_stmt|;
name|APPEND16
argument_list|(
name|item
operator|->
name|type
argument_list|)
expr_stmt|;
name|APPEND16
argument_list|(
name|item
operator|->
name|dns_question_class
argument_list|)
expr_stmt|;
name|APPEND32
argument_list|(
name|item
operator|->
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|is_name
condition|)
block|{
name|off_t
name|len_idx
init|=
name|j
decl_stmt|,
name|name_start
decl_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
name|name_start
operator|=
name|j
expr_stmt|;
name|r
operator|=
name|dnsname_to_labels
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|j
argument_list|,
name|item
operator|->
name|data
argument_list|,
name|strlen
argument_list|(
name|item
operator|->
name|data
argument_list|)
argument_list|,
operator|&
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|overflow
goto|;
name|j
operator|=
name|r
expr_stmt|;
name|t_
operator|=
name|htons
argument_list|(
call|(
name|short
call|)
argument_list|(
name|j
operator|-
name|name_start
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|len_idx
argument_list|,
operator|&
name|t_
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|APPEND16
argument_list|(
name|item
operator|->
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
name|item
operator|->
name|datalen
operator|>
operator|(
name|off_t
operator|)
name|buf_len
condition|)
goto|goto
name|overflow
goto|;
name|memcpy
argument_list|(
name|buf
operator|+
name|j
argument_list|,
name|item
operator|->
name|data
argument_list|,
name|item
operator|->
name|datalen
argument_list|)
expr_stmt|;
name|j
operator|+=
name|item
operator|->
name|datalen
expr_stmt|;
block|}
name|item
operator|=
name|item
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|>
literal|512
condition|)
block|{
name|overflow
label|:
name|j
operator|=
literal|512
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator||=
literal|0x02
expr_stmt|;
comment|/* set the truncated bit. */
block|}
name|req
operator|->
name|response_len
operator|=
name|j
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|req
operator|->
name|response
operator|=
name|mm_malloc
argument_list|(
name|req
operator|->
name|response_len
argument_list|)
operator|)
condition|)
block|{
name|server_request_free_answers
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|dnslabel_clear
argument_list|(
operator|&
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|req
operator|->
name|response
argument_list|,
name|buf
argument_list|,
name|req
operator|->
name|response_len
argument_list|)
expr_stmt|;
name|server_request_free_answers
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|dnslabel_clear
argument_list|(
operator|&
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_server_request_respond
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req_
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|struct
name|server_request
modifier|*
name|req
init|=
name|TO_SERVER_REQUEST
argument_list|(
name|req_
argument_list|)
decl_stmt|;
name|struct
name|evdns_server_port
modifier|*
name|port
init|=
name|req
operator|->
name|port
decl_stmt|;
name|int
name|r
init|=
operator|-
literal|1
decl_stmt|;
name|EVDNS_LOCK
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
operator|->
name|response
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|evdns_server_request_format_response
argument_list|(
name|req
argument_list|,
name|err
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
name|r
operator|=
name|sendto
argument_list|(
name|port
operator|->
name|socket
argument_list|,
name|req
operator|->
name|response
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|response_len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|req
operator|->
name|addr
argument_list|,
operator|(
name|ev_socklen_t
operator|)
name|req
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|int
name|sock_err
init|=
name|evutil_socket_geterror
argument_list|(
name|port
operator|->
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|sock_err
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|port
operator|->
name|pending_replies
condition|)
block|{
name|req
operator|->
name|prev_pending
operator|=
name|port
operator|->
name|pending_replies
operator|->
name|prev_pending
expr_stmt|;
name|req
operator|->
name|next_pending
operator|=
name|port
operator|->
name|pending_replies
expr_stmt|;
name|req
operator|->
name|prev_pending
operator|->
name|next_pending
operator|=
name|req
operator|->
name|next_pending
operator|->
name|prev_pending
operator|=
name|req
expr_stmt|;
block|}
else|else
block|{
name|req
operator|->
name|prev_pending
operator|=
name|req
operator|->
name|next_pending
operator|=
name|req
expr_stmt|;
name|port
operator|->
name|pending_replies
operator|=
name|req
expr_stmt|;
name|port
operator|->
name|choked
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|event_del
argument_list|(
operator|&
name|port
operator|->
name|event
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|port
operator|->
name|event
argument_list|,
name|port
operator|->
name|event_base
argument_list|,
name|port
operator|->
name|socket
argument_list|,
operator|(
name|port
operator|->
name|closing
condition|?
literal|0
else|:
name|EV_READ
operator|)
operator||
name|EV_WRITE
operator||
name|EV_PERSIST
argument_list|,
name|server_port_ready_callback
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|port
operator|->
name|event
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Error from libevent when adding event for DNS server"
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|server_request_free
argument_list|(
name|req
argument_list|)
condition|)
block|{
name|r
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|port
operator|->
name|pending_replies
condition|)
name|server_port_flush
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|EVDNS_UNLOCK
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Free all storage held by RRs in req. */
end_comment

begin_function
specifier|static
name|void
name|server_request_free_answers
parameter_list|(
name|struct
name|server_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|server_reply_item
modifier|*
name|victim
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
modifier|*
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|list
operator|=
operator|&
name|req
operator|->
name|answer
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|list
operator|=
operator|&
name|req
operator|->
name|authority
expr_stmt|;
else|else
name|list
operator|=
operator|&
name|req
operator|->
name|additional
expr_stmt|;
name|victim
operator|=
operator|*
name|list
expr_stmt|;
while|while
condition|(
name|victim
condition|)
block|{
name|next
operator|=
name|victim
operator|->
name|next
expr_stmt|;
name|mm_free
argument_list|(
name|victim
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|victim
operator|->
name|data
condition|)
name|mm_free
argument_list|(
name|victim
operator|->
name|data
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|victim
argument_list|)
expr_stmt|;
name|victim
operator|=
name|next
expr_stmt|;
block|}
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free all storage held by req, and remove links to it. */
end_comment

begin_comment
comment|/* return true iff we just wound up freeing the server_port. */
end_comment

begin_function
specifier|static
name|int
name|server_request_free
parameter_list|(
name|struct
name|server_request
modifier|*
name|req
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|1
decl_stmt|,
name|lock
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|base
operator|.
name|questions
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|req
operator|->
name|base
operator|.
name|nquestions
condition|;
operator|++
name|i
control|)
name|mm_free
argument_list|(
name|req
operator|->
name|base
operator|.
name|questions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|req
operator|->
name|base
operator|.
name|questions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|->
name|port
condition|)
block|{
name|EVDNS_LOCK
argument_list|(
name|req
operator|->
name|port
argument_list|)
expr_stmt|;
name|lock
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|port
operator|->
name|pending_replies
operator|==
name|req
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|next_pending
operator|&&
name|req
operator|->
name|next_pending
operator|!=
name|req
condition|)
name|req
operator|->
name|port
operator|->
name|pending_replies
operator|=
name|req
operator|->
name|next_pending
expr_stmt|;
else|else
name|req
operator|->
name|port
operator|->
name|pending_replies
operator|=
name|NULL
expr_stmt|;
block|}
name|rc
operator|=
operator|--
name|req
operator|->
name|port
operator|->
name|refcnt
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|->
name|response
condition|)
block|{
name|mm_free
argument_list|(
name|req
operator|->
name|response
argument_list|)
expr_stmt|;
block|}
name|server_request_free_answers
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|next_pending
operator|&&
name|req
operator|->
name|next_pending
operator|!=
name|req
condition|)
block|{
name|req
operator|->
name|next_pending
operator|->
name|prev_pending
operator|=
name|req
operator|->
name|prev_pending
expr_stmt|;
name|req
operator|->
name|prev_pending
operator|->
name|next_pending
operator|=
name|req
operator|->
name|next_pending
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|EVDNS_UNLOCK
argument_list|(
name|req
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* ????? nickm */
name|server_port_free
argument_list|(
name|req
operator|->
name|port
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lock
condition|)
name|EVDNS_UNLOCK
argument_list|(
name|req
operator|->
name|port
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free all storage held by an evdns_server_port.  Only called when  */
end_comment

begin_function
specifier|static
name|void
name|server_port_free
parameter_list|(
name|struct
name|evdns_server_port
modifier|*
name|port
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|!
name|port
operator|->
name|refcnt
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|!
name|port
operator|->
name|pending_replies
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|socket
operator|>
literal|0
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|port
operator|->
name|socket
argument_list|)
expr_stmt|;
name|port
operator|->
name|socket
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|event_del
argument_list|(
operator|&
name|port
operator|->
name|event
argument_list|)
expr_stmt|;
name|event_debug_unassign
argument_list|(
operator|&
name|port
operator|->
name|event
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_LOCK
argument_list|(
name|port
operator|->
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_server_request_drop
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req_
parameter_list|)
block|{
name|struct
name|server_request
modifier|*
name|req
init|=
name|TO_SERVER_REQUEST
argument_list|(
name|req_
argument_list|)
decl_stmt|;
name|server_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_server_request_get_requesting_addr
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req_
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|int
name|addr_len
parameter_list|)
block|{
name|struct
name|server_request
modifier|*
name|req
init|=
name|TO_SERVER_REQUEST
argument_list|(
name|req_
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr_len
operator|<
operator|(
name|int
operator|)
name|req
operator|->
name|addrlen
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|sa
argument_list|,
operator|&
operator|(
name|req
operator|->
name|addr
operator|)
argument_list|,
name|req
operator|->
name|addrlen
argument_list|)
expr_stmt|;
return|return
name|req
operator|->
name|addrlen
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|APPEND16
end_undef

begin_undef
undef|#
directive|undef
name|APPEND32
end_undef

begin_comment
comment|/* this is a libevent callback function which is called when a request */
end_comment

begin_comment
comment|/* has timed out. */
end_comment

begin_function
specifier|static
name|void
name|evdns_request_timeout_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|request
modifier|*
specifier|const
name|req
init|=
operator|(
expr|struct
name|request
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|base
init|=
name|req
operator|->
name|base
decl_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|events
expr_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Request %p timed out"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|tx_count
operator|>=
name|req
operator|->
name|base
operator|->
name|global_max_retransmits
condition|)
block|{
name|struct
name|nameserver
modifier|*
name|ns
init|=
name|req
operator|->
name|ns
decl_stmt|;
comment|/* this request has failed */
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Giving up on request %p; tx_count==%d"
argument_list|,
name|arg
argument_list|,
name|req
operator|->
name|tx_count
argument_list|)
expr_stmt|;
name|reply_schedule_callback
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
name|DNS_ERR_TIMEOUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|request_finished
argument_list|(
name|req
argument_list|,
operator|&
name|REQ_HEAD
argument_list|(
name|req
operator|->
name|base
argument_list|,
name|req
operator|->
name|trans_id
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nameserver_failed
argument_list|(
name|ns
argument_list|,
literal|"request timed out."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* retransmit it */
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Retransmitting request %p; tx_count==%d"
argument_list|,
name|arg
argument_list|,
name|req
operator|->
name|tx_count
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|evtimer_del
argument_list|(
operator|&
name|req
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
name|request_swap_ns
argument_list|(
name|req
argument_list|,
name|nameserver_pick
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_request_transmit
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|req
operator|->
name|ns
operator|->
name|timedout
operator|++
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|ns
operator|->
name|timedout
operator|>
name|req
operator|->
name|base
operator|->
name|global_max_nameserver_timeout
condition|)
block|{
name|req
operator|->
name|ns
operator|->
name|timedout
operator|=
literal|0
expr_stmt|;
name|nameserver_failed
argument_list|(
name|req
operator|->
name|ns
argument_list|,
literal|"request timed out."
argument_list|)
expr_stmt|;
block|}
block|}
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* try to send a request to a given server. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* return: */
end_comment

begin_comment
comment|/*   0 ok */
end_comment

begin_comment
comment|/*   1 temporary failure */
end_comment

begin_comment
comment|/*   2 other failure */
end_comment

begin_function
specifier|static
name|int
name|evdns_request_transmit_to
parameter_list|(
name|struct
name|request
modifier|*
name|req
parameter_list|,
name|struct
name|nameserver
modifier|*
name|server
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|req
operator|->
name|base
argument_list|)
expr_stmt|;
name|ASSERT_VALID_REQUEST
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|requests_inflight
operator|==
literal|1
operator|&&
name|req
operator|->
name|base
operator|->
name|disable_when_inactive
operator|&&
name|event_add
argument_list|(
operator|&
name|server
operator|->
name|event
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
name|r
operator|=
name|sendto
argument_list|(
name|server
operator|->
name|socket
argument_list|,
operator|(
name|void
operator|*
operator|)
name|req
operator|->
name|request
argument_list|,
name|req
operator|->
name|request_len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
operator|->
name|address
argument_list|,
name|server
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|int
name|err
init|=
name|evutil_socket_geterror
argument_list|(
name|server
operator|->
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|err
argument_list|)
condition|)
return|return
literal|1
return|;
name|nameserver_failed
argument_list|(
name|req
operator|->
name|ns
argument_list|,
name|evutil_socket_error_to_string
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
operator|(
name|int
operator|)
name|req
operator|->
name|request_len
condition|)
block|{
return|return
literal|1
return|;
comment|/* short write */
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* try to send a request, updating the fields of the request */
end_comment

begin_comment
comment|/* as needed */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* return: */
end_comment

begin_comment
comment|/*   0 ok */
end_comment

begin_comment
comment|/*   1 failed */
end_comment

begin_function
specifier|static
name|int
name|evdns_request_transmit
parameter_list|(
name|struct
name|request
modifier|*
name|req
parameter_list|)
block|{
name|int
name|retcode
init|=
literal|0
decl_stmt|,
name|r
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|req
operator|->
name|base
argument_list|)
expr_stmt|;
name|ASSERT_VALID_REQUEST
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* if we fail to send this packet then this flag marks it */
comment|/* for evdns_transmit */
name|req
operator|->
name|transmit_me
operator|=
literal|1
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|req
operator|->
name|trans_id
operator|!=
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
operator|->
name|ns
condition|)
block|{
comment|/* unable to transmit request if no nameservers */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|req
operator|->
name|ns
operator|->
name|choked
condition|)
block|{
comment|/* don't bother trying to write to a socket */
comment|/* which we have had EAGAIN from */
return|return
literal|1
return|;
block|}
name|r
operator|=
name|evdns_request_transmit_to
argument_list|(
name|req
argument_list|,
name|req
operator|->
name|ns
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|1
case|:
comment|/* temp failure */
name|req
operator|->
name|ns
operator|->
name|choked
operator|=
literal|1
expr_stmt|;
name|nameserver_write_waiting
argument_list|(
name|req
operator|->
name|ns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|2
case|:
comment|/* failed to transmit the request entirely. */
name|retcode
operator|=
literal|1
expr_stmt|;
comment|/* fall through: we'll set a timeout, which will time out, 		 * and make us retransmit the request anyway. */
default|default:
comment|/* all ok */
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Setting timeout for request %p, sent to nameserver %p"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|evtimer_add
argument_list|(
operator|&
name|req
operator|->
name|timeout_event
argument_list|,
operator|&
name|req
operator|->
name|base
operator|->
name|global_timeout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Error from libevent when adding timer for request %p"
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* ???? Do more? */
block|}
name|req
operator|->
name|tx_count
operator|++
expr_stmt|;
name|req
operator|->
name|transmit_me
operator|=
literal|0
expr_stmt|;
return|return
name|retcode
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nameserver_probe_callback
parameter_list|(
name|int
name|result
parameter_list|,
name|char
name|type
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|ttl
parameter_list|,
name|void
modifier|*
name|addresses
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nameserver
modifier|*
specifier|const
name|ns
init|=
operator|(
expr|struct
name|nameserver
operator|*
operator|)
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|type
expr_stmt|;
operator|(
name|void
operator|)
name|count
expr_stmt|;
operator|(
name|void
operator|)
name|ttl
expr_stmt|;
operator|(
name|void
operator|)
name|addresses
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_ERR_CANCEL
condition|)
block|{
comment|/* We canceled this request because the nameserver came up 		 * for some other reason.  Do not change our opinion about 		 * the nameserver. */
return|return;
block|}
name|EVDNS_LOCK
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
name|ns
operator|->
name|probe_request
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_ERR_NONE
operator|||
name|result
operator|==
name|DNS_ERR_NOTEXIST
condition|)
block|{
comment|/* this is a good reply */
name|nameserver_up
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nameserver_probe_failed
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nameserver_send_probe
parameter_list|(
name|struct
name|nameserver
modifier|*
specifier|const
name|ns
parameter_list|)
block|{
name|struct
name|evdns_request
modifier|*
name|handle
decl_stmt|;
name|struct
name|request
modifier|*
name|req
decl_stmt|;
name|char
name|addrbuf
index|[
literal|128
index|]
decl_stmt|;
comment|/* here we need to send a probe to a given nameserver */
comment|/* in the hope that it is up now. */
name|ASSERT_LOCKED
argument_list|(
name|ns
operator|->
name|base
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Sending probe to %s"
argument_list|,
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ns
operator|->
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|handle
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
condition|)
return|return;
name|req
operator|=
name|request_new
argument_list|(
name|ns
operator|->
name|base
argument_list|,
name|handle
argument_list|,
name|TYPE_A
argument_list|,
literal|"google.com"
argument_list|,
name|DNS_QUERY_NO_SEARCH
argument_list|,
name|nameserver_probe_callback
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
block|{
name|mm_free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return;
block|}
name|ns
operator|->
name|probe_request
operator|=
name|handle
expr_stmt|;
comment|/* we force this into the inflight queue no matter what */
name|request_trans_id_set
argument_list|(
name|req
argument_list|,
name|transaction_id_pick
argument_list|(
name|ns
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|ns
operator|=
name|ns
expr_stmt|;
name|request_submit
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns: */
end_comment

begin_comment
comment|/*   0 didn't try to transmit anything */
end_comment

begin_comment
comment|/*   1 tried to transmit something */
end_comment

begin_function
specifier|static
name|int
name|evdns_transmit
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|char
name|did_try_to_transmit
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|n_req_heads
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|base
operator|->
name|req_heads
index|[
name|i
index|]
condition|)
block|{
name|struct
name|request
modifier|*
specifier|const
name|started_at
init|=
name|base
operator|->
name|req_heads
index|[
name|i
index|]
decl_stmt|,
modifier|*
name|req
init|=
name|started_at
decl_stmt|;
comment|/* first transmit all the requests which are currently waiting */
do|do
block|{
if|if
condition|(
name|req
operator|->
name|transmit_me
condition|)
block|{
name|did_try_to_transmit
operator|=
literal|1
expr_stmt|;
name|evdns_request_transmit
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
name|req
operator|=
name|req
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|req
operator|!=
name|started_at
condition|)
do|;
block|}
block|}
return|return
name|did_try_to_transmit
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_base_count_nameservers
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
specifier|const
name|struct
name|nameserver
modifier|*
name|server
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|server
operator|=
name|base
operator|->
name|server_head
expr_stmt|;
if|if
condition|(
operator|!
name|server
condition|)
goto|goto
name|done
goto|;
do|do
block|{
operator|++
name|n
expr_stmt|;
name|server
operator|=
name|server
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|server
operator|!=
name|base
operator|->
name|server_head
condition|)
do|;
name|done
label|:
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|int
name|evdns_count_nameservers
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|evdns_base_count_nameservers
argument_list|(
name|current_base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_base_clear_nameservers_and_suspend
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|nameserver
modifier|*
name|server
decl_stmt|,
modifier|*
name|started_at
decl_stmt|;
name|int
name|i
decl_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|server
operator|=
name|base
operator|->
name|server_head
expr_stmt|;
name|started_at
operator|=
name|base
operator|->
name|server_head
expr_stmt|;
if|if
condition|(
operator|!
name|server
condition|)
block|{
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|nameserver
modifier|*
name|next
init|=
name|server
operator|->
name|next
decl_stmt|;
operator|(
name|void
operator|)
name|event_del
argument_list|(
operator|&
name|server
operator|->
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|evtimer_initialized
argument_list|(
operator|&
name|server
operator|->
name|timeout_event
argument_list|)
condition|)
operator|(
name|void
operator|)
name|evtimer_del
argument_list|(
operator|&
name|server
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|probe_request
condition|)
block|{
name|evdns_cancel_request
argument_list|(
name|server
operator|->
name|base
argument_list|,
name|server
operator|->
name|probe_request
argument_list|)
expr_stmt|;
name|server
operator|->
name|probe_request
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|server
operator|->
name|socket
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|server
operator|->
name|socket
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|started_at
condition|)
break|break;
name|server
operator|=
name|next
expr_stmt|;
block|}
name|base
operator|->
name|server_head
operator|=
name|NULL
expr_stmt|;
name|base
operator|->
name|global_good_nameservers
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|n_req_heads
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|request
modifier|*
name|req
decl_stmt|,
modifier|*
name|req_started_at
decl_stmt|;
name|req
operator|=
name|req_started_at
operator|=
name|base
operator|->
name|req_heads
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|req
condition|)
block|{
name|struct
name|request
modifier|*
name|next
init|=
name|req
operator|->
name|next
decl_stmt|;
name|req
operator|->
name|tx_count
operator|=
name|req
operator|->
name|reissue_count
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|ns
operator|=
name|NULL
expr_stmt|;
comment|/* ???? What to do about searches? */
operator|(
name|void
operator|)
name|evtimer_del
argument_list|(
operator|&
name|req
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
name|req
operator|->
name|trans_id
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|transmit_me
operator|=
literal|0
expr_stmt|;
name|base
operator|->
name|global_requests_waiting
operator|++
expr_stmt|;
name|evdns_request_insert
argument_list|(
name|req
argument_list|,
operator|&
name|base
operator|->
name|req_waiting_head
argument_list|)
expr_stmt|;
comment|/* We want to insert these suspended elements at the front of 			 * the waiting queue, since they were pending before any of 			 * the waiting entries were added.  This is a circular list, 			 * so we can just shift the start back by one.*/
name|base
operator|->
name|req_waiting_head
operator|=
name|base
operator|->
name|req_waiting_head
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|req_started_at
condition|)
break|break;
name|req
operator|=
name|next
expr_stmt|;
block|}
name|base
operator|->
name|req_heads
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|base
operator|->
name|global_requests_inflight
operator|=
literal|0
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evdns_clear_nameservers_and_suspend
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|evdns_base_clear_nameservers_and_suspend
argument_list|(
name|current_base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_base_resume
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|evdns_requests_pump_waiting_queue
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evdns_resume
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|evdns_base_resume
argument_list|(
name|current_base
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdns_nameserver_add_impl_
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|address
parameter_list|,
name|int
name|addrlen
parameter_list|)
block|{
comment|/* first check to see if we already have this nameserver */
specifier|const
name|struct
name|nameserver
modifier|*
name|server
init|=
name|base
operator|->
name|server_head
decl_stmt|,
modifier|*
decl_stmt|const
name|started_at
init|=
name|base
operator|->
name|server_head
decl_stmt|;
name|struct
name|nameserver
modifier|*
name|ns
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
name|addrbuf
index|[
literal|128
index|]
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|!
name|evutil_sockaddr_cmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
operator|->
name|address
argument_list|,
name|address
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|3
return|;
name|server
operator|=
name|server
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|server
operator|!=
name|started_at
condition|)
do|;
block|}
if|if
condition|(
name|addrlen
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ns
operator|->
name|address
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Addrlen %d too long."
argument_list|,
operator|(
name|int
operator|)
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|ns
operator|=
operator|(
expr|struct
name|nameserver
operator|*
operator|)
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nameserver
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|ns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nameserver
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|evtimer_assign
argument_list|(
operator|&
name|ns
operator|->
name|timeout_event
argument_list|,
name|ns
operator|->
name|base
operator|->
name|event_base
argument_list|,
name|nameserver_prod_callback
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|ns
operator|->
name|socket
operator|=
name|evutil_socket_
argument_list|(
name|address
operator|->
name|sa_family
argument_list|,
name|SOCK_DGRAM
operator||
name|EVUTIL_SOCK_NONBLOCK
operator||
name|EVUTIL_SOCK_CLOEXEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|socket
operator|<
literal|0
condition|)
block|{
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
if|if
condition|(
name|base
operator|->
name|global_outgoing_addrlen
operator|&&
operator|!
name|evutil_sockaddr_is_loopback_
argument_list|(
name|address
argument_list|)
condition|)
block|{
if|if
condition|(
name|bind
argument_list|(
name|ns
operator|->
name|socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|base
operator|->
name|global_outgoing_address
argument_list|,
name|base
operator|->
name|global_outgoing_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Couldn't bind to outgoing address"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|2
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
name|memcpy
argument_list|(
operator|&
name|ns
operator|->
name|address
argument_list|,
name|address
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|ns
operator|->
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|ns
operator|->
name|state
operator|=
literal|1
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|ns
operator|->
name|event
argument_list|,
name|ns
operator|->
name|base
operator|->
name|event_base
argument_list|,
name|ns
operator|->
name|socket
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|nameserver_ready_callback
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|disable_when_inactive
operator|&&
name|event_add
argument_list|(
operator|&
name|ns
operator|->
name|event
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
operator|=
literal|2
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Added nameserver %s as %p"
argument_list|,
name|evutil_format_sockaddr_port_
argument_list|(
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
argument_list|,
name|ns
argument_list|)
expr_stmt|;
comment|/* insert this nameserver into the list of them */
if|if
condition|(
operator|!
name|base
operator|->
name|server_head
condition|)
block|{
name|ns
operator|->
name|next
operator|=
name|ns
operator|->
name|prev
operator|=
name|ns
expr_stmt|;
name|base
operator|->
name|server_head
operator|=
name|ns
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|->
name|next
operator|=
name|base
operator|->
name|server_head
operator|->
name|next
expr_stmt|;
name|ns
operator|->
name|prev
operator|=
name|base
operator|->
name|server_head
expr_stmt|;
name|base
operator|->
name|server_head
operator|->
name|next
operator|=
name|ns
expr_stmt|;
name|ns
operator|->
name|next
operator|->
name|prev
operator|=
name|ns
expr_stmt|;
block|}
name|base
operator|->
name|global_good_nameservers
operator|++
expr_stmt|;
return|return
literal|0
return|;
name|out2
label|:
name|evutil_closesocket
argument_list|(
name|ns
operator|->
name|socket
argument_list|)
expr_stmt|;
name|out1
label|:
name|event_debug_unassign
argument_list|(
operator|&
name|ns
operator|->
name|event
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Unable to add nameserver %s: error %d"
argument_list|,
name|evutil_format_sockaddr_port_
argument_list|(
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_base_nameserver_add
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|unsigned
name|long
name|int
name|address
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|res
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|address
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|53
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|res
operator|=
name|evdns_nameserver_add_impl_
argument_list|(
name|base
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|evdns_nameserver_add
parameter_list|(
name|unsigned
name|long
name|int
name|address
parameter_list|)
block|{
if|if
condition|(
operator|!
name|current_base
condition|)
name|current_base
operator|=
name|evdns_base_new
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|evdns_base_nameserver_add
argument_list|(
name|current_base
argument_list|,
name|address
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sockaddr_setport
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|ev_uint16_t
name|port
parameter_list|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|ev_uint16_t
name|sockaddr_getport
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
return|return
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_port
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
return|return
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_port
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_base_nameserver_ip_add
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|ip_as_string
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|evutil_parse_sockaddr_port
argument_list|(
name|ip_as_string
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Unable to parse nameserver address %s"
argument_list|,
name|ip_as_string
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
expr_stmt|;
if|if
condition|(
name|sockaddr_getport
argument_list|(
name|sa
argument_list|)
operator|==
literal|0
condition|)
name|sockaddr_setport
argument_list|(
name|sa
argument_list|,
literal|53
argument_list|)
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|res
operator|=
name|evdns_nameserver_add_impl_
argument_list|(
name|base
argument_list|,
name|sa
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|evdns_nameserver_ip_add
parameter_list|(
specifier|const
name|char
modifier|*
name|ip_as_string
parameter_list|)
block|{
if|if
condition|(
operator|!
name|current_base
condition|)
name|current_base
operator|=
name|evdns_base_new
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|evdns_base_nameserver_ip_add
argument_list|(
name|current_base
argument_list|,
name|ip_as_string
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|evdns_base_nameserver_sockaddr_add
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|ev_socklen_t
name|len
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|res
operator|=
name|evdns_nameserver_add_impl_
argument_list|(
name|base
argument_list|,
name|sa
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|evdns_base_get_nameserver_addr
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|ev_socklen_t
name|len
parameter_list|)
block|{
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|nameserver
modifier|*
name|server
decl_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|server
operator|=
name|base
operator|->
name|server_head
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idx
operator|&&
name|server
condition|;
operator|++
name|i
operator|,
name|server
operator|=
name|server
operator|->
name|next
control|)
block|{
if|if
condition|(
name|server
operator|->
name|next
operator|==
name|base
operator|->
name|server_head
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|server
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|server
operator|->
name|addrlen
operator|>
name|len
condition|)
block|{
name|result
operator|=
operator|(
name|int
operator|)
name|server
operator|->
name|addrlen
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|memcpy
argument_list|(
name|sa
argument_list|,
operator|&
name|server
operator|->
name|address
argument_list|,
name|server
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|int
operator|)
name|server
operator|->
name|addrlen
expr_stmt|;
name|done
label|:
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* remove from the queue */
end_comment

begin_function
specifier|static
name|void
name|evdns_request_remove
parameter_list|(
name|struct
name|request
modifier|*
name|req
parameter_list|,
name|struct
name|request
modifier|*
modifier|*
name|head
parameter_list|)
block|{
name|ASSERT_LOCKED
argument_list|(
name|req
operator|->
name|base
argument_list|)
expr_stmt|;
name|ASSERT_VALID_REQUEST
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|{ 		struct request *ptr; 		int found = 0; 		EVUTIL_ASSERT(*head != NULL);  		ptr = *head; 		do { 			if (ptr == req) { 				found = 1; 				break; 			} 			ptr = ptr->next; 		} while (ptr != *head); 		EVUTIL_ASSERT(found);  		EVUTIL_ASSERT(req->next); 	}
endif|#
directive|endif
if|if
condition|(
name|req
operator|->
name|next
operator|==
name|req
condition|)
block|{
comment|/* only item in the list */
operator|*
name|head
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|req
operator|->
name|next
operator|->
name|prev
operator|=
name|req
operator|->
name|prev
expr_stmt|;
name|req
operator|->
name|prev
operator|->
name|next
operator|=
name|req
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|head
operator|==
name|req
condition|)
operator|*
name|head
operator|=
name|req
operator|->
name|next
expr_stmt|;
block|}
name|req
operator|->
name|next
operator|=
name|req
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* insert into the tail of the queue */
end_comment

begin_function
specifier|static
name|void
name|evdns_request_insert
parameter_list|(
name|struct
name|request
modifier|*
name|req
parameter_list|,
name|struct
name|request
modifier|*
modifier|*
name|head
parameter_list|)
block|{
name|ASSERT_LOCKED
argument_list|(
name|req
operator|->
name|base
argument_list|)
expr_stmt|;
name|ASSERT_VALID_REQUEST
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|head
condition|)
block|{
operator|*
name|head
operator|=
name|req
expr_stmt|;
name|req
operator|->
name|next
operator|=
name|req
operator|->
name|prev
operator|=
name|req
expr_stmt|;
return|return;
block|}
name|req
operator|->
name|prev
operator|=
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
expr_stmt|;
name|req
operator|->
name|prev
operator|->
name|next
operator|=
name|req
expr_stmt|;
name|req
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|=
name|req
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|string_num_dots
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|request
modifier|*
name|request_new
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|struct
name|evdns_request
modifier|*
name|handle
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|callback
parameter_list|,
name|void
modifier|*
name|user_ptr
parameter_list|)
block|{
specifier|const
name|char
name|issuing_now
init|=
operator|(
name|base
operator|->
name|global_requests_inflight
operator|<
name|base
operator|->
name|global_max_requests_inflight
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
specifier|const
name|size_t
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|request_max_len
init|=
name|evdns_request_len
argument_list|(
name|name_len
argument_list|)
decl_stmt|;
specifier|const
name|u16
name|trans_id
init|=
name|issuing_now
condition|?
name|transaction_id_pick
argument_list|(
name|base
argument_list|)
else|:
literal|0xffff
decl_stmt|;
comment|/* the request data is alloced in a single block with the header */
name|struct
name|request
modifier|*
specifier|const
name|req
init|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|request
argument_list|)
operator|+
name|request_max_len
argument_list|)
decl_stmt|;
name|int
name|rlen
decl_stmt|;
name|char
name|namebuf
index|[
literal|256
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|flags
expr_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|name_len
operator|>=
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
condition|)
block|{
name|mm_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|evtimer_assign
argument_list|(
operator|&
name|req
operator|->
name|timeout_event
argument_list|,
name|req
operator|->
name|base
operator|->
name|event_base
argument_list|,
name|evdns_request_timeout_callback
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|global_randomize_case
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|char
name|randbits
index|[
operator|(
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|7
operator|)
operator|/
literal|8
index|]
decl_stmt|;
name|strlcpy
argument_list|(
name|namebuf
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|evutil_secure_rng_get_bytes
argument_list|(
name|randbits
argument_list|,
operator|(
name|name_len
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|name_len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|EVUTIL_ISALPHA_
argument_list|(
name|namebuf
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|randbits
index|[
name|i
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
operator|)
condition|)
name|namebuf
index|[
name|i
index|]
operator||=
literal|0x20
expr_stmt|;
else|else
name|namebuf
index|[
name|i
index|]
operator|&=
operator|~
literal|0x20
expr_stmt|;
block|}
block|}
name|name
operator|=
name|namebuf
expr_stmt|;
block|}
comment|/* request data lives just after the header */
name|req
operator|->
name|request
operator|=
operator|(
operator|(
name|u8
operator|*
operator|)
name|req
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|request
argument_list|)
expr_stmt|;
comment|/* denotes that the request data shouldn't be free()ed */
name|req
operator|->
name|request_appended
operator|=
literal|1
expr_stmt|;
name|rlen
operator|=
name|evdns_request_data_build
argument_list|(
name|name
argument_list|,
name|name_len
argument_list|,
name|trans_id
argument_list|,
name|type
argument_list|,
name|CLASS_INET
argument_list|,
name|req
operator|->
name|request
argument_list|,
name|request_max_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|<
literal|0
condition|)
goto|goto
name|err1
goto|;
name|req
operator|->
name|request_len
operator|=
name|rlen
expr_stmt|;
name|req
operator|->
name|trans_id
operator|=
name|trans_id
expr_stmt|;
name|req
operator|->
name|tx_count
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|request_type
operator|=
name|type
expr_stmt|;
name|req
operator|->
name|user_pointer
operator|=
name|user_ptr
expr_stmt|;
name|req
operator|->
name|user_callback
operator|=
name|callback
expr_stmt|;
name|req
operator|->
name|ns
operator|=
name|issuing_now
condition|?
name|nameserver_pick
argument_list|(
name|base
argument_list|)
else|:
name|NULL
expr_stmt|;
name|req
operator|->
name|next
operator|=
name|req
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|req
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
name|handle
operator|->
name|current_req
operator|=
name|req
expr_stmt|;
name|handle
operator|->
name|base
operator|=
name|base
expr_stmt|;
block|}
return|return
name|req
return|;
name|err1
label|:
name|mm_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|request_submit
parameter_list|(
name|struct
name|request
modifier|*
specifier|const
name|req
parameter_list|)
block|{
name|struct
name|evdns_base
modifier|*
name|base
init|=
name|req
operator|->
name|base
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|ASSERT_VALID_REQUEST
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|ns
condition|)
block|{
comment|/* if it has a nameserver assigned then this is going */
comment|/* straight into the inflight queue */
name|evdns_request_insert
argument_list|(
name|req
argument_list|,
operator|&
name|REQ_HEAD
argument_list|(
name|base
argument_list|,
name|req
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|->
name|global_requests_inflight
operator|++
expr_stmt|;
name|req
operator|->
name|ns
operator|->
name|requests_inflight
operator|++
expr_stmt|;
name|evdns_request_transmit
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evdns_request_insert
argument_list|(
name|req
argument_list|,
operator|&
name|base
operator|->
name|req_waiting_head
argument_list|)
expr_stmt|;
name|base
operator|->
name|global_requests_waiting
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|void
name|evdns_cancel_request
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|struct
name|evdns_request
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|request
modifier|*
name|req
decl_stmt|;
if|if
condition|(
operator|!
name|handle
operator|->
name|current_req
condition|)
return|return;
if|if
condition|(
operator|!
name|base
condition|)
block|{
comment|/* This redundancy is silly; can we fix it? (Not for 2.0) XXXX */
name|base
operator|=
name|handle
operator|->
name|base
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
name|base
operator|=
name|handle
operator|->
name|current_req
operator|->
name|base
expr_stmt|;
block|}
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|pending_cb
condition|)
block|{
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|handle
operator|->
name|current_req
expr_stmt|;
name|ASSERT_VALID_REQUEST
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|reply_schedule_callback
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
name|DNS_ERR_CANCEL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|ns
condition|)
block|{
comment|/* remove from inflight queue */
name|request_finished
argument_list|(
name|req
argument_list|,
operator|&
name|REQ_HEAD
argument_list|(
name|base
argument_list|,
name|req
operator|->
name|trans_id
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* remove from global_waiting head */
name|request_finished
argument_list|(
name|req
argument_list|,
operator|&
name|base
operator|->
name|req_waiting_head
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|struct
name|evdns_request
modifier|*
name|evdns_base_resolve_ipv4
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|callback
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evdns_request
modifier|*
name|handle
decl_stmt|;
name|struct
name|request
modifier|*
name|req
decl_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Resolve requested for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|handle
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DNS_QUERY_NO_SEARCH
condition|)
block|{
name|req
operator|=
name|request_new
argument_list|(
name|base
argument_list|,
name|handle
argument_list|,
name|TYPE_A
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|callback
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
name|request_submit
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|search_request_new
argument_list|(
name|base
argument_list|,
name|handle
argument_list|,
name|TYPE_A
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|callback
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handle
operator|->
name|current_req
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|handle
operator|=
name|NULL
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|handle
return|;
block|}
end_function

begin_function
name|int
name|evdns_resolve_ipv4
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|callback
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|evdns_base_resolve_ipv4
argument_list|(
name|current_base
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|callback
argument_list|,
name|ptr
argument_list|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|struct
name|evdns_request
modifier|*
name|evdns_base_resolve_ipv6
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|callback
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evdns_request
modifier|*
name|handle
decl_stmt|;
name|struct
name|request
modifier|*
name|req
decl_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Resolve requested for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|handle
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DNS_QUERY_NO_SEARCH
condition|)
block|{
name|req
operator|=
name|request_new
argument_list|(
name|base
argument_list|,
name|handle
argument_list|,
name|TYPE_AAAA
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|callback
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
name|request_submit
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|search_request_new
argument_list|(
name|base
argument_list|,
name|handle
argument_list|,
name|TYPE_AAAA
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|callback
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handle
operator|->
name|current_req
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|handle
operator|=
name|NULL
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|handle
return|;
block|}
end_function

begin_function
name|int
name|evdns_resolve_ipv6
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|callback
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|evdns_base_resolve_ipv6
argument_list|(
name|current_base
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|callback
argument_list|,
name|ptr
argument_list|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|evdns_request
modifier|*
name|evdns_base_resolve_reverse
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|in_addr
modifier|*
name|in
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|callback
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|evdns_request
modifier|*
name|handle
decl_stmt|;
name|struct
name|request
modifier|*
name|req
decl_stmt|;
name|u32
name|a
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|a
operator|=
name|ntohl
argument_list|(
name|in
operator|->
name|s_addr
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d.%d.%d.%d.in-addr.arpa"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|u8
argument_list|)
argument_list|(
operator|(
name|a
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|u8
argument_list|)
argument_list|(
operator|(
name|a
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|u8
argument_list|)
argument_list|(
operator|(
name|a
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|u8
argument_list|)
argument_list|(
operator|(
name|a
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|handle
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Resolve requested for %s (reverse)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|req
operator|=
name|request_new
argument_list|(
name|base
argument_list|,
name|handle
argument_list|,
name|TYPE_PTR
argument_list|,
name|buf
argument_list|,
name|flags
argument_list|,
name|callback
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
name|request_submit
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|current_req
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|handle
operator|=
name|NULL
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|handle
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evdns_resolve_reverse
parameter_list|(
specifier|const
name|struct
name|in_addr
modifier|*
name|in
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|callback
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|evdns_base_resolve_reverse
argument_list|(
name|current_base
argument_list|,
name|in
argument_list|,
name|flags
argument_list|,
name|callback
argument_list|,
name|ptr
argument_list|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|evdns_request
modifier|*
name|evdns_base_resolve_reverse_ipv6
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|in
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|callback
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
comment|/* 32 nybbles, 32 periods, "ip6.arpa", NUL. */
name|char
name|buf
index|[
literal|73
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|evdns_request
modifier|*
name|handle
decl_stmt|;
name|struct
name|request
modifier|*
name|req
decl_stmt|;
name|int
name|i
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|u8
name|byte
init|=
name|in
operator|->
name|s6_addr
index|[
name|i
index|]
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|"0123456789abcdef"
index|[
name|byte
operator|&
literal|0x0f
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|"0123456789abcdef"
index|[
name|byte
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
name|EVUTIL_ASSERT
argument_list|(
name|cp
operator|+
name|strlen
argument_list|(
literal|"ip6.arpa"
argument_list|)
operator|<
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
literal|"ip6.arpa"
argument_list|,
name|strlen
argument_list|(
literal|"ip6.arpa"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|handle
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Resolve requested for %s (reverse)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|req
operator|=
name|request_new
argument_list|(
name|base
argument_list|,
name|handle
argument_list|,
name|TYPE_PTR
argument_list|,
name|buf
argument_list|,
name|flags
argument_list|,
name|callback
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
name|request_submit
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|current_req
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|handle
operator|=
name|NULL
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|handle
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evdns_resolve_reverse_ipv6
parameter_list|(
specifier|const
name|struct
name|in6_addr
modifier|*
name|in
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|callback
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|evdns_base_resolve_reverse_ipv6
argument_list|(
name|current_base
argument_list|,
name|in
argument_list|,
name|flags
argument_list|,
name|callback
argument_list|,
name|ptr
argument_list|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ================================================================= */
end_comment

begin_comment
comment|/* Search support */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* the libc resolver has support for searching a number of domains */
end_comment

begin_comment
comment|/* to find a name. If nothing else then it takes the single domain */
end_comment

begin_comment
comment|/* from the gethostname() call. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* It can also be configured via the domain and search options in a */
end_comment

begin_comment
comment|/* resolv.conf. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* The ndots option controls how many dots it takes for the resolver */
end_comment

begin_comment
comment|/* to decide that a name is non-local and so try a raw lookup first. */
end_comment

begin_struct
struct|struct
name|search_domain
block|{
name|int
name|len
decl_stmt|;
name|struct
name|search_domain
modifier|*
name|next
decl_stmt|;
comment|/* the text string is appended to this structure */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|search_state
block|{
name|int
name|refcount
decl_stmt|;
name|int
name|ndots
decl_stmt|;
name|int
name|num_domains
decl_stmt|;
name|struct
name|search_domain
modifier|*
name|head
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|search_state_decref
parameter_list|(
name|struct
name|search_state
modifier|*
specifier|const
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
condition|)
return|return;
name|state
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|refcount
condition|)
block|{
name|struct
name|search_domain
modifier|*
name|next
decl_stmt|,
modifier|*
name|dom
decl_stmt|;
for|for
control|(
name|dom
operator|=
name|state
operator|->
name|head
init|;
name|dom
condition|;
name|dom
operator|=
name|next
control|)
block|{
name|next
operator|=
name|dom
operator|->
name|next
expr_stmt|;
name|mm_free
argument_list|(
name|dom
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|search_state
modifier|*
name|search_state_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|search_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|search_state
operator|*
operator|)
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|search_state
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|search_state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|ndots
operator|=
literal|1
expr_stmt|;
return|return
name|state
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|search_postfix_clear
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|search_state_decref
argument_list|(
name|base
operator|->
name|global_search_state
argument_list|)
expr_stmt|;
name|base
operator|->
name|global_search_state
operator|=
name|search_state_new
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|void
name|evdns_base_search_clear
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|search_postfix_clear
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdns_search_clear
parameter_list|(
name|void
parameter_list|)
block|{
name|evdns_base_search_clear
argument_list|(
name|current_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|search_postfix_add
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|)
block|{
name|size_t
name|domain_len
decl_stmt|;
name|struct
name|search_domain
modifier|*
name|sdomain
decl_stmt|;
while|while
condition|(
name|domain
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|domain
operator|++
expr_stmt|;
name|domain_len
operator|=
name|strlen
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|global_search_state
condition|)
name|base
operator|->
name|global_search_state
operator|=
name|search_state_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|global_search_state
condition|)
return|return;
name|base
operator|->
name|global_search_state
operator|->
name|num_domains
operator|++
expr_stmt|;
name|sdomain
operator|=
operator|(
expr|struct
name|search_domain
operator|*
operator|)
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|search_domain
argument_list|)
operator|+
name|domain_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdomain
condition|)
return|return;
name|memcpy
argument_list|(
operator|(
operator|(
name|u8
operator|*
operator|)
name|sdomain
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|search_domain
argument_list|)
argument_list|,
name|domain
argument_list|,
name|domain_len
argument_list|)
expr_stmt|;
name|sdomain
operator|->
name|next
operator|=
name|base
operator|->
name|global_search_state
operator|->
name|head
expr_stmt|;
name|sdomain
operator|->
name|len
operator|=
operator|(
name|int
operator|)
name|domain_len
expr_stmt|;
name|base
operator|->
name|global_search_state
operator|->
name|head
operator|=
name|sdomain
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reverse the order of members in the postfix list. This is needed because, */
end_comment

begin_comment
comment|/* when parsing resolv.conf we push elements in the wrong order */
end_comment

begin_function
specifier|static
name|void
name|search_reverse
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|search_domain
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|cur
operator|=
name|base
operator|->
name|global_search_state
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
block|}
name|base
operator|->
name|global_search_state
operator|->
name|head
operator|=
name|prev
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|void
name|evdns_base_search_add
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|)
block|{
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|search_postfix_add
argument_list|(
name|base
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdns_search_add
parameter_list|(
specifier|const
name|char
modifier|*
name|domain
parameter_list|)
block|{
name|evdns_base_search_add
argument_list|(
name|current_base
argument_list|,
name|domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|void
name|evdns_base_search_ndots_set
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|int
name|ndots
parameter_list|)
block|{
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|global_search_state
condition|)
name|base
operator|->
name|global_search_state
operator|=
name|search_state_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|global_search_state
condition|)
name|base
operator|->
name|global_search_state
operator|->
name|ndots
operator|=
name|ndots
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdns_search_ndots_set
parameter_list|(
specifier|const
name|int
name|ndots
parameter_list|)
block|{
name|evdns_base_search_ndots_set
argument_list|(
name|current_base
argument_list|,
name|ndots
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|search_set_from_hostname
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|char
name|hostname
index|[
name|HOST_NAME_MAX
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|domainname
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|search_postfix_clear
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
condition|)
return|return;
name|domainname
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|domainname
condition|)
return|return;
name|search_postfix_add
argument_list|(
name|base
argument_list|,
name|domainname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* warning: returns malloced string */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|search_make_new
parameter_list|(
specifier|const
name|struct
name|search_state
modifier|*
specifier|const
name|state
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|base_name
parameter_list|)
block|{
specifier|const
name|size_t
name|base_len
init|=
name|strlen
argument_list|(
name|base_name
argument_list|)
decl_stmt|;
specifier|const
name|char
name|need_to_append_dot
init|=
name|base_name
index|[
name|base_len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|struct
name|search_domain
modifier|*
name|dom
decl_stmt|;
for|for
control|(
name|dom
operator|=
name|state
operator|->
name|head
init|;
name|dom
condition|;
name|dom
operator|=
name|dom
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|n
operator|--
condition|)
block|{
comment|/* this is the postfix we want */
comment|/* the actual postfix string is kept at the end of the structure */
specifier|const
name|u8
modifier|*
specifier|const
name|postfix
init|=
operator|(
operator|(
name|u8
operator|*
operator|)
name|dom
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|search_domain
argument_list|)
decl_stmt|;
specifier|const
name|int
name|postfix_len
init|=
name|dom
operator|->
name|len
decl_stmt|;
name|char
modifier|*
specifier|const
name|newname
init|=
operator|(
name|char
operator|*
operator|)
name|mm_malloc
argument_list|(
name|base_len
operator|+
name|need_to_append_dot
operator|+
name|postfix_len
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newname
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|newname
argument_list|,
name|base_name
argument_list|,
name|base_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_to_append_dot
condition|)
name|newname
index|[
name|base_len
index|]
operator|=
literal|'.'
expr_stmt|;
name|memcpy
argument_list|(
name|newname
operator|+
name|base_len
operator|+
name|need_to_append_dot
argument_list|,
name|postfix
argument_list|,
name|postfix_len
argument_list|)
expr_stmt|;
name|newname
index|[
name|base_len
operator|+
name|need_to_append_dot
operator|+
name|postfix_len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|newname
return|;
block|}
block|}
comment|/* we ran off the end of the list and still didn't find the requested string */
name|EVUTIL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* unreachable; stops warnings in some compilers. */
block|}
end_function

begin_function
specifier|static
name|struct
name|request
modifier|*
name|search_request_new
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|struct
name|evdns_request
modifier|*
name|handle
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|evdns_callback_type
name|user_callback
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|type
operator|==
name|TYPE_A
operator|||
name|type
operator|==
name|TYPE_AAAA
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|handle
operator|->
name|current_req
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|DNS_QUERY_NO_SEARCH
operator|)
operator|==
literal|0
operator|)
operator|&&
name|base
operator|->
name|global_search_state
operator|&&
name|base
operator|->
name|global_search_state
operator|->
name|num_domains
condition|)
block|{
comment|/* we have some domains to search */
name|struct
name|request
modifier|*
name|req
decl_stmt|;
if|if
condition|(
name|string_num_dots
argument_list|(
name|name
argument_list|)
operator|>=
name|base
operator|->
name|global_search_state
operator|->
name|ndots
condition|)
block|{
name|req
operator|=
name|request_new
argument_list|(
name|base
argument_list|,
name|handle
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|user_callback
argument_list|,
name|user_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
return|return
name|NULL
return|;
name|handle
operator|->
name|search_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
specifier|const
name|new_name
init|=
name|search_make_new
argument_list|(
name|base
operator|->
name|global_search_state
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new_name
condition|)
return|return
name|NULL
return|;
name|req
operator|=
name|request_new
argument_list|(
name|base
argument_list|,
name|handle
argument_list|,
name|type
argument_list|,
name|new_name
argument_list|,
name|flags
argument_list|,
name|user_callback
argument_list|,
name|user_arg
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
return|return
name|NULL
return|;
name|handle
operator|->
name|search_index
operator|=
literal|0
expr_stmt|;
block|}
name|EVUTIL_ASSERT
argument_list|(
name|handle
operator|->
name|search_origname
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|handle
operator|->
name|search_origname
operator|=
name|mm_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|search_origname
operator|==
name|NULL
condition|)
block|{
comment|/* XXX Should we dealloc req? If yes, how? */
if|if
condition|(
name|req
condition|)
name|mm_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|handle
operator|->
name|search_state
operator|=
name|base
operator|->
name|global_search_state
expr_stmt|;
name|handle
operator|->
name|search_flags
operator|=
name|flags
expr_stmt|;
name|base
operator|->
name|global_search_state
operator|->
name|refcount
operator|++
expr_stmt|;
name|request_submit
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
name|req
return|;
block|}
else|else
block|{
name|struct
name|request
modifier|*
specifier|const
name|req
init|=
name|request_new
argument_list|(
name|base
argument_list|,
name|handle
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|user_callback
argument_list|,
name|user_arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
return|return
name|NULL
return|;
name|request_submit
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
name|req
return|;
block|}
block|}
end_function

begin_comment
comment|/* this is called when a request has failed to find a name. We need to check */
end_comment

begin_comment
comment|/* if it is part of a search and, if so, try the next name in the list */
end_comment

begin_comment
comment|/* returns: */
end_comment

begin_comment
comment|/*   0 another request has been submitted */
end_comment

begin_comment
comment|/*   1 no more requests needed */
end_comment

begin_function
specifier|static
name|int
name|search_try_next
parameter_list|(
name|struct
name|evdns_request
modifier|*
specifier|const
name|handle
parameter_list|)
block|{
name|struct
name|request
modifier|*
name|req
init|=
name|handle
operator|->
name|current_req
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|base
init|=
name|req
operator|->
name|base
decl_stmt|;
name|struct
name|request
modifier|*
name|newreq
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|search_state
condition|)
block|{
comment|/* it is part of a search */
name|char
modifier|*
name|new_name
decl_stmt|;
name|handle
operator|->
name|search_index
operator|++
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|search_index
operator|>=
name|handle
operator|->
name|search_state
operator|->
name|num_domains
condition|)
block|{
comment|/* no more postfixes to try, however we may need to try */
comment|/* this name without a postfix */
if|if
condition|(
name|string_num_dots
argument_list|(
name|handle
operator|->
name|search_origname
argument_list|)
operator|<
name|handle
operator|->
name|search_state
operator|->
name|ndots
condition|)
block|{
comment|/* yep, we need to try it raw */
name|newreq
operator|=
name|request_new
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|,
name|req
operator|->
name|request_type
argument_list|,
name|handle
operator|->
name|search_origname
argument_list|,
name|handle
operator|->
name|search_flags
argument_list|,
name|req
operator|->
name|user_callback
argument_list|,
name|req
operator|->
name|user_pointer
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Search: trying raw query %s"
argument_list|,
name|handle
operator|->
name|search_origname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newreq
condition|)
block|{
name|search_request_finished
argument_list|(
name|handle
argument_list|)
expr_stmt|;
goto|goto
name|submit_next
goto|;
block|}
block|}
return|return
literal|1
return|;
block|}
name|new_name
operator|=
name|search_make_new
argument_list|(
name|handle
operator|->
name|search_state
argument_list|,
name|handle
operator|->
name|search_index
argument_list|,
name|handle
operator|->
name|search_origname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_name
condition|)
return|return
literal|1
return|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Search: now trying %s (%d)"
argument_list|,
name|new_name
argument_list|,
name|handle
operator|->
name|search_index
argument_list|)
expr_stmt|;
name|newreq
operator|=
name|request_new
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|,
name|req
operator|->
name|request_type
argument_list|,
name|new_name
argument_list|,
name|handle
operator|->
name|search_flags
argument_list|,
name|req
operator|->
name|user_callback
argument_list|,
name|req
operator|->
name|user_pointer
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newreq
condition|)
return|return
literal|1
return|;
goto|goto
name|submit_next
goto|;
block|}
return|return
literal|1
return|;
name|submit_next
label|:
name|request_finished
argument_list|(
name|req
argument_list|,
operator|&
name|REQ_HEAD
argument_list|(
name|req
operator|->
name|base
argument_list|,
name|req
operator|->
name|trans_id
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|handle
operator|->
name|current_req
operator|=
name|newreq
expr_stmt|;
name|newreq
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
name|request_submit
argument_list|(
name|newreq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|search_request_finished
parameter_list|(
name|struct
name|evdns_request
modifier|*
specifier|const
name|handle
parameter_list|)
block|{
name|ASSERT_LOCKED
argument_list|(
name|handle
operator|->
name|current_req
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|search_state
condition|)
block|{
name|search_state_decref
argument_list|(
name|handle
operator|->
name|search_state
argument_list|)
expr_stmt|;
name|handle
operator|->
name|search_state
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|handle
operator|->
name|search_origname
condition|)
block|{
name|mm_free
argument_list|(
name|handle
operator|->
name|search_origname
argument_list|)
expr_stmt|;
name|handle
operator|->
name|search_origname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ================================================================= */
end_comment

begin_comment
comment|/* Parsing resolv.conf files */
end_comment

begin_function
specifier|static
name|void
name|evdns_resolv_set_defaults
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* if the file isn't found then we assume a local resolver */
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DNS_OPTION_SEARCH
condition|)
name|search_set_from_hostname
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DNS_OPTION_NAMESERVERS
condition|)
name|evdns_base_nameserver_ip_add
argument_list|(
name|base
argument_list|,
literal|"127.0.0.1"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__HAVE_STRTOK_R
end_ifndef

begin_function
specifier|static
name|char
modifier|*
name|strtok_r
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
name|char
modifier|*
modifier|*
name|state
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|start
operator|=
name|cp
operator|=
name|s
condition|?
name|s
else|:
operator|*
name|state
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|strchr
argument_list|(
name|delim
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|cp
operator|==
name|start
condition|)
return|return
name|NULL
return|;
operator|*
name|state
operator|=
name|NULL
expr_stmt|;
return|return
name|start
return|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|state
operator|=
name|cp
expr_stmt|;
return|return
name|start
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* helper version of atoi which returns -1 on error */
end_comment

begin_function
specifier|static
name|int
name|strtoint
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|str
parameter_list|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
specifier|const
name|int
name|r
init|=
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|endptr
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Parse a number of seconds into a timeval; return -1 on error. */
end_comment

begin_function
specifier|static
name|int
name|evdns_strtotimeval
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|str
parameter_list|,
name|struct
name|timeval
modifier|*
name|out
parameter_list|)
block|{
name|double
name|d
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|d
operator|=
name|strtod
argument_list|(
name|str
argument_list|,
operator|&
name|endptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|out
operator|->
name|tv_sec
operator|=
operator|(
name|int
operator|)
name|d
expr_stmt|;
name|out
operator|->
name|tv_usec
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|d
operator|-
operator|(
name|int
operator|)
name|d
operator|)
operator|*
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|->
name|tv_sec
operator|==
literal|0
operator|&&
name|out
operator|->
name|tv_usec
operator|<
literal|1000
condition|)
comment|/* less than 1 msec */
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* helper version of atoi that returns -1 on error and clips to bounds. */
end_comment

begin_function
specifier|static
name|int
name|strtoint_clipped
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|str
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|r
init|=
name|strtoint
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
return|return
name|r
return|;
elseif|else
if|if
condition|(
name|r
operator|<
name|min
condition|)
return|return
name|min
return|;
elseif|else
if|if
condition|(
name|r
operator|>
name|max
condition|)
return|return
name|max
return|;
else|else
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdns_base_set_max_requests_inflight
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|int
name|maxinflight
parameter_list|)
block|{
name|int
name|old_n_heads
init|=
name|base
operator|->
name|n_req_heads
decl_stmt|,
name|n_heads
decl_stmt|;
name|struct
name|request
modifier|*
modifier|*
name|old_heads
init|=
name|base
operator|->
name|req_heads
decl_stmt|,
modifier|*
modifier|*
name|new_heads
decl_stmt|,
modifier|*
name|req
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxinflight
operator|<
literal|1
condition|)
name|maxinflight
operator|=
literal|1
expr_stmt|;
name|n_heads
operator|=
operator|(
name|maxinflight
operator|+
literal|4
operator|)
operator|/
literal|5
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|n_heads
operator|>
literal|0
argument_list|)
expr_stmt|;
name|new_heads
operator|=
name|mm_calloc
argument_list|(
name|n_heads
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|request
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_heads
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|old_heads
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_n_heads
condition|;
operator|++
name|i
control|)
block|{
while|while
condition|(
name|old_heads
index|[
name|i
index|]
condition|)
block|{
name|req
operator|=
name|old_heads
index|[
name|i
index|]
expr_stmt|;
name|evdns_request_remove
argument_list|(
name|req
argument_list|,
operator|&
name|old_heads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|evdns_request_insert
argument_list|(
name|req
argument_list|,
operator|&
name|new_heads
index|[
name|req
operator|->
name|trans_id
operator|%
name|n_heads
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|mm_free
argument_list|(
name|old_heads
argument_list|)
expr_stmt|;
block|}
name|base
operator|->
name|req_heads
operator|=
name|new_heads
expr_stmt|;
name|base
operator|->
name|n_req_heads
operator|=
name|n_heads
expr_stmt|;
name|base
operator|->
name|global_max_requests_inflight
operator|=
name|maxinflight
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_function
name|int
name|evdns_base_set_option
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|res
operator|=
name|evdns_base_set_option_impl
argument_list|(
name|base
argument_list|,
name|option
argument_list|,
name|val
argument_list|,
name|DNS_OPTIONS_ALL
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|str_matches_option
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|optionname
parameter_list|)
block|{
comment|/* Option names are given as "option:" We accept either 'option' in 	 * s1, or 'option:randomjunk'.  The latter form is to implement the 	 * resolv.conf parser. */
name|size_t
name|optlen
init|=
name|strlen
argument_list|(
name|optionname
argument_list|)
decl_stmt|;
name|size_t
name|slen
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|;
if|if
condition|(
name|slen
operator|==
name|optlen
operator|||
name|slen
operator|==
name|optlen
operator|-
literal|1
condition|)
return|return
operator|!
name|strncmp
argument_list|(
name|s1
argument_list|,
name|optionname
argument_list|,
name|slen
argument_list|)
return|;
elseif|else
if|if
condition|(
name|slen
operator|>
name|optlen
condition|)
return|return
operator|!
name|strncmp
argument_list|(
name|s1
argument_list|,
name|optionname
argument_list|,
name|optlen
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdns_base_set_option_impl
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_matches_option
argument_list|(
name|option
argument_list|,
literal|"ndots:"
argument_list|)
condition|)
block|{
specifier|const
name|int
name|ndots
init|=
name|strtoint
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|ndots
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNS_OPTION_SEARCH
operator|)
condition|)
return|return
literal|0
return|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Setting ndots to %d"
argument_list|,
name|ndots
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|global_search_state
condition|)
name|base
operator|->
name|global_search_state
operator|=
name|search_state_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|global_search_state
condition|)
return|return
operator|-
literal|1
return|;
name|base
operator|->
name|global_search_state
operator|->
name|ndots
operator|=
name|ndots
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_matches_option
argument_list|(
name|option
argument_list|,
literal|"timeout:"
argument_list|)
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|evdns_strtotimeval
argument_list|(
name|val
argument_list|,
operator|&
name|tv
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNS_OPTION_MISC
operator|)
condition|)
return|return
literal|0
return|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Setting timeout to %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|base
operator|->
name|global_timeout
argument_list|,
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_matches_option
argument_list|(
name|option
argument_list|,
literal|"getaddrinfo-allow-skew:"
argument_list|)
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|evdns_strtotimeval
argument_list|(
name|val
argument_list|,
operator|&
name|tv
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNS_OPTION_MISC
operator|)
condition|)
return|return
literal|0
return|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Setting getaddrinfo-allow-skew to %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|base
operator|->
name|global_getaddrinfo_allow_skew
argument_list|,
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_matches_option
argument_list|(
name|option
argument_list|,
literal|"max-timeouts:"
argument_list|)
condition|)
block|{
specifier|const
name|int
name|maxtimeout
init|=
name|strtoint_clipped
argument_list|(
name|val
argument_list|,
literal|1
argument_list|,
literal|255
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxtimeout
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNS_OPTION_MISC
operator|)
condition|)
return|return
literal|0
return|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Setting maximum allowed timeouts to %d"
argument_list|,
name|maxtimeout
argument_list|)
expr_stmt|;
name|base
operator|->
name|global_max_nameserver_timeout
operator|=
name|maxtimeout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_matches_option
argument_list|(
name|option
argument_list|,
literal|"max-inflight:"
argument_list|)
condition|)
block|{
specifier|const
name|int
name|maxinflight
init|=
name|strtoint_clipped
argument_list|(
name|val
argument_list|,
literal|1
argument_list|,
literal|65000
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxinflight
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNS_OPTION_MISC
operator|)
condition|)
return|return
literal|0
return|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Setting maximum inflight requests to %d"
argument_list|,
name|maxinflight
argument_list|)
expr_stmt|;
name|evdns_base_set_max_requests_inflight
argument_list|(
name|base
argument_list|,
name|maxinflight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_matches_option
argument_list|(
name|option
argument_list|,
literal|"attempts:"
argument_list|)
condition|)
block|{
name|int
name|retries
init|=
name|strtoint
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|retries
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|retries
operator|>
literal|255
condition|)
name|retries
operator|=
literal|255
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNS_OPTION_MISC
operator|)
condition|)
return|return
literal|0
return|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Setting retries to %d"
argument_list|,
name|retries
argument_list|)
expr_stmt|;
name|base
operator|->
name|global_max_retransmits
operator|=
name|retries
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_matches_option
argument_list|(
name|option
argument_list|,
literal|"randomize-case:"
argument_list|)
condition|)
block|{
name|int
name|randcase
init|=
name|strtoint
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNS_OPTION_MISC
operator|)
condition|)
return|return
literal|0
return|;
name|base
operator|->
name|global_randomize_case
operator|=
name|randcase
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_matches_option
argument_list|(
name|option
argument_list|,
literal|"bind-to:"
argument_list|)
condition|)
block|{
comment|/* XXX This only applies to successive nameservers, not 		 * to already-configured ones.	We might want to fix that. */
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|base
operator|->
name|global_outgoing_address
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNS_OPTION_NAMESERVERS
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|evutil_parse_sockaddr_port
argument_list|(
name|val
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|base
operator|->
name|global_outgoing_address
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|base
operator|->
name|global_outgoing_addrlen
operator|=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_matches_option
argument_list|(
name|option
argument_list|,
literal|"initial-probe-timeout:"
argument_list|)
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|evdns_strtotimeval
argument_list|(
name|val
argument_list|,
operator|&
name|tv
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|>
literal|3600
condition|)
name|tv
operator|.
name|tv_sec
operator|=
literal|3600
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNS_OPTION_MISC
operator|)
condition|)
return|return
literal|0
return|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Setting initial probe timeout to %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|base
operator|->
name|global_nameserver_probe_initial_timeout
argument_list|,
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evdns_set_option
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|current_base
condition|)
name|current_base
operator|=
name|evdns_base_new
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|evdns_base_set_option
argument_list|(
name|current_base
argument_list|,
name|option
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resolv_conf_parse_line
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|char
modifier|*
specifier|const
name|start
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|strtok_state
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|delims
init|=
literal|" \t"
decl_stmt|;
define|#
directive|define
name|NEXT_TOKEN
value|strtok_r(NULL, delims,&strtok_state)
name|char
modifier|*
specifier|const
name|first_token
init|=
name|strtok_r
argument_list|(
name|start
argument_list|,
name|delims
argument_list|,
operator|&
name|strtok_state
argument_list|)
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first_token
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|first_token
argument_list|,
literal|"nameserver"
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|DNS_OPTION_NAMESERVERS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|nameserver
init|=
name|NEXT_TOKEN
decl_stmt|;
if|if
condition|(
name|nameserver
condition|)
name|evdns_base_nameserver_ip_add
argument_list|(
name|base
argument_list|,
name|nameserver
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|first_token
argument_list|,
literal|"domain"
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|DNS_OPTION_SEARCH
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|domain
init|=
name|NEXT_TOKEN
decl_stmt|;
if|if
condition|(
name|domain
condition|)
block|{
name|search_postfix_clear
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|search_postfix_add
argument_list|(
name|base
argument_list|,
name|domain
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|first_token
argument_list|,
literal|"search"
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|DNS_OPTION_SEARCH
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|domain
decl_stmt|;
name|search_postfix_clear
argument_list|(
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|domain
operator|=
name|NEXT_TOKEN
operator|)
condition|)
block|{
name|search_postfix_add
argument_list|(
name|base
argument_list|,
name|domain
argument_list|)
expr_stmt|;
block|}
name|search_reverse
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|first_token
argument_list|,
literal|"options"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|option
decl_stmt|;
while|while
condition|(
operator|(
name|option
operator|=
name|NEXT_TOKEN
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|evdns_base_set_option_impl
argument_list|(
name|base
argument_list|,
name|option
argument_list|,
name|val
condition|?
name|val
operator|+
literal|1
else|:
literal|""
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|NEXT_TOKEN
block|}
end_function

begin_comment
comment|/* exported function */
end_comment

begin_comment
comment|/* returns: */
end_comment

begin_comment
comment|/*   0 no errors */
end_comment

begin_comment
comment|/*   1 failed to open file */
end_comment

begin_comment
comment|/*   2 failed to stat file */
end_comment

begin_comment
comment|/*   3 file too large */
end_comment

begin_comment
comment|/*   4 out of memory */
end_comment

begin_comment
comment|/*   5 short read from file */
end_comment

begin_function
name|int
name|evdns_base_resolv_conf_parse
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|filename
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|res
operator|=
name|evdns_base_resolv_conf_parse_impl
argument_list|(
name|base
argument_list|,
name|flags
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|evdns_get_default_hosts_filename
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
comment|/* Windows is a little coy about where it puts its configuration 	 * files.  Sure, they're _usually_ in C:\windows\system32, but 	 * there's no reason in principle they couldn't be in 	 * W:\hoboken chicken emergency\ 	 */
name|char
name|path
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
name|hostfile
index|[]
init|=
literal|"\\drivers\\etc\\hosts"
decl_stmt|;
name|char
modifier|*
name|path_out
decl_stmt|;
name|size_t
name|len_out
decl_stmt|;
if|if
condition|(
operator|!
name|SHGetSpecialFolderPathA
argument_list|(
name|NULL
argument_list|,
name|path
argument_list|,
name|CSIDL_SYSTEM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|len_out
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|hostfile
argument_list|)
operator|+
literal|1
expr_stmt|;
name|path_out
operator|=
name|mm_malloc
argument_list|(
name|len_out
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|path_out
argument_list|,
name|len_out
argument_list|,
literal|"%s%s"
argument_list|,
name|path
argument_list|,
name|hostfile
argument_list|)
expr_stmt|;
return|return
name|path_out
return|;
else|#
directive|else
return|return
name|mm_strdup
argument_list|(
literal|"/etc/hosts"
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|evdns_base_resolv_conf_parse_impl
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|filename
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|char
modifier|*
name|resolv
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Parsing resolv.conf file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DNS_OPTION_HOSTSFILE
condition|)
block|{
name|char
modifier|*
name|fname
init|=
name|evdns_get_default_hosts_filename
argument_list|()
decl_stmt|;
name|evdns_base_load_hosts
argument_list|(
name|base
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
name|mm_free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|evutil_read_file_
argument_list|(
name|filename
argument_list|,
operator|&
name|resolv
argument_list|,
operator|&
name|n
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No file. */
name|evdns_resolv_set_defaults
argument_list|(
name|base
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|2
return|;
block|}
block|}
name|start
operator|=
name|resolv
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
specifier|const
name|newline
init|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newline
condition|)
block|{
name|resolv_conf_parse_line
argument_list|(
name|base
argument_list|,
name|start
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|newline
operator|=
literal|0
expr_stmt|;
name|resolv_conf_parse_line
argument_list|(
name|base
argument_list|,
name|start
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|start
operator|=
name|newline
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|base
operator|->
name|server_head
operator|&&
operator|(
name|flags
operator|&
name|DNS_OPTION_NAMESERVERS
operator|)
condition|)
block|{
comment|/* no nameservers were configured. */
name|evdns_base_nameserver_ip_add
argument_list|(
name|base
argument_list|,
literal|"127.0.0.1"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DNS_OPTION_SEARCH
operator|&&
operator|(
operator|!
name|base
operator|->
name|global_search_state
operator|||
name|base
operator|->
name|global_search_state
operator|->
name|num_domains
operator|==
literal|0
operator|)
condition|)
block|{
name|search_set_from_hostname
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|resolv
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|evdns_resolv_conf_parse
parameter_list|(
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|filename
parameter_list|)
block|{
if|if
condition|(
operator|!
name|current_base
condition|)
name|current_base
operator|=
name|evdns_base_new
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|evdns_base_resolv_conf_parse
argument_list|(
name|current_base
argument_list|,
name|flags
argument_list|,
name|filename
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_comment
comment|/* Add multiple nameservers from a space-or-comma-separated list. */
end_comment

begin_function
specifier|static
name|int
name|evdns_nameserver_ip_add_line
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|ips
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|r
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ips
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|ips
argument_list|)
operator|||
operator|*
name|ips
operator|==
literal|','
operator|||
operator|*
name|ips
operator|==
literal|'\t'
condition|)
operator|++
name|ips
expr_stmt|;
name|addr
operator|=
name|ips
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|ips
argument_list|)
operator|||
operator|*
name|ips
operator|==
literal|'.'
operator|||
operator|*
name|ips
operator|==
literal|':'
operator|||
operator|*
name|ips
operator|==
literal|'['
operator|||
operator|*
name|ips
operator|==
literal|']'
condition|)
operator|++
name|ips
expr_stmt|;
name|buf
operator|=
name|mm_malloc
argument_list|(
name|ips
operator|-
name|addr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
literal|4
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|addr
argument_list|,
name|ips
operator|-
name|addr
argument_list|)
expr_stmt|;
name|buf
index|[
name|ips
operator|-
name|addr
index|]
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|evdns_base_nameserver_ip_add
argument_list|(
name|base
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|DWORD
function_decl|(
name|WINAPI
modifier|*
name|GetNetworkParams_fn_t
function_decl|)
parameter_list|(
name|FIXED_INFO
modifier|*
parameter_list|,
name|DWORD
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Use the windows GetNetworkParams interface in iphlpapi.dll to */
end_comment

begin_comment
comment|/* figure out what our nameservers are. */
end_comment

begin_function
specifier|static
name|int
name|load_nameservers_with_getnetworkparams
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
comment|/* Based on MSDN examples and inspection of  c-ares code. */
name|FIXED_INFO
modifier|*
name|fixed
decl_stmt|;
name|HMODULE
name|handle
init|=
literal|0
decl_stmt|;
name|ULONG
name|size
init|=
sizeof|sizeof
argument_list|(
name|FIXED_INFO
argument_list|)
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|,
name|r
decl_stmt|,
name|added_any
decl_stmt|;
name|IP_ADDR_STRING
modifier|*
name|ns
decl_stmt|;
name|GetNetworkParams_fn_t
name|fn
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|handle
operator|=
name|evutil_load_windows_system_library_
argument_list|(
name|TEXT
argument_list|(
literal|"iphlpapi.dll"
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Could not open iphlpapi.dll"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|fn
operator|=
operator|(
name|GetNetworkParams_fn_t
operator|)
name|GetProcAddress
argument_list|(
name|handle
argument_list|,
literal|"GetNetworkParams"
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Could not get address of function."
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|buf
operator|=
name|mm_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|status
operator|=
literal|4
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fixed
operator|=
name|buf
expr_stmt|;
name|r
operator|=
name|fn
argument_list|(
name|fixed
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ERROR_SUCCESS
operator|&&
name|r
operator|!=
name|ERROR_BUFFER_OVERFLOW
condition|)
block|{
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|r
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|mm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|mm_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|status
operator|=
literal|4
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fixed
operator|=
name|buf
expr_stmt|;
name|r
operator|=
name|fn
argument_list|(
name|fixed
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"fn() failed."
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|EVUTIL_ASSERT
argument_list|(
name|fixed
argument_list|)
expr_stmt|;
name|added_any
operator|=
literal|0
expr_stmt|;
name|ns
operator|=
operator|&
operator|(
name|fixed
operator|->
name|DnsServerList
operator|)
expr_stmt|;
while|while
condition|(
name|ns
condition|)
block|{
name|r
operator|=
name|evdns_nameserver_ip_add_line
argument_list|(
name|base
argument_list|,
name|ns
operator|->
name|IpAddress
operator|.
name|String
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Could not add nameserver %s to list,error: %d"
argument_list|,
operator|(
name|ns
operator|->
name|IpAddress
operator|.
name|String
operator|)
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
operator|++
name|added_any
expr_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Successfully added %s as nameserver"
argument_list|,
name|ns
operator|->
name|IpAddress
operator|.
name|String
argument_list|)
expr_stmt|;
block|}
name|ns
operator|=
name|ns
operator|->
name|Next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|added_any
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"No nameservers added."
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|buf
condition|)
name|mm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
condition|)
name|FreeLibrary
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|config_nameserver_from_reg_key
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|HKEY
name|key
parameter_list|,
specifier|const
name|TCHAR
modifier|*
name|subkey
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|DWORD
name|bufsz
init|=
literal|0
decl_stmt|,
name|type
init|=
literal|0
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|RegQueryValueEx
argument_list|(
name|key
argument_list|,
name|subkey
argument_list|,
literal|0
argument_list|,
operator|&
name|type
argument_list|,
name|NULL
argument_list|,
operator|&
name|bufsz
argument_list|)
operator|!=
name|ERROR_MORE_DATA
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|buf
operator|=
name|mm_malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|RegQueryValueEx
argument_list|(
name|key
argument_list|,
name|subkey
argument_list|,
literal|0
argument_list|,
operator|&
name|type
argument_list|,
operator|(
name|LPBYTE
operator|)
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|)
operator|==
name|ERROR_SUCCESS
operator|&&
name|bufsz
operator|>
literal|1
condition|)
block|{
name|status
operator|=
name|evdns_nameserver_ip_add_line
argument_list|(
name|base
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SERVICES_KEY
value|TEXT("System\\CurrentControlSet\\Services\\")
end_define

begin_define
define|#
directive|define
name|WIN_NS_9X_KEY
value|SERVICES_KEY TEXT("VxD\\MSTCP")
end_define

begin_define
define|#
directive|define
name|WIN_NS_NT_KEY
value|SERVICES_KEY TEXT("Tcpip\\Parameters")
end_define

begin_function
specifier|static
name|int
name|load_nameservers_from_registry
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
define|#
directive|define
name|TRY
parameter_list|(
name|k
parameter_list|,
name|name
parameter_list|)
define|\
value|if (!found&& config_nameserver_from_reg_key(base,k,TEXT(name)) == 0) { \ 		log(EVDNS_LOG_DEBUG,"Found nameservers in %s/%s",#k,name); \ 		found = 1;						\ 	} else if (!found) {						\ 		log(EVDNS_LOG_DEBUG,"Didn't find nameservers in %s/%s", \ 		    #k,#name);						\ 	}
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|GetVersion
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* NT */
name|HKEY
name|nt_key
init|=
literal|0
decl_stmt|,
name|interfaces_key
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|RegOpenKeyEx
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|WIN_NS_NT_KEY
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
operator|&
name|nt_key
argument_list|)
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Couldn't open nt key, %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|r
operator|=
name|RegOpenKeyEx
argument_list|(
name|nt_key
argument_list|,
name|TEXT
argument_list|(
literal|"Interfaces"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|KEY_QUERY_VALUE
operator||
name|KEY_ENUMERATE_SUB_KEYS
argument_list|,
operator|&
name|interfaces_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Couldn't open interfaces key, %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|TRY
argument_list|(
name|nt_key
argument_list|,
literal|"NameServer"
argument_list|)
expr_stmt|;
name|TRY
argument_list|(
name|nt_key
argument_list|,
literal|"DhcpNameServer"
argument_list|)
expr_stmt|;
name|TRY
argument_list|(
name|interfaces_key
argument_list|,
literal|"NameServer"
argument_list|)
expr_stmt|;
name|TRY
argument_list|(
name|interfaces_key
argument_list|,
literal|"DhcpNameServer"
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|interfaces_key
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|nt_key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HKEY
name|win_key
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|RegOpenKeyEx
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|WIN_NS_9X_KEY
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
operator|&
name|win_key
argument_list|)
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Couldn't open registry key, %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|TRY
argument_list|(
name|win_key
argument_list|,
literal|"NameServer"
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|win_key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Didn't find any nameservers."
argument_list|)
expr_stmt|;
block|}
return|return
name|found
condition|?
literal|0
else|:
operator|-
literal|1
return|;
undef|#
directive|undef
name|TRY
block|}
end_function

begin_function
name|int
name|evdns_base_config_windows_nameservers
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
name|base
operator|=
name|current_base
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|fname
operator|=
name|evdns_get_default_hosts_filename
argument_list|()
expr_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Loading hosts entries from %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|evdns_base_load_hosts
argument_list|(
name|base
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
name|mm_free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_nameservers_with_getnetworkparams
argument_list|(
name|base
argument_list|)
operator|==
literal|0
condition|)
block|{
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|r
operator|=
name|load_nameservers_from_registry
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|evdns_config_windows_nameservers
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|current_base
condition|)
block|{
name|current_base
operator|=
name|evdns_base_new
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|current_base
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
else|else
block|{
return|return
name|evdns_base_config_windows_nameservers
argument_list|(
name|current_base
argument_list|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|evdns_base
modifier|*
name|evdns_base_new
parameter_list|(
name|struct
name|event_base
modifier|*
name|event_base
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|evdns_base
modifier|*
name|base
decl_stmt|;
if|if
condition|(
name|evutil_secure_rng_init
argument_list|()
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Unable to seed random number generator; "
literal|"DNS can't run."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Give the evutil library a hook into its evdns-enabled 	 * functionality.  We can't just call evdns_getaddrinfo directly or 	 * else libevent-core will depend on libevent-extras. */
name|evutil_set_evdns_getaddrinfo_fn_
argument_list|(
name|evdns_getaddrinfo
argument_list|)
expr_stmt|;
name|base
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evdns_base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evdns_base
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|->
name|req_waiting_head
operator|=
name|NULL
expr_stmt|;
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|base
operator|->
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Set max requests inflight and allocate req_heads. */
name|base
operator|->
name|req_heads
operator|=
name|NULL
expr_stmt|;
name|evdns_base_set_max_requests_inflight
argument_list|(
name|base
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|base
operator|->
name|server_head
operator|=
name|NULL
expr_stmt|;
name|base
operator|->
name|event_base
operator|=
name|event_base
expr_stmt|;
name|base
operator|->
name|global_good_nameservers
operator|=
name|base
operator|->
name|global_requests_inflight
operator|=
name|base
operator|->
name|global_requests_waiting
operator|=
literal|0
expr_stmt|;
name|base
operator|->
name|global_timeout
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|base
operator|->
name|global_timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|base
operator|->
name|global_max_reissues
operator|=
literal|1
expr_stmt|;
name|base
operator|->
name|global_max_retransmits
operator|=
literal|3
expr_stmt|;
name|base
operator|->
name|global_max_nameserver_timeout
operator|=
literal|3
expr_stmt|;
name|base
operator|->
name|global_search_state
operator|=
name|NULL
expr_stmt|;
name|base
operator|->
name|global_randomize_case
operator|=
literal|1
expr_stmt|;
name|base
operator|->
name|global_getaddrinfo_allow_skew
operator|.
name|tv_sec
operator|=
literal|3
expr_stmt|;
name|base
operator|->
name|global_getaddrinfo_allow_skew
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|base
operator|->
name|global_nameserver_probe_initial_timeout
operator|.
name|tv_sec
operator|=
literal|10
expr_stmt|;
name|base
operator|->
name|global_nameserver_probe_initial_timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|base
operator|->
name|hostsdb
argument_list|)
expr_stmt|;
define|#
directive|define
name|EVDNS_BASE_ALL_FLAGS
value|(0x8001)
if|if
condition|(
name|flags
operator|&
operator|~
name|EVDNS_BASE_ALL_FLAGS
condition|)
block|{
name|flags
operator|=
name|EVDNS_BASE_INITIALIZE_NAMESERVERS
expr_stmt|;
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Unrecognized flag passed to evdns_base_new(). Assuming "
literal|"you meant EVDNS_BASE_INITIALIZE_NAMESERVERS."
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|EVDNS_BASE_ALL_FLAGS
if|if
condition|(
name|flags
operator|&
name|EVDNS_BASE_INITIALIZE_NAMESERVERS
condition|)
block|{
name|int
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|r
operator|=
name|evdns_base_config_windows_nameservers
argument_list|(
name|base
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|evdns_base_resolv_conf_parse
argument_list|(
name|base
argument_list|,
name|DNS_OPTIONS_ALL
argument_list|,
literal|"/etc/resolv.conf"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|evdns_base_free_and_unlock
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|EVDNS_BASE_DISABLE_WHEN_INACTIVE
condition|)
block|{
name|base
operator|->
name|disable_when_inactive
operator|=
literal|1
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|base
return|;
block|}
end_function

begin_function
name|int
name|evdns_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|evdns_base
modifier|*
name|base
init|=
name|evdns_base_new
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|current_base
operator|=
name|base
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evdns_err_to_string
parameter_list|(
name|int
name|err
parameter_list|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|DNS_ERR_NONE
case|:
return|return
literal|"no error"
return|;
case|case
name|DNS_ERR_FORMAT
case|:
return|return
literal|"misformatted query"
return|;
case|case
name|DNS_ERR_SERVERFAILED
case|:
return|return
literal|"server failed"
return|;
case|case
name|DNS_ERR_NOTEXIST
case|:
return|return
literal|"name does not exist"
return|;
case|case
name|DNS_ERR_NOTIMPL
case|:
return|return
literal|"query not implemented"
return|;
case|case
name|DNS_ERR_REFUSED
case|:
return|return
literal|"refused"
return|;
case|case
name|DNS_ERR_TRUNCATED
case|:
return|return
literal|"reply truncated or ill-formed"
return|;
case|case
name|DNS_ERR_UNKNOWN
case|:
return|return
literal|"unknown"
return|;
case|case
name|DNS_ERR_TIMEOUT
case|:
return|return
literal|"request timed out"
return|;
case|case
name|DNS_ERR_SHUTDOWN
case|:
return|return
literal|"dns subsystem shut down"
return|;
case|case
name|DNS_ERR_CANCEL
case|:
return|return
literal|"dns request canceled"
return|;
case|case
name|DNS_ERR_NODATA
case|:
return|return
literal|"no records in the reply"
return|;
default|default:
return|return
literal|"[Unknown error code]"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evdns_nameserver_free
parameter_list|(
name|struct
name|nameserver
modifier|*
name|server
parameter_list|)
block|{
if|if
condition|(
name|server
operator|->
name|socket
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|server
operator|->
name|socket
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|event_del
argument_list|(
operator|&
name|server
operator|->
name|event
argument_list|)
expr_stmt|;
name|event_debug_unassign
argument_list|(
operator|&
name|server
operator|->
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|state
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|event_del
argument_list|(
operator|&
name|server
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|probe_request
condition|)
block|{
name|evdns_cancel_request
argument_list|(
name|server
operator|->
name|base
argument_list|,
name|server
operator|->
name|probe_request
argument_list|)
expr_stmt|;
name|server
operator|->
name|probe_request
operator|=
name|NULL
expr_stmt|;
block|}
name|event_debug_unassign
argument_list|(
operator|&
name|server
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdns_base_free_and_unlock
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|int
name|fail_requests
parameter_list|)
block|{
name|struct
name|nameserver
modifier|*
name|server
decl_stmt|,
modifier|*
name|server_next
decl_stmt|;
name|struct
name|search_domain
modifier|*
name|dom
decl_stmt|,
modifier|*
name|dom_next
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Requires that we hold the lock. */
comment|/* TODO(nickm) we might need to refcount here. */
for|for
control|(
name|server
operator|=
name|base
operator|->
name|server_head
init|;
name|server
condition|;
name|server
operator|=
name|server_next
control|)
block|{
name|server_next
operator|=
name|server
operator|->
name|next
expr_stmt|;
name|evdns_nameserver_free
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_next
operator|==
name|base
operator|->
name|server_head
condition|)
break|break;
block|}
name|base
operator|->
name|server_head
operator|=
name|NULL
expr_stmt|;
name|base
operator|->
name|global_good_nameservers
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|n_req_heads
condition|;
operator|++
name|i
control|)
block|{
while|while
condition|(
name|base
operator|->
name|req_heads
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|fail_requests
condition|)
name|reply_schedule_callback
argument_list|(
name|base
operator|->
name|req_heads
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|DNS_ERR_SHUTDOWN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|request_finished
argument_list|(
name|base
operator|->
name|req_heads
index|[
name|i
index|]
argument_list|,
operator|&
name|REQ_HEAD
argument_list|(
name|base
argument_list|,
name|base
operator|->
name|req_heads
index|[
name|i
index|]
operator|->
name|trans_id
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|base
operator|->
name|req_waiting_head
condition|)
block|{
if|if
condition|(
name|fail_requests
condition|)
name|reply_schedule_callback
argument_list|(
name|base
operator|->
name|req_waiting_head
argument_list|,
literal|0
argument_list|,
name|DNS_ERR_SHUTDOWN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|request_finished
argument_list|(
name|base
operator|->
name|req_waiting_head
argument_list|,
operator|&
name|base
operator|->
name|req_waiting_head
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|base
operator|->
name|global_requests_inflight
operator|=
name|base
operator|->
name|global_requests_waiting
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|global_search_state
condition|)
block|{
for|for
control|(
name|dom
operator|=
name|base
operator|->
name|global_search_state
operator|->
name|head
init|;
name|dom
condition|;
name|dom
operator|=
name|dom_next
control|)
block|{
name|dom_next
operator|=
name|dom
operator|->
name|next
expr_stmt|;
name|mm_free
argument_list|(
name|dom
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|base
operator|->
name|global_search_state
argument_list|)
expr_stmt|;
name|base
operator|->
name|global_search_state
operator|=
name|NULL
expr_stmt|;
block|}
block|{
name|struct
name|hosts_entry
modifier|*
name|victim
decl_stmt|;
while|while
condition|(
operator|(
name|victim
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|hostsdb
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|base
operator|->
name|hostsdb
argument_list|,
name|victim
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|victim
argument_list|)
expr_stmt|;
block|}
block|}
name|mm_free
argument_list|(
name|base
operator|->
name|req_heads
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_LOCK
argument_list|(
name|base
operator|->
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdns_base_free
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|int
name|fail_requests
parameter_list|)
block|{
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|evdns_base_free_and_unlock
argument_list|(
name|base
argument_list|,
name|fail_requests
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdns_base_clear_host_addresses
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|hosts_entry
modifier|*
name|victim
decl_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|victim
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|hostsdb
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|base
operator|->
name|hostsdb
argument_list|,
name|victim
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|victim
argument_list|)
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evdns_shutdown
parameter_list|(
name|int
name|fail_requests
parameter_list|)
block|{
if|if
condition|(
name|current_base
condition|)
block|{
name|struct
name|evdns_base
modifier|*
name|b
init|=
name|current_base
decl_stmt|;
name|current_base
operator|=
name|NULL
expr_stmt|;
name|evdns_base_free
argument_list|(
name|b
argument_list|,
name|fail_requests
argument_list|)
expr_stmt|;
block|}
name|evdns_log_fn
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdns_base_parse_hosts_line
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|strtok_state
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|delims
init|=
literal|" \t"
decl_stmt|;
name|char
modifier|*
specifier|const
name|addr
init|=
name|strtok_r
argument_list|(
name|line
argument_list|,
name|delims
argument_list|,
operator|&
name|strtok_state
argument_list|)
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|hash
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|int
name|socklen
init|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
define|#
directive|define
name|NEXT_TOKEN
value|strtok_r(NULL, delims,&strtok_state)
if|if
condition|(
operator|!
name|addr
operator|||
operator|*
name|addr
operator|==
literal|'#'
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evutil_parse_sockaddr_port
argument_list|(
name|addr
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|socklen
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|socklen
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sockaddr_getport
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|hostname
operator|=
name|NEXT_TOKEN
operator|)
condition|)
block|{
name|struct
name|hosts_entry
modifier|*
name|he
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
if|if
condition|(
operator|(
name|hash
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'#'
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|hash
operator|==
name|hostname
condition|)
return|return
literal|0
return|;
operator|*
name|hash
operator|=
literal|'\0'
expr_stmt|;
block|}
name|namelen
operator|=
name|strlen
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|he
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hosts_entry
argument_list|)
operator|+
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|he
condition|)
return|return
operator|-
literal|1
return|;
name|EVUTIL_ASSERT
argument_list|(
name|socklen
operator|<=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|he
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|he
operator|->
name|addr
argument_list|,
operator|&
name|ss
argument_list|,
name|socklen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|he
operator|->
name|hostname
argument_list|,
name|hostname
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|he
operator|->
name|addrlen
operator|=
name|socklen
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|base
operator|->
name|hostsdb
argument_list|,
name|he
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
undef|#
directive|undef
name|NEXT_TOKEN
block|}
end_function

begin_function
specifier|static
name|int
name|evdns_base_load_hosts_impl
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|hosts_fname
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|NULL
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts_fname
operator|==
name|NULL
operator|||
operator|(
name|err
operator|=
name|evutil_read_file_
argument_list|(
name|hosts_fname
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|char
name|tmp
index|[
literal|64
index|]
decl_stmt|;
name|strlcpy
argument_list|(
name|tmp
argument_list|,
literal|"127.0.0.1   localhost"
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_base_parse_hosts_line
argument_list|(
name|base
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|tmp
argument_list|,
literal|"::1   localhost"
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_base_parse_hosts_line
argument_list|(
name|base
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
comment|/* This will break early if there is a NUL in the hosts file. 	 * Probably not a problem.*/
name|cp
operator|=
name|str
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|eol
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol
condition|)
block|{
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
name|evdns_base_parse_hosts_line
argument_list|(
name|base
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|eol
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|evdns_base_parse_hosts_line
argument_list|(
name|base
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mm_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evdns_base_load_hosts
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|hosts_fname
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
name|base
operator|=
name|current_base
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|res
operator|=
name|evdns_base_load_hosts_impl
argument_list|(
name|base
argument_list|,
name|hosts_fname
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* A single request for a getaddrinfo, either v4 or v6. */
end_comment

begin_struct
struct|struct
name|getaddrinfo_subrequest
block|{
name|struct
name|evdns_request
modifier|*
name|r
decl_stmt|;
name|ev_uint32_t
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* State data used to implement an in-progress getaddrinfo. */
end_comment

begin_struct
struct|struct
name|evdns_getaddrinfo_request
block|{
name|struct
name|evdns_base
modifier|*
name|evdns_base
decl_stmt|;
comment|/* Copy of the modified 'hints' data that we'll use to build 	 * answers. */
name|struct
name|evutil_addrinfo
name|hints
decl_stmt|;
comment|/* The callback to invoke when we're done */
name|evdns_getaddrinfo_cb
name|user_cb
decl_stmt|;
comment|/* User-supplied data to give to the callback. */
name|void
modifier|*
name|user_data
decl_stmt|;
comment|/* The port to use when building sockaddrs. */
name|ev_uint16_t
name|port
decl_stmt|;
comment|/* The sub_request for an A record (if any) */
name|struct
name|getaddrinfo_subrequest
name|ipv4_request
decl_stmt|;
comment|/* The sub_request for an AAAA record (if any) */
name|struct
name|getaddrinfo_subrequest
name|ipv6_request
decl_stmt|;
comment|/* The cname result that we were told (if any) */
name|char
modifier|*
name|cname_result
decl_stmt|;
comment|/* If we have one request answered and one request still inflight, 	 * then this field holds the answer from the first request... */
name|struct
name|evutil_addrinfo
modifier|*
name|pending_result
decl_stmt|;
comment|/* And this event is a timeout that will tell us to cancel the second 	 * request if it's taking a long time. */
name|struct
name|event
name|timeout
decl_stmt|;
comment|/* And this field holds the error code from the first request... */
name|int
name|pending_error
decl_stmt|;
comment|/* If this is set, the user canceled this request. */
name|unsigned
name|user_canceled
range|:
literal|1
decl_stmt|;
comment|/* If this is set, the user can no longer cancel this request; we're 	 * just waiting for the free. */
name|unsigned
name|request_done
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Convert an evdns errors to the equivalent getaddrinfo error. */
end_comment

begin_function
specifier|static
name|int
name|evdns_err_to_getaddrinfo_err
parameter_list|(
name|int
name|e1
parameter_list|)
block|{
comment|/* XXX Do this better! */
if|if
condition|(
name|e1
operator|==
name|DNS_ERR_NONE
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|e1
operator|==
name|DNS_ERR_NOTEXIST
condition|)
return|return
name|EVUTIL_EAI_NONAME
return|;
else|else
return|return
name|EVUTIL_EAI_FAIL
return|;
block|}
end_function

begin_comment
comment|/* Return the more informative of two getaddrinfo errors. */
end_comment

begin_function
specifier|static
name|int
name|getaddrinfo_merge_err
parameter_list|(
name|int
name|e1
parameter_list|,
name|int
name|e2
parameter_list|)
block|{
comment|/* XXXX be cleverer here. */
if|if
condition|(
name|e1
operator|==
literal|0
condition|)
return|return
name|e2
return|;
else|else
return|return
name|e1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_getaddrinfo_request
parameter_list|(
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|data
parameter_list|)
block|{
comment|/* DO NOT CALL this if either of the requests is pending.  Only once 	 * both callbacks have been invoked is it safe to free the request */
if|if
condition|(
name|data
operator|->
name|pending_result
condition|)
name|evutil_freeaddrinfo
argument_list|(
name|data
operator|->
name|pending_result
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|cname_result
condition|)
name|mm_free
argument_list|(
name|data
operator|->
name|cname_result
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|data
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|add_cname_to_reply
parameter_list|(
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|data
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
name|ai
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|cname_result
operator|&&
name|ai
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
name|data
operator|->
name|cname_result
expr_stmt|;
name|data
operator|->
name|cname_result
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Callback: invoked when one request in a mixed-format A/AAAA getaddrinfo  * request has finished, but the other one took too long to answer. Pass  * along the answer we got, and cancel the other request.  */
end_comment

begin_function
specifier|static
name|void
name|evdns_getaddrinfo_timeout_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|v4_timedout
init|=
literal|0
decl_stmt|,
name|v6_timedout
init|=
literal|0
decl_stmt|;
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
comment|/* Cancel any pending requests, and note which one */
if|if
condition|(
name|data
operator|->
name|ipv4_request
operator|.
name|r
condition|)
block|{
comment|/* XXXX This does nothing if the request's callback is already 		 * running (pending_cb is set). */
name|evdns_cancel_request
argument_list|(
name|NULL
argument_list|,
name|data
operator|->
name|ipv4_request
operator|.
name|r
argument_list|)
expr_stmt|;
name|v4_timedout
operator|=
literal|1
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|)
expr_stmt|;
operator|++
name|data
operator|->
name|evdns_base
operator|->
name|getaddrinfo_ipv4_timeouts
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|ipv6_request
operator|.
name|r
condition|)
block|{
comment|/* XXXX This does nothing if the request's callback is already 		 * running (pending_cb is set). */
name|evdns_cancel_request
argument_list|(
name|NULL
argument_list|,
name|data
operator|->
name|ipv6_request
operator|.
name|r
argument_list|)
expr_stmt|;
name|v6_timedout
operator|=
literal|1
expr_stmt|;
name|EVDNS_LOCK
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|)
expr_stmt|;
operator|++
name|data
operator|->
name|evdns_base
operator|->
name|getaddrinfo_ipv6_timeouts
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|)
expr_stmt|;
block|}
comment|/* We only use this timeout callback when we have an answer for 	 * one address. */
name|EVUTIL_ASSERT
argument_list|(
operator|!
name|v4_timedout
operator|||
operator|!
name|v6_timedout
argument_list|)
expr_stmt|;
comment|/* Report the outcome of the other request that didn't time out. */
if|if
condition|(
name|data
operator|->
name|pending_result
condition|)
block|{
name|add_cname_to_reply
argument_list|(
name|data
argument_list|,
name|data
operator|->
name|pending_result
argument_list|)
expr_stmt|;
name|data
operator|->
name|user_cb
argument_list|(
literal|0
argument_list|,
name|data
operator|->
name|pending_result
argument_list|,
name|data
operator|->
name|user_data
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_result
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|e
init|=
name|data
operator|->
name|pending_error
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|e
operator|=
name|EVUTIL_EAI_AGAIN
expr_stmt|;
name|data
operator|->
name|user_cb
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|,
name|data
operator|->
name|user_data
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|user_cb
operator|=
name|NULL
expr_stmt|;
comment|/* prevent double-call if evdns callbacks are 			       * in-progress. XXXX It would be better if this 			       * weren't necessary. */
if|if
condition|(
operator|!
name|v4_timedout
operator|&&
operator|!
name|v6_timedout
condition|)
block|{
comment|/* should be impossible? XXXX */
name|free_getaddrinfo_request
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|evdns_getaddrinfo_set_timeout
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|evdns_base
parameter_list|,
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|data
parameter_list|)
block|{
return|return
name|event_add
argument_list|(
operator|&
name|data
operator|->
name|timeout
argument_list|,
operator|&
name|evdns_base
operator|->
name|global_getaddrinfo_allow_skew
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|evdns_result_is_answer
parameter_list|(
name|int
name|result
parameter_list|)
block|{
return|return
operator|(
name|result
operator|!=
name|DNS_ERR_NOTIMPL
operator|&&
name|result
operator|!=
name|DNS_ERR_REFUSED
operator|&&
name|result
operator|!=
name|DNS_ERR_SERVERFAILED
operator|&&
name|result
operator|!=
name|DNS_ERR_CANCEL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evdns_getaddrinfo_gotresolve
parameter_list|(
name|int
name|result
parameter_list|,
name|char
name|type
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|ttl
parameter_list|,
name|void
modifier|*
name|addresses
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|getaddrinfo_subrequest
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|getaddrinfo_subrequest
modifier|*
name|other_req
decl_stmt|;
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|data
decl_stmt|;
name|struct
name|evutil_addrinfo
modifier|*
name|res
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|socklen
decl_stmt|,
name|addrlen
decl_stmt|;
name|void
modifier|*
name|addrp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|user_canceled
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|req
operator|->
name|type
operator|==
name|DNS_IPv4_A
operator|||
name|req
operator|->
name|type
operator|==
name|DNS_IPv6_AAAA
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|type
operator|==
name|DNS_IPv4_A
condition|)
block|{
name|data
operator|=
name|EVUTIL_UPCAST
argument_list|(
name|req
argument_list|,
expr|struct
name|evdns_getaddrinfo_request
argument_list|,
name|ipv4_request
argument_list|)
expr_stmt|;
name|other_req
operator|=
operator|&
name|data
operator|->
name|ipv6_request
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|EVUTIL_UPCAST
argument_list|(
name|req
argument_list|,
expr|struct
name|evdns_getaddrinfo_request
argument_list|,
name|ipv6_request
argument_list|)
expr_stmt|;
name|other_req
operator|=
operator|&
name|data
operator|->
name|ipv4_request
expr_stmt|;
block|}
name|EVDNS_LOCK
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|evdns_result_is_answer
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|type
operator|==
name|DNS_IPv4_A
condition|)
operator|++
name|data
operator|->
name|evdns_base
operator|->
name|getaddrinfo_ipv4_answered
expr_stmt|;
else|else
operator|++
name|data
operator|->
name|evdns_base
operator|->
name|getaddrinfo_ipv6_answered
expr_stmt|;
block|}
name|user_canceled
operator|=
name|data
operator|->
name|user_canceled
expr_stmt|;
if|if
condition|(
name|other_req
operator|->
name|r
operator|==
name|NULL
condition|)
name|data
operator|->
name|request_done
operator|=
literal|1
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|)
expr_stmt|;
name|req
operator|->
name|r
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_ERR_CANCEL
operator|&&
operator|!
name|user_canceled
condition|)
block|{
comment|/* Internal cancel request from timeout or internal error. 		 * we already answered the user. */
if|if
condition|(
name|other_req
operator|->
name|r
operator|==
name|NULL
condition|)
name|free_getaddrinfo_request
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|data
operator|->
name|user_cb
operator|==
name|NULL
condition|)
block|{
comment|/* We already answered.  XXXX This shouldn't be needed; see 		 * comments in evdns_getaddrinfo_timeout_cb */
name|free_getaddrinfo_request
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|result
operator|==
name|DNS_ERR_NONE
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|err
operator|=
name|EVUTIL_EAI_NODATA
expr_stmt|;
else|else
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|evdns_err_to_getaddrinfo_err
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|/* Looks like we got an error. */
if|if
condition|(
name|other_req
operator|->
name|r
condition|)
block|{
comment|/* The other request is still working; maybe it will 			 * succeed. */
comment|/* XXXX handle failure from set_timeout */
name|evdns_getaddrinfo_set_timeout
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_error
operator|=
name|err
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|user_canceled
condition|)
block|{
name|data
operator|->
name|user_cb
argument_list|(
name|EVUTIL_EAI_CANCEL
argument_list|,
name|NULL
argument_list|,
name|data
operator|->
name|user_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|pending_result
condition|)
block|{
comment|/* If we have an answer waiting, and we weren't 			 * canceled, ignore this error. */
name|add_cname_to_reply
argument_list|(
name|data
argument_list|,
name|data
operator|->
name|pending_result
argument_list|)
expr_stmt|;
name|data
operator|->
name|user_cb
argument_list|(
literal|0
argument_list|,
name|data
operator|->
name|pending_result
argument_list|,
name|data
operator|->
name|user_data
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_result
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|pending_error
condition|)
name|err
operator|=
name|getaddrinfo_merge_err
argument_list|(
name|err
argument_list|,
name|data
operator|->
name|pending_error
argument_list|)
expr_stmt|;
name|data
operator|->
name|user_cb
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|,
name|data
operator|->
name|user_data
argument_list|)
expr_stmt|;
block|}
name|free_getaddrinfo_request
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|user_canceled
condition|)
block|{
if|if
condition|(
name|other_req
operator|->
name|r
condition|)
block|{
comment|/* The other request is still working; let it hit this 			 * callback with EVUTIL_EAI_CANCEL callback and report 			 * the failure. */
return|return;
block|}
name|data
operator|->
name|user_cb
argument_list|(
name|EVUTIL_EAI_CANCEL
argument_list|,
name|NULL
argument_list|,
name|data
operator|->
name|user_data
argument_list|)
expr_stmt|;
name|free_getaddrinfo_request
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Looks like we got some answers. We should turn them into addrinfos 	 * and then either queue those or return them all. */
name|EVUTIL_ASSERT
argument_list|(
name|type
operator|==
name|DNS_IPv4_A
operator|||
name|type
operator|==
name|DNS_IPv6_AAAA
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DNS_IPv4_A
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|data
operator|->
name|port
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
name|socklen
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|addrlen
operator|=
literal|4
expr_stmt|;
name|addrp
operator|=
operator|&
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
name|data
operator|->
name|port
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
name|socklen
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|addrlen
operator|=
literal|16
expr_stmt|;
name|addrp
operator|=
operator|&
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr
expr_stmt|;
block|}
name|res
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|ai
decl_stmt|;
name|memcpy
argument_list|(
name|addrp
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|addresses
operator|)
operator|+
name|i
operator|*
name|addrlen
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|ai
operator|=
name|evutil_new_addrinfo_
argument_list|(
name|sa
argument_list|,
name|socklen
argument_list|,
operator|&
name|data
operator|->
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ai
condition|)
block|{
if|if
condition|(
name|other_req
operator|->
name|r
condition|)
block|{
name|evdns_cancel_request
argument_list|(
name|NULL
argument_list|,
name|other_req
operator|->
name|r
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|user_cb
argument_list|(
name|EVUTIL_EAI_MEMORY
argument_list|,
name|NULL
argument_list|,
name|data
operator|->
name|user_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|evutil_freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_req
operator|->
name|r
operator|==
name|NULL
condition|)
name|free_getaddrinfo_request
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|res
operator|=
name|evutil_addrinfo_append_
argument_list|(
name|res
argument_list|,
name|ai
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|other_req
operator|->
name|r
condition|)
block|{
comment|/* The other request is still in progress; wait for it */
comment|/* XXXX handle failure from set_timeout */
name|evdns_getaddrinfo_set_timeout
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_result
operator|=
name|res
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* The other request is done or never started; append its 		 * results (if any) and return them. */
if|if
condition|(
name|data
operator|->
name|pending_result
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|type
operator|==
name|DNS_IPv4_A
condition|)
name|res
operator|=
name|evutil_addrinfo_append_
argument_list|(
name|res
argument_list|,
name|data
operator|->
name|pending_result
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|evutil_addrinfo_append_
argument_list|(
name|data
operator|->
name|pending_result
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_result
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Call the user callback. */
name|add_cname_to_reply
argument_list|(
name|data
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|data
operator|->
name|user_cb
argument_list|(
literal|0
argument_list|,
name|res
argument_list|,
name|data
operator|->
name|user_data
argument_list|)
expr_stmt|;
comment|/* Free data. */
name|free_getaddrinfo_request
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|hosts_entry
modifier|*
name|find_hosts_entry
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|struct
name|hosts_entry
modifier|*
name|find_after
parameter_list|)
block|{
name|struct
name|hosts_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|find_after
condition|)
name|e
operator|=
name|TAILQ_NEXT
argument_list|(
name|find_after
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|else
name|e
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|hostsdb
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|e
condition|;
name|e
operator|=
name|TAILQ_NEXT
argument_list|(
name|e
argument_list|,
name|next
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|e
operator|->
name|hostname
argument_list|,
name|hostname
argument_list|)
condition|)
return|return
name|e
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evdns_getaddrinfo_fromhosts
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|nodename
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
name|hints
parameter_list|,
name|ev_uint16_t
name|port
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|int
name|n_found
init|=
literal|0
decl_stmt|;
name|struct
name|hosts_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|evutil_addrinfo
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
name|int
name|f
init|=
name|hints
operator|->
name|ai_family
decl_stmt|;
name|EVDNS_LOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|find_hosts_entry
argument_list|(
name|base
argument_list|,
name|nodename
argument_list|,
name|NULL
argument_list|)
init|;
name|e
condition|;
name|e
operator|=
name|find_hosts_entry
argument_list|(
name|base
argument_list|,
name|nodename
argument_list|,
name|e
argument_list|)
control|)
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|ai_new
decl_stmt|;
operator|++
name|n_found
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
name|f
operator|==
name|PF_INET6
operator|)
operator|||
operator|(
name|e
operator|->
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|&&
name|f
operator|==
name|PF_INET
operator|)
condition|)
continue|continue;
name|ai_new
operator|=
name|evutil_new_addrinfo_
argument_list|(
operator|&
name|e
operator|->
name|addr
operator|.
name|sa
argument_list|,
name|e
operator|->
name|addrlen
argument_list|,
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ai_new
condition|)
block|{
name|n_found
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sockaddr_setport
argument_list|(
name|ai_new
operator|->
name|ai_addr
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|ai
operator|=
name|evutil_addrinfo_append_
argument_list|(
name|ai
argument_list|,
name|ai_new
argument_list|)
expr_stmt|;
block|}
name|EVDNS_UNLOCK
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|n_found
condition|)
block|{
comment|/* Note that we return an empty answer if we found entries for 		 * this hostname but none were of the right address type. */
operator|*
name|res
operator|=
name|ai
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|ai
condition|)
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|evdns_getaddrinfo
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|dns_base
parameter_list|,
specifier|const
name|char
modifier|*
name|nodename
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|struct
name|evutil_addrinfo
modifier|*
name|hints_in
parameter_list|,
name|evdns_getaddrinfo_cb
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|data
decl_stmt|;
name|struct
name|evutil_addrinfo
name|hints
decl_stmt|;
name|struct
name|evutil_addrinfo
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
init|=
literal|0
decl_stmt|;
name|int
name|want_cname
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dns_base
condition|)
block|{
name|dns_base
operator|=
name|current_base
expr_stmt|;
if|if
condition|(
operator|!
name|dns_base
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_WARN
argument_list|,
literal|"Call to getaddrinfo_async with no "
literal|"evdns_base configured."
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|EVUTIL_EAI_FAIL
argument_list|,
name|NULL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* ??? better error? */
return|return
name|NULL
return|;
block|}
block|}
comment|/* If we _must_ answer this immediately, do so. */
if|if
condition|(
operator|(
name|hints_in
operator|&&
operator|(
name|hints_in
operator|->
name|ai_flags
operator|&
name|EVUTIL_AI_NUMERICHOST
operator|)
operator|)
condition|)
block|{
name|res
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|evutil_getaddrinfo
argument_list|(
name|nodename
argument_list|,
name|servname
argument_list|,
name|hints_in
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|err
argument_list|,
name|res
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|hints_in
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|hints
argument_list|,
name|hints_in
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
block|}
name|evutil_adjust_hints_for_addrconfig_
argument_list|(
operator|&
name|hints
argument_list|)
expr_stmt|;
comment|/* Now try to see if we _can_ answer immediately. */
comment|/* (It would be nice to do this by calling getaddrinfo directly, with 	 * AI_NUMERICHOST, on plaforms that have it, but we can't: there isn't 	 * a reliable way to distinguish the "that wasn't a numeric host!" case 	 * from any other EAI_NONAME cases.) */
name|err
operator|=
name|evutil_getaddrinfo_common_
argument_list|(
name|nodename
argument_list|,
name|servname
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EVUTIL_EAI_NEED_RESOLVE
condition|)
block|{
name|cb
argument_list|(
name|err
argument_list|,
name|res
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* If there is an entry in the hosts file, we should give it now. */
if|if
condition|(
operator|!
name|evdns_getaddrinfo_fromhosts
argument_list|(
name|dns_base
argument_list|,
name|nodename
argument_list|,
operator|&
name|hints
argument_list|,
name|port
argument_list|,
operator|&
name|res
argument_list|)
condition|)
block|{
name|cb
argument_list|(
literal|0
argument_list|,
name|res
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Okay, things are serious now. We're going to need to actually 	 * launch a request. 	 */
name|data
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evdns_getaddrinfo_request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|cb
argument_list|(
name|EVUTIL_EAI_MEMORY
argument_list|,
name|NULL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|data
operator|->
name|hints
argument_list|,
operator|&
name|hints
argument_list|,
sizeof|sizeof
argument_list|(
name|data
operator|->
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|port
operator|=
operator|(
name|ev_uint16_t
operator|)
name|port
expr_stmt|;
name|data
operator|->
name|ipv4_request
operator|.
name|type
operator|=
name|DNS_IPv4_A
expr_stmt|;
name|data
operator|->
name|ipv6_request
operator|.
name|type
operator|=
name|DNS_IPv6_AAAA
expr_stmt|;
name|data
operator|->
name|user_cb
operator|=
name|cb
expr_stmt|;
name|data
operator|->
name|user_data
operator|=
name|arg
expr_stmt|;
name|data
operator|->
name|evdns_base
operator|=
name|dns_base
expr_stmt|;
name|want_cname
operator|=
operator|(
name|hints
operator|.
name|ai_flags
operator|&
name|EVUTIL_AI_CANONNAME
operator|)
expr_stmt|;
comment|/* If we are asked for a PF_UNSPEC address, we launch two requests in 	 * parallel: one for an A address and one for an AAAA address.  We 	 * can't send just one request, since many servers only answer one 	 * question per DNS request. 	 * 	 * Once we have the answer to one request, we allow for a short 	 * timeout before we report it, to see if the other one arrives.  If 	 * they both show up in time, then we report both the answers. 	 * 	 * If too many addresses of one type time out or fail, we should stop 	 * launching those requests. (XXX we don't do that yet.) 	 */
if|if
condition|(
name|hints
operator|.
name|ai_family
operator|!=
name|PF_INET6
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Sending request for %s on ipv4 as %p"
argument_list|,
name|nodename
argument_list|,
operator|&
name|data
operator|->
name|ipv4_request
argument_list|)
expr_stmt|;
name|data
operator|->
name|ipv4_request
operator|.
name|r
operator|=
name|evdns_base_resolve_ipv4
argument_list|(
name|dns_base
argument_list|,
name|nodename
argument_list|,
literal|0
argument_list|,
name|evdns_getaddrinfo_gotresolve
argument_list|,
operator|&
name|data
operator|->
name|ipv4_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_cname
operator|&&
name|data
operator|->
name|ipv4_request
operator|.
name|r
condition|)
name|data
operator|->
name|ipv4_request
operator|.
name|r
operator|->
name|current_req
operator|->
name|put_cname_in_ptr
operator|=
operator|&
name|data
operator|->
name|cname_result
expr_stmt|;
block|}
if|if
condition|(
name|hints
operator|.
name|ai_family
operator|!=
name|PF_INET
condition|)
block|{
name|log
argument_list|(
name|EVDNS_LOG_DEBUG
argument_list|,
literal|"Sending request for %s on ipv6 as %p"
argument_list|,
name|nodename
argument_list|,
operator|&
name|data
operator|->
name|ipv6_request
argument_list|)
expr_stmt|;
name|data
operator|->
name|ipv6_request
operator|.
name|r
operator|=
name|evdns_base_resolve_ipv6
argument_list|(
name|dns_base
argument_list|,
name|nodename
argument_list|,
literal|0
argument_list|,
name|evdns_getaddrinfo_gotresolve
argument_list|,
operator|&
name|data
operator|->
name|ipv6_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_cname
operator|&&
name|data
operator|->
name|ipv6_request
operator|.
name|r
condition|)
name|data
operator|->
name|ipv6_request
operator|.
name|r
operator|->
name|current_req
operator|->
name|put_cname_in_ptr
operator|=
operator|&
name|data
operator|->
name|cname_result
expr_stmt|;
block|}
name|evtimer_assign
argument_list|(
operator|&
name|data
operator|->
name|timeout
argument_list|,
name|dns_base
operator|->
name|event_base
argument_list|,
name|evdns_getaddrinfo_timeout_cb
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|ipv4_request
operator|.
name|r
operator|||
name|data
operator|->
name|ipv6_request
operator|.
name|r
condition|)
block|{
return|return
name|data
return|;
block|}
else|else
block|{
name|mm_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|EVUTIL_EAI_FAIL
argument_list|,
name|NULL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|void
name|evdns_getaddrinfo_cancel
parameter_list|(
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|data
parameter_list|)
block|{
name|EVDNS_LOCK
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|request_done
condition|)
block|{
name|EVDNS_UNLOCK
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|)
expr_stmt|;
return|return;
block|}
name|event_del
argument_list|(
operator|&
name|data
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|data
operator|->
name|user_canceled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|ipv4_request
operator|.
name|r
condition|)
name|evdns_cancel_request
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|,
name|data
operator|->
name|ipv4_request
operator|.
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|ipv6_request
operator|.
name|r
condition|)
name|evdns_cancel_request
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|,
name|data
operator|->
name|ipv6_request
operator|.
name|r
argument_list|)
expr_stmt|;
name|EVDNS_UNLOCK
argument_list|(
name|data
operator|->
name|evdns_base
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

