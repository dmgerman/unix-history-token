begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008-2012 Niels Provos, Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EVTHREAD_INTERNAL_H_INCLUDED_
end_ifndef

begin_define
define|#
directive|define
name|EVTHREAD_INTERNAL_H_INCLUDED_
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
include|#
directive|include
file|"event2/event-config.h"
include|#
directive|include
file|"evconfig-private.h"
include|#
directive|include
file|"event2/thread.h"
include|#
directive|include
file|"util-internal.h"
struct_decl|struct
name|event_base
struct_decl|;
ifndef|#
directive|ifndef
name|_WIN32
comment|/* On Windows, the way we currently make DLLs, it's not allowed for us to  * have shared global structures.  Thus, we only do the direct-call-to-function  * code path if we know that the local shared library system supports it.  */
define|#
directive|define
name|EVTHREAD_EXPOSE_STRUCTS
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EVENT__DISABLE_THREAD_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|EVTHREAD_EXPOSE_STRUCTS
argument_list|)
comment|/* Global function pointers to lock-related functions. NULL if locking isn't    enabled. */
specifier|extern
name|struct
name|evthread_lock_callbacks
name|evthread_lock_fns_
decl_stmt|;
specifier|extern
name|struct
name|evthread_condition_callbacks
name|evthread_cond_fns_
decl_stmt|;
specifier|extern
name|unsigned
name|long
function_decl|(
modifier|*
name|evthread_id_fn_
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|int
name|evthread_lock_debugging_enabled_
decl_stmt|;
comment|/** Return the ID of the current thread, or 1 if threading isn't enabled. */
define|#
directive|define
name|EVTHREAD_GET_ID
parameter_list|()
define|\
value|(evthread_id_fn_ ? evthread_id_fn_() : 1)
comment|/** Return true iff we're in the thread that is currently (or most recently)  * running a given event_base's loop. Requires lock. */
define|#
directive|define
name|EVBASE_IN_THREAD
parameter_list|(
name|base
parameter_list|)
define|\
value|(evthread_id_fn_ == NULL ||			 \ 	(base)->th_owner_id == evthread_id_fn_())
comment|/** Return true iff we need to notify the base's main thread about changes to  * its state, because it's currently running the main loop in another  * thread. Requires lock. */
define|#
directive|define
name|EVBASE_NEED_NOTIFY
parameter_list|(
name|base
parameter_list|)
define|\
value|(evthread_id_fn_ != NULL&&			 \ 	    (base)->running_loop&&			 \ 	    (base)->th_owner_id != evthread_id_fn_())
comment|/** Allocate a new lock, and store it in lockvar, a void*.  Sets lockvar to     NULL if locking is not enabled. */
define|#
directive|define
name|EVTHREAD_ALLOC_LOCK
parameter_list|(
name|lockvar
parameter_list|,
name|locktype
parameter_list|)
define|\
value|((lockvar) = evthread_lock_fns_.alloc ?		\ 	    evthread_lock_fns_.alloc(locktype) : NULL)
comment|/** Free a given lock, if it is present and locking is enabled. */
define|#
directive|define
name|EVTHREAD_FREE_LOCK
parameter_list|(
name|lockvar
parameter_list|,
name|locktype
parameter_list|)
define|\
value|do {								\ 		void *lock_tmp_ = (lockvar);				\ 		if (lock_tmp_&& evthread_lock_fns_.free)		\ 			evthread_lock_fns_.free(lock_tmp_, (locktype)); \ 	} while (0)
comment|/** Acquire a lock. */
define|#
directive|define
name|EVLOCK_LOCK
parameter_list|(
name|lockvar
parameter_list|,
name|mode
parameter_list|)
define|\
value|do {								\ 		if (lockvar)						\ 			evthread_lock_fns_.lock(mode, lockvar);		\ 	} while (0)
comment|/** Release a lock */
define|#
directive|define
name|EVLOCK_UNLOCK
parameter_list|(
name|lockvar
parameter_list|,
name|mode
parameter_list|)
define|\
value|do {								\ 		if (lockvar)						\ 			evthread_lock_fns_.unlock(mode, lockvar);	\ 	} while (0)
comment|/** Helper: put lockvar1 and lockvar2 into pointerwise ascending order. */
define|#
directive|define
name|EVLOCK_SORTLOCKS_
parameter_list|(
name|lockvar1
parameter_list|,
name|lockvar2
parameter_list|)
define|\
value|do {								\ 		if (lockvar1&& lockvar2&& lockvar1> lockvar2) {	\ 			void *tmp = lockvar1;				\ 			lockvar1 = lockvar2;				\ 			lockvar2 = tmp;					\ 		}							\ 	} while (0)
comment|/** Lock an event_base, if it is set up for locking.  Acquires the lock     in the base structure whose field is named 'lockvar'. */
define|#
directive|define
name|EVBASE_ACQUIRE_LOCK
parameter_list|(
name|base
parameter_list|,
name|lockvar
parameter_list|)
value|do {				\ 		EVLOCK_LOCK((base)->lockvar, 0);			\ 	} while (0)
comment|/** Unlock an event_base, if it is set up for locking. */
define|#
directive|define
name|EVBASE_RELEASE_LOCK
parameter_list|(
name|base
parameter_list|,
name|lockvar
parameter_list|)
value|do {				\ 		EVLOCK_UNLOCK((base)->lockvar, 0);			\ 	} while (0)
comment|/** If lock debugging is enabled, and lock is non-null, assert that 'lock' is  * locked and held by us. */
define|#
directive|define
name|EVLOCK_ASSERT_LOCKED
parameter_list|(
name|lock
parameter_list|)
define|\
value|do {								\ 		if ((lock)&& evthread_lock_debugging_enabled_) {	\ 			EVUTIL_ASSERT(evthread_is_debug_lock_held_(lock)); \ 		}							\ 	} while (0)
comment|/** Try to grab the lock for 'lockvar' without blocking, and return 1 if we  * manage to get it. */
specifier|static
specifier|inline
name|int
name|EVLOCK_TRY_LOCK_
parameter_list|(
name|void
modifier|*
name|lock
parameter_list|)
function_decl|;
specifier|static
specifier|inline
name|int
name|EVLOCK_TRY_LOCK_
parameter_list|(
name|void
modifier|*
name|lock
parameter_list|)
block|{
if|if
condition|(
name|lock
operator|&&
name|evthread_lock_fns_
operator|.
name|lock
condition|)
block|{
name|int
name|r
init|=
name|evthread_lock_fns_
operator|.
name|lock
argument_list|(
name|EVTHREAD_TRY
argument_list|,
name|lock
argument_list|)
decl_stmt|;
return|return
operator|!
name|r
return|;
block|}
else|else
block|{
comment|/* Locking is disabled either globally or for this thing; 		 * of course we count as having the lock. */
return|return
literal|1
return|;
block|}
block|}
comment|/** Allocate a new condition variable and store it in the void *, condvar */
define|#
directive|define
name|EVTHREAD_ALLOC_COND
parameter_list|(
name|condvar
parameter_list|)
define|\
value|do {								\ 		(condvar) = evthread_cond_fns_.alloc_condition ?	\ 		    evthread_cond_fns_.alloc_condition(0) : NULL;	\ 	} while (0)
comment|/** Deallocate and free a condition variable in condvar */
define|#
directive|define
name|EVTHREAD_FREE_COND
parameter_list|(
name|cond
parameter_list|)
define|\
value|do {								\ 		if (cond)						\ 			evthread_cond_fns_.free_condition((cond));	\ 	} while (0)
comment|/** Signal one thread waiting on cond */
define|#
directive|define
name|EVTHREAD_COND_SIGNAL
parameter_list|(
name|cond
parameter_list|)
define|\
value|( (cond) ? evthread_cond_fns_.signal_condition((cond), 0) : 0 )
comment|/** Signal all threads waiting on cond */
define|#
directive|define
name|EVTHREAD_COND_BROADCAST
parameter_list|(
name|cond
parameter_list|)
define|\
value|( (cond) ? evthread_cond_fns_.signal_condition((cond), 1) : 0 )
comment|/** Wait until the condition 'cond' is signalled.  Must be called while  * holding 'lock'.  The lock will be released until the condition is  * signalled, at which point it will be acquired again.  Returns 0 for  * success, -1 for failure. */
define|#
directive|define
name|EVTHREAD_COND_WAIT
parameter_list|(
name|cond
parameter_list|,
name|lock
parameter_list|)
define|\
value|( (cond) ? evthread_cond_fns_.wait_condition((cond), (lock), NULL) : 0 )
comment|/** As EVTHREAD_COND_WAIT, but gives up after 'tv' has elapsed.  Returns 1  * on timeout. */
define|#
directive|define
name|EVTHREAD_COND_WAIT_TIMED
parameter_list|(
name|cond
parameter_list|,
name|lock
parameter_list|,
name|tv
parameter_list|)
define|\
value|( (cond) ? evthread_cond_fns_.wait_condition((cond), (lock), (tv)) : 0 )
comment|/** True iff locking functions have been configured. */
define|#
directive|define
name|EVTHREAD_LOCKING_ENABLED
parameter_list|()
define|\
value|(evthread_lock_fns_.lock != NULL)
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|EVENT__DISABLE_THREAD_SUPPORT
argument_list|)
name|unsigned
name|long
name|evthreadimpl_get_id_
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|evthreadimpl_is_lock_debugging_enabled_
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
modifier|*
name|evthreadimpl_lock_alloc_
parameter_list|(
name|unsigned
name|locktype
parameter_list|)
function_decl|;
name|void
name|evthreadimpl_lock_free_
parameter_list|(
name|void
modifier|*
name|lock
parameter_list|,
name|unsigned
name|locktype
parameter_list|)
function_decl|;
name|int
name|evthreadimpl_lock_lock_
parameter_list|(
name|unsigned
name|mode
parameter_list|,
name|void
modifier|*
name|lock
parameter_list|)
function_decl|;
name|int
name|evthreadimpl_lock_unlock_
parameter_list|(
name|unsigned
name|mode
parameter_list|,
name|void
modifier|*
name|lock
parameter_list|)
function_decl|;
name|void
modifier|*
name|evthreadimpl_cond_alloc_
parameter_list|(
name|unsigned
name|condtype
parameter_list|)
function_decl|;
name|void
name|evthreadimpl_cond_free_
parameter_list|(
name|void
modifier|*
name|cond
parameter_list|)
function_decl|;
name|int
name|evthreadimpl_cond_signal_
parameter_list|(
name|void
modifier|*
name|cond
parameter_list|,
name|int
name|broadcast
parameter_list|)
function_decl|;
name|int
name|evthreadimpl_cond_wait_
parameter_list|(
name|void
modifier|*
name|cond
parameter_list|,
name|void
modifier|*
name|lock
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
function_decl|;
name|int
name|evthreadimpl_locking_enabled_
parameter_list|(
name|void
parameter_list|)
function_decl|;
define|#
directive|define
name|EVTHREAD_GET_ID
parameter_list|()
value|evthreadimpl_get_id_()
define|#
directive|define
name|EVBASE_IN_THREAD
parameter_list|(
name|base
parameter_list|)
define|\
value|((base)->th_owner_id == evthreadimpl_get_id_())
define|#
directive|define
name|EVBASE_NEED_NOTIFY
parameter_list|(
name|base
parameter_list|)
define|\
value|((base)->running_loop&&			 \ 	    ((base)->th_owner_id != evthreadimpl_get_id_()))
define|#
directive|define
name|EVTHREAD_ALLOC_LOCK
parameter_list|(
name|lockvar
parameter_list|,
name|locktype
parameter_list|)
define|\
value|((lockvar) = evthreadimpl_lock_alloc_(locktype))
define|#
directive|define
name|EVTHREAD_FREE_LOCK
parameter_list|(
name|lockvar
parameter_list|,
name|locktype
parameter_list|)
define|\
value|do {								\ 		void *lock_tmp_ = (lockvar);				\ 		if (lock_tmp_)						\ 			evthreadimpl_lock_free_(lock_tmp_, (locktype)); \ 	} while (0)
comment|/** Acquire a lock. */
define|#
directive|define
name|EVLOCK_LOCK
parameter_list|(
name|lockvar
parameter_list|,
name|mode
parameter_list|)
define|\
value|do {								\ 		if (lockvar)						\ 			evthreadimpl_lock_lock_(mode, lockvar);		\ 	} while (0)
comment|/** Release a lock */
define|#
directive|define
name|EVLOCK_UNLOCK
parameter_list|(
name|lockvar
parameter_list|,
name|mode
parameter_list|)
define|\
value|do {								\ 		if (lockvar)						\ 			evthreadimpl_lock_unlock_(mode, lockvar);	\ 	} while (0)
comment|/** Lock an event_base, if it is set up for locking.  Acquires the lock     in the base structure whose field is named 'lockvar'. */
define|#
directive|define
name|EVBASE_ACQUIRE_LOCK
parameter_list|(
name|base
parameter_list|,
name|lockvar
parameter_list|)
value|do {				\ 		EVLOCK_LOCK((base)->lockvar, 0);			\ 	} while (0)
comment|/** Unlock an event_base, if it is set up for locking. */
define|#
directive|define
name|EVBASE_RELEASE_LOCK
parameter_list|(
name|base
parameter_list|,
name|lockvar
parameter_list|)
value|do {				\ 		EVLOCK_UNLOCK((base)->lockvar, 0);			\ 	} while (0)
comment|/** If lock debugging is enabled, and lock is non-null, assert that 'lock' is  * locked and held by us. */
define|#
directive|define
name|EVLOCK_ASSERT_LOCKED
parameter_list|(
name|lock
parameter_list|)
define|\
value|do {								\ 		if ((lock)&& evthreadimpl_is_lock_debugging_enabled_()) { \ 			EVUTIL_ASSERT(evthread_is_debug_lock_held_(lock)); \ 		}							\ 	} while (0)
comment|/** Try to grab the lock for 'lockvar' without blocking, and return 1 if we  * manage to get it. */
specifier|static
specifier|inline
name|int
name|EVLOCK_TRY_LOCK_
parameter_list|(
name|void
modifier|*
name|lock
parameter_list|)
function_decl|;
specifier|static
specifier|inline
name|int
name|EVLOCK_TRY_LOCK_
parameter_list|(
name|void
modifier|*
name|lock
parameter_list|)
block|{
if|if
condition|(
name|lock
condition|)
block|{
name|int
name|r
init|=
name|evthreadimpl_lock_lock_
argument_list|(
name|EVTHREAD_TRY
argument_list|,
name|lock
argument_list|)
decl_stmt|;
return|return
operator|!
name|r
return|;
block|}
else|else
block|{
comment|/* Locking is disabled either globally or for this thing; 		 * of course we count as having the lock. */
return|return
literal|1
return|;
block|}
block|}
comment|/** Allocate a new condition variable and store it in the void *, condvar */
define|#
directive|define
name|EVTHREAD_ALLOC_COND
parameter_list|(
name|condvar
parameter_list|)
define|\
value|do {								\ 		(condvar) = evthreadimpl_cond_alloc_(0);		\ 	} while (0)
comment|/** Deallocate and free a condition variable in condvar */
define|#
directive|define
name|EVTHREAD_FREE_COND
parameter_list|(
name|cond
parameter_list|)
define|\
value|do {								\ 		if (cond)						\ 			evthreadimpl_cond_free_((cond));		\ 	} while (0)
comment|/** Signal one thread waiting on cond */
define|#
directive|define
name|EVTHREAD_COND_SIGNAL
parameter_list|(
name|cond
parameter_list|)
define|\
value|( (cond) ? evthreadimpl_cond_signal_((cond), 0) : 0 )
comment|/** Signal all threads waiting on cond */
define|#
directive|define
name|EVTHREAD_COND_BROADCAST
parameter_list|(
name|cond
parameter_list|)
define|\
value|( (cond) ? evthreadimpl_cond_signal_((cond), 1) : 0 )
comment|/** Wait until the condition 'cond' is signalled.  Must be called while  * holding 'lock'.  The lock will be released until the condition is  * signalled, at which point it will be acquired again.  Returns 0 for  * success, -1 for failure. */
define|#
directive|define
name|EVTHREAD_COND_WAIT
parameter_list|(
name|cond
parameter_list|,
name|lock
parameter_list|)
define|\
value|( (cond) ? evthreadimpl_cond_wait_((cond), (lock), NULL) : 0 )
comment|/** As EVTHREAD_COND_WAIT, but gives up after 'tv' has elapsed.  Returns 1  * on timeout. */
define|#
directive|define
name|EVTHREAD_COND_WAIT_TIMED
parameter_list|(
name|cond
parameter_list|,
name|lock
parameter_list|,
name|tv
parameter_list|)
define|\
value|( (cond) ? evthreadimpl_cond_wait_((cond), (lock), (tv)) : 0 )
define|#
directive|define
name|EVTHREAD_LOCKING_ENABLED
parameter_list|()
define|\
value|(evthreadimpl_locking_enabled_())
else|#
directive|else
comment|/* EVENT__DISABLE_THREAD_SUPPORT */
define|#
directive|define
name|EVTHREAD_GET_ID
parameter_list|()
value|1
define|#
directive|define
name|EVTHREAD_ALLOC_LOCK
parameter_list|(
name|lockvar
parameter_list|,
name|locktype
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVTHREAD_FREE_LOCK
parameter_list|(
name|lockvar
parameter_list|,
name|locktype
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVLOCK_LOCK
parameter_list|(
name|lockvar
parameter_list|,
name|mode
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVLOCK_UNLOCK
parameter_list|(
name|lockvar
parameter_list|,
name|mode
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVLOCK_LOCK2
parameter_list|(
name|lock1
parameter_list|,
name|lock2
parameter_list|,
name|mode1
parameter_list|,
name|mode2
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVLOCK_UNLOCK2
parameter_list|(
name|lock1
parameter_list|,
name|lock2
parameter_list|,
name|mode1
parameter_list|,
name|mode2
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVBASE_IN_THREAD
parameter_list|(
name|base
parameter_list|)
value|1
define|#
directive|define
name|EVBASE_NEED_NOTIFY
parameter_list|(
name|base
parameter_list|)
value|0
define|#
directive|define
name|EVBASE_ACQUIRE_LOCK
parameter_list|(
name|base
parameter_list|,
name|lock
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVBASE_RELEASE_LOCK
parameter_list|(
name|base
parameter_list|,
name|lock
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVLOCK_ASSERT_LOCKED
parameter_list|(
name|lock
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVLOCK_TRY_LOCK_
parameter_list|(
name|lock
parameter_list|)
value|1
define|#
directive|define
name|EVTHREAD_ALLOC_COND
parameter_list|(
name|condvar
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVTHREAD_FREE_COND
parameter_list|(
name|cond
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVTHREAD_COND_SIGNAL
parameter_list|(
name|cond
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVTHREAD_COND_BROADCAST
parameter_list|(
name|cond
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVTHREAD_COND_WAIT
parameter_list|(
name|cond
parameter_list|,
name|lock
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVTHREAD_COND_WAIT_TIMED
parameter_list|(
name|cond
parameter_list|,
name|lock
parameter_list|,
name|howlong
parameter_list|)
value|EVUTIL_NIL_STMT_
define|#
directive|define
name|EVTHREAD_LOCKING_ENABLED
parameter_list|()
value|0
endif|#
directive|endif
comment|/* This code is shared between both lock impls */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EVENT__DISABLE_THREAD_SUPPORT
argument_list|)
comment|/** Helper: put lockvar1 and lockvar2 into pointerwise ascending order. */
define|#
directive|define
name|EVLOCK_SORTLOCKS_
parameter_list|(
name|lockvar1
parameter_list|,
name|lockvar2
parameter_list|)
define|\
value|do {								\ 		if (lockvar1&& lockvar2&& lockvar1> lockvar2) {	\ 			void *tmp = lockvar1;				\ 			lockvar1 = lockvar2;				\ 			lockvar2 = tmp;					\ 		}							\ 	} while (0)
comment|/** Acquire both lock1 and lock2.  Always allocates locks in the same order,  * so that two threads locking two locks with LOCK2 will not deadlock. */
define|#
directive|define
name|EVLOCK_LOCK2
parameter_list|(
name|lock1
parameter_list|,
name|lock2
parameter_list|,
name|mode1
parameter_list|,
name|mode2
parameter_list|)
define|\
value|do {								\ 		void *lock1_tmplock_ = (lock1);				\ 		void *lock2_tmplock_ = (lock2);				\ 		EVLOCK_SORTLOCKS_(lock1_tmplock_,lock2_tmplock_);	\ 		EVLOCK_LOCK(lock1_tmplock_,mode1);			\ 		if (lock2_tmplock_ != lock1_tmplock_)			\ 			EVLOCK_LOCK(lock2_tmplock_,mode2);		\ 	} while (0)
comment|/** Release both lock1 and lock2.  */
define|#
directive|define
name|EVLOCK_UNLOCK2
parameter_list|(
name|lock1
parameter_list|,
name|lock2
parameter_list|,
name|mode1
parameter_list|,
name|mode2
parameter_list|)
define|\
value|do {								\ 		void *lock1_tmplock_ = (lock1);				\ 		void *lock2_tmplock_ = (lock2);				\ 		EVLOCK_SORTLOCKS_(lock1_tmplock_,lock2_tmplock_);	\ 		if (lock2_tmplock_ != lock1_tmplock_)			\ 			EVLOCK_UNLOCK(lock2_tmplock_,mode2);		\ 		EVLOCK_UNLOCK(lock1_tmplock_,mode1);			\ 	} while (0)
name|int
name|evthread_is_debug_lock_held_
parameter_list|(
name|void
modifier|*
name|lock
parameter_list|)
function_decl|;
name|void
modifier|*
name|evthread_debug_get_real_lock_
parameter_list|(
name|void
modifier|*
name|lock
parameter_list|)
function_decl|;
name|void
modifier|*
name|evthread_setup_global_lock_
parameter_list|(
name|void
modifier|*
name|lock_
parameter_list|,
name|unsigned
name|locktype
parameter_list|,
name|int
name|enable_locks
parameter_list|)
function_decl|;
define|#
directive|define
name|EVTHREAD_SETUP_GLOBAL_LOCK
parameter_list|(
name|lockvar
parameter_list|,
name|locktype
parameter_list|)
define|\
value|do {								\ 		lockvar = evthread_setup_global_lock_(lockvar,		\ 		    (locktype), enable_locks);				\ 		if (!lockvar) {						\ 			event_warn("Couldn't allocate %s", #lockvar);	\ 			return -1;					\ 		}							\ 	} while (0);
name|int
name|event_global_setup_locks_
parameter_list|(
specifier|const
name|int
name|enable_locks
parameter_list|)
function_decl|;
name|int
name|evsig_global_setup_locks_
parameter_list|(
specifier|const
name|int
name|enable_locks
parameter_list|)
function_decl|;
name|int
name|evutil_global_setup_locks_
parameter_list|(
specifier|const
name|int
name|enable_locks
parameter_list|)
function_decl|;
name|int
name|evutil_secure_rng_global_setup_locks_
parameter_list|(
specifier|const
name|int
name|enable_locks
parameter_list|)
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EVTHREAD_INTERNAL_H_INCLUDED_ */
end_comment

end_unit

