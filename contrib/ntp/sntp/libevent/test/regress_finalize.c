begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"tinytest.h"
end_include

begin_include
include|#
directive|include
file|"tinytest_macros.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_include
include|#
directive|include
file|"defer-internal.h"
end_include

begin_include
include|#
directive|include
file|"regress.h"
end_include

begin_include
include|#
directive|include
file|"regress_thread.h"
end_include

begin_function
specifier|static
name|void
name|timer_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|int_arg
init|=
name|arg
decl_stmt|;
operator|*
name|int_arg
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|what
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|simple_callback
parameter_list|(
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|int_arg
init|=
name|arg
decl_stmt|;
operator|*
name|int_arg
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|evcb
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_finalize_callback_1
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|int_arg
init|=
name|arg
decl_stmt|;
operator|*
name|int_arg
operator|+=
literal|100
expr_stmt|;
operator|(
name|void
operator|)
name|ev
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|callback_finalize_callback_1
parameter_list|(
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|int_arg
init|=
name|arg
decl_stmt|;
operator|*
name|int_arg
operator|+=
literal|100
expr_stmt|;
operator|(
name|void
operator|)
name|evcb
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_fin_cb_invoked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
name|struct
name|event
name|ev2
decl_stmt|;
name|struct
name|event_callback
name|evcb
decl_stmt|;
name|int
name|cb_called
init|=
literal|0
decl_stmt|;
name|int
name|ev_called
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|timeval
name|ten_sec
init|=
block|{
literal|10
block|,
literal|0
block|}
decl_stmt|;
name|event_deferred_cb_init_
argument_list|(
operator|&
name|evcb
argument_list|,
literal|0
argument_list|,
name|simple_callback
argument_list|,
operator|&
name|cb_called
argument_list|)
expr_stmt|;
name|ev
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|timer_callback
argument_list|,
operator|&
name|ev_called
argument_list|)
expr_stmt|;
comment|/* Just finalize them; don't bother adding. */
name|event_free_finalize
argument_list|(
literal|0
argument_list|,
name|ev
argument_list|,
name|event_finalize_callback_1
argument_list|)
expr_stmt|;
name|event_callback_finalize_
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
operator|&
name|evcb
argument_list|,
name|callback_finalize_callback_1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|cb_called
argument_list|,
operator|==
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev_called
argument_list|,
operator|==
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|ev_called
operator|=
name|cb_called
operator|=
literal|0
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Now try it when they're active. (actually, don't finalize: make 	 * sure activation can happen! */
name|ev
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|timer_callback
argument_list|,
operator|&
name|ev_called
argument_list|)
expr_stmt|;
name|event_deferred_cb_init_
argument_list|(
operator|&
name|evcb
argument_list|,
literal|0
argument_list|,
name|simple_callback
argument_list|,
operator|&
name|cb_called
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
name|ev
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_callback_activate_
argument_list|(
name|base
argument_list|,
operator|&
name|evcb
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|cb_called
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev_called
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ev_called
operator|=
name|cb_called
operator|=
literal|0
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Great, it worked. Now activate and finalize and make sure only 	 * finalizing happens. */
name|event_active
argument_list|(
name|ev
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_callback_activate_
argument_list|(
name|base
argument_list|,
operator|&
name|evcb
argument_list|)
expr_stmt|;
name|event_free_finalize
argument_list|(
literal|0
argument_list|,
name|ev
argument_list|,
name|event_finalize_callback_1
argument_list|)
expr_stmt|;
name|event_callback_finalize_
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
operator|&
name|evcb
argument_list|,
name|callback_finalize_callback_1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|cb_called
argument_list|,
operator|==
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev_called
argument_list|,
operator|==
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|ev_called
operator|=
literal|0
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Okay, now add but don't have it become active, and make sure *that* 	 * works. */
name|ev
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|timer_callback
argument_list|,
operator|&
name|ev_called
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev
argument_list|,
operator|&
name|ten_sec
argument_list|)
expr_stmt|;
name|event_free_finalize
argument_list|(
literal|0
argument_list|,
name|ev
argument_list|,
name|event_finalize_callback_1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev_called
argument_list|,
operator|==
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|ev_called
operator|=
literal|0
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Now try adding and deleting after finalizing. */
name|ev
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|timer_callback
argument_list|,
operator|&
name|ev_called
argument_list|)
expr_stmt|;
name|evtimer_assign
argument_list|(
operator|&
name|ev2
argument_list|,
name|base
argument_list|,
name|timer_callback
argument_list|,
operator|&
name|ev_called
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev
argument_list|,
operator|&
name|ten_sec
argument_list|)
expr_stmt|;
name|event_free_finalize
argument_list|(
literal|0
argument_list|,
name|ev
argument_list|,
name|event_finalize_callback_1
argument_list|)
expr_stmt|;
name|event_finalize
argument_list|(
literal|0
argument_list|,
operator|&
name|ev2
argument_list|,
name|event_finalize_callback_1
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|ev2
argument_list|,
operator|&
name|ten_sec
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|ev2
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev_called
argument_list|,
operator|==
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__DISABLE_MM_REPLACEMENT
end_ifndef

begin_function
specifier|static
name|void
modifier|*
name|tfff_malloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
modifier|*
name|tfff_p1
init|=
name|NULL
decl_stmt|,
modifier|*
name|tfff_p2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tfff_p1_freed
init|=
literal|0
decl_stmt|,
name|tfff_p2_freed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tfff_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return;
if|if
condition|(
name|p
operator|==
name|tfff_p1
condition|)
operator|++
name|tfff_p1_freed
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|tfff_p2
condition|)
operator|++
name|tfff_p2_freed
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|tfff_realloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
return|return
name|realloc
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|test_fin_free_finalize
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EVENT__DISABLE_MM_REPLACEMENT
name|tinytest_set_test_skipped_
argument_list|()
expr_stmt|;
else|#
directive|else
name|struct
name|event_base
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|,
modifier|*
name|ev2
decl_stmt|;
name|int
name|ev_called
init|=
literal|0
decl_stmt|;
name|int
name|ev2_called
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|arg
expr_stmt|;
name|event_set_mem_functions
argument_list|(
name|tfff_malloc
argument_list|,
name|tfff_realloc
argument_list|,
name|tfff_free
argument_list|)
expr_stmt|;
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|ev
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|timer_callback
argument_list|,
operator|&
name|ev_called
argument_list|)
expr_stmt|;
name|ev2
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|timer_callback
argument_list|,
operator|&
name|ev2_called
argument_list|)
expr_stmt|;
name|tfff_p1
operator|=
name|ev
expr_stmt|;
name|tfff_p2
operator|=
name|ev2
expr_stmt|;
name|event_free_finalize
argument_list|(
literal|0
argument_list|,
name|ev
argument_list|,
name|event_finalize_callback_1
argument_list|)
expr_stmt|;
name|event_finalize
argument_list|(
literal|0
argument_list|,
name|ev2
argument_list|,
name|event_finalize_callback_1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev_called
argument_list|,
operator|==
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev2_called
argument_list|,
operator|==
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|tfff_p1_freed
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|tfff_p2_freed
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|ev2
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|base
condition|)
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* For test_fin_within_cb */
end_comment

begin_struct
struct|struct
name|event_and_count
block|{
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
name|struct
name|event
modifier|*
name|ev2
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|event_finalize_callback_2
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event_and_count
modifier|*
name|evc
init|=
name|arg
decl_stmt|;
name|evc
operator|->
name|count
operator|+=
literal|100
expr_stmt|;
name|event_free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timer_callback_2
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event_and_count
modifier|*
name|evc
init|=
name|arg
decl_stmt|;
name|event_finalize
argument_list|(
literal|0
argument_list|,
name|evc
operator|->
name|ev
argument_list|,
name|event_finalize_callback_2
argument_list|)
expr_stmt|;
name|event_finalize
argument_list|(
literal|0
argument_list|,
name|evc
operator|->
name|ev2
argument_list|,
name|event_finalize_callback_2
argument_list|)
expr_stmt|;
operator|++
name|evc
operator|->
name|count
expr_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|what
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_fin_within_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event_and_count
name|evc1
decl_stmt|,
name|evc2
decl_stmt|;
name|evc1
operator|.
name|count
operator|=
name|evc2
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|evc2
operator|.
name|ev2
operator|=
name|evc1
operator|.
name|ev
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|timer_callback_2
argument_list|,
operator|&
name|evc1
argument_list|)
expr_stmt|;
name|evc1
operator|.
name|ev2
operator|=
name|evc2
operator|.
name|ev
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|timer_callback_2
argument_list|,
operator|&
name|evc2
argument_list|)
expr_stmt|;
comment|/* Activate both.  The first one will have its callback run, which 	 * will finalize both of them, preventing the second one's callback 	 * from running. */
name|event_active
argument_list|(
name|evc1
operator|.
name|ev
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
name|evc2
operator|.
name|ev
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evc1
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|101
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evc2
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Now try with EV_PERSIST events. */
name|evc1
operator|.
name|count
operator|=
name|evc2
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|evc2
operator|.
name|ev2
operator|=
name|evc1
operator|.
name|ev
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_PERSIST
argument_list|,
name|timer_callback_2
argument_list|,
operator|&
name|evc1
argument_list|)
expr_stmt|;
name|evc1
operator|.
name|ev2
operator|=
name|evc2
operator|.
name|ev
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_PERSIST
argument_list|,
name|timer_callback_2
argument_list|,
operator|&
name|evc2
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
name|evc1
operator|.
name|ev
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
name|evc2
operator|.
name|ev
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evc1
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|101
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evc2
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void timer_callback_3(evutil_socket_t *fd, short what, void *arg) { 	(void)fd; 	(void)what;  } static void test_fin_many(void *arg) { 	struct basic_test_data *data = arg; 	struct event_base *base = data->base;  	struct event *ev1, *ev2; 	struct event_callback evcb1, evcb2; 	int ev1_count = 0, ev2_count = 0; 	int evcb1_count = 0, evcb2_count = 0; 	struct event_callback *array[4];  	int n;
comment|/* First attempt: call finalize_many with no events running */
end_comment

begin_endif
unit|ev1 = evtimer_new(base, timer_callback,&ev1_count); 	ev1 = evtimer_new(base, timer_callback,&ev2_count); 	event_deferred_cb_init_(&evcb1, 0, simple_callback,&evcb1_called); 	event_deferred_cb_init_(&evcb2, 0, simple_callback,&evcb2_called); 	array[0] =&ev1->ev_evcallback; 	array[1] =&ev2->ev_evcallback; 	array[2] =&evcb1; 	array[3] =&evcb2;  	  	n = event_callback_finalize_many(base, 4, array, 	    callback_finalize_callback_1);  }
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TEST
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
define|\
value|{ #name, test_fin_##name, (flags),&basic_setup, NULL }
end_define

begin_decl_stmt
name|struct
name|testcase_t
name|finalize_testcases
index|[]
init|=
block|{
name|TEST
argument_list|(
name|cb_invoked
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
name|TEST
argument_list|(
name|free_finalize
argument_list|,
name|TT_FORK
argument_list|)
block|,
name|TEST
argument_list|(
name|within_cb
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
comment|//	TEST(many, TT_FORK|TT_NEED_BASE),
name|END_OF_TESTCASES
block|}
decl_stmt|;
end_decl_stmt

end_unit

