begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_comment
comment|/* The old tests here need assertions to work. */
end_comment

begin_undef
undef|#
directive|undef
name|NDEBUG
end_undef

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_PTHREADS
end_ifdef

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"sys/queue.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/thread.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_include
include|#
directive|include
file|"defer-internal.h"
end_include

begin_include
include|#
directive|include
file|"regress.h"
end_include

begin_include
include|#
directive|include
file|"tinytest_macros.h"
end_include

begin_include
include|#
directive|include
file|"time-internal.h"
end_include

begin_include
include|#
directive|include
file|"regress_thread.h"
end_include

begin_struct
struct|struct
name|cond_wait
block|{
name|void
modifier|*
name|lock
decl_stmt|;
name|void
modifier|*
name|cond
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|wake_all_timeout
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cond_wait
modifier|*
name|cw
init|=
name|arg
decl_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|cw
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVTHREAD_COND_BROADCAST
argument_list|(
name|cw
operator|->
name|cond
argument_list|)
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|cw
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wake_one_timeout
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cond_wait
modifier|*
name|cw
init|=
name|arg
decl_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|cw
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVTHREAD_COND_SIGNAL
argument_list|(
name|cw
operator|->
name|cond
argument_list|)
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|cw
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NUM_THREADS
value|100
end_define

begin_define
define|#
directive|define
name|NUM_ITERATIONS
value|100
end_define

begin_decl_stmt
name|void
modifier|*
name|count_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|THREAD_FN
name|basic_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cond_wait
name|cw
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|arg
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|cw
operator|.
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVTHREAD_ALLOC_COND
argument_list|(
name|cw
operator|.
name|cond
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cw
operator|.
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cw
operator|.
name|cond
argument_list|)
expr_stmt|;
name|evtimer_assign
argument_list|(
operator|&
name|ev
argument_list|,
name|base
argument_list|,
name|wake_all_timeout
argument_list|,
operator|&
name|cw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ITERATIONS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|3000
expr_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|cw
operator|.
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we need to make sure that event does not happen before 		 * we get to wait on the conditional variable */
name|assert
argument_list|(
name|evtimer_add
argument_list|(
operator|&
name|ev
argument_list|,
operator|&
name|tv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|EVTHREAD_COND_WAIT
argument_list|(
name|cw
operator|.
name|cond
argument_list|,
name|cw
operator|.
name|lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|cw
operator|.
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* exit the loop only if all threads fired all timeouts */
name|EVLOCK_LOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|NUM_THREADS
operator|*
name|NUM_ITERATIONS
condition|)
name|event_base_loopexit
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_LOCK
argument_list|(
name|cw
operator|.
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_COND
argument_list|(
name|cw
operator|.
name|cond
argument_list|)
expr_stmt|;
name|THREAD_RETURN
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|notification_fd_used
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|got_sigchld
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sigchld_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|arg
decl_stmt|;
name|got_sigchld
operator|++
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|100000
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|base
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_fd_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
operator|++
name|notification_fd_used
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|thread_basic
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|THREAD_T
name|threads
index|[
name|NUM_THREADS
index|]
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
modifier|*
name|notification_event
init|=
name|NULL
decl_stmt|;
name|struct
name|event
modifier|*
name|sigchld_event
init|=
name|NULL
decl_stmt|;
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|count_lock
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|evthread_make_base_notifiable
argument_list|(
name|base
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_abort_msg
argument_list|(
literal|"Couldn't make base notifiable!"
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|_WIN32
if|if
condition|(
name|data
operator|->
name|setup_data
operator|&&
operator|!
name|strcmp
argument_list|(
name|data
operator|->
name|setup_data
argument_list|,
literal|"forking"
argument_list|)
condition|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|sigchld_event
operator|=
name|evsignal_new
argument_list|(
name|base
argument_list|,
name|SIGCHLD
argument_list|,
name|sigchld_cb
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* This piggybacks on the th_notify_fd weirdly, and looks 		 * inside libevent internals.  Not a good idea in non-testing 		 * code! */
name|notification_event
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|notify_fd_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|sigchld_event
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|notification_event
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|event_del
argument_list|(
name|notification_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_reinit
argument_list|(
name|base
argument_list|)
operator|<
literal|0
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"reinit"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|event_assign
argument_list|(
name|notification_event
argument_list|,
name|base
argument_list|,
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|notify_fd_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|notification_event
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|child
goto|;
block|}
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|tt_abort_perror
argument_list|(
literal|"waitpid"
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Waitpid okay\n"
operator|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|got_sigchld
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|notification_fd_used
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|child
label|:
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
operator|++
name|i
control|)
name|THREAD_START
argument_list|(
name|threads
index|[
name|i
index|]
argument_list|,
name|basic_thread
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|evtimer_assign
argument_list|(
operator|&
name|ev
argument_list|,
name|base
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|1000
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
operator|++
name|i
control|)
name|THREAD_JOIN
argument_list|(
name|threads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|count
argument_list|,
operator|==
argument_list|,
name|NUM_THREADS
operator|*
name|NUM_ITERATIONS
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_LOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"notifiations==%d"
operator|,
name|notification_fd_used
operator|)
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|notification_event
condition|)
name|event_free
argument_list|(
name|notification_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigchld_event
condition|)
name|event_free
argument_list|(
name|sigchld_event
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|NUM_THREADS
end_undef

begin_define
define|#
directive|define
name|NUM_THREADS
value|10
end_define

begin_struct
struct|struct
name|alerted_record
block|{
name|struct
name|cond_wait
modifier|*
name|cond
decl_stmt|;
name|struct
name|timeval
name|delay
decl_stmt|;
name|struct
name|timeval
name|alerted_at
decl_stmt|;
name|int
name|timed_out
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|THREAD_FN
name|wait_for_condition
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|alerted_record
modifier|*
name|rec
init|=
name|arg
decl_stmt|;
name|int
name|r
decl_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|rec
operator|->
name|cond
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|delay
operator|.
name|tv_sec
operator|||
name|rec
operator|->
name|delay
operator|.
name|tv_usec
condition|)
block|{
name|r
operator|=
name|EVTHREAD_COND_WAIT_TIMED
argument_list|(
name|rec
operator|->
name|cond
operator|->
name|cond
argument_list|,
name|rec
operator|->
name|cond
operator|->
name|lock
argument_list|,
operator|&
name|rec
operator|->
name|delay
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|EVTHREAD_COND_WAIT
argument_list|(
name|rec
operator|->
name|cond
operator|->
name|cond
argument_list|,
name|rec
operator|->
name|cond
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|EVLOCK_UNLOCK
argument_list|(
name|rec
operator|->
name|cond
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|rec
operator|->
name|alerted_at
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|1
condition|)
name|rec
operator|->
name|timed_out
operator|=
literal|1
expr_stmt|;
name|THREAD_RETURN
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_conditions_simple
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|timeval
name|tv_signal
decl_stmt|,
name|tv_timeout
decl_stmt|,
name|tv_broadcast
decl_stmt|;
name|struct
name|alerted_record
name|alerted
index|[
name|NUM_THREADS
index|]
decl_stmt|;
name|THREAD_T
name|threads
index|[
name|NUM_THREADS
index|]
decl_stmt|;
name|struct
name|cond_wait
name|cond
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|launched_at
decl_stmt|;
name|struct
name|event
name|wake_one
decl_stmt|;
name|struct
name|event
name|wake_all
decl_stmt|;
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|int
name|n_timed_out
init|=
literal|0
decl_stmt|,
name|n_signal
init|=
literal|0
decl_stmt|,
name|n_broadcast
init|=
literal|0
decl_stmt|;
name|tv_signal
operator|.
name|tv_sec
operator|=
name|tv_timeout
operator|.
name|tv_sec
operator|=
name|tv_broadcast
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv_signal
operator|.
name|tv_usec
operator|=
literal|30
operator|*
literal|1000
expr_stmt|;
name|tv_timeout
operator|.
name|tv_usec
operator|=
literal|150
operator|*
literal|1000
expr_stmt|;
name|tv_broadcast
operator|.
name|tv_usec
operator|=
literal|500
operator|*
literal|1000
expr_stmt|;
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|cond
operator|.
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|EVTHREAD_ALLOC_COND
argument_list|(
name|cond
operator|.
name|cond
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cond
operator|.
name|lock
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cond
operator|.
name|cond
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
operator|++
name|i
control|)
block|{
name|memset
argument_list|(
operator|&
name|alerted
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alerted_record
argument_list|)
argument_list|)
expr_stmt|;
name|alerted
index|[
name|i
index|]
operator|.
name|cond
operator|=
operator|&
name|cond
expr_stmt|;
block|}
comment|/* Threads 5 and 6 will be allowed to time out */
name|memcpy
argument_list|(
operator|&
name|alerted
index|[
literal|5
index|]
operator|.
name|delay
argument_list|,
operator|&
name|tv_timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|tv_timeout
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|alerted
index|[
literal|6
index|]
operator|.
name|delay
argument_list|,
operator|&
name|tv_timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|tv_timeout
argument_list|)
argument_list|)
expr_stmt|;
name|evtimer_assign
argument_list|(
operator|&
name|wake_one
argument_list|,
name|base
argument_list|,
name|wake_one_timeout
argument_list|,
operator|&
name|cond
argument_list|)
expr_stmt|;
name|evtimer_assign
argument_list|(
operator|&
name|wake_all
argument_list|,
name|base
argument_list|,
name|wake_all_timeout
argument_list|,
operator|&
name|cond
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|launched_at
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Launch the threads... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
operator|++
name|i
control|)
block|{
name|THREAD_START
argument_list|(
name|threads
index|[
name|i
index|]
argument_list|,
name|wait_for_condition
argument_list|,
operator|&
name|alerted
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Start the timers... */
name|tt_int_op
argument_list|(
name|event_add
argument_list|(
operator|&
name|wake_one
argument_list|,
operator|&
name|tv_signal
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_add
argument_list|(
operator|&
name|wake_all
argument_list|,
operator|&
name|tv_broadcast
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* And run for a bit... */
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* And wait till the threads are done. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
operator|++
name|i
control|)
name|THREAD_JOIN
argument_list|(
name|threads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Now, let's see what happened. At least one of 5 or 6 should 	 * have timed out. */
name|n_timed_out
operator|=
name|alerted
index|[
literal|5
index|]
operator|.
name|timed_out
operator|+
name|alerted
index|[
literal|6
index|]
operator|.
name|timed_out
expr_stmt|;
name|tt_int_op
argument_list|(
name|n_timed_out
argument_list|,
operator|>=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n_timed_out
argument_list|,
operator|<=
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|struct
name|timeval
modifier|*
name|target_delay
decl_stmt|;
name|struct
name|timeval
name|target_time
decl_stmt|,
name|actual_delay
decl_stmt|;
if|if
condition|(
name|alerted
index|[
name|i
index|]
operator|.
name|timed_out
condition|)
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"%d looks like a timeout\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|target_delay
operator|=
operator|&
name|tv_timeout
expr_stmt|;
name|tt_assert
argument_list|(
name|i
operator|==
literal|5
operator|||
name|i
operator|==
literal|6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evutil_timerisset
argument_list|(
operator|&
name|alerted
index|[
name|i
index|]
operator|.
name|alerted_at
argument_list|)
condition|)
block|{
name|long
name|diff1
decl_stmt|,
name|diff2
decl_stmt|;
name|evutil_timersub
argument_list|(
operator|&
name|alerted
index|[
name|i
index|]
operator|.
name|alerted_at
argument_list|,
operator|&
name|launched_at
argument_list|,
operator|&
name|actual_delay
argument_list|)
expr_stmt|;
name|diff1
operator|=
name|timeval_msec_diff
argument_list|(
operator|&
name|actual_delay
argument_list|,
operator|&
name|tv_signal
argument_list|)
expr_stmt|;
name|diff2
operator|=
name|timeval_msec_diff
argument_list|(
operator|&
name|actual_delay
argument_list|,
operator|&
name|tv_broadcast
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|diff1
argument_list|)
operator|<
name|abs
argument_list|(
name|diff2
argument_list|)
condition|)
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"%d looks like a signal\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|target_delay
operator|=
operator|&
name|tv_signal
expr_stmt|;
operator|++
name|n_signal
expr_stmt|;
block|}
else|else
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"%d looks like a broadcast\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|target_delay
operator|=
operator|&
name|tv_broadcast
expr_stmt|;
operator|++
name|n_broadcast
expr_stmt|;
block|}
block|}
else|else
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Thread %d never got woken"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|evutil_timeradd
argument_list|(
name|target_delay
argument_list|,
operator|&
name|launched_at
argument_list|,
operator|&
name|target_time
argument_list|)
expr_stmt|;
name|test_timeval_diff_leq
argument_list|(
operator|&
name|target_time
argument_list|,
operator|&
name|alerted
index|[
name|i
index|]
operator|.
name|alerted_at
argument_list|,
literal|0
argument_list|,
literal|50
argument_list|)
expr_stmt|;
block|}
name|tt_int_op
argument_list|(
name|n_broadcast
operator|+
name|n_signal
operator|+
name|n_timed_out
argument_list|,
operator|==
argument_list|,
name|NUM_THREADS
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n_signal
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CB_COUNT
value|128
end_define

begin_define
define|#
directive|define
name|QUEUE_THREAD_COUNT
value|8
end_define

begin_function
specifier|static
name|void
name|SLEEP_MS
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|ms
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|ms
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|evutil_usleep_
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|deferred_test_data
block|{
name|struct
name|event_callback
name|cbs
index|[
name|CB_COUNT
index|]
decl_stmt|;
name|struct
name|event_base
modifier|*
name|queue
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|timer_start
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|timer_end
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|callback_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|THREAD_T
name|load_threads
index|[
name|QUEUE_THREAD_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|deferred_test_data
name|deferred_data
index|[
name|QUEUE_THREAD_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|deferred_callback
parameter_list|(
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|SLEEP_MS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|callback_count
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|THREAD_FN
name|load_deferred_queue
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|deferred_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CB_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|event_deferred_cb_init_
argument_list|(
operator|&
name|data
operator|->
name|cbs
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|deferred_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_deferred_cb_schedule_
argument_list|(
name|data
operator|->
name|queue
argument_list|,
operator|&
name|data
operator|->
name|cbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SLEEP_MS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|THREAD_RETURN
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timer_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|evutil_gettimeofday
argument_list|(
operator|&
name|timer_end
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_threads_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QUEUE_THREAD_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|THREAD_START
argument_list|(
name|load_threads
index|[
name|i
index|]
argument_list|,
name|load_deferred_queue
argument_list|,
operator|&
name|deferred_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|thread_deferred_cb_skew
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|timeval
name|tv_timer
init|=
block|{
literal|1
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|struct
name|event_config
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|elapsed
decl_stmt|;
name|int
name|elapsed_usec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cfg
operator|=
name|event_config_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|event_config_set_max_dispatch_interval
argument_list|(
name|cfg
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|event_base_new_with_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QUEUE_THREAD_COUNT
condition|;
operator|++
name|i
control|)
name|deferred_data
index|[
name|i
index|]
operator|.
name|queue
operator|=
name|base
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|timer_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_base_once
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|timer_callback
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv_timer
argument_list|)
expr_stmt|;
name|event_base_once
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|start_threads_callback
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|evutil_timersub
argument_list|(
operator|&
name|timer_end
argument_list|,
operator|&
name|timer_start
argument_list|,
operator|&
name|elapsed
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"callback count, %u"
operator|,
name|callback_count
operator|)
argument_list|)
expr_stmt|;
name|elapsed_usec
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|elapsed
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|elapsed
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"elapsed time, %u usec"
operator|,
name|elapsed_usec
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX be more intelligent here.  just make sure skew is 	 * within .4 seconds for now. */
name|tt_assert
argument_list|(
name|elapsed_usec
operator|>=
literal|600000
operator|&&
name|elapsed_usec
operator|<=
literal|1400000
argument_list|)
expr_stmt|;
name|end
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QUEUE_THREAD_COUNT
condition|;
operator|++
name|i
control|)
name|THREAD_JOIN
argument_list|(
name|load_threads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
name|event_config_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|event
name|time_events
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|times
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|event_base
modifier|*
name|exit_base
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|note_time_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|evutil_gettimeofday
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
operator|&
name|times
index|[
literal|4
index|]
condition|)
block|{
name|event_base_loopbreak
argument_list|(
name|exit_base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|THREAD_FN
name|register_events_subthread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|timeval
name|tv
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|SLEEP_MS
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|time_events
index|[
literal|0
index|]
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SLEEP_MS
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|time_events
index|[
literal|1
index|]
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SLEEP_MS
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|100
operator|*
literal|1000
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|time_events
index|[
literal|2
index|]
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|150
operator|*
literal|1000
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|time_events
index|[
literal|3
index|]
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|SLEEP_MS
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|time_events
index|[
literal|4
index|]
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|THREAD_RETURN
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_no_events
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|THREAD_T
name|thread
decl_stmt|;
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|timeval
name|starttime
decl_stmt|,
name|endtime
decl_stmt|;
name|int
name|i
decl_stmt|;
name|exit_base
operator|=
name|data
operator|->
name|base
expr_stmt|;
name|memset
argument_list|(
name|times
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|times
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
name|event_assign
argument_list|(
operator|&
name|time_events
index|[
name|i
index|]
argument_list|,
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|note_time_cb
argument_list|,
operator|&
name|times
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|evutil_gettimeofday
argument_list|(
operator|&
name|starttime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|THREAD_START
argument_list|(
name|thread
argument_list|,
name|register_events_subthread
argument_list|,
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
name|event_base_loop
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|EVLOOP_NO_EXIT_ON_EMPTY
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|endtime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|event_base_got_break
argument_list|(
name|data
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|THREAD_JOIN
argument_list|(
name|thread
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|diff
decl_stmt|;
name|double
name|sec
decl_stmt|;
name|evutil_timersub
argument_list|(
operator|&
name|times
index|[
name|i
index|]
argument_list|,
operator|&
name|starttime
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|sec
operator|=
name|diff
operator|.
name|tv_sec
operator|+
name|diff
operator|.
name|tv_usec
operator|/
literal|1.0e6
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"event %d at %.4f seconds"
operator|,
name|i
operator|,
name|sec
operator|)
argument_list|)
expr_stmt|;
block|}
name|test_timeval_diff_eq
argument_list|(
operator|&
name|starttime
argument_list|,
operator|&
name|times
index|[
literal|0
index|]
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|starttime
argument_list|,
operator|&
name|times
index|[
literal|1
index|]
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|starttime
argument_list|,
operator|&
name|times
index|[
literal|2
index|]
argument_list|,
literal|400
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|starttime
argument_list|,
operator|&
name|times
index|[
literal|3
index|]
argument_list|,
literal|450
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|starttime
argument_list|,
operator|&
name|times
index|[
literal|4
index|]
argument_list|,
literal|500
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|starttime
argument_list|,
operator|&
name|endtime
argument_list|,
literal|500
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|TEST
parameter_list|(
name|name
parameter_list|)
define|\
value|{ #name, thread_##name, TT_FORK|TT_NEED_THREADS|TT_NEED_BASE,	\&basic_setup, NULL }
end_define

begin_decl_stmt
name|struct
name|testcase_t
name|thread_testcases
index|[]
init|=
block|{
block|{
literal|"basic"
block|,
name|thread_basic
block|,
name|TT_FORK
operator||
name|TT_NEED_THREADS
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
ifndef|#
directive|ifndef
name|_WIN32
block|{
literal|"forking"
block|,
name|thread_basic
block|,
name|TT_FORK
operator||
name|TT_NEED_THREADS
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
operator|(
name|char
operator|*
operator|)
literal|"forking"
block|}
block|,
endif|#
directive|endif
name|TEST
argument_list|(
name|conditions_simple
argument_list|)
block|,
block|{
literal|"deferred_cb_skew"
block|,
name|thread_deferred_cb_skew
block|,
name|TT_FORK
operator||
name|TT_NEED_THREADS
operator||
name|TT_OFF_BY_DEFAULT
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
name|TEST
argument_list|(
name|no_events
argument_list|)
block|,
name|END_OF_TESTCASES
block|}
decl_stmt|;
end_decl_stmt

end_unit

