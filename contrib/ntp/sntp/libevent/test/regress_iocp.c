begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/thread.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent.h"
end_include

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<ws2tcpip.h>
end_include

begin_include
include|#
directive|include
file|"regress.h"
end_include

begin_include
include|#
directive|include
file|"tinytest.h"
end_include

begin_include
include|#
directive|include
file|"tinytest_macros.h"
end_include

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_undef
undef|#
directive|undef
name|WIN32_LEAN_AND_MEAN
end_undef

begin_include
include|#
directive|include
file|"iocp-internal.h"
end_include

begin_include
include|#
directive|include
file|"evbuffer-internal.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_comment
comment|/* FIXME remove these ones */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_define
define|#
directive|define
name|MAX_CALLS
value|16
end_define

begin_decl_stmt
specifier|static
name|void
modifier|*
name|count_lock
init|=
name|NULL
decl_stmt|,
modifier|*
name|count_cond
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|count_init
parameter_list|(
name|void
parameter_list|)
block|{
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVTHREAD_ALLOC_COND
argument_list|(
name|count_cond
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|count_lock
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|count_cond
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|count_free
parameter_list|(
name|void
parameter_list|)
block|{
name|EVTHREAD_FREE_LOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_COND
argument_list|(
name|count_cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|count_incr
parameter_list|(
name|void
parameter_list|)
block|{
name|EVLOCK_LOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|EVTHREAD_COND_BROADCAST
argument_list|(
name|count_cond
argument_list|)
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|count_wait_for
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|DWORD
name|elapsed
decl_stmt|;
name|int
name|rv
init|=
operator|-
literal|1
decl_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|ms
operator|>
literal|0
operator|&&
name|count
operator|!=
name|i
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|ms
operator|*
literal|1000
expr_stmt|;
name|elapsed
operator|=
name|GetTickCount
argument_list|()
expr_stmt|;
name|EVTHREAD_COND_WAIT_TIMED
argument_list|(
name|count_cond
argument_list|,
name|count_lock
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|elapsed
operator|=
name|GetTickCount
argument_list|()
operator|-
name|elapsed
expr_stmt|;
name|ms
operator|-=
name|elapsed
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|i
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|count_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_struct
struct|struct
name|dummy_overlapped
block|{
name|struct
name|event_overlapped
name|eo
decl_stmt|;
name|void
modifier|*
name|lock
decl_stmt|;
name|int
name|call_count
decl_stmt|;
name|uintptr_t
name|keys
index|[
name|MAX_CALLS
index|]
decl_stmt|;
name|ev_ssize_t
name|sizes
index|[
name|MAX_CALLS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|dummy_cb
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|o
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|ev_ssize_t
name|n
parameter_list|,
name|int
name|ok
parameter_list|)
block|{
name|struct
name|dummy_overlapped
modifier|*
name|d_o
init|=
name|EVUTIL_UPCAST
argument_list|(
name|o
argument_list|,
expr|struct
name|dummy_overlapped
argument_list|,
name|eo
argument_list|)
decl_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|d_o
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_o
operator|->
name|call_count
operator|<
name|MAX_CALLS
condition|)
block|{
name|d_o
operator|->
name|keys
index|[
name|d_o
operator|->
name|call_count
index|]
operator|=
name|key
expr_stmt|;
name|d_o
operator|->
name|sizes
index|[
name|d_o
operator|->
name|call_count
index|]
operator|=
name|n
expr_stmt|;
block|}
name|d_o
operator|->
name|call_count
operator|++
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|d_o
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count_incr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pair_is_in
parameter_list|(
name|struct
name|dummy_overlapped
modifier|*
name|o
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|ev_ssize_t
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|o
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|call_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|o
operator|->
name|keys
index|[
name|i
index|]
operator|==
name|key
operator|&&
name|o
operator|->
name|sizes
index|[
name|i
index|]
operator|==
name|n
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|EVLOCK_UNLOCK
argument_list|(
name|o
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_iocp_port
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|event_iocp_port
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|struct
name|dummy_overlapped
name|o1
decl_stmt|,
name|o2
decl_stmt|;
name|memset
argument_list|(
operator|&
name|o1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|o1
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|o2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|o2
argument_list|)
argument_list|)
expr_stmt|;
name|count_init
argument_list|()
expr_stmt|;
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|o1
operator|.
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|o2
operator|.
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|o1
operator|.
name|lock
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|o2
operator|.
name|lock
argument_list|)
expr_stmt|;
name|event_overlapped_init_
argument_list|(
operator|&
name|o1
operator|.
name|eo
argument_list|,
name|dummy_cb
argument_list|)
expr_stmt|;
name|event_overlapped_init_
argument_list|(
operator|&
name|o2
operator|.
name|eo
argument_list|,
name|dummy_cb
argument_list|)
expr_stmt|;
name|port
operator|=
name|event_iocp_port_launch_
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_iocp_activate_overlapped_
argument_list|(
name|port
argument_list|,
operator|&
name|o1
operator|.
name|eo
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_iocp_activate_overlapped_
argument_list|(
name|port
argument_list|,
operator|&
name|o2
operator|.
name|eo
argument_list|,
literal|20
argument_list|,
literal|200
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_iocp_activate_overlapped_
argument_list|(
name|port
argument_list|,
operator|&
name|o1
operator|.
name|eo
argument_list|,
literal|11
argument_list|,
literal|101
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_iocp_activate_overlapped_
argument_list|(
name|port
argument_list|,
operator|&
name|o2
operator|.
name|eo
argument_list|,
literal|21
argument_list|,
literal|201
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_iocp_activate_overlapped_
argument_list|(
name|port
argument_list|,
operator|&
name|o1
operator|.
name|eo
argument_list|,
literal|12
argument_list|,
literal|102
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_iocp_activate_overlapped_
argument_list|(
name|port
argument_list|,
operator|&
name|o2
operator|.
name|eo
argument_list|,
literal|22
argument_list|,
literal|202
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_iocp_activate_overlapped_
argument_list|(
name|port
argument_list|,
operator|&
name|o1
operator|.
name|eo
argument_list|,
literal|13
argument_list|,
literal|103
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_iocp_activate_overlapped_
argument_list|(
name|port
argument_list|,
operator|&
name|o2
operator|.
name|eo
argument_list|,
literal|23
argument_list|,
literal|203
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|count_wait_for
argument_list|(
literal|8
argument_list|,
literal|2000
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
operator|!
name|event_iocp_shutdown_
argument_list|(
name|port
argument_list|,
literal|2000
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|o1
operator|.
name|call_count
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|o2
operator|.
name|call_count
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|pair_is_in
argument_list|(
operator|&
name|o1
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|pair_is_in
argument_list|(
operator|&
name|o1
argument_list|,
literal|11
argument_list|,
literal|101
argument_list|)
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|pair_is_in
argument_list|(
operator|&
name|o1
argument_list|,
literal|12
argument_list|,
literal|102
argument_list|)
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|pair_is_in
argument_list|(
operator|&
name|o1
argument_list|,
literal|13
argument_list|,
literal|103
argument_list|)
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|pair_is_in
argument_list|(
operator|&
name|o2
argument_list|,
literal|20
argument_list|,
literal|200
argument_list|)
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|pair_is_in
argument_list|(
operator|&
name|o2
argument_list|,
literal|21
argument_list|,
literal|201
argument_list|)
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|pair_is_in
argument_list|(
operator|&
name|o2
argument_list|,
literal|22
argument_list|,
literal|202
argument_list|)
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|pair_is_in
argument_list|(
operator|&
name|o2
argument_list|,
literal|23
argument_list|,
literal|203
argument_list|)
argument_list|)
expr_stmt|;
name|end
label|:
name|EVTHREAD_FREE_LOCK
argument_list|(
name|o1
operator|.
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_LOCK
argument_list|(
name|o2
operator|.
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|count_free
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|evbuffer
modifier|*
name|rbuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|wbuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|read_complete
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|eo
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|ev_ssize_t
name|nbytes
parameter_list|,
name|int
name|ok
parameter_list|)
block|{
name|tt_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|evbuffer_commit_read_
argument_list|(
name|rbuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|count_incr
argument_list|()
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_complete
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|eo
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|ev_ssize_t
name|nbytes
parameter_list|,
name|int
name|ok
parameter_list|)
block|{
name|tt_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|evbuffer_commit_write_
argument_list|(
name|wbuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|count_incr
argument_list|()
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_iocp_evbuffer
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|event_overlapped
name|rol
decl_stmt|,
name|wol
decl_stmt|;
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_iocp_port
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|char
name|junk
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|count_init
argument_list|()
expr_stmt|;
name|event_overlapped_init_
argument_list|(
operator|&
name|rol
argument_list|,
name|read_complete
argument_list|)
expr_stmt|;
name|event_overlapped_init_
argument_list|(
operator|&
name|wol
argument_list|,
name|write_complete
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|junk
argument_list|)
condition|;
operator|++
name|i
control|)
name|junk
index|[
name|i
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|rbuf
operator|=
name|evbuffer_overlapped_new_
argument_list|(
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wbuf
operator|=
name|evbuffer_overlapped_new_
argument_list|(
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|evbuffer_enable_locking
argument_list|(
name|rbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_enable_locking
argument_list|(
name|wbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|port
operator|=
name|event_iocp_port_launch_
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_iocp_port_associate_
argument_list|(
name|port
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_iocp_port_associate_
argument_list|(
name|port
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
name|evbuffer_add
argument_list|(
name|wbuf
argument_list|,
name|junk
argument_list|,
sizeof|sizeof
argument_list|(
name|junk
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|rbuf
argument_list|,
name|junk
argument_list|,
sizeof|sizeof
argument_list|(
name|junk
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evbuffer_launch_read_
argument_list|(
name|rbuf
argument_list|,
literal|2048
argument_list|,
operator|&
name|rol
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|buf
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|junk
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|buf
operator|->
name|first
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
name|tt_int_op
argument_list|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_MEM_PINNED_ANY
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evbuffer_get_length
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evbuffer_launch_write_
argument_list|(
name|wbuf
argument_list|,
literal|512
argument_list|,
operator|&
name|wol
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|count_wait_for
argument_list|(
literal|2
argument_list|,
literal|2000
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|rbuf
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* FIXME Actually test some stuff here. */
name|tt_want
argument_list|(
operator|!
name|event_iocp_shutdown_
argument_list|(
name|port
argument_list|,
literal|2000
argument_list|)
argument_list|)
expr_stmt|;
name|end
label|:
name|count_free
argument_list|()
expr_stmt|;
name|evbuffer_free
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|got_readcb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|async_readcb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* Disabling read should cause the loop to quit */
name|bufferevent_disable
argument_list|(
name|bev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|got_readcb
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_iocp_bufferevent_async
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_iocp_port
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bea1
init|=
name|NULL
decl_stmt|,
modifier|*
name|bea2
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|event_base_start_iocp_
argument_list|(
name|data
operator|->
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|=
name|event_base_get_iocp_
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|bea1
operator|=
name|bufferevent_async_new_
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|BEV_OPT_DEFER_CALLBACKS
argument_list|)
expr_stmt|;
name|bea2
operator|=
name|bufferevent_async_new_
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|BEV_OPT_DEFER_CALLBACKS
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|bea1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|bea2
argument_list|)
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|bea2
argument_list|,
name|async_readcb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|bea1
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|bea2
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|bufferevent_write
argument_list|(
name|bea1
argument_list|,
literal|"Hello world"
argument_list|,
name|strlen
argument_list|(
literal|"Hello world"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|got_readcb
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|bufferevent_read
argument_list|(
name|bea2
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tt_str_op
argument_list|(
name|buf
argument_list|,
operator|==
argument_list|,
literal|"Hello world"
argument_list|)
expr_stmt|;
name|end
label|:
name|bufferevent_free
argument_list|(
name|bea1
argument_list|)
expr_stmt|;
name|bufferevent_free
argument_list|(
name|bea2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|testcase_t
name|iocp_testcases
index|[]
init|=
block|{
block|{
literal|"port"
block|,
name|test_iocp_port
block|,
name|TT_FORK
operator||
name|TT_NEED_THREADS
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"evbuffer"
block|,
name|test_iocp_evbuffer
block|,
name|TT_FORK
operator||
name|TT_NEED_SOCKETPAIR
operator||
name|TT_NEED_THREADS
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"bufferevent_async"
block|,
name|test_iocp_bufferevent_async
block|,
name|TT_FORK
operator||
name|TT_NEED_SOCKETPAIR
operator||
name|TT_NEED_THREADS
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
name|END_OF_TESTCASES
block|}
decl_stmt|;
end_decl_stmt

end_unit

