begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003-2007 Niels Provos<provos@citi.umich.edu>  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"../util-internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<ws2tcpip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_NETINET_IN6_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"event2/dns.h"
end_include

begin_include
include|#
directive|include
file|"event2/dns_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/dns_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event2/listener.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"regress.h"
end_include

begin_include
include|#
directive|include
file|"regress_testutils.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|dns_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dns_got_cancel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dns_err
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dns_gethostbyname_cb
parameter_list|(
name|int
name|result
parameter_list|,
name|char
name|type
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|ttl
parameter_list|,
name|void
modifier|*
name|addresses
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dns_ok
operator|=
name|dns_err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_ERR_TIMEOUT
condition|)
block|{
name|printf
argument_list|(
literal|"[Timed out] "
argument_list|)
expr_stmt|;
name|dns_err
operator|=
name|result
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|DNS_ERR_NONE
condition|)
block|{
name|printf
argument_list|(
literal|"[Error code %d] "
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|TT_BLATHER
argument_list|(
operator|(
literal|"type: %d, count: %d, ttl: %d: "
operator|,
name|type
operator|,
name|count
operator|,
name|ttl
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DNS_IPv6_AAAA
case|:
block|{
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_STRUCT_IN6_ADDR
argument_list|)
operator|&&
name|defined
argument_list|(
name|EVENT__HAVE_INET_NTOP
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6_ADDRSTRLEN
argument_list|)
name|struct
name|in6_addr
modifier|*
name|in6_addrs
init|=
name|addresses
decl_stmt|;
name|char
name|buf
index|[
name|INET6_ADDRSTRLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* a resolution that's not valid does not help */
if|if
condition|(
name|ttl
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|b
init|=
name|evutil_inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|in6_addrs
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
name|TT_BLATHER
argument_list|(
operator|(
literal|"%s "
operator|,
name|b
operator|)
argument_list|)
expr_stmt|;
else|else
name|TT_BLATHER
argument_list|(
operator|(
literal|"%s "
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
case|case
name|DNS_IPv4_A
case|:
block|{
name|struct
name|in_addr
modifier|*
name|in_addrs
init|=
name|addresses
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* a resolution that's not valid does not help */
if|if
condition|(
name|ttl
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|TT_BLATHER
argument_list|(
operator|(
literal|"%s "
operator|,
name|inet_ntoa
argument_list|(
name|in_addrs
index|[
name|i
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DNS_PTR
case|:
comment|/* may get at most one PTR */
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
goto|goto
name|out
goto|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"%s "
operator|,
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|addresses
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|out
goto|;
block|}
name|dns_ok
operator|=
name|type
expr_stmt|;
name|out
label|:
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|event_loopexit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|else
name|event_base_loopexit
argument_list|(
operator|(
expr|struct
name|event_base
operator|*
operator|)
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dns_gethostbyname
parameter_list|(
name|void
parameter_list|)
block|{
name|dns_ok
operator|=
literal|0
expr_stmt|;
name|evdns_resolve_ipv4
argument_list|(
literal|"www.monkey.org"
argument_list|,
literal|0
argument_list|,
name|dns_gethostbyname_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|tt_int_op
argument_list|(
name|dns_ok
argument_list|,
operator|==
argument_list|,
name|DNS_IPv4_A
argument_list|)
expr_stmt|;
name|test_ok
operator|=
name|dns_ok
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dns_gethostbyname6
parameter_list|(
name|void
parameter_list|)
block|{
name|dns_ok
operator|=
literal|0
expr_stmt|;
name|evdns_resolve_ipv6
argument_list|(
literal|"www.ietf.org"
argument_list|,
literal|0
argument_list|,
name|dns_gethostbyname_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dns_ok
operator|&&
name|dns_err
operator|==
name|DNS_ERR_TIMEOUT
condition|)
block|{
name|tt_skip
argument_list|()
expr_stmt|;
block|}
name|tt_int_op
argument_list|(
name|dns_ok
argument_list|,
operator|==
argument_list|,
name|DNS_IPv6_AAAA
argument_list|)
expr_stmt|;
name|test_ok
operator|=
literal|1
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dns_gethostbyaddr
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|in_addr
name|in
decl_stmt|;
name|in
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x7f000001ul
argument_list|)
expr_stmt|;
comment|/* 127.0.0.1 */
name|dns_ok
operator|=
literal|0
expr_stmt|;
name|evdns_resolve_reverse
argument_list|(
operator|&
name|in
argument_list|,
literal|0
argument_list|,
name|dns_gethostbyname_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|tt_int_op
argument_list|(
name|dns_ok
argument_list|,
operator|==
argument_list|,
name|DNS_PTR
argument_list|)
expr_stmt|;
name|test_ok
operator|=
name|dns_ok
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dns_resolve_reverse
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|in_addr
name|in
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|event_base_new
argument_list|()
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns
init|=
name|evdns_base_new
argument_list|(
name|base
argument_list|,
literal|1
comment|/* init name servers */
argument_list|)
decl_stmt|;
name|struct
name|evdns_request
modifier|*
name|req
init|=
name|NULL
decl_stmt|;
name|tt_assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|dns
argument_list|)
expr_stmt|;
name|in
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x7f000001ul
argument_list|)
expr_stmt|;
comment|/* 127.0.0.1 */
name|dns_ok
operator|=
literal|0
expr_stmt|;
name|req
operator|=
name|evdns_base_resolve_reverse
argument_list|(
name|dns
argument_list|,
operator|&
name|in
argument_list|,
literal|0
argument_list|,
name|dns_gethostbyname_cb
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|dns_ok
argument_list|,
operator|==
argument_list|,
name|DNS_PTR
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|dns
condition|)
name|evdns_base_free
argument_list|(
name|dns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|n_server_responses
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dns_server_request_cb
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
specifier|const
name|char
name|TEST_ARPA
index|[]
init|=
literal|"11.11.168.192.in-addr.arpa"
decl_stmt|;
specifier|const
name|char
name|TEST_IN6
index|[]
init|=
literal|"f.e.f.e."
literal|"0.0.0.0."
literal|"0.0.0.0."
literal|"1.1.1.1."
literal|"a.a.a.a."
literal|"0.0.0.0."
literal|"0.0.0.0."
literal|"0.f.f.f.ip6.arpa"
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|req
operator|->
name|nquestions
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|qtype
init|=
name|req
operator|->
name|questions
index|[
name|i
index|]
operator|->
name|type
decl_stmt|;
specifier|const
name|int
name|qclass
init|=
name|req
operator|->
name|questions
index|[
name|i
index|]
operator|->
name|dns_question_class
decl_stmt|;
specifier|const
name|char
modifier|*
name|qname
init|=
name|req
operator|->
name|questions
index|[
name|i
index|]
operator|->
name|name
decl_stmt|;
name|struct
name|in_addr
name|ans
decl_stmt|;
name|ans
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0xc0a80b0bUL
argument_list|)
expr_stmt|;
comment|/* 192.168.11.11 */
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_A
operator|&&
name|qclass
operator|==
name|EVDNS_CLASS_INET
operator|&&
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"zz.example.com"
argument_list|)
condition|)
block|{
name|r
operator|=
name|evdns_server_request_add_a_reply
argument_list|(
name|req
argument_list|,
name|qname
argument_list|,
literal|1
argument_list|,
operator|&
name|ans
operator|.
name|s_addr
argument_list|,
literal|12345
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|dns_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_AAAA
operator|&&
name|qclass
operator|==
name|EVDNS_CLASS_INET
operator|&&
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"zz.example.com"
argument_list|)
condition|)
block|{
name|char
name|addr6
index|[
literal|17
index|]
init|=
literal|"abcdefghijklmnop"
decl_stmt|;
name|r
operator|=
name|evdns_server_request_add_aaaa_reply
argument_list|(
name|req
argument_list|,
name|qname
argument_list|,
literal|1
argument_list|,
name|addr6
argument_list|,
literal|123
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|dns_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_PTR
operator|&&
name|qclass
operator|==
name|EVDNS_CLASS_INET
operator|&&
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
name|TEST_ARPA
argument_list|)
condition|)
block|{
name|r
operator|=
name|evdns_server_request_add_ptr_reply
argument_list|(
name|req
argument_list|,
name|NULL
argument_list|,
name|qname
argument_list|,
literal|"ZZ.EXAMPLE.COM"
argument_list|,
literal|54321
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|dns_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_PTR
operator|&&
name|qclass
operator|==
name|EVDNS_CLASS_INET
operator|&&
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
name|TEST_IN6
argument_list|)
condition|)
block|{
name|r
operator|=
name|evdns_server_request_add_ptr_reply
argument_list|(
name|req
argument_list|,
name|NULL
argument_list|,
name|qname
argument_list|,
literal|"ZZ-INET6.EXAMPLE.COM"
argument_list|,
literal|54322
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|dns_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_A
operator|&&
name|qclass
operator|==
name|EVDNS_CLASS_INET
operator|&&
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"drop.example.com"
argument_list|)
condition|)
block|{
if|if
condition|(
name|evdns_server_request_drop
argument_list|(
name|req
argument_list|)
operator|<
literal|0
condition|)
name|dns_ok
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unexpected question %d %d \"%s\" "
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|dns_ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|r
operator|=
name|evdns_server_request_respond
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Couldn't send reply. "
argument_list|)
expr_stmt|;
name|dns_ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dns_server_gethostbyname_cb
parameter_list|(
name|int
name|result
parameter_list|,
name|char
name|type
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|ttl
parameter_list|,
name|void
modifier|*
name|addresses
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_ERR_CANCEL
condition|)
block|{
if|if
condition|(
name|arg
operator|!=
operator|(
name|void
operator|*
operator|)
operator|(
name|char
operator|*
operator|)
literal|90909
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected cancelation"
argument_list|)
expr_stmt|;
name|dns_ok
operator|=
literal|0
expr_stmt|;
block|}
name|dns_got_cancel
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|DNS_ERR_NONE
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected result %d. "
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|dns_ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected answer count %d. "
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|dns_ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DNS_IPv4_A
case|:
block|{
name|struct
name|in_addr
modifier|*
name|in_addrs
init|=
name|addresses
decl_stmt|;
if|if
condition|(
name|in_addrs
index|[
literal|0
index|]
operator|.
name|s_addr
operator|!=
name|htonl
argument_list|(
literal|0xc0a80b0bUL
argument_list|)
operator|||
name|ttl
operator|!=
literal|12345
condition|)
block|{
name|printf
argument_list|(
literal|"Bad IPv4 response \"%s\" %d. "
argument_list|,
name|inet_ntoa
argument_list|(
name|in_addrs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|dns_ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
block|}
case|case
name|DNS_IPv6_AAAA
case|:
block|{
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_STRUCT_IN6_ADDR
argument_list|)
operator|&&
name|defined
argument_list|(
name|EVENT__HAVE_INET_NTOP
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6_ADDRSTRLEN
argument_list|)
name|struct
name|in6_addr
modifier|*
name|in6_addrs
init|=
name|addresses
decl_stmt|;
name|char
name|buf
index|[
name|INET6_ADDRSTRLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|in6_addrs
index|[
literal|0
index|]
operator|.
name|s6_addr
argument_list|,
literal|"abcdefghijklmnop"
argument_list|,
literal|16
argument_list|)
operator|||
name|ttl
operator|!=
literal|123
condition|)
block|{
specifier|const
name|char
modifier|*
name|b
init|=
name|evutil_inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|in6_addrs
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"Bad IPv6 response \"%s\" %d. "
argument_list|,
name|b
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|dns_ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
break|break;
block|}
case|case
name|DNS_PTR
case|:
block|{
name|char
modifier|*
modifier|*
name|addrs
init|=
name|addresses
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
operator|(
name|void
operator|*
operator|)
literal|6
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|addrs
index|[
literal|0
index|]
argument_list|,
literal|"ZZ.EXAMPLE.COM"
argument_list|)
operator|||
name|ttl
operator|!=
literal|54321
condition|)
block|{
name|printf
argument_list|(
literal|"Bad PTR response \"%s\" %d. "
argument_list|,
name|addrs
index|[
literal|0
index|]
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|dns_ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|addrs
index|[
literal|0
index|]
argument_list|,
literal|"ZZ-INET6.EXAMPLE.COM"
argument_list|)
operator|||
name|ttl
operator|!=
literal|54322
condition|)
block|{
name|printf
argument_list|(
literal|"Bad ipv6 PTR response \"%s\" %d. "
argument_list|,
name|addrs
index|[
literal|0
index|]
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|dns_ok
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"Bad response type %d. "
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dns_ok
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
operator|++
name|n_server_responses
operator|==
literal|3
condition|)
block|{
name|event_loopexit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dns_server
parameter_list|(
name|void
parameter_list|)
block|{
name|evutil_socket_t
name|sock
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sockaddr_in
name|my_addr
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|ev_socklen_t
name|slen
decl_stmt|;
name|struct
name|evdns_server_port
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|struct
name|in_addr
name|resolve_addr
decl_stmt|;
name|struct
name|in6_addr
name|resolve_addr6
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|struct
name|evdns_request
modifier|*
name|req
init|=
name|NULL
decl_stmt|;
name|dns_ok
operator|=
literal|1
expr_stmt|;
name|base
operator|=
name|evdns_base_new
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now configure a nameserver port. */
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|tt_abort_perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
block|}
name|evutil_make_socket_nonblocking
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|my_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|my_addr
argument_list|)
argument_list|)
expr_stmt|;
name|my_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|my_addr
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/* kernel picks */
name|my_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x7f000001UL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|my_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|my_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_abort_perror
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
block|}
name|slen
operator|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|slen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_abort_perror
argument_list|(
literal|"getsockname"
argument_list|)
expr_stmt|;
block|}
name|port
operator|=
name|evdns_add_server_port
argument_list|(
name|sock
argument_list|,
literal|0
argument_list|,
name|dns_server_request_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Add ourself as the only nameserver, and make sure we really are 	 * the only nameserver. */
name|evdns_base_nameserver_sockaddr_add
argument_list|(
name|base
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|slen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evdns_base_count_nameservers
argument_list|(
name|base
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Send some queries. */
name|evdns_base_resolve_ipv4
argument_list|(
name|base
argument_list|,
literal|"zz.example.com"
argument_list|,
name|DNS_QUERY_NO_SEARCH
argument_list|,
name|dns_server_gethostbyname_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv6
argument_list|(
name|base
argument_list|,
literal|"zz.example.com"
argument_list|,
name|DNS_QUERY_NO_SEARCH
argument_list|,
name|dns_server_gethostbyname_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|resolve_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0xc0a80b0bUL
argument_list|)
expr_stmt|;
comment|/* 192.168.11.11 */
name|evdns_base_resolve_reverse
argument_list|(
name|base
argument_list|,
operator|&
name|resolve_addr
argument_list|,
literal|0
argument_list|,
name|dns_server_gethostbyname_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|resolve_addr6
operator|.
name|s6_addr
argument_list|,
literal|"\xff\xf0\x00\x00\x00\x00\xaa\xaa"
literal|"\x11\x11\x00\x00\x00\x00\xef\xef"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|evdns_base_resolve_reverse_ipv6
argument_list|(
name|base
argument_list|,
operator|&
name|resolve_addr6
argument_list|,
literal|0
argument_list|,
name|dns_server_gethostbyname_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|6
argument_list|)
expr_stmt|;
name|req
operator|=
name|evdns_base_resolve_ipv4
argument_list|(
name|base
argument_list|,
literal|"drop.example.com"
argument_list|,
name|DNS_QUERY_NO_SEARCH
argument_list|,
name|dns_server_gethostbyname_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|char
operator|*
operator|)
literal|90909
argument_list|)
expr_stmt|;
name|evdns_cancel_request
argument_list|(
name|base
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|dns_got_cancel
argument_list|)
expr_stmt|;
name|test_ok
operator|=
name|dns_ok
expr_stmt|;
name|end
label|:
if|if
condition|(
name|port
condition|)
name|evdns_close_server_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|evdns_base_free
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|n_replies_left
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|event_base
modifier|*
name|exit_base
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|generic_dns_callback_result
block|{
name|int
name|result
decl_stmt|;
name|char
name|type
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|ttl
decl_stmt|;
name|size_t
name|addrs_len
decl_stmt|;
name|void
modifier|*
name|addrs
decl_stmt|;
name|char
name|addrs_buf
index|[
literal|256
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|generic_dns_callback
parameter_list|(
name|int
name|result
parameter_list|,
name|char
name|type
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|ttl
parameter_list|,
name|void
modifier|*
name|addresses
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|struct
name|generic_dns_callback_result
modifier|*
name|res
init|=
name|arg
decl_stmt|;
name|res
operator|->
name|result
operator|=
name|result
expr_stmt|;
name|res
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|res
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|res
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DNS_IPv4_A
condition|)
name|len
operator|=
name|count
operator|*
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|DNS_IPv6_AAAA
condition|)
name|len
operator|=
name|count
operator|*
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|DNS_PTR
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|addresses
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|res
operator|->
name|addrs_len
operator|=
name|len
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|addrs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|res
operator|->
name|addrs_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|256
condition|)
name|len
operator|=
literal|256
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|addrs_buf
argument_list|,
name|addresses
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|res
operator|->
name|addrs
operator|=
name|res
operator|->
name|addrs_buf
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|n_replies_left
operator|==
literal|0
condition|)
name|event_base_loopexit
argument_list|(
name|exit_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|regress_dns_server_table
name|search_table
index|[]
init|=
block|{
block|{
literal|"host.a.example.com"
block|,
literal|"err"
block|,
literal|"3"
block|,
literal|0
block|}
block|,
block|{
literal|"host.b.example.com"
block|,
literal|"err"
block|,
literal|"3"
block|,
literal|0
block|}
block|,
block|{
literal|"host.c.example.com"
block|,
literal|"A"
block|,
literal|"11.22.33.44"
block|,
literal|0
block|}
block|,
block|{
literal|"host2.a.example.com"
block|,
literal|"err"
block|,
literal|"3"
block|,
literal|0
block|}
block|,
block|{
literal|"host2.b.example.com"
block|,
literal|"A"
block|,
literal|"200.100.0.100"
block|,
literal|0
block|}
block|,
block|{
literal|"host2.c.example.com"
block|,
literal|"err"
block|,
literal|"3"
block|,
literal|0
block|}
block|,
block|{
literal|"hostn.a.example.com"
block|,
literal|"errsoa"
block|,
literal|"0"
block|,
literal|0
block|}
block|,
block|{
literal|"hostn.b.example.com"
block|,
literal|"errsoa"
block|,
literal|"3"
block|,
literal|0
block|}
block|,
block|{
literal|"hostn.c.example.com"
block|,
literal|"err"
block|,
literal|"0"
block|,
literal|0
block|}
block|,
block|{
literal|"host"
block|,
literal|"err"
block|,
literal|"3"
block|,
literal|0
block|}
block|,
block|{
literal|"host2"
block|,
literal|"err"
block|,
literal|"3"
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
literal|"err"
block|,
literal|"3"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dns_search_test
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns
init|=
name|NULL
decl_stmt|;
name|ev_uint16_t
name|portnum
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|generic_dns_callback_result
name|r
index|[
literal|8
index|]
decl_stmt|;
name|tt_assert
argument_list|(
name|regress_dnsserver
argument_list|(
name|base
argument_list|,
operator|&
name|portnum
argument_list|,
name|search_table
argument_list|)
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"127.0.0.1:%d"
argument_list|,
operator|(
name|int
operator|)
name|portnum
argument_list|)
expr_stmt|;
name|dns
operator|=
name|evdns_base_new
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_nameserver_ip_add
argument_list|(
name|dns
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_base_search_add
argument_list|(
name|dns
argument_list|,
literal|"a.example.com"
argument_list|)
expr_stmt|;
name|evdns_base_search_add
argument_list|(
name|dns
argument_list|,
literal|"b.example.com"
argument_list|)
expr_stmt|;
name|evdns_base_search_add
argument_list|(
name|dns
argument_list|,
literal|"c.example.com"
argument_list|)
expr_stmt|;
name|n_replies_left
operator|=
sizeof|sizeof
argument_list|(
name|r
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|r
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit_base
operator|=
name|base
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"host"
argument_list|,
literal|0
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"host2"
argument_list|,
literal|0
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"host"
argument_list|,
name|DNS_NO_SEARCH
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"host2"
argument_list|,
name|DNS_NO_SEARCH
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"host3"
argument_list|,
literal|0
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"hostn.a.example.com"
argument_list|,
name|DNS_NO_SEARCH
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"hostn.b.example.com"
argument_list|,
name|DNS_NO_SEARCH
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"hostn.c.example.com"
argument_list|,
name|DNS_NO_SEARCH
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|0
index|]
operator|.
name|type
argument_list|,
operator|==
argument_list|,
name|DNS_IPv4_A
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|0
index|]
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
operator|(
operator|(
name|ev_uint32_t
operator|*
operator|)
name|r
index|[
literal|0
index|]
operator|.
name|addrs
operator|)
index|[
literal|0
index|]
argument_list|,
operator|==
argument_list|,
name|htonl
argument_list|(
literal|0x0b16212c
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|1
index|]
operator|.
name|type
argument_list|,
operator|==
argument_list|,
name|DNS_IPv4_A
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|1
index|]
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
operator|(
operator|(
name|ev_uint32_t
operator|*
operator|)
name|r
index|[
literal|1
index|]
operator|.
name|addrs
operator|)
index|[
literal|0
index|]
argument_list|,
operator|==
argument_list|,
name|htonl
argument_list|(
literal|0xc8640064
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|2
index|]
operator|.
name|result
argument_list|,
operator|==
argument_list|,
name|DNS_ERR_NOTEXIST
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|3
index|]
operator|.
name|result
argument_list|,
operator|==
argument_list|,
name|DNS_ERR_NOTEXIST
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|4
index|]
operator|.
name|result
argument_list|,
operator|==
argument_list|,
name|DNS_ERR_NOTEXIST
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|5
index|]
operator|.
name|result
argument_list|,
operator|==
argument_list|,
name|DNS_ERR_NODATA
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|5
index|]
operator|.
name|ttl
argument_list|,
operator|==
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|6
index|]
operator|.
name|result
argument_list|,
operator|==
argument_list|,
name|DNS_ERR_NOTEXIST
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|6
index|]
operator|.
name|ttl
argument_list|,
operator|==
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|7
index|]
operator|.
name|result
argument_list|,
operator|==
argument_list|,
name|DNS_ERR_NODATA
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
literal|7
index|]
operator|.
name|ttl
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|dns
condition|)
name|evdns_base_free
argument_list|(
name|dns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regress_clean_dnsserver
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|request_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|evdns_request
modifier|*
name|current_req
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|search_cancel_server_cb
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|question
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|nquestions
operator|!=
literal|1
condition|)
name|TT_DIE
argument_list|(
operator|(
literal|"Only handling one question at a time; got %d"
operator|,
name|req
operator|->
name|nquestions
operator|)
argument_list|)
expr_stmt|;
name|question
operator|=
name|req
operator|->
name|questions
index|[
literal|0
index|]
operator|->
name|name
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"got question, %s"
operator|,
name|question
operator|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|request_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_server_request_respond
argument_list|(
name|req
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|request_count
condition|)
name|evdns_cancel_request
argument_list|(
name|NULL
argument_list|,
name|current_req
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dns_search_cancel_test
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns
init|=
name|NULL
decl_stmt|;
name|struct
name|evdns_server_port
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|ev_uint16_t
name|portnum
init|=
literal|0
decl_stmt|;
name|struct
name|generic_dns_callback_result
name|r1
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|port
operator|=
name|regress_get_dnsserver
argument_list|(
name|base
argument_list|,
operator|&
name|portnum
argument_list|,
name|NULL
argument_list|,
name|search_cancel_server_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"127.0.0.1:%d"
argument_list|,
operator|(
name|int
operator|)
name|portnum
argument_list|)
expr_stmt|;
name|dns
operator|=
name|evdns_base_new
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_nameserver_ip_add
argument_list|(
name|dns
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_base_search_add
argument_list|(
name|dns
argument_list|,
literal|"a.example.com"
argument_list|)
expr_stmt|;
name|evdns_base_search_add
argument_list|(
name|dns
argument_list|,
literal|"b.example.com"
argument_list|)
expr_stmt|;
name|evdns_base_search_add
argument_list|(
name|dns
argument_list|,
literal|"c.example.com"
argument_list|)
expr_stmt|;
name|evdns_base_search_add
argument_list|(
name|dns
argument_list|,
literal|"d.example.com"
argument_list|)
expr_stmt|;
name|exit_base
operator|=
name|base
expr_stmt|;
name|request_count
operator|=
literal|3
expr_stmt|;
name|n_replies_left
operator|=
literal|1
expr_stmt|;
name|current_req
operator|=
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"host"
argument_list|,
literal|0
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r1
operator|.
name|result
argument_list|,
operator|==
argument_list|,
name|DNS_ERR_CANCEL
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|port
condition|)
name|evdns_close_server_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns
condition|)
name|evdns_base_free
argument_list|(
name|dns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fail_server_cb
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|question
decl_stmt|;
name|int
modifier|*
name|count
init|=
name|data
decl_stmt|;
name|struct
name|in_addr
name|in
decl_stmt|;
comment|/* Drop the first N requests that we get. */
if|if
condition|(
operator|*
name|count
operator|>
literal|0
condition|)
block|{
operator|--
operator|*
name|count
expr_stmt|;
name|tt_want
argument_list|(
operator|!
name|evdns_server_request_drop
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|req
operator|->
name|nquestions
operator|!=
literal|1
condition|)
name|TT_DIE
argument_list|(
operator|(
literal|"Only handling one question at a time; got %d"
operator|,
name|req
operator|->
name|nquestions
operator|)
argument_list|)
expr_stmt|;
name|question
operator|=
name|req
operator|->
name|questions
index|[
literal|0
index|]
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|question
argument_list|,
literal|"google.com"
argument_list|)
condition|)
block|{
comment|/* Detect a probe, and get out of the loop. */
name|event_base_loopexit
argument_list|(
name|exit_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|tt_assert
argument_list|(
name|evutil_inet_pton
argument_list|(
name|AF_INET
argument_list|,
literal|"16.32.64.128"
argument_list|,
operator|&
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_server_request_add_a_reply
argument_list|(
name|req
argument_list|,
name|question
argument_list|,
literal|1
argument_list|,
operator|&
name|in
operator|.
name|s_addr
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
argument|! evdns_server_request_respond(req,
literal|0
argument|)
argument_list|)
return|return;
name|end
label|:
name|tt_want
argument_list|(
operator|!
name|evdns_server_request_drop
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dns_retry_test
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|evdns_server_port
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns
init|=
name|NULL
decl_stmt|;
name|int
name|drop_count
init|=
literal|2
decl_stmt|;
name|ev_uint16_t
name|portnum
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|generic_dns_callback_result
name|r1
decl_stmt|;
name|port
operator|=
name|regress_get_dnsserver
argument_list|(
name|base
argument_list|,
operator|&
name|portnum
argument_list|,
name|NULL
argument_list|,
name|fail_server_cb
argument_list|,
operator|&
name|drop_count
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"127.0.0.1:%d"
argument_list|,
operator|(
name|int
operator|)
name|portnum
argument_list|)
expr_stmt|;
name|dns
operator|=
name|evdns_base_new
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_nameserver_ip_add
argument_list|(
name|dns
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns
argument_list|,
literal|"timeout"
argument_list|,
literal|"0.2"
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns
argument_list|,
literal|"max-timeouts:"
argument_list|,
literal|"10"
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns
argument_list|,
literal|"initial-probe-timeout"
argument_list|,
literal|"0.1"
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"host.example.com"
argument_list|,
literal|0
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r1
argument_list|)
expr_stmt|;
name|n_replies_left
operator|=
literal|1
expr_stmt|;
name|exit_base
operator|=
name|base
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|drop_count
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r1
operator|.
name|type
argument_list|,
operator|==
argument_list|,
name|DNS_IPv4_A
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r1
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
operator|(
operator|(
name|ev_uint32_t
operator|*
operator|)
name|r1
operator|.
name|addrs
operator|)
index|[
literal|0
index|]
argument_list|,
operator|==
argument_list|,
name|htonl
argument_list|(
literal|0x10204080
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now try again, but this time have the server get treated as 	 * failed, so we can send it a test probe. */
name|drop_count
operator|=
literal|4
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns
argument_list|,
literal|"max-timeouts:"
argument_list|,
literal|"2"
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns
argument_list|,
literal|"attempts:"
argument_list|,
literal|"3"
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|r1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|r1
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"host.example.com"
argument_list|,
literal|0
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r1
argument_list|)
expr_stmt|;
name|n_replies_left
operator|=
literal|2
expr_stmt|;
comment|/* This will run until it answers the "google.com" probe request. */
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* We'll treat the server as failed here. */
name|tt_int_op
argument_list|(
name|r1
operator|.
name|result
argument_list|,
operator|==
argument_list|,
name|DNS_ERR_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* It should work this time. */
name|tt_int_op
argument_list|(
name|drop_count
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"host.example.com"
argument_list|,
literal|0
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r1
operator|.
name|result
argument_list|,
operator|==
argument_list|,
name|DNS_ERR_NONE
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r1
operator|.
name|type
argument_list|,
operator|==
argument_list|,
name|DNS_IPv4_A
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r1
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
operator|(
operator|(
name|ev_uint32_t
operator|*
operator|)
name|r1
operator|.
name|addrs
operator|)
index|[
literal|0
index|]
argument_list|,
operator|==
argument_list|,
name|htonl
argument_list|(
literal|0x10204080
argument_list|)
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|dns
condition|)
name|evdns_base_free
argument_list|(
name|dns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
name|evdns_close_server_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|regress_dns_server_table
name|internal_error_table
index|[]
init|=
block|{
comment|/* Error 4 (NOTIMPL) makes us reissue the request to another server 	   if we can.  	   XXXX we should reissue under a much wider set of circumstances! 	 */
block|{
literal|"foof.example.com"
block|,
literal|"err"
block|,
literal|"4"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|regress_dns_server_table
name|reissue_table
index|[]
init|=
block|{
block|{
literal|"foof.example.com"
block|,
literal|"A"
block|,
literal|"240.15.240.15"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dns_reissue_test
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|evdns_server_port
modifier|*
name|port1
init|=
name|NULL
decl_stmt|,
modifier|*
name|port2
init|=
name|NULL
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns
init|=
name|NULL
decl_stmt|;
name|struct
name|generic_dns_callback_result
name|r1
decl_stmt|;
name|ev_uint16_t
name|portnum1
init|=
literal|0
decl_stmt|,
name|portnum2
init|=
literal|0
decl_stmt|;
name|char
name|buf1
index|[
literal|64
index|]
decl_stmt|,
name|buf2
index|[
literal|64
index|]
decl_stmt|;
name|port1
operator|=
name|regress_get_dnsserver
argument_list|(
name|base
argument_list|,
operator|&
name|portnum1
argument_list|,
name|NULL
argument_list|,
name|regress_dns_server_cb
argument_list|,
name|internal_error_table
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|port1
argument_list|)
expr_stmt|;
name|port2
operator|=
name|regress_get_dnsserver
argument_list|(
name|base
argument_list|,
operator|&
name|portnum2
argument_list|,
name|NULL
argument_list|,
name|regress_dns_server_cb
argument_list|,
name|reissue_table
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|port2
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
literal|"127.0.0.1:%d"
argument_list|,
operator|(
name|int
operator|)
name|portnum1
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|,
literal|"127.0.0.1:%d"
argument_list|,
operator|(
name|int
operator|)
name|portnum2
argument_list|)
expr_stmt|;
name|dns
operator|=
name|evdns_base_new
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_nameserver_ip_add
argument_list|(
name|dns
argument_list|,
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns
argument_list|,
literal|"timeout:"
argument_list|,
literal|"0.3"
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns
argument_list|,
literal|"max-timeouts:"
argument_list|,
literal|"2"
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns
argument_list|,
literal|"attempts:"
argument_list|,
literal|"5"
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|r1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|r1
argument_list|)
argument_list|)
expr_stmt|;
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"foof.example.com"
argument_list|,
literal|0
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r1
argument_list|)
expr_stmt|;
comment|/* Add this after, so that we are sure to get a reissue. */
name|tt_assert
argument_list|(
operator|!
name|evdns_base_nameserver_ip_add
argument_list|(
name|dns
argument_list|,
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|n_replies_left
operator|=
literal|1
expr_stmt|;
name|exit_base
operator|=
name|base
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r1
operator|.
name|result
argument_list|,
operator|==
argument_list|,
name|DNS_ERR_NONE
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r1
operator|.
name|type
argument_list|,
operator|==
argument_list|,
name|DNS_IPv4_A
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r1
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
operator|(
operator|(
name|ev_uint32_t
operator|*
operator|)
name|r1
operator|.
name|addrs
operator|)
index|[
literal|0
index|]
argument_list|,
operator|==
argument_list|,
name|htonl
argument_list|(
literal|0xf00ff00f
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure we dropped at least once. */
name|tt_int_op
argument_list|(
name|internal_error_table
index|[
literal|0
index|]
operator|.
name|seen
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|dns
condition|)
name|evdns_base_free
argument_list|(
name|dns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|port1
condition|)
name|evdns_close_server_port
argument_list|(
name|port1
argument_list|)
expr_stmt|;
if|if
condition|(
name|port2
condition|)
name|evdns_close_server_port
argument_list|(
name|port2
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void dumb_bytes_fn(char *p, size_t n) { 	unsigned i;
comment|/* This gets us 6 bits of entropy per transaction ID, which means we 	 * will have probably have collisions and need to pick again. */
end_comment

begin_endif
unit|for (i=0;i<n;++i) 		p[i] = (char)(rand()& 7); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dns_inflight_test
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns
init|=
name|NULL
decl_stmt|;
name|ev_uint16_t
name|portnum
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|generic_dns_callback_result
name|r
index|[
literal|20
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tt_assert
argument_list|(
name|regress_dnsserver
argument_list|(
name|base
argument_list|,
operator|&
name|portnum
argument_list|,
name|reissue_table
argument_list|)
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"127.0.0.1:%d"
argument_list|,
operator|(
name|int
operator|)
name|portnum
argument_list|)
expr_stmt|;
name|dns
operator|=
name|evdns_base_new
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_nameserver_ip_add
argument_list|(
name|dns
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns
argument_list|,
literal|"max-inflight:"
argument_list|,
literal|"3"
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns
argument_list|,
literal|"randomize-case:"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
operator|++
name|i
control|)
name|evdns_base_resolve_ipv4
argument_list|(
name|dns
argument_list|,
literal|"foof.example.com"
argument_list|,
literal|0
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|r
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|n_replies_left
operator|=
literal|20
expr_stmt|;
name|exit_base
operator|=
name|base
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
operator|++
name|i
control|)
block|{
name|tt_int_op
argument_list|(
name|r
index|[
name|i
index|]
operator|.
name|type
argument_list|,
operator|==
argument_list|,
name|DNS_IPv4_A
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
index|[
name|i
index|]
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
operator|(
operator|(
name|ev_uint32_t
operator|*
operator|)
name|r
index|[
name|i
index|]
operator|.
name|addrs
operator|)
index|[
literal|0
index|]
argument_list|,
operator|==
argument_list|,
name|htonl
argument_list|(
literal|0xf00ff00f
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|dns
condition|)
name|evdns_base_free
argument_list|(
name|dns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regress_clean_dnsserver
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* === Test for bufferevent_socket_connect_hostname */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_connected_or_failed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_n_accepted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|event_base
modifier|*
name|be_connect_hostname_base
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implements a DNS server for the connect_hostname test and the  * getaddrinfo_async test */
end_comment

begin_function
specifier|static
name|void
name|be_getaddrinfo_server_cb
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|n_got_p
init|=
name|data
decl_stmt|;
name|int
name|added_any
init|=
literal|0
decl_stmt|;
operator|++
operator|*
name|n_got_p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|req
operator|->
name|nquestions
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|qtype
init|=
name|req
operator|->
name|questions
index|[
name|i
index|]
operator|->
name|type
decl_stmt|;
specifier|const
name|int
name|qclass
init|=
name|req
operator|->
name|questions
index|[
name|i
index|]
operator|->
name|dns_question_class
decl_stmt|;
specifier|const
name|char
modifier|*
name|qname
init|=
name|req
operator|->
name|questions
index|[
name|i
index|]
operator|->
name|name
decl_stmt|;
name|struct
name|in_addr
name|ans
decl_stmt|;
name|struct
name|in6_addr
name|ans6
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ans6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ans6
argument_list|)
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Got question about %s, type=%d"
operator|,
name|qname
operator|,
name|qtype
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_A
operator|&&
name|qclass
operator|==
name|EVDNS_CLASS_INET
operator|&&
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"nobodaddy.example.com"
argument_list|)
condition|)
block|{
name|ans
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x7f000001
argument_list|)
expr_stmt|;
name|evdns_server_request_add_a_reply
argument_list|(
name|req
argument_list|,
name|qname
argument_list|,
literal|1
argument_list|,
operator|&
name|ans
operator|.
name|s_addr
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|added_any
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"nosuchplace.example.com"
argument_list|)
condition|)
block|{
comment|/* ok, just say notfound. */
block|}
elseif|else
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"both.example.com"
argument_list|)
condition|)
block|{
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_A
condition|)
block|{
name|ans
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x50502020
argument_list|)
expr_stmt|;
name|evdns_server_request_add_a_reply
argument_list|(
name|req
argument_list|,
name|qname
argument_list|,
literal|1
argument_list|,
operator|&
name|ans
operator|.
name|s_addr
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|added_any
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_AAAA
condition|)
block|{
name|ans6
operator|.
name|s6_addr
index|[
literal|0
index|]
operator|=
literal|0x80
expr_stmt|;
name|ans6
operator|.
name|s6_addr
index|[
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
name|ans6
operator|.
name|s6_addr
index|[
literal|14
index|]
operator|=
literal|0xbb
expr_stmt|;
name|ans6
operator|.
name|s6_addr
index|[
literal|15
index|]
operator|=
literal|0xbb
expr_stmt|;
name|evdns_server_request_add_aaaa_reply
argument_list|(
name|req
argument_list|,
name|qname
argument_list|,
literal|1
argument_list|,
operator|&
name|ans6
operator|.
name|s6_addr
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|added_any
operator|=
literal|1
expr_stmt|;
block|}
name|evdns_server_request_add_cname_reply
argument_list|(
name|req
argument_list|,
name|qname
argument_list|,
literal|"both-canonical.example.com"
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"v4only.example.com"
argument_list|)
operator|||
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"v4assert.example.com"
argument_list|)
condition|)
block|{
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_A
condition|)
block|{
name|ans
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x12345678
argument_list|)
expr_stmt|;
name|evdns_server_request_add_a_reply
argument_list|(
name|req
argument_list|,
name|qname
argument_list|,
literal|1
argument_list|,
operator|&
name|ans
operator|.
name|s_addr
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|added_any
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"v4assert.example.com"
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Got an AAAA request for v4assert"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"v6only.example.com"
argument_list|)
operator|||
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"v6assert.example.com"
argument_list|)
condition|)
block|{
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_AAAA
condition|)
block|{
name|ans6
operator|.
name|s6_addr
index|[
literal|0
index|]
operator|=
literal|0x0b
expr_stmt|;
name|ans6
operator|.
name|s6_addr
index|[
literal|1
index|]
operator|=
literal|0x0b
expr_stmt|;
name|ans6
operator|.
name|s6_addr
index|[
literal|14
index|]
operator|=
literal|0xf0
expr_stmt|;
name|ans6
operator|.
name|s6_addr
index|[
literal|15
index|]
operator|=
literal|0x0d
expr_stmt|;
name|evdns_server_request_add_aaaa_reply
argument_list|(
name|req
argument_list|,
name|qname
argument_list|,
literal|1
argument_list|,
operator|&
name|ans6
operator|.
name|s6_addr
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|added_any
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"v6assert.example.com"
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Got a A request for v6assert"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"v6timeout.example.com"
argument_list|)
condition|)
block|{
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_A
condition|)
block|{
name|ans
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0xabcdef01
argument_list|)
expr_stmt|;
name|evdns_server_request_add_a_reply
argument_list|(
name|req
argument_list|,
name|qname
argument_list|,
literal|1
argument_list|,
operator|&
name|ans
operator|.
name|s_addr
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|added_any
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_AAAA
condition|)
block|{
comment|/* Let the v6 request time out.*/
name|evdns_server_request_drop
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"v4timeout.example.com"
argument_list|)
condition|)
block|{
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_AAAA
condition|)
block|{
name|ans6
operator|.
name|s6_addr
index|[
literal|0
index|]
operator|=
literal|0x0a
expr_stmt|;
name|ans6
operator|.
name|s6_addr
index|[
literal|1
index|]
operator|=
literal|0x0a
expr_stmt|;
name|ans6
operator|.
name|s6_addr
index|[
literal|14
index|]
operator|=
literal|0xff
expr_stmt|;
name|ans6
operator|.
name|s6_addr
index|[
literal|15
index|]
operator|=
literal|0x01
expr_stmt|;
name|evdns_server_request_add_aaaa_reply
argument_list|(
name|req
argument_list|,
name|qname
argument_list|,
literal|1
argument_list|,
operator|&
name|ans6
operator|.
name|s6_addr
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|added_any
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_A
condition|)
block|{
comment|/* Let the v4 request time out.*/
name|evdns_server_request_drop
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"v6timeout-nonexist.example.com"
argument_list|)
condition|)
block|{
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_A
condition|)
block|{
comment|/* Fall through, give an nexist. */
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|EVDNS_TYPE_AAAA
condition|)
block|{
comment|/* Let the v6 request time out.*/
name|evdns_server_request_drop
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|qname
argument_list|,
literal|"all-timeout.example.com"
argument_list|)
condition|)
block|{
comment|/* drop all requests */
name|evdns_server_request_drop
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|TT_GRIPE
argument_list|(
operator|(
literal|"Got weird request for %s"
operator|,
name|qname
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|added_any
condition|)
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"answering"
operator|)
argument_list|)
expr_stmt|;
name|evdns_server_request_respond
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"saying nexist."
operator|)
argument_list|)
expr_stmt|;
name|evdns_server_request_respond
argument_list|(
name|req
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implements a listener for connect_hostname test. */
end_comment

begin_function
specifier|static
name|void
name|nil_accept_cb
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|l
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|s
parameter_list|,
name|int
name|socklen
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|arg
decl_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
operator|++
name|total_n_accepted
expr_stmt|;
comment|/* don't do anything with the socket; let it close when we exit() */
if|if
condition|(
name|total_n_accepted
operator|>=
literal|3
operator|&&
name|total_connected_or_failed
operator|>=
literal|5
condition|)
name|event_base_loopexit
argument_list|(
name|be_connect_hostname_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|be_conn_hostname_result
block|{
name|int
name|dnserr
decl_stmt|;
name|int
name|what
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bufferevent event callback for the connect_hostname test: remembers what  * event we got. */
end_comment

begin_function
specifier|static
name|void
name|be_connect_hostname_event_cb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|be_conn_hostname_result
modifier|*
name|got
init|=
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
name|got
operator|->
name|what
condition|)
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"Got a bufferevent event %d"
operator|,
name|what
operator|)
argument_list|)
expr_stmt|;
name|got
operator|->
name|what
operator|=
name|what
expr_stmt|;
if|if
condition|(
operator|(
name|what
operator|&
name|BEV_EVENT_CONNECTED
operator|)
operator|||
operator|(
name|what
operator|&
name|BEV_EVENT_ERROR
operator|)
condition|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|bufferevent_socket_get_dns_error
argument_list|(
name|bev
argument_list|)
operator|)
condition|)
block|{
name|got
operator|->
name|dnserr
operator|=
name|r
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"DNS error %d: %s"
operator|,
name|r
operator|,
name|evutil_gai_strerror
argument_list|(
name|r
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|total_connected_or_failed
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Got %d connections or errors."
operator|,
name|total_connected_or_failed
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_n_accepted
operator|>=
literal|3
operator|&&
name|total_connected_or_failed
operator|>=
literal|5
condition|)
name|event_base_loopexit
argument_list|(
name|be_connect_hostname_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Two events on one bufferevent. %d,%d"
operator|,
name|got
operator|->
name|what
operator|,
operator|(
name|int
operator|)
name|what
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_bufferevent_connect_hostname
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|evconnlistener
modifier|*
name|listener
init|=
name|NULL
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|be1
init|=
name|NULL
decl_stmt|,
modifier|*
name|be2
init|=
name|NULL
decl_stmt|,
modifier|*
name|be3
init|=
name|NULL
decl_stmt|,
modifier|*
name|be4
init|=
name|NULL
decl_stmt|,
modifier|*
name|be5
init|=
name|NULL
decl_stmt|;
name|struct
name|be_conn_hostname_result
name|be1_outcome
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|be2_outcome
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|be3_outcome
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|be4_outcome
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|be5_outcome
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|expect_err5
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns
init|=
name|NULL
decl_stmt|;
name|struct
name|evdns_server_port
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|listener_port
init|=
operator|-
literal|1
decl_stmt|;
name|ev_uint16_t
name|dns_port
init|=
literal|0
decl_stmt|;
name|int
name|n_accept
init|=
literal|0
decl_stmt|,
name|n_dns
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|be_connect_hostname_base
operator|=
name|data
operator|->
name|base
expr_stmt|;
comment|/* Bind an address and figure out what port it's on. */
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x7f000001
argument_list|)
expr_stmt|;
comment|/* 127.0.0.1 */
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
name|listener
operator|=
name|evconnlistener_new_bind
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|nil_accept_cb
argument_list|,
operator|&
name|n_accept
argument_list|,
name|LEV_OPT_REUSEABLE
operator||
name|LEV_OPT_CLOSE_ON_EXEC
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|listener_port
operator|=
name|regress_get_socket_port
argument_list|(
name|evconnlistener_get_fd
argument_list|(
name|listener
argument_list|)
argument_list|)
expr_stmt|;
name|port
operator|=
name|regress_get_dnsserver
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|&
name|dns_port
argument_list|,
name|NULL
argument_list|,
name|be_getaddrinfo_server_cb
argument_list|,
operator|&
name|n_dns
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|dns_port
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start an evdns_base that uses the server as its resolver. */
name|dns
operator|=
name|evdns_base_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"127.0.0.1:%d"
argument_list|,
operator|(
name|int
operator|)
name|dns_port
argument_list|)
expr_stmt|;
name|evdns_base_nameserver_ip_add
argument_list|(
name|dns
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Now, finally, at long last, launch the bufferevents.	 One should do 	 * a failing lookup IP, one should do a successful lookup by IP, 	 * and one should do a successful lookup by hostname. */
name|be1
operator|=
name|bufferevent_socket_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
argument_list|)
expr_stmt|;
name|be2
operator|=
name|bufferevent_socket_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
argument_list|)
expr_stmt|;
name|be3
operator|=
name|bufferevent_socket_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
argument_list|)
expr_stmt|;
name|be4
operator|=
name|bufferevent_socket_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
argument_list|)
expr_stmt|;
name|be5
operator|=
name|bufferevent_socket_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
argument_list|)
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|be1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|be_connect_hostname_event_cb
argument_list|,
operator|&
name|be1_outcome
argument_list|)
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|be2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|be_connect_hostname_event_cb
argument_list|,
operator|&
name|be2_outcome
argument_list|)
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|be3
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|be_connect_hostname_event_cb
argument_list|,
operator|&
name|be3_outcome
argument_list|)
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|be4
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|be_connect_hostname_event_cb
argument_list|,
operator|&
name|be4_outcome
argument_list|)
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|be5
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|be_connect_hostname_event_cb
argument_list|,
operator|&
name|be5_outcome
argument_list|)
expr_stmt|;
comment|/* Launch an async resolve that will fail. */
name|tt_assert
argument_list|(
operator|!
name|bufferevent_socket_connect_hostname
argument_list|(
name|be1
argument_list|,
name|dns
argument_list|,
name|AF_INET
argument_list|,
literal|"nosuchplace.example.com"
argument_list|,
name|listener_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Connect to the IP without resolving. */
name|tt_assert
argument_list|(
operator|!
name|bufferevent_socket_connect_hostname
argument_list|(
name|be2
argument_list|,
name|dns
argument_list|,
name|AF_INET
argument_list|,
literal|"127.0.0.1"
argument_list|,
name|listener_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Launch an async resolve that will succeed. */
name|tt_assert
argument_list|(
operator|!
name|bufferevent_socket_connect_hostname
argument_list|(
name|be3
argument_list|,
name|dns
argument_list|,
name|AF_INET
argument_list|,
literal|"nobodaddy.example.com"
argument_list|,
name|listener_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the blocking resolver.  This one will fail if your resolver 	 * can't resolve localhost to 127.0.0.1 */
name|tt_assert
argument_list|(
operator|!
name|bufferevent_socket_connect_hostname
argument_list|(
name|be4
argument_list|,
name|NULL
argument_list|,
name|AF_INET
argument_list|,
literal|"localhost"
argument_list|,
name|listener_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the blocking resolver with a nonexistent hostname. */
name|tt_assert
argument_list|(
operator|!
name|bufferevent_socket_connect_hostname
argument_list|(
name|be5
argument_list|,
name|NULL
argument_list|,
name|AF_INET
argument_list|,
literal|"nonesuch.nowhere.example.com"
argument_list|,
literal|80
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* The blocking resolver will use the system nameserver, which 		 * might tell us anything.  (Yes, some twits even pretend that 		 * example.com is real.) Let's see what answer to expect. */
name|struct
name|evutil_addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|expect_err5
operator|=
name|evutil_getaddrinfo
argument_list|(
literal|"nonesuch.nowhere.example.com"
argument_list|,
literal|"80"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
block|}
name|event_base_dispatch
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|be1_outcome
operator|.
name|what
argument_list|,
operator|==
argument_list|,
name|BEV_EVENT_ERROR
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|be1_outcome
operator|.
name|dnserr
argument_list|,
operator|==
argument_list|,
name|EVUTIL_EAI_NONAME
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|be2_outcome
operator|.
name|what
argument_list|,
operator|==
argument_list|,
name|BEV_EVENT_CONNECTED
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|be2_outcome
operator|.
name|dnserr
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|be3_outcome
operator|.
name|what
argument_list|,
operator|==
argument_list|,
name|BEV_EVENT_CONNECTED
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|be3_outcome
operator|.
name|dnserr
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|be4_outcome
operator|.
name|what
argument_list|,
operator|==
argument_list|,
name|BEV_EVENT_CONNECTED
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|be4_outcome
operator|.
name|dnserr
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expect_err5
condition|)
block|{
name|tt_int_op
argument_list|(
name|be5_outcome
operator|.
name|what
argument_list|,
operator|==
argument_list|,
name|BEV_EVENT_ERROR
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|be5_outcome
operator|.
name|dnserr
argument_list|,
operator|==
argument_list|,
name|expect_err5
argument_list|)
expr_stmt|;
block|}
name|tt_int_op
argument_list|(
name|n_accept
argument_list|,
operator|==
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n_dns
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|listener
condition|)
name|evconnlistener_free
argument_list|(
name|listener
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
name|evdns_close_server_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns
condition|)
name|evdns_base_free
argument_list|(
name|dns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|be1
condition|)
name|bufferevent_free
argument_list|(
name|be1
argument_list|)
expr_stmt|;
if|if
condition|(
name|be2
condition|)
name|bufferevent_free
argument_list|(
name|be2
argument_list|)
expr_stmt|;
if|if
condition|(
name|be3
condition|)
name|bufferevent_free
argument_list|(
name|be3
argument_list|)
expr_stmt|;
if|if
condition|(
name|be4
condition|)
name|bufferevent_free
argument_list|(
name|be4
argument_list|)
expr_stmt|;
if|if
condition|(
name|be5
condition|)
name|bufferevent_free
argument_list|(
name|be5
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|gai_outcome
block|{
name|int
name|err
decl_stmt|;
name|struct
name|evutil_addrinfo
modifier|*
name|ai
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|n_gai_results_pending
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|event_base
modifier|*
name|exit_base_on_no_pending_results
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gai_cb
parameter_list|(
name|int
name|err
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
name|res
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|gai_outcome
modifier|*
name|go
init|=
name|ptr
decl_stmt|;
name|go
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|go
operator|->
name|ai
operator|=
name|res
expr_stmt|;
if|if
condition|(
operator|--
name|n_gai_results_pending
operator|<=
literal|0
operator|&&
name|exit_base_on_no_pending_results
condition|)
name|event_base_loopexit
argument_list|(
name|exit_base_on_no_pending_results
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_gai_results_pending
operator|<
literal|900
condition|)
name|TT_BLATHER
argument_list|(
operator|(
literal|"Got an answer; expecting %d more."
operator|,
name|n_gai_results_pending
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cancel_gai_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|r
init|=
name|ptr
decl_stmt|;
name|evdns_getaddrinfo_cancel
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_getaddrinfo_async
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|evutil_addrinfo
name|hints
decl_stmt|,
modifier|*
name|a
decl_stmt|;
name|struct
name|gai_outcome
name|local_outcome
decl_stmt|;
name|struct
name|gai_outcome
name|a_out
index|[
literal|12
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|r
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|evdns_server_port
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|ev_uint16_t
name|dns_port
init|=
literal|0
decl_stmt|;
name|int
name|n_dns_questions
init|=
literal|0
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns_base
decl_stmt|;
name|memset
argument_list|(
name|a_out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|a_out
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|local_outcome
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_outcome
argument_list|)
argument_list|)
expr_stmt|;
name|dns_base
operator|=
name|evdns_base_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|dns_base
argument_list|)
expr_stmt|;
comment|/* for localhost */
name|evdns_base_load_hosts
argument_list|(
name|dns_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns_base
argument_list|,
literal|"timeout"
argument_list|,
literal|"0.3"
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_set_option
argument_list|(
name|dns_base
argument_list|,
literal|"getaddrinfo-allow-skew"
argument_list|,
literal|"0.2"
argument_list|)
argument_list|)
expr_stmt|;
name|n_gai_results_pending
operator|=
literal|10000
expr_stmt|;
comment|/* don't think about exiting yet. */
comment|/* 1. Try some cases that will never hit the asynchronous resolver. */
comment|/* 1a. Simple case with a symbolic service name */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|memset
argument_list|(
operator|&
name|local_outcome
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_outcome
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"1.2.3.4"
argument_list|,
literal|"http"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|local_outcome
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_outcome
operator|.
name|err
condition|)
block|{
name|tt_ptr_op
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
literal|"1.2.3.4:80"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
name|local_outcome
operator|.
name|ai
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"Apparently we have no getservbyname."
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 1b. EVUTIL_AI_NUMERICHOST is set */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|EVUTIL_AI_NUMERICHOST
expr_stmt|;
name|memset
argument_list|(
operator|&
name|local_outcome
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_outcome
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"www.google.com"
argument_list|,
literal|"80"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|local_outcome
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|local_outcome
operator|.
name|err
argument_list|,
operator|==
argument_list|,
name|EVUTIL_EAI_NONAME
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 1c. We give a numeric address (ipv6) */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|local_outcome
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_outcome
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"f::f"
argument_list|,
literal|"8008"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|local_outcome
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|r
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|local_outcome
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|local_outcome
operator|.
name|ai
operator|->
name|ai_next
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
literal|"[f::f]:8008"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
name|local_outcome
operator|.
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* 1d. We give a numeric address (ipv4) */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|local_outcome
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_outcome
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"5.6.7.8"
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|local_outcome
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|r
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|local_outcome
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
name|a
operator|=
name|ai_find_by_protocol
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"5.6.7.8"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|a
operator|=
name|ai_find_by_protocol
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"5.6.7.8"
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
name|local_outcome
operator|.
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* 1e. nodename is NULL (bind) */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|local_outcome
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_outcome
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|EVUTIL_AI_PASSIVE
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
name|NULL
argument_list|,
literal|"9090"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|local_outcome
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|r
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|local_outcome
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
comment|/* we should get a v4 address of 0.0.0.0... */
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
name|PF_INET
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"0.0.0.0:9090"
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
comment|/* ... and a v6 address of ::0 */
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
name|PF_INET6
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"[::]:9090"
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
name|local_outcome
operator|.
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* 1f. nodename is NULL (connect) */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|local_outcome
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_outcome
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
name|NULL
argument_list|,
literal|"2"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|local_outcome
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|r
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|local_outcome
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
comment|/* we should get a v4 address of 127.0.0.1 .... */
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
name|PF_INET
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"127.0.0.1:2"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
comment|/* ... and a v6 address of ::1 */
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
name|PF_INET6
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"[::1]:2"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
name|local_outcome
operator|.
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* 1g. We find localhost immediately. (pf_unspec) */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|local_outcome
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_outcome
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"LOCALHOST"
argument_list|,
literal|"80"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|local_outcome
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|r
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|local_outcome
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
comment|/* we should get a v4 address of 127.0.0.1 .... */
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
name|PF_INET
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"127.0.0.1:80"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
comment|/* ... and a v6 address of ::1 */
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|,
name|PF_INET6
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"[::1]:80"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
name|local_outcome
operator|.
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* 1g. We find localhost immediately. (pf_inet6) */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|local_outcome
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_outcome
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"LOCALHOST"
argument_list|,
literal|"9999"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|local_outcome
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|r
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|local_outcome
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
name|a
operator|=
name|local_outcome
operator|.
name|ai
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"[::1]:9999"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|a
operator|->
name|ai_next
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
name|local_outcome
operator|.
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* 2. Okay, now we can actually test the asynchronous resolver. */
comment|/* Start a dummy local dns server... */
name|port
operator|=
name|regress_get_dnsserver
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|&
name|dns_port
argument_list|,
name|NULL
argument_list|,
name|be_getaddrinfo_server_cb
argument_list|,
operator|&
name|n_dns_questions
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|dns_port
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... and tell the evdns_base about it. */
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"127.0.0.1:%d"
argument_list|,
name|dns_port
argument_list|)
expr_stmt|;
name|evdns_base_nameserver_ip_add
argument_list|(
name|dns_base
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|EVUTIL_AI_CANONNAME
expr_stmt|;
comment|/* 0: Request for both.example.com should return both addresses. */
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"both.example.com"
argument_list|,
literal|"8000"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 1: Request for v4only.example.com should return one address. */
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"v4only.example.com"
argument_list|,
literal|"8001"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 2: Request for v6only.example.com should return one address. */
name|hints
operator|.
name|ai_flags
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"v6only.example.com"
argument_list|,
literal|"8002"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 3: PF_INET request for v4assert.example.com should not generate a 	 * v6 request.	The server will fail the test if it does. */
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"v4assert.example.com"
argument_list|,
literal|"8003"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 4: PF_INET6 request for v6assert.example.com should not generate a 	 * v4 request.	The server will fail the test if it does. */
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"v6assert.example.com"
argument_list|,
literal|"8004"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 5: PF_INET request for nosuchplace.example.com should give NEXIST. */
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"nosuchplace.example.com"
argument_list|,
literal|"8005"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 6: PF_UNSPEC request for nosuchplace.example.com should give NEXIST. 	 */
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"nosuchplace.example.com"
argument_list|,
literal|"8006"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 7: PF_UNSPEC request for v6timeout.example.com should give an ipv4 	 * address only. */
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"v6timeout.example.com"
argument_list|,
literal|"8007"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 8: PF_UNSPEC request for v6timeout-nonexist.example.com should give 	 * a NEXIST */
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"v6timeout-nonexist.example.com"
argument_list|,
literal|"8008"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 9: AI_ADDRCONFIG should at least not crash.	Can't test it more 	 * without knowing what kind of internet we have. */
name|hints
operator|.
name|ai_flags
operator||=
name|EVUTIL_AI_ADDRCONFIG
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"both.example.com"
argument_list|,
literal|"8009"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 10: PF_UNSPEC for v4timeout.example.com should give an ipv6 address 	 * only. */
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"v4timeout.example.com"
argument_list|,
literal|"8010"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* 11: timeout.example.com: cancel it after 100 msec. */
name|r
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"all-timeout.example.com"
argument_list|,
literal|"8011"
argument_list|,
operator|&
name|hints
argument_list|,
name|gai_cb
argument_list|,
operator|&
name|a_out
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|100
operator|*
literal|1000
expr_stmt|;
comment|/* 100 msec */
name|event_base_once
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|cancel_gai_cb
argument_list|,
name|r
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
comment|/* XXXXX There are more tests we could do, including:  	   - A test to elicit NODATA.  	 */
name|n_gai_results_pending
operator|=
literal|12
expr_stmt|;
name|exit_base_on_no_pending_results
operator|=
name|data
operator|->
name|base
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
comment|/* 0: both.example.com */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|0
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|0
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|0
index|]
operator|.
name|ai
operator|->
name|ai_next
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|a_out
index|[
literal|0
index|]
operator|.
name|ai
operator|->
name|ai_next
operator|->
name|ai_next
argument_list|)
expr_stmt|;
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|a_out
index|[
literal|0
index|]
operator|.
name|ai
argument_list|,
name|PF_INET
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"80.80.32.32:8000"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|a_out
index|[
literal|0
index|]
operator|.
name|ai
argument_list|,
name|PF_INET6
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"[80ff::bbbb]:8000"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|0
index|]
operator|.
name|ai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|a_out
index|[
literal|0
index|]
operator|.
name|ai
operator|->
name|ai_canonname
argument_list|,
operator|==
argument_list|,
literal|"both-canonical.example.com"
argument_list|)
expr_stmt|;
comment|/* 1: v4only.example.com */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|1
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|1
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|a_out
index|[
literal|1
index|]
operator|.
name|ai
operator|->
name|ai_next
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a_out
index|[
literal|1
index|]
operator|.
name|ai
argument_list|,
literal|"18.52.86.120:8001"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|1
index|]
operator|.
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 2: v6only.example.com */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|2
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|2
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|a_out
index|[
literal|2
index|]
operator|.
name|ai
operator|->
name|ai_next
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a_out
index|[
literal|2
index|]
operator|.
name|ai
argument_list|,
literal|"[b0b::f00d]:8002"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
comment|/* 3: v4assert.example.com */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|3
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|3
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|a_out
index|[
literal|3
index|]
operator|.
name|ai
operator|->
name|ai_next
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a_out
index|[
literal|3
index|]
operator|.
name|ai
argument_list|,
literal|"18.52.86.120:8003"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
comment|/* 4: v6assert.example.com */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|4
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|4
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|a_out
index|[
literal|4
index|]
operator|.
name|ai
operator|->
name|ai_next
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a_out
index|[
literal|4
index|]
operator|.
name|ai
argument_list|,
literal|"[b0b::f00d]:8004"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
comment|/* 5: nosuchplace.example.com (inet) */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|5
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
name|EVUTIL_EAI_NONAME
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|a_out
index|[
literal|5
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
comment|/* 6: nosuchplace.example.com (unspec) */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|6
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
name|EVUTIL_EAI_NONAME
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|a_out
index|[
literal|6
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
comment|/* 7: v6timeout.example.com */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|7
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|7
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|a_out
index|[
literal|7
index|]
operator|.
name|ai
operator|->
name|ai_next
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a_out
index|[
literal|7
index|]
operator|.
name|ai
argument_list|,
literal|"171.205.239.1:8007"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
comment|/* 8: v6timeout-nonexist.example.com */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|8
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
name|EVUTIL_EAI_NONAME
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|a_out
index|[
literal|8
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
comment|/* 9: both (ADDRCONFIG) */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|9
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|9
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|a_out
index|[
literal|9
index|]
operator|.
name|ai
argument_list|,
name|PF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
condition|)
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"80.80.32.32:8009"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
else|else
name|tt_assert
argument_list|(
name|ai_find_by_family
argument_list|(
name|a_out
index|[
literal|9
index|]
operator|.
name|ai
argument_list|,
name|PF_INET6
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|a_out
index|[
literal|9
index|]
operator|.
name|ai
argument_list|,
name|PF_INET6
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
condition|)
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"[80ff::bbbb]:8009"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
else|else
name|tt_assert
argument_list|(
name|ai_find_by_family
argument_list|(
name|a_out
index|[
literal|9
index|]
operator|.
name|ai
argument_list|,
name|PF_INET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 10: v4timeout.example.com */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|10
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|10
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|a_out
index|[
literal|10
index|]
operator|.
name|ai
operator|->
name|ai_next
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a_out
index|[
literal|10
index|]
operator|.
name|ai
argument_list|,
literal|"[a0a::ff01]:8010"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
comment|/* 11: cancelled request. */
name|tt_int_op
argument_list|(
name|a_out
index|[
literal|11
index|]
operator|.
name|err
argument_list|,
operator|==
argument_list|,
name|EVUTIL_EAI_CANCEL
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a_out
index|[
literal|11
index|]
operator|.
name|ai
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|local_outcome
operator|.
name|ai
condition|)
name|evutil_freeaddrinfo
argument_list|(
name|local_outcome
operator|.
name|ai
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|a_out
index|[
name|i
index|]
operator|.
name|ai
condition|)
name|evutil_freeaddrinfo
argument_list|(
name|a_out
index|[
name|i
index|]
operator|.
name|ai
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
condition|)
name|evdns_close_server_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_base
condition|)
name|evdns_base_free
argument_list|(
name|dns_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|gaic_request_status
block|{
name|int
name|magic
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns_base
decl_stmt|;
name|struct
name|evdns_getaddrinfo_request
modifier|*
name|request
decl_stmt|;
name|struct
name|event
name|cancel_event
decl_stmt|;
name|int
name|canceled
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|GAIC_MAGIC
value|0x1234abcd
end_define

begin_decl_stmt
specifier|static
name|int
name|pending
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gaic_cancel_request_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|gaic_request_status
modifier|*
name|status
init|=
name|arg
decl_stmt|;
name|tt_assert
argument_list|(
name|status
operator|->
name|magic
operator|==
name|GAIC_MAGIC
argument_list|)
expr_stmt|;
name|status
operator|->
name|canceled
operator|=
literal|1
expr_stmt|;
name|evdns_getaddrinfo_cancel
argument_list|(
name|status
operator|->
name|request
argument_list|)
expr_stmt|;
return|return;
name|end
label|:
name|event_base_loopexit
argument_list|(
name|status
operator|->
name|base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gaic_server_cb
parameter_list|(
name|struct
name|evdns_server_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ev_uint32_t
name|answer
init|=
literal|0x7f000001
decl_stmt|;
name|tt_assert
argument_list|(
name|req
operator|->
name|nquestions
argument_list|)
expr_stmt|;
name|evdns_server_request_add_a_reply
argument_list|(
name|req
argument_list|,
name|req
operator|->
name|questions
index|[
literal|0
index|]
operator|->
name|name
argument_list|,
literal|1
argument_list|,
operator|&
name|answer
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|evdns_server_request_respond
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
name|end
label|:
name|evdns_server_request_respond
argument_list|(
name|req
argument_list|,
name|DNS_ERR_REFUSED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gaic_getaddrinfo_cb
parameter_list|(
name|int
name|result
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
name|res
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|gaic_request_status
modifier|*
name|status
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|status
operator|->
name|base
decl_stmt|;
name|tt_assert
argument_list|(
name|status
operator|->
name|magic
operator|==
name|GAIC_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|EVUTIL_EAI_CANCEL
condition|)
block|{
name|tt_assert
argument_list|(
name|status
operator|->
name|canceled
argument_list|)
expr_stmt|;
block|}
name|event_del
argument_list|(
operator|&
name|status
operator|->
name|cancel_event
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|status
argument_list|,
literal|0xf0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
operator|--
name|pending
operator|<=
literal|0
condition|)
name|event_base_loopexit
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gaic_launch
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|evdns_base
modifier|*
name|dns_base
parameter_list|)
block|{
name|struct
name|gaic_request_status
modifier|*
name|status
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|tv
init|=
block|{
literal|0
block|,
literal|10000
block|}
decl_stmt|;
name|status
operator|->
name|magic
operator|=
name|GAIC_MAGIC
expr_stmt|;
name|status
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|status
operator|->
name|dns_base
operator|=
name|dns_base
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|status
operator|->
name|cancel_event
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|gaic_cancel_request_cb
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|->
name|request
operator|=
name|evdns_getaddrinfo
argument_list|(
name|dns_base
argument_list|,
literal|"foobar.bazquux.example.com"
argument_list|,
literal|"80"
argument_list|,
name|NULL
argument_list|,
name|gaic_getaddrinfo_cb
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|status
operator|->
name|cancel_event
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
operator|++
name|pending
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED
end_ifdef

begin_comment
comment|/* FIXME: We should move this to regress_main.c if anything else needs it.*/
end_comment

begin_comment
comment|/* Trivial replacements for malloc/free/realloc to check for memory leaks.  * Not threadsafe. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocated_chunks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|cnt_malloc
parameter_list|(
name|size_t
name|sz
parameter_list|)
block|{
name|allocated_chunks
operator|+=
literal|1
expr_stmt|;
return|return
name|malloc
argument_list|(
name|sz
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|cnt_realloc
parameter_list|(
name|void
modifier|*
name|old
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
if|if
condition|(
operator|!
name|old
condition|)
name|allocated_chunks
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|sz
condition|)
name|allocated_chunks
operator|-=
literal|1
expr_stmt|;
return|return
name|realloc
argument_list|(
name|old
argument_list|,
name|sz
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cnt_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|allocated_chunks
operator|-=
literal|1
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|testleak_env_t
block|{
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns_base
decl_stmt|;
name|struct
name|evdns_request
modifier|*
name|req
decl_stmt|;
name|struct
name|generic_dns_callback_result
name|r
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
modifier|*
name|testleak_setup
parameter_list|(
specifier|const
name|struct
name|testcase_t
modifier|*
name|testcase
parameter_list|)
block|{
name|struct
name|testleak_env_t
modifier|*
name|env
decl_stmt|;
name|allocated_chunks
operator|=
literal|0
expr_stmt|;
name|event_set_mem_functions
argument_list|(
name|cnt_malloc
argument_list|,
name|cnt_realloc
argument_list|,
name|cnt_free
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|libevent_tests_running_in_debug_mode
condition|)
name|event_enable_debug_mode
argument_list|()
expr_stmt|;
comment|/* not mm_calloc: we don't want to mess with the count. */
name|env
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|testleak_env_t
argument_list|)
argument_list|)
expr_stmt|;
name|env
operator|->
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
name|env
operator|->
name|dns_base
operator|=
name|evdns_base_new
argument_list|(
name|env
operator|->
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|env
operator|->
name|req
operator|=
name|evdns_base_resolve_ipv4
argument_list|(
name|env
operator|->
name|dns_base
argument_list|,
literal|"example.com"
argument_list|,
name|DNS_QUERY_NO_SEARCH
argument_list|,
name|generic_dns_callback
argument_list|,
operator|&
name|env
operator|->
name|r
argument_list|)
expr_stmt|;
return|return
name|env
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|testleak_cleanup
parameter_list|(
specifier|const
name|struct
name|testcase_t
modifier|*
name|testcase
parameter_list|,
name|void
modifier|*
name|env_
parameter_list|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|struct
name|testleak_env_t
modifier|*
name|env
init|=
name|env_
decl_stmt|;
name|tt_assert
argument_list|(
name|env
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENT__DISABLE_DEBUG_MODE
name|tt_int_op
argument_list|(
name|allocated_chunks
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* FIXME: that's `1' because of event_debug_map_HT_GROW */
name|tt_int_op
argument_list|(
name|allocated_chunks
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ok
operator|=
literal|1
expr_stmt|;
name|end
label|:
if|if
condition|(
name|env
condition|)
block|{
if|if
condition|(
name|env
operator|->
name|dns_base
condition|)
name|evdns_base_free
argument_list|(
name|env
operator|->
name|dns_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|->
name|base
condition|)
name|event_base_free
argument_list|(
name|env
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|testcase_setup_t
name|testleak_funcs
init|=
block|{
name|testleak_setup
block|,
name|testleak_cleanup
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|test_dbg_leak_cancel
parameter_list|(
name|void
modifier|*
name|env_
parameter_list|)
block|{
comment|/* cancel, loop, free/dns, free/base */
name|struct
name|testleak_env_t
modifier|*
name|env
init|=
name|env_
decl_stmt|;
name|int
name|send_err_shutdown
init|=
literal|1
decl_stmt|;
name|evdns_cancel_request
argument_list|(
name|env
operator|->
name|dns_base
argument_list|,
name|env
operator|->
name|req
argument_list|)
expr_stmt|;
name|env
operator|->
name|req
operator|=
literal|0
expr_stmt|;
comment|/* `req` is freed in callback, that's why one loop is required. */
name|event_base_loop
argument_list|(
name|env
operator|->
name|base
argument_list|,
name|EVLOOP_NONBLOCK
argument_list|)
expr_stmt|;
comment|/* send_err_shutdown means nothing as soon as our request is 	 * already canceled */
name|evdns_base_free
argument_list|(
name|env
operator|->
name|dns_base
argument_list|,
name|send_err_shutdown
argument_list|)
expr_stmt|;
name|env
operator|->
name|dns_base
operator|=
literal|0
expr_stmt|;
name|event_base_free
argument_list|(
name|env
operator|->
name|base
argument_list|)
expr_stmt|;
name|env
operator|->
name|base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dbg_leak_resume
parameter_list|(
name|void
modifier|*
name|env_
parameter_list|,
name|int
name|cancel
parameter_list|,
name|int
name|send_err_shutdown
parameter_list|)
block|{
comment|/* cancel, loop, free/dns, free/base */
name|struct
name|testleak_env_t
modifier|*
name|env
init|=
name|env_
decl_stmt|;
if|if
condition|(
name|cancel
condition|)
block|{
name|evdns_cancel_request
argument_list|(
name|env
operator|->
name|dns_base
argument_list|,
name|env
operator|->
name|req
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|evdns_base_resume
argument_list|(
name|env
operator|->
name|dns_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO: No nameservers, request can't be processed, must be errored */
name|tt_assert
argument_list|(
operator|!
name|evdns_base_resume
argument_list|(
name|env
operator|->
name|dns_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Because we don't cancel request, 	 * and want our callback to recieve DNS_ERR_SHUTDOWN, 	 * we use deferred callback, and there was 	 * - one extra malloc(), 	 *   @see reply_schedule_callback() 	 * - and one missing free 	 *   @see request_finished() (req->handle->pending_cb = 1) 	 * than we don't need to count in testleak_cleanup() 	 * 	 * So just decrement allocated_chunks to 2, 	 * like we already take care about it. 	 */
if|if
condition|(
operator|!
name|cancel
operator|&&
name|send_err_shutdown
condition|)
block|{
name|allocated_chunks
operator|-=
literal|2
expr_stmt|;
block|}
name|event_base_loop
argument_list|(
name|env
operator|->
name|base
argument_list|,
name|EVLOOP_NONBLOCK
argument_list|)
expr_stmt|;
name|end
label|:
name|evdns_base_free
argument_list|(
name|env
operator|->
name|dns_base
argument_list|,
name|send_err_shutdown
argument_list|)
expr_stmt|;
name|env
operator|->
name|dns_base
operator|=
literal|0
expr_stmt|;
name|event_base_free
argument_list|(
name|env
operator|->
name|base
argument_list|)
expr_stmt|;
name|env
operator|->
name|base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IMPL_DBG_LEAK_RESUME
parameter_list|(
name|name
parameter_list|,
name|cancel
parameter_list|,
name|send_err_shutdown
parameter_list|)
define|\
value|static void                                                    \ 	test_dbg_leak_##name##_(void *env_)                            \ 	{                                                              \ 		dbg_leak_resume(env_, cancel, send_err_shutdown);          \ 	}
end_define

begin_macro
name|IMPL_DBG_LEAK_RESUME
argument_list|(
argument|resume
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
end_macro

begin_macro
name|IMPL_DBG_LEAK_RESUME
argument_list|(
argument|cancel_and_resume
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
end_macro

begin_macro
name|IMPL_DBG_LEAK_RESUME
argument_list|(
argument|resume_send_err
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
end_macro

begin_macro
name|IMPL_DBG_LEAK_RESUME
argument_list|(
argument|cancel_and_resume_send_err
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|test_dbg_leak_shutdown
parameter_list|(
name|void
modifier|*
name|env_
parameter_list|)
block|{
comment|/* free/dns, loop, free/base */
name|struct
name|testleak_env_t
modifier|*
name|env
init|=
name|env_
decl_stmt|;
name|int
name|send_err_shutdown
init|=
literal|1
decl_stmt|;
comment|/* `req` is freed both with `send_err_shutdown` and without it, 	 * the only difference is `evdns_callback` call */
name|env
operator|->
name|req
operator|=
literal|0
expr_stmt|;
name|evdns_base_free
argument_list|(
name|env
operator|->
name|dns_base
argument_list|,
name|send_err_shutdown
argument_list|)
expr_stmt|;
name|env
operator|->
name|dns_base
operator|=
literal|0
expr_stmt|;
comment|/* `req` is freed in callback, that's why one loop is required */
name|event_base_loop
argument_list|(
name|env
operator|->
name|base
argument_list|,
name|EVLOOP_NONBLOCK
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|env
operator|->
name|base
argument_list|)
expr_stmt|;
name|env
operator|->
name|base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|test_getaddrinfo_async_cancel_stress
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
name|struct
name|evdns_base
modifier|*
name|dns_base
init|=
name|NULL
decl_stmt|;
name|struct
name|evdns_server_port
modifier|*
name|server
init|=
name|NULL
decl_stmt|;
name|evutil_socket_t
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|ev_socklen_t
name|slen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
name|dns_base
operator|=
name|evdns_base_new
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x7f000001
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|tt_abort_perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
block|}
name|evutil_make_socket_nonblocking
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_abort_perror
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
block|}
name|server
operator|=
name|evdns_add_server_port_with_base
argument_list|(
name|base
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|,
name|gaic_server_cb
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
name|slen
operator|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|slen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_abort_perror
argument_list|(
literal|"getsockname"
argument_list|)
expr_stmt|;
block|}
name|evdns_base_nameserver_sockaddr_add
argument_list|(
name|dns_base
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|slen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
operator|++
name|i
control|)
block|{
name|gaic_launch
argument_list|(
name|base
argument_list|,
name|dns_base
argument_list|)
expr_stmt|;
block|}
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|dns_base
condition|)
name|evdns_base_free
argument_list|(
name|dns_base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
condition|)
name|evdns_close_server_port
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DNS_LEGACY
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
define|\
value|{ #name, run_legacy_test_fn, flags|TT_LEGACY,&legacy_setup,   \ 		    dns_##name }
end_define

begin_decl_stmt
name|struct
name|testcase_t
name|dns_testcases
index|[]
init|=
block|{
name|DNS_LEGACY
argument_list|(
name|server
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
name|DNS_LEGACY
argument_list|(
name|gethostbyname
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NEED_DNS
operator||
name|TT_OFF_BY_DEFAULT
argument_list|)
block|,
name|DNS_LEGACY
argument_list|(
name|gethostbyname6
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NEED_DNS
operator||
name|TT_OFF_BY_DEFAULT
argument_list|)
block|,
name|DNS_LEGACY
argument_list|(
name|gethostbyaddr
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NEED_DNS
operator||
name|TT_OFF_BY_DEFAULT
argument_list|)
block|,
block|{
literal|"resolve_reverse"
block|,
name|dns_resolve_reverse
block|,
name|TT_FORK
operator||
name|TT_OFF_BY_DEFAULT
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"search"
block|,
name|dns_search_test
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"search_cancel"
block|,
name|dns_search_cancel_test
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"retry"
block|,
name|dns_retry_test
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NO_LOGS
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"reissue"
block|,
name|dns_reissue_test
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NO_LOGS
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"inflight"
block|,
name|dns_inflight_test
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"bufferevent_connect_hostname"
block|,
name|test_bufferevent_connect_hostname
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"getaddrinfo_async"
block|,
name|test_getaddrinfo_async
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
operator|(
name|char
operator|*
operator|)
literal|""
block|}
block|,
block|{
literal|"getaddrinfo_cancel_stress"
block|,
name|test_getaddrinfo_async_cancel_stress
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
ifdef|#
directive|ifdef
name|EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED
block|{
literal|"leak_shutdown"
block|,
name|test_dbg_leak_shutdown
block|,
name|TT_FORK
block|,
operator|&
name|testleak_funcs
block|,
name|NULL
block|}
block|,
block|{
literal|"leak_cancel"
block|,
name|test_dbg_leak_cancel
block|,
name|TT_FORK
block|,
operator|&
name|testleak_funcs
block|,
name|NULL
block|}
block|,
block|{
literal|"leak_resume"
block|,
name|test_dbg_leak_resume_
block|,
name|TT_FORK
block|,
operator|&
name|testleak_funcs
block|,
name|NULL
block|}
block|,
block|{
literal|"leak_cancel_and_resume"
block|,
name|test_dbg_leak_cancel_and_resume_
block|,
name|TT_FORK
block|,
operator|&
name|testleak_funcs
block|,
name|NULL
block|}
block|,
block|{
literal|"leak_resume_send_err"
block|,
name|test_dbg_leak_resume_send_err_
block|,
name|TT_FORK
block|,
operator|&
name|testleak_funcs
block|,
name|NULL
block|}
block|,
block|{
literal|"leak_cancel_and_resume_send_err"
block|,
name|test_dbg_leak_cancel_and_resume_send_err_
block|,
name|TT_FORK
block|,
operator|&
name|testleak_funcs
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
name|END_OF_TESTCASES
block|}
decl_stmt|;
end_decl_stmt

end_unit

