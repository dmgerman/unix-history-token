begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tinytest.c -- Copyright 2009-2012 Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TINYTEST_LOCAL
end_ifdef

begin_include
include|#
directive|include
file|"tinytest_local.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
argument_list|)
end_if

begin_if
if|#
directive|if
operator|(
name|__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
operator|>=
literal|1060
operator|&&
expr|\
name|__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
operator|<
literal|1070
operator|)
end_if

begin_comment
comment|/* Workaround for a stupid bug in OSX 10.6 */
end_comment

begin_define
define|#
directive|define
name|FORK_BREAKS_GCOV
end_define

begin_include
include|#
directive|include
file|<vproc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|__attribute__
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tinytest.h"
end_include

begin_include
include|#
directive|include
file|"tinytest_macros.h"
end_include

begin_define
define|#
directive|define
name|LONGEST_TEST_NAME
value|16384
end_define

begin_decl_stmt
specifier|static
name|int
name|in_tinytest_main
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< true if we're in tinytest_main().*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Number of tests that have passed */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_bad
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Number of tests that have failed. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_skipped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Number of tests that have been skipped. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|opt_forked
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< True iff we're called from inside a win32 fork*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|opt_nofork
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< Suppress calls to fork() for debugging. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|opt_verbosity
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< -==quiet,0==terse,1==normal,2==verbose */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|verbosity_flag
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|testlist_alias_t
modifier|*
name|cfg_aliases
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|outcome
block|{
name|SKIP
init|=
literal|2
block|,
name|OK
init|=
literal|1
block|,
name|FAIL
init|=
literal|0
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|outcome
name|cur_test_outcome
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|cur_test_prefix
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**< prefix of the current test group */
end_comment

begin_comment
comment|/** Name of the current test, if we haven't logged is yet. Used for --quiet */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|cur_test_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_comment
comment|/* Copy of argv[0] for win32. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|commandname
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|struct
name|testgroup_t
modifier|*
name|groups
parameter_list|,
name|int
name|list_groups
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|process_test_option
parameter_list|(
name|struct
name|testgroup_t
modifier|*
name|groups
parameter_list|,
specifier|const
name|char
modifier|*
name|test
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|enum
name|outcome
name|testcase_run_bare_
parameter_list|(
specifier|const
name|struct
name|testcase_t
modifier|*
name|testcase
parameter_list|)
block|{
name|void
modifier|*
name|env
init|=
name|NULL
decl_stmt|;
name|int
name|outcome
decl_stmt|;
if|if
condition|(
name|testcase
operator|->
name|setup
condition|)
block|{
name|env
operator|=
name|testcase
operator|->
name|setup
operator|->
name|setup_fn
argument_list|(
name|testcase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env
condition|)
return|return
name|FAIL
return|;
elseif|else
if|if
condition|(
name|env
operator|==
operator|(
name|void
operator|*
operator|)
name|TT_SKIP
condition|)
return|return
name|SKIP
return|;
block|}
name|cur_test_outcome
operator|=
name|OK
expr_stmt|;
name|testcase
operator|->
name|fn
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|outcome
operator|=
name|cur_test_outcome
expr_stmt|;
if|if
condition|(
name|testcase
operator|->
name|setup
condition|)
block|{
if|if
condition|(
name|testcase
operator|->
name|setup
operator|->
name|cleanup_fn
argument_list|(
name|testcase
argument_list|,
name|env
argument_list|)
operator|==
literal|0
condition|)
name|outcome
operator|=
name|FAIL
expr_stmt|;
block|}
return|return
name|outcome
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAGIC_EXITCODE
value|42
end_define

begin_function
specifier|static
name|enum
name|outcome
name|testcase_run_forked_
parameter_list|(
specifier|const
name|struct
name|testgroup_t
modifier|*
name|group
parameter_list|,
specifier|const
name|struct
name|testcase_t
modifier|*
name|testcase
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
comment|/* Fork? On Win32?  How primitive!  We'll do what the smart kids do: 	   we'll invoke our own exe (whose name we recall from the command 	   line) with a command line that tells it to run just the test we 	   want, and this time without forking.  	   (No, threads aren't an option.  The whole point of forking is to 	   share no state between tests.) 	 */
name|int
name|ok
decl_stmt|;
name|char
name|buffer
index|[
name|LONGEST_TEST_NAME
operator|+
literal|256
index|]
decl_stmt|;
name|STARTUPINFOA
name|si
decl_stmt|;
name|PROCESS_INFORMATION
name|info
decl_stmt|;
name|DWORD
name|exitcode
decl_stmt|;
if|if
condition|(
operator|!
name|in_tinytest_main
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR.  On Windows, testcase_run_forked_ must be"
literal|" called from within tinytest_main.\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|opt_verbosity
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"[forking] "
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s --RUNNING-FORKED %s %s%s"
argument_list|,
name|commandname
argument_list|,
name|verbosity_flag
argument_list|,
name|group
operator|->
name|prefix
argument_list|,
name|testcase
operator|->
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|si
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|.
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|ok
operator|=
name|CreateProcessA
argument_list|(
name|commandname
argument_list|,
name|buffer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|si
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|printf
argument_list|(
literal|"CreateProcess failed!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|WaitForSingleObject
argument_list|(
name|info
operator|.
name|hProcess
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
name|GetExitCodeProcess
argument_list|(
name|info
operator|.
name|hProcess
argument_list|,
operator|&
name|exitcode
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|info
operator|.
name|hProcess
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|info
operator|.
name|hThread
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitcode
operator|==
literal|0
condition|)
return|return
name|OK
return|;
elseif|else
if|if
condition|(
name|exitcode
operator|==
name|MAGIC_EXITCODE
condition|)
return|return
name|SKIP
return|;
else|else
return|return
name|FAIL
return|;
else|#
directive|else
name|int
name|outcome_pipe
index|[
literal|2
index|]
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
operator|(
name|void
operator|)
name|group
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|outcome_pipe
argument_list|)
condition|)
name|perror
argument_list|(
literal|"opening pipe"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_verbosity
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"[forking] "
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FORK_BREAKS_GCOV
name|vproc_transaction_begin
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pid
condition|)
block|{
comment|/* child. */
name|int
name|test_r
decl_stmt|,
name|write_r
decl_stmt|;
name|char
name|b
index|[
literal|1
index|]
decl_stmt|;
name|close
argument_list|(
name|outcome_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|test_r
operator|=
name|testcase_run_bare_
argument_list|(
name|testcase
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|<=
operator|(
name|int
operator|)
name|test_r
operator|&&
operator|(
name|int
operator|)
name|test_r
operator|<=
literal|2
argument_list|)
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
literal|"NYS"
index|[
name|test_r
index|]
expr_stmt|;
name|write_r
operator|=
operator|(
name|int
operator|)
name|write
argument_list|(
name|outcome_pipe
index|[
literal|1
index|]
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_r
operator|!=
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"write outcome to pipe"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
comment|/* unreachable */
block|}
else|else
block|{
comment|/* parent */
name|int
name|status
decl_stmt|,
name|r
decl_stmt|;
name|char
name|b
index|[
literal|1
index|]
decl_stmt|;
comment|/* Close this now, so that if the other side closes it, 		 * our read fails. */
name|close
argument_list|(
name|outcome_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|int
operator|)
name|read
argument_list|(
name|outcome_pipe
index|[
literal|0
index|]
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"[Lost connection!] "
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"read outcome from pipe"
argument_list|)
expr_stmt|;
block|}
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|outcome_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|b
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|?
name|OK
else|:
operator|(
name|b
index|[
literal|0
index|]
operator|==
literal|'S'
condition|?
name|SKIP
else|:
name|FAIL
operator|)
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|testcase_run_one
parameter_list|(
specifier|const
name|struct
name|testgroup_t
modifier|*
name|group
parameter_list|,
specifier|const
name|struct
name|testcase_t
modifier|*
name|testcase
parameter_list|)
block|{
name|enum
name|outcome
name|outcome
decl_stmt|;
if|if
condition|(
name|testcase
operator|->
name|flags
operator|&
operator|(
name|TT_SKIP
operator||
name|TT_OFF_BY_DEFAULT
operator|)
condition|)
block|{
if|if
condition|(
name|opt_verbosity
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s%s: %s\n"
argument_list|,
name|group
operator|->
name|prefix
argument_list|,
name|testcase
operator|->
name|name
argument_list|,
operator|(
name|testcase
operator|->
name|flags
operator|&
name|TT_SKIP
operator|)
condition|?
literal|"SKIPPED"
else|:
literal|"DISABLED"
argument_list|)
expr_stmt|;
operator|++
name|n_skipped
expr_stmt|;
return|return
name|SKIP
return|;
block|}
if|if
condition|(
name|opt_verbosity
operator|>
literal|0
operator|&&
operator|!
name|opt_forked
condition|)
block|{
name|printf
argument_list|(
literal|"%s%s: "
argument_list|,
name|group
operator|->
name|prefix
argument_list|,
name|testcase
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opt_verbosity
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|cur_test_prefix
operator|=
name|group
operator|->
name|prefix
expr_stmt|;
name|cur_test_name
operator|=
name|testcase
operator|->
name|name
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|testcase
operator|->
name|flags
operator|&
name|TT_FORK
operator|)
operator|&&
operator|!
operator|(
name|opt_forked
operator|||
name|opt_nofork
operator|)
condition|)
block|{
name|outcome
operator|=
name|testcase_run_forked_
argument_list|(
name|group
argument_list|,
name|testcase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outcome
operator|=
name|testcase_run_bare_
argument_list|(
name|testcase
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outcome
operator|==
name|OK
condition|)
block|{
operator|++
name|n_ok
expr_stmt|;
if|if
condition|(
name|opt_verbosity
operator|>
literal|0
operator|&&
operator|!
name|opt_forked
condition|)
name|puts
argument_list|(
name|opt_verbosity
operator|==
literal|1
condition|?
literal|"OK"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outcome
operator|==
name|SKIP
condition|)
block|{
operator|++
name|n_skipped
expr_stmt|;
if|if
condition|(
name|opt_verbosity
operator|>
literal|0
operator|&&
operator|!
name|opt_forked
condition|)
name|puts
argument_list|(
literal|"SKIPPED"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|n_bad
expr_stmt|;
if|if
condition|(
operator|!
name|opt_forked
condition|)
name|printf
argument_list|(
literal|"\n  [%s FAILED]\n"
argument_list|,
name|testcase
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt_forked
condition|)
block|{
name|exit
argument_list|(
name|outcome
operator|==
name|OK
condition|?
literal|0
else|:
operator|(
name|outcome
operator|==
name|SKIP
condition|?
name|MAGIC_EXITCODE
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* unreachable */
block|}
else|else
block|{
return|return
operator|(
name|int
operator|)
name|outcome
return|;
block|}
block|}
end_function

begin_function
name|int
name|tinytest_set_flag_
parameter_list|(
name|struct
name|testgroup_t
modifier|*
name|groups
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|set
parameter_list|,
name|unsigned
name|long
name|flag
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|size_t
name|length
init|=
name|LONGEST_TEST_NAME
decl_stmt|;
name|char
name|fullname
index|[
name|LONGEST_TEST_NAME
index|]
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|arg
argument_list|,
literal|".."
argument_list|)
condition|)
name|length
operator|=
name|strstr
argument_list|(
name|arg
argument_list|,
literal|".."
argument_list|)
operator|-
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|groups
index|[
name|i
index|]
operator|.
name|prefix
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|groups
index|[
name|i
index|]
operator|.
name|cases
index|[
name|j
index|]
operator|.
name|name
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|testcase_t
modifier|*
name|testcase
init|=
operator|&
name|groups
index|[
name|i
index|]
operator|.
name|cases
index|[
name|j
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|fullname
argument_list|,
sizeof|sizeof
argument_list|(
name|fullname
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|groups
index|[
name|i
index|]
operator|.
name|prefix
argument_list|,
name|testcase
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag
condition|)
block|{
comment|/* Hack! */
name|printf
argument_list|(
literal|"    %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|testcase
operator|->
name|flags
operator|&
name|TT_OFF_BY_DEFAULT
condition|)
name|puts
argument_list|(
literal|"   (Off by default)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|testcase
operator|->
name|flags
operator|&
name|TT_SKIP
condition|)
name|puts
argument_list|(
literal|"  (DISABLED)"
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|fullname
argument_list|,
name|arg
argument_list|,
name|length
argument_list|)
condition|)
block|{
if|if
condition|(
name|set
condition|)
name|testcase
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
else|else
name|testcase
operator|->
name|flags
operator|&=
operator|~
name|flag
expr_stmt|;
operator|++
name|found
expr_stmt|;
block|}
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|struct
name|testgroup_t
modifier|*
name|groups
parameter_list|,
name|int
name|list_groups
parameter_list|)
block|{
name|puts
argument_list|(
literal|"Options are: [--verbose|--quiet|--terse] [--no-fork]"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  Specify tests by name, or using a prefix ending with '..'"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  To skip a test, prefix its name with a colon."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  To enable a disabled test, prefix its name with a plus."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  Use --list-tests for a list of tests."
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_groups
condition|)
block|{
name|puts
argument_list|(
literal|"Known tests are:"
argument_list|)
expr_stmt|;
name|tinytest_set_flag_
argument_list|(
name|groups
argument_list|,
literal|".."
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_test_alias
parameter_list|(
name|struct
name|testgroup_t
modifier|*
name|groups
parameter_list|,
specifier|const
name|char
modifier|*
name|test
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cfg_aliases
operator|&&
name|cfg_aliases
index|[
name|i
index|]
operator|.
name|name
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cfg_aliases
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|test
argument_list|)
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|cfg_aliases
index|[
name|i
index|]
operator|.
name|tests
index|[
name|j
index|]
condition|;
operator|++
name|j
control|)
block|{
name|r
operator|=
name|process_test_option
argument_list|(
name|groups
argument_list|,
name|cfg_aliases
index|[
name|i
index|]
operator|.
name|tests
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|n
operator|+=
name|r
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
block|}
name|printf
argument_list|(
literal|"No such test alias as @%s!"
argument_list|,
name|test
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_test_option
parameter_list|(
name|struct
name|testgroup_t
modifier|*
name|groups
parameter_list|,
specifier|const
name|char
modifier|*
name|test
parameter_list|)
block|{
name|int
name|flag
init|=
name|TT_ENABLED_
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|test
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
return|return
name|process_test_alias
argument_list|(
name|groups
argument_list|,
name|test
operator|+
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|test
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
operator|++
name|test
expr_stmt|;
name|flag
operator|=
name|TT_SKIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|test
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
operator|++
name|test
expr_stmt|;
operator|++
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|tinytest_set_flag_
argument_list|(
name|groups
argument_list|,
name|test
argument_list|,
literal|0
argument_list|,
name|TT_OFF_BY_DEFAULT
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"No such test as %s!\n"
argument_list|,
name|test
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tinytest_set_flag_
argument_list|(
name|groups
argument_list|,
name|test
argument_list|,
literal|1
argument_list|,
name|flag
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"No such test as %s!\n"
argument_list|,
name|test
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|tinytest_set_aliases
parameter_list|(
specifier|const
name|struct
name|testlist_alias_t
modifier|*
name|aliases
parameter_list|)
block|{
name|cfg_aliases
operator|=
name|aliases
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tinytest_main
parameter_list|(
name|int
name|c
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|v
parameter_list|,
name|struct
name|testgroup_t
modifier|*
name|groups
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
specifier|const
name|char
modifier|*
name|sp
init|=
name|strrchr
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|extension
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|sp
operator|||
name|stricmp
argument_list|(
name|sp
argument_list|,
literal|".exe"
argument_list|)
condition|)
name|extension
operator|=
literal|".exe"
expr_stmt|;
comment|/* Add an exe so CreateProcess will work */
name|snprintf
argument_list|(
name|commandname
argument_list|,
sizeof|sizeof
argument_list|(
name|commandname
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|v
index|[
literal|0
index|]
argument_list|,
name|extension
argument_list|)
expr_stmt|;
name|commandname
index|[
name|MAX_PATH
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
index|[
name|i
index|]
argument_list|,
literal|"--RUNNING-FORKED"
argument_list|)
condition|)
block|{
name|opt_forked
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
index|[
name|i
index|]
argument_list|,
literal|"--no-fork"
argument_list|)
condition|)
block|{
name|opt_nofork
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
index|[
name|i
index|]
argument_list|,
literal|"--quiet"
argument_list|)
condition|)
block|{
name|opt_verbosity
operator|=
operator|-
literal|1
expr_stmt|;
name|verbosity_flag
operator|=
literal|"--quiet"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
index|[
name|i
index|]
argument_list|,
literal|"--verbose"
argument_list|)
condition|)
block|{
name|opt_verbosity
operator|=
literal|2
expr_stmt|;
name|verbosity_flag
operator|=
literal|"--verbose"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
index|[
name|i
index|]
argument_list|,
literal|"--terse"
argument_list|)
condition|)
block|{
name|opt_verbosity
operator|=
literal|0
expr_stmt|;
name|verbosity_flag
operator|=
literal|"--terse"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
index|[
name|i
index|]
argument_list|,
literal|"--help"
argument_list|)
condition|)
block|{
name|usage
argument_list|(
name|groups
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
index|[
name|i
index|]
argument_list|,
literal|"--list-tests"
argument_list|)
condition|)
block|{
name|usage
argument_list|(
name|groups
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unknown option %s.  Try --help\n"
argument_list|,
name|v
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|int
name|r
init|=
name|process_test_option
argument_list|(
name|groups
argument_list|,
name|v
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|n
operator|+=
name|r
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
name|tinytest_set_flag_
argument_list|(
name|groups
argument_list|,
literal|".."
argument_list|,
literal|1
argument_list|,
name|TT_ENABLED_
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|in_tinytest_main
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|groups
index|[
name|i
index|]
operator|.
name|prefix
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|groups
index|[
name|i
index|]
operator|.
name|cases
index|[
name|j
index|]
operator|.
name|name
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|groups
index|[
name|i
index|]
operator|.
name|cases
index|[
name|j
index|]
operator|.
name|flags
operator|&
name|TT_ENABLED_
condition|)
name|testcase_run_one
argument_list|(
operator|&
name|groups
index|[
name|i
index|]
argument_list|,
operator|&
name|groups
index|[
name|i
index|]
operator|.
name|cases
index|[
name|j
index|]
argument_list|)
expr_stmt|;
operator|--
name|in_tinytest_main
expr_stmt|;
if|if
condition|(
name|opt_verbosity
operator|==
literal|0
condition|)
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_bad
condition|)
name|printf
argument_list|(
literal|"%d/%d TESTS FAILED. (%d skipped)\n"
argument_list|,
name|n_bad
argument_list|,
name|n_bad
operator|+
name|n_ok
argument_list|,
name|n_skipped
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_verbosity
operator|>=
literal|1
condition|)
name|printf
argument_list|(
literal|"%d tests ok.  (%d skipped)\n"
argument_list|,
name|n_ok
argument_list|,
name|n_skipped
argument_list|)
expr_stmt|;
return|return
operator|(
name|n_bad
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_function
name|int
name|tinytest_get_verbosity_
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|opt_verbosity
return|;
block|}
end_function

begin_function
name|void
name|tinytest_set_test_failed_
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|opt_verbosity
operator|<=
literal|0
operator|&&
name|cur_test_name
condition|)
block|{
if|if
condition|(
name|opt_verbosity
operator|==
literal|0
condition|)
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s: "
argument_list|,
name|cur_test_prefix
argument_list|,
name|cur_test_name
argument_list|)
expr_stmt|;
name|cur_test_name
operator|=
name|NULL
expr_stmt|;
block|}
name|cur_test_outcome
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tinytest_set_test_skipped_
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cur_test_outcome
operator|==
name|OK
condition|)
name|cur_test_outcome
operator|=
name|SKIP
expr_stmt|;
block|}
end_function

end_unit

