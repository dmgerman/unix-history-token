begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009-2012 Nick Mathewson and Niels Provos  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"../util-internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<ws2tcpip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_NETINET_IN6_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"../ipv6-internal.h"
end_include

begin_include
include|#
directive|include
file|"../log-internal.h"
end_include

begin_include
include|#
directive|include
file|"../strlcpy-internal.h"
end_include

begin_include
include|#
directive|include
file|"../mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"../time-internal.h"
end_include

begin_include
include|#
directive|include
file|"regress.h"
end_include

begin_enum
enum|enum
name|entry_status
block|{
name|NORMAL
block|,
name|CANONICAL
block|,
name|BAD
block|}
enum|;
end_enum

begin_comment
comment|/* This is a big table of results we expect from generating and parsing */
end_comment

begin_struct
specifier|static
struct|struct
name|ipv4_entry
block|{
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
name|ev_uint32_t
name|res
decl_stmt|;
name|enum
name|entry_status
name|status
decl_stmt|;
block|}
name|ipv4_entries
index|[]
init|=
block|{
block|{
literal|"1.2.3.4"
block|,
literal|0x01020304u
block|,
name|CANONICAL
block|}
block|,
block|{
literal|"255.255.255.255"
block|,
literal|0xffffffffu
block|,
name|CANONICAL
block|}
block|,
block|{
literal|"256.0.0.0"
block|,
literal|0
block|,
name|BAD
block|}
block|,
block|{
literal|"ABC"
block|,
literal|0
block|,
name|BAD
block|}
block|,
block|{
literal|"1.2.3.4.5"
block|,
literal|0
block|,
name|BAD
block|}
block|,
block|{
literal|"176.192.208.244"
block|,
literal|0xb0c0d0f4
block|,
name|CANONICAL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|BAD
block|}
block|, }
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|ipv6_entry
block|{
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
name|ev_uint32_t
name|res
index|[
literal|4
index|]
decl_stmt|;
name|enum
name|entry_status
name|status
decl_stmt|;
block|}
name|ipv6_entries
index|[]
init|=
block|{
block|{
literal|"::"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
block|,
name|CANONICAL
block|}
block|,
block|{
literal|"0:0:0:0:0:0:0:0"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
block|,
name|NORMAL
block|}
block|,
block|{
literal|"::1"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|, }
block|,
name|CANONICAL
block|}
block|,
block|{
literal|"::1.2.3.4"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x01020304
block|, }
block|,
name|CANONICAL
block|}
block|,
block|{
literal|"ffff:1::"
block|,
block|{
literal|0xffff0001u
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
block|,
name|CANONICAL
block|}
block|,
block|{
literal|"ffff:0000::"
block|,
block|{
literal|0xffff0000u
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
block|,
name|NORMAL
block|}
block|,
block|{
literal|"ffff::1234"
block|,
block|{
literal|0xffff0000u
block|,
literal|0
block|,
literal|0
block|,
literal|0x1234
block|, }
block|,
name|CANONICAL
block|}
block|,
block|{
literal|"0102::1.2.3.4"
block|,
block|{
literal|0x01020000u
block|,
literal|0
block|,
literal|0
block|,
literal|0x01020304u
block|}
block|,
name|NORMAL
block|}
block|,
block|{
literal|"::9:c0a8:1:1"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0x0009c0a8u
block|,
literal|0x00010001u
block|}
block|,
name|CANONICAL
block|}
block|,
block|{
literal|"::ffff:1.2.3.4"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0x000ffffu
block|,
literal|0x01020304u
block|}
block|,
name|CANONICAL
block|}
block|,
block|{
literal|"FFFF::"
block|,
block|{
literal|0xffff0000u
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|NORMAL
block|}
block|,
block|{
literal|"foobar."
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
literal|"foobar"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
literal|"fo:obar"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
literal|"ffff"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
literal|"fffff::"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
literal|"fffff::"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
literal|"::1.0.1.1000"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
literal|"1:2:33333:4::"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
literal|"1:2:3:4:5:6:7:8:9"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
literal|"1::2::3"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
literal|":::1"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|BAD
block|}
block|,
block|{
name|NULL
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,  }
block|,
name|BAD
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|void
name|regress_ipv4_parse
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ipv4_entries
index|[
name|i
index|]
operator|.
name|addr
condition|;
operator|++
name|i
control|)
block|{
name|char
name|written
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|ipv4_entry
modifier|*
name|ent
init|=
operator|&
name|ipv4_entries
index|[
name|i
index|]
decl_stmt|;
name|struct
name|in_addr
name|in
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|evutil_inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|ent
operator|->
name|addr
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|status
operator|!=
name|BAD
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"%s did not parse, but it's a good address!"
operator|,
name|ent
operator|->
name|addr
operator|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|ent
operator|->
name|status
operator|==
name|BAD
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"%s parsed, but we expected an error"
operator|,
name|ent
operator|->
name|addr
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|in
operator|.
name|s_addr
argument_list|)
operator|!=
name|ent
operator|->
name|res
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"%s parsed to %lx, but we expected %lx"
operator|,
name|ent
operator|->
name|addr
operator|,
operator|(
name|unsigned
name|long
operator|)
name|ntohl
argument_list|(
name|in
operator|.
name|s_addr
argument_list|)
operator|,
operator|(
name|unsigned
name|long
operator|)
name|ent
operator|->
name|res
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ent
operator|->
name|status
operator|==
name|CANONICAL
condition|)
block|{
specifier|const
name|char
modifier|*
name|w
init|=
name|evutil_inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|in
argument_list|,
name|written
argument_list|,
sizeof|sizeof
argument_list|(
name|written
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Tried to write out %s; got NULL."
operator|,
name|ent
operator|->
name|addr
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|written
argument_list|,
name|ent
operator|->
name|addr
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Tried to write out %s; got %s"
operator|,
name|ent
operator|->
name|addr
operator|,
name|written
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|regress_ipv6_parse
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AF_INET6
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ipv6_entries
index|[
name|i
index|]
operator|.
name|addr
condition|;
operator|++
name|i
control|)
block|{
name|char
name|written
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|ipv6_entry
modifier|*
name|ent
init|=
operator|&
name|ipv6_entries
index|[
name|i
index|]
decl_stmt|;
name|struct
name|in6_addr
name|in6
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|evutil_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|ent
operator|->
name|addr
argument_list|,
operator|&
name|in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|status
operator|!=
name|BAD
condition|)
name|TT_FAIL
argument_list|(
operator|(
literal|"%s did not parse, but it's a good address!"
operator|,
name|ent
operator|->
name|addr
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ent
operator|->
name|status
operator|==
name|BAD
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"%s parsed, but we expected an error"
operator|,
name|ent
operator|->
name|addr
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
operator|++
name|j
control|)
block|{
comment|/* Can't use s6_addr32 here; some don't have it. */
name|ev_uint32_t
name|u
init|=
operator|(
name|in6
operator|.
name|s6_addr
index|[
name|j
operator|*
literal|4
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|in6
operator|.
name|s6_addr
index|[
name|j
operator|*
literal|4
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|in6
operator|.
name|s6_addr
index|[
name|j
operator|*
literal|4
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|in6
operator|.
name|s6_addr
index|[
name|j
operator|*
literal|4
operator|+
literal|3
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|u
operator|!=
name|ent
operator|->
name|res
index|[
name|j
index|]
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"%s did not parse as expected."
operator|,
name|ent
operator|->
name|addr
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|ent
operator|->
name|status
operator|==
name|CANONICAL
condition|)
block|{
specifier|const
name|char
modifier|*
name|w
init|=
name|evutil_inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|in6
argument_list|,
name|written
argument_list|,
sizeof|sizeof
argument_list|(
name|written
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Tried to write out %s; got NULL."
operator|,
name|ent
operator|->
name|addr
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|written
argument_list|,
name|ent
operator|->
name|addr
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Tried to write out %s; got %s"
operator|,
name|ent
operator|->
name|addr
operator|,
name|written
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
else|#
directive|else
name|TT_BLATHER
argument_list|(
operator|(
literal|"Skipping IPv6 address parsing."
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_struct
specifier|static
struct|struct
name|sa_port_ent
block|{
specifier|const
name|char
modifier|*
name|parse
decl_stmt|;
name|int
name|safamily
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|port
decl_stmt|;
block|}
name|sa_port_ents
index|[]
init|=
block|{
block|{
literal|"[ffff::1]:1000"
block|,
name|AF_INET6
block|,
literal|"ffff::1"
block|,
literal|1000
block|}
block|,
block|{
literal|"[ffff::1]"
block|,
name|AF_INET6
block|,
literal|"ffff::1"
block|,
literal|0
block|}
block|,
block|{
literal|"[ffff::1"
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"[ffff::1]:65599"
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"[ffff::1]:0"
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"[ffff::1]:-1"
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"::1"
block|,
name|AF_INET6
block|,
literal|"::1"
block|,
literal|0
block|}
block|,
block|{
literal|"1:2::1"
block|,
name|AF_INET6
block|,
literal|"1:2::1"
block|,
literal|0
block|}
block|,
block|{
literal|"192.168.0.1:50"
block|,
name|AF_INET
block|,
literal|"192.168.0.1"
block|,
literal|50
block|}
block|,
block|{
literal|"1.2.3.4"
block|,
name|AF_INET
block|,
literal|"1.2.3.4"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|void
name|regress_sockaddr_port_parse
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sa_port_ents
index|[
name|i
index|]
operator|.
name|parse
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|sa_port_ent
modifier|*
name|ent
init|=
operator|&
name|sa_port_ents
index|[
name|i
index|]
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_parse_sockaddr_port
argument_list|(
name|ent
operator|->
name|parse
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|safamily
condition|)
name|TT_FAIL
argument_list|(
operator|(
literal|"Couldn't parse %s!"
operator|,
name|ent
operator|->
name|parse
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|ent
operator|->
name|safamily
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Shouldn't have been able to parse %s!"
operator|,
name|ent
operator|->
name|parse
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ent
operator|->
name|safamily
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|ent
operator|->
name|port
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|ent
operator|->
name|addr
argument_list|,
operator|&
name|sin
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|!=
name|r
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Couldn't parse ipv4 target %s."
operator|,
name|ent
operator|->
name|addr
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|sin
argument_list|,
operator|&
name|ss
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Parse for %s was not as expected."
operator|,
name|ent
operator|->
name|parse
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Length for %s not as expected."
operator|,
name|ent
operator|->
name|parse
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
name|ent
operator|->
name|port
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|ent
operator|->
name|addr
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|!=
name|r
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Couldn't parse ipv6 target %s."
operator|,
name|ent
operator|->
name|addr
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|sin6
argument_list|,
operator|&
name|ss
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Parse for %s was not as expected."
operator|,
name|ent
operator|->
name|parse
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Length for %s not as expected."
operator|,
name|ent
operator|->
name|parse
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|regress_sockaddr_port_format
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|cbuf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_parse_sockaddr_port
argument_list|(
literal|"192.168.1.1:80"
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|cp
argument_list|,
operator|==
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|cp
argument_list|,
operator|==
argument_list|,
literal|"192.168.1.1:80"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_parse_sockaddr_port
argument_list|(
literal|"[ff00::8010]:999"
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|cp
argument_list|,
operator|==
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|cp
argument_list|,
operator|==
argument_list|,
literal|"[ff00::8010]:999"
argument_list|)
expr_stmt|;
name|ss
operator|.
name|ss_family
operator|=
literal|99
expr_stmt|;
name|cp
operator|=
name|evutil_format_sockaddr_port_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|cp
argument_list|,
operator|==
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|cp
argument_list|,
operator|==
argument_list|,
literal|"<addr with socktype 99>"
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|sa_pred_ent
block|{
specifier|const
name|char
modifier|*
name|parse
decl_stmt|;
name|int
name|is_loopback
decl_stmt|;
block|}
name|sa_pred_entries
index|[]
init|=
block|{
block|{
literal|"127.0.0.1"
block|,
literal|1
block|}
block|,
block|{
literal|"127.0.3.2"
block|,
literal|1
block|}
block|,
block|{
literal|"128.1.2.3"
block|,
literal|0
block|}
block|,
block|{
literal|"18.0.0.1"
block|,
literal|0
block|}
block|,
block|{
literal|"129.168.1.1"
block|,
literal|0
block|}
block|,
block|{
literal|"::1"
block|,
literal|1
block|}
block|,
block|{
literal|"::0"
block|,
literal|0
block|}
block|,
block|{
literal|"f::1"
block|,
literal|0
block|}
block|,
block|{
literal|"::501"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|,  }
struct|;
end_struct

begin_function
specifier|static
name|void
name|test_evutil_sockaddr_predicates
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sa_pred_entries
index|[
name|i
index|]
operator|.
name|parse
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|sa_pred_ent
modifier|*
name|ent
init|=
operator|&
name|sa_pred_entries
index|[
name|i
index|]
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
decl_stmt|;
name|r
operator|=
name|evutil_parse_sockaddr_port
argument_list|(
name|ent
operator|->
name|parse
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Couldn't parse %s!"
operator|,
name|ent
operator|->
name|parse
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* sockaddr_is_loopback */
if|if
condition|(
name|ent
operator|->
name|is_loopback
operator|!=
name|evutil_sockaddr_is_loopback_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"evutil_sockaddr_loopback(%s) not as expected"
operator|,
name|ent
operator|->
name|parse
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_strtoll
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|tt_want
argument_list|(
name|evutil_strtoll
argument_list|(
literal|"5000000000"
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|==
operator|(
operator|(
name|ev_int64_t
operator|)
literal|5000000
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|evutil_strtoll
argument_list|(
literal|"-5000000000"
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|==
operator|(
operator|(
name|ev_int64_t
operator|)
literal|5000000
operator|)
operator|*
operator|-
literal|1000
argument_list|)
expr_stmt|;
name|s
operator|=
literal|" 99999stuff"
expr_stmt|;
name|tt_want
argument_list|(
name|evutil_strtoll
argument_list|(
name|s
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
operator|==
operator|(
name|ev_int64_t
operator|)
literal|99999
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|endptr
operator|==
name|s
operator|+
literal|6
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|evutil_strtoll
argument_list|(
literal|"foo"
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_snprintf
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|ev_uint64_t
name|u64
init|=
operator|(
operator|(
name|ev_uint64_t
operator|)
literal|1000000000
operator|)
operator|*
literal|200
decl_stmt|;
name|ev_int64_t
name|i64
init|=
operator|-
literal|1
operator|*
operator|(
name|ev_int64_t
operator|)
name|u64
decl_stmt|;
name|size_t
name|size
init|=
literal|8000
decl_stmt|;
name|ev_ssize_t
name|ssize
init|=
operator|-
literal|9000
decl_stmt|;
name|r
operator|=
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d %d"
argument_list|,
literal|50
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|buf
argument_list|,
operator|==
argument_list|,
literal|"50 100"
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"longish %d"
argument_list|,
literal|1234567890
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|buf
argument_list|,
operator|==
argument_list|,
literal|"longish 1234567"
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|EV_U64_FMT
argument_list|,
name|EV_U64_ARG
argument_list|(
name|u64
argument_list|)
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|buf
argument_list|,
operator|==
argument_list|,
literal|"200000000000"
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|EV_I64_FMT
argument_list|,
name|EV_I64_ARG
argument_list|(
name|i64
argument_list|)
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|buf
argument_list|,
operator|==
argument_list|,
literal|"-200000000000"
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|EV_SIZE_FMT
literal|" "
name|EV_SSIZE_FMT
argument_list|,
name|EV_SIZE_ARG
argument_list|(
name|size
argument_list|)
argument_list|,
name|EV_SSIZE_ARG
argument_list|(
name|ssize
argument_list|)
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|buf
argument_list|,
operator|==
argument_list|,
literal|"8000 -9000"
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_casecmp
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|tt_int_op
argument_list|(
name|evutil_ascii_strcasecmp
argument_list|(
literal|"ABC"
argument_list|,
literal|"ABC"
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strcasecmp
argument_list|(
literal|"ABC"
argument_list|,
literal|"abc"
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strcasecmp
argument_list|(
literal|"ABC"
argument_list|,
literal|"abcd"
argument_list|)
argument_list|,
operator|<
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strcasecmp
argument_list|(
literal|"ABC"
argument_list|,
literal|"abb"
argument_list|)
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strcasecmp
argument_list|(
literal|"ABCd"
argument_list|,
literal|"abc"
argument_list|)
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strncasecmp
argument_list|(
literal|"Libevent"
argument_list|,
literal|"LibEvEnT"
argument_list|,
literal|100
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strncasecmp
argument_list|(
literal|"Libevent"
argument_list|,
literal|"LibEvEnT"
argument_list|,
literal|4
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strncasecmp
argument_list|(
literal|"Libevent"
argument_list|,
literal|"LibEXXXX"
argument_list|,
literal|4
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strncasecmp
argument_list|(
literal|"Libevent"
argument_list|,
literal|"LibE"
argument_list|,
literal|4
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strncasecmp
argument_list|(
literal|"Libe"
argument_list|,
literal|"LibEvEnT"
argument_list|,
literal|4
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strncasecmp
argument_list|(
literal|"Lib"
argument_list|,
literal|"LibEvEnT"
argument_list|,
literal|4
argument_list|)
argument_list|,
operator|<
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strncasecmp
argument_list|(
literal|"abc"
argument_list|,
literal|"def"
argument_list|,
literal|99
argument_list|)
argument_list|,
operator|<
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_ascii_strncasecmp
argument_list|(
literal|"Z"
argument_list|,
literal|"qrst"
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_rtrim
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
define|#
directive|define
name|TEST_TRIM
parameter_list|(
name|s
parameter_list|,
name|result
parameter_list|)
define|\
value|do {						\ 	    if (cp) mm_free(cp);			\ 	    cp = mm_strdup(s);				\ 	    tt_assert(cp);				\ 	    evutil_rtrim_lws_(cp);			\ 	    tt_str_op(cp, ==, result);			\ 	} while(0)
name|char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|ptr
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"a"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"abcdef ghi"
argument_list|,
literal|"abcdef ghi"
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"  "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"a "
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"abcdef  gH       "
argument_list|,
literal|"abcdef  gH"
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"\t\t"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|" \t"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"\t"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"a \t"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"a\t "
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"a\t"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|TEST_TRIM
argument_list|(
literal|"abcdef  gH    \t  "
argument_list|,
literal|"abcdef  gH"
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|cp
condition|)
name|mm_free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|logsev
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|logmsg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|logfn
parameter_list|(
name|int
name|severity
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|logsev
operator|=
name|severity
expr_stmt|;
name|tt_want
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
if|if
condition|(
name|logmsg
condition|)
name|free
argument_list|(
name|logmsg
argument_list|)
expr_stmt|;
name|logmsg
operator|=
name|strdup
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|fatal_want_severity
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|fatal_want_message
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fatalfn
parameter_list|(
name|int
name|exitcode
parameter_list|)
block|{
if|if
condition|(
name|logsev
operator|!=
name|fatal_want_severity
operator|||
operator|!
name|logmsg
operator|||
name|strcmp
argument_list|(
name|logmsg
argument_list|,
name|fatal_want_message
argument_list|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_define
define|#
directive|define
name|CAN_CHECK_ERR
end_define

begin_function
specifier|static
name|void
name|check_error_logging
parameter_list|(
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|int
name|wantexitcode
parameter_list|,
name|int
name|wantseverity
parameter_list|,
specifier|const
name|char
modifier|*
name|wantmsg
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|,
name|exitcode
decl_stmt|;
name|fatal_want_severity
operator|=
name|wantseverity
expr_stmt|;
name|fatal_want_message
operator|=
name|wantmsg
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|regress_fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* child process */
name|fn
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* should be unreachable. */
block|}
else|else
block|{
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|exitcode
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|wantexitcode
argument_list|,
operator|==
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
block|}
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|errx_fn
parameter_list|(
name|void
parameter_list|)
block|{
name|event_errx
argument_list|(
literal|2
argument_list|,
literal|"Fatal error; too many kumquats (%d)"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|err_fn
parameter_list|(
name|void
parameter_list|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
name|event_err
argument_list|(
literal|5
argument_list|,
literal|"Couldn't open %s"
argument_list|,
literal|"/very/bad/file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sock_err_fn
parameter_list|(
name|void
parameter_list|)
block|{
name|evutil_socket_t
name|fd
init|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|EVUTIL_SET_SOCKET_ERROR
argument_list|(
name|WSAEWOULDBLOCK
argument_list|)
expr_stmt|;
else|#
directive|else
name|errno
operator|=
name|EAGAIN
expr_stmt|;
endif|#
directive|endif
name|event_sock_err
argument_list|(
literal|20
argument_list|,
name|fd
argument_list|,
literal|"Unhappy socket"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|test_evutil_log
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|evutil_socket_t
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|event_set_log_callback
argument_list|(
name|logfn
argument_list|)
expr_stmt|;
name|event_set_fatal_callback
argument_list|(
name|fatalfn
argument_list|)
expr_stmt|;
define|#
directive|define
name|RESET
parameter_list|()
value|do {				\ 		logsev = 0;	\ 		if (logmsg) free(logmsg);	\ 		logmsg = NULL;			\ 	} while (0)
define|#
directive|define
name|LOGEQ
parameter_list|(
name|sev
parameter_list|,
name|msg
parameter_list|)
value|do {			\ 		tt_int_op(logsev,==,sev);	\ 		tt_assert(logmsg != NULL);	\ 		tt_str_op(logmsg,==,msg);	\ 	} while (0)
ifdef|#
directive|ifdef
name|CAN_CHECK_ERR
comment|/* We need to disable these tests for now.  Previously, the logging 	 * module didn't enforce the requirement that a fatal callback 	 * actually exit.  Now, it exits no matter what, so if we wan to 	 * reinstate these tests, we'll need to fork for each one. */
name|check_error_logging
argument_list|(
name|errx_fn
argument_list|,
literal|2
argument_list|,
name|EVENT_LOG_ERR
argument_list|,
literal|"Fatal error; too many kumquats (5)"
argument_list|)
expr_stmt|;
name|RESET
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|event_warnx
argument_list|(
literal|"Far too many %s (%d)"
argument_list|,
literal|"wombats"
argument_list|,
literal|99
argument_list|)
expr_stmt|;
name|LOGEQ
argument_list|(
name|EVENT_LOG_WARN
argument_list|,
literal|"Far too many wombats (99)"
argument_list|)
expr_stmt|;
name|RESET
argument_list|()
expr_stmt|;
name|event_msgx
argument_list|(
literal|"Connecting lime to coconut"
argument_list|)
expr_stmt|;
name|LOGEQ
argument_list|(
name|EVENT_LOG_MSG
argument_list|,
literal|"Connecting lime to coconut"
argument_list|)
expr_stmt|;
name|RESET
argument_list|()
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"A millisecond passed! We should log that!"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DEBUG
name|LOGEQ
argument_list|(
name|EVENT_LOG_DEBUG
argument_list|,
literal|"A millisecond passed! We should log that!"
argument_list|)
expr_stmt|;
else|#
directive|else
name|tt_int_op
argument_list|(
name|logsev
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|logmsg
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RESET
argument_list|()
expr_stmt|;
comment|/* Try with an errno. */
name|errno
operator|=
name|ENOENT
expr_stmt|;
name|event_warn
argument_list|(
literal|"Couldn't open %s"
argument_list|,
literal|"/bad/file"
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Couldn't open /bad/file: %s"
argument_list|,
name|strerror
argument_list|(
name|ENOENT
argument_list|)
argument_list|)
expr_stmt|;
name|LOGEQ
argument_list|(
name|EVENT_LOG_WARN
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|RESET
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CAN_CHECK_ERR
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Couldn't open /very/bad/file: %s"
argument_list|,
name|strerror
argument_list|(
name|ENOENT
argument_list|)
argument_list|)
expr_stmt|;
name|check_error_logging
argument_list|(
name|err_fn
argument_list|,
literal|5
argument_list|,
name|EVENT_LOG_ERR
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|RESET
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Try with a socket errno. */
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Unhappy socket: %s"
argument_list|,
name|evutil_socket_error_to_string
argument_list|(
name|WSAEWOULDBLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|EVUTIL_SET_SOCKET_ERROR
argument_list|(
name|WSAEWOULDBLOCK
argument_list|)
expr_stmt|;
else|#
directive|else
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Unhappy socket: %s"
argument_list|,
name|strerror
argument_list|(
name|EAGAIN
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EAGAIN
expr_stmt|;
endif|#
directive|endif
name|event_sock_warn
argument_list|(
name|fd
argument_list|,
literal|"Unhappy socket"
argument_list|)
expr_stmt|;
name|LOGEQ
argument_list|(
name|EVENT_LOG_WARN
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|RESET
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CAN_CHECK_ERR
name|check_error_logging
argument_list|(
name|sock_err_fn
argument_list|,
literal|20
argument_list|,
name|EVENT_LOG_ERR
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|RESET
argument_list|()
expr_stmt|;
endif|#
directive|endif
undef|#
directive|undef
name|RESET
undef|#
directive|undef
name|LOGEQ
name|end
label|:
if|if
condition|(
name|logmsg
condition|)
name|free
argument_list|(
name|logmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_strlcpy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
comment|/* Successful case. */
name|tt_int_op
argument_list|(
literal|5
argument_list|,
operator|==
argument_list|,
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"Hello"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|buf
argument_list|,
operator|==
argument_list|,
literal|"Hello"
argument_list|)
expr_stmt|;
comment|/* Overflow by a lot. */
name|tt_int_op
argument_list|(
literal|13
argument_list|,
operator|==
argument_list|,
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"pentasyllabic"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|buf
argument_list|,
operator|==
argument_list|,
literal|"pentasy"
argument_list|)
expr_stmt|;
comment|/* Overflow by exactly one. */
name|tt_int_op
argument_list|(
literal|8
argument_list|,
operator|==
argument_list|,
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"overlong"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|buf
argument_list|,
operator|==
argument_list|,
literal|"overlon"
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_struct
struct|struct
name|example_struct
block|{
specifier|const
name|char
modifier|*
name|a
decl_stmt|;
specifier|const
name|char
modifier|*
name|b
decl_stmt|;
name|long
name|c
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|test_evutil_upcast
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|example_struct
name|es1
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
name|es1
operator|.
name|a
operator|=
literal|"World"
expr_stmt|;
name|es1
operator|.
name|b
operator|=
literal|"Hello"
expr_stmt|;
name|es1
operator|.
name|c
operator|=
operator|-
literal|99
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_offsetof
argument_list|(
expr|struct
name|example_struct
argument_list|,
name|b
argument_list|)
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|es1
operator|.
name|b
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|EVUTIL_UPCAST
argument_list|(
name|cp
argument_list|,
expr|struct
name|example_struct
argument_list|,
name|b
argument_list|)
argument_list|,
operator|==
argument_list|,
operator|&
name|es1
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_integers
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ev_int64_t
name|i64
decl_stmt|;
name|ev_uint64_t
name|u64
decl_stmt|;
name|ev_int32_t
name|i32
decl_stmt|;
name|ev_uint32_t
name|u32
decl_stmt|;
name|ev_int16_t
name|i16
decl_stmt|;
name|ev_uint16_t
name|u16
decl_stmt|;
name|ev_int8_t
name|i8
decl_stmt|;
name|ev_uint8_t
name|u8
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|ev_intptr_t
name|iptr
decl_stmt|;
name|ev_uintptr_t
name|uptr
decl_stmt|;
name|ev_ssize_t
name|ssize
decl_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|i64
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|i32
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|i16
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|i8
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|ev_ssize_t
argument_list|)
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|ev_intptr_t
argument_list|)
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
sizeof|sizeof
argument_list|(
name|ev_uintptr_t
argument_list|)
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|intptr_t
argument_list|)
argument_list|)
expr_stmt|;
name|u64
operator|=
literal|1000000000
expr_stmt|;
name|u64
operator|*=
literal|1000000000
expr_stmt|;
name|tt_assert
argument_list|(
name|u64
operator|/
literal|1000000000
operator|==
literal|1000000000
argument_list|)
expr_stmt|;
name|i64
operator|=
operator|-
literal|1000000000
expr_stmt|;
name|i64
operator|*=
literal|1000000000
expr_stmt|;
name|tt_assert
argument_list|(
name|i64
operator|/
literal|1000000000
operator|==
operator|-
literal|1000000000
argument_list|)
expr_stmt|;
name|u64
operator|=
name|EV_UINT64_MAX
expr_stmt|;
name|i64
operator|=
name|EV_INT64_MAX
expr_stmt|;
name|tt_assert
argument_list|(
name|u64
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i64
operator|>
literal|0
argument_list|)
expr_stmt|;
name|u64
operator|++
expr_stmt|;
name|i64
operator|++
expr_stmt|;
name|tt_assert
argument_list|(
name|u64
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i64
operator|==
name|EV_INT64_MIN
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i64
operator|<
literal|0
argument_list|)
expr_stmt|;
name|u32
operator|=
name|EV_UINT32_MAX
expr_stmt|;
name|i32
operator|=
name|EV_INT32_MAX
expr_stmt|;
name|tt_assert
argument_list|(
name|u32
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i32
operator|>
literal|0
argument_list|)
expr_stmt|;
name|u32
operator|++
expr_stmt|;
name|i32
operator|++
expr_stmt|;
name|tt_assert
argument_list|(
name|u32
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i32
operator|==
name|EV_INT32_MIN
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i32
operator|<
literal|0
argument_list|)
expr_stmt|;
name|u16
operator|=
name|EV_UINT16_MAX
expr_stmt|;
name|i16
operator|=
name|EV_INT16_MAX
expr_stmt|;
name|tt_assert
argument_list|(
name|u16
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i16
operator|>
literal|0
argument_list|)
expr_stmt|;
name|u16
operator|++
expr_stmt|;
name|i16
operator|++
expr_stmt|;
name|tt_assert
argument_list|(
name|u16
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i16
operator|==
name|EV_INT16_MIN
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i16
operator|<
literal|0
argument_list|)
expr_stmt|;
name|u8
operator|=
name|EV_UINT8_MAX
expr_stmt|;
name|i8
operator|=
name|EV_INT8_MAX
expr_stmt|;
name|tt_assert
argument_list|(
name|u8
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i8
operator|>
literal|0
argument_list|)
expr_stmt|;
name|u8
operator|++
expr_stmt|;
name|i8
operator|++
expr_stmt|;
name|tt_assert
argument_list|(
name|u8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i8
operator|==
name|EV_INT8_MIN
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|i8
operator|<
literal|0
argument_list|)
expr_stmt|;
name|ssize
operator|=
name|EV_SSIZE_MAX
expr_stmt|;
name|tt_assert
argument_list|(
name|ssize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ssize
operator|++
expr_stmt|;
name|tt_assert
argument_list|(
name|ssize
operator|<
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ssize
operator|==
name|EV_SSIZE_MIN
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|&
name|ssize
expr_stmt|;
name|iptr
operator|=
operator|(
name|ev_intptr_t
operator|)
name|ptr
expr_stmt|;
name|uptr
operator|=
operator|(
name|ev_uintptr_t
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|iptr
expr_stmt|;
name|tt_assert
argument_list|(
name|ptr
operator|==
operator|&
name|ssize
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|uptr
expr_stmt|;
name|tt_assert
argument_list|(
name|ptr
operator|==
operator|&
name|ssize
argument_list|)
expr_stmt|;
name|iptr
operator|=
operator|-
literal|1
expr_stmt|;
name|tt_assert
argument_list|(
name|iptr
operator|<
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
name|struct
name|evutil_addrinfo
modifier|*
name|ai_find_by_family
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
name|ai
parameter_list|,
name|int
name|family
parameter_list|)
block|{
while|while
condition|(
name|ai
condition|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|==
name|family
condition|)
return|return
name|ai
return|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|evutil_addrinfo
modifier|*
name|ai_find_by_protocol
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
name|ai
parameter_list|,
name|int
name|protocol
parameter_list|)
block|{
while|while
condition|(
name|ai
condition|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_protocol
operator|==
name|protocol
condition|)
return|return
name|ai
return|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|test_ai_eq_
parameter_list|(
specifier|const
name|struct
name|evutil_addrinfo
modifier|*
name|ai
parameter_list|,
specifier|const
name|char
modifier|*
name|sockaddr_port
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|protocol
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|int
name|slen
init|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
decl_stmt|;
name|int
name|gotport
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|socktype
operator|>
literal|0
condition|)
name|tt_int_op
argument_list|(
name|ai
operator|->
name|ai_socktype
argument_list|,
operator|==
argument_list|,
name|socktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|>
literal|0
condition|)
name|tt_int_op
argument_list|(
name|ai
operator|->
name|ai_protocol
argument_list|,
operator|==
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|evutil_parse_sockaddr_port
argument_list|(
name|sockaddr_port
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|slen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Couldn't parse expected address %s on line %d"
operator|,
name|sockaddr_port
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|!=
name|ss
operator|.
name|ss_family
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Address family %d did not match %d on line %d"
operator|,
name|ai
operator|->
name|ai_family
operator|,
name|ss
operator|.
name|ss_family
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ai
operator|->
name|ai_addr
decl_stmt|;
name|evutil_inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|gotport
operator|=
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_addrlen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Addr size mismatch on line %d"
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ai
operator|->
name|ai_addr
decl_stmt|;
name|evutil_inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|gotport
operator|=
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_addrlen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Addr size mismatch on line %d"
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|evutil_sockaddr_cmp
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|TT_FAIL
argument_list|(
operator|(
literal|"Wanted %s, got %s:%d on line %d"
operator|,
name|sockaddr_port
operator|,
name|buf
operator|,
name|gotport
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"Wanted %s, got %s:%d on line %d"
operator|,
name|sockaddr_port
operator|,
name|buf
operator|,
name|gotport
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|end
label|:
name|TT_FAIL
argument_list|(
operator|(
literal|"Test failed on line %d"
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_rand
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|buf1
index|[
literal|32
index|]
decl_stmt|;
name|char
name|buf2
index|[
literal|32
index|]
decl_stmt|;
name|int
name|counts
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|struct
name|evutil_weakrand_state
name|seed
init|=
block|{
literal|12346789U
block|}
decl_stmt|;
name|memset
argument_list|(
name|buf2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|counts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|counts
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|32
condition|;
operator|++
name|k
control|)
block|{
comment|/* Try a few different start and end points; try to catch 		 * the various misaligned cases of arc4random_buf */
name|int
name|startpoint
init|=
name|evutil_weakrand_
argument_list|(
operator|&
name|seed
argument_list|)
operator|%
literal|4
decl_stmt|;
name|int
name|endpoint
init|=
literal|32
operator|-
operator|(
name|evutil_weakrand_
argument_list|(
operator|&
name|seed
argument_list|)
operator|%
literal|4
operator|)
decl_stmt|;
name|memset
argument_list|(
name|buf2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do 6 runs over buf1, or-ing the result into buf2 each 		 * time, to make sure we're setting each byte that we mean 		 * to set. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|memset
argument_list|(
name|buf1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|evutil_secure_rng_get_bytes
argument_list|(
name|buf1
operator|+
name|startpoint
argument_list|,
name|endpoint
operator|-
name|startpoint
argument_list|)
expr_stmt|;
name|n
operator|+=
name|endpoint
operator|-
name|startpoint
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|startpoint
operator|&&
name|j
operator|<
name|endpoint
condition|)
block|{
name|buf2
index|[
name|j
index|]
operator||=
name|buf1
index|[
name|j
index|]
expr_stmt|;
operator|++
name|counts
index|[
operator|(
name|unsigned
name|char
operator|)
name|buf1
index|[
name|j
index|]
index|]
expr_stmt|;
block|}
else|else
block|{
name|tt_assert
argument_list|(
name|buf1
index|[
name|j
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|buf1
index|[
name|j
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* This will give a false positive with P=(256**8)==(2**64) 		 * for each character. */
for|for
control|(
name|j
operator|=
name|startpoint
init|;
name|j
operator|<
name|endpoint
condition|;
operator|++
name|j
control|)
block|{
name|tt_int_op
argument_list|(
name|buf2
index|[
name|j
index|]
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|evutil_weakrand_seed_
argument_list|(
operator|&
name|seed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
operator|++
name|i
control|)
block|{
name|ev_int32_t
name|r
init|=
name|evutil_weakrand_range_
argument_list|(
operator|&
name|seed
argument_list|,
literal|9999
argument_list|)
decl_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|<=
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|<
argument_list|,
literal|9999
argument_list|)
expr_stmt|;
block|}
comment|/* for (i=0;i<256;++i) { printf("%3d %2d\n", i, counts[i]); } */
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_getaddrinfo
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|ai
init|=
name|NULL
decl_stmt|,
modifier|*
name|a
decl_stmt|;
name|struct
name|evutil_addrinfo
name|hints
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Try using it as a pton. */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
literal|"1.2.3.4"
argument_list|,
literal|"8080"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ai
operator|->
name|ai_next
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* no ambiguity */
name|test_ai_eq
argument_list|(
name|ai
argument_list|,
literal|"1.2.3.4:8080"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
literal|"1001:b0b::f00f"
argument_list|,
literal|"4321"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ai
operator|->
name|ai_next
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* no ambiguity */
name|test_ai_eq
argument_list|(
name|ai
argument_list|,
literal|"[1001:b0b::f00f]:4321"
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* Try out the behavior of nodename=NULL */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|EVUTIL_AI_PASSIVE
expr_stmt|;
comment|/* as if for bind */
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
name|NULL
argument_list|,
literal|"9999"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ai
operator|->
name|ai_next
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|ai
argument_list|,
literal|"0.0.0.0:9999"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
literal|0
expr_stmt|;
comment|/* as if for connect */
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
name|NULL
argument_list|,
literal|"9998"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|ai
argument_list|,
literal|"127.0.0.1:9998"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ai
operator|->
name|ai_next
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
literal|0
expr_stmt|;
comment|/* as if for connect */
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
name|NULL
argument_list|,
literal|"9997"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ai
operator|->
name|ai_next
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|ai
argument_list|,
literal|"[::1]:9997"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|EVUTIL_AI_PASSIVE
expr_stmt|;
comment|/* as if for bind. */
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
name|NULL
argument_list|,
literal|"9996"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ai
operator|->
name|ai_next
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|ai
argument_list|,
literal|"[::]:9996"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* Now try an unspec one. We should get a v6 and a v4. */
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
name|NULL
argument_list|,
literal|"9996"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|ai
argument_list|,
name|PF_INET6
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"[::]:9996"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|a
operator|=
name|ai_find_by_family
argument_list|(
name|ai
argument_list|,
name|PF_INET
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"0.0.0.0:9996"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* Try out AI_NUMERICHOST: successful case.  Also try 	 * multiprotocol. */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|EVUTIL_AI_NUMERICHOST
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
literal|"1.2.3.4"
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|a
operator|=
name|ai_find_by_protocol
argument_list|(
name|ai
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"1.2.3.4"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|a
operator|=
name|ai_find_by_protocol
argument_list|(
name|ai
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|a
argument_list|,
literal|"1.2.3.4"
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* Try the failing case of AI_NUMERICHOST */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|EVUTIL_AI_NUMERICHOST
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
literal|"www.google.com"
argument_list|,
literal|"80"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
name|EVUTIL_EAI_NONAME
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ai
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Try symbolic service names wit AI_NUMERICSERV */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|EVUTIL_AI_NUMERICSERV
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
literal|"1.2.3.4"
argument_list|,
literal|"http"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
name|EVUTIL_EAI_NONAME
argument_list|)
expr_stmt|;
comment|/* Try symbolic service names */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
literal|"1.2.3.4"
argument_list|,
literal|"http"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|TT_DECLARE
argument_list|(
literal|"SKIP"
argument_list|,
operator|(
literal|"Symbolic service names seem broken."
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_assert
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|test_ai_eq
argument_list|(
name|ai
argument_list|,
literal|"1.2.3.4:80"
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|ai
condition|)
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_getaddrinfo_live
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
name|struct
name|evutil_addrinfo
name|hints
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Now do some actual lookups. */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
literal|"www.google.com"
argument_list|,
literal|"80"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|TT_DECLARE
argument_list|(
literal|"SKIP"
argument_list|,
operator|(
literal|"Couldn't resolve www.google.com"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_assert
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
operator|==
argument_list|,
name|PF_INET
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ai
operator|->
name|ai_protocol
argument_list|,
operator|==
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ai
operator|->
name|ai_socktype
argument_list|,
operator|==
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ai
operator|->
name|ai_addrlen
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ai
operator|->
name|ai_addr
expr_stmt|;
name|tt_int_op
argument_list|(
name|sin
operator|->
name|sin_family
argument_list|,
operator|==
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|,
operator|==
argument_list|,
name|htons
argument_list|(
literal|80
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
operator|!=
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evutil_inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"www.google.com resolved to %s"
operator|,
name|cp
condition|?
name|cp
else|:
literal|"<unwriteable>"
operator|)
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
block|}
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
name|r
operator|=
name|evutil_getaddrinfo
argument_list|(
literal|"ipv6.google.com"
argument_list|,
literal|"80"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"Couldn't do an ipv6 lookup for ipv6.google.com"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_assert
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
operator|==
argument_list|,
name|PF_INET6
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ai
operator|->
name|ai_addrlen
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ai
operator|->
name|ai_addr
expr_stmt|;
name|tt_int_op
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|,
operator|==
argument_list|,
name|htons
argument_list|(
literal|80
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evutil_inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"ipv6.google.com resolved to %s"
operator|,
name|cp
condition|?
name|cp
else|:
literal|"<unwriteable>"
operator|)
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|ai
condition|)
name|evutil_freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
specifier|static
name|void
name|test_evutil_loadsyslib
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|HANDLE
name|h
init|=
name|NULL
decl_stmt|;
name|h
operator|=
name|evutil_load_windows_system_library_
argument_list|(
name|TEXT
argument_list|(
literal|"kernel32.dll"
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|h
condition|)
name|CloseHandle
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** Test mm_malloc(). */
end_comment

begin_function
specifier|static
name|void
name|test_event_malloc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|arg
expr_stmt|;
comment|/* mm_malloc(0) should simply return NULL. */
ifndef|#
directive|ifndef
name|EVENT__DISABLE_MM_REPLACEMENT
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mm_malloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|errno
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Trivial case. */
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mm_malloc
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|errno
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
label|:
name|errno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_calloc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|arg
expr_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_MM_REPLACEMENT
comment|/* mm_calloc() should simply return NULL 	 * if either argument is zero. */
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mm_calloc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|errno
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mm_calloc
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|errno
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|errno
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Trivial case. */
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mm_calloc
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|errno
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* mm_calloc() should set errno = ENOMEM and return NULL 	 * in case of potential overflow. */
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mm_calloc
argument_list|(
name|EV_SIZE_MAX
operator|/
literal|2
argument_list|,
name|EV_SIZE_MAX
operator|/
literal|2
operator|+
literal|8
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|errno
argument_list|,
operator|==
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|end
label|:
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|mm_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_strdup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|arg
expr_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_MM_REPLACEMENT
comment|/* mm_strdup(NULL) should set errno = EINVAL and return NULL. */
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mm_strdup
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|errno
argument_list|,
operator|==
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Trivial cases. */
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mm_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|errno
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|p
argument_list|,
operator|==
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mm_strdup
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|errno
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|p
argument_list|,
operator|==
argument_list|,
literal|"foo"
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* XXX 	 * mm_strdup(str) where str is a string of length EV_SIZE_MAX 	 * should set errno = ENOMEM and return NULL. */
name|end
label|:
name|errno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_usleep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|timeval
name|tv1
decl_stmt|,
name|tv2
decl_stmt|,
name|tv3
decl_stmt|,
name|diff1
decl_stmt|,
name|diff2
decl_stmt|;
specifier|const
name|struct
name|timeval
name|quarter_sec
init|=
block|{
literal|0
block|,
literal|250
operator|*
literal|1000
block|}
decl_stmt|;
specifier|const
name|struct
name|timeval
name|tenth_sec
init|=
block|{
literal|0
block|,
literal|100
operator|*
literal|1000
block|}
decl_stmt|;
name|long
name|usec1
decl_stmt|,
name|usec2
decl_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|tv1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evutil_usleep_
argument_list|(
operator|&
name|quarter_sec
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|tv2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evutil_usleep_
argument_list|(
operator|&
name|tenth_sec
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|tv3
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evutil_timersub
argument_list|(
operator|&
name|tv2
argument_list|,
operator|&
name|tv1
argument_list|,
operator|&
name|diff1
argument_list|)
expr_stmt|;
name|evutil_timersub
argument_list|(
operator|&
name|tv3
argument_list|,
operator|&
name|tv2
argument_list|,
operator|&
name|diff2
argument_list|)
expr_stmt|;
name|usec1
operator|=
name|diff1
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|diff1
operator|.
name|tv_usec
expr_stmt|;
name|usec2
operator|=
name|diff2
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|diff2
operator|.
name|tv_usec
expr_stmt|;
name|tt_int_op
argument_list|(
name|usec1
argument_list|,
operator|>
argument_list|,
literal|200000
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|usec1
argument_list|,
operator|<
argument_list|,
literal|300000
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|usec2
argument_list|,
operator|>
argument_list|,
literal|80000
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|usec2
argument_list|,
operator|<
argument_list|,
literal|120000
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_monotonic_res
parameter_list|(
name|void
modifier|*
name|data_
parameter_list|)
block|{
comment|/* Basic santity-test for monotonic timers.  What we'd really like 	 * to do is make sure that they can't go backwards even when the 	 * system clock goes backwards. But we haven't got a good way to 	 * move the system clock backwards. 	 */
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|data_
decl_stmt|;
name|struct
name|evutil_monotonic_timer
name|timer
decl_stmt|;
specifier|const
name|int
name|precise
init|=
name|strstr
argument_list|(
name|data
operator|->
name|setup_data
argument_list|,
literal|"precise"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
specifier|const
name|int
name|fallback
init|=
name|strstr
argument_list|(
name|data
operator|->
name|setup_data
argument_list|,
literal|"fallback"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|tv
index|[
literal|10
index|]
decl_stmt|,
name|delay
decl_stmt|;
name|int
name|total_diff
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|,
name|wantres
decl_stmt|,
name|acceptdiff
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|precise
condition|)
name|flags
operator||=
name|EV_MONOT_PRECISE
expr_stmt|;
if|if
condition|(
name|fallback
condition|)
name|flags
operator||=
name|EV_MONOT_FALLBACK
expr_stmt|;
if|if
condition|(
name|precise
operator|||
name|fallback
condition|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|wantres
operator|=
literal|10
operator|*
literal|1000
expr_stmt|;
name|acceptdiff
operator|=
literal|1000
expr_stmt|;
else|#
directive|else
name|wantres
operator|=
literal|1000
expr_stmt|;
name|acceptdiff
operator|=
literal|300
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|wantres
operator|=
literal|40
operator|*
literal|1000
expr_stmt|;
name|acceptdiff
operator|=
literal|20
operator|*
literal|1000
expr_stmt|;
block|}
name|TT_BLATHER
argument_list|(
operator|(
literal|"Precise = %d"
operator|,
name|precise
operator|)
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Fallback = %d"
operator|,
name|fallback
operator|)
argument_list|)
expr_stmt|;
comment|/* First, make sure we match up with usleep. */
name|delay
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|delay
operator|.
name|tv_usec
operator|=
name|wantres
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_configure_monotonic_time_
argument_list|(
operator|&
name|timer
argument_list|,
name|flags
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
name|evutil_gettime_monotonic_
argument_list|(
operator|&
name|timer
argument_list|,
operator|&
name|tv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|evutil_usleep_
argument_list|(
operator|&
name|delay
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|diff
decl_stmt|;
name|tt_assert
argument_list|(
name|evutil_timercmp
argument_list|(
operator|&
name|tv
index|[
name|i
index|]
argument_list|,
operator|&
name|tv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|<
argument_list|)
argument_list|)
expr_stmt|;
name|evutil_timersub
argument_list|(
operator|&
name|tv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|tv
index|[
name|i
index|]
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|diff
operator|.
name|tv_sec
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|total_diff
operator|+=
name|diff
operator|.
name|tv_usec
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Difference = %d"
operator|,
operator|(
name|int
operator|)
name|diff
operator|.
name|tv_usec
operator|)
argument_list|)
expr_stmt|;
block|}
name|tt_int_op
argument_list|(
name|abs
argument_list|(
name|total_diff
operator|/
literal|9
operator|-
name|wantres
argument_list|)
argument_list|,
operator|<
argument_list|,
name|acceptdiff
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evutil_monotonic_prc
parameter_list|(
name|void
modifier|*
name|data_
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|data_
decl_stmt|;
name|struct
name|evutil_monotonic_timer
name|timer
decl_stmt|;
specifier|const
name|int
name|precise
init|=
name|strstr
argument_list|(
name|data
operator|->
name|setup_data
argument_list|,
literal|"precise"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
specifier|const
name|int
name|fallback
init|=
name|strstr
argument_list|(
name|data
operator|->
name|setup_data
argument_list|,
literal|"fallback"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|tv
index|[
literal|10
index|]
decl_stmt|;
name|int
name|total_diff
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxstep
init|=
literal|25
operator|*
literal|1000
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|precise
condition|)
name|maxstep
operator|=
literal|500
expr_stmt|;
if|if
condition|(
name|precise
condition|)
name|flags
operator||=
name|EV_MONOT_PRECISE
expr_stmt|;
if|if
condition|(
name|fallback
condition|)
name|flags
operator||=
name|EV_MONOT_FALLBACK
expr_stmt|;
name|tt_int_op
argument_list|(
name|evutil_configure_monotonic_time_
argument_list|(
operator|&
name|timer
argument_list|,
name|flags
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* find out what precision we actually see. */
name|evutil_gettime_monotonic_
argument_list|(
operator|&
name|timer
argument_list|,
operator|&
name|tv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
do|do
block|{
name|evutil_gettime_monotonic_
argument_list|(
operator|&
name|timer
argument_list|,
operator|&
name|tv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|evutil_timercmp
argument_list|(
operator|&
name|tv
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|&
name|tv
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|)
condition|)
do|;
block|}
name|total_diff
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|diff
decl_stmt|;
name|tt_assert
argument_list|(
name|evutil_timercmp
argument_list|(
operator|&
name|tv
index|[
name|i
index|]
argument_list|,
operator|&
name|tv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|<
argument_list|)
argument_list|)
expr_stmt|;
name|evutil_timersub
argument_list|(
operator|&
name|tv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|tv
index|[
name|i
index|]
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|diff
operator|.
name|tv_sec
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|total_diff
operator|+=
name|diff
operator|.
name|tv_usec
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Step difference = %d"
operator|,
operator|(
name|int
operator|)
name|diff
operator|.
name|tv_usec
operator|)
argument_list|)
expr_stmt|;
block|}
name|TT_BLATHER
argument_list|(
operator|(
literal|"Average step difference = %d"
operator|,
name|total_diff
operator|/
literal|9
operator|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|total_diff
operator|/
literal|9
argument_list|,
operator|<
argument_list|,
name|maxstep
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|testcase_t
name|util_testcases
index|[]
init|=
block|{
block|{
literal|"ipv4_parse"
block|,
name|regress_ipv4_parse
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"ipv6_parse"
block|,
name|regress_ipv6_parse
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"sockaddr_port_parse"
block|,
name|regress_sockaddr_port_parse
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"sockaddr_port_format"
block|,
name|regress_sockaddr_port_format
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"sockaddr_predicates"
block|,
name|test_evutil_sockaddr_predicates
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"evutil_snprintf"
block|,
name|test_evutil_snprintf
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"evutil_strtoll"
block|,
name|test_evutil_strtoll
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"evutil_casecmp"
block|,
name|test_evutil_casecmp
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"evutil_rtrim"
block|,
name|test_evutil_rtrim
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"strlcpy"
block|,
name|test_evutil_strlcpy
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"log"
block|,
name|test_evutil_log
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"upcast"
block|,
name|test_evutil_upcast
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"integers"
block|,
name|test_evutil_integers
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"rand"
block|,
name|test_evutil_rand
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"getaddrinfo"
block|,
name|test_evutil_getaddrinfo
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"getaddrinfo_live"
block|,
name|test_evutil_getaddrinfo_live
block|,
name|TT_FORK
operator||
name|TT_OFF_BY_DEFAULT
block|,
name|NULL
block|,
name|NULL
block|}
block|,
ifdef|#
directive|ifdef
name|_WIN32
block|{
literal|"loadsyslib"
block|,
name|test_evutil_loadsyslib
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
block|{
literal|"mm_malloc"
block|,
name|test_event_malloc
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"mm_calloc"
block|,
name|test_event_calloc
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"mm_strdup"
block|,
name|test_event_strdup
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"usleep"
block|,
name|test_evutil_usleep
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"monotonic_res"
block|,
name|test_evutil_monotonic_res
block|,
literal|0
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|""
block|}
block|,
block|{
literal|"monotonic_res_precise"
block|,
name|test_evutil_monotonic_res
block|,
name|TT_OFF_BY_DEFAULT
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"precise"
block|}
block|,
block|{
literal|"monotonic_res_fallback"
block|,
name|test_evutil_monotonic_res
block|,
name|TT_OFF_BY_DEFAULT
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"fallback"
block|}
block|,
block|{
literal|"monotonic_prc"
block|,
name|test_evutil_monotonic_prc
block|,
literal|0
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|""
block|}
block|,
block|{
literal|"monotonic_prc_precise"
block|,
name|test_evutil_monotonic_prc
block|,
literal|0
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"precise"
block|}
block|,
block|{
literal|"monotonic_prc_fallback"
block|,
name|test_evutil_monotonic_prc
block|,
literal|0
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"fallback"
block|}
block|,
name|END_OF_TESTCASES
block|, }
decl_stmt|;
end_decl_stmt

end_unit

