begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|// Get rid of OSX 10.7 and greater deprecation warnings.
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__clang__
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|clang
name|diagnostic
name|ignored
literal|"-Wdeprecated-declarations"
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent_ssl.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/listener.h"
end_include

begin_include
include|#
directive|include
file|"regress.h"
end_include

begin_include
include|#
directive|include
file|"tinytest.h"
end_include

begin_include
include|#
directive|include
file|"tinytest_macros.h"
end_include

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* A short pre-generated key, to save the cost of doing an RSA key generation  * step during the unit tests.  It's only 512 bits long, and it is published  * in this file, so you would have to be very foolish to consider using it in  * your own code. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|KEY
index|[]
init|=
literal|"-----BEGIN RSA PRIVATE KEY-----\n"
literal|"MIIBOgIBAAJBAKibTEzXjj+sqpipePX1lEk5BNFuL/dDBbw8QCXgaJWikOiKHeJq\n"
literal|"3FQ0OmCnmpkdsPFE4x3ojYmmdgE2i0dJwq0CAwEAAQJAZ08gpUS+qE1IClps/2gG\n"
literal|"AAer6Bc31K2AaiIQvCSQcH440cp062QtWMC3V5sEoWmdLsbAHFH26/9ZHn5zAflp\n"
literal|"gQIhANWOx/UYeR8HD0WREU5kcuSzgzNLwUErHLzxP7U6aojpAiEAyh2H35CjN/P7\n"
literal|"NhcZ4QYw3PeUWpqgJnaE/4i80BSYkSUCIQDLHFhLYLJZ80HwHTADif/ISn9/Ow6b\n"
literal|"p6BWh3DbMar/eQIgBPS6azH5vpp983KXkNv9AL4VZi9ac/b+BeINdzC6GP0CIDmB\n"
literal|"U6GFEQTZ3IfuiVabG5pummdC4DNbcdI+WKrSFNmQ\n"
literal|"-----END RSA PRIVATE KEY-----\n"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|getkey
parameter_list|(
name|void
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|key
decl_stmt|;
name|BIO
modifier|*
name|bio
decl_stmt|;
comment|/* new read-only BIO backed by KEY. */
name|bio
operator|=
name|BIO_new_mem_buf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|KEY
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|bio
argument_list|)
expr_stmt|;
name|key
operator|=
name|PEM_read_bio_PrivateKey
argument_list|(
name|bio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|key
return|;
name|end
label|:
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|X509
modifier|*
name|getcert
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Dummy code to make a quick-and-dirty valid certificate with 	   OpenSSL.  Don't copy this code into your own program! It does a 	   number of things in a stupid and insecure way. */
name|X509
modifier|*
name|x509
init|=
name|NULL
decl_stmt|;
name|X509_NAME
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|EVP_PKEY
modifier|*
name|key
init|=
name|getkey
argument_list|()
decl_stmt|;
name|int
name|nid
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|tt_assert
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|x509
operator|=
name|X509_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
literal|0
operator|!=
name|X509_set_version
argument_list|(
name|x509
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
literal|0
operator|!=
name|ASN1_INTEGER_set
argument_list|(
name|X509_get_serialNumber
argument_list|(
name|x509
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|X509_NAME_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|nid
operator|=
name|OBJ_txt2nid
argument_list|(
literal|"commonName"
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|NID_undef
operator|!=
name|nid
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
literal|0
operator|!=
name|X509_NAME_add_entry_by_NID
argument_list|(
name|name
argument_list|,
name|nid
argument_list|,
name|MBSTRING_ASC
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"example.com"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|X509_set_subject_name
argument_list|(
name|x509
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|X509_set_issuer_name
argument_list|(
name|x509
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|X509_time_adj
argument_list|(
name|X509_get_notBefore
argument_list|(
name|x509
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|now
operator|+=
literal|3600
expr_stmt|;
name|X509_time_adj
argument_list|(
name|X509_get_notAfter
argument_list|(
name|x509
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|X509_set_pubkey
argument_list|(
name|x509
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
literal|0
operator|!=
name|X509_sign
argument_list|(
name|x509
argument_list|,
name|key
argument_list|,
name|EVP_sha1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x509
return|;
name|end
label|:
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|disable_tls_11_and_12
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SSL_CTX
modifier|*
name|the_ssl_ctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|SSL_CTX
modifier|*
name|get_ssl_ctx
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|the_ssl_ctx
condition|)
return|return
name|the_ssl_ctx
return|;
name|the_ssl_ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|SSLv23_method
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|the_ssl_ctx
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|disable_tls_11_and_12
condition|)
block|{
ifdef|#
directive|ifdef
name|SSL_OP_NO_TLSv1_2
name|SSL_CTX_set_options
argument_list|(
name|the_ssl_ctx
argument_list|,
name|SSL_OP_NO_TLSv1_2
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SSL_OP_NO_TLSv1_1
name|SSL_CTX_set_options
argument_list|(
name|the_ssl_ctx
argument_list|,
name|SSL_OP_NO_TLSv1_1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|the_ssl_ctx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_ssl
parameter_list|(
name|void
parameter_list|)
block|{
name|SSL_library_init
argument_list|()
expr_stmt|;
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
if|if
condition|(
name|SSLeay
argument_list|()
operator|!=
name|OPENSSL_VERSION_NUMBER
condition|)
block|{
name|TT_DECLARE
argument_list|(
literal|"WARN"
argument_list|,
operator|(
literal|"Version mismatch for openssl: compiled with %lx but running with %lx"
operator|,
operator|(
name|unsigned
name|long
operator|)
name|OPENSSL_VERSION_NUMBER
operator|,
operator|(
name|unsigned
name|long
operator|)
name|SSLeay
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ====================    Here's a simple test: we read a number from the input, increment it, and    reply, until we get to 1001. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|test_is_done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_connected
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|got_close
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|got_error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|renegotiate_at
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stop_when_connected
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pending_connect_events
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|event_base
modifier|*
name|exit_base
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|respond_to_number
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|b
init|=
name|bufferevent_get_input
argument_list|(
name|bev
argument_list|)
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|n
decl_stmt|;
name|line
operator|=
name|evbuffer_readln
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|line
condition|)
return|return;
name|n
operator|=
name|atoi
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|TT_FAIL
argument_list|(
operator|(
literal|"Bad number: %s"
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"The number was %d"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1001
condition|)
block|{
operator|++
name|test_is_done
expr_stmt|;
name|bufferevent_free
argument_list|(
name|bev
argument_list|)
expr_stmt|;
comment|/* Should trigger close on other side. */
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
argument_list|,
literal|"client"
argument_list|)
operator|&&
name|n
operator|==
name|renegotiate_at
condition|)
block|{
name|SSL_renegotiate
argument_list|(
name|bufferevent_openssl_get_ssl
argument_list|(
name|bev
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|bufferevent_get_output
argument_list|(
name|bev
argument_list|)
argument_list|,
literal|"%d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Done reading; now writing."
operator|)
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|bev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|bufferevent_disable
argument_list|(
name|bev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|done_writing_cb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|b
init|=
name|bufferevent_get_output
argument_list|(
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|b
argument_list|)
condition|)
return|return;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Done writing."
operator|)
argument_list|)
expr_stmt|;
name|bufferevent_disable
argument_list|(
name|bev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|bev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eventcb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"Got event %d"
operator|,
operator|(
name|int
operator|)
name|what
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|&
name|BEV_EVENT_CONNECTED
condition|)
block|{
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|X509
modifier|*
name|peer_cert
decl_stmt|;
operator|++
name|n_connected
expr_stmt|;
name|ssl
operator|=
name|bufferevent_openssl_get_ssl
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|peer_cert
operator|=
name|SSL_get_peer_certificate
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|ctx
argument_list|,
literal|"server"
argument_list|)
condition|)
block|{
name|tt_assert
argument_list|(
name|peer_cert
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_assert
argument_list|(
name|peer_cert
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stop_when_connected
condition|)
block|{
if|if
condition|(
operator|--
name|pending_connect_events
operator|==
literal|0
condition|)
name|event_base_loopexit
argument_list|(
name|exit_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|BEV_EVENT_EOF
condition|)
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"Got a good EOF"
operator|)
argument_list|)
expr_stmt|;
operator|++
name|got_close
expr_stmt|;
name|bufferevent_free
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|BEV_EVENT_ERROR
condition|)
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"Got an error."
operator|)
argument_list|)
expr_stmt|;
operator|++
name|got_error
expr_stmt|;
name|bufferevent_free
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|open_ssl_bufevs
parameter_list|(
name|struct
name|bufferevent
modifier|*
modifier|*
name|bev1_out
parameter_list|,
name|struct
name|bufferevent
modifier|*
modifier|*
name|bev2_out
parameter_list|,
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|is_open
parameter_list|,
name|int
name|flags
parameter_list|,
name|SSL
modifier|*
name|ssl1
parameter_list|,
name|SSL
modifier|*
name|ssl2
parameter_list|,
name|evutil_socket_t
modifier|*
name|fd_pair
parameter_list|,
name|struct
name|bufferevent
modifier|*
modifier|*
name|underlying_pair
parameter_list|)
block|{
name|int
name|state1
init|=
name|is_open
condition|?
name|BUFFEREVENT_SSL_OPEN
else|:
name|BUFFEREVENT_SSL_CONNECTING
decl_stmt|;
name|int
name|state2
init|=
name|is_open
condition|?
name|BUFFEREVENT_SSL_OPEN
else|:
name|BUFFEREVENT_SSL_ACCEPTING
decl_stmt|;
if|if
condition|(
name|fd_pair
condition|)
block|{
operator|*
name|bev1_out
operator|=
name|bufferevent_openssl_socket_new
argument_list|(
name|base
argument_list|,
name|fd_pair
index|[
literal|0
index|]
argument_list|,
name|ssl1
argument_list|,
name|state1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|bev2_out
operator|=
name|bufferevent_openssl_socket_new
argument_list|(
name|base
argument_list|,
name|fd_pair
index|[
literal|1
index|]
argument_list|,
name|ssl2
argument_list|,
name|state2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bev1_out
operator|=
name|bufferevent_openssl_filter_new
argument_list|(
name|base
argument_list|,
name|underlying_pair
index|[
literal|0
index|]
argument_list|,
name|ssl1
argument_list|,
name|state1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|bev2_out
operator|=
name|bufferevent_openssl_filter_new
argument_list|(
name|base
argument_list|,
name|underlying_pair
index|[
literal|1
index|]
argument_list|,
name|ssl2
argument_list|,
name|state2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|bufferevent_setcb
argument_list|(
operator|*
name|bev1_out
argument_list|,
name|respond_to_number
argument_list|,
name|done_writing_cb
argument_list|,
name|eventcb
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|"client"
argument_list|)
expr_stmt|;
name|bufferevent_setcb
argument_list|(
operator|*
name|bev2_out
argument_list|,
name|respond_to_number
argument_list|,
name|done_writing_cb
argument_list|,
name|eventcb
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|"server"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|regress_bufferevent_openssl
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev1
decl_stmt|,
modifier|*
name|bev2
decl_stmt|;
name|SSL
modifier|*
name|ssl1
decl_stmt|,
modifier|*
name|ssl2
decl_stmt|;
name|X509
modifier|*
name|cert
init|=
name|getcert
argument_list|()
decl_stmt|;
name|EVP_PKEY
modifier|*
name|key
init|=
name|getkey
argument_list|()
decl_stmt|;
specifier|const
name|int
name|start_open
init|=
name|strstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
operator|->
name|setup_data
argument_list|,
literal|"open"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
specifier|const
name|int
name|filter
init|=
name|strstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
operator|->
name|setup_data
argument_list|,
literal|"filter"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|int
name|flags
init|=
name|BEV_OPT_DEFER_CALLBACKS
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev_ll
index|[
literal|2
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|evutil_socket_t
modifier|*
name|fd_pair
init|=
name|NULL
decl_stmt|;
name|tt_assert
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|init_ssl
argument_list|()
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
operator|->
name|setup_data
argument_list|,
literal|"renegotiate"
argument_list|)
condition|)
block|{
if|if
condition|(
name|SSLeay
argument_list|()
operator|>=
literal|0x10001000
operator|&&
name|SSLeay
argument_list|()
operator|<
literal|0x1000104f
condition|)
block|{
comment|/* 1.0.1 up to 1.0.1c has a bug where TLS1.1 and 1.2 			 * can't renegotiate with themselves. Disable. */
name|disable_tls_11_and_12
operator|=
literal|1
expr_stmt|;
block|}
name|renegotiate_at
operator|=
literal|600
expr_stmt|;
block|}
name|ssl1
operator|=
name|SSL_new
argument_list|(
name|get_ssl_ctx
argument_list|()
argument_list|)
expr_stmt|;
name|ssl2
operator|=
name|SSL_new
argument_list|(
name|get_ssl_ctx
argument_list|()
argument_list|)
expr_stmt|;
name|SSL_use_certificate
argument_list|(
name|ssl2
argument_list|,
name|cert
argument_list|)
expr_stmt|;
name|SSL_use_PrivateKey
argument_list|(
name|ssl2
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start_open
condition|)
name|flags
operator||=
name|BEV_OPT_CLOSE_ON_FREE
expr_stmt|;
if|if
condition|(
operator|!
name|filter
condition|)
block|{
name|tt_assert
argument_list|(
name|strstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
operator|->
name|setup_data
argument_list|,
literal|"socketpair"
argument_list|)
argument_list|)
expr_stmt|;
name|fd_pair
operator|=
name|data
operator|->
name|pair
expr_stmt|;
block|}
else|else
block|{
name|bev_ll
index|[
literal|0
index|]
operator|=
name|bufferevent_socket_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
argument_list|)
expr_stmt|;
name|bev_ll
index|[
literal|1
index|]
operator|=
name|bufferevent_socket_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
argument_list|)
expr_stmt|;
block|}
name|open_ssl_bufevs
argument_list|(
operator|&
name|bev1
argument_list|,
operator|&
name|bev2
argument_list|,
name|data
operator|->
name|base
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|ssl1
argument_list|,
name|ssl2
argument_list|,
name|fd_pair
argument_list|,
name|bev_ll
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filter
condition|)
block|{
name|tt_int_op
argument_list|(
name|bufferevent_getfd
argument_list|(
name|bev1
argument_list|)
argument_list|,
operator|==
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_ptr_op
argument_list|(
name|bufferevent_get_underlying
argument_list|(
name|bev1
argument_list|)
argument_list|,
operator|==
argument_list|,
name|bev_ll
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start_open
condition|)
block|{
name|pending_connect_events
operator|=
literal|2
expr_stmt|;
name|stop_when_connected
operator|=
literal|1
expr_stmt|;
name|exit_base
operator|=
name|data
operator|->
name|base
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
comment|/* Okay, now the renegotiation is done.  Make new 		 * bufferevents to test opening in BUFFEREVENT_SSL_OPEN */
name|flags
operator||=
name|BEV_OPT_CLOSE_ON_FREE
expr_stmt|;
name|bufferevent_free
argument_list|(
name|bev1
argument_list|)
expr_stmt|;
name|bufferevent_free
argument_list|(
name|bev2
argument_list|)
expr_stmt|;
name|bev1
operator|=
name|bev2
operator|=
name|NULL
expr_stmt|;
name|open_ssl_bufevs
argument_list|(
operator|&
name|bev1
argument_list|,
operator|&
name|bev2
argument_list|,
name|data
operator|->
name|base
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|,
name|ssl1
argument_list|,
name|ssl2
argument_list|,
name|fd_pair
argument_list|,
name|bev_ll
argument_list|)
expr_stmt|;
block|}
name|bufferevent_enable
argument_list|(
name|bev1
argument_list|,
name|EV_READ
operator||
name|EV_WRITE
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|bev2
argument_list|,
name|EV_READ
operator||
name|EV_WRITE
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|bufferevent_get_output
argument_list|(
name|bev1
argument_list|)
argument_list|,
literal|"1\n"
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|test_is_done
operator|==
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|n_connected
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* We don't handle shutdown properly yet. 	   tt_int_op(got_close, ==, 1); 	   tt_int_op(got_error, ==, 0); 	*/
name|end
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|acceptcb
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|listener
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|int
name|socklen
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
decl_stmt|;
name|SSL
modifier|*
name|ssl
init|=
name|SSL_new
argument_list|(
name|get_ssl_ctx
argument_list|()
argument_list|)
decl_stmt|;
name|SSL_use_certificate
argument_list|(
name|ssl
argument_list|,
name|getcert
argument_list|()
argument_list|)
expr_stmt|;
name|SSL_use_PrivateKey
argument_list|(
name|ssl
argument_list|,
name|getkey
argument_list|()
argument_list|)
expr_stmt|;
name|bev
operator|=
name|bufferevent_openssl_socket_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|fd
argument_list|,
name|ssl
argument_list|,
name|BUFFEREVENT_SSL_ACCEPTING
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
operator||
name|BEV_OPT_DEFER_CALLBACKS
argument_list|)
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|bev
argument_list|,
name|respond_to_number
argument_list|,
name|NULL
argument_list|,
name|eventcb
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|"server"
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|bev
argument_list|,
name|EV_READ
operator||
name|EV_WRITE
argument_list|)
expr_stmt|;
comment|/* Only accept once, then disable ourself. */
name|evconnlistener_disable
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|regress_bufferevent_openssl_connect
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|evconnlistener
modifier|*
name|listener
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|ev_socklen_t
name|slen
decl_stmt|;
name|init_ssl
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x7f000001
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
name|slen
operator|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|listener
operator|=
name|evconnlistener_new_bind
argument_list|(
name|base
argument_list|,
name|acceptcb
argument_list|,
name|data
argument_list|,
name|LEV_OPT_CLOSE_ON_FREE
operator||
name|LEV_OPT_REUSEABLE
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evconnlistener_get_fd
argument_list|(
name|listener
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|bev
operator|=
name|bufferevent_openssl_socket_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|SSL_new
argument_list|(
name|get_ssl_ctx
argument_list|()
argument_list|)
argument_list|,
name|BUFFEREVENT_SSL_CONNECTING
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
operator||
name|BEV_OPT_DEFER_CALLBACKS
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|bev
argument_list|,
name|respond_to_number
argument_list|,
name|NULL
argument_list|,
name|eventcb
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|"client"
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|getsockname
argument_list|(
name|evconnlistener_get_fd
argument_list|(
name|listener
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|slen
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|slen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sa_family
argument_list|,
operator|==
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sa_family
argument_list|,
operator|==
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
literal|0
operator|==
name|bufferevent_socket_connect
argument_list|(
name|bev
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|slen
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|bufferevent_get_output
argument_list|(
name|bev
argument_list|)
argument_list|,
literal|"1\n"
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|bev
argument_list|,
name|EV_READ
operator||
name|EV_WRITE
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|testcase_t
name|ssl_testcases
index|[]
init|=
block|{
block|{
literal|"bufferevent_socketpair"
block|,
name|regress_bufferevent_openssl
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"socketpair"
block|}
block|,
block|{
literal|"bufferevent_filter"
block|,
name|regress_bufferevent_openssl
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"filter"
block|}
block|,
block|{
literal|"bufferevent_renegotiate_socketpair"
block|,
name|regress_bufferevent_openssl
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"socketpair renegotiate"
block|}
block|,
block|{
literal|"bufferevent_renegotiate_filter"
block|,
name|regress_bufferevent_openssl
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"filter renegotiate"
block|}
block|,
block|{
literal|"bufferevent_socketpair_startopen"
block|,
name|regress_bufferevent_openssl
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"socketpair open"
block|}
block|,
block|{
literal|"bufferevent_filter_startopen"
block|,
name|regress_bufferevent_openssl
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"filter open"
block|}
block|,
block|{
literal|"bufferevent_connect"
block|,
name|regress_bufferevent_openssl_connect
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
name|END_OF_TESTCASES
block|, }
decl_stmt|;
end_decl_stmt

end_unit

