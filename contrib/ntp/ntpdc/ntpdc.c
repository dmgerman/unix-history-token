begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntpdc - control and monitor your ntpd daemon  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_include
include|#
directive|include
file|<mswsock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|"ntpdc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_select.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lineedit.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_include
include|#
directive|include
file|"openssl/evp.h"
end_include

begin_include
include|#
directive|include
file|"openssl/objects.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ssl_applink.c>
end_include

begin_include
include|#
directive|include
file|"ntp_libopts.h"
end_include

begin_include
include|#
directive|include
file|"ntpdc-opts.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_VXWORKS
end_ifdef

begin_comment
comment|/* vxWorks needs mode flag -casey*/
end_comment

begin_define
define|#
directive|define
name|open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
value|open(name, flags, 0777)
end_define

begin_define
define|#
directive|define
name|SERVER_PORT_NUM
value|123
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We use COMMAND as an autogen keyword */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMMAND
end_ifdef

begin_undef
undef|#
directive|undef
name|COMMAND
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Because we now potentially understand a lot of commands (and  * it requires a lot of commands to talk to ntpd) we will run  * interactive if connected to a terminal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when we should prompt */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|prompt
init|=
literal|"ntpdc> "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prompt to ask him about */
end_comment

begin_comment
comment|/*  * Keyid used for authenticated requests.  Obtained on the fly.  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|info_auth_keyid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|keyid_entered
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|info_auth_keytype
init|=
name|NID_md5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MD5 */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|info_auth_hashlen
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MD5 */
end_comment

begin_decl_stmt
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* needed by authkeys; not used */
end_comment

begin_comment
comment|/*  * for get_systime()  */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision (log2 s) */
end_comment

begin_function_decl
name|int
name|ntpdcmain
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Built in command handler declarations  */
end_comment

begin_function_decl
specifier|static
name|int
name|openhost
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sendpkt
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|growpktdata
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getresponse
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sendrequest
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_int
parameter_list|,
name|size_t
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getcmds
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RETSIGTYPE
name|abortcmd
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|docmd
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tokenize
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|findcmd
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|xcmd
modifier|*
parameter_list|,
name|struct
name|xcmd
modifier|*
parameter_list|,
name|struct
name|xcmd
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getarg
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|arg_v
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|sockaddr_u
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|help
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|helpsort
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printusage
parameter_list|(
name|struct
name|xcmd
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timeout
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_delay
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|host
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keyid
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keytype
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|passwd
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hostnames
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setdebug
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quit
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|version
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|u_long
name|getkeyid
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Built-in commands we understand  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|xcmd
name|builtins
index|[]
init|=
block|{
block|{
literal|"?"
block|,
name|help
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"command"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"tell the use and syntax of commands"
block|}
block|,
block|{
literal|"help"
block|,
name|help
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"command"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"tell the use and syntax of commands"
block|}
block|,
block|{
literal|"timeout"
block|,
name|timeout
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"msec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the primary receive time out"
block|}
block|,
block|{
literal|"delay"
block|,
name|my_delay
block|,
block|{
name|OPT
operator||
name|NTP_INT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"msec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the delay added to encryption time stamps"
block|}
block|,
block|{
literal|"host"
block|,
name|host
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|"hostname"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify the host whose NTP server we talk to"
block|}
block|,
block|{
literal|"passwd"
block|,
name|passwd
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify a password to use for authenticated requests"
block|}
block|,
block|{
literal|"hostnames"
block|,
name|hostnames
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"yes|no"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify whether hostnames or net numbers are printed"
block|}
block|,
block|{
literal|"debug"
block|,
name|setdebug
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"no|more|less"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set/change debugging level"
block|}
block|,
block|{
literal|"quit"
block|,
name|quit
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"exit ntpdc"
block|}
block|,
block|{
literal|"exit"
block|,
name|quit
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"exit ntpdc"
block|}
block|,
block|{
literal|"keyid"
block|,
name|keyid
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"key#"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set/show keyid to use for authenticated requests"
block|}
block|,
block|{
literal|"keytype"
block|,
name|keytype
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"(md5|des)"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set/show key authentication type for authenticated requests (des|md5)"
block|}
block|,
block|{
literal|"version"
block|,
name|version
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print version number"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default values we use.  */
end_comment

begin_define
define|#
directive|define
name|DEFHOST
value|"localhost"
end_define

begin_comment
comment|/* default host name */
end_comment

begin_define
define|#
directive|define
name|DEFTIMEOUT
value|(5)
end_define

begin_comment
comment|/* 5 second time out */
end_comment

begin_define
define|#
directive|define
name|DEFSTIMEOUT
value|(2)
end_define

begin_comment
comment|/* 2 second time out after first */
end_comment

begin_define
define|#
directive|define
name|DEFDELAY
value|0x51EB852
end_define

begin_comment
comment|/* 20 milliseconds, l_fp fraction */
end_comment

begin_define
define|#
directive|define
name|LENHOSTNAME
value|256
end_define

begin_comment
comment|/* host name is 256 characters long */
end_comment

begin_define
define|#
directive|define
name|MAXCMDS
value|100
end_define

begin_comment
comment|/* maximum commands on cmd line */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTS
value|200
end_define

begin_comment
comment|/* maximum hosts on cmd line */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|512
end_define

begin_comment
comment|/* maximum line length */
end_comment

begin_define
define|#
directive|define
name|MAXTOKENS
value|(1+1+MAXARGS+MOREARGS+2)
end_define

begin_comment
comment|/* maximum number of usable tokens */
end_comment

begin_define
define|#
directive|define
name|SCREENWIDTH
value|78
end_define

begin_comment
comment|/* nominal screen width in columns */
end_comment

begin_comment
comment|/*  * Some variables used and manipulated locally  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sock_timeval
name|tvout
init|=
block|{
name|DEFTIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time out for reads */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sock_timeval
name|tvsout
init|=
block|{
name|DEFSTIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* secondary time out */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|delay_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delay time */
end_comment

begin_decl_stmt
specifier|static
name|char
name|currenthost
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current host name */
end_comment

begin_decl_stmt
name|int
name|showhostnames
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show host names by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ai_fam_templ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address family */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ai_fam_default
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default address family */
end_comment

begin_decl_stmt
specifier|static
name|SOCKET
name|sockfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fd socket is opened on */
end_comment

begin_decl_stmt
specifier|static
name|int
name|havehost
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when host open */
end_comment

begin_decl_stmt
name|int
name|s_port
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Holds data returned from queries.  We allocate INITDATASIZE  * octets to begin with, increasing this as we need to.  */
end_comment

begin_define
define|#
directive|define
name|INITDATASIZE
value|(sizeof(struct resp_pkt) * 16)
end_define

begin_define
define|#
directive|define
name|INCDATASIZE
value|(sizeof(struct resp_pkt) * 8)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pktdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pktdatasize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These are used to help the magic with old and new versions of ntpd.  */
end_comment

begin_decl_stmt
name|int
name|impl_ver
init|=
name|IMPL_XNTPD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|req_pkt_size
init|=
name|REQ_LEN_NOMAC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For commands typed on the command line (with the -c option)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numcmds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ccmds
index|[
name|MAXCMDS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDCMD
parameter_list|(
name|cp
parameter_list|)
value|if (numcmds< MAXCMDS) ccmds[numcmds++] = (cp)
end_define

begin_comment
comment|/*  * When multiple hosts are specified.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numhosts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|chosts
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDHOST
parameter_list|(
name|cp
parameter_list|)
value|if (numhosts< MAXHOSTS) chosts[numhosts++] = (cp)
end_define

begin_comment
comment|/*  * Error codes for internal use  */
end_comment

begin_define
define|#
directive|define
name|ERR_INCOMPLETE
value|16
end_define

begin_define
define|#
directive|define
name|ERR_TIMEOUT
value|17
end_define

begin_comment
comment|/*  * Macro definitions we use  */
end_comment

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '\n' || (c) == '\r' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * Jump buffer for longjumping back to the command level  */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|interrupt_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|jump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pointer to current output unit  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|current_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Command table imported from ntpdc_ops.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|xcmd
name|opcmds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_MAIN_ALLOWED
end_ifdef

begin_expr_stmt
name|CALL
argument_list|(
name|ntpdc
argument_list|,
literal|"ntpdc"
argument_list|,
name|ntpdcmain
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
return|return
name|ntpdcmain
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_VXWORKS
end_ifdef

begin_function
name|void
name|clear_globals
parameter_list|(
name|void
parameter_list|)
block|{
name|showhostnames
operator|=
literal|0
expr_stmt|;
comment|/* show host names by default */
name|havehost
operator|=
literal|0
expr_stmt|;
comment|/* set to 1 when host open */
name|numcmds
operator|=
literal|0
expr_stmt|;
name|numhosts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * main - parse arguments and handle options  */
end_comment

begin_function
name|int
name|ntpdcmain
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|delay_time
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|delay_time
operator|.
name|l_uf
operator|=
name|DEFDELAY
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_VXWORKS
name|clear_globals
argument_list|()
expr_stmt|;
name|taskPrioritySet
argument_list|(
name|taskIdSelf
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_lib
argument_list|()
expr_stmt|;
comment|/* sets up ipv4_works, ipv6_works */
name|ssl_applink
argument_list|()
expr_stmt|;
name|init_auth
argument_list|()
expr_stmt|;
comment|/* Check to see if we have IPv6. Otherwise default to IPv4 */
if|if
condition|(
operator|!
name|ipv6_works
condition|)
name|ai_fam_default
operator|=
name|AF_INET
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|{
name|int
name|optct
init|=
name|ntpOptionProcess
argument_list|(
operator|&
name|ntpdcOptions
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|argc
operator|-=
name|optct
expr_stmt|;
name|argv
operator|+=
name|optct
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IPV4
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IPV6
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|ai_fam_templ
operator|=
name|ai_fam_default
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|COMMAND
argument_list|)
condition|)
block|{
name|int
name|cmdct
init|=
name|STACKCT_OPT
argument_list|(
name|COMMAND
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cmds
init|=
name|STACKLST_OPT
argument_list|(
name|COMMAND
argument_list|)
decl_stmt|;
while|while
condition|(
name|cmdct
operator|--
operator|>
literal|0
condition|)
block|{
name|ADDCMD
argument_list|(
operator|*
name|cmds
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
name|debug
operator|=
name|OPT_VALUE_SET_DEBUG_LEVEL
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|INTERACTIVE
argument_list|)
condition|)
block|{
name|interactive
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|NUMERIC
argument_list|)
condition|)
block|{
name|showhostnames
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|LISTPEERS
argument_list|)
condition|)
block|{
name|ADDCMD
argument_list|(
literal|"listpeers"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|PEERS
argument_list|)
condition|)
block|{
name|ADDCMD
argument_list|(
literal|"peers"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|SHOWPEERS
argument_list|)
condition|)
block|{
name|ADDCMD
argument_list|(
literal|"dmpeers"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntp_optind
operator|==
name|argc
condition|)
block|{
name|ADDHOST
argument_list|(
name|DEFHOST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|ntp_optind
operator|<
name|argc
condition|;
name|ntp_optind
operator|++
control|)
name|ADDHOST
argument_list|(
name|argv
index|[
name|ntp_optind
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numcmds
operator|==
literal|0
operator|&&
name|interactive
operator|==
literal|0
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
block|{
name|interactive
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* Under NT cannot handle SIGINT, WIN32 spawns a handler */
if|if
condition|(
name|interactive
condition|)
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGINT
argument_list|,
name|abortcmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Initialize the packet data buffer 	 */
name|pktdatasize
operator|=
name|INITDATASIZE
expr_stmt|;
name|pktdata
operator|=
name|emalloc
argument_list|(
name|INITDATASIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|numcmds
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|openhost
argument_list|(
name|chosts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|getcmds
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|ihost
decl_stmt|;
name|int
name|icmd
decl_stmt|;
for|for
control|(
name|ihost
operator|=
literal|0
init|;
name|ihost
operator|<
name|numhosts
condition|;
name|ihost
operator|++
control|)
block|{
if|if
condition|(
name|openhost
argument_list|(
name|chosts
index|[
name|ihost
index|]
argument_list|)
condition|)
for|for
control|(
name|icmd
operator|=
literal|0
init|;
name|icmd
operator|<
name|numcmds
condition|;
name|icmd
operator|++
control|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"--- %s ---\n"
argument_list|,
name|chosts
index|[
name|ihost
index|]
argument_list|)
expr_stmt|;
name|docmd
argument_list|(
name|ccmds
index|[
name|icmd
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|SYS_WINNT
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* main end */
end_comment

begin_comment
comment|/*  * openhost - open a socket to a host  */
end_comment

begin_function
specifier|static
name|int
name|openhost
parameter_list|(
specifier|const
name|char
modifier|*
name|hname
parameter_list|)
block|{
name|char
name|temphost
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|int
name|a_info
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|name
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|char
name|service
index|[
literal|5
index|]
decl_stmt|;
comment|/* 	 * We need to get by the [] if they were entered  	 */
name|cp
operator|=
name|hname
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'['
condition|)
block|{
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|']'
condition|;
name|cp
operator|++
operator|,
name|i
operator|++
control|)
name|name
index|[
name|i
index|]
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|']'
condition|)
block|{
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hname
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * First try to resolve it as an ip address and if that fails, 	 * do a fullblown (dns) lookup. That way we only use the dns 	 * when it is needed and work around some implementations that 	 * will return an "IPv4-mapped IPv6 address" address if you 	 * give it an IPv4 address to lookup. 	 */
name|strlcpy
argument_list|(
name|service
argument_list|,
literal|"ntp"
argument_list|,
sizeof|sizeof
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|ai_fam_templ
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|Z_AI_NUMERICHOST
expr_stmt|;
name|a_info
operator|=
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
name|service
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_info
operator|==
name|EAI_NONAME
ifdef|#
directive|ifdef
name|EAI_NODATA
operator|||
name|a_info
operator|==
name|EAI_NODATA
endif|#
directive|endif
condition|)
block|{
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
ifdef|#
directive|ifdef
name|AI_ADDRCONFIG
name|hints
operator|.
name|ai_flags
operator||=
name|AI_ADDRCONFIG
expr_stmt|;
endif|#
directive|endif
name|a_info
operator|=
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
name|service
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
block|}
comment|/* Some older implementations don't like AI_ADDRCONFIG. */
if|if
condition|(
name|a_info
operator|==
name|EAI_BADFLAGS
condition|)
block|{
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
name|a_info
operator|=
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
name|service
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a_info
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|gai_strerror
argument_list|(
name|a_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|!=
name|NULL
condition|)
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  	 * getaddrinfo() has returned without error so ai should not  	 * be NULL. 	 */
name|INSIST
argument_list|(
name|ai
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|octets
operator|=
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
name|strlcpy
argument_list|(
name|temphost
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|temphost
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|temphost
argument_list|,
name|ai
operator|->
name|ai_canonname
argument_list|,
sizeof|sizeof
argument_list|(
name|temphost
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Opening host %s\n"
argument_list|,
name|temphost
argument_list|)
expr_stmt|;
if|if
condition|(
name|havehost
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Closing old host %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|havehost
operator|=
literal|0
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|currenthost
argument_list|,
name|temphost
argument_list|,
sizeof|sizeof
argument_list|(
name|currenthost
argument_list|)
argument_list|)
expr_stmt|;
comment|/* port maps to the same in both families */
name|s_port
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
empty_stmt|;
ifdef|#
directive|ifdef
name|SYS_VXWORKS
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|hostaddr
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|SERVER_PORT_NUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|==
name|AF_INET
condition|)
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|hostaddr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
else|else
operator|*
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|hostaddr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_VXWORKS */
ifdef|#
directive|ifdef
name|SYS_WINNT
block|{
name|int
name|optionValue
init|=
name|SO_SYNCHRONOUS_NONALERT
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|setsockopt
argument_list|(
name|INVALID_SOCKET
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_OPENTYPE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|optionValue
argument_list|,
sizeof|sizeof
argument_list|(
name|optionValue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NO_ERROR
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open nonoverlapped sockets\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
name|sockfd
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|error
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NEED_RCVBUF_SLOP
ifdef|#
directive|ifdef
name|SO_RCVBUF
block|{
name|int
name|rbufsize
init|=
name|INITDATASIZE
operator|+
literal|2048
decl_stmt|;
comment|/* 2K for slop */
if|if
condition|(
name|setsockopt
argument_list|(
name|sockfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|rbufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"setsockopt"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_VXWORKS
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|hostaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|hostaddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
endif|#
directive|endif
comment|/* SYS_VXWORKS */
name|error
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|havehost
operator|=
literal|1
expr_stmt|;
name|req_pkt_size
operator|=
name|REQ_LEN_NOMAC
expr_stmt|;
name|impl_ver
operator|=
name|IMPL_XNTPD
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* XXX ELIMINATE sendpkt similar in ntpq.c, ntpdc.c, ntp_io.c, ntptrace.c */
comment|/*  * sendpkt - send a packet to the remote host  */
specifier|static
name|int
name|sendpkt
parameter_list|(
name|void
modifier|*
name|xdata
parameter_list|,
name|size_t
name|xdatalen
parameter_list|)
block|{
if|if
condition|(
name|send
argument_list|(
name|sockfd
argument_list|,
name|xdata
argument_list|,
name|xdatalen
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"write to %s failed"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  * growpktdata - grow the packet data area  */
specifier|static
name|void
name|growpktdata
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|priorsz
decl_stmt|;
name|priorsz
operator|=
operator|(
name|size_t
operator|)
name|pktdatasize
expr_stmt|;
name|pktdatasize
operator|+=
name|INCDATASIZE
expr_stmt|;
name|pktdata
operator|=
name|erealloc_zero
argument_list|(
name|pktdata
argument_list|,
operator|(
name|size_t
operator|)
name|pktdatasize
argument_list|,
name|priorsz
argument_list|)
expr_stmt|;
block|}
comment|/*  * getresponse - get a (series of) response packet(s) and return the data  */
specifier|static
name|int
name|getresponse
parameter_list|(
name|int
name|implcode
parameter_list|,
name|int
name|reqcode
parameter_list|,
name|int
modifier|*
name|ritems
parameter_list|,
name|int
modifier|*
name|rsize
parameter_list|,
name|char
modifier|*
modifier|*
name|rdata
parameter_list|,
name|int
name|esize
parameter_list|)
block|{
name|struct
name|resp_pkt
name|rpkt
decl_stmt|;
name|struct
name|sock_timeval
name|tvo
decl_stmt|;
name|int
name|items
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|datasize
decl_stmt|;
name|char
modifier|*
name|datap
decl_stmt|;
name|char
modifier|*
name|tmp_data
decl_stmt|;
name|char
name|haveseq
index|[
name|MAXSEQ
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|firstpkt
decl_stmt|;
name|int
name|lastseq
decl_stmt|;
name|int
name|numrecv
decl_stmt|;
name|int
name|seq
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|ssize_t
name|n
decl_stmt|;
name|int
name|pad
decl_stmt|;
comment|/* 	 * This is pretty tricky.  We may get between 1 and many packets 	 * back in response to the request.  We peel the data out of 	 * each packet and collect it in one long block.  When the last 	 * packet in the sequence is received we'll know how many we 	 * should have had.  Note we use one long time out, should reconsider. 	 */
operator|*
name|ritems
operator|=
literal|0
expr_stmt|;
operator|*
name|rsize
operator|=
literal|0
expr_stmt|;
name|firstpkt
operator|=
literal|1
expr_stmt|;
name|numrecv
operator|=
literal|0
expr_stmt|;
operator|*
name|rdata
operator|=
name|datap
operator|=
name|pktdata
expr_stmt|;
name|lastseq
operator|=
literal|999
expr_stmt|;
comment|/* too big to be a sequence number */
name|ZERO
argument_list|(
name|haveseq
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|firstpkt
condition|)
name|tvo
operator|=
name|tvout
expr_stmt|;
else|else
name|tvo
operator|=
name|tvsout
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvo
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"select fails"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Timed out.  Return what we have 		 */
if|if
condition|(
name|firstpkt
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timed out, nothing received\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
return|return
name|ERR_TIMEOUT
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timed out with incomplete data\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"Received sequence numbers"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|MAXSEQ
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|haveseq
index|[
name|n
index|]
condition|)
name|printf
argument_list|(
literal|" %zd,"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastseq
operator|!=
literal|999
condition|)
name|printf
argument_list|(
literal|" last frame received\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" last frame not received\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ERR_INCOMPLETE
return|;
block|}
block|}
name|n
operator|=
name|recv
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Check for format errors.  Bug proofing. 	 */
if|if
condition|(
name|n
operator|<
operator|(
name|ssize_t
operator|)
name|RESP_HEADER_SIZE
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Short (%zd byte) packet received\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|INFO_VERSION
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
operator|||
name|INFO_VERSION
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|<
name|NTP_OLDVERSION
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Packet received with version %d\n"
argument_list|,
name|INFO_VERSION
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|INFO_MODE
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|!=
name|MODE_PRIVATE
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Packet received with mode %d\n"
argument_list|,
name|INFO_MODE
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|INFO_IS_AUTH
argument_list|(
name|rpkt
operator|.
name|auth_seq
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Encrypted packet received\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
operator|!
name|ISRESPONSE
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received request packet, wanted response\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|INFO_MBZ
argument_list|(
name|rpkt
operator|.
name|mbz_itemsize
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received packet with nonzero MBZ field!\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Check implementation/request.  Could be old data getting to us. 	 */
if|if
condition|(
name|rpkt
operator|.
name|implementation
operator|!=
name|implcode
operator|||
name|rpkt
operator|.
name|request
operator|!=
name|reqcode
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received implementation/request of %d/%d, wanted %d/%d"
argument_list|,
name|rpkt
operator|.
name|implementation
argument_list|,
name|rpkt
operator|.
name|request
argument_list|,
name|implcode
argument_list|,
name|reqcode
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Check the error code.  If non-zero, return it. 	 */
if|if
condition|(
name|INFO_ERR
argument_list|(
name|rpkt
operator|.
name|err_nitems
argument_list|)
operator|!=
name|INFO_OKAY
condition|)
block|{
if|if
condition|(
name|debug
operator|&&
name|ISMORE
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error code %d received on not-final packet\n"
argument_list|,
name|INFO_ERR
argument_list|(
name|rpkt
operator|.
name|err_nitems
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|INFO_ERR
argument_list|(
name|rpkt
operator|.
name|err_nitems
argument_list|)
return|;
block|}
comment|/* 	 * Collect items and size.  Make sure they make sense. 	 */
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|rpkt
operator|.
name|err_nitems
argument_list|)
expr_stmt|;
name|size
operator|=
name|INFO_ITEMSIZE
argument_list|(
name|rpkt
operator|.
name|mbz_itemsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|esize
operator|>
name|size
condition|)
name|pad
operator|=
name|esize
operator|-
name|size
expr_stmt|;
else|else
name|pad
operator|=
literal|0
expr_stmt|;
name|datasize
operator|=
name|items
operator|*
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|datasize
operator|>
operator|(
name|n
operator|-
name|RESP_HEADER_SIZE
operator|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received items %d, size %d (total %d), data in packet is %zu\n"
argument_list|,
name|items
argument_list|,
name|size
argument_list|,
name|datasize
argument_list|,
name|n
operator|-
name|RESP_HEADER_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * If this isn't our first packet, make sure the size matches 	 * the other ones. 	 */
if|if
condition|(
operator|!
name|firstpkt
operator|&&
name|size
operator|!=
operator|*
name|rsize
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received itemsize %d, previous %d\n"
argument_list|,
name|size
argument_list|,
operator|*
name|rsize
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * If we've received this before, +toss it 	 */
name|seq
operator|=
name|INFO_SEQ
argument_list|(
name|rpkt
operator|.
name|auth_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|haveseq
index|[
name|seq
index|]
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received duplicate sequence number %d\n"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|haveseq
index|[
name|seq
index|]
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If this is the last in the sequence, record that. 	 */
if|if
condition|(
operator|!
name|ISMORE
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastseq
operator|!=
literal|999
condition|)
block|{
name|printf
argument_list|(
literal|"Received second end sequence packet\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|lastseq
operator|=
name|seq
expr_stmt|;
block|}
comment|/* 	 * So far, so good.  Copy this data into the output array. 	 */
if|if
condition|(
operator|(
name|datap
operator|+
name|datasize
operator|+
operator|(
name|pad
operator|*
name|items
operator|)
operator|)
operator|>
operator|(
name|pktdata
operator|+
name|pktdatasize
operator|)
condition|)
block|{
name|int
name|offset
init|=
name|datap
operator|-
name|pktdata
decl_stmt|;
name|growpktdata
argument_list|()
expr_stmt|;
operator|*
name|rdata
operator|=
name|pktdata
expr_stmt|;
comment|/* might have been realloced ! */
name|datap
operator|=
name|pktdata
operator|+
name|offset
expr_stmt|;
block|}
comment|/*  	 * We now move the pointer along according to size and number of 	 * items.  This is so we can play nice with older implementations 	 */
name|tmp_data
operator|=
name|rpkt
operator|.
name|u
operator|.
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|items
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|datap
argument_list|,
name|tmp_data
argument_list|,
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
name|tmp_data
operator|+=
name|size
expr_stmt|;
name|zero_mem
argument_list|(
name|datap
operator|+
name|size
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|datap
operator|+=
name|size
operator|+
name|pad
expr_stmt|;
block|}
if|if
condition|(
name|firstpkt
condition|)
block|{
name|firstpkt
operator|=
literal|0
expr_stmt|;
operator|*
name|rsize
operator|=
name|size
operator|+
name|pad
expr_stmt|;
block|}
operator|*
name|ritems
operator|+=
name|items
expr_stmt|;
comment|/* 	 * Finally, check the count of received packets.  If we've got them 	 * all, return 	 */
operator|++
name|numrecv
expr_stmt|;
if|if
condition|(
name|numrecv
operator|<=
name|lastseq
condition|)
goto|goto
name|again
goto|;
return|return
name|INFO_OKAY
return|;
block|}
comment|/*  * sendrequest - format and send a request packet  *  * Historically, ntpdc has used a fixed-size request packet regardless  * of the actual payload size.  When authenticating, the timestamp, key  * ID, and digest have been placed just before the end of the packet.  * With the introduction in late 2009 of support for authenticated  * ntpdc requests using larger 20-octet digests (vs. 16 for MD5), we  * come up four bytes short.  *  * To maintain interop while allowing for larger digests, the behavior  * is unchanged when using 16-octet digests.  For larger digests, the  * timestamp, key ID, and digest are placed immediately following the  * request payload, with the overall packet size variable.  ntpd can  * distinguish 16-octet digests by the overall request size being  * REQ_LEN_NOMAC + 4 + 16 with the auth bit enabled.  When using a  * longer digest, that request size should be avoided.  *  * With the form used with 20-octet and larger digests, the timestamp,  * key ID, and digest are located by ntpd relative to the start of the  * packet, and the size of the digest is then implied by the packet  * size.  */
specifier|static
name|int
name|sendrequest
parameter_list|(
name|int
name|implcode
parameter_list|,
name|int
name|reqcode
parameter_list|,
name|int
name|auth
parameter_list|,
name|u_int
name|qitems
parameter_list|,
name|size_t
name|qsize
parameter_list|,
name|char
modifier|*
name|qdata
parameter_list|)
block|{
name|struct
name|req_pkt
name|qpkt
decl_stmt|;
name|size_t
name|datasize
decl_stmt|;
name|size_t
name|reqsize
decl_stmt|;
name|u_long
name|key_id
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|l_fp
modifier|*
name|ptstamp
decl_stmt|;
name|int
name|maclen
decl_stmt|;
name|char
modifier|*
name|pass
decl_stmt|;
name|ZERO
argument_list|(
name|qpkt
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|rm_vn_mode
operator|=
name|RM_VN_MODE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|implementation
operator|=
operator|(
name|u_char
operator|)
name|implcode
expr_stmt|;
name|qpkt
operator|.
name|request
operator|=
operator|(
name|u_char
operator|)
name|reqcode
expr_stmt|;
name|datasize
operator|=
name|qitems
operator|*
name|qsize
expr_stmt|;
if|if
condition|(
name|datasize
operator|&&
name|qdata
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|qpkt
operator|.
name|u
operator|.
name|data
argument_list|,
name|qdata
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|err_nitems
operator|=
name|ERR_NITEMS
argument_list|(
literal|0
argument_list|,
name|qitems
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|mbz_itemsize
operator|=
name|MBZ_ITEMSIZE
argument_list|(
name|qsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qpkt
operator|.
name|err_nitems
operator|=
name|ERR_NITEMS
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|mbz_itemsize
operator|=
name|MBZ_ITEMSIZE
argument_list|(
name|qsize
argument_list|)
expr_stmt|;
comment|/* allow for optional first item */
block|}
if|if
condition|(
operator|!
name|auth
operator|||
operator|(
name|keyid_entered
operator|&&
name|info_auth_keyid
operator|==
literal|0
operator|)
condition|)
block|{
name|qpkt
operator|.
name|auth_seq
operator|=
name|AUTH_SEQ
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|sendpkt
argument_list|(
operator|&
name|qpkt
argument_list|,
name|req_pkt_size
argument_list|)
return|;
block|}
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
name|key_id
operator|=
name|getkeyid
argument_list|(
literal|"Keyid: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key_id
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid key identifier\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|info_auth_keyid
operator|=
name|key_id
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|info_auth_keyid
argument_list|)
condition|)
block|{
name|pass
operator|=
name|getpass_keytype
argument_list|(
name|info_auth_keytype
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|pass
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid password\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|pass
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|info_auth_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|qpkt
operator|.
name|auth_seq
operator|=
name|AUTH_SEQ
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_auth_hashlen
operator|>
literal|16
condition|)
block|{
comment|/* 		 * Only ntpd which expects REQ_LEN_NOMAC plus maclen 		 * octets in an authenticated request using a 16 octet 		 * digest (that is, a newer ntpd) will handle digests 		 * larger than 16 octets, so for longer digests, do 		 * not attempt to shorten the requests for downlevel 		 * ntpd compatibility. 		 */
if|if
condition|(
name|REQ_LEN_NOMAC
operator|!=
name|req_pkt_size
condition|)
return|return
literal|1
return|;
name|reqsize
operator|=
name|REQ_LEN_HDR
operator|+
name|datasize
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ptstamp
argument_list|)
expr_stmt|;
comment|/* align to 32 bits */
name|reqsize
operator|=
operator|(
name|reqsize
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
block|}
else|else
name|reqsize
operator|=
name|req_pkt_size
expr_stmt|;
name|ptstamp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qpkt
operator|+
name|reqsize
operator|)
expr_stmt|;
name|ptstamp
operator|--
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|delay_time
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|ts
argument_list|,
name|ptstamp
argument_list|)
expr_stmt|;
name|maclen
operator|=
name|authencrypt
argument_list|(
name|info_auth_keyid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
name|reqsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|maclen
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Key not found\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|maclen
operator|!=
call|(
name|int
call|)
argument_list|(
name|info_auth_hashlen
operator|+
sizeof|sizeof
argument_list|(
name|keyid_t
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d octet MAC, %zu expected with %zu octet digest\n"
argument_list|,
name|maclen
argument_list|,
operator|(
name|info_auth_hashlen
operator|+
sizeof|sizeof
argument_list|(
name|keyid_t
argument_list|)
operator|)
argument_list|,
name|info_auth_hashlen
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|sendpkt
argument_list|(
operator|&
name|qpkt
argument_list|,
name|reqsize
operator|+
name|maclen
argument_list|)
return|;
block|}
comment|/*  * doquery - send a request and process the response  */
name|int
name|doquery
parameter_list|(
name|int
name|implcode
parameter_list|,
name|int
name|reqcode
parameter_list|,
name|int
name|auth
parameter_list|,
name|int
name|qitems
parameter_list|,
name|int
name|qsize
parameter_list|,
name|char
modifier|*
name|qdata
parameter_list|,
name|int
modifier|*
name|ritems
parameter_list|,
name|int
modifier|*
name|rsize
parameter_list|,
name|char
modifier|*
modifier|*
name|rdata
parameter_list|,
name|int
name|quiet_mask
parameter_list|,
name|int
name|esize
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|char
name|junk
index|[
literal|512
index|]
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|struct
name|sock_timeval
name|tvzero
decl_stmt|;
comment|/* 	 * Check to make sure host is open 	 */
if|if
condition|(
operator|!
name|havehost
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No host open, use `host' command\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Poll the socket and clear out any pending data 	 */
name|again
label|:
do|do
block|{
name|tvzero
operator|.
name|tv_sec
operator|=
name|tvzero
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|res
operator|=
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvzero
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"polling select"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|res
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|recv
argument_list|(
name|sockfd
argument_list|,
name|junk
argument_list|,
sizeof|sizeof
name|junk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|res
operator|>
literal|0
condition|)
do|;
comment|/* 	 * send a request 	 */
name|res
operator|=
name|sendrequest
argument_list|(
name|implcode
argument_list|,
name|reqcode
argument_list|,
name|auth
argument_list|,
name|qitems
argument_list|,
name|qsize
argument_list|,
name|qdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|res
return|;
comment|/* 	 * Get the response.  If we got a standard error, print a message 	 */
name|res
operator|=
name|getresponse
argument_list|(
name|implcode
argument_list|,
name|reqcode
argument_list|,
name|ritems
argument_list|,
name|rsize
argument_list|,
name|rdata
argument_list|,
name|esize
argument_list|)
expr_stmt|;
comment|/* 	 * Try to be compatible with older implementations of ntpd. 	 */
if|if
condition|(
name|res
operator|==
name|INFO_ERR_FMT
operator|&&
name|req_pkt_size
operator|!=
literal|48
condition|)
block|{
name|int
name|oldsize
decl_stmt|;
name|oldsize
operator|=
name|req_pkt_size
expr_stmt|;
switch|switch
condition|(
name|req_pkt_size
condition|)
block|{
case|case
name|REQ_LEN_NOMAC
case|:
name|req_pkt_size
operator|=
literal|160
expr_stmt|;
break|break;
case|case
literal|160
case|:
name|req_pkt_size
operator|=
literal|48
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|impl_ver
operator|==
name|IMPL_XNTPD
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Warning changing to older implementation\n"
argument_list|)
expr_stmt|;
return|return
name|INFO_ERR_IMPL
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Warning changing the request packet size from %d to %d\n"
argument_list|,
name|oldsize
argument_list|,
name|req_pkt_size
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* log error message if not told to be quiet */
if|if
condition|(
operator|(
name|res
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
literal|1
operator|<<
name|res
operator|)
operator|&
name|quiet_mask
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|INFO_ERR_IMPL
case|:
comment|/* Give us a chance to try the older implementation. */
if|if
condition|(
name|implcode
operator|==
name|IMPL_XNTPD
condition|)
break|break;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server implementation incompatible with our own\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INFO_ERR_REQ
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server doesn't implement this request\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INFO_ERR_FMT
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server reports a format error in the received packet (shouldn't happen)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INFO_ERR_NODATA
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server reports data not found\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INFO_ERR_AUTH
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Permission denied\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_TIMEOUT
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Request timed out\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_INCOMPLETE
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Response from server was incomplete\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returns unknown error code %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|res
return|;
block|}
comment|/*  * getcmds - read commands from the standard input and execute them  */
specifier|static
name|void
name|getcmds
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|count
decl_stmt|;
name|ntp_readline_init
argument_list|(
name|interactive
condition|?
name|prompt
else|:
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|line
operator|=
name|ntp_readline
argument_list|(
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|line
condition|)
break|break;
name|docmd
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|ntp_readline_uninit
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* Under NT cannot handle SIGINT, WIN32 spawns a handler */
comment|/*  * abortcmd - catch interrupts and abort the current command  */
specifier|static
name|RETSIGTYPE
name|abortcmd
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|current_output
operator|==
name|stdout
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
name|longjmp
argument_list|(
name|interrupt_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/*  * docmd - decode the command line and execute a command  */
specifier|static
name|void
name|docmd
parameter_list|(
specifier|const
name|char
modifier|*
name|cmdline
parameter_list|)
block|{
name|char
modifier|*
name|tokens
index|[
literal|1
operator|+
name|MAXARGS
operator|+
name|MOREARGS
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|parse
name|pcmd
decl_stmt|;
name|int
name|ntok
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ti
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|xcmd
decl_stmt|;
name|ai_fam_templ
operator|=
name|ai_fam_default
expr_stmt|;
comment|/* 	 * Tokenize the command line.  If nothing on it, return. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|cmdline
argument_list|)
operator|>=
name|MAXLINE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command ignored, more than %d characters:\n%s\n"
argument_list|,
name|MAXLINE
operator|-
literal|1
argument_list|,
name|cmdline
argument_list|)
expr_stmt|;
return|return;
block|}
name|tokenize
argument_list|(
name|cmdline
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Find the appropriate command description. 	 */
name|i
operator|=
name|findcmd
argument_list|(
name|tokens
index|[
literal|0
index|]
argument_list|,
name|builtins
argument_list|,
name|opcmds
argument_list|,
operator|&
name|xcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command `%s' unknown\n"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command `%s' ambiguous\n"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Save the keyword, then walk through the arguments, interpreting 	 * as we go. 	 */
name|pcmd
operator|.
name|keyword
operator|=
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|pcmd
operator|.
name|nargs
operator|=
literal|0
expr_stmt|;
name|ti
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
operator|&&
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|NO
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
name|ti
operator|)
operator|>=
name|ntok
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
operator|)
condition|)
block|{
name|printusage
argument_list|(
name|xcmd
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
operator|)
operator|&&
operator|(
operator|*
name|tokens
index|[
name|i
operator|+
name|ti
index|]
operator|==
literal|'>'
operator|)
condition|)
break|break;
name|rval
operator|=
name|getarg
argument_list|(
name|tokens
index|[
name|i
operator|+
name|ti
index|]
argument_list|,
operator|(
name|int
operator|)
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
argument_list|,
operator|&
name|pcmd
operator|.
name|argval
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
block|{
name|ti
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
return|return;
name|pcmd
operator|.
name|nargs
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* Any extra args are assumed to be "OPT|NTP_STR". */
for|for
control|(
init|;
name|i
operator|<
name|MAXARGS
operator|+
name|MOREARGS
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
name|ti
operator|)
operator|>=
name|ntok
condition|)
break|break;
name|rval
operator|=
name|getarg
argument_list|(
name|tokens
index|[
name|i
operator|+
name|ti
index|]
argument_list|,
call|(
name|int
call|)
argument_list|(
name|OPT
operator||
name|NTP_STR
argument_list|)
argument_list|,
operator|&
name|pcmd
operator|.
name|argval
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
block|{
name|ti
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
return|return;
name|pcmd
operator|.
name|nargs
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|+=
name|ti
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ntok
operator|&&
operator|*
name|tokens
index|[
name|i
index|]
operator|==
literal|'>'
condition|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|tokens
index|[
name|i
index|]
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|fname
operator|=
name|tokens
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|ntok
condition|)
name|fname
operator|=
name|tokens
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No file for redirect\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|current_output
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_output
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Error opening %s: "
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|current_output
operator|=
name|stdout
expr_stmt|;
block|}
if|if
condition|(
name|interactive
operator|&&
name|setjmp
argument_list|(
name|interrupt_buf
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|jump
operator|=
literal|1
expr_stmt|;
call|(
name|xcmd
operator|->
name|handler
call|)
argument_list|(
operator|&
name|pcmd
argument_list|,
name|current_output
argument_list|)
expr_stmt|;
name|jump
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_output
operator|!=
name|stdout
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|current_output
argument_list|)
expr_stmt|;
name|current_output
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*  * tokenize - turn a command line into tokens  */
specifier|static
name|void
name|tokenize
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
modifier|*
name|tokens
parameter_list|,
name|int
modifier|*
name|ntok
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|static
name|char
name|tspace
index|[
name|MAXLINE
index|]
decl_stmt|;
name|sp
operator|=
name|tspace
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
for|for
control|(
operator|*
name|ntok
operator|=
literal|0
init|;
operator|*
name|ntok
operator|<
name|MAXTOKENS
condition|;
operator|(
operator|*
name|ntok
operator|)
operator|++
control|)
block|{
name|tokens
index|[
operator|*
name|ntok
index|]
operator|=
name|sp
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
do|do
block|{
operator|*
name|sp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
operator|*
name|sp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/*  * findcmd - find a command in a command description table  */
specifier|static
name|int
name|findcmd
parameter_list|(
specifier|register
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|xcmd
modifier|*
name|clist1
parameter_list|,
name|struct
name|xcmd
modifier|*
name|clist2
parameter_list|,
name|struct
name|xcmd
modifier|*
modifier|*
name|cmd
parameter_list|)
block|{
specifier|register
name|struct
name|xcmd
modifier|*
name|cl
decl_stmt|;
specifier|register
name|int
name|clen
decl_stmt|;
name|int
name|nmatch
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|nearmatch
init|=
name|NULL
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|clist
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|nmatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clist1
operator|!=
literal|0
condition|)
name|clist
operator|=
name|clist1
expr_stmt|;
elseif|else
if|if
condition|(
name|clist2
operator|!=
literal|0
condition|)
name|clist
operator|=
name|clist2
expr_stmt|;
else|else
return|return
literal|0
return|;
name|again
label|:
for|for
control|(
name|cl
operator|=
name|clist
init|;
name|cl
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|cl
operator|++
control|)
block|{
comment|/* do a first character check, for efficiency */
if|if
condition|(
operator|*
name|str
operator|!=
operator|*
operator|(
name|cl
operator|->
name|keyword
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|cl
operator|->
name|keyword
argument_list|,
operator|(
name|unsigned
operator|)
name|clen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Could be extact match, could be approximate. 			 * Is exact if the length of the keyword is the 			 * same as the str. 			 */
if|if
condition|(
operator|*
operator|(
operator|(
name|cl
operator|->
name|keyword
operator|)
operator|+
name|clen
operator|)
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|cmd
operator|=
name|cl
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nmatch
operator|++
expr_stmt|;
name|nearmatch
operator|=
name|cl
expr_stmt|;
block|}
block|}
comment|/* 				 * See if there is more to do.  If so, go again.  Sorry about the 				 * goto, too much looking at BSD sources... 				 */
if|if
condition|(
name|clist
operator|==
name|clist1
operator|&&
name|clist2
operator|!=
literal|0
condition|)
block|{
name|clist
operator|=
name|clist2
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 				 * If we got extactly 1 near match, use it, else return number 				 * of matches. 				 */
if|if
condition|(
name|nmatch
operator|==
literal|1
condition|)
block|{
operator|*
name|cmd
operator|=
name|nearmatch
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|nmatch
return|;
block|}
comment|/*  * getarg - interpret an argument token  *  * string is always set.  * type is set to the decoded type.  *  * return:	 0 - failure  *		 1 - success  *		-1 - skip to next token  */
specifier|static
name|int
name|getarg
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|code
parameter_list|,
name|arg_v
modifier|*
name|argp
parameter_list|)
block|{
name|int
name|isneg
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|digits
init|=
literal|"0123456789"
decl_stmt|;
name|ZERO
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
name|argp
operator|->
name|string
operator|=
name|str
expr_stmt|;
name|argp
operator|->
name|type
operator|=
name|code
operator|&
operator|~
name|OPT
expr_stmt|;
switch|switch
condition|(
name|argp
operator|->
name|type
condition|)
block|{
case|case
name|NTP_STR
case|:
break|break;
case|case
name|NTP_ADD
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-6"
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|ai_fam_templ
operator|=
name|AF_INET6
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-4"
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|ai_fam_templ
operator|=
name|AF_INET
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|str
argument_list|,
operator|&
operator|(
name|argp
operator|->
name|netnum
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
break|break;
case|case
name|NTP_INT
case|:
case|case
name|NTP_UINT
case|:
name|isneg
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|'-'
condition|)
block|{
name|np
operator|++
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
name|argp
operator|->
name|uval
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|digits
argument_list|,
operator|*
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Illegal integer value %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argp
operator|->
name|uval
operator|*=
literal|10
expr_stmt|;
name|argp
operator|->
name|uval
operator|+=
operator|(
name|cp
operator|-
name|digits
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|(
operator|++
name|np
operator|)
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|isneg
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|&
operator|~
name|OPT
operator|)
operator|==
name|NTP_UINT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Value %s should be unsigned\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argp
operator|->
name|ival
operator|=
operator|-
name|argp
operator|->
name|ival
expr_stmt|;
block|}
break|break;
case|case
name|IP_VERSION
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-6"
argument_list|,
name|str
argument_list|)
condition|)
name|argp
operator|->
name|ival
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-4"
argument_list|,
name|str
argument_list|)
condition|)
name|argp
operator|->
name|ival
operator|=
literal|4
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Version must be either 4 or 6\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
comment|/*  * getnetnum - given a host name, return its net number  *	       and (optional) full name  */
specifier|static
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|hname
parameter_list|,
name|sockaddr_u
modifier|*
name|num
parameter_list|,
name|char
modifier|*
name|fullhost
parameter_list|,
name|int
name|af
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
ifdef|#
directive|ifdef
name|AI_ADDRCONFIG
name|hints
operator|.
name|ai_flags
operator||=
name|AI_ADDRCONFIG
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * decodenetnum only works with addresses, but handles syntax 	 * that getaddrinfo doesn't:  [2001::1]:1234 	 */
if|if
condition|(
name|decodenetnum
argument_list|(
name|hname
argument_list|,
name|num
argument_list|)
condition|)
block|{
if|if
condition|(
name|fullhost
operator|!=
name|NULL
condition|)
name|getnameinfo
argument_list|(
operator|&
name|num
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|num
argument_list|)
argument_list|,
name|fullhost
argument_list|,
name|LENHOSTNAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|num
argument_list|)
operator|>=
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|num
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullhost
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|fullhost
argument_list|,
name|ai
operator|->
name|ai_canonname
argument_list|,
name|LENHOSTNAME
argument_list|)
expr_stmt|;
else|else
name|getnameinfo
argument_list|(
operator|&
name|num
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|num
argument_list|)
argument_list|,
name|fullhost
argument_list|,
name|LENHOSTNAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Can't find host %s\n"
argument_list|,
name|hname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * nntohost - convert network number to host name.  This routine enforces  *	       the showhostnames setting.  */
specifier|const
name|char
modifier|*
name|nntohost
parameter_list|(
name|sockaddr_u
modifier|*
name|netnum
parameter_list|)
block|{
if|if
condition|(
operator|!
name|showhostnames
operator|||
name|SOCK_UNSPEC
argument_list|(
name|netnum
argument_list|)
condition|)
return|return
name|stoa
argument_list|(
name|netnum
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
name|netnum
argument_list|)
condition|)
return|return
name|refnumtoa
argument_list|(
name|netnum
argument_list|)
return|;
else|else
return|return
name|socktohost
argument_list|(
name|netnum
argument_list|)
return|;
block|}
comment|/*  * Finally, the built in command handlers  */
comment|/*  * help - tell about commands, or details of a particular command  */
specifier|static
name|void
name|help
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|xcmd
modifier|*
name|xcp
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|list
index|[
literal|100
index|]
decl_stmt|;
name|size_t
name|word
decl_stmt|,
name|words
decl_stmt|;
name|size_t
name|row
decl_stmt|,
name|rows
decl_stmt|;
name|size_t
name|col
decl_stmt|,
name|cols
decl_stmt|;
name|size_t
name|length
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|words
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|xcp
operator|=
name|builtins
init|;
name|xcp
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|xcp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|xcp
operator|->
name|keyword
operator|)
operator|!=
literal|'?'
condition|)
name|list
index|[
name|words
operator|++
index|]
operator|=
name|xcp
operator|->
name|keyword
expr_stmt|;
block|}
for|for
control|(
name|xcp
operator|=
name|opcmds
init|;
name|xcp
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|xcp
operator|++
control|)
name|list
index|[
name|words
operator|++
index|]
operator|=
name|xcp
operator|->
name|keyword
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|list
argument_list|,
name|words
argument_list|,
sizeof|sizeof
argument_list|(
name|list
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|helpsort
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|word
operator|=
literal|0
init|;
name|word
operator|<
name|words
condition|;
name|word
operator|++
control|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|list
index|[
name|word
index|]
argument_list|)
expr_stmt|;
name|col
operator|=
name|max
argument_list|(
name|col
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|cols
operator|=
name|SCREENWIDTH
operator|/
operator|++
name|col
expr_stmt|;
name|rows
operator|=
operator|(
name|words
operator|+
name|cols
operator|-
literal|1
operator|)
operator|/
name|cols
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ntpdc commands:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|word
operator|=
name|row
init|;
name|word
operator|<
name|words
condition|;
name|word
operator|+=
name|rows
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*.*s"
argument_list|,
operator|(
name|int
operator|)
name|col
argument_list|,
operator|(
name|int
operator|)
name|col
operator|-
literal|1
argument_list|,
name|list
index|[
name|word
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cmd
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
name|words
operator|=
name|findcmd
argument_list|(
name|cmd
argument_list|,
name|builtins
argument_list|,
name|opcmds
argument_list|,
operator|&
name|xcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command `%s' is unknown\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|words
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command `%s' is ambiguous\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"function: %s\n"
argument_list|,
name|xcp
operator|->
name|comment
argument_list|)
expr_stmt|;
name|printusage
argument_list|(
name|xcp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * helpsort - do hostname qsort comparisons  */
specifier|static
name|int
name|helpsort
parameter_list|(
specifier|const
name|void
modifier|*
name|t1
parameter_list|,
specifier|const
name|void
modifier|*
name|t2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|name1
init|=
name|t1
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|name2
init|=
name|t2
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|*
name|name1
argument_list|,
operator|*
name|name2
argument_list|)
return|;
block|}
comment|/*  * printusage - print usage information for a command  */
specifier|static
name|void
name|printusage
parameter_list|(
name|struct
name|xcmd
modifier|*
name|xcp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|opt46
decl_stmt|;
name|opt46
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"usage: %s"
argument_list|,
name|xcp
operator|->
name|keyword
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
operator|&&
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|NO
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|opt46
operator|==
literal|0
operator|&&
operator|(
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|&
operator|~
name|OPT
operator|)
operator|==
name|NTP_ADD
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" [ -4|-6 ]"
argument_list|)
expr_stmt|;
name|opt46
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" [ %s ]"
argument_list|,
name|xcp
operator|->
name|desc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s"
argument_list|,
name|xcp
operator|->
name|desc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*  * timeout - set time out time  */
specifier|static
name|void
name|timeout
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|tvout
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tvout
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"primary timeout %d ms\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tvout
operator|.
name|tv_sec
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|/
literal|1000
expr_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
operator|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|-
operator|(
name|tvout
operator|.
name|tv_sec
operator|*
literal|1000
operator|)
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
block|}
comment|/*  * my_delay - set delay for auth requests  */
specifier|static
name|void
name|my_delay
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|isneg
decl_stmt|;
name|u_long
name|val
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|delay_time
operator|.
name|l_ui
operator|*
literal|1000
operator|+
name|delay_time
operator|.
name|l_uf
operator|/
literal|4294967
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"delay %lu ms\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|val
operator|=
call|(
name|u_long
call|)
argument_list|(
operator|-
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isneg
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
name|u_long
operator|)
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
expr_stmt|;
block|}
name|delay_time
operator|.
name|l_ui
operator|=
name|val
operator|/
literal|1000
expr_stmt|;
name|val
operator|%=
literal|1000
expr_stmt|;
name|delay_time
operator|.
name|l_uf
operator|=
name|val
operator|*
literal|4294967
expr_stmt|;
comment|/* 2**32/1000 */
if|if
condition|(
name|isneg
condition|)
name|L_NEG
argument_list|(
operator|&
name|delay_time
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * host - set the host we are dealing with.  */
specifier|static
name|void
name|host
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host is %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no current host\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-4"
argument_list|,
name|pcmd
operator|->
name|argval
index|[
name|i
index|]
operator|.
name|string
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-6"
argument_list|,
name|pcmd
operator|->
name|argval
index|[
name|i
index|]
operator|.
name|string
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET6
expr_stmt|;
else|else
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host remains %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"still no current host\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|openhost
argument_list|(
name|pcmd
operator|->
name|argval
index|[
name|i
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host set to %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host remains %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"still no current host\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * keyid - get a keyid to use for authenticating requests  */
specifier|static
name|void
name|keyid
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
operator|&&
operator|!
name|keyid_entered
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no keyid defined\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
operator|&&
name|keyid_entered
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no keyid will be sent\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keyid is %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|info_auth_keyid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info_auth_keyid
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
expr_stmt|;
name|keyid_entered
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/*  * keytype - get type of key to use for authenticating requests  */
specifier|static
name|void
name|keytype
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest_name
decl_stmt|;
name|size_t
name|digest_len
decl_stmt|;
name|int
name|key_type
decl_stmt|;
if|if
condition|(
operator|!
name|pcmd
operator|->
name|nargs
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keytype is %s with %lu octet digests\n"
argument_list|,
name|keytype_name
argument_list|(
name|info_auth_keytype
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|info_auth_hashlen
argument_list|)
expr_stmt|;
return|return;
block|}
name|digest_name
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
name|digest_len
operator|=
literal|0
expr_stmt|;
name|key_type
operator|=
name|keytype_from_text
argument_list|(
name|digest_name
argument_list|,
operator|&
name|digest_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key_type
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keytype must be 'md5'%s\n"
argument_list|,
ifdef|#
directive|ifdef
name|OPENSSL
literal|" or a digest type provided by OpenSSL"
argument_list|)
expr_stmt|;
else|#
directive|else
literal|""
block|)
empty_stmt|;
endif|#
directive|endif
return|return;
block|}
name|info_auth_keytype
operator|=
name|key_type
expr_stmt|;
name|info_auth_hashlen
operator|=
name|digest_len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * passwd - get an authentication key  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|passwd
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|pass
decl_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
name|info_auth_keyid
operator|=
name|getkeyid
argument_list|(
literal|"Keyid: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Keyid must be defined\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|1
condition|)
name|pass
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
else|else
block|{
name|pass
operator|=
name|getpass_keytype
argument_list|(
name|info_auth_keytype
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|pass
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Password unchanged\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|pass
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|info_auth_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * hostnames - set the showhostnames flag  */
end_comment

begin_function
specifier|static
name|void
name|hostnames
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|showhostnames
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hostnames being shown\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hostnames not being shown\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|showhostnames
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
name|showhostnames
operator|=
literal|0
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * setdebug - set/change debugging level  */
end_comment

begin_function
specifier|static
name|void
name|setdebug
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"debug level is %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
name|debug
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"more"
argument_list|)
condition|)
block|{
name|debug
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"less"
argument_list|)
condition|)
block|{
name|debug
operator|--
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"debug level set to %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * quit - stop this nonsense  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|quit
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|havehost
condition|)
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * version - print the current version number  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|version
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
name|vwarning
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
name|va_list
name|ap
argument_list|)
block|{
name|int
name|serrno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|strerror
argument_list|(
name|serrno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * warning - print a warning message  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
argument_list|)
name|warning
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarning
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * error - print a message and exit  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
argument_list|)
name|error
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarning
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * getkeyid - prompt the user for a keyid to use  */
end_comment

begin_function
specifier|static
name|u_long
name|getkeyid
parameter_list|(
specifier|const
name|char
modifier|*
name|keyprompt
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|fi
decl_stmt|;
name|char
name|pbuf
index|[
literal|20
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|ilim
decl_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
operator|(
name|fi
operator|=
name|fdopen
argument_list|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|fi
operator|=
name|_fdopen
argument_list|(
name|open
argument_list|(
literal|"CONIN$"
argument_list|,
name|_O_TEXT
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
comment|/* SYS_WINNT */
name|fi
operator|=
name|stdin
expr_stmt|;
else|else
name|setbuf
argument_list|(
name|fi
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|keyprompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ilim
operator|=
name|COUNTOF
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
init|;
name|i
operator|<
name|ilim
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fi
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|;
control|)
name|pbuf
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|pbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fi
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fi
argument_list|)
expr_stmt|;
return|return
operator|(
name|u_long
operator|)
name|atoi
argument_list|(
name|pbuf
argument_list|)
return|;
block|}
end_function

end_unit

