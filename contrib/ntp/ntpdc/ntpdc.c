begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntpdc - control and monitor your ntpd daemon  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntpdc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_select.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|closesocket
value|close
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBREADLINE
end_ifdef

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIBREADLINE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_VXWORKS
end_ifdef

begin_comment
comment|/* vxWorks needs mode flag -casey*/
end_comment

begin_define
define|#
directive|define
name|open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
value|open(name, flags, 0777)
end_define

begin_define
define|#
directive|define
name|SERVER_PORT_NUM
value|123
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Because we now potentially understand a lot of commands (and  * it requires a lot of commands to talk to ntpd) we will run  * interactive if connected to a terminal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when we should prompt */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|prompt
init|=
literal|"ntpdc> "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prompt to ask him about */
end_comment

begin_comment
comment|/*  * Keyid used for authenticated requests.  Obtained on the fly.  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|info_auth_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Type of key md5 or des  */
end_comment

begin_define
define|#
directive|define
name|KEY_TYPE_DES
value|3
end_define

begin_define
define|#
directive|define
name|KEY_TYPE_MD5
value|4
end_define

begin_decl_stmt
specifier|static
name|int
name|info_auth_keytype
init|=
name|KEY_TYPE_MD5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MD5*/
end_comment

begin_decl_stmt
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* needed by authkeys; not used */
end_comment

begin_decl_stmt
name|int
name|ntpdcmain
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Built in command handler declarations  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|openhost
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sendpkt
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|growpktdata
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getresponse
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sendrequest
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getcmds
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|abortcmd
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|docmd
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tokenize
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findcmd
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|xcmd
operator|*
operator|,
expr|struct
name|xcmd
operator|*
operator|,
expr|struct
name|xcmd
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getarg
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|arg_v
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getnetnum
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|u_int32
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|help
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|QSORT_USES_VOID_P
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|helpsort
name|P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|helpsort
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|printusage
name|P
argument_list|(
operator|(
expr|struct
name|xcmd
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|timeout
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|my_delay
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|host
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|keyid
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|keytype
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|passwd
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hostnames
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setdebug
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|quit
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|version
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warning
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|getkeyid
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Built-in commands we understand  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|xcmd
name|builtins
index|[]
init|=
block|{
block|{
literal|"?"
block|,
name|help
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"command"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"tell the use and syntax of commands"
block|}
block|,
block|{
literal|"help"
block|,
name|help
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"command"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"tell the use and syntax of commands"
block|}
block|,
block|{
literal|"timeout"
block|,
name|timeout
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"msec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the primary receive time out"
block|}
block|,
block|{
literal|"delay"
block|,
name|my_delay
block|,
block|{
name|OPT
operator||
name|INT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"msec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the delay added to encryption time stamps"
block|}
block|,
block|{
literal|"host"
block|,
name|host
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"hostname"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify the host whose NTP server we talk to"
block|}
block|,
block|{
literal|"passwd"
block|,
name|passwd
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify a password to use for authenticated requests"
block|}
block|,
block|{
literal|"hostnames"
block|,
name|hostnames
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"yes|no"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify whether hostnames or net numbers are printed"
block|}
block|,
block|{
literal|"debug"
block|,
name|setdebug
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"no|more|less"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set/change debugging level"
block|}
block|,
block|{
literal|"quit"
block|,
name|quit
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"exit ntpdc"
block|}
block|,
block|{
literal|"exit"
block|,
name|quit
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"exit ntpdc"
block|}
block|,
block|{
literal|"keyid"
block|,
name|keyid
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"key#"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set/show keyid to use for authenticated requests"
block|}
block|,
block|{
literal|"keytype"
block|,
name|keytype
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"(md5|des)"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set/show key authentication type for authenticated requests (des|md5)"
block|}
block|,
block|{
literal|"version"
block|,
name|version
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print version number"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default values we use.  */
end_comment

begin_define
define|#
directive|define
name|DEFTIMEOUT
value|(5)
end_define

begin_comment
comment|/* 5 second time out */
end_comment

begin_define
define|#
directive|define
name|DEFSTIMEOUT
value|(2)
end_define

begin_comment
comment|/* 2 second time out after first */
end_comment

begin_define
define|#
directive|define
name|DEFDELAY
value|0x51EB852
end_define

begin_comment
comment|/* 20 milliseconds, l_fp fraction */
end_comment

begin_define
define|#
directive|define
name|DEFHOST
value|"localhost"
end_define

begin_comment
comment|/* default host name */
end_comment

begin_define
define|#
directive|define
name|LENHOSTNAME
value|256
end_define

begin_comment
comment|/* host name is 256 characters long */
end_comment

begin_define
define|#
directive|define
name|MAXCMDS
value|100
end_define

begin_comment
comment|/* maximum commands on cmd line */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTS
value|200
end_define

begin_comment
comment|/* maximum hosts on cmd line */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|512
end_define

begin_comment
comment|/* maximum line length */
end_comment

begin_define
define|#
directive|define
name|MAXTOKENS
value|(1+MAXARGS+2)
end_define

begin_comment
comment|/* maximum number of usable tokens */
end_comment

begin_comment
comment|/*  * Some variables used and manipulated locally  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|tvout
init|=
block|{
name|DEFTIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time out for reads */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|tvsout
init|=
block|{
name|DEFSTIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* secondary time out */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|delay_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delay time */
end_comment

begin_decl_stmt
specifier|static
name|char
name|currenthost
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current host name */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|hostaddr
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host address */
end_comment

begin_decl_stmt
specifier|static
name|int
name|showhostnames
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show host names by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sockfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fd socket is openned on */
end_comment

begin_decl_stmt
specifier|static
name|int
name|havehost
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when host open */
end_comment

begin_decl_stmt
name|struct
name|servent
modifier|*
name|server_entry
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* server entry for ntp */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
end_if

begin_decl_stmt
name|char
name|password
index|[
literal|9
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT || SYS_VXWORKS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_decl_stmt
name|WORD
name|wVersionRequested
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WSADATA
name|wsaData
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DWORD
name|NumberOfBytesWritten
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HANDLE
name|TimerThreadHandle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1998/06/03 - Used in ntplib/machines.c */
end_comment

begin_function
name|void
name|timer
parameter_list|(
name|void
parameter_list|)
block|{
empty_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* 1998/06/03 - Used in ntplib/machines.c */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * Holds data returned from queries.  We allocate INITDATASIZE  * octets to begin with, increasing this as we need to.  */
end_comment

begin_define
define|#
directive|define
name|INITDATASIZE
value|(sizeof(struct resp_pkt) * 16)
end_define

begin_define
define|#
directive|define
name|INCDATASIZE
value|(sizeof(struct resp_pkt) * 8)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pktdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pktdatasize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For commands typed on the command line (with the -c option)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numcmds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ccmds
index|[
name|MAXCMDS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDCMD
parameter_list|(
name|cp
parameter_list|)
value|if (numcmds< MAXCMDS) ccmds[numcmds++] = (cp)
end_define

begin_comment
comment|/*  * When multiple hosts are specified.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numhosts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|chosts
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDHOST
parameter_list|(
name|cp
parameter_list|)
value|if (numhosts< MAXHOSTS) chosts[numhosts++] = (cp)
end_define

begin_comment
comment|/*  * Error codes for internal use  */
end_comment

begin_define
define|#
directive|define
name|ERR_INCOMPLETE
value|16
end_define

begin_define
define|#
directive|define
name|ERR_TIMEOUT
value|17
end_define

begin_comment
comment|/*  * Macro definitions we use  */
end_comment

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '\n' || (c) == '\r' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * For converting time stamps to dates  */
end_comment

begin_define
define|#
directive|define
name|JAN_1970
value|2208988800
end_define

begin_comment
comment|/* 1970 - 1900 in seconds */
end_comment

begin_comment
comment|/*  * Jump buffer for longjumping back to the command level  */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|interrupt_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|jump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pointer to current output unit  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|current_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Command table imported from ntpdc_ops.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|xcmd
name|opcmds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_MAIN_ALLOWED
end_ifdef

begin_expr_stmt
name|CALL
argument_list|(
name|ntpdc
argument_list|,
literal|"ntpdc"
argument_list|,
name|ntpdcmain
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
return|return
name|ntpdcmain
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_VXWORKS
end_ifdef

begin_function
name|void
name|clear_globals
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ntp_optarg
decl_stmt|;
name|showhostnames
operator|=
literal|0
expr_stmt|;
comment|/* show host names by default */
name|ntp_optind
operator|=
literal|0
expr_stmt|;
name|ntp_optarg
operator|=
literal|0
expr_stmt|;
name|server_entry
operator|=
name|NULL
expr_stmt|;
comment|/* server entry for ntp */
name|havehost
operator|=
literal|0
expr_stmt|;
comment|/* set to 1 when host open */
name|numcmds
operator|=
literal|0
expr_stmt|;
name|numhosts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * main - parse arguments and handle options  */
end_comment

begin_function
name|int
name|ntpdcmain
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ntp_optarg
decl_stmt|;
name|delay_time
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|delay_time
operator|.
name|l_uf
operator|=
name|DEFDELAY
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_VXWORKS
name|clear_globals
argument_list|()
expr_stmt|;
name|taskPrioritySet
argument_list|(
name|taskIdSelf
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:dilnps"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|ADDCMD
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ADDCMD
argument_list|(
literal|"listpeers"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|showhostnames
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ADDCMD
argument_list|(
literal|"peers"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ADDCMD
argument_list|(
literal|"dmpeers"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errflg
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-dilnps] [-c cmd] host ...\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntp_optind
operator|==
name|argc
condition|)
block|{
name|ADDHOST
argument_list|(
name|DEFHOST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|ntp_optind
operator|<
name|argc
condition|;
name|ntp_optind
operator|++
control|)
name|ADDHOST
argument_list|(
name|argv
index|[
name|ntp_optind
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numcmds
operator|==
literal|0
operator|&&
name|interactive
operator|==
literal|0
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
block|{
name|interactive
operator|=
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* Under NT cannot handle SIGINT, WIN32 spawns a handler */
if|if
condition|(
name|interactive
condition|)
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGINT
argument_list|,
name|abortcmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Initialize the packet data buffer 	 */
name|pktdata
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|INITDATASIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktdata
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: malloc() failed!\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pktdatasize
operator|=
name|INITDATASIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|wVersionRequested
operator|=
name|MAKEWORD
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No useable winsock.dll"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
if|if
condition|(
name|numcmds
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|openhost
argument_list|(
name|chosts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|getcmds
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|ihost
decl_stmt|;
name|int
name|icmd
decl_stmt|;
for|for
control|(
name|ihost
operator|=
literal|0
init|;
name|ihost
operator|<
name|numhosts
condition|;
name|ihost
operator|++
control|)
block|{
if|if
condition|(
name|openhost
argument_list|(
name|chosts
index|[
name|ihost
index|]
argument_list|)
condition|)
for|for
control|(
name|icmd
operator|=
literal|0
init|;
name|icmd
operator|<
name|numcmds
condition|;
name|icmd
operator|++
control|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"--- %s ---\n"
argument_list|,
name|chosts
index|[
name|ihost
index|]
argument_list|)
expr_stmt|;
name|docmd
argument_list|(
name|ccmds
index|[
name|icmd
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|SYS_WINNT
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* main end */
end_comment

begin_comment
comment|/*  * openhost - open a socket to a host  */
end_comment

begin_function
specifier|static
name|int
name|openhost
parameter_list|(
specifier|const
name|char
modifier|*
name|hname
parameter_list|)
block|{
name|u_int32
name|netnum
decl_stmt|;
name|char
name|temphost
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
if|if
condition|(
name|server_entry
operator|==
name|NULL
condition|)
block|{
name|server_entry
operator|=
name|getservbyname
argument_list|(
literal|"ntp"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_entry
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
comment|/* UCX getservbyname() doesn't work [yet], but we do know better */
name|server_entry
operator|=
operator|(
expr|struct
name|servent
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|servent
argument_list|)
argument_list|)
expr_stmt|;
name|server_entry
operator|->
name|s_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ntp/udp: unknown service\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS& UCX */
block|}
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Got ntp/udp service entry\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|hname
argument_list|,
operator|&
name|netnum
argument_list|,
name|temphost
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Opening host %s\n"
argument_list|,
name|temphost
argument_list|)
expr_stmt|;
if|if
condition|(
name|havehost
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Closing old host %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|havehost
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|currenthost
argument_list|,
name|temphost
argument_list|)
expr_stmt|;
name|hostaddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_VXWORKS
name|hostaddr
operator|.
name|sin_port
operator|=
name|server_entry
operator|->
name|s_port
expr_stmt|;
else|#
directive|else
name|hostaddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|SERVER_PORT_NUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hostaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|netnum
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
block|{
name|int
name|optionValue
init|=
name|SO_SYNCHRONOUS_NONALERT
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|setsockopt
argument_list|(
name|INVALID_SOCKET
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_OPENTYPE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|optionValue
argument_list|,
sizeof|sizeof
argument_list|(
name|optionValue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NO_ERROR
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open nonoverlapped sockets\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|error
argument_list|(
literal|"socket"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|sockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"socket"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
ifdef|#
directive|ifdef
name|NEED_RCVBUF_SLOP
ifdef|#
directive|ifdef
name|SO_RCVBUF
block|{
name|int
name|rbufsize
init|=
name|INITDATASIZE
operator|+
literal|2048
decl_stmt|;
comment|/* 2K for slop */
if|if
condition|(
name|setsockopt
argument_list|(
name|sockfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|rbufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"setsockopt"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|hostaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|hostaddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"connect"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|havehost
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE sendpkt similar in ntpq.c, ntpdc.c, ntp_io.c, ntptrace.c */
end_comment

begin_comment
comment|/*  * sendpkt - send a packet to the remote host  */
end_comment

begin_function
specifier|static
name|int
name|sendpkt
parameter_list|(
name|char
modifier|*
name|xdata
parameter_list|,
name|int
name|xdatalen
parameter_list|)
block|{
if|if
condition|(
name|send
argument_list|(
name|sockfd
argument_list|,
name|xdata
argument_list|,
operator|(
name|size_t
operator|)
name|xdatalen
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"write to %s failed"
argument_list|,
name|currenthost
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * growpktdata - grow the packet data area  */
end_comment

begin_function
specifier|static
name|void
name|growpktdata
parameter_list|(
name|void
parameter_list|)
block|{
name|pktdatasize
operator|+=
name|INCDATASIZE
expr_stmt|;
name|pktdata
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pktdata
argument_list|,
operator|(
name|unsigned
operator|)
name|pktdatasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktdata
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: realloc() failed!\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * getresponse - get a (series of) response packet(s) and return the data  */
end_comment

begin_function
specifier|static
name|int
name|getresponse
parameter_list|(
name|int
name|implcode
parameter_list|,
name|int
name|reqcode
parameter_list|,
name|int
modifier|*
name|ritems
parameter_list|,
name|int
modifier|*
name|rsize
parameter_list|,
name|char
modifier|*
modifier|*
name|rdata
parameter_list|)
block|{
name|struct
name|resp_pkt
name|rpkt
decl_stmt|;
name|struct
name|timeval
name|tvo
decl_stmt|;
name|int
name|items
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|datasize
decl_stmt|;
name|char
modifier|*
name|datap
decl_stmt|;
name|char
name|haveseq
index|[
name|MAXSEQ
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|firstpkt
decl_stmt|;
name|int
name|lastseq
decl_stmt|;
name|int
name|numrecv
decl_stmt|;
name|int
name|seq
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* 	 * This is pretty tricky.  We may get between 1 and many packets 	 * back in response to the request.  We peel the data out of 	 * each packet and collect it in one long block.  When the last 	 * packet in the sequence is received we'll know how many we 	 * should have had.  Note we use one long time out, should reconsider. 	 */
operator|*
name|ritems
operator|=
literal|0
expr_stmt|;
operator|*
name|rsize
operator|=
literal|0
expr_stmt|;
name|firstpkt
operator|=
literal|1
expr_stmt|;
name|numrecv
operator|=
literal|0
expr_stmt|;
operator|*
name|rdata
operator|=
name|datap
operator|=
name|pktdata
expr_stmt|;
name|lastseq
operator|=
literal|999
expr_stmt|;
comment|/* too big to be a sequence number */
name|memset
argument_list|(
name|haveseq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|haveseq
argument_list|)
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|firstpkt
condition|)
name|tvo
operator|=
name|tvout
expr_stmt|;
else|else
name|tvo
operator|=
name|tvsout
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvo
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"select fails"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Timed out.  Return what we have 		 */
if|if
condition|(
name|firstpkt
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timed out, nothing received\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
return|return
name|ERR_TIMEOUT
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timed out with incomplete data\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"Received sequence numbers"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|MAXSEQ
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|haveseq
index|[
name|n
index|]
condition|)
name|printf
argument_list|(
literal|" %d,"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastseq
operator|!=
literal|999
condition|)
name|printf
argument_list|(
literal|" last frame received\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" last frame not received\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ERR_INCOMPLETE
return|;
block|}
block|}
name|n
operator|=
name|recv
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"read"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Check for format errors.  Bug proofing. 	 */
if|if
condition|(
name|n
operator|<
name|RESP_HEADER_SIZE
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Short (%d byte) packet received\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|INFO_VERSION
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
operator|||
name|INFO_VERSION
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|<
name|NTP_OLDVERSION
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Packet received with version %d\n"
argument_list|,
name|INFO_VERSION
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|INFO_MODE
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|!=
name|MODE_PRIVATE
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Packet received with mode %d\n"
argument_list|,
name|INFO_MODE
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|INFO_IS_AUTH
argument_list|(
name|rpkt
operator|.
name|auth_seq
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Encrypted packet received\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
operator|!
name|ISRESPONSE
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received request packet, wanted response\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|INFO_MBZ
argument_list|(
name|rpkt
operator|.
name|mbz_itemsize
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received packet with nonzero MBZ field!\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Check implementation/request.  Could be old data getting to us. 	 */
if|if
condition|(
name|rpkt
operator|.
name|implementation
operator|!=
name|implcode
operator|||
name|rpkt
operator|.
name|request
operator|!=
name|reqcode
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received implementation/request of %d/%d, wanted %d/%d"
argument_list|,
name|rpkt
operator|.
name|implementation
argument_list|,
name|rpkt
operator|.
name|request
argument_list|,
name|implcode
argument_list|,
name|reqcode
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Check the error code.  If non-zero, return it. 	 */
if|if
condition|(
name|INFO_ERR
argument_list|(
name|rpkt
operator|.
name|err_nitems
argument_list|)
operator|!=
name|INFO_OKAY
condition|)
block|{
if|if
condition|(
name|debug
operator|&&
name|ISMORE
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error code %d received on not-final packet\n"
argument_list|,
name|INFO_ERR
argument_list|(
name|rpkt
operator|.
name|err_nitems
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|INFO_ERR
argument_list|(
name|rpkt
operator|.
name|err_nitems
argument_list|)
return|;
block|}
comment|/* 	 * Collect items and size.  Make sure they make sense. 	 */
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|rpkt
operator|.
name|err_nitems
argument_list|)
expr_stmt|;
name|size
operator|=
name|INFO_ITEMSIZE
argument_list|(
name|rpkt
operator|.
name|mbz_itemsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|datasize
operator|=
name|items
operator|*
name|size
operator|)
operator|>
operator|(
name|n
operator|-
name|RESP_HEADER_SIZE
operator|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received items %d, size %d (total %d), data in packet is %d\n"
argument_list|,
name|items
argument_list|,
name|size
argument_list|,
name|datasize
argument_list|,
name|n
operator|-
name|RESP_HEADER_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * If this isn't our first packet, make sure the size matches 	 * the other ones. 	 */
if|if
condition|(
operator|!
name|firstpkt
operator|&&
name|size
operator|!=
operator|*
name|rsize
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received itemsize %d, previous %d\n"
argument_list|,
name|size
argument_list|,
operator|*
name|rsize
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * If we've received this before, toss it 	 */
name|seq
operator|=
name|INFO_SEQ
argument_list|(
name|rpkt
operator|.
name|auth_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|haveseq
index|[
name|seq
index|]
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received duplicate sequence number %d\n"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|haveseq
index|[
name|seq
index|]
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If this is the last in the sequence, record that. 	 */
if|if
condition|(
operator|!
name|ISMORE
argument_list|(
name|rpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastseq
operator|!=
literal|999
condition|)
block|{
name|printf
argument_list|(
literal|"Received second end sequence packet\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|lastseq
operator|=
name|seq
expr_stmt|;
block|}
comment|/* 	 * So far, so good.  Copy this data into the output array. 	 */
if|if
condition|(
operator|(
name|datap
operator|+
name|datasize
operator|)
operator|>
operator|(
name|pktdata
operator|+
name|pktdatasize
operator|)
condition|)
block|{
name|int
name|offset
init|=
name|datap
operator|-
name|pktdata
decl_stmt|;
name|growpktdata
argument_list|()
expr_stmt|;
operator|*
name|rdata
operator|=
name|pktdata
expr_stmt|;
comment|/* might have been realloced ! */
name|datap
operator|=
name|pktdata
operator|+
name|offset
expr_stmt|;
block|}
name|memmove
argument_list|(
name|datap
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|.
name|data
argument_list|,
operator|(
name|unsigned
operator|)
name|datasize
argument_list|)
expr_stmt|;
name|datap
operator|+=
name|datasize
expr_stmt|;
if|if
condition|(
name|firstpkt
condition|)
block|{
name|firstpkt
operator|=
literal|0
expr_stmt|;
operator|*
name|rsize
operator|=
name|size
expr_stmt|;
block|}
operator|*
name|ritems
operator|+=
name|items
expr_stmt|;
comment|/* 	 * Finally, check the count of received packets.  If we've got them 	 * all, return 	 */
operator|++
name|numrecv
expr_stmt|;
if|if
condition|(
name|numrecv
operator|<=
name|lastseq
condition|)
goto|goto
name|again
goto|;
return|return
name|INFO_OKAY
return|;
block|}
end_function

begin_comment
comment|/*  * sendrequest - format and send a request packet  */
end_comment

begin_function
specifier|static
name|int
name|sendrequest
parameter_list|(
name|int
name|implcode
parameter_list|,
name|int
name|reqcode
parameter_list|,
name|int
name|auth
parameter_list|,
name|int
name|qitems
parameter_list|,
name|int
name|qsize
parameter_list|,
name|char
modifier|*
name|qdata
parameter_list|)
block|{
name|struct
name|req_pkt
name|qpkt
decl_stmt|;
name|int
name|datasize
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|qpkt
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|rm_vn_mode
operator|=
name|RM_VN_MODE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|implementation
operator|=
operator|(
name|u_char
operator|)
name|implcode
expr_stmt|;
name|qpkt
operator|.
name|request
operator|=
operator|(
name|u_char
operator|)
name|reqcode
expr_stmt|;
name|datasize
operator|=
name|qitems
operator|*
name|qsize
expr_stmt|;
if|if
condition|(
name|datasize
operator|!=
literal|0
operator|&&
name|qdata
operator|!=
name|NULL
condition|)
block|{
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qpkt
operator|.
name|data
argument_list|,
name|qdata
argument_list|,
operator|(
name|unsigned
operator|)
name|datasize
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|err_nitems
operator|=
name|ERR_NITEMS
argument_list|(
literal|0
argument_list|,
name|qitems
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|mbz_itemsize
operator|=
name|MBZ_ITEMSIZE
argument_list|(
name|qsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qpkt
operator|.
name|err_nitems
operator|=
name|ERR_NITEMS
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|mbz_itemsize
operator|=
name|MBZ_ITEMSIZE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|auth
condition|)
block|{
name|qpkt
operator|.
name|auth_seq
operator|=
name|AUTH_SEQ
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|sendpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
name|REQ_LEN_NOMAC
argument_list|)
return|;
block|}
else|else
block|{
name|l_fp
name|ts
decl_stmt|;
name|int
name|maclen
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|pass
init|=
literal|"\0"
decl_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
name|maclen
operator|=
name|getkeyid
argument_list|(
literal|"Keyid: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|maclen
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid key identifier\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|info_auth_keyid
operator|=
name|maclen
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|info_auth_keyid
argument_list|)
condition|)
block|{
name|pass
operator|=
name|getpass
argument_list|(
operator|(
name|info_auth_keytype
operator|==
name|KEY_TYPE_DES
operator|)
condition|?
literal|"DES Password: "
else|:
literal|"MD5 Password: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pass
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid password\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|pass
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|info_auth_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|auth_seq
operator|=
name|AUTH_SEQ
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|keyid
operator|=
name|htonl
argument_list|(
name|info_auth_keyid
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|delay_time
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|qpkt
operator|.
name|tstamp
argument_list|)
expr_stmt|;
name|maclen
operator|=
name|authencrypt
argument_list|(
name|info_auth_keyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
name|REQ_LEN_NOMAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|maclen
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Key not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
name|sendpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
call|(
name|int
call|)
argument_list|(
name|REQ_LEN_NOMAC
operator|+
name|maclen
argument_list|)
argument_list|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * doquery - send a request and process the response  */
end_comment

begin_function
name|int
name|doquery
parameter_list|(
name|int
name|implcode
parameter_list|,
name|int
name|reqcode
parameter_list|,
name|int
name|auth
parameter_list|,
name|int
name|qitems
parameter_list|,
name|int
name|qsize
parameter_list|,
name|char
modifier|*
name|qdata
parameter_list|,
name|int
modifier|*
name|ritems
parameter_list|,
name|int
modifier|*
name|rsize
parameter_list|,
name|char
modifier|*
modifier|*
name|rdata
parameter_list|,
name|int
name|quiet_mask
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|char
name|junk
index|[
literal|512
index|]
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|struct
name|timeval
name|tvzero
decl_stmt|;
comment|/* 	 * Check to make sure host is open 	 */
if|if
condition|(
operator|!
name|havehost
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No host open, use `host' command\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Poll the socket and clear out any pending data 	 */
do|do
block|{
name|tvzero
operator|.
name|tv_sec
operator|=
name|tvzero
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|res
operator|=
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvzero
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"polling select"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|res
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|recv
argument_list|(
name|sockfd
argument_list|,
name|junk
argument_list|,
sizeof|sizeof
name|junk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|res
operator|>
literal|0
condition|)
do|;
comment|/* 	 * send a request 	 */
name|res
operator|=
name|sendrequest
argument_list|(
name|implcode
argument_list|,
name|reqcode
argument_list|,
name|auth
argument_list|,
name|qitems
argument_list|,
name|qsize
argument_list|,
name|qdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|res
return|;
comment|/* 	 * Get the response.  If we got a standard error, print a message 	 */
name|res
operator|=
name|getresponse
argument_list|(
name|implcode
argument_list|,
name|reqcode
argument_list|,
name|ritems
argument_list|,
name|rsize
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
comment|/* log error message if not told to be quiet */
if|if
condition|(
operator|(
name|res
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
literal|1
operator|<<
name|res
operator|)
operator|&
name|quiet_mask
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|INFO_ERR_IMPL
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server implementation incompatable with our own\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INFO_ERR_REQ
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server doesn't implement this request\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INFO_ERR_FMT
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server reports a format error in the received packet (shouldn't happen)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INFO_ERR_NODATA
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server reports data not found\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INFO_ERR_AUTH
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Permission denied\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_TIMEOUT
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Request timed out\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_INCOMPLETE
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Response from server was incomplete\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returns unknown error code %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * getcmds - read commands from the standard input and execute them  */
end_comment

begin_function
specifier|static
name|void
name|getcmds
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LIBREADLINE
name|char
modifier|*
name|line
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|line
operator|=
name|readline
argument_list|(
name|interactive
condition|?
name|prompt
else|:
literal|""
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|*
name|line
condition|)
name|add_history
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|docmd
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not HAVE_LIBREADLINE */
name|char
name|line
index|[
name|MAXLINE
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|interactive
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
comment|/* work around a problem with mixing stdout& stderr */
name|fputs
argument_list|(
literal|""
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|prompt
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|docmd
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not HAVE_LIBREADLINE */
block|}
end_function

begin_comment
comment|/*  * abortcmd - catch interrupts and abort the current command  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|abortcmd
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|current_output
operator|==
name|stdout
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
name|longjmp
argument_list|(
name|interrupt_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * docmd - decode the command line and execute a command  */
end_comment

begin_function
specifier|static
name|void
name|docmd
parameter_list|(
specifier|const
name|char
modifier|*
name|cmdline
parameter_list|)
block|{
name|char
modifier|*
name|tokens
index|[
literal|1
operator|+
name|MAXARGS
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|parse
name|pcmd
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|static
name|int
name|i
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|xcmd
decl_stmt|;
comment|/* 	 * Tokenize the command line.  If nothing on it, return. 	 */
name|tokenize
argument_list|(
name|cmdline
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Find the appropriate command description. 	 */
name|i
operator|=
name|findcmd
argument_list|(
name|tokens
index|[
literal|0
index|]
argument_list|,
name|builtins
argument_list|,
name|opcmds
argument_list|,
operator|&
name|xcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command `%s' unknown\n"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command `%s' ambiguous\n"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Save the keyword, then walk through the arguments, interpreting 	 * as we go. 	 */
name|pcmd
operator|.
name|keyword
operator|=
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|pcmd
operator|.
name|nargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
operator|&&
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|NO
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|>=
name|ntok
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
operator|)
condition|)
block|{
name|printusage
argument_list|(
name|xcmd
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
operator|)
operator|&&
operator|(
operator|*
name|tokens
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'>'
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|getarg
argument_list|(
name|tokens
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
argument_list|,
operator|&
name|pcmd
operator|.
name|argval
index|[
name|i
index|]
argument_list|)
condition|)
return|return;
name|pcmd
operator|.
name|nargs
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ntok
operator|&&
operator|*
name|tokens
index|[
name|i
index|]
operator|==
literal|'>'
condition|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|tokens
index|[
name|i
index|]
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|fname
operator|=
name|tokens
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|ntok
condition|)
name|fname
operator|=
name|tokens
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No file for redirect\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|current_output
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_output
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Error opening %s: "
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|1
expr_stmt|;
comment|/* flag we need a close */
block|}
else|else
block|{
name|current_output
operator|=
name|stdout
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* flag no close */
block|}
if|if
condition|(
name|interactive
operator|&&
name|setjmp
argument_list|(
name|interrupt_buf
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|jump
operator|=
literal|1
expr_stmt|;
call|(
name|xcmd
operator|->
name|handler
call|)
argument_list|(
operator|&
name|pcmd
argument_list|,
name|current_output
argument_list|)
expr_stmt|;
name|jump
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|current_output
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * tokenize - turn a command line into tokens  */
end_comment

begin_function
specifier|static
name|void
name|tokenize
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
modifier|*
name|tokens
parameter_list|,
name|int
modifier|*
name|ntok
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|static
name|char
name|tspace
index|[
name|MAXLINE
index|]
decl_stmt|;
name|sp
operator|=
name|tspace
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
for|for
control|(
operator|*
name|ntok
operator|=
literal|0
init|;
operator|*
name|ntok
operator|<
name|MAXTOKENS
condition|;
operator|(
operator|*
name|ntok
operator|)
operator|++
control|)
block|{
name|tokens
index|[
operator|*
name|ntok
index|]
operator|=
name|sp
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
do|do
block|{
operator|*
name|sp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
operator|*
name|sp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * findcmd - find a command in a command description table  */
end_comment

begin_function
specifier|static
name|int
name|findcmd
parameter_list|(
specifier|register
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|xcmd
modifier|*
name|clist1
parameter_list|,
name|struct
name|xcmd
modifier|*
name|clist2
parameter_list|,
name|struct
name|xcmd
modifier|*
modifier|*
name|cmd
parameter_list|)
block|{
specifier|register
name|struct
name|xcmd
modifier|*
name|cl
decl_stmt|;
specifier|register
name|int
name|clen
decl_stmt|;
name|int
name|nmatch
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|nearmatch
init|=
name|NULL
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|clist
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|nmatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clist1
operator|!=
literal|0
condition|)
name|clist
operator|=
name|clist1
expr_stmt|;
elseif|else
if|if
condition|(
name|clist2
operator|!=
literal|0
condition|)
name|clist
operator|=
name|clist2
expr_stmt|;
else|else
return|return
literal|0
return|;
name|again
label|:
for|for
control|(
name|cl
operator|=
name|clist
init|;
name|cl
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|cl
operator|++
control|)
block|{
comment|/* do a first character check, for efficiency */
if|if
condition|(
operator|*
name|str
operator|!=
operator|*
operator|(
name|cl
operator|->
name|keyword
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|cl
operator|->
name|keyword
argument_list|,
operator|(
name|unsigned
operator|)
name|clen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Could be extact match, could be approximate. 			 * Is exact if the length of the keyword is the 			 * same as the str. 			 */
if|if
condition|(
operator|*
operator|(
operator|(
name|cl
operator|->
name|keyword
operator|)
operator|+
name|clen
operator|)
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|cmd
operator|=
name|cl
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nmatch
operator|++
expr_stmt|;
name|nearmatch
operator|=
name|cl
expr_stmt|;
block|}
block|}
comment|/* 				 * See if there is more to do.  If so, go again.  Sorry about the 				 * goto, too much looking at BSD sources... 				 */
if|if
condition|(
name|clist
operator|==
name|clist1
operator|&&
name|clist2
operator|!=
literal|0
condition|)
block|{
name|clist
operator|=
name|clist2
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 				 * If we got extactly 1 near match, use it, else return number 				 * of matches. 				 */
if|if
condition|(
name|nmatch
operator|==
literal|1
condition|)
block|{
operator|*
name|cmd
operator|=
name|nearmatch
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|nmatch
return|;
block|}
end_function

begin_comment
comment|/*  * getarg - interpret an argument token  */
end_comment

begin_function
specifier|static
name|int
name|getarg
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|code
parameter_list|,
name|arg_v
modifier|*
name|argp
parameter_list|)
block|{
name|int
name|isneg
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|digits
init|=
literal|"0123456789"
decl_stmt|;
switch|switch
condition|(
name|code
operator|&
operator|~
name|OPT
condition|)
block|{
case|case
name|NTP_STR
case|:
name|argp
operator|->
name|string
operator|=
name|str
expr_stmt|;
break|break;
case|case
name|ADD
case|:
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|str
argument_list|,
operator|&
operator|(
name|argp
operator|->
name|netnum
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
break|break;
case|case
name|INT
case|:
case|case
name|UINT
case|:
name|isneg
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|'-'
condition|)
block|{
name|np
operator|++
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
name|argp
operator|->
name|uval
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|digits
argument_list|,
operator|*
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Illegal integer value %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argp
operator|->
name|uval
operator|*=
literal|10
expr_stmt|;
name|argp
operator|->
name|uval
operator|+=
operator|(
name|cp
operator|-
name|digits
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|(
operator|++
name|np
operator|)
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|isneg
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|&
operator|~
name|OPT
operator|)
operator|==
name|UINT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Value %s should be unsigned\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argp
operator|->
name|ival
operator|=
operator|-
name|argp
operator|->
name|ival
expr_stmt|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * getnetnum - given a host name, return its net number  *	       and (optional) full name  */
end_comment

begin_function
specifier|static
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|hname
parameter_list|,
name|u_int32
modifier|*
name|num
parameter_list|,
name|char
modifier|*
name|fullhost
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|decodenetnum
argument_list|(
name|hname
argument_list|,
name|num
argument_list|)
condition|)
block|{
if|if
condition|(
name|fullhost
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fullhost
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
call|(
name|u_int
call|)
argument_list|(
operator|(
name|htonl
argument_list|(
operator|*
name|num
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|u_int
call|)
argument_list|(
operator|(
name|htonl
argument_list|(
operator|*
name|num
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|u_int
call|)
argument_list|(
operator|(
name|htonl
argument_list|(
operator|*
name|num
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|htonl
argument_list|(
operator|*
name|num
argument_list|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hname
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullhost
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fullhost
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Can't find host %s\n"
argument_list|,
name|hname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * nntohost - convert network number to host name.  This routine enforces  *	       the showhostnames setting.  */
end_comment

begin_function
name|char
modifier|*
name|nntohost
parameter_list|(
name|u_int32
name|netnum
parameter_list|)
block|{
if|if
condition|(
operator|!
name|showhostnames
condition|)
return|return
name|numtoa
argument_list|(
name|netnum
argument_list|)
return|;
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|netnum
argument_list|)
operator|&
name|REFCLOCK_MASK
operator|)
operator|==
name|REFCLOCK_ADDR
condition|)
return|return
name|refnumtoa
argument_list|(
name|netnum
argument_list|)
return|;
return|return
name|numtohost
argument_list|(
name|netnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finally, the built in command handlers  */
end_comment

begin_comment
comment|/*  * help - tell about commands, or details of a particular command  */
end_comment

begin_function
specifier|static
name|void
name|help
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|xcp
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmdsort
index|[
literal|100
index|]
decl_stmt|;
name|int
name|length
index|[
literal|100
index|]
decl_stmt|;
name|int
name|maxlength
decl_stmt|;
name|int
name|numperline
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|spaces
init|=
literal|"                    "
decl_stmt|;
comment|/* 20 spaces */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|xcp
operator|=
name|builtins
init|;
name|xcp
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|xcp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|xcp
operator|->
name|keyword
operator|)
operator|!=
literal|'?'
condition|)
name|cmdsort
index|[
name|n
operator|++
index|]
operator|=
name|xcp
operator|->
name|keyword
expr_stmt|;
block|}
for|for
control|(
name|xcp
operator|=
name|opcmds
init|;
name|xcp
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|xcp
operator|++
control|)
name|cmdsort
index|[
name|n
operator|++
index|]
operator|=
name|xcp
operator|->
name|keyword
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_USES_VOID_P
name|qsort
argument_list|(
name|cmdsort
argument_list|,
operator|(
name|size_t
operator|)
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|helpsort
argument_list|)
expr_stmt|;
else|#
directive|else
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdsort
argument_list|,
operator|(
name|size_t
operator|)
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|helpsort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maxlength
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|length
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|cmdsort
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
index|[
name|i
index|]
operator|>
name|maxlength
condition|)
name|maxlength
operator|=
name|length
index|[
name|i
index|]
expr_stmt|;
block|}
name|maxlength
operator|++
expr_stmt|;
name|numperline
operator|=
literal|76
operator|/
name|maxlength
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Commands available:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
name|numperline
operator|)
operator|==
operator|(
name|numperline
operator|-
literal|1
operator|)
operator|||
name|i
operator|==
operator|(
name|n
operator|-
literal|1
operator|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|cmdsort
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s"
argument_list|,
name|cmdsort
index|[
name|i
index|]
argument_list|,
name|spaces
operator|+
literal|20
operator|-
name|maxlength
operator|+
name|length
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cmd
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
name|n
operator|=
name|findcmd
argument_list|(
name|cmd
argument_list|,
name|builtins
argument_list|,
name|opcmds
argument_list|,
operator|&
name|xcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command `%s' is unknown\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|n
operator|>=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command `%s' is ambiguous\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"function: %s\n"
argument_list|,
name|xcp
operator|->
name|comment
argument_list|)
expr_stmt|;
name|printusage
argument_list|(
name|xcp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * helpsort - do hostname qsort comparisons  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|QSORT_USES_VOID_P
end_ifdef

begin_function
specifier|static
name|int
name|helpsort
parameter_list|(
specifier|const
name|void
modifier|*
name|t1
parameter_list|,
specifier|const
name|void
modifier|*
name|t2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|name1
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|t1
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|name2
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|t2
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|*
name|name1
argument_list|,
operator|*
name|name2
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|helpsort
parameter_list|(
name|char
modifier|*
modifier|*
name|name1
parameter_list|,
name|char
modifier|*
modifier|*
name|name2
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|*
name|name1
argument_list|,
operator|*
name|name2
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * printusage - print usage information for a command  */
end_comment

begin_function
specifier|static
name|void
name|printusage
parameter_list|(
name|struct
name|xcmd
modifier|*
name|xcp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"usage: %s"
argument_list|,
name|xcp
operator|->
name|keyword
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
operator|&&
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|NO
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" [ %s ]"
argument_list|,
name|xcp
operator|->
name|desc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s"
argument_list|,
name|xcp
operator|->
name|desc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * timeout - set time out time  */
end_comment

begin_function
specifier|static
name|void
name|timeout
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|tvout
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tvout
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"primary timeout %d ms\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tvout
operator|.
name|tv_sec
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|/
literal|1000
expr_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
operator|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|-
operator|(
name|tvout
operator|.
name|tv_sec
operator|*
literal|1000
operator|)
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * my_delay - set delay for auth requests  */
end_comment

begin_function
specifier|static
name|void
name|my_delay
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|isneg
decl_stmt|;
name|u_long
name|val
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|delay_time
operator|.
name|l_ui
operator|*
literal|1000
operator|+
name|delay_time
operator|.
name|l_uf
operator|/
literal|4294967
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"delay %lu ms\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|val
operator|=
call|(
name|u_long
call|)
argument_list|(
operator|-
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isneg
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
name|u_long
operator|)
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
expr_stmt|;
block|}
name|delay_time
operator|.
name|l_ui
operator|=
name|val
operator|/
literal|1000
expr_stmt|;
name|val
operator|%=
literal|1000
expr_stmt|;
name|delay_time
operator|.
name|l_uf
operator|=
name|val
operator|*
literal|4294967
expr_stmt|;
comment|/* 2**32/1000 */
if|if
condition|(
name|isneg
condition|)
name|L_NEG
argument_list|(
operator|&
name|delay_time
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * host - set the host we are dealing with.  */
end_comment

begin_function
specifier|static
name|void
name|host
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host is %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no current host\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|openhost
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host set to %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host remains %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"still no current host\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * keyid - get a keyid to use for authenticating requests  */
end_comment

begin_function
specifier|static
name|void
name|keyid
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no keyid defined\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keyid is %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|info_auth_keyid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info_auth_keyid
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * keytype - get type of key to use for authenticating requests  */
end_comment

begin_function
specifier|static
name|void
name|keytype
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keytype is %s\n"
argument_list|,
operator|(
name|info_auth_keytype
operator|==
name|KEY_TYPE_MD5
operator|)
condition|?
literal|"MD5"
else|:
literal|"DES"
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
operator|*
operator|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
operator|)
condition|)
block|{
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|info_auth_keytype
operator|=
name|KEY_TYPE_MD5
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|info_auth_keytype
operator|=
name|KEY_TYPE_DES
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keytype must be 'md5' or 'des'\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * passwd - get an authentication key  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|passwd
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|pass
decl_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
name|info_auth_keyid
operator|=
name|getkeyid
argument_list|(
literal|"Keyid: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Keyid must be defined\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|interactive
condition|)
block|{
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|info_auth_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pass
operator|=
name|getpass
argument_list|(
operator|(
name|info_auth_keytype
operator|==
name|KEY_TYPE_DES
operator|)
condition|?
literal|"DES Password: "
else|:
literal|"MD5 Password: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pass
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Password unchanged\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|pass
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|info_auth_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * hostnames - set the showhostnames flag  */
end_comment

begin_function
specifier|static
name|void
name|hostnames
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|showhostnames
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hostnames being shown\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hostnames not being shown\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|showhostnames
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
name|showhostnames
operator|=
literal|0
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * setdebug - set/change debugging level  */
end_comment

begin_function
specifier|static
name|void
name|setdebug
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"debug level is %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
name|debug
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"more"
argument_list|)
condition|)
block|{
name|debug
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"less"
argument_list|)
condition|)
block|{
name|debug
operator|--
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"debug level set to %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * quit - stop this nonsense  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|quit
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|havehost
condition|)
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * version - print the current version number  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|version
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * warning - print a warning message  */
end_comment

begin_function
specifier|static
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|st1
parameter_list|,
specifier|const
name|char
modifier|*
name|st2
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|st1
argument_list|,
name|st2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * error - print a message and exit  */
end_comment

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|st1
parameter_list|,
specifier|const
name|char
modifier|*
name|st2
parameter_list|)
block|{
name|warning
argument_list|(
name|fmt
argument_list|,
name|st1
argument_list|,
name|st2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * getkeyid - prompt the user for a keyid to use  */
end_comment

begin_function
specifier|static
name|u_long
name|getkeyid
parameter_list|(
specifier|const
name|char
modifier|*
name|keyprompt
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|fi
decl_stmt|;
name|char
name|pbuf
index|[
literal|20
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
operator|(
name|fi
operator|=
name|fdopen
argument_list|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|fi
operator|=
name|_fdopen
argument_list|(
operator|(
name|int
operator|)
name|GetStdHandle
argument_list|(
name|STD_INPUT_HANDLE
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
comment|/* SYS_WINNT */
name|fi
operator|=
name|stdin
expr_stmt|;
else|else
name|setbuf
argument_list|(
name|fi
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|keyprompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pbuf
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fi
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|<
operator|&
name|pbuf
index|[
literal|18
index|]
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fi
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fi
argument_list|)
expr_stmt|;
return|return
operator|(
name|u_int32
operator|)
name|atoi
argument_list|(
name|pbuf
argument_list|)
return|;
block|}
end_function

end_unit

