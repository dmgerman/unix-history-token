begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2007, 2009, 2010  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2000-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: entropy.c,v 1.22 2010/08/10 23:48:19 tbox Exp $ */
end_comment

begin_comment
comment|/*! \file  * \brief  * This is the system independent part of the entropy module.  It is  * compiled via inclusion from the relevant OS source file, ie,  * \link unix/entropy.c unix/entropy.c \endlink or win32/entropy.c.  *  * \author Much of this code is modeled after the NetBSD /dev/random implementation,  * written by Michael Graff<explorer@netbsd.org>.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/entropy.h>
end_include

begin_include
include|#
directive|include
file|<isc/keyboard.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/msgs.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/sha1.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_define
define|#
directive|define
name|ENTROPY_MAGIC
value|ISC_MAGIC('E', 'n', 't', 'e')
end_define

begin_define
define|#
directive|define
name|SOURCE_MAGIC
value|ISC_MAGIC('E', 'n', 't', 's')
end_define

begin_define
define|#
directive|define
name|VALID_ENTROPY
parameter_list|(
name|e
parameter_list|)
value|ISC_MAGIC_VALID(e, ENTROPY_MAGIC)
end_define

begin_define
define|#
directive|define
name|VALID_SOURCE
parameter_list|(
name|s
parameter_list|)
value|ISC_MAGIC_VALID(s, SOURCE_MAGIC)
end_define

begin_comment
comment|/***  *** "constants."  Do not change these unless you _really_ know what  *** you are doing.  ***/
end_comment

begin_comment
comment|/*%  * Size of entropy pool in 32-bit words.  This _MUST_ be a power of 2.  */
end_comment

begin_define
define|#
directive|define
name|RND_POOLWORDS
value|128
end_define

begin_comment
comment|/*% Pool in bytes. */
end_comment

begin_define
define|#
directive|define
name|RND_POOLBYTES
value|(RND_POOLWORDS * 4)
end_define

begin_comment
comment|/*% Pool in bits. */
end_comment

begin_define
define|#
directive|define
name|RND_POOLBITS
value|(RND_POOLWORDS * 32)
end_define

begin_comment
comment|/*%  * Number of bytes returned per hash.  This must be true:  *	threshold * 2<= digest_size_in_bytes  */
end_comment

begin_define
define|#
directive|define
name|RND_ENTROPY_THRESHOLD
value|10
end_define

begin_define
define|#
directive|define
name|THRESHOLD_BITS
value|(RND_ENTROPY_THRESHOLD * 8)
end_define

begin_comment
comment|/*%  * Size of the input event queue in samples.  */
end_comment

begin_define
define|#
directive|define
name|RND_EVENTQSIZE
value|32
end_define

begin_comment
comment|/*%  * The number of times we'll "reseed" for pseudorandom seeds.  This is an  * extremely weak pseudorandom seed.  If the caller is using lots of  * pseudorandom data and they cannot provide a stronger random source,  * there is little we can do other than hope they're smart enough to  * call _adddata() with something better than we can come up with.  */
end_comment

begin_define
define|#
directive|define
name|RND_INITIALIZE
value|128
end_define

begin_comment
comment|/*% Entropy Pool */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|isc_uint32_t
name|cursor
decl_stmt|;
comment|/*%< current add point in the pool */
name|isc_uint32_t
name|entropy
decl_stmt|;
comment|/*%< current entropy estimate in bits */
name|isc_uint32_t
name|pseudo
decl_stmt|;
comment|/*%< bits extracted in pseudorandom */
name|isc_uint32_t
name|rotate
decl_stmt|;
comment|/*%< how many bits to rotate by */
name|isc_uint32_t
name|pool
index|[
name|RND_POOLWORDS
index|]
decl_stmt|;
comment|/*%< random pool data */
block|}
name|isc_entropypool_t
typedef|;
end_typedef

begin_struct
struct|struct
name|isc_entropy
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|unsigned
name|int
name|refcnt
decl_stmt|;
name|isc_uint32_t
name|initialized
decl_stmt|;
name|isc_uint32_t
name|initcount
decl_stmt|;
name|isc_entropypool_t
name|pool
decl_stmt|;
name|unsigned
name|int
name|nsources
decl_stmt|;
name|isc_entropysource_t
modifier|*
name|nextsource
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_entropysource_t
argument_list|)
name|sources
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*% Sample Queue */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|isc_uint32_t
name|last_time
decl_stmt|;
comment|/*%< last time recorded */
name|isc_uint32_t
name|last_delta
decl_stmt|;
comment|/*%< last delta value */
name|isc_uint32_t
name|last_delta2
decl_stmt|;
comment|/*%< last delta2 value */
name|isc_uint32_t
name|nsamples
decl_stmt|;
comment|/*%< number of samples filled in */
name|isc_uint32_t
modifier|*
name|samples
decl_stmt|;
comment|/*%< the samples */
name|isc_uint32_t
modifier|*
name|extra
decl_stmt|;
comment|/*%< extra samples added in */
block|}
name|sample_queue_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|sample_queue_t
name|samplequeue
decl_stmt|;
block|}
name|isc_entropysamplesource_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|isc_boolean_t
name|start_called
decl_stmt|;
name|isc_entropystart_t
name|startfunc
decl_stmt|;
name|isc_entropyget_t
name|getfunc
decl_stmt|;
name|isc_entropystop_t
name|stopfunc
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|sample_queue_t
name|samplequeue
decl_stmt|;
block|}
name|isc_cbsource_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|FILESOURCE_HANDLE_TYPE
name|handle
decl_stmt|;
block|}
name|isc_entropyfilesource_t
typedef|;
end_typedef

begin_struct
struct|struct
name|isc_entropysource
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|isc_entropy_t
modifier|*
name|ent
decl_stmt|;
name|isc_uint32_t
name|total
decl_stmt|;
comment|/*%< entropy from this source */
name|ISC_LINK
argument_list|(
argument|isc_entropysource_t
argument_list|)
name|link
expr_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|isc_boolean_t
name|bad
decl_stmt|;
name|isc_boolean_t
name|warn_keyboard
decl_stmt|;
name|isc_keyboard_t
name|kbd
decl_stmt|;
union|union
block|{
name|isc_entropysamplesource_t
name|sample
decl_stmt|;
name|isc_entropyfilesource_t
name|file
decl_stmt|;
name|isc_cbsource_t
name|callback
decl_stmt|;
name|isc_entropyusocketsource_t
name|usocket
decl_stmt|;
block|}
name|sources
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ENTROPY_SOURCETYPE_SAMPLE
value|1
end_define

begin_comment
comment|/*%< Type is a sample source */
end_comment

begin_define
define|#
directive|define
name|ENTROPY_SOURCETYPE_FILE
value|2
end_define

begin_comment
comment|/*%< Type is a file source */
end_comment

begin_define
define|#
directive|define
name|ENTROPY_SOURCETYPE_CALLBACK
value|3
end_define

begin_comment
comment|/*%< Type is a callback source */
end_comment

begin_define
define|#
directive|define
name|ENTROPY_SOURCETYPE_USOCKET
value|4
end_define

begin_comment
comment|/*%< Type is a Unix socket source */
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/*%  * The random pool "taps"  */
end_comment

begin_define
define|#
directive|define
name|TAP1
value|99
end_define

begin_define
define|#
directive|define
name|TAP2
value|59
end_define

begin_define
define|#
directive|define
name|TAP3
value|31
end_define

begin_define
define|#
directive|define
name|TAP4
value|9
end_define

begin_define
define|#
directive|define
name|TAP5
value|7
end_define

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/*%  * Declarations for function provided by the system dependent sources that  * include this file.  */
end_comment

begin_function_decl
specifier|static
name|void
name|fillpool
parameter_list|(
name|isc_entropy_t
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|isc_boolean_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wait_for_sources
parameter_list|(
name|isc_entropy_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroyfilesource
parameter_list|(
name|isc_entropyfilesource_t
modifier|*
name|source
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroyusocketsource
parameter_list|(
name|isc_entropyusocketsource_t
modifier|*
name|source
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*@}*/
end_comment

begin_function
specifier|static
name|void
name|samplequeue_release
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|sample_queue_t
modifier|*
name|sq
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|sq
operator|->
name|samples
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sq
operator|->
name|extra
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|ent
operator|->
name|mctx
argument_list|,
name|sq
operator|->
name|samples
argument_list|,
name|RND_EVENTQSIZE
operator|*
literal|4
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|ent
operator|->
name|mctx
argument_list|,
name|sq
operator|->
name|extra
argument_list|,
name|RND_EVENTQSIZE
operator|*
literal|4
argument_list|)
expr_stmt|;
name|sq
operator|->
name|samples
operator|=
name|NULL
expr_stmt|;
name|sq
operator|->
name|extra
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|samplesource_allocate
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|sample_queue_t
modifier|*
name|sq
parameter_list|)
block|{
name|sq
operator|->
name|samples
operator|=
name|isc_mem_get
argument_list|(
name|ent
operator|->
name|mctx
argument_list|,
name|RND_EVENTQSIZE
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|samples
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|sq
operator|->
name|extra
operator|=
name|isc_mem_get
argument_list|(
name|ent
operator|->
name|mctx
argument_list|,
name|RND_EVENTQSIZE
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|extra
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|ent
operator|->
name|mctx
argument_list|,
name|sq
operator|->
name|samples
argument_list|,
name|RND_EVENTQSIZE
operator|*
literal|4
argument_list|)
expr_stmt|;
name|sq
operator|->
name|samples
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|sq
operator|->
name|nsamples
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * Add in entropy, even when the value we're adding in could be  * very large.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_entropy
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|isc_uint32_t
name|entropy
parameter_list|)
block|{
comment|/* clamp input.  Yes, this must be done. */
name|entropy
operator|=
name|ISC_MIN
argument_list|(
name|entropy
argument_list|,
name|RND_POOLBITS
argument_list|)
expr_stmt|;
comment|/* Add in the entropy we already have. */
name|entropy
operator|+=
name|ent
operator|->
name|pool
operator|.
name|entropy
expr_stmt|;
comment|/* Clamp. */
name|ent
operator|->
name|pool
operator|.
name|entropy
operator|=
name|ISC_MIN
argument_list|(
name|entropy
argument_list|,
name|RND_POOLBITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*%  * Decrement the amount of entropy the pool has.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|subtract_entropy
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|isc_uint32_t
name|entropy
parameter_list|)
block|{
name|entropy
operator|=
name|ISC_MIN
argument_list|(
name|entropy
argument_list|,
name|ent
operator|->
name|pool
operator|.
name|entropy
argument_list|)
expr_stmt|;
name|ent
operator|->
name|pool
operator|.
name|entropy
operator|-=
name|entropy
expr_stmt|;
block|}
end_function

begin_comment
comment|/*!  * Add in entropy, even when the value we're adding in could be  * very large.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_pseudo
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|isc_uint32_t
name|pseudo
parameter_list|)
block|{
comment|/* clamp input.  Yes, this must be done. */
name|pseudo
operator|=
name|ISC_MIN
argument_list|(
name|pseudo
argument_list|,
name|RND_POOLBITS
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* Add in the pseudo we already have. */
name|pseudo
operator|+=
name|ent
operator|->
name|pool
operator|.
name|pseudo
expr_stmt|;
comment|/* Clamp. */
name|ent
operator|->
name|pool
operator|.
name|pseudo
operator|=
name|ISC_MIN
argument_list|(
name|pseudo
argument_list|,
name|RND_POOLBITS
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*!  * Decrement the amount of pseudo the pool has.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|subtract_pseudo
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|isc_uint32_t
name|pseudo
parameter_list|)
block|{
name|pseudo
operator|=
name|ISC_MIN
argument_list|(
name|pseudo
argument_list|,
name|ent
operator|->
name|pool
operator|.
name|pseudo
argument_list|)
expr_stmt|;
name|ent
operator|->
name|pool
operator|.
name|pseudo
operator|-=
name|pseudo
expr_stmt|;
block|}
end_function

begin_comment
comment|/*!  * Add one word to the pool, rotating the input as needed.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|entropypool_add_word
parameter_list|(
name|isc_entropypool_t
modifier|*
name|rp
parameter_list|,
name|isc_uint32_t
name|val
parameter_list|)
block|{
comment|/* 	 * Steal some values out of the pool, and xor them into the 	 * word we were given. 	 * 	 * Mix the new value into the pool using xor.  This will 	 * prevent the actual values from being known to the caller 	 * since the previous values are assumed to be unknown as well. 	 */
name|val
operator|^=
name|rp
operator|->
name|pool
index|[
operator|(
name|rp
operator|->
name|cursor
operator|+
name|TAP1
operator|)
operator|&
operator|(
name|RND_POOLWORDS
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|val
operator|^=
name|rp
operator|->
name|pool
index|[
operator|(
name|rp
operator|->
name|cursor
operator|+
name|TAP2
operator|)
operator|&
operator|(
name|RND_POOLWORDS
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|val
operator|^=
name|rp
operator|->
name|pool
index|[
operator|(
name|rp
operator|->
name|cursor
operator|+
name|TAP3
operator|)
operator|&
operator|(
name|RND_POOLWORDS
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|val
operator|^=
name|rp
operator|->
name|pool
index|[
operator|(
name|rp
operator|->
name|cursor
operator|+
name|TAP4
operator|)
operator|&
operator|(
name|RND_POOLWORDS
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|val
operator|^=
name|rp
operator|->
name|pool
index|[
operator|(
name|rp
operator|->
name|cursor
operator|+
name|TAP5
operator|)
operator|&
operator|(
name|RND_POOLWORDS
operator|-
literal|1
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rotate
operator|==
literal|0
condition|)
name|rp
operator|->
name|pool
index|[
name|rp
operator|->
name|cursor
operator|++
index|]
operator|^=
name|val
expr_stmt|;
else|else
name|rp
operator|->
name|pool
index|[
name|rp
operator|->
name|cursor
operator|++
index|]
operator|^=
operator|(
operator|(
name|val
operator|<<
name|rp
operator|->
name|rotate
operator|)
operator||
operator|(
name|val
operator|>>
operator|(
literal|32
operator|-
name|rp
operator|->
name|rotate
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* 	 * If we have looped around the pool, increment the rotate 	 * variable so the next value will get xored in rotated to 	 * a different position. 	 * Increment by a value that is relatively prime to the word size 	 * to try to spread the bits throughout the pool quickly when the 	 * pool is empty. 	 */
if|if
condition|(
name|rp
operator|->
name|cursor
operator|==
name|RND_POOLWORDS
condition|)
block|{
name|rp
operator|->
name|cursor
operator|=
literal|0
expr_stmt|;
name|rp
operator|->
name|rotate
operator|=
operator|(
name|rp
operator|->
name|rotate
operator|+
literal|7
operator|)
operator|&
literal|31
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*!  * Add a buffer's worth of data to the pool.  *  * Requires that the lock is held on the entropy pool.  */
end_comment

begin_function
specifier|static
name|void
name|entropypool_adddata
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|isc_uint32_t
name|entropy
parameter_list|)
block|{
name|isc_uint32_t
name|val
decl_stmt|;
name|unsigned
name|long
name|addr
decl_stmt|;
name|isc_uint8_t
modifier|*
name|buf
decl_stmt|;
name|addr
operator|=
operator|(
name|unsigned
name|long
operator|)
name|p
expr_stmt|;
name|buf
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|&
literal|0x03U
operator|)
operator|!=
literal|0U
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
name|val
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
case|case
literal|2
case|:
name|val
operator|=
name|val
operator|<<
literal|8
operator||
operator|*
name|buf
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
case|case
literal|1
case|:
name|val
operator|=
name|val
operator|<<
literal|8
operator||
operator|*
name|buf
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|entropypool_add_word
argument_list|(
operator|&
name|ent
operator|->
name|pool
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|len
operator|>
literal|3
condition|;
name|len
operator|-=
literal|4
control|)
block|{
name|val
operator|=
operator|*
operator|(
operator|(
name|isc_uint32_t
operator|*
operator|)
name|buf
operator|)
expr_stmt|;
name|entropypool_add_word
argument_list|(
operator|&
name|ent
operator|->
name|pool
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
name|val
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
case|case
literal|2
case|:
name|val
operator|=
name|val
operator|<<
literal|8
operator||
operator|*
name|buf
operator|++
expr_stmt|;
case|case
literal|1
case|:
name|val
operator|=
name|val
operator|<<
literal|8
operator||
operator|*
name|buf
operator|++
expr_stmt|;
block|}
name|entropypool_add_word
argument_list|(
operator|&
name|ent
operator|->
name|pool
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|add_entropy
argument_list|(
name|ent
argument_list|,
name|entropy
argument_list|)
expr_stmt|;
name|subtract_pseudo
argument_list|(
name|ent
argument_list|,
name|entropy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|reseed
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|)
block|{
name|isc_time_t
name|t
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|initcount
operator|==
literal|0
condition|)
block|{
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|entropypool_adddata
argument_list|(
name|ent
argument_list|,
operator|&
name|pid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pid
operator|=
name|getppid
argument_list|()
expr_stmt|;
name|entropypool_adddata
argument_list|(
name|ent
argument_list|,
operator|&
name|pid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*! 	 * After we've reseeded 100 times, only add new timing info every 	 * 50 requests.  This will keep us from using lots and lots of 	 * CPU just to return bad pseudorandom data anyway. 	 */
if|if
condition|(
name|ent
operator|->
name|initcount
operator|>
literal|100
condition|)
if|if
condition|(
operator|(
name|ent
operator|->
name|initcount
operator|%
literal|50
operator|)
operator|!=
literal|0
condition|)
return|return;
name|TIME_NOW
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|entropypool_adddata
argument_list|(
name|ent
argument_list|,
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ent
operator|->
name|initcount
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|estimate_entropy
parameter_list|(
name|sample_queue_t
modifier|*
name|sq
parameter_list|,
name|isc_uint32_t
name|t
parameter_list|)
block|{
name|isc_int32_t
name|delta
decl_stmt|;
name|isc_int32_t
name|delta2
decl_stmt|;
name|isc_int32_t
name|delta3
decl_stmt|;
comment|/*! 	 * If the time counter has overflowed, calculate the real difference. 	 * If it has not, it is simpler. 	 */
if|if
condition|(
name|t
operator|<
name|sq
operator|->
name|last_time
condition|)
name|delta
operator|=
name|UINT_MAX
operator|-
name|sq
operator|->
name|last_time
operator|+
name|t
expr_stmt|;
else|else
name|delta
operator|=
name|sq
operator|->
name|last_time
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
comment|/* 	 * Calculate the second and third order differentials 	 */
name|delta2
operator|=
name|sq
operator|->
name|last_delta
operator|-
name|delta
expr_stmt|;
if|if
condition|(
name|delta2
operator|<
literal|0
condition|)
name|delta2
operator|=
operator|-
name|delta2
expr_stmt|;
name|delta3
operator|=
name|sq
operator|->
name|last_delta2
operator|-
name|delta2
expr_stmt|;
if|if
condition|(
name|delta3
operator|<
literal|0
condition|)
name|delta3
operator|=
operator|-
name|delta3
expr_stmt|;
name|sq
operator|->
name|last_time
operator|=
name|t
expr_stmt|;
name|sq
operator|->
name|last_delta
operator|=
name|delta
expr_stmt|;
name|sq
operator|->
name|last_delta2
operator|=
name|delta2
expr_stmt|;
comment|/* 	 * If any delta is 0, we got no entropy.  If all are non-zero, we 	 * might have something. 	 */
if|if
condition|(
name|delta
operator|==
literal|0
operator|||
name|delta2
operator|==
literal|0
operator|||
name|delta3
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	 * We could find the smallest delta and claim we got log2(delta) 	 * bits, but for now return that we found 1 bit. 	 */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|crunchsamples
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|sample_queue_t
modifier|*
name|sq
parameter_list|)
block|{
name|unsigned
name|int
name|ns
decl_stmt|;
name|unsigned
name|int
name|added
decl_stmt|;
if|if
condition|(
name|sq
operator|->
name|nsamples
operator|<
literal|6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|added
operator|=
literal|0
expr_stmt|;
name|sq
operator|->
name|last_time
operator|=
name|sq
operator|->
name|samples
index|[
literal|0
index|]
expr_stmt|;
name|sq
operator|->
name|last_delta
operator|=
literal|0
expr_stmt|;
name|sq
operator|->
name|last_delta2
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Prime the values by adding in the first 4 samples in.  This 	 * should completely initialize the delta calculations. 	 */
for|for
control|(
name|ns
operator|=
literal|0
init|;
name|ns
operator|<
literal|4
condition|;
name|ns
operator|++
control|)
operator|(
name|void
operator|)
name|estimate_entropy
argument_list|(
name|sq
argument_list|,
name|sq
operator|->
name|samples
index|[
name|ns
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|ns
operator|=
literal|4
init|;
name|ns
operator|<
name|sq
operator|->
name|nsamples
condition|;
name|ns
operator|++
control|)
name|added
operator|+=
name|estimate_entropy
argument_list|(
name|sq
argument_list|,
name|sq
operator|->
name|samples
index|[
name|ns
index|]
argument_list|)
expr_stmt|;
name|entropypool_adddata
argument_list|(
name|ent
argument_list|,
name|sq
operator|->
name|samples
argument_list|,
name|sq
operator|->
name|nsamples
operator|*
literal|4
argument_list|,
name|added
argument_list|)
expr_stmt|;
name|entropypool_adddata
argument_list|(
name|ent
argument_list|,
name|sq
operator|->
name|extra
argument_list|,
name|sq
operator|->
name|nsamples
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Move the last 4 samples into the first 4 positions, and start 	 * adding new samples from that point. 	 */
for|for
control|(
name|ns
operator|=
literal|0
init|;
name|ns
operator|<
literal|4
condition|;
name|ns
operator|++
control|)
block|{
name|sq
operator|->
name|samples
index|[
name|ns
index|]
operator|=
name|sq
operator|->
name|samples
index|[
name|sq
operator|->
name|nsamples
operator|-
literal|4
operator|+
name|ns
index|]
expr_stmt|;
name|sq
operator|->
name|extra
index|[
name|ns
index|]
operator|=
name|sq
operator|->
name|extra
index|[
name|sq
operator|->
name|nsamples
operator|-
literal|4
operator|+
name|ns
index|]
expr_stmt|;
block|}
name|sq
operator|->
name|nsamples
operator|=
literal|4
expr_stmt|;
return|return
operator|(
name|added
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|get_from_callback
parameter_list|(
name|isc_entropysource_t
modifier|*
name|source
parameter_list|,
name|unsigned
name|int
name|desired
parameter_list|,
name|isc_boolean_t
name|blocking
parameter_list|)
block|{
name|isc_entropy_t
modifier|*
name|ent
init|=
name|source
operator|->
name|ent
decl_stmt|;
name|isc_cbsource_t
modifier|*
name|cbs
init|=
operator|&
name|source
operator|->
name|sources
operator|.
name|callback
decl_stmt|;
name|unsigned
name|int
name|added
decl_stmt|;
name|unsigned
name|int
name|got
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|desired
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|source
operator|->
name|bad
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|cbs
operator|->
name|start_called
operator|&&
name|cbs
operator|->
name|startfunc
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|cbs
operator|->
name|startfunc
argument_list|(
name|source
argument_list|,
name|cbs
operator|->
name|arg
argument_list|,
name|blocking
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cbs
operator|->
name|start_called
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|added
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
while|while
condition|(
name|desired
operator|>
literal|0
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|cbs
operator|->
name|getfunc
argument_list|(
name|source
argument_list|,
name|cbs
operator|->
name|arg
argument_list|,
name|blocking
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_QUEUEFULL
condition|)
block|{
name|got
operator|=
name|crunchsamples
argument_list|(
name|ent
argument_list|,
operator|&
name|cbs
operator|->
name|samplequeue
argument_list|)
expr_stmt|;
name|added
operator|+=
name|got
expr_stmt|;
name|desired
operator|-=
name|ISC_MIN
argument_list|(
name|got
argument_list|,
name|desired
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTBLOCKING
condition|)
name|source
operator|->
name|bad
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
return|return
operator|(
name|added
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract some number of bytes from the random pool, decreasing the  * estimate of randomness as each byte is extracted.  *  * Do this by stiring the pool and returning a part of hash as randomness.  * Note that no secrets are given away here since parts of the hash are  * xored together before returned.  *  * Honor the request from the caller to only return good data, any data,  * etc.  */
end_comment

begin_function
name|isc_result_t
name|isc_entropy_getdata
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|unsigned
name|int
modifier|*
name|returned
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_sha1_t
name|hash
decl_stmt|;
name|unsigned
name|char
name|digest
index|[
name|ISC_SHA1_DIGESTLENGTH
index|]
decl_stmt|;
name|isc_uint32_t
name|remain
decl_stmt|,
name|deltae
decl_stmt|,
name|count
decl_stmt|,
name|total
decl_stmt|;
name|isc_uint8_t
modifier|*
name|buf
decl_stmt|;
name|isc_boolean_t
name|goodonly
decl_stmt|,
name|partial
decl_stmt|,
name|blocking
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_ENTROPY
argument_list|(
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|goodonly
operator|=
name|ISC_TF
argument_list|(
operator|(
name|flags
operator|&
name|ISC_ENTROPY_GOODONLY
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|partial
operator|=
name|ISC_TF
argument_list|(
operator|(
name|flags
operator|&
name|ISC_ENTROPY_PARTIAL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|blocking
operator|=
name|ISC_TF
argument_list|(
operator|(
name|flags
operator|&
name|ISC_ENTROPY_BLOCKING
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|partial
operator|||
name|returned
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|remain
operator|=
name|length
expr_stmt|;
name|buf
operator|=
name|data
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|remain
operator|!=
literal|0
condition|)
block|{
name|count
operator|=
name|ISC_MIN
argument_list|(
name|remain
argument_list|,
name|RND_ENTROPY_THRESHOLD
argument_list|)
expr_stmt|;
comment|/* 		 * If we are extracting good data only, make certain we 		 * have enough data in our pool for this pass.  If we don't, 		 * get some, and fail if we can't, and partial returns 		 * are not ok. 		 */
if|if
condition|(
name|goodonly
condition|)
block|{
name|unsigned
name|int
name|fillcount
decl_stmt|;
name|fillcount
operator|=
name|ISC_MAX
argument_list|(
name|remain
operator|*
literal|8
argument_list|,
name|count
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* 			 * If, however, we have at least THRESHOLD_BITS 			 * of entropy in the pool, don't block here.  It is 			 * better to drain the pool once in a while and 			 * then refill it than it is to constantly keep the 			 * pool full. 			 */
if|if
condition|(
name|ent
operator|->
name|pool
operator|.
name|entropy
operator|>=
name|THRESHOLD_BITS
condition|)
name|fillpool
argument_list|(
name|ent
argument_list|,
name|fillcount
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
else|else
name|fillpool
argument_list|(
name|ent
argument_list|,
name|fillcount
argument_list|,
name|blocking
argument_list|)
expr_stmt|;
comment|/* 			 * Verify that we got enough entropy to do one 			 * extraction.  If we didn't, bail. 			 */
if|if
condition|(
name|ent
operator|->
name|pool
operator|.
name|entropy
operator|<
name|THRESHOLD_BITS
condition|)
block|{
if|if
condition|(
operator|!
name|partial
condition|)
goto|goto
name|zeroize
goto|;
else|else
goto|goto
name|partial_output
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * If we've extracted half our pool size in bits 			 * since the last refresh, try to refresh here. 			 */
if|if
condition|(
name|ent
operator|->
name|initialized
operator|<
name|THRESHOLD_BITS
condition|)
name|fillpool
argument_list|(
name|ent
argument_list|,
name|THRESHOLD_BITS
argument_list|,
name|blocking
argument_list|)
expr_stmt|;
else|else
name|fillpool
argument_list|(
name|ent
argument_list|,
literal|0
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
comment|/* 			 * If we've not initialized with enough good random 			 * data, seed with our crappy code. 			 */
if|if
condition|(
name|ent
operator|->
name|initialized
operator|<
name|THRESHOLD_BITS
condition|)
name|reseed
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
name|isc_sha1_init
argument_list|(
operator|&
name|hash
argument_list|)
expr_stmt|;
name|isc_sha1_update
argument_list|(
operator|&
name|hash
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|ent
operator|->
name|pool
operator|.
name|pool
operator|)
argument_list|,
name|RND_POOLBYTES
argument_list|)
expr_stmt|;
name|isc_sha1_final
argument_list|(
operator|&
name|hash
argument_list|,
name|digest
argument_list|)
expr_stmt|;
comment|/* 		 * Stir the extracted data (all of it) back into the pool. 		 */
name|entropypool_adddata
argument_list|(
name|ent
argument_list|,
name|digest
argument_list|,
name|ISC_SHA1_DIGESTLENGTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|digest
index|[
name|i
index|]
operator|^
name|digest
index|[
name|i
operator|+
name|RND_ENTROPY_THRESHOLD
index|]
expr_stmt|;
name|buf
operator|+=
name|count
expr_stmt|;
name|remain
operator|-=
name|count
expr_stmt|;
name|deltae
operator|=
name|count
operator|*
literal|8
expr_stmt|;
name|deltae
operator|=
name|ISC_MIN
argument_list|(
name|deltae
argument_list|,
name|ent
operator|->
name|pool
operator|.
name|entropy
argument_list|)
expr_stmt|;
name|total
operator|+=
name|deltae
expr_stmt|;
name|subtract_entropy
argument_list|(
name|ent
argument_list|,
name|deltae
argument_list|)
expr_stmt|;
name|add_pseudo
argument_list|(
name|ent
argument_list|,
name|count
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
name|partial_output
label|:
name|memset
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|digest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|returned
operator|!=
name|NULL
condition|)
operator|*
name|returned
operator|=
operator|(
name|length
operator|-
name|remain
operator|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|zeroize
label|:
comment|/* put the entropy we almost extracted back */
name|add_entropy
argument_list|(
name|ent
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|digest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|returned
operator|!=
name|NULL
condition|)
operator|*
name|returned
operator|=
literal|0
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOENTROPY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isc_entropypool_init
parameter_list|(
name|isc_entropypool_t
modifier|*
name|pool
parameter_list|)
block|{
name|pool
operator|->
name|cursor
operator|=
name|RND_POOLWORDS
operator|-
literal|1
expr_stmt|;
name|pool
operator|->
name|entropy
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|pseudo
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|rotate
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pool
operator|->
name|pool
argument_list|,
literal|0
argument_list|,
name|RND_POOLBYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isc_entropypool_invalidate
parameter_list|(
name|isc_entropypool_t
modifier|*
name|pool
parameter_list|)
block|{
name|pool
operator|->
name|cursor
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|entropy
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|pseudo
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|rotate
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pool
operator|->
name|pool
argument_list|,
literal|0
argument_list|,
name|RND_POOLBYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_entropy_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_entropy_t
modifier|*
modifier|*
name|entp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_entropy_t
modifier|*
name|ent
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|entp
operator|!=
name|NULL
operator|&&
operator|*
name|entp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ent
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_entropy_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* 	 * We need a lock. 	 */
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|errout
goto|;
comment|/* 	 * From here down, no failures will/can occur. 	 */
name|ISC_LIST_INIT
argument_list|(
name|ent
operator|->
name|sources
argument_list|)
expr_stmt|;
name|ent
operator|->
name|nextsource
operator|=
name|NULL
expr_stmt|;
name|ent
operator|->
name|nsources
operator|=
literal|0
expr_stmt|;
name|ent
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|ent
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|ent
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|ent
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
name|ent
operator|->
name|initcount
operator|=
literal|0
expr_stmt|;
name|ent
operator|->
name|magic
operator|=
name|ENTROPY_MAGIC
expr_stmt|;
name|isc_entropypool_init
argument_list|(
operator|&
name|ent
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|entp
operator|=
name|ent
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|errout
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|ent
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_entropy_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*!  * Requires "ent" be locked.  */
end_comment

begin_function
specifier|static
name|void
name|destroysource
parameter_list|(
name|isc_entropysource_t
modifier|*
modifier|*
name|sourcep
parameter_list|)
block|{
name|isc_entropysource_t
modifier|*
name|source
decl_stmt|;
name|isc_entropy_t
modifier|*
name|ent
decl_stmt|;
name|isc_cbsource_t
modifier|*
name|cbs
decl_stmt|;
name|source
operator|=
operator|*
name|sourcep
expr_stmt|;
operator|*
name|sourcep
operator|=
name|NULL
expr_stmt|;
name|ent
operator|=
name|source
operator|->
name|ent
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|ent
operator|->
name|sources
argument_list|,
name|source
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ent
operator|->
name|nextsource
operator|=
name|NULL
expr_stmt|;
name|REQUIRE
argument_list|(
name|ent
operator|->
name|nsources
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ent
operator|->
name|nsources
operator|--
expr_stmt|;
switch|switch
condition|(
name|source
operator|->
name|type
condition|)
block|{
case|case
name|ENTROPY_SOURCETYPE_FILE
case|:
if|if
condition|(
operator|!
name|source
operator|->
name|bad
condition|)
name|destroyfilesource
argument_list|(
operator|&
name|source
operator|->
name|sources
operator|.
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENTROPY_SOURCETYPE_USOCKET
case|:
if|if
condition|(
operator|!
name|source
operator|->
name|bad
condition|)
name|destroyusocketsource
argument_list|(
operator|&
name|source
operator|->
name|sources
operator|.
name|usocket
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENTROPY_SOURCETYPE_SAMPLE
case|:
name|samplequeue_release
argument_list|(
name|ent
argument_list|,
operator|&
name|source
operator|->
name|sources
operator|.
name|sample
operator|.
name|samplequeue
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENTROPY_SOURCETYPE_CALLBACK
case|:
name|cbs
operator|=
operator|&
name|source
operator|->
name|sources
operator|.
name|callback
expr_stmt|;
if|if
condition|(
name|cbs
operator|->
name|start_called
operator|&&
name|cbs
operator|->
name|stopfunc
operator|!=
name|NULL
condition|)
block|{
name|cbs
operator|->
name|stopfunc
argument_list|(
name|source
argument_list|,
name|cbs
operator|->
name|arg
argument_list|)
expr_stmt|;
name|cbs
operator|->
name|start_called
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|samplequeue_release
argument_list|(
name|ent
argument_list|,
operator|&
name|cbs
operator|->
name|samplequeue
argument_list|)
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
name|source
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_entropysource_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|ent
operator|->
name|mctx
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_entropysource_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|destroy_check
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|)
block|{
name|isc_entropysource_t
modifier|*
name|source
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|source
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ent
operator|->
name|sources
argument_list|)
expr_stmt|;
while|while
condition|(
name|source
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|source
operator|->
name|type
condition|)
block|{
case|case
name|ENTROPY_SOURCETYPE_FILE
case|:
case|case
name|ENTROPY_SOURCETYPE_USOCKET
case|:
break|break;
default|default:
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|source
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|source
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|isc_entropy_t
modifier|*
modifier|*
name|entp
parameter_list|)
block|{
name|isc_entropy_t
modifier|*
name|ent
decl_stmt|;
name|isc_entropysource_t
modifier|*
name|source
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|entp
operator|!=
name|NULL
operator|&&
operator|*
name|entp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ent
operator|=
operator|*
name|entp
expr_stmt|;
operator|*
name|entp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ent
operator|->
name|refcnt
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Here, detach non-sample sources. 	 */
name|source
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ent
operator|->
name|sources
argument_list|)
expr_stmt|;
while|while
condition|(
name|source
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|source
operator|->
name|type
condition|)
block|{
case|case
name|ENTROPY_SOURCETYPE_FILE
case|:
case|case
name|ENTROPY_SOURCETYPE_USOCKET
case|:
name|destroysource
argument_list|(
operator|&
name|source
argument_list|)
expr_stmt|;
break|break;
block|}
name|source
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ent
operator|->
name|sources
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are other types of sources, we've found a bug. 	 */
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|ent
operator|->
name|sources
argument_list|)
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|ent
operator|->
name|mctx
expr_stmt|;
name|isc_entropypool_invalidate
argument_list|(
operator|&
name|ent
operator|->
name|pool
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_entropy_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|ent
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_entropy_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_entropy_destroysource
parameter_list|(
name|isc_entropysource_t
modifier|*
modifier|*
name|sourcep
parameter_list|)
block|{
name|isc_entropysource_t
modifier|*
name|source
decl_stmt|;
name|isc_entropy_t
modifier|*
name|ent
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|REQUIRE
argument_list|(
name|sourcep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOURCE
argument_list|(
operator|*
name|sourcep
argument_list|)
argument_list|)
expr_stmt|;
name|source
operator|=
operator|*
name|sourcep
expr_stmt|;
operator|*
name|sourcep
operator|=
name|NULL
expr_stmt|;
name|ent
operator|=
name|source
operator|->
name|ent
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_ENTROPY
argument_list|(
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroysource
argument_list|(
operator|&
name|source
argument_list|)
expr_stmt|;
name|killit
operator|=
name|destroy_check
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|destroy
argument_list|(
operator|&
name|ent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_entropy_createcallbacksource
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|isc_entropystart_t
name|start
parameter_list|,
name|isc_entropyget_t
name|get
parameter_list|,
name|isc_entropystop_t
name|stop
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|isc_entropysource_t
modifier|*
modifier|*
name|sourcep
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_entropysource_t
modifier|*
name|source
decl_stmt|;
name|isc_cbsource_t
modifier|*
name|cbs
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_ENTROPY
argument_list|(
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|get
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sourcep
operator|!=
name|NULL
operator|&&
operator|*
name|sourcep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|source
operator|=
name|isc_mem_get
argument_list|(
name|ent
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_entropysource_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|source
operator|->
name|bad
operator|=
name|ISC_FALSE
expr_stmt|;
name|cbs
operator|=
operator|&
name|source
operator|->
name|sources
operator|.
name|callback
expr_stmt|;
name|result
operator|=
name|samplesource_allocate
argument_list|(
name|ent
argument_list|,
operator|&
name|cbs
operator|->
name|samplequeue
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|errout
goto|;
name|cbs
operator|->
name|start_called
operator|=
name|ISC_FALSE
expr_stmt|;
name|cbs
operator|->
name|startfunc
operator|=
name|start
expr_stmt|;
name|cbs
operator|->
name|getfunc
operator|=
name|get
expr_stmt|;
name|cbs
operator|->
name|stopfunc
operator|=
name|stop
expr_stmt|;
name|cbs
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
comment|/* 	 * From here down, no failures can occur. 	 */
name|source
operator|->
name|magic
operator|=
name|SOURCE_MAGIC
expr_stmt|;
name|source
operator|->
name|type
operator|=
name|ENTROPY_SOURCETYPE_CALLBACK
expr_stmt|;
name|source
operator|->
name|ent
operator|=
name|ent
expr_stmt|;
name|source
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|source
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|source
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|source
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Hook it into the entropy system. 	 */
name|ISC_LIST_APPEND
argument_list|(
name|ent
operator|->
name|sources
argument_list|,
name|source
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ent
operator|->
name|nsources
operator|++
expr_stmt|;
operator|*
name|sourcep
operator|=
name|source
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|errout
label|:
if|if
condition|(
name|source
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|ent
operator|->
name|mctx
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_entropysource_t
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_entropy_stopcallbacksources
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|)
block|{
name|isc_entropysource_t
modifier|*
name|source
decl_stmt|;
name|isc_cbsource_t
modifier|*
name|cbs
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_ENTROPY
argument_list|(
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|source
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ent
operator|->
name|sources
argument_list|)
expr_stmt|;
while|while
condition|(
name|source
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|source
operator|->
name|type
operator|==
name|ENTROPY_SOURCETYPE_CALLBACK
condition|)
block|{
name|cbs
operator|=
operator|&
name|source
operator|->
name|sources
operator|.
name|callback
expr_stmt|;
if|if
condition|(
name|cbs
operator|->
name|start_called
operator|&&
name|cbs
operator|->
name|stopfunc
operator|!=
name|NULL
condition|)
block|{
name|cbs
operator|->
name|stopfunc
argument_list|(
name|source
argument_list|,
name|cbs
operator|->
name|arg
argument_list|)
expr_stmt|;
name|cbs
operator|->
name|start_called
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
name|source
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|source
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_entropy_createsamplesource
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|isc_entropysource_t
modifier|*
modifier|*
name|sourcep
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_entropysource_t
modifier|*
name|source
decl_stmt|;
name|sample_queue_t
modifier|*
name|sq
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_ENTROPY
argument_list|(
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sourcep
operator|!=
name|NULL
operator|&&
operator|*
name|sourcep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|source
operator|=
name|isc_mem_get
argument_list|(
name|ent
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_entropysource_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|sq
operator|=
operator|&
name|source
operator|->
name|sources
operator|.
name|sample
operator|.
name|samplequeue
expr_stmt|;
name|result
operator|=
name|samplesource_allocate
argument_list|(
name|ent
argument_list|,
name|sq
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|errout
goto|;
comment|/* 	 * From here down, no failures can occur. 	 */
name|source
operator|->
name|magic
operator|=
name|SOURCE_MAGIC
expr_stmt|;
name|source
operator|->
name|type
operator|=
name|ENTROPY_SOURCETYPE_SAMPLE
expr_stmt|;
name|source
operator|->
name|ent
operator|=
name|ent
expr_stmt|;
name|source
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|source
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|source
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|source
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Hook it into the entropy system. 	 */
name|ISC_LIST_APPEND
argument_list|(
name|ent
operator|->
name|sources
argument_list|,
name|source
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ent
operator|->
name|nsources
operator|++
expr_stmt|;
operator|*
name|sourcep
operator|=
name|source
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|errout
label|:
if|if
condition|(
name|source
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|ent
operator|->
name|mctx
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_entropysource_t
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*!  * Add a sample, and return ISC_R_SUCCESS if the queue has become full,  * ISC_R_NOENTROPY if it has space remaining, and ISC_R_NOMORE if the  * queue was full when this function was called.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|addsample
parameter_list|(
name|sample_queue_t
modifier|*
name|sq
parameter_list|,
name|isc_uint32_t
name|sample
parameter_list|,
name|isc_uint32_t
name|extra
parameter_list|)
block|{
if|if
condition|(
name|sq
operator|->
name|nsamples
operator|>=
name|RND_EVENTQSIZE
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
name|sq
operator|->
name|samples
index|[
name|sq
operator|->
name|nsamples
index|]
operator|=
name|sample
expr_stmt|;
name|sq
operator|->
name|extra
index|[
name|sq
operator|->
name|nsamples
index|]
operator|=
name|extra
expr_stmt|;
name|sq
operator|->
name|nsamples
operator|++
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|nsamples
operator|>=
name|RND_EVENTQSIZE
condition|)
return|return
operator|(
name|ISC_R_QUEUEFULL
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_entropy_addsample
parameter_list|(
name|isc_entropysource_t
modifier|*
name|source
parameter_list|,
name|isc_uint32_t
name|sample
parameter_list|,
name|isc_uint32_t
name|extra
parameter_list|)
block|{
name|isc_entropy_t
modifier|*
name|ent
decl_stmt|;
name|sample_queue_t
modifier|*
name|sq
decl_stmt|;
name|unsigned
name|int
name|entropy
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOURCE
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|=
name|source
operator|->
name|ent
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sq
operator|=
operator|&
name|source
operator|->
name|sources
operator|.
name|sample
operator|.
name|samplequeue
expr_stmt|;
name|result
operator|=
name|addsample
argument_list|(
name|sq
argument_list|,
name|sample
argument_list|,
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_QUEUEFULL
condition|)
block|{
name|entropy
operator|=
name|crunchsamples
argument_list|(
name|ent
argument_list|,
name|sq
argument_list|)
expr_stmt|;
name|add_entropy
argument_list|(
name|ent
argument_list|,
name|entropy
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_entropy_addcallbacksample
parameter_list|(
name|isc_entropysource_t
modifier|*
name|source
parameter_list|,
name|isc_uint32_t
name|sample
parameter_list|,
name|isc_uint32_t
name|extra
parameter_list|)
block|{
name|sample_queue_t
modifier|*
name|sq
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOURCE
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|source
operator|->
name|type
operator|==
name|ENTROPY_SOURCETYPE_CALLBACK
argument_list|)
expr_stmt|;
name|sq
operator|=
operator|&
name|source
operator|->
name|sources
operator|.
name|callback
operator|.
name|samplequeue
expr_stmt|;
name|result
operator|=
name|addsample
argument_list|(
name|sq
argument_list|,
name|sample
argument_list|,
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_entropy_putdata
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|isc_uint32_t
name|entropy
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_ENTROPY
argument_list|(
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|entropypool_adddata
argument_list|(
name|ent
argument_list|,
name|data
argument_list|,
name|length
argument_list|,
name|entropy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|initialized
operator|<
name|THRESHOLD_BITS
condition|)
name|ent
operator|->
name|initialized
operator|=
name|THRESHOLD_BITS
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dumpstats
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_ENTROPY
argument_list|,
name|ISC_MSG_ENTROPYSTATS
argument_list|,
literal|"Entropy pool %p:  refcnt %u cursor %u,"
literal|" rotate %u entropy %u pseudo %u nsources %u"
literal|" nextsource %p initialized %u initcount %u\n"
argument_list|)
argument_list|,
name|ent
argument_list|,
name|ent
operator|->
name|refcnt
argument_list|,
name|ent
operator|->
name|pool
operator|.
name|cursor
argument_list|,
name|ent
operator|->
name|pool
operator|.
name|rotate
argument_list|,
name|ent
operator|->
name|pool
operator|.
name|entropy
argument_list|,
name|ent
operator|->
name|pool
operator|.
name|pseudo
argument_list|,
name|ent
operator|->
name|nsources
argument_list|,
name|ent
operator|->
name|nextsource
argument_list|,
name|ent
operator|->
name|initialized
argument_list|,
name|ent
operator|->
name|initcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function ignores locking.  Use at your own risk.  */
end_comment

begin_function
name|void
name|isc_entropy_stats
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_ENTROPY
argument_list|(
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|dumpstats
argument_list|(
name|ent
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|isc_entropy_status
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|)
block|{
name|unsigned
name|int
name|estimate
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|estimate
operator|=
name|ent
operator|->
name|pool
operator|.
name|entropy
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|estimate
return|;
block|}
end_function

begin_function
name|void
name|isc_entropy_attach
parameter_list|(
name|isc_entropy_t
modifier|*
name|ent
parameter_list|,
name|isc_entropy_t
modifier|*
modifier|*
name|entp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_ENTROPY
argument_list|(
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|entp
operator|!=
name|NULL
operator|&&
operator|*
name|entp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ent
operator|->
name|refcnt
operator|++
expr_stmt|;
operator|*
name|entp
operator|=
name|ent
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_entropy_detach
parameter_list|(
name|isc_entropy_t
modifier|*
modifier|*
name|entp
parameter_list|)
block|{
name|isc_entropy_t
modifier|*
name|ent
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|REQUIRE
argument_list|(
name|entp
operator|!=
name|NULL
operator|&&
name|VALID_ENTROPY
argument_list|(
operator|*
name|entp
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|=
operator|*
name|entp
expr_stmt|;
operator|*
name|entp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ent
operator|->
name|refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ent
operator|->
name|refcnt
operator|--
expr_stmt|;
name|killit
operator|=
name|destroy_check
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|ent
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|destroy
argument_list|(
operator|&
name|ent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|kbdstart
parameter_list|(
name|isc_entropysource_t
modifier|*
name|source
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|isc_boolean_t
name|blocking
parameter_list|)
block|{
comment|/* 	 * The intent of "first" is to provide a warning message only once 	 * during the run of a program that might try to gather keyboard 	 * entropy multiple times. 	 */
specifier|static
name|isc_boolean_t
name|first
init|=
name|ISC_TRUE
decl_stmt|;
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blocking
condition|)
return|return
operator|(
name|ISC_R_NOENTROPY
operator|)
return|;
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|source
operator|->
name|warn_keyboard
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You must use the keyboard to create "
literal|"entropy, since your system is lacking\n"
literal|"/dev/random (or equivalent)\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"start typing:\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|isc_keyboard_open
argument_list|(
operator|&
name|source
operator|->
name|kbd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kbdstop
parameter_list|(
name|isc_entropysource_t
modifier|*
name|source
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isc_keyboard_canceled
argument_list|(
operator|&
name|source
operator|->
name|kbd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stop typing.\r\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_keyboard_close
argument_list|(
operator|&
name|source
operator|->
name|kbd
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|kbdget
parameter_list|(
name|isc_entropysource_t
modifier|*
name|source
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|isc_boolean_t
name|blocking
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_time_t
name|t
decl_stmt|;
name|isc_uint32_t
name|sample
decl_stmt|;
name|isc_uint32_t
name|extra
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blocking
condition|)
return|return
operator|(
name|ISC_R_NOTBLOCKING
operator|)
return|;
name|result
operator|=
name|isc_keyboard_getchar
argument_list|(
operator|&
name|source
operator|->
name|kbd
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|TIME_NOW
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|sample
operator|=
name|isc_time_nanoseconds
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|extra
operator|=
name|c
expr_stmt|;
name|result
operator|=
name|isc_entropy_addcallbacksample
argument_list|(
name|source
argument_list|,
name|sample
argument_list|,
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_entropy_usebestsource
parameter_list|(
name|isc_entropy_t
modifier|*
name|ectx
parameter_list|,
name|isc_entropysource_t
modifier|*
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|randomfile
parameter_list|,
name|int
name|use_keyboard
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_result_t
name|final_result
init|=
name|ISC_R_NOENTROPY
decl_stmt|;
name|isc_boolean_t
name|userfile
init|=
name|ISC_TRUE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_ENTROPY
argument_list|(
name|ectx
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|source
operator|!=
name|NULL
operator|&&
operator|*
name|source
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|use_keyboard
operator|==
name|ISC_ENTROPY_KEYBOARDYES
operator|||
name|use_keyboard
operator|==
name|ISC_ENTROPY_KEYBOARDNO
operator|||
name|use_keyboard
operator|==
name|ISC_ENTROPY_KEYBOARDMAYBE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PATH_RANDOMDEV
if|if
condition|(
name|randomfile
operator|==
name|NULL
condition|)
block|{
name|randomfile
operator|=
name|PATH_RANDOMDEV
expr_stmt|;
name|userfile
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|randomfile
operator|!=
name|NULL
operator|&&
name|use_keyboard
operator|!=
name|ISC_ENTROPY_KEYBOARDYES
condition|)
block|{
name|result
operator|=
name|isc_entropy_createfilesource
argument_list|(
name|ectx
argument_list|,
name|randomfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|use_keyboard
operator|==
name|ISC_ENTROPY_KEYBOARDMAYBE
condition|)
name|use_keyboard
operator|=
name|ISC_ENTROPY_KEYBOARDNO
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|userfile
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|final_result
operator|=
name|result
expr_stmt|;
block|}
if|if
condition|(
name|use_keyboard
operator|!=
name|ISC_ENTROPY_KEYBOARDNO
condition|)
block|{
name|result
operator|=
name|isc_entropy_createcallbacksource
argument_list|(
name|ectx
argument_list|,
name|kbdstart
argument_list|,
name|kbdget
argument_list|,
name|kbdstop
argument_list|,
name|NULL
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
operator|(
operator|*
name|source
operator|)
operator|->
name|warn_keyboard
operator|=
name|ISC_TF
argument_list|(
name|use_keyboard
operator|==
name|ISC_ENTROPY_KEYBOARDMAYBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|final_result
operator|=
name|result
expr_stmt|;
block|}
comment|/* 	 * final_result is ISC_R_SUCCESS if at least one source of entropy 	 * could be started, otherwise it is the error from the most recently 	 * failed operation (or ISC_R_NOENTROPY if PATH_RANDOMDEV is not 	 * defined and use_keyboard is ISC_ENTROPY_KEYBOARDNO). 	 */
return|return
operator|(
name|final_result
operator|)
return|;
block|}
end_function

end_unit

