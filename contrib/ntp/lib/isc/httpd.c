begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2006-2008, 2010-2012  Internet Systems Consortium, Inc. ("ISC")  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id$ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/httpd.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/socket.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/*%  * TODO:  *  *  o  Put in better checks to make certain things are passed in correctly.  *     This includes a magic number for externally-visible structures,  *     checking for NULL-ness before dereferencing, etc.  *  o  Make the URL processing external functions which will fill-in a buffer  *     structure we provide, or return an error and we will render a generic  *     page and close the client.  */
end_comment

begin_define
define|#
directive|define
name|MSHUTTINGDOWN
parameter_list|(
name|cm
parameter_list|)
value|((cm->flags& ISC_HTTPDMGR_FLAGSHUTTINGDOWN) != 0)
end_define

begin_define
define|#
directive|define
name|MSETSHUTTINGDOWN
parameter_list|(
name|cm
parameter_list|)
value|(cm->flags |= ISC_HTTPDMGR_FLAGSHUTTINGDOWN)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_HTTPD
end_ifdef

begin_define
define|#
directive|define
name|ENTER
parameter_list|(
name|x
parameter_list|)
value|do { fprintf(stderr, "ENTER %s\n", (x)); } while (0)
end_define

begin_define
define|#
directive|define
name|EXIT
parameter_list|(
name|x
parameter_list|)
value|do { fprintf(stderr, "EXIT %s\n", (x)); } while (0)
end_define

begin_define
define|#
directive|define
name|NOTICE
parameter_list|(
name|x
parameter_list|)
value|do { fprintf(stderr, "NOTICE %s\n", (x)); } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ENTER
parameter_list|(
name|x
parameter_list|)
value|do { } while(0)
end_define

begin_define
define|#
directive|define
name|EXIT
parameter_list|(
name|x
parameter_list|)
value|do { } while(0)
end_define

begin_define
define|#
directive|define
name|NOTICE
parameter_list|(
name|x
parameter_list|)
value|do { } while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HTTP_RECVLEN
value|1024
end_define

begin_define
define|#
directive|define
name|HTTP_SENDGROW
value|1024
end_define

begin_define
define|#
directive|define
name|HTTP_SEND_MAXLEN
value|10240
end_define

begin_comment
comment|/*%  * HTTP urls.  These are the URLs we manage, and the function to call to  * provide the data for it.  We pass in the base url (so the same function  * can handle multiple requests), and a structure to fill in to return a  * result to the client.  We also pass in a pointer to be filled in for  * the data cleanup function.  */
end_comment

begin_struct
struct|struct
name|isc_httpdurl
block|{
name|char
modifier|*
name|url
decl_stmt|;
name|isc_httpdaction_t
modifier|*
name|action
decl_stmt|;
name|void
modifier|*
name|action_arg
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|isc_httpdurl_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HTTPD_CLOSE
value|0x0001
end_define

begin_comment
comment|/* Got a Connection: close header */
end_comment

begin_define
define|#
directive|define
name|HTTPD_FOUNDHOST
value|0x0002
end_define

begin_comment
comment|/* Got a Host: header */
end_comment

begin_comment
comment|/*% http client */
end_comment

begin_struct
struct|struct
name|isc_httpd
block|{
name|isc_httpdmgr_t
modifier|*
name|mgr
decl_stmt|;
comment|/*%< our parent */
name|ISC_LINK
argument_list|(
argument|isc_httpd_t
argument_list|)
name|link
expr_stmt|;
name|unsigned
name|int
name|state
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
comment|/*% 	 * Received data state. 	 */
name|char
name|recvbuf
index|[
name|HTTP_RECVLEN
index|]
decl_stmt|;
comment|/*%< receive buffer */
name|isc_uint32_t
name|recvlen
decl_stmt|;
comment|/*%< length recv'd */
name|unsigned
name|int
name|method
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
name|char
modifier|*
name|querystring
decl_stmt|;
name|char
modifier|*
name|protocol
decl_stmt|;
comment|/* 	 * Flags on the httpd client. 	 */
name|int
name|flags
decl_stmt|;
comment|/*% 	 * Transmit data state. 	 * 	 * This is the data buffer we will transmit. 	 * 	 * This free function pointer is filled in by the rendering function 	 * we call.  The free function is called after the data is transmitted 	 * to the client. 	 * 	 * The bufflist is the list of buffers we are currently transmitting. 	 * The headerdata is where we render our headers to.  If we run out of 	 * space when rendering a header, we will change the size of our 	 * buffer.  We will not free it until we are finished, and will 	 * allocate an additional HTTP_SENDGROW bytes per header space grow. 	 * 	 * We currently use two buffers total, one for the headers (which 	 * we manage) and another for the client to fill in (which it manages, 	 * it provides the space for it, etc) -- we will pass that buffer 	 * structure back to the caller, who is responsible for managing the 	 * space it may have allocated as backing store for it.  This second 	 * buffer is bodybuffer, and we only allocate the buffer itself, not 	 * the backing store. 	 */
name|isc_bufferlist_t
name|bufflist
decl_stmt|;
name|char
modifier|*
name|headerdata
decl_stmt|;
comment|/*%< send header buf */
name|unsigned
name|int
name|headerlen
decl_stmt|;
comment|/*%< current header buffer size */
name|isc_buffer_t
name|headerbuffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|mimetype
decl_stmt|;
name|unsigned
name|int
name|retcode
decl_stmt|;
specifier|const
name|char
modifier|*
name|retmsg
decl_stmt|;
name|isc_buffer_t
name|bodybuffer
decl_stmt|;
name|isc_httpdfree_t
modifier|*
name|freecb
decl_stmt|;
name|void
modifier|*
name|freecb_arg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*% lightweight socket manager for httpd output */
end_comment

begin_struct
struct|struct
name|isc_httpdmgr
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
comment|/*%< listening socket */
name|isc_task_t
modifier|*
name|task
decl_stmt|;
comment|/*%< owning task */
name|isc_timermgr_t
modifier|*
name|timermgr
decl_stmt|;
name|isc_httpdclientok_t
modifier|*
name|client_ok
decl_stmt|;
comment|/*%< client validator */
name|isc_httpdondestroy_t
modifier|*
name|ondestroy
decl_stmt|;
comment|/*%< cleanup callback */
name|void
modifier|*
name|cb_arg
decl_stmt|;
comment|/*%< argument for the above */
name|unsigned
name|int
name|flags
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_httpd_t
argument_list|)
name|running
expr_stmt|;
comment|/*%< running clients */
name|isc_mutex_t
name|lock
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_httpdurl_t
argument_list|)
name|urls
expr_stmt|;
comment|/*%< urls we manage */
name|isc_httpdaction_t
modifier|*
name|render_404
decl_stmt|;
name|isc_httpdaction_t
modifier|*
name|render_500
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  * HTTP methods.  */
end_comment

begin_define
define|#
directive|define
name|ISC_HTTPD_METHODUNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_METHODGET
value|1
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_METHODPOST
value|2
end_define

begin_comment
comment|/*%  * Client states.  *  * _IDLE	The client is not doing anything at all.  This state should  *		only occur just after creation, and just before being  *		destroyed.  *  * _RECV	The client is waiting for data after issuing a socket recv().  *  * _RECVDONE	Data has been received, and is being processed.  *  * _SEND	All data for a response has completed, and a reply was  *		sent via a socket send() call.  *  * _SENDDONE	Send is completed.  *  * Badly formatted state table:  *  *	IDLE -> RECV when client has a recv() queued.  *  *	RECV -> RECVDONE when recvdone event received.  *  *	RECVDONE -> SEND if the data for a reply is at hand.  *  *	SEND -> RECV when a senddone event was received.  *  *	At any time -> RECV on error.  If RECV fails, the client will  *	self-destroy, closing the socket and freeing memory.  */
end_comment

begin_define
define|#
directive|define
name|ISC_HTTPD_STATEIDLE
value|0
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_STATERECV
value|1
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_STATERECVDONE
value|2
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_STATESEND
value|3
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_STATESENDDONE
value|4
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_ISRECV
parameter_list|(
name|c
parameter_list|)
value|((c)->state == ISC_HTTPD_STATERECV)
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_ISRECVDONE
parameter_list|(
name|c
parameter_list|)
value|((c)->state == ISC_HTTPD_STATERECVDONE)
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_ISSEND
parameter_list|(
name|c
parameter_list|)
value|((c)->state == ISC_HTTPD_STATESEND)
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_ISSENDDONE
parameter_list|(
name|c
parameter_list|)
value|((c)->state == ISC_HTTPD_STATESENDDONE)
end_define

begin_comment
comment|/*%  * Overall magic test that means we're not idle.  */
end_comment

begin_define
define|#
directive|define
name|ISC_HTTPD_SETRECV
parameter_list|(
name|c
parameter_list|)
value|((c)->state = ISC_HTTPD_STATERECV)
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_SETRECVDONE
parameter_list|(
name|c
parameter_list|)
value|((c)->state = ISC_HTTPD_STATERECVDONE)
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_SETSEND
parameter_list|(
name|c
parameter_list|)
value|((c)->state = ISC_HTTPD_STATESEND)
end_define

begin_define
define|#
directive|define
name|ISC_HTTPD_SETSENDDONE
parameter_list|(
name|c
parameter_list|)
value|((c)->state = ISC_HTTPD_STATESENDDONE)
end_define

begin_function_decl
specifier|static
name|void
name|isc_httpd_accept
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isc_httpd_recvdone
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isc_httpd_senddone
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_client
parameter_list|(
name|isc_httpd_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|process_request
parameter_list|(
name|isc_httpd_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|httpdmgr_destroy
parameter_list|(
name|isc_httpdmgr_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|grow_headerspace
parameter_list|(
name|isc_httpd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reset_client
parameter_list|(
name|isc_httpd_t
modifier|*
name|httpd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|render_404
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|isc_buffer_t
modifier|*
parameter_list|,
name|isc_httpdfree_t
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|render_500
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|isc_buffer_t
modifier|*
parameter_list|,
name|isc_httpdfree_t
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|destroy_client
parameter_list|(
name|isc_httpd_t
modifier|*
modifier|*
name|httpdp
parameter_list|)
block|{
name|isc_httpd_t
modifier|*
name|httpd
init|=
operator|*
name|httpdp
decl_stmt|;
name|isc_httpdmgr_t
modifier|*
name|httpdmgr
init|=
name|httpd
operator|->
name|mgr
decl_stmt|;
operator|*
name|httpdp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|httpd
operator|->
name|sock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|httpdmgr
operator|->
name|running
argument_list|,
name|httpd
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|httpd
operator|->
name|headerlen
operator|>
literal|0
condition|)
name|isc_mem_put
argument_list|(
name|httpdmgr
operator|->
name|mctx
argument_list|,
name|httpd
operator|->
name|headerdata
argument_list|,
name|httpd
operator|->
name|headerlen
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|httpdmgr
operator|->
name|mctx
argument_list|,
name|httpd
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_httpd_t
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|httpdmgr_destroy
argument_list|(
name|httpdmgr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_httpdmgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_httpdclientok_t
modifier|*
name|client_ok
parameter_list|,
name|isc_httpdondestroy_t
modifier|*
name|ondestroy
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|,
name|isc_timermgr_t
modifier|*
name|tmgr
parameter_list|,
name|isc_httpdmgr_t
modifier|*
modifier|*
name|httpdp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_httpdmgr_t
modifier|*
name|httpd
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|tmgr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|httpdp
operator|!=
name|NULL
operator|&&
operator|*
name|httpdp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|httpd
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_httpdmgr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|httpd
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|httpd
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|httpd
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_httpdmgr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|httpd
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|httpd
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|httpd
operator|->
name|sock
operator|=
name|NULL
expr_stmt|;
name|isc_socket_attach
argument_list|(
name|sock
argument_list|,
operator|&
name|httpd
operator|->
name|sock
argument_list|)
expr_stmt|;
name|httpd
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|httpd
operator|->
name|task
argument_list|)
expr_stmt|;
name|httpd
operator|->
name|timermgr
operator|=
name|tmgr
expr_stmt|;
comment|/* XXXMLG no attach function? */
name|httpd
operator|->
name|client_ok
operator|=
name|client_ok
expr_stmt|;
name|httpd
operator|->
name|ondestroy
operator|=
name|ondestroy
expr_stmt|;
name|httpd
operator|->
name|cb_arg
operator|=
name|cb_arg
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|httpd
operator|->
name|running
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|httpd
operator|->
name|urls
argument_list|)
expr_stmt|;
comment|/* XXXMLG ignore errors on isc_socket_listen() */
name|result
operator|=
name|isc_socket_listen
argument_list|(
name|sock
argument_list|,
name|SOMAXCONN
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_socket_listen() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
operator|(
name|void
operator|)
name|isc_socket_filter
argument_list|(
name|sock
argument_list|,
literal|"httpready"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_accept
argument_list|(
name|sock
argument_list|,
name|task
argument_list|,
name|isc_httpd_accept
argument_list|,
name|httpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|httpd
operator|->
name|render_404
operator|=
name|render_404
expr_stmt|;
name|httpd
operator|->
name|render_500
operator|=
name|render_500
expr_stmt|;
operator|*
name|httpdp
operator|=
name|httpd
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|isc_task_detach
argument_list|(
operator|&
name|httpd
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|httpd
operator|->
name|sock
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|httpd
operator|->
name|mctx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_mutex_destroy
argument_list|(
operator|&
name|httpd
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|httpd
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_httpdmgr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|httpdmgr_destroy
parameter_list|(
name|isc_httpdmgr_t
modifier|*
name|httpdmgr
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_httpdurl_t
modifier|*
name|url
decl_stmt|;
name|ENTER
argument_list|(
literal|"httpdmgr_destroy"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MSHUTTINGDOWN
argument_list|(
name|httpdmgr
argument_list|)
condition|)
block|{
name|NOTICE
argument_list|(
literal|"httpdmgr_destroy not shutting down yet"
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If all clients are not shut down, don't do anything yet. 	 */
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|httpdmgr
operator|->
name|running
argument_list|)
condition|)
block|{
name|NOTICE
argument_list|(
literal|"httpdmgr_destroy clients still active"
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|NOTICE
argument_list|(
literal|"httpdmgr_destroy detaching socket, task, and timermgr"
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|httpdmgr
operator|->
name|sock
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|httpdmgr
operator|->
name|task
argument_list|)
expr_stmt|;
name|httpdmgr
operator|->
name|timermgr
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Clear out the list of all actions we know about.  Just free the 	 * memory. 	 */
name|url
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|httpdmgr
operator|->
name|urls
argument_list|)
expr_stmt|;
while|while
condition|(
name|url
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_free
argument_list|(
name|httpdmgr
operator|->
name|mctx
argument_list|,
name|url
operator|->
name|url
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|httpdmgr
operator|->
name|urls
argument_list|,
name|url
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|httpdmgr
operator|->
name|mctx
argument_list|,
name|url
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_httpdurl_t
argument_list|)
argument_list|)
expr_stmt|;
name|url
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|httpdmgr
operator|->
name|urls
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_mutex_destroy
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|httpdmgr
operator|->
name|ondestroy
operator|!=
name|NULL
condition|)
call|(
name|httpdmgr
operator|->
name|ondestroy
call|)
argument_list|(
name|httpdmgr
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|httpdmgr
operator|->
name|mctx
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|mctx
argument_list|,
name|httpdmgr
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_httpdmgr_t
argument_list|)
argument_list|)
expr_stmt|;
name|EXIT
argument_list|(
literal|"httpdmgr_destroy"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LENGTHOK
parameter_list|(
name|s
parameter_list|)
value|(httpd->recvbuf - (s)< (int)httpd->recvlen)
end_define

begin_define
define|#
directive|define
name|BUFLENOK
parameter_list|(
name|s
parameter_list|)
value|(httpd->recvbuf - (s)< HTTP_RECVLEN)
end_define

begin_function
specifier|static
name|isc_result_t
name|process_request
parameter_list|(
name|isc_httpd_t
modifier|*
name|httpd
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|delim
decl_stmt|;
name|ENTER
argument_list|(
literal|"request"
argument_list|)
expr_stmt|;
name|httpd
operator|->
name|recvlen
operator|+=
name|length
expr_stmt|;
name|httpd
operator|->
name|recvbuf
index|[
name|httpd
operator|->
name|recvlen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we don't find a blank line in our buffer, return that we need 	 * more data. 	 */
name|s
operator|=
name|strstr
argument_list|(
name|httpd
operator|->
name|recvbuf
argument_list|,
literal|"\r\n\r\n"
argument_list|)
expr_stmt|;
name|delim
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|strstr
argument_list|(
name|httpd
operator|->
name|recvbuf
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|delim
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
comment|/* 	 * Determine if this is a POST or GET method.  Any other values will 	 * cause an error to be returned. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|httpd
operator|->
name|recvbuf
argument_list|,
literal|"GET "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|httpd
operator|->
name|method
operator|=
name|ISC_HTTPD_METHODGET
expr_stmt|;
name|p
operator|=
name|httpd
operator|->
name|recvbuf
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|httpd
operator|->
name|recvbuf
argument_list|,
literal|"POST "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|httpd
operator|->
name|method
operator|=
name|ISC_HTTPD_METHODPOST
expr_stmt|;
name|p
operator|=
name|httpd
operator|->
name|recvbuf
operator|+
literal|5
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
block|}
comment|/* 	 * From now on, p is the start of our buffer. 	 */
comment|/* 	 * Extract the URL. 	 */
name|s
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|LENGTHOK
argument_list|(
name|s
argument_list|)
operator|&&
name|BUFLENOK
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\r'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|LENGTHOK
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
if|if
condition|(
operator|!
name|BUFLENOK
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make the URL relative. 	 */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"http:/"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"https:/"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Skip first / */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
name|p
operator|++
expr_stmt|;
comment|/* Skip second / */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
name|p
operator|++
expr_stmt|;
comment|/* Find third / */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|--
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
name|httpd
operator|->
name|url
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|s
operator|+
name|delim
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
comment|/* 	 * Now, see if there is a ? mark in the URL.  If so, this is 	 * part of the query string, and we will split it from the URL. 	 */
name|httpd
operator|->
name|querystring
operator|=
name|strchr
argument_list|(
name|httpd
operator|->
name|url
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
name|httpd
operator|->
name|querystring
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|(
name|httpd
operator|->
name|querystring
operator|)
operator|=
literal|0
expr_stmt|;
name|httpd
operator|->
name|querystring
operator|++
expr_stmt|;
block|}
comment|/* 	 * Extract the HTTP/1.X protocol.  We will bounce on anything but 	 * HTTP/1.1 for now. 	 */
while|while
condition|(
name|LENGTHOK
argument_list|(
name|s
argument_list|)
operator|&&
name|BUFLENOK
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\r'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|LENGTHOK
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
if|if
condition|(
operator|!
name|BUFLENOK
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"HTTP/1.0"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"HTTP/1.1"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
name|httpd
operator|->
name|protocol
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|s
argument_list|,
literal|"Connection: close"
argument_list|)
operator|!=
name|NULL
condition|)
name|httpd
operator|->
name|flags
operator||=
name|HTTPD_CLOSE
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|s
argument_list|,
literal|"Host: "
argument_list|)
operator|!=
name|NULL
condition|)
name|httpd
operator|->
name|flags
operator||=
name|HTTPD_FOUNDHOST
expr_stmt|;
comment|/* 	 * Standards compliance hooks here. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|httpd
operator|->
name|protocol
argument_list|,
literal|"HTTP/1.1"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|httpd
operator|->
name|flags
operator|&
name|HTTPD_FOUNDHOST
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
name|EXIT
argument_list|(
literal|"request"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isc_httpd_accept
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_httpdmgr_t
modifier|*
name|httpdmgr
init|=
name|ev
operator|->
name|ev_arg
decl_stmt|;
name|isc_httpd_t
modifier|*
name|httpd
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|nev
init|=
operator|(
name|isc_socket_newconnev_t
operator|*
operator|)
name|ev
decl_stmt|;
name|isc_sockaddr_t
name|peeraddr
decl_stmt|;
name|ENTER
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|MSHUTTINGDOWN
argument_list|(
name|httpdmgr
argument_list|)
condition|)
block|{
name|NOTICE
argument_list|(
literal|"accept shutting down, goto out"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nev
operator|->
name|result
operator|==
name|ISC_R_CANCELED
condition|)
block|{
name|NOTICE
argument_list|(
literal|"accept canceled, goto out"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nev
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* XXXMLG log failure */
name|NOTICE
argument_list|(
literal|"accept returned failure, goto requeue"
argument_list|)
expr_stmt|;
goto|goto
name|requeue
goto|;
block|}
operator|(
name|void
operator|)
name|isc_socket_getpeername
argument_list|(
name|nev
operator|->
name|newsocket
argument_list|,
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|httpdmgr
operator|->
name|client_ok
operator|!=
name|NULL
operator|&&
operator|!
call|(
name|httpdmgr
operator|->
name|client_ok
call|)
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|httpdmgr
operator|->
name|cb_arg
argument_list|)
condition|)
block|{
name|isc_socket_detach
argument_list|(
operator|&
name|nev
operator|->
name|newsocket
argument_list|)
expr_stmt|;
goto|goto
name|requeue
goto|;
block|}
name|httpd
operator|=
name|isc_mem_get
argument_list|(
name|httpdmgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_httpd_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|httpd
operator|==
name|NULL
condition|)
block|{
comment|/* XXXMLG log failure */
name|NOTICE
argument_list|(
literal|"accept failed to allocate memory, goto requeue"
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|nev
operator|->
name|newsocket
argument_list|)
expr_stmt|;
goto|goto
name|requeue
goto|;
block|}
name|httpd
operator|->
name|mgr
operator|=
name|httpdmgr
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|httpd
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|httpdmgr
operator|->
name|running
argument_list|,
name|httpd
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_HTTPD_SETRECV
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
name|httpd
operator|->
name|sock
operator|=
name|nev
operator|->
name|newsocket
expr_stmt|;
name|isc_socket_setname
argument_list|(
name|httpd
operator|->
name|sock
argument_list|,
literal|"httpd"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|httpd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize the buffer for our headers. 	 */
name|httpd
operator|->
name|headerdata
operator|=
name|isc_mem_get
argument_list|(
name|httpdmgr
operator|->
name|mctx
argument_list|,
name|HTTP_SENDGROW
argument_list|)
expr_stmt|;
if|if
condition|(
name|httpd
operator|->
name|headerdata
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|httpdmgr
operator|->
name|mctx
argument_list|,
name|httpd
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_httpd_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|nev
operator|->
name|newsocket
argument_list|)
expr_stmt|;
goto|goto
name|requeue
goto|;
block|}
name|httpd
operator|->
name|headerlen
operator|=
name|HTTP_SENDGROW
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|,
name|httpd
operator|->
name|headerdata
argument_list|,
name|httpd
operator|->
name|headerlen
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|httpd
operator|->
name|bufflist
argument_list|)
expr_stmt|;
name|isc_buffer_initnull
argument_list|(
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|)
expr_stmt|;
name|reset_client
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
name|r
operator|.
name|base
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|httpd
operator|->
name|recvbuf
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|HTTP_RECVLEN
operator|-
literal|1
expr_stmt|;
name|result
operator|=
name|isc_socket_recv
argument_list|(
name|httpd
operator|->
name|sock
argument_list|,
operator|&
name|r
argument_list|,
literal|1
argument_list|,
name|task
argument_list|,
name|isc_httpd_recvdone
argument_list|,
name|httpd
argument_list|)
expr_stmt|;
comment|/* FIXME!!! */
name|POST
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|NOTICE
argument_list|(
literal|"accept queued recv on socket"
argument_list|)
expr_stmt|;
name|requeue
label|:
name|result
operator|=
name|isc_socket_accept
argument_list|(
name|httpdmgr
operator|->
name|sock
argument_list|,
name|task
argument_list|,
name|isc_httpd_accept
argument_list|,
name|httpdmgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* XXXMLG what to do?  Log failure... */
name|NOTICE
argument_list|(
literal|"accept could not reaccept due to failure"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|UNLOCK
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|httpdmgr_destroy
argument_list|(
name|httpdmgr
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|EXIT
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|render_404
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|querystring
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|int
modifier|*
name|retcode
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|retmsg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|mimetype
parameter_list|,
name|isc_buffer_t
modifier|*
name|b
parameter_list|,
name|isc_httpdfree_t
modifier|*
modifier|*
name|freecb
parameter_list|,
name|void
modifier|*
modifier|*
name|freecb_args
parameter_list|)
block|{
specifier|static
name|char
name|msg
index|[]
init|=
literal|"No such URL."
decl_stmt|;
name|UNUSED
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|querystring
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
operator|*
name|retcode
operator|=
literal|404
expr_stmt|;
operator|*
name|retmsg
operator|=
literal|"No such URL"
expr_stmt|;
operator|*
name|mimetype
operator|=
literal|"text/plain"
expr_stmt|;
name|isc_buffer_reinit
argument_list|(
name|b
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|b
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|freecb
operator|=
name|NULL
expr_stmt|;
operator|*
name|freecb_args
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|render_500
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|querystring
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|int
modifier|*
name|retcode
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|retmsg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|mimetype
parameter_list|,
name|isc_buffer_t
modifier|*
name|b
parameter_list|,
name|isc_httpdfree_t
modifier|*
modifier|*
name|freecb
parameter_list|,
name|void
modifier|*
modifier|*
name|freecb_args
parameter_list|)
block|{
specifier|static
name|char
name|msg
index|[]
init|=
literal|"Internal server failure."
decl_stmt|;
name|UNUSED
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|querystring
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|arg
argument_list|)
expr_stmt|;
operator|*
name|retcode
operator|=
literal|500
expr_stmt|;
operator|*
name|retmsg
operator|=
literal|"Internal server failure"
expr_stmt|;
operator|*
name|mimetype
operator|=
literal|"text/plain"
expr_stmt|;
name|isc_buffer_reinit
argument_list|(
name|b
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|b
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|freecb
operator|=
name|NULL
expr_stmt|;
operator|*
name|freecb_args
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isc_httpd_recvdone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_httpd_t
modifier|*
name|httpd
init|=
name|ev
operator|->
name|ev_arg
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|sev
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|ev
decl_stmt|;
name|isc_httpdurl_t
modifier|*
name|url
decl_stmt|;
name|isc_time_t
name|now
decl_stmt|;
name|char
name|datebuf
index|[
literal|32
index|]
decl_stmt|;
comment|/* Only need 30, but safety first */
name|ENTER
argument_list|(
literal|"recv"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_HTTPD_ISRECV
argument_list|(
name|httpd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sev
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|NOTICE
argument_list|(
literal|"recv destroying client"
argument_list|)
expr_stmt|;
name|destroy_client
argument_list|(
operator|&
name|httpd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|result
operator|=
name|process_request
argument_list|(
name|httpd
argument_list|,
name|sev
operator|->
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
if|if
condition|(
name|httpd
operator|->
name|recvlen
operator|>=
name|HTTP_RECVLEN
operator|-
literal|1
condition|)
block|{
name|destroy_client
argument_list|(
operator|&
name|httpd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|r
operator|.
name|base
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|httpd
operator|->
name|recvbuf
operator|+
name|httpd
operator|->
name|recvlen
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|HTTP_RECVLEN
operator|-
name|httpd
operator|->
name|recvlen
operator|-
literal|1
expr_stmt|;
comment|/* check return code? */
operator|(
name|void
operator|)
name|isc_socket_recv
argument_list|(
name|httpd
operator|->
name|sock
argument_list|,
operator|&
name|r
argument_list|,
literal|1
argument_list|,
name|task
argument_list|,
name|isc_httpd_recvdone
argument_list|,
name|httpd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|destroy_client
argument_list|(
operator|&
name|httpd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ISC_HTTPD_SETSEND
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
comment|/* 	 * XXXMLG Call function here.  Provide an add-header function 	 * which will append the common headers to a response we generate. 	 */
name|isc_buffer_initnull
argument_list|(
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|)
expr_stmt|;
name|isc_time_now
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|isc_time_formathttptimestamp
argument_list|(
operator|&
name|now
argument_list|,
name|datebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|datebuf
argument_list|)
argument_list|)
expr_stmt|;
name|url
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|httpd
operator|->
name|mgr
operator|->
name|urls
argument_list|)
expr_stmt|;
while|while
condition|(
name|url
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|httpd
operator|->
name|url
argument_list|,
name|url
operator|->
name|url
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|url
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|url
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|url
operator|==
name|NULL
condition|)
name|result
operator|=
name|httpd
operator|->
name|mgr
operator|->
name|render_404
argument_list|(
name|httpd
operator|->
name|url
argument_list|,
name|httpd
operator|->
name|querystring
argument_list|,
name|NULL
argument_list|,
operator|&
name|httpd
operator|->
name|retcode
argument_list|,
operator|&
name|httpd
operator|->
name|retmsg
argument_list|,
operator|&
name|httpd
operator|->
name|mimetype
argument_list|,
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|,
operator|&
name|httpd
operator|->
name|freecb
argument_list|,
operator|&
name|httpd
operator|->
name|freecb_arg
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|url
operator|->
name|action
argument_list|(
name|httpd
operator|->
name|url
argument_list|,
name|httpd
operator|->
name|querystring
argument_list|,
name|url
operator|->
name|action_arg
argument_list|,
operator|&
name|httpd
operator|->
name|retcode
argument_list|,
operator|&
name|httpd
operator|->
name|retmsg
argument_list|,
operator|&
name|httpd
operator|->
name|mimetype
argument_list|,
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|,
operator|&
name|httpd
operator|->
name|freecb
argument_list|,
operator|&
name|httpd
operator|->
name|freecb_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|httpd
operator|->
name|mgr
operator|->
name|render_500
argument_list|(
name|httpd
operator|->
name|url
argument_list|,
name|httpd
operator|->
name|querystring
argument_list|,
name|NULL
argument_list|,
operator|&
name|httpd
operator|->
name|retcode
argument_list|,
operator|&
name|httpd
operator|->
name|retmsg
argument_list|,
operator|&
name|httpd
operator|->
name|mimetype
argument_list|,
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|,
operator|&
name|httpd
operator|->
name|freecb
argument_list|,
operator|&
name|httpd
operator|->
name|freecb_arg
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|isc_httpd_response
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
name|isc_httpd_addheader
argument_list|(
name|httpd
argument_list|,
literal|"Content-Type"
argument_list|,
name|httpd
operator|->
name|mimetype
argument_list|)
expr_stmt|;
name|isc_httpd_addheader
argument_list|(
name|httpd
argument_list|,
literal|"Date"
argument_list|,
name|datebuf
argument_list|)
expr_stmt|;
name|isc_httpd_addheader
argument_list|(
name|httpd
argument_list|,
literal|"Expires"
argument_list|,
name|datebuf
argument_list|)
expr_stmt|;
name|isc_httpd_addheader
argument_list|(
name|httpd
argument_list|,
literal|"Last-Modified"
argument_list|,
name|datebuf
argument_list|)
expr_stmt|;
name|isc_httpd_addheader
argument_list|(
name|httpd
argument_list|,
literal|"Pragma: no-cache"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_httpd_addheader
argument_list|(
name|httpd
argument_list|,
literal|"Cache-Control: no-cache"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_httpd_addheader
argument_list|(
name|httpd
argument_list|,
literal|"Server: libisc"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_httpd_addheaderuint
argument_list|(
name|httpd
argument_list|,
literal|"Content-Length"
argument_list|,
name|isc_buffer_usedlength
argument_list|(
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|)
argument_list|)
expr_stmt|;
name|isc_httpd_endheaders
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
comment|/* done */
name|ISC_LIST_APPEND
argument_list|(
name|httpd
operator|->
name|bufflist
argument_list|,
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Link the data buffer into our send queue, should we have any data 	 * rendered into it.  If no data is present, we won't do anything 	 * with the buffer. 	 */
if|if
condition|(
name|isc_buffer_length
argument_list|(
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|)
operator|>
literal|0
condition|)
name|ISC_LIST_APPEND
argument_list|(
name|httpd
operator|->
name|bufflist
argument_list|,
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* check return code? */
operator|(
name|void
operator|)
name|isc_socket_sendv
argument_list|(
name|httpd
operator|->
name|sock
argument_list|,
operator|&
name|httpd
operator|->
name|bufflist
argument_list|,
name|task
argument_list|,
name|isc_httpd_senddone
argument_list|,
name|httpd
argument_list|)
expr_stmt|;
name|out
label|:
name|isc_event_free
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|EXIT
argument_list|(
literal|"recv"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_httpdmgr_shutdown
parameter_list|(
name|isc_httpdmgr_t
modifier|*
modifier|*
name|httpdmgrp
parameter_list|)
block|{
name|isc_httpdmgr_t
modifier|*
name|httpdmgr
decl_stmt|;
name|isc_httpd_t
modifier|*
name|httpd
decl_stmt|;
name|httpdmgr
operator|=
operator|*
name|httpdmgrp
expr_stmt|;
operator|*
name|httpdmgrp
operator|=
name|NULL
expr_stmt|;
name|ENTER
argument_list|(
literal|"isc_httpdmgr_shutdown"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|MSETSHUTTINGDOWN
argument_list|(
name|httpdmgr
argument_list|)
expr_stmt|;
name|isc_socket_cancel
argument_list|(
name|httpdmgr
operator|->
name|sock
argument_list|,
name|httpdmgr
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_ALL
argument_list|)
expr_stmt|;
name|httpd
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|httpdmgr
operator|->
name|running
argument_list|)
expr_stmt|;
while|while
condition|(
name|httpd
operator|!=
name|NULL
condition|)
block|{
name|isc_socket_cancel
argument_list|(
name|httpd
operator|->
name|sock
argument_list|,
name|httpdmgr
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_ALL
argument_list|)
expr_stmt|;
name|httpd
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|httpd
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|httpdmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|EXIT
argument_list|(
literal|"isc_httpdmgr_shutdown"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|grow_headerspace
parameter_list|(
name|isc_httpd_t
modifier|*
name|httpd
parameter_list|)
block|{
name|char
modifier|*
name|newspace
decl_stmt|;
name|unsigned
name|int
name|newlen
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|newlen
operator|=
name|httpd
operator|->
name|headerlen
operator|+
name|HTTP_SENDGROW
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|HTTP_SEND_MAXLEN
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|newspace
operator|=
name|isc_mem_get
argument_list|(
name|httpd
operator|->
name|mgr
operator|->
name|mctx
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newspace
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|isc_buffer_region
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_reinit
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|,
name|newspace
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|httpd
operator|->
name|mgr
operator|->
name|mctx
argument_list|,
name|r
operator|.
name|base
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_httpd_response
parameter_list|(
name|isc_httpd_t
modifier|*
name|httpd
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|needlen
decl_stmt|;
name|needlen
operator|=
name|strlen
argument_list|(
name|httpd
operator|->
name|protocol
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* protocol + space */
name|needlen
operator|+=
literal|3
operator|+
literal|1
expr_stmt|;
comment|/* room for response code, always 3 bytes */
name|needlen
operator|+=
name|strlen
argument_list|(
name|httpd
operator|->
name|retmsg
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* return msg + CRLF */
while|while
condition|(
name|isc_buffer_availablelength
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|)
operator|<
name|needlen
condition|)
block|{
name|result
operator|=
name|grow_headerspace
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|isc_buffer_used
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|)
argument_list|,
literal|"%s %03d %s\r\n"
argument_list|,
name|httpd
operator|->
name|protocol
argument_list|,
name|httpd
operator|->
name|retcode
argument_list|,
name|httpd
operator|->
name|retmsg
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|,
name|needlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_httpd_addheader
parameter_list|(
name|isc_httpd_t
modifier|*
name|httpd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|needlen
decl_stmt|;
name|needlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* name itself */
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
name|needlen
operator|+=
literal|2
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* :<space> and val */
name|needlen
operator|+=
literal|2
expr_stmt|;
comment|/* CRLF */
while|while
condition|(
name|isc_buffer_availablelength
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|)
operator|<
name|needlen
condition|)
block|{
name|result
operator|=
name|grow_headerspace
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|isc_buffer_used
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|)
argument_list|,
literal|"%s: %s\r\n"
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|isc_buffer_used
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|)
argument_list|,
literal|"%s\r\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|,
name|needlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_httpd_endheaders
parameter_list|(
name|isc_httpd_t
modifier|*
name|httpd
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
while|while
condition|(
name|isc_buffer_availablelength
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|)
operator|<
literal|2
condition|)
block|{
name|result
operator|=
name|grow_headerspace
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|isc_buffer_used
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|)
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_httpd_addheaderuint
parameter_list|(
name|isc_httpd_t
modifier|*
name|httpd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|needlen
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
expr|"18446744073709551616"]
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|needlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* name itself */
name|needlen
operator|+=
literal|2
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* :<space> and val */
name|needlen
operator|+=
literal|2
expr_stmt|;
comment|/* CRLF */
while|while
condition|(
name|isc_buffer_availablelength
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|)
operator|<
name|needlen
condition|)
block|{
name|result
operator|=
name|grow_headerspace
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|isc_buffer_used
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|)
argument_list|,
literal|"%s: %s\r\n"
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|,
name|needlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isc_httpd_senddone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc_httpd_t
modifier|*
name|httpd
init|=
name|ev
operator|->
name|ev_arg
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|sev
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|ev
decl_stmt|;
name|ENTER
argument_list|(
literal|"senddone"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_HTTPD_ISSEND
argument_list|(
name|httpd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * First, unlink our header buffer from the socket's bufflist.  This 	 * is sort of an evil hack, since we know our buffer will be there, 	 * and we know it's address, so we can just remove it directly. 	 */
name|NOTICE
argument_list|(
literal|"senddone unlinked header"
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|sev
operator|->
name|bufferlist
argument_list|,
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * We will always want to clean up our receive buffer, even if we 	 * got an error on send or we are shutting down. 	 * 	 * We will pass in the buffer only if there is data in it.  If 	 * there is no data, we will pass in a NULL. 	 */
if|if
condition|(
name|httpd
operator|->
name|freecb
operator|!=
name|NULL
condition|)
block|{
name|isc_buffer_t
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|isc_buffer_length
argument_list|(
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|)
operator|>
literal|0
condition|)
name|b
operator|=
operator|&
name|httpd
operator|->
name|bodybuffer
expr_stmt|;
name|httpd
operator|->
name|freecb
argument_list|(
name|b
argument_list|,
name|httpd
operator|->
name|freecb_arg
argument_list|)
expr_stmt|;
name|NOTICE
argument_list|(
literal|"senddone free callback performed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|sev
operator|->
name|bufferlist
argument_list|,
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|NOTICE
argument_list|(
literal|"senddone body buffer unlinked"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sev
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|destroy_client
argument_list|(
operator|&
name|httpd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|httpd
operator|->
name|flags
operator|&
name|HTTPD_CLOSE
operator|)
operator|!=
literal|0
condition|)
block|{
name|destroy_client
argument_list|(
operator|&
name|httpd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ISC_HTTPD_SETRECV
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
name|NOTICE
argument_list|(
literal|"senddone restarting recv on socket"
argument_list|)
expr_stmt|;
name|reset_client
argument_list|(
name|httpd
argument_list|)
expr_stmt|;
name|r
operator|.
name|base
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|httpd
operator|->
name|recvbuf
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|HTTP_RECVLEN
operator|-
literal|1
expr_stmt|;
comment|/* check return code? */
operator|(
name|void
operator|)
name|isc_socket_recv
argument_list|(
name|httpd
operator|->
name|sock
argument_list|,
operator|&
name|r
argument_list|,
literal|1
argument_list|,
name|task
argument_list|,
name|isc_httpd_recvdone
argument_list|,
name|httpd
argument_list|)
expr_stmt|;
name|out
label|:
name|isc_event_free
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|EXIT
argument_list|(
literal|"senddone"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_client
parameter_list|(
name|isc_httpd_t
modifier|*
name|httpd
parameter_list|)
block|{
comment|/* 	 * Catch errors here.  We MUST be in RECV mode, and we MUST NOT have 	 * any outstanding buffers.  If we have buffers, we have a leak. 	 */
name|INSIST
argument_list|(
name|ISC_HTTPD_ISRECV
argument_list|(
name|httpd
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|httpd
operator|->
name|recvbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|httpd
operator|->
name|recvlen
operator|=
literal|0
expr_stmt|;
name|httpd
operator|->
name|method
operator|=
name|ISC_HTTPD_METHODUNKNOWN
expr_stmt|;
name|httpd
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
name|httpd
operator|->
name|querystring
operator|=
name|NULL
expr_stmt|;
name|httpd
operator|->
name|protocol
operator|=
name|NULL
expr_stmt|;
name|httpd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|isc_buffer_clear
argument_list|(
operator|&
name|httpd
operator|->
name|headerbuffer
argument_list|)
expr_stmt|;
name|isc_buffer_invalidate
argument_list|(
operator|&
name|httpd
operator|->
name|bodybuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_httpdmgr_addurl
parameter_list|(
name|isc_httpdmgr_t
modifier|*
name|httpdmgr
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|isc_httpdaction_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_httpdurl_t
modifier|*
name|item
decl_stmt|;
if|if
condition|(
name|url
operator|==
name|NULL
condition|)
block|{
name|httpdmgr
operator|->
name|render_404
operator|=
name|func
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|item
operator|=
name|isc_mem_get
argument_list|(
name|httpdmgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_httpdurl_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|item
operator|->
name|url
operator|=
name|isc_mem_strdup
argument_list|(
name|httpdmgr
operator|->
name|mctx
argument_list|,
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|url
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|httpdmgr
operator|->
name|mctx
argument_list|,
name|item
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_httpdurl_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|item
operator|->
name|action
operator|=
name|func
expr_stmt|;
name|item
operator|->
name|action_arg
operator|=
name|arg
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|item
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|httpdmgr
operator|->
name|urls
argument_list|,
name|item
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

