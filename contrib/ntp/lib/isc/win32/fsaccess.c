begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2007  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2000-2002  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: fsaccess.c,v 1.15 2007/06/19 23:47:19 tbox Exp $ */
end_comment

begin_comment
comment|/*  * Note that Win32 does not have the concept of files having access  * and ownership bits.  The FAT File system only has a readonly flag  * for everyone and that's all. NTFS uses ACL's which is a totally  * different concept of controlling access.  *  * This code needs to be revisited to set up proper access control for  * NTFS file systems.  Nothing can be done for FAT file systems.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<aclapi.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<isc/file.h>
end_include

begin_include
include|#
directive|include
file|<isc/stat.h>
end_include

begin_include
include|#
directive|include
file|"errno2result.h"
end_include

begin_comment
comment|/*  * The OS-independent part of the API is in lib/isc.  */
end_comment

begin_include
include|#
directive|include
file|"../fsaccess.c"
end_include

begin_comment
comment|/* Store the user account name locally */
end_comment

begin_decl_stmt
specifier|static
name|char
name|username
index|[
literal|255
index|]
init|=
literal|"\0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DWORD
name|namelen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * In order to set or retrieve access information, we need to obtain  * the File System type.  These could be UNC-type shares.  */
end_comment

begin_function
name|BOOL
name|is_ntfs
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|char
name|drive
index|[
literal|255
index|]
decl_stmt|;
name|char
name|FSType
index|[
literal|20
index|]
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|machinename
decl_stmt|;
name|char
modifier|*
name|sharename
decl_stmt|;
name|char
name|filename
index|[
literal|1024
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_file_absolutepath
argument_list|(
name|file
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * Look for c:\path\... style, c:/path/... or \\computer\shar\path... 	 * the UNC style file specs 	 */
if|if
condition|(
name|isalpha
argument_list|(
name|filename
index|[
literal|0
index|]
argument_list|)
operator|&&
name|filename
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
operator|(
name|filename
index|[
literal|2
index|]
operator|==
literal|'\\'
operator|||
name|filename
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
name|strncpy
argument_list|(
name|drive
argument_list|,
name|filename
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|drive
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
comment|/* Find the machine and share name and rebuild the UNC */
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|machinename
operator|=
name|strtok
argument_list|(
name|tmpbuf
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
name|sharename
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|drive
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|drive
argument_list|,
name|machinename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|drive
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|drive
argument_list|,
name|sharename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|drive
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not determinable */
return|return
operator|(
name|FALSE
operator|)
return|;
name|GetVolumeInformation
argument_list|(
name|drive
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FSType
argument_list|,
sizeof|sizeof
argument_list|(
name|FSType
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|FSType
argument_list|,
literal|"NTFS"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If it's not NTFS, we assume that it is FAT and proceed  * with almost nothing to do. Only the write flag can be set or  * cleared.  */
end_comment

begin_function
name|isc_result_t
name|FAT_fsaccess_set
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|isc_fsaccess_t
name|access
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|isc_fsaccess_t
name|bits
decl_stmt|;
comment|/* 	 * Done with checking bad bits.  Set mode_t. 	 */
name|mode
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|SET_AND_CLEAR1
parameter_list|(
name|modebit
parameter_list|)
define|\
value|if ((access& bits) != 0) { \ 		mode |= modebit; \ 		access&= ~bits; \ 	}
define|#
directive|define
name|SET_AND_CLEAR
parameter_list|(
name|user
parameter_list|,
name|group
parameter_list|,
name|other
parameter_list|)
define|\
value|SET_AND_CLEAR1(user); \ 	bits<<= STEP; \ 	SET_AND_CLEAR1(group); \ 	bits<<= STEP; \ 	SET_AND_CLEAR1(other);
name|bits
operator|=
name|ISC_FSACCESS_READ
operator||
name|ISC_FSACCESS_LISTDIRECTORY
expr_stmt|;
name|SET_AND_CLEAR
argument_list|(
name|S_IRUSR
argument_list|,
name|S_IRGRP
argument_list|,
name|S_IROTH
argument_list|)
expr_stmt|;
name|bits
operator|=
name|ISC_FSACCESS_WRITE
operator||
name|ISC_FSACCESS_CREATECHILD
operator||
name|ISC_FSACCESS_DELETECHILD
expr_stmt|;
name|SET_AND_CLEAR
argument_list|(
name|S_IWUSR
argument_list|,
name|S_IWGRP
argument_list|,
name|S_IWOTH
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|access
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_chmod
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|isc__errno2result
argument_list|(
name|errno
argument_list|)
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|NTFS_Access_Control
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|,
name|int
name|access
parameter_list|,
name|isc_boolean_t
name|isdir
parameter_list|)
block|{
name|SECURITY_DESCRIPTOR
name|sd
decl_stmt|;
name|BYTE
name|aclBuffer
index|[
literal|1024
index|]
decl_stmt|;
name|PACL
name|pacl
init|=
operator|(
name|PACL
operator|)
operator|&
name|aclBuffer
decl_stmt|;
name|BYTE
name|sidBuffer
index|[
literal|100
index|]
decl_stmt|;
name|PSID
name|psid
init|=
operator|(
name|PSID
operator|)
operator|&
name|sidBuffer
decl_stmt|;
name|DWORD
name|sidBufferSize
init|=
sizeof|sizeof
argument_list|(
name|sidBuffer
argument_list|)
decl_stmt|;
name|BYTE
name|adminSidBuffer
index|[
literal|100
index|]
decl_stmt|;
name|PSID
name|padminsid
init|=
operator|(
name|PSID
operator|)
operator|&
name|adminSidBuffer
decl_stmt|;
name|DWORD
name|adminSidBufferSize
init|=
sizeof|sizeof
argument_list|(
name|adminSidBuffer
argument_list|)
decl_stmt|;
name|BYTE
name|otherSidBuffer
index|[
literal|100
index|]
decl_stmt|;
name|PSID
name|pothersid
init|=
operator|(
name|PSID
operator|)
operator|&
name|otherSidBuffer
decl_stmt|;
name|DWORD
name|otherSidBufferSize
init|=
sizeof|sizeof
argument_list|(
name|otherSidBuffer
argument_list|)
decl_stmt|;
name|char
name|domainBuffer
index|[
literal|100
index|]
decl_stmt|;
name|DWORD
name|domainBufferSize
init|=
sizeof|sizeof
argument_list|(
name|domainBuffer
argument_list|)
decl_stmt|;
name|SID_NAME_USE
name|snu
decl_stmt|;
name|int
name|errval
decl_stmt|;
name|DWORD
name|NTFSbits
decl_stmt|;
name|int
name|caccess
decl_stmt|;
comment|/* Initialize an ACL */
if|if
condition|(
operator|!
name|InitializeSecurityDescriptor
argument_list|(
operator|&
name|sd
argument_list|,
name|SECURITY_DESCRIPTOR_REVISION
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
if|if
condition|(
operator|!
name|InitializeAcl
argument_list|(
name|pacl
argument_list|,
sizeof|sizeof
argument_list|(
name|aclBuffer
argument_list|)
argument_list|,
name|ACL_REVISION
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
if|if
condition|(
operator|!
name|LookupAccountName
argument_list|(
literal|0
argument_list|,
name|user
argument_list|,
name|psid
argument_list|,
operator|&
name|sidBufferSize
argument_list|,
name|domainBuffer
argument_list|,
operator|&
name|domainBufferSize
argument_list|,
operator|&
name|snu
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
name|domainBufferSize
operator|=
sizeof|sizeof
argument_list|(
name|domainBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LookupAccountName
argument_list|(
literal|0
argument_list|,
literal|"Administrators"
argument_list|,
name|padminsid
argument_list|,
operator|&
name|adminSidBufferSize
argument_list|,
name|domainBuffer
argument_list|,
operator|&
name|domainBufferSize
argument_list|,
operator|&
name|snu
argument_list|)
condition|)
block|{
name|errval
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
block|}
name|domainBufferSize
operator|=
sizeof|sizeof
argument_list|(
name|domainBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LookupAccountName
argument_list|(
literal|0
argument_list|,
literal|"Everyone"
argument_list|,
name|pothersid
argument_list|,
operator|&
name|otherSidBufferSize
argument_list|,
name|domainBuffer
argument_list|,
operator|&
name|domainBufferSize
argument_list|,
operator|&
name|snu
argument_list|)
condition|)
block|{
name|errval
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
block|}
name|caccess
operator|=
name|access
expr_stmt|;
comment|/* Owner check */
name|NTFSbits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_READ
condition|)
name|NTFSbits
operator||=
name|FILE_GENERIC_READ
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_WRITE
condition|)
name|NTFSbits
operator||=
name|FILE_GENERIC_WRITE
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_EXECUTE
condition|)
name|NTFSbits
operator||=
name|FILE_GENERIC_EXECUTE
expr_stmt|;
comment|/* For directories check the directory-specific bits */
if|if
condition|(
name|isdir
operator|==
name|ISC_TRUE
condition|)
block|{
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_CREATECHILD
condition|)
name|NTFSbits
operator||=
name|FILE_ADD_SUBDIRECTORY
operator||
name|FILE_ADD_FILE
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_DELETECHILD
condition|)
name|NTFSbits
operator||=
name|FILE_DELETE_CHILD
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_LISTDIRECTORY
condition|)
name|NTFSbits
operator||=
name|FILE_LIST_DIRECTORY
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_ACCESSCHILD
condition|)
name|NTFSbits
operator||=
name|FILE_TRAVERSE
expr_stmt|;
block|}
if|if
condition|(
name|NTFSbits
operator|==
operator|(
name|FILE_GENERIC_READ
operator||
name|FILE_GENERIC_WRITE
operator||
name|FILE_GENERIC_EXECUTE
operator|)
condition|)
name|NTFSbits
operator||=
name|FILE_ALL_ACCESS
expr_stmt|;
comment|/* 	 * Owner and Administrator also get STANDARD_RIGHTS_ALL 	 * to ensure that they have full control 	 */
name|NTFSbits
operator||=
name|STANDARD_RIGHTS_ALL
expr_stmt|;
comment|/* Add the ACE to the ACL */
if|if
condition|(
operator|!
name|AddAccessAllowedAce
argument_list|(
name|pacl
argument_list|,
name|ACL_REVISION
argument_list|,
name|NTFSbits
argument_list|,
name|psid
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
if|if
condition|(
operator|!
name|AddAccessAllowedAce
argument_list|(
name|pacl
argument_list|,
name|ACL_REVISION
argument_list|,
name|NTFSbits
argument_list|,
name|padminsid
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
comment|/* 	 * Group is ignored since we can be in multiple groups or no group 	 * and its meaning is not clear on Win32 	 */
name|caccess
operator|=
name|caccess
operator|>>
name|STEP
expr_stmt|;
comment|/* 	 * Other check.  We translate this to be the same as Everyone 	 */
name|caccess
operator|=
name|caccess
operator|>>
name|STEP
expr_stmt|;
name|NTFSbits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_READ
condition|)
name|NTFSbits
operator||=
name|FILE_GENERIC_READ
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_WRITE
condition|)
name|NTFSbits
operator||=
name|FILE_GENERIC_WRITE
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_EXECUTE
condition|)
name|NTFSbits
operator||=
name|FILE_GENERIC_EXECUTE
expr_stmt|;
comment|/* For directories check the directory-specific bits */
if|if
condition|(
name|isdir
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_CREATECHILD
condition|)
name|NTFSbits
operator||=
name|FILE_ADD_SUBDIRECTORY
operator||
name|FILE_ADD_FILE
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_DELETECHILD
condition|)
name|NTFSbits
operator||=
name|FILE_DELETE_CHILD
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_LISTDIRECTORY
condition|)
name|NTFSbits
operator||=
name|FILE_LIST_DIRECTORY
expr_stmt|;
if|if
condition|(
name|caccess
operator|&
name|ISC_FSACCESS_ACCESSCHILD
condition|)
name|NTFSbits
operator||=
name|FILE_TRAVERSE
expr_stmt|;
block|}
comment|/* Add the ACE to the ACL */
if|if
condition|(
operator|!
name|AddAccessAllowedAce
argument_list|(
name|pacl
argument_list|,
name|ACL_REVISION
argument_list|,
name|NTFSbits
argument_list|,
name|pothersid
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
if|if
condition|(
operator|!
name|SetSecurityDescriptorDacl
argument_list|(
operator|&
name|sd
argument_list|,
name|TRUE
argument_list|,
name|pacl
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
if|if
condition|(
operator|!
name|SetFileSecurity
argument_list|(
name|filename
argument_list|,
name|DACL_SECURITY_INFORMATION
argument_list|,
operator|&
name|sd
argument_list|)
condition|)
block|{
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|NTFS_fsaccess_set
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|isc_fsaccess_t
name|access
parameter_list|,
name|isc_boolean_t
name|isdir
parameter_list|)
block|{
comment|/* 	 * For NTFS we first need to get the name of the account under 	 * which BIND is running 	 */
if|if
condition|(
name|namelen
operator|<=
literal|0
condition|)
block|{
name|namelen
operator|=
sizeof|sizeof
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetUserName
argument_list|(
name|username
argument_list|,
operator|&
name|namelen
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
return|return
operator|(
name|NTFS_Access_Control
argument_list|(
name|path
argument_list|,
name|username
argument_list|,
name|access
argument_list|,
name|isdir
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_fsaccess_set
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|isc_fsaccess_t
name|access
parameter_list|)
block|{
name|struct
name|stat
name|statb
decl_stmt|;
name|isc_boolean_t
name|is_dir
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|statb
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|isc__errno2result
argument_list|(
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
operator|!=
literal|0
condition|)
name|is_dir
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFREG
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_INVALIDFILE
operator|)
return|;
name|result
operator|=
name|check_bad_bits
argument_list|(
name|access
argument_list|,
name|is_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Determine if this is a FAT or NTFS disk and 	 * call the appropriate function to set the permissions 	 */
if|if
condition|(
name|is_ntfs
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|(
name|NTFS_fsaccess_set
argument_list|(
name|path
argument_list|,
name|access
argument_list|,
name|is_dir
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|FAT_fsaccess_set
argument_list|(
name|path
argument_list|,
name|access
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_fsaccess_changeowner
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|)
block|{
name|SECURITY_DESCRIPTOR
name|psd
decl_stmt|;
name|BYTE
name|sidBuffer
index|[
literal|500
index|]
decl_stmt|;
name|BYTE
name|groupBuffer
index|[
literal|500
index|]
decl_stmt|;
name|PSID
name|psid
init|=
operator|(
name|PSID
operator|)
operator|&
name|sidBuffer
decl_stmt|;
name|DWORD
name|sidBufferSize
init|=
sizeof|sizeof
argument_list|(
name|sidBuffer
argument_list|)
decl_stmt|;
name|char
name|domainBuffer
index|[
literal|100
index|]
decl_stmt|;
name|DWORD
name|domainBufferSize
init|=
sizeof|sizeof
argument_list|(
name|domainBuffer
argument_list|)
decl_stmt|;
name|SID_NAME_USE
name|snu
decl_stmt|;
name|PSID
name|pSidGroup
init|=
operator|(
name|PSID
operator|)
operator|&
name|groupBuffer
decl_stmt|;
name|DWORD
name|groupBufferSize
init|=
sizeof|sizeof
argument_list|(
name|groupBuffer
argument_list|)
decl_stmt|;
comment|/* 	 * Determine if this is a FAT or NTFS disk and 	 * call the appropriate function to set the ownership 	 * FAT disks do not have ownership attributes so it's 	 * a noop. 	 */
if|if
condition|(
name|is_ntfs
argument_list|(
name|filename
argument_list|)
operator|==
name|FALSE
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
operator|!
name|InitializeSecurityDescriptor
argument_list|(
operator|&
name|psd
argument_list|,
name|SECURITY_DESCRIPTOR_REVISION
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
if|if
condition|(
operator|!
name|LookupAccountName
argument_list|(
literal|0
argument_list|,
name|user
argument_list|,
name|psid
argument_list|,
operator|&
name|sidBufferSize
argument_list|,
name|domainBuffer
argument_list|,
operator|&
name|domainBufferSize
argument_list|,
operator|&
name|snu
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
comment|/* Make sure administrators can get to it */
name|domainBufferSize
operator|=
sizeof|sizeof
argument_list|(
name|domainBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LookupAccountName
argument_list|(
literal|0
argument_list|,
literal|"Administrators"
argument_list|,
name|pSidGroup
argument_list|,
operator|&
name|groupBufferSize
argument_list|,
name|domainBuffer
argument_list|,
operator|&
name|domainBufferSize
argument_list|,
operator|&
name|snu
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
if|if
condition|(
operator|!
name|SetSecurityDescriptorOwner
argument_list|(
operator|&
name|psd
argument_list|,
name|psid
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
if|if
condition|(
operator|!
name|SetSecurityDescriptorGroup
argument_list|(
operator|&
name|psd
argument_list|,
name|pSidGroup
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
if|if
condition|(
operator|!
name|SetFileSecurity
argument_list|(
name|filename
argument_list|,
name|OWNER_SECURITY_INFORMATION
operator||
name|GROUP_SECURITY_INFORMATION
argument_list|,
operator|&
name|psd
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

