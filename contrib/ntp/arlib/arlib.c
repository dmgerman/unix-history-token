begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * arlib.c (C)opyright 1993 Darren Reed. All rights reserved.  * This file may not be distributed without the author's permission in any  * shape or form. The author takes no responsibility for any damage or loss  * of property which results from the use of this software.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)arlib.c	1.9 6/5/93 (C)opyright 1992 Darren \ Reed. ASYNC DNS"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|"netdb.h"
end_include

begin_include
include|#
directive|include
file|"arpa/nameser.h"
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|"arlib.h"
end_include

begin_include
include|#
directive|include
file|"arplib.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|,
name|h_errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ar_hostbuf
index|[
literal|65
index|]
decl_stmt|,
name|ar_domainname
index|[
literal|65
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ar_dot
index|[]
init|=
literal|"."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ar_resfd
init|=
operator|-
literal|1
decl_stmt|,
name|ar_vc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|reslist
modifier|*
name|ar_last
decl_stmt|,
modifier|*
name|ar_first
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statistics structure.  */
end_comment

begin_struct
specifier|static
struct|struct
name|resstats
block|{
name|int
name|re_errors
decl_stmt|;
name|int
name|re_nu_look
decl_stmt|;
name|int
name|re_na_look
decl_stmt|;
name|int
name|re_replies
decl_stmt|;
name|int
name|re_requests
decl_stmt|;
name|int
name|re_resends
decl_stmt|;
name|int
name|re_sent
decl_stmt|;
name|int
name|re_timeouts
decl_stmt|;
block|}
name|ar_reinfo
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|do_query_name
parameter_list|(
comment|/* struct resinfo *, char *, struct reslist * */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_query_number
parameter_list|(
comment|/* struct resinfo *, char *, struct reslist * */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ar_resend_query
parameter_list|(
comment|/* struct reslist * */
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ar_init  *  * Initializes the various ARLIB internal varilables and related DNS  * options for res_init().  *  * Returns 0 or the socket opened for use with talking to name servers  * if 0 is passed or ARES_INITSOCK is set.  */
end_comment

begin_function
name|int
name|ar_init
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|op
operator|&
name|ARES_INITLIST
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|ar_reinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|ar_reinfo
argument_list|)
argument_list|)
expr_stmt|;
name|ar_first
operator|=
name|ar_last
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|ARES_CALLINIT
operator|&&
operator|!
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
condition|)
block|{
name|ret
operator|=
name|res_init
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ar_domainname
argument_list|,
name|ar_dot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|ar_domainname
argument_list|,
name|_res
operator|.
name|defdname
argument_list|,
sizeof|sizeof
argument_list|(
name|ar_domainname
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|ARES_INITSOCK
condition|)
name|ret
operator|=
name|ar_resfd
operator|=
name|ar_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|ARES_INITDEBG
condition|)
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
name|ret
operator|=
name|ar_resfd
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * ar_open  *  * Open a socket to talk to a name server with.  * Check _res.options to see if we use a TCP or UDP socket.  */
end_comment

begin_function
name|int
name|ar_open
parameter_list|()
block|{
if|if
condition|(
name|ar_resfd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_USEVC
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sip
operator|=
name|_res
operator|.
name|NS_ADDR_LIST
expr_stmt|;
comment|/* was _res.nsaddr_list */
name|ar_vc
operator|=
literal|1
expr_stmt|;
name|ar_resfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Try each name server listed in sequence until we 			 * succeed or run out. 			 */
while|while
condition|(
name|connect
argument_list|(
name|ar_resfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sip
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ar_resfd
argument_list|)
expr_stmt|;
name|ar_resfd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|_res
operator|.
name|nscount
condition|)
break|break;
name|ar_resfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ar_resfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ar_resfd
operator|>=
literal|0
condition|)
block|{
comment|/* Need one of these two here - and it MUST work!! */
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|ar_resfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
ifdef|#
directive|ifdef
name|O_NONBLOCK
if|if
condition|(
name|fcntl
argument_list|(
name|ar_resfd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|O_NDELAY
if|if
condition|(
name|fcntl
argument_list|(
name|ar_resfd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_NDELAY
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|FNDELAY
if|if
condition|(
name|fcntl
argument_list|(
name|ar_resfd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|FNDELAY
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ar_resfd
argument_list|)
expr_stmt|;
name|ar_resfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|ar_resfd
return|;
block|}
end_function

begin_comment
comment|/*  * ar_close  *  * Closes and flags the ARLIB socket as closed.  */
end_comment

begin_function
name|void
name|ar_close
parameter_list|()
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ar_resfd
argument_list|)
expr_stmt|;
name|ar_resfd
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ar_add_request  *  * Add a new DNS query to the end of the query list.  */
end_comment

begin_function
specifier|static
name|int
name|ar_add_request
parameter_list|(
name|new
parameter_list|)
name|struct
name|reslist
modifier|*
name|new
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|new
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|ar_first
condition|)
name|ar_first
operator|=
name|ar_last
operator|=
name|new
expr_stmt|;
else|else
block|{
name|ar_last
operator|->
name|re_next
operator|=
name|new
expr_stmt|;
name|ar_last
operator|=
name|new
expr_stmt|;
block|}
name|new
operator|->
name|re_next
operator|=
name|NULL
expr_stmt|;
name|ar_reinfo
operator|.
name|re_requests
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ar_remrequest  *  * Remove a request from the list. This must also free any memory that has  * been allocated for temporary storage of DNS results.  *  * Returns -1 if there are anyy problems removing the requested structure  * or 0 if the remove is successful.  */
end_comment

begin_function
specifier|static
name|int
name|ar_remrequest
parameter_list|(
name|old
parameter_list|)
name|struct
name|reslist
modifier|*
name|old
decl_stmt|;
block|{
specifier|register
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|,
modifier|*
name|r2ptr
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|rptr
operator|=
name|ar_first
operator|,
name|r2ptr
operator|=
name|NULL
init|;
name|rptr
condition|;
name|rptr
operator|=
name|rptr
operator|->
name|re_next
control|)
block|{
if|if
condition|(
name|rptr
operator|==
name|old
condition|)
break|break;
name|r2ptr
operator|=
name|rptr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rptr
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|rptr
operator|==
name|ar_first
condition|)
name|ar_first
operator|=
name|ar_first
operator|->
name|re_next
expr_stmt|;
elseif|else
if|if
condition|(
name|rptr
operator|==
name|ar_last
condition|)
block|{
if|if
condition|(
name|ar_last
operator|=
name|r2ptr
condition|)
name|ar_last
operator|->
name|re_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|r2ptr
operator|->
name|re_next
operator|=
name|rptr
operator|->
name|re_next
expr_stmt|;
if|if
condition|(
operator|!
name|ar_first
condition|)
name|ar_last
operator|=
name|ar_first
expr_stmt|;
ifdef|#
directive|ifdef
name|ARLIB_DEBUG
name|ar_dump_hostent
argument_list|(
literal|"ar_remrequest:"
argument_list|,
name|rptr
operator|->
name|re_he
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rptr
operator|->
name|re_he
operator|.
name|h_name
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|rptr
operator|->
name|re_he
operator|.
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|rptr
operator|->
name|re_he
operator|.
name|h_aliases
condition|)
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
operator|(
name|void
operator|)
name|free
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ar_make_request  *  * Create a DNS query recorded for the request being made and place it on the  * current list awaiting replies.  Initialization of the record with set  * values should also be done.  */
end_comment

begin_function
specifier|static
name|struct
name|reslist
modifier|*
name|ar_make_request
parameter_list|(
name|resi
parameter_list|)
specifier|register
name|struct
name|resinfo
modifier|*
name|resi
decl_stmt|;
block|{
specifier|register
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|;
specifier|register
name|struct
name|resinfo
modifier|*
name|rp
decl_stmt|;
name|rptr
operator|=
operator|(
expr|struct
name|reslist
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reslist
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|&
name|rptr
operator|->
name|re_rinfo
expr_stmt|;
name|rptr
operator|->
name|re_next
operator|=
name|NULL
expr_stmt|;
comment|/* where NULL is non-zero ;) */
name|rptr
operator|->
name|re_sentat
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|rptr
operator|->
name|re_retries
operator|=
name|_res
operator|.
name|retry
expr_stmt|;
name|rptr
operator|->
name|re_sends
operator|=
literal|1
expr_stmt|;
name|rptr
operator|->
name|re_resend
operator|=
literal|1
expr_stmt|;
name|rptr
operator|->
name|re_timeout
operator|=
name|rptr
operator|->
name|re_sentat
operator|+
name|_res
operator|.
name|retrans
expr_stmt|;
name|rptr
operator|->
name|re_he
operator|.
name|h_name
operator|=
name|NULL
expr_stmt|;
name|rptr
operator|->
name|re_he
operator|.
name|h_addrtype
operator|=
name|AF_INET
expr_stmt|;
name|rptr
operator|->
name|re_he
operator|.
name|h_aliases
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|ri_ptr
operator|=
name|resi
operator|->
name|ri_ptr
expr_stmt|;
name|rp
operator|->
name|ri_size
operator|=
name|resi
operator|->
name|ri_size
expr_stmt|;
operator|(
name|void
operator|)
name|ar_add_request
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
return|return
name|rptr
return|;
block|}
end_function

begin_comment
comment|/*  * ar_timeout  *  * Remove queries from the list which have been there too long without  * being resolved.  */
end_comment

begin_function
name|long
name|ar_timeout
parameter_list|(
name|now
parameter_list|,
name|info
parameter_list|,
name|size
parameter_list|)
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|,
modifier|*
name|r2ptr
decl_stmt|;
specifier|register
name|long
name|next
init|=
literal|0
decl_stmt|;
for|for
control|(
name|rptr
operator|=
name|ar_first
operator|,
name|r2ptr
operator|=
name|NULL
init|;
name|rptr
condition|;
name|rptr
operator|=
name|r2ptr
control|)
block|{
name|r2ptr
operator|=
name|rptr
operator|->
name|re_next
expr_stmt|;
if|if
condition|(
name|now
operator|>=
name|rptr
operator|->
name|re_timeout
condition|)
block|{
comment|/* 			 * If the timeout for the query has been exceeded, 			 * then resend the query if we still have some 			 * 'retry credit' and reset the timeout. If we have 			 * used it all up, then remove the request. 			 */
if|if
condition|(
operator|--
name|rptr
operator|->
name|re_retries
operator|<=
literal|0
condition|)
block|{
name|ar_reinfo
operator|.
name|re_timeouts
operator|++
expr_stmt|;
if|if
condition|(
name|info
operator|&&
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
condition|)
name|bcopy
argument_list|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
argument_list|,
name|info
argument_list|,
name|MIN
argument_list|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_size
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ar_remrequest
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
return|return
name|now
return|;
block|}
else|else
block|{
name|rptr
operator|->
name|re_sends
operator|++
expr_stmt|;
name|rptr
operator|->
name|re_sentat
operator|=
name|now
expr_stmt|;
name|rptr
operator|->
name|re_timeout
operator|=
name|now
operator|+
name|_res
operator|.
name|retrans
expr_stmt|;
operator|(
name|void
operator|)
name|ar_resend_query
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|next
operator|||
name|rptr
operator|->
name|re_timeout
operator|<
name|next
condition|)
name|next
operator|=
name|rptr
operator|->
name|re_timeout
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/*  * ar_send_res_msg  *  * When sending queries to nameservers listed in the resolv.conf file,  * don't send a query to every one, but increase the number sent linearly  * to match the number of resends. This increase only occurs if there are  * multiple nameserver entries in the resolv.conf file.  * The return value is the number of messages successfully sent to   * nameservers or -1 if no successful sends.  */
end_comment

begin_function
specifier|static
name|int
name|ar_send_res_msg
parameter_list|(
name|msg
parameter_list|,
name|len
parameter_list|,
name|rcount
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|len
decl_stmt|,
name|rcount
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|sent
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
return|return
operator|-
literal|1
return|;
name|rcount
operator|=
operator|(
name|_res
operator|.
name|nscount
operator|>
name|rcount
operator|)
condition|?
name|rcount
else|:
name|_res
operator|.
name|nscount
expr_stmt|;
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_PRIMARY
condition|)
name|rcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ar_vc
condition|)
block|{
name|ar_reinfo
operator|.
name|re_sent
operator|++
expr_stmt|;
name|sent
operator|++
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|ar_resfd
argument_list|,
name|msg
argument_list|,
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errtmp
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ar_resfd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|errtmp
expr_stmt|;
name|ar_resfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sendto
argument_list|(
name|ar_resfd
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
operator|(
name|_res
operator|.
name|NS_ADDR_LIST
index|[
name|i
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|==
name|len
condition|)
block|{
name|ar_reinfo
operator|.
name|re_sent
operator|++
expr_stmt|;
name|sent
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|sent
operator|)
condition|?
name|sent
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * ar_find_id  *  * find a dns query record by the id (id is determined by dn_mkquery)  */
end_comment

begin_function
specifier|static
name|struct
name|reslist
modifier|*
name|ar_find_id
parameter_list|(
name|id
parameter_list|)
name|int
name|id
decl_stmt|;
block|{
specifier|register
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|;
for|for
control|(
name|rptr
operator|=
name|ar_first
init|;
name|rptr
condition|;
name|rptr
operator|=
name|rptr
operator|->
name|re_next
control|)
if|if
condition|(
name|rptr
operator|->
name|re_id
operator|==
name|id
condition|)
return|return
name|rptr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * ar_delete  *  * Delete a request from the waiting list if it has a data pointer which  * matches the one passed.  */
end_comment

begin_function
name|int
name|ar_delete
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|;
specifier|register
name|struct
name|reslist
modifier|*
name|r2ptr
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|rptr
operator|=
name|ar_first
init|;
name|rptr
condition|;
name|rptr
operator|=
name|r2ptr
control|)
block|{
name|r2ptr
operator|=
name|rptr
operator|->
name|re_next
expr_stmt|;
if|if
condition|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
operator|&&
name|ptr
operator|&&
name|size
operator|&&
name|bcmp
argument_list|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ar_remrequest
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
name|removed
operator|++
expr_stmt|;
block|}
block|}
return|return
name|removed
return|;
block|}
end_function

begin_comment
comment|/*  * ar_query_name  *  * generate a query based on class, type and name.  */
end_comment

begin_function
specifier|static
name|int
name|ar_query_name
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|,
name|rptr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXPACKET
index|]
decl_stmt|;
name|int
name|r
decl_stmt|,
name|s
decl_stmt|,
name|a
decl_stmt|;
name|HEADER
modifier|*
name|hptr
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
block|{
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|r
return|;
block|}
name|hptr
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
expr_stmt|;
name|rptr
operator|->
name|re_id
operator|=
name|ntohs
argument_list|(
name|hptr
operator|->
name|id
argument_list|)
expr_stmt|;
name|s
operator|=
name|ar_send_res_msg
argument_list|(
name|buf
argument_list|,
name|r
argument_list|,
name|rptr
operator|->
name|re_sends
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
block|{
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
name|rptr
operator|->
name|re_sent
operator|+=
name|s
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ar_gethostbyname  *  * Replacement library function call to gethostbyname().  This one, however,  * doesn't return the record being looked up but just places the query in the  * queue to await answers.  */
end_comment

begin_function
name|int
name|ar_gethostbyname
parameter_list|(
name|name
parameter_list|,
name|info
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
name|host
index|[
literal|65
index|]
decl_stmt|;
name|struct
name|resinfo
name|resi
decl_stmt|;
specifier|register
name|struct
name|resinfo
modifier|*
name|rp
init|=
operator|&
name|resi
decl_stmt|;
if|if
condition|(
name|size
operator|&&
name|info
condition|)
block|{
name|rp
operator|->
name|ri_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|info
argument_list|,
name|rp
operator|->
name|ri_ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ri_size
operator|=
name|size
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|resi
argument_list|)
argument_list|)
expr_stmt|;
name|ar_reinfo
operator|.
name|re_na_look
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|host
argument_list|,
name|name
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|host
index|[
literal|64
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|do_query_name
argument_list|(
name|rp
argument_list|,
name|host
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_query_name
parameter_list|(
name|resi
parameter_list|,
name|name
parameter_list|,
name|rptr
parameter_list|)
name|struct
name|resinfo
modifier|*
name|resi
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|;
block|{
name|char
name|hname
index|[
literal|65
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|strncpy
argument_list|(
name|hname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|hname
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rptr
operator|&&
operator|(
name|hname
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|hname
argument_list|,
name|ar_dot
argument_list|,
sizeof|sizeof
argument_list|(
name|hname
argument_list|)
operator|-
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * NOTE: The logical relationship between DNSRCH and DEFNAMES 		 * is implies. ie no DEFNAES, no DNSRCH. 		 */
if|if
condition|(
name|_res
operator|.
name|options
operator|&
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator|)
operator|==
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator|)
condition|)
block|{
if|if
condition|(
name|_res
operator|.
name|dnsrch
index|[
name|rptr
operator|->
name|re_srch
index|]
condition|)
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|hname
argument_list|,
name|_res
operator|.
name|dnsrch
index|[
name|rptr
operator|->
name|re_srch
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|hname
argument_list|)
operator|-
operator|++
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEFNAMES
condition|)
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|hname
argument_list|,
name|ar_domainname
argument_list|,
sizeof|sizeof
argument_list|(
name|hname
argument_list|)
operator|-
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Store the name passed as the one to lookup and generate other host 	 * names to pass onto the nameserver(s) for lookups. 	 */
if|if
condition|(
operator|!
name|rptr
condition|)
block|{
name|rptr
operator|=
name|ar_make_request
argument_list|(
name|resi
argument_list|)
expr_stmt|;
name|rptr
operator|->
name|re_type
operator|=
name|T_A
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|rptr
operator|->
name|re_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|rptr
operator|->
name|re_name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ar_query_name
argument_list|(
name|hname
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
name|rptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_gethostbyaddr  *  * Generates a query for a given IP address.  */
end_comment

begin_function
name|int
name|ar_gethostbyaddr
parameter_list|(
name|addr
parameter_list|,
name|info
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|resinfo
name|resi
decl_stmt|;
specifier|register
name|struct
name|resinfo
modifier|*
name|rp
init|=
operator|&
name|resi
decl_stmt|;
if|if
condition|(
name|size
operator|&&
name|info
condition|)
block|{
name|rp
operator|->
name|ri_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|info
argument_list|,
name|rp
operator|->
name|ri_ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ri_size
operator|=
name|size
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|resi
argument_list|)
argument_list|)
expr_stmt|;
name|ar_reinfo
operator|.
name|re_nu_look
operator|++
expr_stmt|;
return|return
operator|(
name|do_query_number
argument_list|(
name|rp
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * do_query_number  *  * Use this to do reverse IP# lookups.  */
end_comment

begin_function
specifier|static
name|int
name|do_query_number
parameter_list|(
name|resi
parameter_list|,
name|numb
parameter_list|,
name|rptr
parameter_list|)
name|struct
name|resinfo
modifier|*
name|resi
decl_stmt|;
name|char
modifier|*
name|numb
decl_stmt|;
specifier|register
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|ipbuf
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 * Generate name in the "in-addr.arpa" domain.  No addings bits to this 	 * name to get more names to query!. 	 */
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|numb
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ipbuf
argument_list|,
literal|"%u.%u.%u.%u.in-addr.arpa."
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|cp
index|[
literal|3
index|]
argument_list|)
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|)
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rptr
condition|)
block|{
name|rptr
operator|=
name|ar_make_request
argument_list|(
name|resi
argument_list|)
expr_stmt|;
name|rptr
operator|->
name|re_type
operator|=
name|T_PTR
expr_stmt|;
name|rptr
operator|->
name|re_he
operator|.
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|numb
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rptr
operator|->
name|re_addr
argument_list|,
name|rptr
operator|->
name|re_he
operator|.
name|h_length
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|numb
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rptr
operator|->
name|re_he
operator|.
name|h_addr_list
index|[
literal|0
index|]
operator|.
name|s_addr
argument_list|,
name|rptr
operator|->
name|re_he
operator|.
name|h_length
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ar_query_name
argument_list|(
name|ipbuf
argument_list|,
name|C_IN
argument_list|,
name|T_PTR
argument_list|,
name|rptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_resent_query  *  * resends a query.  */
end_comment

begin_function
specifier|static
name|int
name|ar_resend_query
parameter_list|(
name|rptr
parameter_list|)
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|rptr
operator|->
name|re_resend
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|rptr
operator|->
name|re_type
condition|)
block|{
case|case
name|T_PTR
case|:
name|ar_reinfo
operator|.
name|re_resends
operator|++
expr_stmt|;
return|return
name|do_query_number
argument_list|(
name|NULL
argument_list|,
operator|&
name|rptr
operator|->
name|re_addr
argument_list|,
name|rptr
argument_list|)
return|;
case|case
name|T_A
case|:
name|ar_reinfo
operator|.
name|re_resends
operator|++
expr_stmt|;
return|return
name|do_query_name
argument_list|(
name|NULL
argument_list|,
name|rptr
operator|->
name|re_name
argument_list|,
name|rptr
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * ar_procanswer  *  * process an answer received from a nameserver.  */
end_comment

begin_function
specifier|static
name|int
name|ar_procanswer
parameter_list|(
name|rptr
parameter_list|,
name|hptr
parameter_list|,
name|buf
parameter_list|,
name|eob
parameter_list|)
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
decl|*
name|eob
decl_stmt|;
end_function

begin_decl_stmt
name|HEADER
modifier|*
name|hptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|alias
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|,
name|len
decl_stmt|,
name|ans
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|,
name|dr
decl_stmt|,
modifier|*
name|adr
decl_stmt|;
name|struct
name|hent
modifier|*
name|hp
decl_stmt|;
name|cp
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|adr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|rptr
operator|->
name|re_he
operator|.
name|h_addr_list
expr_stmt|;
while|while
condition|(
operator|*
name|adr
condition|)
name|adr
operator|++
expr_stmt|;
name|alias
operator|=
name|rptr
operator|->
name|re_he
operator|.
name|h_aliases
expr_stmt|;
while|while
condition|(
operator|*
name|alias
condition|)
name|alias
operator|++
expr_stmt|;
name|hp
operator|=
operator|&
name|rptr
operator|->
name|re_he
expr_stmt|;
comment|/* 	 * Skip over the original question. 	 */
while|while
condition|(
name|hptr
operator|->
name|qdcount
operator|--
operator|>
literal|0
condition|)
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eob
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
comment|/* 	 * proccess each answer sent to us. blech. 	 */
while|while
condition|(
name|hptr
operator|->
name|ancount
operator|--
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eob
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|buf
argument_list|,
name|eob
argument_list|,
name|cp
argument_list|,
name|ar_hostbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ar_hostbuf
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
name|ans
return|;
name|ans
operator|++
expr_stmt|;
comment|/* 		 * 'skip' past the general dns crap (ttl, class, etc) to get 		 * the pointer to the right spot.  Some of thse are actually 		 * useful so its not a good idea to skip past in one big jump. 		 */
name|type
operator|=
operator|(
name|int
operator|)
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|class
operator|=
operator|(
name|int
operator|)
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|ttl
operator|=
operator|(
name|u_int32_t
operator|)
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|dlen
operator|=
operator|(
name|int
operator|)
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|rptr
operator|->
name|re_type
operator|=
name|type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
name|rptr
operator|->
name|re_he
operator|.
name|h_length
operator|=
name|dlen
expr_stmt|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
name|rptr
operator|->
name|re_he
operator|.
name|h_addrtype
operator|=
operator|(
name|class
operator|==
name|C_IN
operator|)
condition|?
name|AF_INET
else|:
name|AF_UNSPEC
expr_stmt|;
if|if
condition|(
name|dlen
operator|!=
sizeof|sizeof
argument_list|(
name|dr
argument_list|)
condition|)
block|{
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
continue|continue;
block|}
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|&
name|dr
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
operator|*
name|adr
operator|++
operator|=
name|dr
expr_stmt|;
operator|*
name|adr
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ar_hostbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rptr
operator|->
name|re_he
operator|.
name|h_name
condition|)
block|{
name|rptr
operator|->
name|re_he
operator|.
name|h_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rptr
operator|->
name|re_he
operator|.
name|h_name
condition|)
break|break;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rptr
operator|->
name|re_he
operator|.
name|h_name
argument_list|,
name|ar_hostbuf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_PTR
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|buf
argument_list|,
name|eob
argument_list|,
name|cp
argument_list|,
name|ar_hostbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ar_hostbuf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ar_hostbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 			 * copy the returned hostname into the host name 			 * or alias field if there is a known hostname 			 * already. 			 */
if|if
condition|(
operator|!
name|rptr
operator|->
name|re_he
operator|.
name|h_name
condition|)
block|{
name|rptr
operator|->
name|re_he
operator|.
name|h_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rptr
operator|->
name|re_he
operator|.
name|h_name
condition|)
break|break;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rptr
operator|->
name|re_he
operator|.
name|h_name
argument_list|,
name|ar_hostbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|alias
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|alias
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|*
name|alias
operator|++
argument_list|,
name|ar_hostbuf
argument_list|)
expr_stmt|;
operator|*
name|alias
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|T_CNAME
case|:
name|cp
operator|+=
name|dlen
expr_stmt|;
if|if
condition|(
name|alias
operator|>=
operator|&
operator|(
name|rptr
operator|->
name|re_he
operator|.
name|h_aliases
index|[
name|MAXALIASES
operator|-
literal|1
index|]
operator|)
condition|)
continue|continue;
name|n
operator|=
name|strlen
argument_list|(
name|ar_hostbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|alias
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|alias
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|*
name|alias
operator|++
argument_list|,
name|ar_hostbuf
argument_list|)
expr_stmt|;
operator|*
name|alias
operator|=
name|NULL
expr_stmt|;
break|break;
default|default :
break|break;
block|}
block|}
return|return
name|ans
return|;
block|}
end_block

begin_comment
comment|/*  * ar_answer  *  * Get an answer from a DNS server and process it.  If a query is found to  * which no answer has been given to yet, copy its 'info' structure back  * to where "reip" points and return a pointer to the hostent structure.  */
end_comment

begin_function
name|struct
name|hostent
modifier|*
name|ar_answer
parameter_list|(
name|reip
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|reip
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|static
name|char
name|ar_rcvbuf
index|[
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
operator|+
name|MAXPACKET
index|]
decl_stmt|;
specifier|static
name|struct
name|hostent
name|ar_host
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hptr
decl_stmt|;
specifier|register
name|struct
name|reslist
modifier|*
name|rptr
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|unsigned
name|long
modifier|*
name|adr
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|a
decl_stmt|;
name|rc
operator|=
name|recv
argument_list|(
name|ar_resfd
argument_list|,
name|ar_rcvbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ar_rcvbuf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<=
literal|0
condition|)
goto|goto
name|getres_err
goto|;
name|ar_reinfo
operator|.
name|re_replies
operator|++
expr_stmt|;
name|hptr
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|ar_rcvbuf
expr_stmt|;
comment|/* 	 * convert things to be in the right order. 	 */
name|hptr
operator|->
name|id
operator|=
name|ntohs
argument_list|(
name|hptr
operator|->
name|id
argument_list|)
expr_stmt|;
name|hptr
operator|->
name|ancount
operator|=
name|ntohs
argument_list|(
name|hptr
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|hptr
operator|->
name|arcount
operator|=
name|ntohs
argument_list|(
name|hptr
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|hptr
operator|->
name|nscount
operator|=
name|ntohs
argument_list|(
name|hptr
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|hptr
operator|->
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hptr
operator|->
name|qdcount
argument_list|)
expr_stmt|;
comment|/* 	 * response for an id which we have already received an answer for 	 * just ignore this response. 	 */
name|rptr
operator|=
name|ar_find_id
argument_list|(
name|hptr
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rptr
condition|)
goto|goto
name|getres_err
goto|;
if|if
condition|(
operator|(
name|hptr
operator|->
name|rcode
operator|!=
name|NOERROR
operator|)
operator|||
operator|(
name|hptr
operator|->
name|ancount
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|hptr
operator|->
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
name|h_errno
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
break|break;
case|case
name|SERVFAIL
case|:
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
break|break;
case|case
name|NOERROR
case|:
name|h_errno
operator|=
name|NO_DATA
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
case|case
name|NOTIMP
case|:
case|case
name|REFUSED
case|:
default|default:
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
break|break;
block|}
name|ar_reinfo
operator|.
name|re_errors
operator|++
expr_stmt|;
comment|/* 		** If a bad error was returned, we stop here and dont send 		** send any more (no retries granted). 		*/
if|if
condition|(
name|h_errno
operator|!=
name|TRY_AGAIN
condition|)
block|{
name|rptr
operator|->
name|re_resend
operator|=
literal|0
expr_stmt|;
name|rptr
operator|->
name|re_retries
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|getres_err
goto|;
block|}
name|a
operator|=
name|ar_procanswer
argument_list|(
name|rptr
argument_list|,
name|hptr
argument_list|,
name|ar_rcvbuf
argument_list|,
name|ar_rcvbuf
operator|+
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rptr
operator|->
name|re_type
operator|==
name|T_PTR
operator|)
operator|&&
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_CHECKPTR
operator|)
condition|)
block|{
comment|/* 		 * For reverse lookups on IP#'s, lookup the name that is given 		 * for the ip# and return with that as the official result. 		 * -avalon 		 */
name|rptr
operator|->
name|re_type
operator|=
name|T_A
expr_stmt|;
comment|/* 		 * Clean out the list of addresses already set, even though 		 * there should only be one :) 		 */
name|adr
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|rptr
operator|->
name|re_he
operator|.
name|h_addr_list
expr_stmt|;
while|while
condition|(
operator|*
name|adr
condition|)
operator|*
name|adr
operator|++
operator|=
literal|0L
expr_stmt|;
comment|/* 		 * Lookup the name that we were given for the ip# 		 */
name|ar_reinfo
operator|.
name|re_na_look
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|rptr
operator|->
name|re_name
argument_list|,
name|rptr
operator|->
name|re_he
operator|.
name|h_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rptr
operator|->
name|re_name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rptr
operator|->
name|re_he
operator|.
name|h_name
operator|=
name|NULL
expr_stmt|;
name|rptr
operator|->
name|re_retries
operator|=
name|_res
operator|.
name|retry
expr_stmt|;
name|rptr
operator|->
name|re_sends
operator|=
literal|1
expr_stmt|;
name|rptr
operator|->
name|re_resend
operator|=
literal|1
expr_stmt|;
name|rptr
operator|->
name|re_he
operator|.
name|h_name
operator|=
name|NULL
expr_stmt|;
name|ar_reinfo
operator|.
name|re_na_look
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|ar_query_name
argument_list|(
name|rptr
operator|->
name|re_name
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|reip
operator|&&
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
operator|&&
name|size
condition|)
name|bcopy
argument_list|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
argument_list|,
name|reip
argument_list|,
name|MIN
argument_list|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_size
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up structure from previous usage. 	 */
name|hp
operator|=
operator|&
name|ar_host
expr_stmt|;
ifdef|#
directive|ifdef
name|ARLIB_DEBUG
name|ar_dump_hostent
argument_list|(
literal|"ar_answer: previous usage"
argument_list|,
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hp
operator|->
name|h_name
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|hp
operator|->
name|h_aliases
condition|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|hp
operator|->
name|h_aliases
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|=
name|hp
operator|->
name|h_addr_list
condition|)
block|{
comment|/* 		 * Only free once since we allocated space for 		 * address in one big chunk. 		 */
operator|(
name|void
operator|)
name|free
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|hp
operator|->
name|h_addr_list
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setup and copy details for the structure we return a pointer to. 	 */
name|hp
operator|->
name|h_addrtype
operator|=
name|AF_INET
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rptr
operator|->
name|re_he
operator|.
name|h_name
condition|)
block|{
name|hp
operator|->
name|h_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|rptr
operator|->
name|re_he
operator|.
name|h_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
operator|->
name|h_name
condition|)
block|{
ifdef|#
directive|ifdef
name|ARLIB_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no memory for hostname\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
goto|goto
name|getres_err
goto|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|h_name
argument_list|,
name|rptr
operator|->
name|re_he
operator|.
name|h_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ARLIB_DEBUG
name|ar_dump_hostent
argument_list|(
literal|"ar_answer: (snap) store name"
argument_list|,
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Count IP#'s. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|i
operator|<
name|MAXADDRS
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
if|if
condition|(
operator|!
name|rptr
operator|->
name|re_he
operator|.
name|h_addr_list
index|[
name|i
index|]
operator|.
name|s_addr
condition|)
break|break;
name|s
operator|=
name|hp
operator|->
name|h_addr_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
operator|*
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
ifdef|#
directive|ifdef
name|ARLIB_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no memory for IP#'s (%d)\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
goto|goto
name|getres_err
goto|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rptr
operator|->
name|re_he
operator|.
name|h_addr_list
index|[
literal|0
index|]
operator|.
name|s_addr
argument_list|,
operator|*
name|s
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
block|{
operator|*
name|s
operator|=
name|hp
operator|->
name|h_addr
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rptr
operator|->
name|re_he
operator|.
name|h_addr_list
index|[
name|i
index|]
operator|.
name|s_addr
argument_list|,
operator|*
name|s
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|s
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ARLIB_DEBUG
name|ar_dump_hostent
argument_list|(
literal|"ar_answer: (snap) store IP#'s"
argument_list|,
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Count CNAMEs 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|i
operator|<
name|MAXADDRS
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
if|if
condition|(
operator|!
name|rptr
operator|->
name|re_he
operator|.
name|h_aliases
index|[
name|i
index|]
condition|)
break|break;
name|s
operator|=
name|hp
operator|->
name|h_aliases
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
ifdef|#
directive|ifdef
name|ARLIB_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no memory for aliases (%d)\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
goto|goto
name|getres_err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|s
operator|++
operator|=
name|rptr
operator|->
name|re_he
operator|.
name|h_aliases
index|[
name|i
index|]
expr_stmt|;
name|rptr
operator|->
name|re_he
operator|.
name|h_aliases
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ARLIB_DEBUG
name|ar_dump_hostent
argument_list|(
literal|"ar_answer: (snap) store CNAMEs"
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|ar_dump_hostent
argument_list|(
literal|"ar_answer: new one"
argument_list|,
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|a
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ar_remrequest
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rptr
operator|->
name|re_sent
condition|)
operator|(
name|void
operator|)
name|ar_remrequest
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
name|getres_err
label|:
if|if
condition|(
name|rptr
condition|)
block|{
if|if
condition|(
name|reip
operator|&&
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
operator|&&
name|size
condition|)
name|bcopy
argument_list|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
argument_list|,
name|reip
argument_list|,
name|MIN
argument_list|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_size
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h_errno
operator|!=
name|TRY_AGAIN
operator|)
operator|&&
operator|(
name|_res
operator|.
name|options
operator|&
operator|(
name|RES_DNSRCH
operator||
name|RES_DEFNAMES
operator|)
operator|==
operator|(
name|RES_DNSRCH
operator||
name|RES_DEFNAMES
operator|)
operator|)
condition|)
if|if
condition|(
name|_res
operator|.
name|dnsrch
index|[
name|rptr
operator|->
name|re_srch
index|]
condition|)
block|{
name|rptr
operator|->
name|re_retries
operator|=
name|_res
operator|.
name|retry
expr_stmt|;
name|rptr
operator|->
name|re_sends
operator|=
literal|1
expr_stmt|;
name|rptr
operator|->
name|re_resend
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|ar_resend_query
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
name|rptr
operator|->
name|re_srch
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ARLIB_DEBUG
end_ifdef

begin_function
name|void
name|ar_dump_hostent
parameter_list|(
name|prefix
parameter_list|,
name|hp
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  hp %p\n"
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    h_name %p '%s'\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|hp
operator|->
name|h_aliases
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    h_aliases %p\n"
argument_list|,
name|hp
operator|->
name|h_aliases
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      element %p\n"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|=
name|hp
operator|->
name|h_addr_list
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    h_addr_list %p\n"
argument_list|,
name|hp
operator|->
name|h_addr_list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      element %p\n"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar_dump_reslist
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|struct
name|reslist
modifier|*
name|rptr
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rptr
operator|=
name|ar_first
init|;
name|rptr
condition|;
name|rptr
operator|=
name|rptr
operator|->
name|re_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%4d [%p] %4d [%p]: %s\n"
argument_list|,
name|rptr
operator|->
name|re_id
argument_list|,
name|rptr
argument_list|,
operator|*
operator|(
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
operator|)
argument_list|,
name|rptr
operator|->
name|re_rinfo
operator|.
name|ri_ptr
argument_list|,
name|rptr
operator|->
name|re_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

