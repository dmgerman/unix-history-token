begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* chutest.c,v 3.1 1993/07/06 01:05:21 jbj Exp  * chutest - test the CHU clock  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STROPTS_H
end_ifdef

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STROPTS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIOS_H
end_ifdef

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SGTTY_H
end_ifdef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CHULDISC
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_CHUDEFS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/chudefs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHULDISC
end_ifndef

begin_define
define|#
directive|define
name|NCHUCHARS
value|(10)
end_define

begin_struct
struct|struct
name|chucode
block|{
name|u_char
name|codechars
index|[
name|NCHUCHARS
index|]
decl_stmt|;
comment|/* code characters */
name|u_char
name|ncodechars
decl_stmt|;
comment|/* number of code characters */
name|u_char
name|chustatus
decl_stmt|;
comment|/* not used currently */
name|struct
name|timeval
name|codetimes
index|[
name|NCHUCHARS
index|]
decl_stmt|;
comment|/* arrival times */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_decl_stmt
name|char
specifier|const
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dofilter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when we should run filter algorithm */
end_comment

begin_decl_stmt
name|int
name|showtimes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when we should show char arrival times */
end_comment

begin_decl_stmt
name|int
name|doprocess
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when we do processing analogous to driver */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CHULDISC
end_ifdef

begin_decl_stmt
name|int
name|usechuldisc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when CHU line discipline should be used */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STREAM
end_ifdef

begin_decl_stmt
name|int
name|usechuldisc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when CHU line discipline should be used */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|timeval
name|lasttv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|chucode
name|chudata
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|error
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
name|char
modifier|*
name|s1
parameter_list|,
name|char
modifier|*
name|s2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|init_chu
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|openterm
parameter_list|(
name|char
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|process_raw
parameter_list|(
name|int
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|process_ldisc
parameter_list|(
name|int
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|raw_filter
parameter_list|(
name|unsigned
name|int
name|c
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|chufilter
parameter_list|(
name|struct
name|chucode
modifier|*
name|chuc
parameter_list|,
name|l_fp
modifier|*
name|rtime
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * main - parse arguments and handle options  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cdfpt"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
ifdef|#
directive|ifdef
name|STREAM
name|usechuldisc
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CHULDISC
name|usechuldisc
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|STREAM
ifndef|#
directive|ifndef
name|CHULDISC
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: CHU line discipline not available on this machine\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|dofilter
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|doprocess
operator|=
literal|1
expr_stmt|;
case|case
literal|'t'
case|:
name|showtimes
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errflg
operator|||
name|ntp_optind
operator|+
literal|1
operator|!=
name|argc
condition|)
block|{
ifdef|#
directive|ifdef
name|STREAM
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-dft] tty_device\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CHULDISC
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-dft] tty_device\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|STREAM
ifndef|#
directive|ifndef
name|CHULDISC
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-cdft] tty_device\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|lasttv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|openterm
argument_list|(
name|argv
index|[
name|ntp_optind
index|]
argument_list|)
expr_stmt|;
name|init_chu
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|STREAM
if|if
condition|(
name|usechuldisc
condition|)
name|process_ldisc
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CHULDISC
if|if
condition|(
name|usechuldisc
condition|)
name|process_ldisc
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|process_raw
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * openterm - open a port to the CHU clock  */
end_comment

begin_function
name|int
name|openterm
parameter_list|(
name|char
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|sgttyb
name|ttyb
decl_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Doing open..."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|open
argument_list|(
name|dev
argument_list|,
name|O_RDONLY
argument_list|,
literal|0777
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"open(%s)"
argument_list|,
name|dev
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"open okay\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setting exclusive use..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|TIOCEXCL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ioctl(TIOCEXCL)"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|ttyb
operator|.
name|sg_ispeed
operator|=
name|ttyb
operator|.
name|sg_ospeed
operator|=
name|B300
expr_stmt|;
name|ttyb
operator|.
name|sg_erase
operator|=
name|ttyb
operator|.
name|sg_kill
operator|=
literal|0
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|=
name|EVENP
operator||
name|ODDP
operator||
name|RAW
expr_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setting baud rate et al..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|TIOCSETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ioctl(TIOCSETP, raw)"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CHULDISC
if|if
condition|(
name|usechuldisc
condition|)
block|{
name|int
name|ldisc
decl_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Switching to CHU ldisc..."
argument_list|)
expr_stmt|;
name|ldisc
operator|=
name|CHULDISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|TIOCSETD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ioctl(TIOCSETD, CHULDISC)"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"okay\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STREAM
if|if
condition|(
name|usechuldisc
condition|)
block|{
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Poping off streams..."
argument_list|)
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|I_POP
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"okay\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Pushing CHU stream..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|I_PUSH
argument_list|,
literal|"chu"
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ioctl(I_PUSH, \"chu\")"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"okay\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * process_raw - process characters in raw mode  */
end_comment

begin_function
name|int
name|process_raw
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|u_char
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
name|difftv
decl_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|s
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dofilter
condition|)
name|raw_filter
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
else|else
block|{
name|difftv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
operator|-
name|lasttv
operator|.
name|tv_sec
expr_stmt|;
name|difftv
operator|.
name|tv_usec
operator|=
name|tv
operator|.
name|tv_usec
operator|-
name|lasttv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|difftv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|difftv
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|difftv
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%02x\t%lu.%06lu\t%lu.%06lu\n"
argument_list|,
name|c
argument_list|,
name|tv
operator|.
name|tv_sec
argument_list|,
name|tv
operator|.
name|tv_usec
argument_list|,
name|difftv
operator|.
name|tv_sec
argument_list|,
name|difftv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|lasttv
operator|=
name|tv
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: zero returned on read\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"read()"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * raw_filter - run the line discipline filter over raw data  */
end_comment

begin_function
name|void
name|raw_filter
parameter_list|(
name|unsigned
name|int
name|c
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
specifier|static
name|struct
name|timeval
name|diffs
index|[
literal|10
index|]
decl_stmt|;
name|struct
name|timeval
name|diff
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0xf
operator|)
operator|>
literal|9
operator|||
operator|(
operator|(
name|c
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|>
literal|9
condition|)
block|{
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"character %02x failed BCD test\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|chudata
operator|.
name|ncodechars
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chudata
operator|.
name|ncodechars
operator|>
literal|0
condition|)
block|{
name|diff
operator|.
name|tv_sec
operator|=
name|tv
operator|->
name|tv_sec
operator|-
name|chudata
operator|.
name|codetimes
index|[
name|chudata
operator|.
name|ncodechars
index|]
operator|.
name|tv_sec
expr_stmt|;
name|diff
operator|.
name|tv_usec
operator|=
name|tv
operator|->
name|tv_usec
operator|-
name|chudata
operator|.
name|codetimes
index|[
name|chudata
operator|.
name|ncodechars
index|]
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|diff
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|diff
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|diff
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
comment|/* 		    if (diff.tv_sec != 0 || diff.tv_usec> 900000) { 		    if (debug) 		    (void) fprintf(stderr, 		    "character %02x failed time test\n"); 		    chudata.ncodechars = 0; 		    return; 		    } */
block|}
name|chudata
operator|.
name|codechars
index|[
name|chudata
operator|.
name|ncodechars
index|]
operator|=
name|c
expr_stmt|;
name|chudata
operator|.
name|codetimes
index|[
name|chudata
operator|.
name|ncodechars
index|]
operator|=
operator|*
name|tv
expr_stmt|;
if|if
condition|(
name|chudata
operator|.
name|ncodechars
operator|>
literal|0
condition|)
name|diffs
index|[
name|chudata
operator|.
name|ncodechars
index|]
operator|=
name|diff
expr_stmt|;
if|if
condition|(
operator|++
name|chudata
operator|.
name|ncodechars
operator|==
literal|10
condition|)
block|{
if|if
condition|(
name|doprocess
condition|)
block|{
name|TVTOTS
argument_list|(
operator|&
name|chudata
operator|.
name|codetimes
index|[
name|NCHUCHARS
operator|-
literal|1
index|]
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|chufilter
argument_list|(
operator|&
name|chudata
argument_list|,
operator|&
name|chudata
operator|.
name|codetimes
index|[
name|NCHUCHARS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chudata
operator|.
name|ncodechars
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%x%x\t%lu.%06lu\t%lu.%06lu\n"
argument_list|,
name|chudata
operator|.
name|codechars
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|,
operator|(
name|chudata
operator|.
name|codechars
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|,
name|chudata
operator|.
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_sec
argument_list|,
name|chudata
operator|.
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_usec
argument_list|,
name|diffs
index|[
name|i
index|]
operator|.
name|tv_sec
argument_list|,
name|diffs
index|[
name|i
index|]
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
block|}
name|chudata
operator|.
name|ncodechars
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* #ifdef CHULDISC*/
end_comment

begin_comment
comment|/*  * process_ldisc - process line discipline  */
end_comment

begin_function
name|int
name|process_ldisc
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|struct
name|chucode
name|chu
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|diff
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|void
name|chufilter
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chu
argument_list|,
sizeof|sizeof
name|chu
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|!=
sizeof|sizeof
name|chu
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected %d, got %d\n"
argument_list|,
sizeof|sizeof
name|chu
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|doprocess
condition|)
block|{
name|TVTOTS
argument_list|(
operator|&
name|chu
operator|.
name|codetimes
index|[
name|NCHUCHARS
operator|-
literal|1
index|]
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|chufilter
argument_list|(
operator|&
name|chu
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|diff
operator|.
name|tv_sec
operator|=
name|diff
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|diff
operator|.
name|tv_sec
operator|=
name|chu
operator|.
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_sec
operator|-
name|chu
operator|.
name|codetimes
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|tv_sec
expr_stmt|;
name|diff
operator|.
name|tv_usec
operator|=
name|chu
operator|.
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_usec
operator|-
name|chu
operator|.
name|codetimes
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|diff
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|diff
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|diff
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%x%x\t%lu.%06lu\t%lu.%06lu\n"
argument_list|,
name|chu
operator|.
name|codechars
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|,
operator|(
name|chu
operator|.
name|codechars
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|,
name|chu
operator|.
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_sec
argument_list|,
name|chu
operator|.
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_usec
argument_list|,
name|diff
operator|.
name|tv_sec
argument_list|,
name|diff
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: zero returned on read\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"read()"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*#endif*/
end_comment

begin_comment
comment|/*  * error - print an error message  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
name|char
modifier|*
name|s1
parameter_list|,
name|char
modifier|*
name|s2
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Definitions  */
end_comment

begin_define
define|#
directive|define
name|MAXUNITS
value|4
end_define

begin_comment
comment|/* maximum number of CHU units permitted */
end_comment

begin_define
define|#
directive|define
name|CHUDEV
value|"/dev/chu%d"
end_define

begin_comment
comment|/* device we open.  %d is unit number */
end_comment

begin_define
define|#
directive|define
name|NCHUCODES
value|9
end_define

begin_comment
comment|/* expect 9 CHU codes per minute */
end_comment

begin_comment
comment|/*  * When CHU is operating optimally we want the primary clock distance  * to come out at 300 ms.  Thus, peer.distance in the CHU peer structure  * is set to 290 ms and we compute delays which are at least 10 ms long.  * The following are 290 ms and 10 ms expressed in u_fp format  */
end_comment

begin_define
define|#
directive|define
name|CHUDISTANCE
value|0x00004a3d
end_define

begin_define
define|#
directive|define
name|CHUBASEDELAY
value|0x0000028f
end_define

begin_comment
comment|/*  * To compute a quality for the estimate (a pseudo delay) we add a  * fixed 10 ms for each missing code in the minute and add to this  * the sum of the differences between the remaining offsets and the  * estimated sample offset.  */
end_comment

begin_define
define|#
directive|define
name|CHUDELAYPENALTY
value|0x0000028f
end_define

begin_comment
comment|/*  * Other constant stuff  */
end_comment

begin_define
define|#
directive|define
name|CHUPRECISION
value|(-9)
end_define

begin_comment
comment|/* what the heck */
end_comment

begin_define
define|#
directive|define
name|CHUREFID
value|"CHU\0"
end_define

begin_comment
comment|/*  * Default fudge factors  */
end_comment

begin_define
define|#
directive|define
name|DEFPROPDELAY
value|0x00624dd3
end_define

begin_comment
comment|/* 0.0015 seconds, 1.5 ms */
end_comment

begin_define
define|#
directive|define
name|DEFFILTFUDGE
value|0x000d1b71
end_define

begin_comment
comment|/* 0.0002 seconds, 200 us */
end_comment

begin_comment
comment|/*  * Hacks to avoid excercising the multiplier.  I have no pride.  */
end_comment

begin_define
define|#
directive|define
name|MULBY10
parameter_list|(
name|x
parameter_list|)
value|(((x)<<3) + ((x)<<1))
end_define

begin_define
define|#
directive|define
name|MULBY60
parameter_list|(
name|x
parameter_list|)
value|(((x)<<6) - ((x)<<2))
end_define

begin_comment
comment|/* watch overflow */
end_comment

begin_define
define|#
directive|define
name|MULBY24
parameter_list|(
name|x
parameter_list|)
value|(((x)<<4) + ((x)<<3))
end_define

begin_comment
comment|/*  * Constants for use when multiplying by 0.1.  ZEROPTONE is 0.1  * as an l_fp fraction, NZPOBITS is the number of significant bits  * in ZEROPTONE.  */
end_comment

begin_define
define|#
directive|define
name|ZEROPTONE
value|0x1999999a
end_define

begin_define
define|#
directive|define
name|NZPOBITS
value|29
end_define

begin_comment
comment|/*  * The CHU table.  This gives the expected time of arrival of each  * character after the on-time second and is computed as follows:  * The CHU time code is sent at 300 bps.  Your average UART will  * synchronize at the edge of the start bit and will consider the  * character complete at the center of the first stop bit, i.e.  * 0.031667 ms later.  Thus the expected time of each interrupt  * is the start bit time plus 0.031667 seconds.  These times are  * in chutable[].  To this we add such things as propagation delay  * and delay fudge factor.  */
end_comment

begin_define
define|#
directive|define
name|CHARDELAY
value|0x081b4e80
end_define

begin_decl_stmt
specifier|static
name|u_long
name|chutable
index|[
name|NCHUCHARS
index|]
init|=
block|{
literal|0x2147ae14
operator|+
name|CHARDELAY
block|,
comment|/* 0.130 (exactly) */
literal|0x2ac08312
operator|+
name|CHARDELAY
block|,
comment|/* 0.167 (exactly) */
literal|0x34395810
operator|+
name|CHARDELAY
block|,
comment|/* 0.204 (exactly) */
literal|0x3db22d0e
operator|+
name|CHARDELAY
block|,
comment|/* 0.241 (exactly) */
literal|0x472b020c
operator|+
name|CHARDELAY
block|,
comment|/* 0.278 (exactly) */
literal|0x50a3d70a
operator|+
name|CHARDELAY
block|,
comment|/* 0.315 (exactly) */
literal|0x5a1cac08
operator|+
name|CHARDELAY
block|,
comment|/* 0.352 (exactly) */
literal|0x63958106
operator|+
name|CHARDELAY
block|,
comment|/* 0.389 (exactly) */
literal|0x6d0e5604
operator|+
name|CHARDELAY
block|,
comment|/* 0.426 (exactly) */
literal|0x76872b02
operator|+
name|CHARDELAY
block|,
comment|/* 0.463 (exactly) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keep the fudge factors separately so they can be set even  * when no clock is configured.  */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|propagation_delay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_fp
name|fudgefactor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_fp
name|offset_fudge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We keep track of the start of the year, watching for changes.  * We also keep track of whether the year is a leap year or not.  * All because stupid CHU doesn't include the year in the time code.  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|yearstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * init_chu - initialize internal chu driver data  */
end_comment

begin_function
name|void
name|init_chu
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Initialize fudge factors to default. 	 */
name|propagation_delay
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|propagation_delay
operator|.
name|l_uf
operator|=
name|DEFPROPDELAY
expr_stmt|;
name|fudgefactor
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|fudgefactor
operator|.
name|l_uf
operator|=
name|DEFFILTFUDGE
expr_stmt|;
name|offset_fudge
operator|=
name|propagation_delay
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset_fudge
argument_list|,
operator|&
name|fudgefactor
argument_list|)
expr_stmt|;
name|yearstart
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|chufilter
parameter_list|(
name|struct
name|chucode
modifier|*
name|chuc
parameter_list|,
name|l_fp
modifier|*
name|rtime
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_long
name|date_ui
decl_stmt|;
specifier|register
name|u_long
name|tmp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|code
decl_stmt|;
name|int
name|isneg
decl_stmt|;
name|int
name|imin
decl_stmt|;
name|int
name|imax
decl_stmt|;
name|u_long
name|reftime
decl_stmt|;
name|l_fp
name|off
index|[
name|NCHUCHARS
index|]
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|int
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|;
specifier|static
name|u_char
name|lastcode
index|[
name|NCHUCHARS
index|]
decl_stmt|;
comment|/* 	 * We'll skip the checks made in the kernel, but assume they've 	 * been done.  This means that all characters are BCD and 	 * the intercharacter spacing isn't unreasonable. 	 */
comment|/* 	 * print the code 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%c%c"
argument_list|,
operator|(
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|&
literal|0xf
operator|)
operator|+
literal|'0'
argument_list|,
operator|(
operator|(
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Format check.  Make sure the two halves match. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
operator|/
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|!=
name|chuc
operator|->
name|codechars
index|[
name|i
operator|+
operator|(
name|NCHUCHARS
operator|/
literal|2
operator|)
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Bad format, halves don't match\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Break out the code into the BCD nibbles.  Only need to fiddle 	 * with the first half since both are identical.  Note the first 	 * BCD character is the low order nibble, the second the high order. 	 */
name|code
operator|=
name|lastcode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|code
operator|++
operator|=
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|&
literal|0xf
expr_stmt|;
operator|*
name|code
operator|++
operator|=
operator|(
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
comment|/* 	 * If the first nibble isn't a 6, we're up the creek 	 */
name|code
operator|=
name|lastcode
expr_stmt|;
if|if
condition|(
operator|*
name|code
operator|++
operator|!=
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Bad format, no 6 at start\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Collect the day, the hour, the minute and the second. 	 */
name|day
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|day
operator|=
name|MULBY10
argument_list|(
name|day
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|day
operator|=
name|MULBY10
argument_list|(
name|day
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|hour
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|hour
operator|=
name|MULBY10
argument_list|(
name|hour
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|minute
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|minute
operator|=
name|MULBY10
argument_list|(
name|minute
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|second
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|second
operator|=
name|MULBY10
argument_list|(
name|second
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
comment|/* 	 * Sanity check the day and time.  Note that this 	 * only occurs on the 31st through the 39th second 	 * of the minute. 	 */
if|if
condition|(
name|day
operator|<
literal|1
operator|||
name|day
operator|>
literal|366
operator|||
name|hour
operator|>
literal|23
operator|||
name|minute
operator|>
literal|59
operator|||
name|second
operator|<
literal|31
operator|||
name|second
operator|>
literal|39
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Failed date sanity check: %d %d %d %d\n"
argument_list|,
name|day
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Compute seconds into the year. 	 */
name|tmp
operator|=
call|(
name|u_long
call|)
argument_list|(
name|MULBY24
argument_list|(
operator|(
name|day
operator|-
literal|1
operator|)
argument_list|)
operator|+
name|hour
argument_list|)
expr_stmt|;
comment|/* hours */
name|tmp
operator|=
name|MULBY60
argument_list|(
name|tmp
argument_list|)
operator|+
operator|(
name|u_long
operator|)
name|minute
expr_stmt|;
comment|/* minutes */
name|tmp
operator|=
name|MULBY60
argument_list|(
name|tmp
argument_list|)
operator|+
operator|(
name|u_long
operator|)
name|second
expr_stmt|;
comment|/* seconds */
comment|/* 	 * Now the fun begins.  We demand that the received time code 	 * be within CLOCK_WAYTOOBIG of the receive timestamp, but 	 * there is uncertainty about the year the timestamp is in. 	 * Use the current year start for the first check, this should 	 * work most of the time. 	 */
name|date_ui
operator|=
name|tmp
operator|+
name|yearstart
expr_stmt|;
define|#
directive|define
name|CLOCK_WAYTOOBIG
value|1000
comment|/* revived from ancient sources */
if|if
condition|(
name|date_ui
operator|<
operator|(
name|rtime
operator|->
name|l_ui
operator|+
name|CLOCK_WAYTOOBIG
operator|)
operator|&&
name|date_ui
operator|>
operator|(
name|rtime
operator|->
name|l_ui
operator|-
name|CLOCK_WAYTOOBIG
operator|)
condition|)
goto|goto
name|codeokay
goto|;
comment|/* looks good */
comment|/* 	 * Trouble.  Next check is to see if the year rolled over and, if 	 * so, try again with the new year's start. 	 */
name|date_ui
operator|=
name|calyearstart
argument_list|(
name|rtime
operator|->
name|l_ui
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|date_ui
operator|!=
name|yearstart
condition|)
block|{
name|yearstart
operator|=
name|date_ui
expr_stmt|;
name|date_ui
operator|+=
name|tmp
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"time %u, code %u, difference %d\n"
argument_list|,
name|date_ui
argument_list|,
name|rtime
operator|->
name|l_ui
argument_list|,
operator|(
name|long
operator|)
name|date_ui
operator|-
operator|(
name|long
operator|)
name|rtime
operator|->
name|l_ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|date_ui
operator|<
operator|(
name|rtime
operator|->
name|l_ui
operator|+
name|CLOCK_WAYTOOBIG
operator|)
operator|&&
name|date_ui
operator|>
operator|(
name|rtime
operator|->
name|l_ui
operator|-
name|CLOCK_WAYTOOBIG
operator|)
condition|)
goto|goto
name|codeokay
goto|;
comment|/* okay this time */
block|}
name|ts
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|=
name|yearstart
expr_stmt|;
name|printf
argument_list|(
literal|"yearstart %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"received %s\n"
argument_list|,
name|prettydate
argument_list|(
name|rtime
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|=
name|date_ui
expr_stmt|;
name|printf
argument_list|(
literal|"date_ui %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|ts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Here we know the year start matches the current system 	 * time.  One remaining possibility is that the time code 	 * is in the year previous to that of the system time.  This 	 * is only worth checking if the receive timestamp is less 	 * than CLOCK_WAYTOOBIG seconds into the new year. 	 */
if|if
condition|(
operator|(
name|rtime
operator|->
name|l_ui
operator|-
name|yearstart
operator|)
operator|<
name|CLOCK_WAYTOOBIG
condition|)
block|{
name|date_ui
operator|=
name|tmp
expr_stmt|;
name|date_ui
operator|+=
name|calyearstart
argument_list|(
name|yearstart
operator|-
name|CLOCK_WAYTOOBIG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtime
operator|->
name|l_ui
operator|-
name|date_ui
operator|)
operator|<
name|CLOCK_WAYTOOBIG
condition|)
goto|goto
name|codeokay
goto|;
block|}
comment|/* 	 * One last possibility is that the time stamp is in the year 	 * following the year the system is in.  Try this one before 	 * giving up. 	 */
name|date_ui
operator|=
name|tmp
expr_stmt|;
name|date_ui
operator|+=
name|calyearstart
argument_list|(
name|yearstart
operator|+
operator|(
literal|400
operator|*
name|SECSPERDAY
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|date_ui
operator|-
name|rtime
operator|->
name|l_ui
operator|)
operator|>=
name|CLOCK_WAYTOOBIG
condition|)
block|{
name|printf
argument_list|(
literal|"Date hopelessly off\n"
argument_list|)
expr_stmt|;
return|return;
comment|/* hopeless, let it sync to other peers */
block|}
name|codeokay
label|:
name|reftime
operator|=
name|date_ui
expr_stmt|;
comment|/* 	 * We've now got the integral seconds part of the time code (we hope). 	 * The fractional part comes from the table.  We next compute 	 * the offsets for each character. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|u_long
name|tmp2
decl_stmt|;
name|off
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
name|date_ui
expr_stmt|;
name|off
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|chutable
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|chuc
operator|->
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|chuc
operator|->
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_usec
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|,
name|tmp
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Here is a *big* problem.  What one would normally 	 * do here on a machine with lots of clock bits (say 	 * a Vax or the gizmo board) is pick the most positive 	 * offset and the estimate, since this is the one that 	 * is most likely suffered the smallest interrupt delay. 	 * The trouble is that the low order clock bit on an IBM 	 * RT, which is the machine I had in mind when doing this, 	 * ticks at just under the millisecond mark.  This isn't 	 * precise enough.  What we can do to improve this is to 	 * average all 10 samples and rely on the second level 	 * filtering to pick the least delayed estimate.  Trouble 	 * is, this means we have to divide a 64 bit fixed point 	 * number by 10, a procedure which really sucks.  Oh, well. 	 * First compute the sum. 	 */
name|date_ui
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
name|M_ADD
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_ISNEG
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|)
condition|)
name|isneg
operator|=
literal|1
expr_stmt|;
else|else
name|isneg
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Here is a multiply-by-0.1 optimization that should apply 	 * just about everywhere.  If the magnitude of the sum 	 * is less than 9 we don't have to worry about overflow 	 * out of a 64 bit product, even after rounding. 	 */
if|if
condition|(
name|date_ui
operator|<
literal|9
operator|||
name|date_ui
operator|>
literal|0xfffffff7
condition|)
block|{
specifier|register
name|u_long
name|prod_ui
decl_stmt|;
specifier|register
name|u_long
name|prod_uf
decl_stmt|;
name|prod_ui
operator|=
name|prod_uf
operator|=
literal|0
expr_stmt|;
comment|/* 		 * This code knows the low order bit in 0.1 is zero 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NZPOBITS
condition|;
name|i
operator|++
control|)
block|{
name|M_LSHIFT
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZEROPTONE
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|M_ADD
argument_list|(
name|prod_ui
argument_list|,
name|prod_uf
argument_list|,
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Done, round it correctly.  Prod_ui contains the 		 * fraction. 		 */
if|if
condition|(
name|prod_uf
operator|&
literal|0x80000000
condition|)
name|prod_ui
operator|++
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
name|date_ui
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|date_ui
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|prod_ui
expr_stmt|;
comment|/* 		 * date_ui is integral part, tmp is fraction. 		 */
block|}
else|else
block|{
specifier|register
name|u_long
name|prod_ovr
decl_stmt|;
specifier|register
name|u_long
name|prod_ui
decl_stmt|;
specifier|register
name|u_long
name|prod_uf
decl_stmt|;
specifier|register
name|u_long
name|highbits
decl_stmt|;
name|prod_ovr
operator|=
name|prod_ui
operator|=
name|prod_uf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
name|highbits
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* sign extend */
else|else
name|highbits
operator|=
literal|0
expr_stmt|;
comment|/* 		 * This code knows the low order bit in 0.1 is zero 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NZPOBITS
condition|;
name|i
operator|++
control|)
block|{
name|M_LSHIFT3
argument_list|(
name|highbits
argument_list|,
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZEROPTONE
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|M_ADD3
argument_list|(
name|prod_ovr
argument_list|,
name|prod_uf
argument_list|,
name|prod_ui
argument_list|,
name|highbits
argument_list|,
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prod_uf
operator|&
literal|0x80000000
condition|)
name|M_ADDUF
argument_list|(
name|prod_ovr
argument_list|,
name|prod_ui
argument_list|,
operator|(
name|u_long
operator|)
literal|1
argument_list|)
expr_stmt|;
name|date_ui
operator|=
name|prod_ovr
expr_stmt|;
name|tmp
operator|=
name|prod_ui
expr_stmt|;
block|}
comment|/* 	 * At this point we have the mean offset, with the integral 	 * part in date_ui and the fractional part in tmp.  Store 	 * it in the structure. 	 */
comment|/* 	 * Add in fudge factor. 	 */
name|M_ADD
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|,
name|offset_fudge
operator|.
name|l_ui
argument_list|,
name|offset_fudge
operator|.
name|l_uf
argument_list|)
expr_stmt|;
comment|/* 	 * Find the minimun and maximum offset 	 */
name|imin
operator|=
name|imax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|L_ISGEQ
argument_list|(
operator|&
name|off
index|[
name|i
index|]
argument_list|,
operator|&
name|off
index|[
name|imax
index|]
argument_list|)
condition|)
block|{
name|imax
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|L_ISGEQ
argument_list|(
operator|&
name|off
index|[
name|imin
index|]
argument_list|,
operator|&
name|off
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|imin
operator|=
name|i
expr_stmt|;
block|}
block|}
name|L_ADD
argument_list|(
operator|&
name|off
index|[
name|imin
index|]
argument_list|,
operator|&
name|offset_fudge
argument_list|)
expr_stmt|;
if|if
condition|(
name|imin
operator|!=
name|imax
condition|)
name|L_ADD
argument_list|(
operator|&
name|off
index|[
name|imax
index|]
argument_list|,
operator|&
name|offset_fudge
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"mean %s, min %s, max %s\n"
argument_list|,
name|mfptoa
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|,
literal|8
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|off
index|[
name|imin
index|]
argument_list|,
literal|8
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|off
index|[
name|imax
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

