begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * timespecops.h -- calculations on 'struct timespec' values  *  * Written by Juergen Perlinger (perlinger@ntp.org) for the NTP project.  * The contents of 'html/copyright.html' apply.  *  * Rationale  * ---------  *  * Doing basic arithmetic on a 'struct timespec' is not exceedingly  * hard, but it requires tedious and repetitive code to keep the result  * normalised. We consider a timespec normalised when the nanosecond  * fraction is in the interval [0 .. 10^9[ ; there are multiple value  * pairs of seconds and nanoseconds that denote the same time interval,  * but the normalised representation is unique. No two different  * intervals can have the same normalised representation.  *  * Another topic is the representation of negative time intervals.  * There's more than one way to this, since both the seconds and the  * nanoseconds of a timespec are signed values. IMHO, the easiest way is  * to use a complement representation where the nanoseconds are still  * normalised, no matter what the sign of the seconds value. This makes  * normalisation easier, since the sign of the integer part is  * irrelevant, and it removes several sign decision cases during the  * calculations.  *  * As long as no signed integer overflow can occur with the nanosecond  * part of the operands, all operations work as expected and produce a  * normalised result.  *  * The exception to this are functions fix a '_fast' suffix, which do no  * normalisation on input data and therefore expect the input data to be  * normalised.  *  * Input and output operands may overlap; all input is consumed before  * the output is written to.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TIMESPECOPS_H
end_ifndef

begin_define
define|#
directive|define
name|TIMESPECOPS_H
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"timetoa.h"
end_include

begin_comment
comment|/* nanoseconds per second */
end_comment

begin_define
define|#
directive|define
name|NANOSECONDS
value|1000000000
end_define

begin_comment
comment|/* predicate: returns TRUE if the nanoseconds are in nominal range */
end_comment

begin_define
define|#
directive|define
name|timespec_isnormal
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)->tv_nsec>= 0&& (x)->tv_nsec< NANOSECONDS)
end_define

begin_comment
comment|/* predicate: returns TRUE if the nanoseconds are out-of-bounds */
end_comment

begin_define
define|#
directive|define
name|timespec_isdenormal
parameter_list|(
name|x
parameter_list|)
value|(!timespec_isnormal(x))
end_define

begin_comment
comment|/* conversion between l_fp fractions and nanoseconds */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_U_INT64
end_ifdef

begin_define
define|#
directive|define
name|FTOTVN
parameter_list|(
name|tsf
parameter_list|)
define|\
value|((int32)						\ 	 (((u_int64)(tsf) * NANOSECONDS + 0x80000000)>> 32))
end_define

begin_define
define|#
directive|define
name|TVNTOF
parameter_list|(
name|tvu
parameter_list|)
define|\
value|((u_int32)						\ 	 ((((u_int64)(tvu)<< 32) + NANOSECONDS / 2) /		\ 	  NANOSECONDS))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NSECFRAC
value|(FRAC / NANOSECONDS)
end_define

begin_define
define|#
directive|define
name|FTOTVN
parameter_list|(
name|tsf
parameter_list|)
define|\
value|((int32)((tsf) / NSECFRAC + 0.5))
end_define

begin_define
define|#
directive|define
name|TVNTOF
parameter_list|(
name|tvu
parameter_list|)
define|\
value|((u_int32)((tvu) * NSECFRAC + 0.5))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* make sure nanoseconds are in nominal range */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timespec
name|normalize_tspec
parameter_list|(
name|struct
name|timespec
name|x
parameter_list|)
block|{
if|#
directive|if
name|SIZEOF_LONG
operator|>
literal|4
name|long
name|z
decl_stmt|;
comment|/*  	 * tv_nsec is of type 'long', and on a 64-bit machine using only 	 * loops becomes prohibitive once the upper 32 bits get 	 * involved. On the other hand, division by constant should be 	 * fast enough; so we do a division of the nanoseconds in that 	 * case. The floor adjustment step follows with the standard 	 * normalisation loops. And labs() is intentionally not used 	 * here: it has implementation-defined behaviour when applied 	 * to LONG_MIN. 	 */
if|if
condition|(
name|x
operator|.
name|tv_nsec
operator|<
operator|-
literal|3l
operator|*
name|NANOSECONDS
operator|||
name|x
operator|.
name|tv_nsec
operator|>
literal|3l
operator|*
name|NANOSECONDS
condition|)
block|{
name|z
operator|=
name|x
operator|.
name|tv_nsec
operator|/
name|NANOSECONDS
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|-=
name|z
operator|*
name|NANOSECONDS
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|+=
name|z
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* since 10**9 is close to 2**32, we don't divide but do a 	 * normalisation in a loop; this takes 3 steps max, and should 	 * outperform a division even if the mul-by-inverse trick is 	 * employed. */
if|if
condition|(
name|x
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
do|do
block|{
name|x
operator|.
name|tv_nsec
operator|+=
name|NANOSECONDS
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
do|;
elseif|else
if|if
condition|(
name|x
operator|.
name|tv_nsec
operator|>=
name|NANOSECONDS
condition|)
do|do
block|{
name|x
operator|.
name|tv_nsec
operator|-=
name|NANOSECONDS
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|.
name|tv_nsec
operator|>=
name|NANOSECONDS
condition|)
do|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* x = a + b */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timespec
name|add_tspec
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|,
name|struct
name|timespec
name|b
parameter_list|)
block|{
name|struct
name|timespec
name|x
decl_stmt|;
name|x
operator|=
name|a
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|+=
name|b
operator|.
name|tv_sec
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|+=
name|b
operator|.
name|tv_nsec
expr_stmt|;
return|return
name|normalize_tspec
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* x = a + b, b is fraction only */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timespec
name|add_tspec_ns
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|struct
name|timespec
name|x
decl_stmt|;
name|x
operator|=
name|a
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|+=
name|b
expr_stmt|;
return|return
name|normalize_tspec
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* x = a - b */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timespec
name|sub_tspec
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|,
name|struct
name|timespec
name|b
parameter_list|)
block|{
name|struct
name|timespec
name|x
decl_stmt|;
name|x
operator|=
name|a
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|-=
name|b
operator|.
name|tv_sec
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|-=
name|b
operator|.
name|tv_nsec
expr_stmt|;
return|return
name|normalize_tspec
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* x = a - b, b is fraction only */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timespec
name|sub_tspec_ns
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|struct
name|timespec
name|x
decl_stmt|;
name|x
operator|=
name|a
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|-=
name|b
expr_stmt|;
return|return
name|normalize_tspec
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* x = -a */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timespec
name|neg_tspec
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|)
block|{
name|struct
name|timespec
name|x
decl_stmt|;
name|x
operator|.
name|tv_sec
operator|=
operator|-
name|a
operator|.
name|tv_sec
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|=
operator|-
name|a
operator|.
name|tv_nsec
expr_stmt|;
return|return
name|normalize_tspec
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* x = abs(a) */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timespec
name|abs_tspec
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|)
block|{
name|struct
name|timespec
name|c
decl_stmt|;
name|c
operator|=
name|normalize_tspec
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|tv_sec
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|.
name|tv_nsec
operator|!=
literal|0
condition|)
block|{
name|c
operator|.
name|tv_sec
operator|=
operator|-
name|c
operator|.
name|tv_sec
operator|-
literal|1
expr_stmt|;
name|c
operator|.
name|tv_nsec
operator|=
name|NANOSECONDS
operator|-
name|c
operator|.
name|tv_nsec
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|tv_sec
operator|=
operator|-
name|c
operator|.
name|tv_sec
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * compare previously-normalised a and b  * return 1 / 0 / -1 if a< / == /> b  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cmp_tspec
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|,
name|struct
name|timespec
name|b
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|a
operator|.
name|tv_sec
operator|>
name|b
operator|.
name|tv_sec
operator|)
operator|-
operator|(
name|a
operator|.
name|tv_sec
operator|<
name|b
operator|.
name|tv_sec
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|r
condition|)
name|r
operator|=
operator|(
name|a
operator|.
name|tv_nsec
operator|>
name|b
operator|.
name|tv_nsec
operator|)
operator|-
operator|(
name|a
operator|.
name|tv_nsec
operator|<
name|b
operator|.
name|tv_nsec
operator|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * compare possibly-denormal a and b  * return 1 / 0 / -1 if a< / == /> b  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cmp_tspec_denorm
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|,
name|struct
name|timespec
name|b
parameter_list|)
block|{
return|return
name|cmp_tspec
argument_list|(
name|normalize_tspec
argument_list|(
name|a
argument_list|)
argument_list|,
name|normalize_tspec
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * test previously-normalised a  * return 1 / 0 / -1 if a< / == /> 0  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|test_tspec
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|a
operator|.
name|tv_sec
operator|>
literal|0
operator|)
operator|-
operator|(
name|a
operator|.
name|tv_sec
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
operator|(
name|a
operator|.
name|tv_nsec
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * test possibly-denormal a  * return 1 / 0 / -1 if a< / == /> 0  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|test_tspec_denorm
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|)
block|{
return|return
name|test_tspec
argument_list|(
name|normalize_tspec
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* return LIB buffer ptr to string rep */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|tspectoa
parameter_list|(
name|struct
name|timespec
name|x
parameter_list|)
block|{
return|return
name|format_time_fraction
argument_list|(
name|x
operator|.
name|tv_sec
argument_list|,
name|x
operator|.
name|tv_nsec
argument_list|,
literal|9
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  convert to l_fp type, relative and absolute  */
end_comment

begin_comment
comment|/* convert from timespec duration to l_fp duration */
end_comment

begin_function
specifier|static
specifier|inline
name|l_fp
name|tspec_intv_to_lfp
parameter_list|(
name|struct
name|timespec
name|x
parameter_list|)
block|{
name|struct
name|timespec
name|v
decl_stmt|;
name|l_fp
name|y
decl_stmt|;
name|v
operator|=
name|normalize_tspec
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|.
name|l_uf
operator|=
name|TVNTOF
argument_list|(
name|v
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
name|y
operator|.
name|l_i
operator|=
operator|(
name|int32
operator|)
name|v
operator|.
name|tv_sec
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/* x must be UN*X epoch, output will be in NTP epoch */
end_comment

begin_function
specifier|static
specifier|inline
name|l_fp
name|tspec_stamp_to_lfp
parameter_list|(
name|struct
name|timespec
name|x
parameter_list|)
block|{
name|l_fp
name|y
decl_stmt|;
name|y
operator|=
name|tspec_intv_to_lfp
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/* convert from l_fp type, relative signed/unsigned and absolute */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timespec
name|lfp_intv_to_tspec
parameter_list|(
name|l_fp
name|x
parameter_list|)
block|{
name|struct
name|timespec
name|out
decl_stmt|;
name|l_fp
name|absx
decl_stmt|;
name|int
name|neg
decl_stmt|;
name|neg
operator|=
name|L_ISNEG
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
name|absx
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|L_NEG
argument_list|(
operator|&
name|absx
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|tv_nsec
operator|=
name|FTOTVN
argument_list|(
name|absx
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|out
operator|.
name|tv_sec
operator|=
name|absx
operator|.
name|l_i
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|out
operator|.
name|tv_sec
operator|=
operator|-
name|out
operator|.
name|tv_sec
expr_stmt|;
name|out
operator|.
name|tv_nsec
operator|=
operator|-
name|out
operator|.
name|tv_nsec
expr_stmt|;
name|out
operator|=
name|normalize_tspec
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|timespec
name|lfp_uintv_to_tspec
parameter_list|(
name|l_fp
name|x
parameter_list|)
block|{
name|struct
name|timespec
name|out
decl_stmt|;
name|out
operator|.
name|tv_nsec
operator|=
name|FTOTVN
argument_list|(
name|x
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|out
operator|.
name|tv_sec
operator|=
name|x
operator|.
name|l_ui
expr_stmt|;
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/*  * absolute (timestamp) conversion. Input is time in NTP epoch, output  * is in UN*X epoch. The NTP time stamp will be expanded around the  * pivot time *p or the current time, if p is NULL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timespec
name|lfp_stamp_to_tspec
parameter_list|(
name|l_fp
name|x
parameter_list|,
specifier|const
name|time_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|timespec
name|out
decl_stmt|;
name|vint64
name|sec
decl_stmt|;
name|sec
operator|=
name|ntpcal_ntp_to_time
argument_list|(
name|x
operator|.
name|l_ui
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|out
operator|.
name|tv_nsec
operator|=
name|FTOTVN
argument_list|(
name|x
operator|.
name|l_uf
argument_list|)
expr_stmt|;
comment|/* copying a vint64 to a time_t needs some care... */
if|#
directive|if
name|SIZEOF_TIME_T
operator|<=
literal|4
name|out
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|sec
operator|.
name|d_s
operator|.
name|lo
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_INT64
argument_list|)
name|out
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|sec
operator|.
name|q_s
expr_stmt|;
else|#
directive|else
name|out
operator|.
name|tv_sec
operator|=
operator|(
operator|(
name|time_t
operator|)
name|sec
operator|.
name|d_s
operator|.
name|hi
operator|<<
literal|32
operator|)
operator||
name|sec
operator|.
name|d_s
operator|.
name|lo
expr_stmt|;
endif|#
directive|endif
return|return
name|out
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIMESPECOPS_H */
end_comment

end_unit

