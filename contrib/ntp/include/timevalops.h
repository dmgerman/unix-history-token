begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * timevalops.h -- calculations on 'struct timeval' values  *  * Written by Juergen Perlinger (perlinger@ntp.org) for the NTP project.  * The contents of 'html/copyright.html' apply.  *  * For a rationale look at 'timespecops.h'; we do the same here, but the  * normalisation keeps the microseconds in [0 .. 10^6[, of course.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TIMEVALOPS_H
end_ifndef

begin_define
define|#
directive|define
name|TIMEVALOPS_H
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"timetoa.h"
end_include

begin_comment
comment|/* microseconds per second */
end_comment

begin_define
define|#
directive|define
name|MICROSECONDS
value|1000000
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_U_INT64
end_ifndef

begin_define
define|#
directive|define
name|USE_TSF_USEC_TABLES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Convert usec to a time stamp fraction.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_TSF_USEC_TABLES
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|u_int32
name|ustotslo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|u_int32
name|ustotsmid
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|u_int32
name|ustotshi
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TVUTOTSF
parameter_list|(
name|tvu
parameter_list|,
name|tsf
parameter_list|)
define|\
value|((tsf) = ustotslo[(tvu)& 0xff]				\ 		  + ustotsmid[((tvu)>> 8)& 0xff]			\ 		  + ustotshi[((tvu)>> 16)& 0xf])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TVUTOTSF
parameter_list|(
name|tvu
parameter_list|,
name|tsf
parameter_list|)
define|\
value|((tsf) = (u_int32)						\ 		 ((((u_int64)(tvu)<< 32) + MICROSECONDS / 2) /		\ 		  MICROSECONDS))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Convert a time stamp fraction to microseconds.  The time stamp  * fraction is assumed to be unsigned.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_TSF_USEC_TABLES
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|u_int32
name|tstouslo
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|u_int32
name|tstousmid
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|u_int32
name|tstoushi
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TV_SHIFT is used to turn the table result into a usec value.  To  * round, add in TV_ROUNDBIT before shifting.  */
end_comment

begin_define
define|#
directive|define
name|TV_SHIFT
value|3
end_define

begin_define
define|#
directive|define
name|TV_ROUNDBIT
value|0x4
end_define

begin_define
define|#
directive|define
name|TSFTOTVU
parameter_list|(
name|tsf
parameter_list|,
name|tvu
parameter_list|)
define|\
value|((tvu) = (tstoushi[((tsf)>> 24)& 0xff]			\ 		  + tstousmid[((tsf)>> 16)& 0xff]			\ 		  + tstouslo[((tsf)>> 9)& 0x7f]			\ 		  + TV_ROUNDBIT)>> TV_SHIFT)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TSFTOTVU
parameter_list|(
name|tsf
parameter_list|,
name|tvu
parameter_list|)
define|\
value|((tvu) = (int32)						\ 		  (((u_int64)(tsf) * MICROSECONDS + 0x80000000)>> 32))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Convert a struct timeval to a time stamp.  */
end_comment

begin_define
define|#
directive|define
name|TVTOTS
parameter_list|(
name|tv
parameter_list|,
name|ts
parameter_list|)
define|\
value|do { \ 		(ts)->l_ui = (u_long)(tv)->tv_sec; \ 		TVUTOTSF((tv)->tv_usec, (ts)->l_uf); \ 	} while (FALSE)
end_define

begin_define
define|#
directive|define
name|sTVTOTS
parameter_list|(
name|tv
parameter_list|,
name|ts
parameter_list|)
define|\
value|do { \ 		int isneg = 0; \ 		long usec; \ 		(ts)->l_ui = (tv)->tv_sec; \ 		usec = (tv)->tv_usec; \ 		if (((tv)->tv_sec< 0) || ((tv)->tv_usec< 0)) { \ 			usec = -usec; \ 			(ts)->l_ui = -(ts)->l_ui; \ 			isneg = 1; \ 		} \ 		TVUTOTSF(usec, (ts)->l_uf); \ 		if (isneg) { \ 			L_NEG((ts)); \ 		} \ 	} while (FALSE)
end_define

begin_comment
comment|/*  * Convert a time stamp to a struct timeval.  The time stamp  * has to be positive.  */
end_comment

begin_define
define|#
directive|define
name|TSTOTV
parameter_list|(
name|ts
parameter_list|,
name|tv
parameter_list|)
define|\
value|do { \ 		(tv)->tv_sec = (ts)->l_ui; \ 		TSFTOTVU((ts)->l_uf, (tv)->tv_usec); \ 		if ((tv)->tv_usec == 1000000) { \ 			(tv)->tv_sec++; \ 			(tv)->tv_usec = 0; \ 		} \ 	} while (FALSE)
end_define

begin_comment
comment|/*  * predicate: returns TRUE if the microseconds are in nominal range  * use like: int timeval_isnormal(const struct timeval *x)  */
end_comment

begin_define
define|#
directive|define
name|timeval_isnormal
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)->tv_usec>= 0&& (x)->tv_usec< MICROSECONDS)
end_define

begin_comment
comment|/*  * Convert milliseconds to a time stamp fraction.  Unused except for  * refclock_leitch.c, so accompanying lookup tables were removed in  * favor of reusing the microseconds conversion tables.  */
end_comment

begin_define
define|#
directive|define
name|MSUTOTSF
parameter_list|(
name|msu
parameter_list|,
name|tsf
parameter_list|)
value|TVUTOTSF((msu) * 1000, tsf)
end_define

begin_comment
comment|/*  * predicate: returns TRUE if the microseconds are out-of-bounds  * use like: int timeval_isdenormal(const struct timeval *x)  */
end_comment

begin_define
define|#
directive|define
name|timeval_isdenormal
parameter_list|(
name|x
parameter_list|)
value|(!timeval_isnormal(x))
end_define

begin_comment
comment|/* make sure microseconds are in nominal range */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timeval
name|normalize_tval
parameter_list|(
name|struct
name|timeval
name|x
parameter_list|)
block|{
name|long
name|z
decl_stmt|;
comment|/* 	 * If the fraction becomes excessive denormal, we use division 	 * to do first partial normalisation. The normalisation loops 	 * following will do the remaining cleanup. Since the size of 	 * tv_usec has a peculiar definition by the standard the range 	 * check is coded manually. And labs() is intentionally not used 	 * here: it has implementation-defined behaviour when applied 	 * to LONG_MIN. 	 */
if|if
condition|(
name|x
operator|.
name|tv_usec
operator|<
operator|-
literal|3l
operator|*
name|MICROSECONDS
operator|||
name|x
operator|.
name|tv_usec
operator|>
literal|3l
operator|*
name|MICROSECONDS
condition|)
block|{
name|z
operator|=
name|x
operator|.
name|tv_usec
operator|/
name|MICROSECONDS
expr_stmt|;
name|x
operator|.
name|tv_usec
operator|-=
name|z
operator|*
name|MICROSECONDS
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|+=
name|z
expr_stmt|;
block|}
comment|/* 	 * Do any remaining normalisation steps in loops. This takes 3 	 * steps max, and should outperform a division even if the 	 * mul-by-inverse trick is employed. (It also does the floor 	 * division adjustment if the above division was executed.) 	 */
if|if
condition|(
name|x
operator|.
name|tv_usec
operator|<
literal|0
condition|)
do|do
block|{
name|x
operator|.
name|tv_usec
operator|+=
name|MICROSECONDS
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|.
name|tv_usec
operator|<
literal|0
condition|)
do|;
elseif|else
if|if
condition|(
name|x
operator|.
name|tv_usec
operator|>=
name|MICROSECONDS
condition|)
do|do
block|{
name|x
operator|.
name|tv_usec
operator|-=
name|MICROSECONDS
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|.
name|tv_usec
operator|>=
name|MICROSECONDS
condition|)
do|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* x = a + b */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timeval
name|add_tval
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|,
name|struct
name|timeval
name|b
parameter_list|)
block|{
name|struct
name|timeval
name|x
decl_stmt|;
name|x
operator|=
name|a
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|+=
name|b
operator|.
name|tv_sec
expr_stmt|;
name|x
operator|.
name|tv_usec
operator|+=
name|b
operator|.
name|tv_usec
expr_stmt|;
return|return
name|normalize_tval
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* x = a + b, b is fraction only */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timeval
name|add_tval_us
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|struct
name|timeval
name|x
decl_stmt|;
name|x
operator|=
name|a
expr_stmt|;
name|x
operator|.
name|tv_usec
operator|+=
name|b
expr_stmt|;
return|return
name|normalize_tval
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* x = a - b */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timeval
name|sub_tval
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|,
name|struct
name|timeval
name|b
parameter_list|)
block|{
name|struct
name|timeval
name|x
decl_stmt|;
name|x
operator|=
name|a
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|-=
name|b
operator|.
name|tv_sec
expr_stmt|;
name|x
operator|.
name|tv_usec
operator|-=
name|b
operator|.
name|tv_usec
expr_stmt|;
return|return
name|normalize_tval
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* x = a - b, b is fraction only */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timeval
name|sub_tval_us
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|struct
name|timeval
name|x
decl_stmt|;
name|x
operator|=
name|a
expr_stmt|;
name|x
operator|.
name|tv_usec
operator|-=
name|b
expr_stmt|;
return|return
name|normalize_tval
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* x = -a */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timeval
name|neg_tval
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|)
block|{
name|struct
name|timeval
name|x
decl_stmt|;
name|x
operator|.
name|tv_sec
operator|=
operator|-
name|a
operator|.
name|tv_sec
expr_stmt|;
name|x
operator|.
name|tv_usec
operator|=
operator|-
name|a
operator|.
name|tv_usec
expr_stmt|;
return|return
name|normalize_tval
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* x = abs(a) */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timeval
name|abs_tval
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|)
block|{
name|struct
name|timeval
name|c
decl_stmt|;
name|c
operator|=
name|normalize_tval
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|tv_sec
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|.
name|tv_usec
operator|!=
literal|0
condition|)
block|{
name|c
operator|.
name|tv_sec
operator|=
operator|-
name|c
operator|.
name|tv_sec
operator|-
literal|1
expr_stmt|;
name|c
operator|.
name|tv_usec
operator|=
name|MICROSECONDS
operator|-
name|c
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|tv_sec
operator|=
operator|-
name|c
operator|.
name|tv_sec
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * compare previously-normalised a and b  * return 1 / 0 / -1 if a< / == /> b  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cmp_tval
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|,
name|struct
name|timeval
name|b
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|a
operator|.
name|tv_sec
operator|>
name|b
operator|.
name|tv_sec
operator|)
operator|-
operator|(
name|a
operator|.
name|tv_sec
operator|<
name|b
operator|.
name|tv_sec
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|r
condition|)
name|r
operator|=
operator|(
name|a
operator|.
name|tv_usec
operator|>
name|b
operator|.
name|tv_usec
operator|)
operator|-
operator|(
name|a
operator|.
name|tv_usec
operator|<
name|b
operator|.
name|tv_usec
operator|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * compare possibly-denormal a and b  * return 1 / 0 / -1 if a< / == /> b  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cmp_tval_denorm
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|,
name|struct
name|timeval
name|b
parameter_list|)
block|{
return|return
name|cmp_tval
argument_list|(
name|normalize_tval
argument_list|(
name|a
argument_list|)
argument_list|,
name|normalize_tval
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * test previously-normalised a  * return 1 / 0 / -1 if a< / == /> 0  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|test_tval
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|a
operator|.
name|tv_sec
operator|>
literal|0
operator|)
operator|-
operator|(
name|a
operator|.
name|tv_sec
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
operator|(
name|a
operator|.
name|tv_usec
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * test possibly-denormal a  * return 1 / 0 / -1 if a< / == /> 0  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|test_tval_denorm
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|)
block|{
return|return
name|test_tval
argument_list|(
name|normalize_tval
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* return LIB buffer ptr to string rep */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|tvaltoa
parameter_list|(
name|struct
name|timeval
name|x
parameter_list|)
block|{
return|return
name|format_time_fraction
argument_list|(
name|x
operator|.
name|tv_sec
argument_list|,
name|x
operator|.
name|tv_usec
argument_list|,
literal|6
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* convert from timeval duration to l_fp duration */
end_comment

begin_function
specifier|static
specifier|inline
name|l_fp
name|tval_intv_to_lfp
parameter_list|(
name|struct
name|timeval
name|x
parameter_list|)
block|{
name|struct
name|timeval
name|v
decl_stmt|;
name|l_fp
name|y
decl_stmt|;
name|v
operator|=
name|normalize_tval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|v
operator|.
name|tv_usec
argument_list|,
name|y
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|y
operator|.
name|l_i
operator|=
operator|(
name|int32
operator|)
name|v
operator|.
name|tv_sec
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/* x must be UN*X epoch, output *y will be in NTP epoch */
end_comment

begin_function
specifier|static
specifier|inline
name|l_fp
name|tval_stamp_to_lfp
parameter_list|(
name|struct
name|timeval
name|x
parameter_list|)
block|{
name|l_fp
name|y
decl_stmt|;
name|y
operator|=
name|tval_intv_to_lfp
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/* convert to l_fp type, relative signed/unsigned and absolute */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timeval
name|lfp_intv_to_tval
parameter_list|(
name|l_fp
name|x
parameter_list|)
block|{
name|struct
name|timeval
name|out
decl_stmt|;
name|l_fp
name|absx
decl_stmt|;
name|int
name|neg
decl_stmt|;
name|neg
operator|=
name|L_ISNEG
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
name|absx
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|L_NEG
argument_list|(
operator|&
name|absx
argument_list|)
expr_stmt|;
block|}
name|TSFTOTVU
argument_list|(
name|absx
operator|.
name|l_uf
argument_list|,
name|out
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|out
operator|.
name|tv_sec
operator|=
name|absx
operator|.
name|l_i
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|out
operator|.
name|tv_sec
operator|=
operator|-
name|out
operator|.
name|tv_sec
expr_stmt|;
name|out
operator|.
name|tv_usec
operator|=
operator|-
name|out
operator|.
name|tv_usec
expr_stmt|;
name|out
operator|=
name|normalize_tval
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|timeval
name|lfp_uintv_to_tval
parameter_list|(
name|l_fp
name|x
parameter_list|)
block|{
name|struct
name|timeval
name|out
decl_stmt|;
name|TSFTOTVU
argument_list|(
name|x
operator|.
name|l_uf
argument_list|,
name|out
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|out
operator|.
name|tv_sec
operator|=
name|x
operator|.
name|l_ui
expr_stmt|;
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/*  * absolute (timestamp) conversion. Input is time in NTP epoch, output  * is in UN*X epoch. The NTP time stamp will be expanded around the  * pivot time *p or the current time, if p is NULL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|timeval
name|lfp_stamp_to_tval
parameter_list|(
name|l_fp
name|x
parameter_list|,
specifier|const
name|time_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|timeval
name|out
decl_stmt|;
name|vint64
name|sec
decl_stmt|;
name|sec
operator|=
name|ntpcal_ntp_to_time
argument_list|(
name|x
operator|.
name|l_ui
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|TSFTOTVU
argument_list|(
name|x
operator|.
name|l_uf
argument_list|,
name|out
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* copying a vint64 to a time_t needs some care... */
if|#
directive|if
name|SIZEOF_TIME_T
operator|<=
literal|4
name|out
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|sec
operator|.
name|d_s
operator|.
name|lo
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_INT64
argument_list|)
name|out
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|sec
operator|.
name|q_s
expr_stmt|;
else|#
directive|else
name|out
operator|.
name|tv_sec
operator|=
operator|(
operator|(
name|time_t
operator|)
name|sec
operator|.
name|d_s
operator|.
name|hi
operator|<<
literal|32
operator|)
operator||
name|sec
operator|.
name|d_s
operator|.
name|lo
expr_stmt|;
endif|#
directive|endif
name|out
operator|=
name|normalize_tval
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIMEVALOPS_H */
end_comment

end_unit

