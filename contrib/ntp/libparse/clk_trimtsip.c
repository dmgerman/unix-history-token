begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/ntp-4/libparse/clk_trimtsip.c,v 4.13 1999/11/28 09:13:51 kardel RELEASE_19991128_A  *  * clk_trimtsip.c,v 4.13 1999/11/28 09:13:51 kardel RELEASE_19991128_A  *  * Trimble TSIP support - CURRENTLY VERY MUCH UNDER CONSTRUCTION  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_PARSE
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_TRIMTSIP
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PARSESTREAM
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"sys/parsestreams.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ascii.h"
end_include

begin_include
include|#
directive|include
file|"binio.h"
end_include

begin_include
include|#
directive|include
file|"ieee754io.h"
end_include

begin_include
include|#
directive|include
file|"trimble.h"
end_include

begin_comment
comment|/*  * Trimble low level TSIP parser / time converter  *  * The receiver uses a serial message protocol called Trimble Standard  * Interface Protocol (it can support others but this driver only supports  * TSIP). Messages in this protocol have the following form:  *  *<DLE><id> ...<data> ...<DLE><ETX>  *  * Any bytes within the<data> portion of value 10 hex (<DLE>) are doubled  * on transmission and compressed back to one on reception. Otherwise  * the values of data bytes can be anything. The serial interface is RS-422  * asynchronous using 9600 baud, 8 data bits with odd party (**note** 9 bits  * in total!), and 1 stop bit. The protocol supports byte, integer, single,  * and double datatypes. Integers are two bytes, sent most significant first.  * Singles are IEEE754 single precision floating point numbers (4 byte) sent  * sign& exponent first. Doubles are IEEE754 double precision floating point  * numbers (8 byte) sent sign& exponent first.  * The receiver supports a large set of messages, only a very small subset of  * which is used here.  *  * From this module the following are recognised:  *  *  ID    Description  *  *  41    GPS Time  *  46    Receiver health  *  4F    UTC correction data (used to get leap second warnings)  *  * All others are accepted but ignored for time conversion - they are passed up to higher layers.  *  */
end_comment

begin_decl_stmt
specifier|static
name|offsets_t
name|trim_offsets
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|trimble
block|{
name|u_char
name|t_in_pkt
decl_stmt|;
comment|/* first DLE received */
name|u_char
name|t_dle
decl_stmt|;
comment|/* subsequent DLE received */
name|u_short
name|t_week
decl_stmt|;
comment|/* GPS week */
name|u_short
name|t_weekleap
decl_stmt|;
comment|/* GPS week of next/last week */
name|u_short
name|t_dayleap
decl_stmt|;
comment|/* day in week */
name|u_short
name|t_gpsutc
decl_stmt|;
comment|/* GPS - UTC offset */
name|u_short
name|t_gpsutcleap
decl_stmt|;
comment|/* offset at next/last leap */
name|u_char
name|t_operable
decl_stmt|;
comment|/* receiver feels OK */
name|u_char
name|t_mode
decl_stmt|;
comment|/* actual operating mode */
name|u_char
name|t_leap
decl_stmt|;
comment|/* possible leap warning */
name|u_char
name|t_utcknown
decl_stmt|;
comment|/* utc offset known */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|STATUS_BAD
value|0
end_define

begin_comment
comment|/* BAD or UNINITIALIZED receiver status */
end_comment

begin_define
define|#
directive|define
name|STATUS_UNSAFE
value|1
end_define

begin_comment
comment|/* not enough receivers for full precision */
end_comment

begin_define
define|#
directive|define
name|STATUS_SYNC
value|2
end_define

begin_comment
comment|/* enough information for good operation */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|inp_tsip
name|P
argument_list|(
operator|(
name|parse_t
operator|*
operator|,
name|unsigned
name|int
operator|,
name|timestamp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cvt_trimtsip
name|P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|format
operator|*
operator|,
name|clocktime_t
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|clockformat
name|clock_trimtsip
init|=
block|{
name|inp_tsip
block|,
comment|/* Trimble TSIP input handler */
name|cvt_trimtsip
block|,
comment|/* Trimble TSIP conversion */
name|pps_one
block|,
comment|/* easy PPS monitoring */
literal|0
block|,
comment|/* no configuration data */
literal|"Trimble TSIP"
block|,
literal|400
block|,
comment|/* input buffer */
expr|sizeof
operator|(
expr|struct
name|trimble
operator|)
comment|/* private data */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDSECOND
value|0x01
end_define

begin_define
define|#
directive|define
name|DELSECOND
value|0x02
end_define

begin_function
specifier|static
name|unsigned
name|long
name|inp_tsip
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|unsigned
name|int
name|ch
parameter_list|,
name|timestamp_t
modifier|*
name|tstamp
parameter_list|)
block|{
name|struct
name|trimble
modifier|*
name|t
init|=
operator|(
expr|struct
name|trimble
operator|*
operator|)
name|parseio
operator|->
name|parse_pdata
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|PARSE_INP_SKIP
return|;
comment|/* local data not allocated - sigh! */
if|if
condition|(
operator|!
name|t
operator|->
name|t_in_pkt
operator|&&
name|ch
operator|!=
name|DLE
condition|)
block|{
comment|/* wait for start of packet */
return|return
name|PARSE_INP_SKIP
return|;
block|}
if|if
condition|(
operator|(
name|parseio
operator|->
name|parse_index
operator|>=
operator|(
name|parseio
operator|->
name|parse_dsize
operator|-
literal|2
operator|)
operator|)
operator|||
operator|(
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
argument_list|)
operator|-
literal|2
operator|)
operator|)
condition|)
block|{
comment|/* OVERFLOW - DROP! */
name|t
operator|->
name|t_in_pkt
operator|=
name|t
operator|->
name|t_dle
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_index
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|=
literal|0
expr_stmt|;
return|return
name|PARSE_INP_SKIP
return|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|DLE
case|:
if|if
condition|(
operator|!
name|t
operator|->
name|t_in_pkt
condition|)
block|{
name|t
operator|->
name|t_dle
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_in_pkt
operator|=
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_index
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
index|[
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|tstamp
expr_stmt|;
comment|/* pick up time stamp at packet start */
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|t_dle
condition|)
block|{
comment|/* Double DLE -> insert a DLE */
name|t
operator|->
name|t_dle
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|DLE
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
index|[
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|++
index|]
operator|=
name|DLE
expr_stmt|;
block|}
else|else
name|t
operator|->
name|t_dle
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ETX
case|:
if|if
condition|(
name|t
operator|->
name|t_dle
condition|)
block|{
comment|/* DLE,ETX -> end of packet */
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|DLE
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
index|]
operator|=
name|ch
expr_stmt|;
name|parseio
operator|->
name|parse_ldsize
operator|=
name|parseio
operator|->
name|parse_index
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|parseio
operator|->
name|parse_ldata
argument_list|,
name|parseio
operator|->
name|parse_data
argument_list|,
name|parseio
operator|->
name|parse_ldsize
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
index|[
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|++
index|]
operator|=
name|DLE
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
index|[
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|t
operator|->
name|t_in_pkt
operator|=
name|t
operator|->
name|t_dle
operator|=
literal|0
expr_stmt|;
return|return
name|PARSE_INP_TIME
operator||
name|PARSE_INP_DATA
return|;
block|}
default|default:
comment|/* collect data */
name|t
operator|->
name|t_dle
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
index|[
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
return|return
name|PARSE_INP_SKIP
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getshort
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|get_msb_short
argument_list|(
operator|&
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * cvt_trimtsip  *  * convert TSIP type format  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|cvt_trimtsip
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|format
modifier|*
name|format
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|,
name|void
modifier|*
name|local
parameter_list|)
block|{
specifier|register
name|struct
name|trimble
modifier|*
name|t
init|=
operator|(
expr|struct
name|trimble
operator|*
operator|)
name|local
decl_stmt|;
comment|/* get local data space */
define|#
directive|define
name|mb
parameter_list|(
name|_X_
parameter_list|)
value|(buffer[2+(_X_)])
comment|/* shortcut for buffer access */
specifier|register
name|u_char
name|cmd
decl_stmt|;
name|clock_time
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
return|return
name|CVT_NONE
return|;
comment|/* local data not allocated - sigh! */
block|}
if|if
condition|(
operator|(
name|size
operator|<
literal|4
operator|)
operator|||
operator|(
name|buffer
index|[
literal|0
index|]
operator|!=
name|DLE
operator|)
operator|||
operator|(
name|buffer
index|[
name|size
operator|-
literal|1
index|]
operator|!=
name|ETX
operator|)
operator|||
operator|(
name|buffer
index|[
name|size
operator|-
literal|2
index|]
operator|!=
name|DLE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"TRIMBLE BAD packet, size %d:\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|CVT_NONE
return|;
block|}
else|else
block|{
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|cmd
operator|=
name|buffer
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CMD_RCURTIME
case|:
block|{
comment|/* GPS time */
name|l_fp
name|secs
decl_stmt|;
name|int
name|week
init|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|l_fp
name|utcoffset
decl_stmt|;
name|l_fp
name|gpstime
decl_stmt|;
name|bp
operator|=
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch_ieee754
argument_list|(
operator|&
name|bp
argument_list|,
name|IEEE_SINGLE
argument_list|,
operator|&
name|secs
argument_list|,
name|trim_offsets
argument_list|)
operator|!=
name|IEEE_OK
condition|)
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
if|if
condition|(
operator|(
name|secs
operator|.
name|l_i
operator|<=
literal|0
operator|)
operator|||
operator|(
name|t
operator|->
name|t_utcknown
operator|==
literal|0
operator|)
condition|)
block|{
name|clock_time
operator|->
name|flags
operator|=
name|PARSEB_POWERUP
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
if|if
condition|(
name|week
operator|<
literal|990
condition|)
block|{
name|week
operator|+=
literal|1024
expr_stmt|;
block|}
comment|/* time OK */
comment|/* fetch UTC offset */
name|bp
operator|=
operator|&
name|mb
argument_list|(
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch_ieee754
argument_list|(
operator|&
name|bp
argument_list|,
name|IEEE_SINGLE
argument_list|,
operator|&
name|utcoffset
argument_list|,
name|trim_offsets
argument_list|)
operator|!=
name|IEEE_OK
condition|)
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
name|L_SUB
argument_list|(
operator|&
name|secs
argument_list|,
operator|&
name|utcoffset
argument_list|)
expr_stmt|;
comment|/* adjust GPS time to UTC time */
name|gpstolfp
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|week
argument_list|,
operator|(
name|unsigned
name|short
operator|)
literal|0
argument_list|,
name|secs
operator|.
name|l_ui
argument_list|,
operator|&
name|gpstime
argument_list|)
expr_stmt|;
name|gpstime
operator|.
name|l_uf
operator|=
name|secs
operator|.
name|l_uf
expr_stmt|;
name|clock_time
operator|->
name|utctime
operator|=
name|gpstime
operator|.
name|l_ui
operator|-
name|JAN_1970
expr_stmt|;
name|TSFTOTVU
argument_list|(
name|gpstime
operator|.
name|l_uf
argument_list|,
name|clock_time
operator|->
name|usecond
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_leap
operator|==
name|ADDSECOND
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPADD
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_leap
operator|==
name|DELSECOND
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPDEL
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|t_operable
condition|)
block|{
case|case
name|STATUS_SYNC
case|:
name|clock_time
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PARSEB_POWERUP
operator||
name|PARSEB_NOSYNC
operator|)
expr_stmt|;
break|break;
case|case
name|STATUS_UNSAFE
case|:
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_NOSYNC
expr_stmt|;
break|break;
case|case
name|STATUS_BAD
case|:
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_NOSYNC
operator||
name|PARSEB_POWERUP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|t_mode
operator|==
literal|0
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_POSITION
expr_stmt|;
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_S_LEAP
operator||
name|PARSEB_S_POSITION
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
comment|/* case 0x41 */
case|case
name|CMD_RRECVHEALTH
case|:
block|{
comment|/* TRIMBLE health */
name|u_char
name|status
init|=
name|mb
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* position fixes */
name|t
operator|->
name|t_operable
operator|=
name|STATUS_SYNC
expr_stmt|;
break|break;
case|case
literal|0x09
case|:
comment|/* 1 satellite */
case|case
literal|0x0A
case|:
comment|/* 2 satellites */
case|case
literal|0x0B
case|:
comment|/* 3 satellites */
name|t
operator|->
name|t_operable
operator|=
name|STATUS_UNSAFE
expr_stmt|;
break|break;
default|default:
name|t
operator|->
name|t_operable
operator|=
name|STATUS_BAD
expr_stmt|;
break|break;
block|}
name|t
operator|->
name|t_mode
operator|=
name|status
expr_stmt|;
block|}
break|break;
case|case
name|CMD_RUTCPARAM
case|:
block|{
name|l_fp
name|t0t
decl_stmt|;
name|unsigned
name|char
modifier|*
name|lbp
decl_stmt|;
comment|/* UTC correction data - derive a leap warning */
name|int
name|tls
init|=
name|t
operator|->
name|t_gpsutc
operator|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|12
argument_list|)
argument_list|)
decl_stmt|;
comment|/* current leap correction (GPS-UTC) */
name|int
name|tlsf
init|=
name|t
operator|->
name|t_gpsutcleap
operator|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|24
argument_list|)
argument_list|)
decl_stmt|;
comment|/* new leap correction */
name|t
operator|->
name|t_weekleap
operator|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|20
argument_list|)
argument_list|)
expr_stmt|;
comment|/* week no of leap correction */
if|if
condition|(
name|t
operator|->
name|t_weekleap
operator|<
literal|990
condition|)
name|t
operator|->
name|t_weekleap
operator|+=
literal|1024
expr_stmt|;
name|t
operator|->
name|t_dayleap
operator|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|22
argument_list|)
argument_list|)
expr_stmt|;
comment|/* day in week of leap correction */
name|t
operator|->
name|t_week
operator|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|18
argument_list|)
argument_list|)
expr_stmt|;
comment|/* current week no */
if|if
condition|(
name|t
operator|->
name|t_week
operator|<
literal|990
condition|)
name|t
operator|->
name|t_week
operator|+=
literal|1024
expr_stmt|;
name|lbp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|14
argument_list|)
expr_stmt|;
comment|/* last update time */
if|if
condition|(
name|fetch_ieee754
argument_list|(
operator|&
name|lbp
argument_list|,
name|IEEE_SINGLE
argument_list|,
operator|&
name|t0t
argument_list|,
name|trim_offsets
argument_list|)
operator|!=
name|IEEE_OK
condition|)
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
name|t
operator|->
name|t_utcknown
operator|=
name|t0t
operator|.
name|l_ui
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|t_utcknown
operator|)
operator|&&
comment|/* got UTC information */
operator|(
name|tlsf
operator|!=
name|tls
operator|)
operator|&&
comment|/* something will change */
operator|(
operator|(
name|t
operator|->
name|t_weekleap
operator|-
name|t
operator|->
name|t_week
operator|)
operator|<
literal|5
operator|)
condition|)
comment|/* and close in the future */
block|{
comment|/* generate a leap warning */
if|if
condition|(
name|tlsf
operator|>
name|tls
condition|)
name|t
operator|->
name|t_leap
operator|=
name|ADDSECOND
expr_stmt|;
else|else
name|t
operator|->
name|t_leap
operator|=
name|DELSECOND
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|t_leap
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* it's validly formed, but we don't care about it! */
break|break;
block|}
block|}
return|return
name|CVT_SKIP
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_TRIMTSIP&& !PARSESTREAM) */
end_comment

begin_decl_stmt
name|int
name|clk_trimtsip_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_TRIMTSIP&& !PARSESTREAM) */
end_comment

begin_comment
comment|/*  * History:  *  * clk_trimtsip.c,v  * Revision 4.13  1999/11/28 09:13:51  kardel  * RECON_4_0_98F  *  * Revision 4.12  1999/02/28 13:00:08  kardel  * *** empty log message ***  *  * Revision 4.11  1999/02/28 11:47:54  kardel  * (struct trimble): new member t_utcknown  * (cvt_trimtsip): fixed status monitoring, bad receiver states are  * now recognized  *  * Revision 4.10  1999/02/27 15:57:15  kardel  * use mmemcpy instead of bcopy  *  * Revision 4.9  1999/02/21 12:17:42  kardel  * 4.91f reconcilation  *  * Revision 4.8  1998/11/15 20:27:58  kardel  * Release 4.0.73e13 reconcilation  *  * Revision 4.7  1998/08/16 18:49:20  kardel  * (cvt_trimtsip): initial kernel capable version (no more floats)  * (clock_trimtsip =): new format name  *  * Revision 4.6  1998/08/09 22:26:05  kardel  * Trimble TSIP support  *  * Revision 4.5  1998/08/02 10:37:05  kardel  * working TSIP parser  *  * Revision 4.4  1998/06/28 16:50:40  kardel  * (getflt): fixed ENDIAN issue  * (getdbl): fixed ENDIAN issue  * (getint): use get_msb_short()  * (cvt_trimtsip): use gpstolfp() for conversion  *  * Revision 4.3  1998/06/13 12:07:31  kardel  * fix SYSV clock name clash  *  * Revision 4.2  1998/06/12 15:22:30  kardel  * fix prototypes  *  * Revision 4.1  1998/05/24 09:39:54  kardel  * implementation of the new IO handling model  *  * Revision 4.0  1998/04/10 19:45:32  kardel  * Start 4.0 release version numbering  *  * from V3 1.8 loginfo deleted 1998/04/11 kardel  */
end_comment

end_unit

