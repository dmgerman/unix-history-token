begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/ntp-4/libparse/clk_meinberg.c,v 4.8 1999/11/28 09:13:50 kardel RELEASE_19991128_A  *    * clk_meinberg.c,v 4.8 1999/11/28 09:13:50 kardel RELEASE_19991128_A  *  * Meinberg clock support  *  * Copyright (C) 1995-1999 by Frank Kardel<kardel@acm.org>  * Copyright (C) 1992-1994 by Frank Kardel, Friedrich-Alexander Universität Erlangen-Nürnberg, Germany  *                                      * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_PARSE
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_MEINBERG
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PARSESTREAM
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"sys/parsestreams.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"mbg_gps166.h"
end_include

begin_include
include|#
directive|include
file|"binio.h"
end_include

begin_include
include|#
directive|include
file|"ascii.h"
end_include

begin_comment
comment|/*  * The Meinberg receiver every second sends a datagram of the following form  * (Standard Format)  *   *<STX>D:<dd>.<mm>.<yy>;T:<w>;U:<hh>:<mm>:<ss>;<S><F><D><A><ETX>  * pos:  0  00 00 0 00 0 11 111 1 111 12 2 22 2 22 2 2  2  3  3   3  *       1  23 45 6 78 9 01 234 5 678 90 1 23 4 56 7 8  9  0  1   2  *<STX>           = '\002' ASCII start of text  *<ETX>           = '\003' ASCII end of text  *<dd>,<mm>,<yy>  = day, month, year(2 digits!!)  *<w>             = day of week (sunday= 0)  *<hh>,<mm>,<ss>  = hour, minute, second  *<S>             = '#' if never synced since powerup for DCF C51  *                 = '#' if not PZF sychronisation available for PZF 535/509  *                 = ' ' if ok  *<F>             = '*' if time comes from internal quartz  *                 = ' ' if completely synched  *<D>             = 'S' if daylight saving time is active  *                 = 'U' if time is represented in UTC  *                 = ' ' if no special condition exists  *<A>             = '!' during the hour preceeding an daylight saving time  *                       start/end change  *                 = 'A' leap second insert warning  *                 = ' ' if no special condition exists  *  * Extended data format (PZFUERL for PZF type clocks)  *  *<STX><dd>.<mm>.<yy>;<w>;<hh>:<mm>:<ss>;<U><S><F><D><A><L><R><ETX>  * pos:  0   00 0 00 0 00 11 1 11 11 1 11 2 22 22 2  2  2  2  2  3  3   3  *       1   23 4 56 7 89 01 2 34 56 7 89 0 12 34 5  6  7  8  9  0  1   2  *<STX>           = '\002' ASCII start of text  *<ETX>           = '\003' ASCII end of text  *<dd>,<mm>,<yy>  = day, month, year(2 digits!!)  *<w>             = day of week (sunday= 0)  *<hh>,<mm>,<ss>  = hour, minute, second  *<U>             = 'U' UTC time display  *<S>             = '#' if never synced since powerup else ' ' for DCF C51  *                   '#' if not PZF sychronisation available else ' ' for PZF 535/509  *<F>             = '*' if time comes from internal quartz else ' '  *<D>             = 'S' if daylight saving time is active else ' '  *<A>             = '!' during the hour preceeding an daylight saving time  *                       start/end change  *<L>             = 'A' LEAP second announcement  *<R>             = 'R' alternate antenna  *  * Meinberg GPS166 receiver  *  * You must get the Uni-Erlangen firmware for the GPS receiver support  * to work to full satisfaction !  *  *<STX><dd>.<mm>.<yy>;<w>;<hh>:<mm>:<ss>;<+/-><00:00>;<U><S><F><D><A><L><R><L>;<position...><ETX>  *  *        000000000111111111122222222223333333333444444444455555555556666666  *        123456789012345678901234567890123456789012345678901234567890123456  *     \x0209.07.93; 5; 08:48:26; +00:00; #*S!A L; 49.5736N  11.0280E  373m\x03  *  *   *<STX>           = '\002' ASCII start of text  *<ETX>           = '\003' ASCII end of text  *<dd>,<mm>,<yy>  = day, month, year(2 digits!!)  *<w>             = day of week (sunday= 0)  *<hh>,<mm>,<ss>  = hour, minute, second  *<+/->,<00:00>   = offset to UTC  *<S>             = '#' if never synced since powerup else ' '  *<F>             = '*' if position is not confirmed else ' '  *<D>             = 'S' if daylight saving time is active else ' '  *<A>             = '!' during the hour preceeding an daylight saving time  *                       start/end change  *<L>             = 'A' LEAP second announcement  *<R>             = 'R' alternate antenna (reminiscent of PZF535) usually ' '  *<L>		   = 'L' on 23:59:60  *  * Binary messages have a lead in for a fixed header of SOH  */
end_comment

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Name:         csum()                                         */
end_comment

begin_comment
comment|/*                                                              */
end_comment

begin_comment
comment|/* Purpose:      Compute a checksum about a number of bytes     */
end_comment

begin_comment
comment|/*                                                              */
end_comment

begin_comment
comment|/* Input:        uchar *p    address of the first byte          */
end_comment

begin_comment
comment|/*               short n     the number of bytes                */
end_comment

begin_comment
comment|/*                                                              */
end_comment

begin_comment
comment|/* Output:       --                                             */
end_comment

begin_comment
comment|/*                                                              */
end_comment

begin_comment
comment|/* Ret val:      the checksum                                   */
end_comment

begin_comment
comment|/*+-------------------------------------------------------------*/
end_comment

begin_function
name|unsigned
name|long
name|mbg_csum
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|long
name|sum
init|=
literal|0
decl_stmt|;
name|short
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_comment
comment|/* csum */
end_comment

begin_function
name|void
name|get_mbg_header
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|bufpp
parameter_list|,
name|GPS_MSG_HDR
modifier|*
name|headerp
parameter_list|)
block|{
name|headerp
operator|->
name|gps_cmd
operator|=
name|get_lsb_short
argument_list|(
name|bufpp
argument_list|)
expr_stmt|;
name|headerp
operator|->
name|gps_len
operator|=
name|get_lsb_short
argument_list|(
name|bufpp
argument_list|)
expr_stmt|;
name|headerp
operator|->
name|gps_data_csum
operator|=
name|get_lsb_short
argument_list|(
name|bufpp
argument_list|)
expr_stmt|;
name|headerp
operator|->
name|gps_hdr_csum
operator|=
name|get_lsb_short
argument_list|(
name|bufpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|format
name|meinberg_fmt
index|[]
init|=
block|{
block|{
block|{
block|{
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|2
block|}
block|,
block|{
literal|9
block|,
literal|2
block|}
block|,
block|{
literal|18
block|,
literal|2
block|}
block|,
block|{
literal|21
block|,
literal|2
block|}
block|,
block|{
literal|24
block|,
literal|2
block|}
block|,
block|{
literal|14
block|,
literal|1
block|}
block|,
block|{
literal|27
block|,
literal|4
block|}
block|,
block|{
literal|29
block|,
literal|1
block|}
block|, 		}
block|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"\2D:  .  .  ;T: ;U:  .  .  ;    \3"
block|,
literal|0
block|}
block|,
block|{
comment|/* special extended FAU Erlangen extended format */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|2
block|}
block|,
block|{
literal|14
block|,
literal|2
block|}
block|,
block|{
literal|17
block|,
literal|2
block|}
block|,
block|{
literal|20
block|,
literal|2
block|}
block|,
block|{
literal|11
block|,
literal|1
block|}
block|,
block|{
literal|25
block|,
literal|4
block|}
block|,
block|{
literal|27
block|,
literal|1
block|}
block|, 		}
block|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"\2  .  .  ;  ;   :  :  ;        \3"
block|,
name|MBG_EXTENDED
block|}
block|,
block|{
comment|/* special extended FAU Erlangen GPS format */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|2
block|}
block|,
block|{
literal|14
block|,
literal|2
block|}
block|,
block|{
literal|17
block|,
literal|2
block|}
block|,
block|{
literal|20
block|,
literal|2
block|}
block|,
block|{
literal|11
block|,
literal|1
block|}
block|,
block|{
literal|32
block|,
literal|7
block|}
block|,
block|{
literal|35
block|,
literal|1
block|}
block|,
block|{
literal|25
block|,
literal|2
block|}
block|,
block|{
literal|28
block|,
literal|2
block|}
block|,
block|{
literal|24
block|,
literal|1
block|}
block|}
block|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"\2  .  .  ;  ;   :  :  ;    :  ;        ;   .         .       "
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|cvt_meinberg
name|P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|format
operator|*
operator|,
name|clocktime_t
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|cvt_mgps
name|P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|format
operator|*
operator|,
name|clocktime_t
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|mbg_input
name|P
argument_list|(
operator|(
name|parse_t
operator|*
operator|,
name|unsigned
name|int
operator|,
name|timestamp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|gps_input
name|P
argument_list|(
operator|(
name|parse_t
operator|*
operator|,
name|unsigned
name|int
operator|,
name|timestamp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|msg_buf
block|{
name|unsigned
name|short
name|len
decl_stmt|;
comment|/* len to fill */
name|unsigned
name|short
name|phase
decl_stmt|;
comment|/* current input phase */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MBG_NONE
value|0
end_define

begin_comment
comment|/* no data input */
end_comment

begin_define
define|#
directive|define
name|MBG_HEADER
value|1
end_define

begin_comment
comment|/* receiving header */
end_comment

begin_define
define|#
directive|define
name|MBG_DATA
value|2
end_define

begin_comment
comment|/* receiving data */
end_comment

begin_define
define|#
directive|define
name|MBG_STRING
value|3
end_define

begin_comment
comment|/* receiving standard data message */
end_comment

begin_decl_stmt
name|clockformat_t
name|clock_meinberg
index|[]
init|=
block|{
block|{
name|mbg_input
block|,
comment|/* normal input handling */
name|cvt_meinberg
block|,
comment|/* Meinberg conversion */
name|pps_one
block|,
comment|/* easy PPS monitoring */
literal|0
block|,
comment|/* conversion configuration */
literal|"Meinberg Standard"
block|,
comment|/* Meinberg simple format - beware */
literal|32
block|,
comment|/* string buffer */
literal|0
comment|/* no private data (complete pakets) */
block|}
block|,
block|{
name|mbg_input
block|,
comment|/* normal input handling */
name|cvt_meinberg
block|,
comment|/* Meinberg conversion */
name|pps_one
block|,
comment|/* easy PPS monitoring */
literal|0
block|,
comment|/* conversion configuration */
literal|"Meinberg Extended"
block|,
comment|/* Meinberg enhanced format */
literal|32
block|,
comment|/* string buffer */
literal|0
comment|/* no private data (complete pakets) */
block|}
block|,
block|{
name|gps_input
block|,
comment|/* no input handling */
name|cvt_mgps
block|,
comment|/* Meinberg GPS166 conversion */
name|pps_one
block|,
comment|/* easy PPS monitoring */
operator|(
name|void
operator|*
operator|)
operator|&
name|meinberg_fmt
index|[
literal|2
index|]
block|,
comment|/* conversion configuration */
literal|"Meinberg GPS Extended"
block|,
comment|/* Meinberg FAU GPS format */
literal|512
block|,
comment|/* string buffer */
expr|sizeof
operator|(
expr|struct
name|msg_buf
operator|)
comment|/* no private data (complete pakets) */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * cvt_meinberg  *  * convert simple type format  */
end_comment

begin_function
specifier|static
name|u_long
name|cvt_meinberg
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|format
modifier|*
name|unused
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|,
name|void
modifier|*
name|local
parameter_list|)
block|{
name|struct
name|format
modifier|*
name|format
decl_stmt|;
comment|/* 	 * select automagically correct data format 	 */
if|if
condition|(
name|Strok
argument_list|(
name|buffer
argument_list|,
name|meinberg_fmt
index|[
literal|0
index|]
operator|.
name|fixed_string
argument_list|)
condition|)
block|{
name|format
operator|=
operator|&
name|meinberg_fmt
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Strok
argument_list|(
name|buffer
argument_list|,
name|meinberg_fmt
index|[
literal|1
index|]
operator|.
name|fixed_string
argument_list|)
condition|)
block|{
name|format
operator|=
operator|&
name|meinberg_fmt
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
block|}
comment|/* 	 * collect data 	 */
if|if
condition|(
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_DAY
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|day
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_DAY
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_MONTH
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|month
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_MONTH
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_YEAR
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|year
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_YEAR
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_HOUR
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|hour
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_HOUR
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_MIN
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|minute
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_MIN
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_SEC
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|second
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_SEC
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
else|else
block|{
name|unsigned
name|char
modifier|*
name|f
init|=
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_FLAGS
index|]
operator|.
name|offset
index|]
decl_stmt|;
name|clock_time
operator|->
name|usecond
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|flags
operator|=
name|PARSEB_S_LEAP
expr_stmt|;
if|if
condition|(
name|clock_time
operator|->
name|second
operator|==
literal|60
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPSECOND
expr_stmt|;
comment|/* 		 * in the extended timecode format we have also the 		 * indication that the timecode is in UTC 		 * for compatibilty reasons we start at the USUAL 		 * offset (POWERUP flag) and know that the UTC indication 		 * is the character before the powerup flag 		 */
if|if
condition|(
operator|(
name|format
operator|->
name|flags
operator|&
name|MBG_EXTENDED
operator|)
operator|&&
operator|(
name|f
index|[
operator|-
literal|1
index|]
operator|==
literal|'U'
operator|)
condition|)
block|{
comment|/* 			 * timecode is in UTC 			 */
name|clock_time
operator|->
name|utcoffset
operator|=
literal|0
expr_stmt|;
comment|/* UTC */
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_UTC
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * only calculate UTC offset if MET/MED is in time code 			 * or we have the old time code format, where we do not 			 * know whether it is UTC time or MET/MED 			 * pray that nobody switches to UTC in the *old* standard time code 			 * ROMS !!!! The new ROMS have 'U' at the ZONE field - good. 			 */
switch|switch
condition|(
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_ZONE
index|]
operator|.
name|offset
index|]
condition|)
block|{
case|case
literal|' '
case|:
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
literal|1
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
comment|/* MET */
break|break;
case|case
literal|'S'
case|:
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
literal|2
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
comment|/* MED */
break|break;
case|case
literal|'U'
case|:
comment|/* 				 * timecode is in UTC 				 */
name|clock_time
operator|->
name|utcoffset
operator|=
literal|0
expr_stmt|;
comment|/* UTC */
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_UTC
expr_stmt|;
break|break;
default|default:
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
block|}
comment|/* 		 * gather status flags 		 */
if|if
condition|(
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_ZONE
index|]
operator|.
name|offset
index|]
operator|==
literal|'S'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_DST
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_POWERUP
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_NOSYNC
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|3
index|]
operator|==
literal|'!'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_ANNOUNCE
expr_stmt|;
comment|/* 		 * oncoming leap second 		 * 'a' code not confirmed - earth is not 		 * expected to speed up 		 */
if|if
condition|(
name|f
index|[
literal|3
index|]
operator|==
literal|'A'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPADD
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|3
index|]
operator|==
literal|'a'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPDEL
expr_stmt|;
if|if
condition|(
name|format
operator|->
name|flags
operator|&
name|MBG_EXTENDED
condition|)
block|{
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_S_ANTENNA
expr_stmt|;
comment|/* 			 * DCF77 does not encode the direction - 			 * so we take the current default - 			 * earth slowing down 			 */
name|clock_time
operator|->
name|flags
operator|&=
operator|~
name|PARSEB_LEAPDEL
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|4
index|]
operator|==
literal|'A'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPADD
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|5
index|]
operator|==
literal|'R'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_ALTERNATE
expr_stmt|;
block|}
return|return
name|CVT_OK
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * mbg_input  *  * grep data from input stream  */
end_comment

begin_function
specifier|static
name|u_long
name|mbg_input
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|unsigned
name|int
name|ch
parameter_list|,
name|timestamp_t
modifier|*
name|tstamp
parameter_list|)
block|{
name|unsigned
name|int
name|rtc
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"mbg_input(0x%lx, 0x%x, ...)\n"
operator|,
operator|(
name|long
operator|)
name|parseio
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|STX
case|:
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"mbg_input: STX seen\n"
operator|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_index
operator|=
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|tstamp
expr_stmt|;
comment|/* collect timestamp */
return|return
name|PARSE_INP_SKIP
return|;
case|case
name|ETX
case|:
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"mbg_input: ETX seen\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtc
operator|=
name|parse_addchar
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|)
operator|)
operator|==
name|PARSE_INP_SKIP
condition|)
return|return
name|parse_end
argument_list|(
name|parseio
argument_list|)
return|;
else|else
return|return
name|rtc
return|;
default|default:
return|return
name|parse_addchar
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * cvt_mgps  *  * convert Meinberg GPS format  */
end_comment

begin_function
specifier|static
name|u_long
name|cvt_mgps
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|format
modifier|*
name|format
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|,
name|void
modifier|*
name|local
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Strok
argument_list|(
name|buffer
argument_list|,
name|format
operator|->
name|fixed_string
argument_list|)
condition|)
block|{
return|return
name|cvt_meinberg
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
name|format
argument_list|,
name|clock_time
argument_list|,
name|local
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_DAY
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|day
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_DAY
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_MONTH
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|month
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_MONTH
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_YEAR
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|year
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_YEAR
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_HOUR
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|hour
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_HOUR
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_MIN
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|minute
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_MIN
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_SEC
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|second
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_SEC
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
else|else
block|{
name|long
name|h
decl_stmt|;
name|unsigned
name|char
modifier|*
name|f
init|=
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_FLAGS
index|]
operator|.
name|offset
index|]
decl_stmt|;
name|clock_time
operator|->
name|flags
operator|=
name|PARSEB_S_LEAP
operator||
name|PARSEB_S_POSITION
expr_stmt|;
name|clock_time
operator|->
name|usecond
operator|=
literal|0
expr_stmt|;
comment|/* 			 * calculate UTC offset 			 */
if|if
condition|(
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_UTCHOFFSET
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|h
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_UTCHOFFSET
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
else|else
block|{
if|if
condition|(
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_UTCMOFFSET
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|utcoffset
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_UTCMOFFSET
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
name|clock_time
operator|->
name|utcoffset
operator|+=
name|TIMES60
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|utcoffset
operator|=
name|TIMES60
argument_list|(
name|clock_time
operator|->
name|utcoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_UTCSOFFSET
index|]
operator|.
name|offset
index|]
operator|!=
literal|'-'
condition|)
block|{
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
name|clock_time
operator|->
name|utcoffset
expr_stmt|;
block|}
block|}
comment|/* 			 * gather status flags 			 */
if|if
condition|(
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_ZONE
index|]
operator|.
name|offset
index|]
operator|==
literal|'S'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_DST
expr_stmt|;
if|if
condition|(
name|clock_time
operator|->
name|utcoffset
operator|==
literal|0
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_UTC
expr_stmt|;
comment|/* 			 * no sv's seen - no time& position 			 */
if|if
condition|(
name|f
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_POWERUP
expr_stmt|;
comment|/* 			 * at least one sv seen - time (for last position) 			 */
if|if
condition|(
name|f
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_NOSYNC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|clock_time
operator|->
name|flags
operator|&
name|PARSEB_POWERUP
operator|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_POSITION
expr_stmt|;
comment|/* 			 * oncoming zone switch 			 */
if|if
condition|(
name|f
index|[
literal|3
index|]
operator|==
literal|'!'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_ANNOUNCE
expr_stmt|;
comment|/* 			 * oncoming leap second 			 * 'a' code not confirmed - earth is not 			 * expected to speed up 			 */
if|if
condition|(
name|f
index|[
literal|4
index|]
operator|==
literal|'A'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPADD
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|4
index|]
operator|==
literal|'a'
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPDEL
expr_stmt|;
comment|/* 			 * f[5] == ' ' 			 */
comment|/* 			 * this is the leap second 			 */
if|if
condition|(
operator|(
name|f
index|[
literal|6
index|]
operator|==
literal|'L'
operator|)
operator|||
operator|(
name|clock_time
operator|->
name|second
operator|==
literal|60
operator|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPSECOND
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * gps_input  *  * grep binary data from input stream  */
end_comment

begin_function
specifier|static
name|u_long
name|gps_input
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|unsigned
name|int
name|ch
parameter_list|,
name|timestamp_t
modifier|*
name|tstamp
parameter_list|)
block|{
name|CSUM
name|calc_csum
decl_stmt|;
comment|/* used to compare the incoming csums */
name|GPS_MSG_HDR
name|header
decl_stmt|;
name|struct
name|msg_buf
modifier|*
name|msg_buf
decl_stmt|;
name|msg_buf
operator|=
operator|(
expr|struct
name|msg_buf
operator|*
operator|)
name|parseio
operator|->
name|parse_pdata
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"gps_input(0x%lx, 0x%x, ...)\n"
operator|,
operator|(
name|long
operator|)
name|parseio
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg_buf
condition|)
return|return
name|PARSE_INP_SKIP
return|;
if|if
condition|(
name|msg_buf
operator|->
name|phase
operator|==
name|MBG_NONE
condition|)
block|{
comment|/* not receiving yet */
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|SOH
case|:
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"gps_input: SOH seen\n"
operator|)
argument_list|)
expr_stmt|;
name|msg_buf
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* prepare to receive msg header */
name|msg_buf
operator|->
name|phase
operator|=
name|MBG_HEADER
expr_stmt|;
comment|/* receiving header */
break|break;
case|case
name|STX
case|:
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"gps_input: STX seen\n"
operator|)
argument_list|)
expr_stmt|;
name|msg_buf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|msg_buf
operator|->
name|phase
operator|=
name|MBG_STRING
expr_stmt|;
comment|/* prepare to receive ASCII ETX delimited message */
name|parseio
operator|->
name|parse_index
operator|=
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
break|break;
default|default:
return|return
name|PARSE_INP_SKIP
return|;
comment|/* keep searching */
block|}
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|=
literal|1
expr_stmt|;
comment|/* reset buffer pointer */
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
comment|/* fill in first character */
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|tstamp
expr_stmt|;
comment|/* collect timestamp */
return|return
name|PARSE_INP_SKIP
return|;
block|}
comment|/* SOH/STX has already been received */
comment|/* save incoming character in both buffers if needbe */
if|if
condition|(
operator|(
name|msg_buf
operator|->
name|phase
operator|==
name|MBG_STRING
operator|)
operator|&&
operator|(
name|parseio
operator|->
name|parse_index
operator|<
name|parseio
operator|->
name|parse_dsize
operator|)
condition|)
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
index|[
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|++
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msglen
operator|>
sizeof|sizeof
argument_list|(
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
argument_list|)
condition|)
block|{
name|msg_buf
operator|->
name|phase
operator|=
name|MBG_NONE
expr_stmt|;
comment|/* buffer overflow - discard */
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memcpy
argument_list|(
name|parseio
operator|->
name|parse_ldata
argument_list|,
name|parseio
operator|->
name|parse_data
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|parseio
operator|->
name|parse_index
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_ldsize
operator|=
name|parseio
operator|->
name|parse_index
operator|+
literal|1
expr_stmt|;
return|return
name|PARSE_INP_DATA
return|;
block|}
switch|switch
condition|(
name|msg_buf
operator|->
name|phase
condition|)
block|{
case|case
name|MBG_HEADER
case|:
case|case
name|MBG_DATA
case|:
name|msg_buf
operator|->
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|msg_buf
operator|->
name|len
condition|)
comment|/* transfer not complete */
return|return
name|PARSE_INP_SKIP
return|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"gps_input: %s complete\n"
operator|,
operator|(
name|msg_buf
operator|->
name|phase
operator|==
name|MBG_DATA
operator|)
condition|?
literal|"data"
else|:
literal|"header"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBG_STRING
case|:
if|if
condition|(
operator|(
name|ch
operator|==
name|ETX
operator|)
operator|||
operator|(
name|parseio
operator|->
name|parse_index
operator|>=
name|parseio
operator|->
name|parse_dsize
operator|)
condition|)
block|{
name|msg_buf
operator|->
name|phase
operator|=
name|MBG_NONE
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"gps_input: string complete\n"
operator|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memcpy
argument_list|(
name|parseio
operator|->
name|parse_ldata
argument_list|,
name|parseio
operator|->
name|parse_data
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|parseio
operator|->
name|parse_index
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_ldsize
operator|=
name|parseio
operator|->
name|parse_index
operator|+
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_index
operator|=
literal|0
expr_stmt|;
return|return
name|PARSE_INP_TIME
return|;
block|}
else|else
block|{
return|return
name|PARSE_INP_SKIP
return|;
block|}
block|}
comment|/* cnt == 0, so the header or the whole message is complete */
if|if
condition|(
name|msg_buf
operator|->
name|phase
operator|==
name|MBG_HEADER
condition|)
block|{
comment|/* header complete now */
name|unsigned
name|char
modifier|*
name|datap
init|=
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
operator|+
literal|1
decl_stmt|;
name|get_mbg_header
argument_list|(
operator|&
name|datap
argument_list|,
operator|&
name|header
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"gps_input: header: cmd 0x%x, len %d, dcsum 0x%x, hcsum 0x%x\n"
operator|,
operator|(
name|int
operator|)
name|header
operator|.
name|gps_cmd
operator|,
operator|(
name|int
operator|)
name|header
operator|.
name|gps_len
operator|,
operator|(
name|int
operator|)
name|header
operator|.
name|gps_data_csum
operator|,
operator|(
name|int
operator|)
name|header
operator|.
name|gps_hdr_csum
operator|)
argument_list|)
expr_stmt|;
name|calc_csum
operator|=
name|mbg_csum
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
operator|+
literal|1
argument_list|,
operator|(
name|unsigned
name|short
operator|)
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc_csum
operator|!=
name|header
operator|.
name|gps_hdr_csum
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"gps_input: header checksum mismatch expected 0x%x, got 0x%x\n"
operator|,
operator|(
name|int
operator|)
name|calc_csum
operator|,
operator|(
name|int
operator|)
name|mbg_csum
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
argument_list|,
operator|(
name|unsigned
name|short
operator|)
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|msg_buf
operator|->
name|phase
operator|=
name|MBG_NONE
expr_stmt|;
comment|/* back to hunting mode */
return|return
name|PARSE_INP_DATA
return|;
comment|/* invalid header checksum received - pass up for detection */
block|}
if|if
condition|(
operator|(
name|header
operator|.
name|gps_len
operator|==
literal|0
operator|)
operator|||
comment|/* no data to wait for */
operator|(
name|header
operator|.
name|gps_len
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_msg
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|header
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
comment|/* blows anything we have space for */
block|{
name|msg_buf
operator|->
name|phase
operator|=
name|MBG_NONE
expr_stmt|;
comment|/* back to hunting mode */
return|return
operator|(
name|header
operator|.
name|gps_len
operator|==
literal|0
operator|)
condition|?
name|PARSE_INP_DATA
else|:
name|PARSE_INP_SKIP
return|;
comment|/* message complete/throwaway */
block|}
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"gps_input: expecting %d bytes of data message\n"
operator|,
operator|(
name|int
operator|)
name|header
operator|.
name|gps_len
operator|)
argument_list|)
expr_stmt|;
name|msg_buf
operator|->
name|len
operator|=
name|header
operator|.
name|gps_len
expr_stmt|;
comment|/* save number of bytes to wait for */
name|msg_buf
operator|->
name|phase
operator|=
name|MBG_DATA
expr_stmt|;
comment|/* flag header already complete */
return|return
name|PARSE_INP_SKIP
return|;
block|}
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"gps_input: message data complete\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Header and data have been received. The header checksum has been */
comment|/* checked */
name|msg_buf
operator|->
name|phase
operator|=
name|MBG_NONE
expr_stmt|;
comment|/* back to hunting mode */
return|return
name|PARSE_INP_DATA
return|;
comment|/* message complete, must be evaluated */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_MEINBERG) */
end_comment

begin_decl_stmt
name|int
name|clk_meinberg_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_MEINBERG) */
end_comment

begin_comment
comment|/*  * History:  *  * clk_meinberg.c,v  * Revision 4.8  1999/11/28 09:13:50  kardel  * RECON_4_0_98F  *  * Revision 4.7  1999/02/21 11:09:14  kardel  * cleanup  *  * Revision 4.6  1998/06/14 21:09:36  kardel  * Sun acc cleanup  *  * Revision 4.5  1998/06/13 15:18:54  kardel  * fix mem*() to b*() function macro emulation  *  * Revision 4.4  1998/06/13 12:03:23  kardel  * fix SYSV clock name clash  *  * Revision 4.3  1998/06/12 15:22:28  kardel  * fix prototypes  *  * Revision 4.2  1998/05/24 16:14:42  kardel  * support current Meinberg standard data formats  *  * Revision 4.1  1998/05/24 09:39:52  kardel  * implementation of the new IO handling model  *  * Revision 4.0  1998/04/10 19:45:29  kardel  * Start 4.0 release version numbering  *  * from V3 3.23 - log info deleted 1998/04/11 kardel  *  */
end_comment

end_unit

