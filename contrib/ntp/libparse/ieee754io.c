begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/ntp4-dev/libntp/ieee754io.c,v 4.12 2005/04/16 17:32:10 kardel RELEASE_20050508_A  *  * ieee754io.c,v 4.12 2005/04/16 17:32:10 kardel RELEASE_20050508_A  *  * $Created: Sun Jul 13 09:12:02 1997 $  *  * Copyright (c) 1997-2005 by Frank Kardel<kardel<AT> ntp.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"l_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ieee754io.h"
end_include

begin_function_decl
specifier|static
name|unsigned
name|char
name|get_byte
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|offsets_t
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__not_yet__
end_ifdef

begin_function_decl
specifier|static
name|void
name|put_byte
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|offsets_t
parameter_list|,
name|int
modifier|*
parameter_list|,
name|unsigned
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LIBDEBUG
end_ifdef

begin_include
include|#
directive|include
file|"lib_strbuf.h"
end_include

begin_function
specifier|static
name|char
modifier|*
name|fmt_blong
parameter_list|(
name|unsigned
name|long
name|val
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|i
init|=
name|cnt
decl_stmt|;
name|val
operator|<<=
literal|32
operator|-
name|cnt
expr_stmt|;
name|LIB_GETBUF
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
if|if
condition|(
name|val
operator|&
literal|0x80000000
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
name|val
operator|<<=
literal|1
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fmt_flt
parameter_list|(
name|unsigned
name|int
name|sign
parameter_list|,
name|unsigned
name|long
name|mh
parameter_list|,
name|unsigned
name|long
name|ml
parameter_list|,
name|unsigned
name|long
name|ch
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|LIB_GETBUF
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|LIB_BUFLENGTH
argument_list|,
literal|"%c %s %s %s"
argument_list|,
name|sign
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|fmt_blong
argument_list|(
name|ch
argument_list|,
literal|11
argument_list|)
argument_list|,
name|fmt_blong
argument_list|(
name|mh
argument_list|,
literal|20
argument_list|)
argument_list|,
name|fmt_blong
argument_list|(
name|ml
argument_list|,
literal|32
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fmt_hex
parameter_list|(
name|unsigned
name|char
modifier|*
name|bufp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|hex
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|LIB_GETBUF
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|hex
argument_list|,
sizeof|sizeof
argument_list|(
name|hex
argument_list|)
argument_list|,
literal|"%02x"
argument_list|,
name|bufp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|hex
argument_list|,
name|LIB_BUFLENGTH
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|unsigned
name|char
name|get_byte
parameter_list|(
name|unsigned
name|char
modifier|*
name|bufp
parameter_list|,
name|offsets_t
name|offset
parameter_list|,
name|int
modifier|*
name|fieldindex
parameter_list|)
block|{
name|unsigned
name|char
name|val
decl_stmt|;
name|val
operator|=
operator|*
operator|(
name|bufp
operator|+
name|offset
index|[
operator|*
name|fieldindex
index|]
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBDEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"fetchieee754: getbyte(0x%08x, %d) = 0x%02x\n"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|bufp
argument_list|)
operator|+
name|offset
index|[
operator|*
name|fieldindex
index|]
argument_list|,
operator|*
name|fieldindex
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|fieldindex
operator|)
operator|++
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__not_yet__
end_ifdef

begin_function
specifier|static
name|void
name|put_byte
parameter_list|(
name|unsigned
name|char
modifier|*
name|bufp
parameter_list|,
name|offsets_t
name|offsets
parameter_list|,
name|int
modifier|*
name|fieldindex
parameter_list|,
name|unsigned
name|char
name|val
parameter_list|)
block|{
operator|*
operator|(
name|bufp
operator|+
name|offsets
index|[
operator|*
name|fieldindex
index|]
operator|)
operator|=
name|val
expr_stmt|;
operator|(
operator|*
name|fieldindex
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * make conversions to and from external IEEE754 formats and internal  * NTP FP format.  */
end_comment

begin_function
name|int
name|fetch_ieee754
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|buffpp
parameter_list|,
name|int
name|size
parameter_list|,
name|l_fp
modifier|*
name|lfpp
parameter_list|,
name|offsets_t
name|offsets
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|bufp
init|=
operator|*
name|buffpp
decl_stmt|;
name|unsigned
name|int
name|sign
decl_stmt|;
name|unsigned
name|int
name|bias
decl_stmt|;
name|unsigned
name|int
name|maxexp
decl_stmt|;
name|int
name|mbits
decl_stmt|;
name|u_long
name|mantissa_low
decl_stmt|;
name|u_long
name|mantissa_high
decl_stmt|;
name|u_long
name|characteristic
decl_stmt|;
name|long
name|exponent
decl_stmt|;
ifdef|#
directive|ifdef
name|LIBDEBUG
name|int
name|length
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|char
name|val
decl_stmt|;
name|int
name|fieldindex
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
name|IEEE_DOUBLE
case|:
ifdef|#
directive|ifdef
name|LIBDEBUG
name|length
operator|=
literal|8
expr_stmt|;
endif|#
directive|endif
name|mbits
operator|=
literal|52
expr_stmt|;
name|bias
operator|=
literal|1023
expr_stmt|;
name|maxexp
operator|=
literal|2047
expr_stmt|;
break|break;
case|case
name|IEEE_SINGLE
case|:
ifdef|#
directive|ifdef
name|LIBDEBUG
name|length
operator|=
literal|4
expr_stmt|;
endif|#
directive|endif
name|mbits
operator|=
literal|23
expr_stmt|;
name|bias
operator|=
literal|127
expr_stmt|;
name|maxexp
operator|=
literal|255
expr_stmt|;
break|break;
default|default:
return|return
name|IEEE_BADCALL
return|;
block|}
name|val
operator|=
name|get_byte
argument_list|(
name|bufp
argument_list|,
name|offsets
argument_list|,
operator|&
name|fieldindex
argument_list|)
expr_stmt|;
comment|/* fetch sign byte& first part of characteristic */
name|sign
operator|=
operator|(
name|val
operator|&
literal|0x80
operator|)
operator|!=
literal|0
expr_stmt|;
name|characteristic
operator|=
operator|(
name|val
operator|&
literal|0x7F
operator|)
expr_stmt|;
name|val
operator|=
name|get_byte
argument_list|(
name|bufp
argument_list|,
name|offsets
argument_list|,
operator|&
name|fieldindex
argument_list|)
expr_stmt|;
comment|/* fetch rest of characteristic and start of mantissa */
switch|switch
condition|(
name|size
condition|)
block|{
case|case
name|IEEE_SINGLE
case|:
name|characteristic
operator|<<=
literal|1
expr_stmt|;
name|characteristic
operator||=
operator|(
name|val
operator|&
literal|0x80
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* grab last characteristic bit */
name|mantissa_high
operator|=
literal|0
expr_stmt|;
name|mantissa_low
operator|=
operator|(
name|val
operator|&
literal|0x7F
operator|)
operator|<<
literal|16
expr_stmt|;
name|mantissa_low
operator||=
operator|(
name|u_long
operator|)
name|get_byte
argument_list|(
name|bufp
argument_list|,
name|offsets
argument_list|,
operator|&
name|fieldindex
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|mantissa_low
operator||=
name|get_byte
argument_list|(
name|bufp
argument_list|,
name|offsets
argument_list|,
operator|&
name|fieldindex
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE_DOUBLE
case|:
name|characteristic
operator|<<=
literal|4
expr_stmt|;
name|characteristic
operator||=
operator|(
name|val
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* grab lower characteristic bits */
name|mantissa_high
operator|=
operator|(
name|val
operator|&
literal|0x0F
operator|)
operator|<<
literal|16
expr_stmt|;
name|mantissa_high
operator||=
operator|(
name|u_long
operator|)
name|get_byte
argument_list|(
name|bufp
argument_list|,
name|offsets
argument_list|,
operator|&
name|fieldindex
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|mantissa_high
operator||=
name|get_byte
argument_list|(
name|bufp
argument_list|,
name|offsets
argument_list|,
operator|&
name|fieldindex
argument_list|)
expr_stmt|;
name|mantissa_low
operator|=
operator|(
name|u_long
operator|)
name|get_byte
argument_list|(
name|bufp
argument_list|,
name|offsets
argument_list|,
operator|&
name|fieldindex
argument_list|)
operator|<<
literal|24
expr_stmt|;
name|mantissa_low
operator||=
operator|(
name|u_long
operator|)
name|get_byte
argument_list|(
name|bufp
argument_list|,
name|offsets
argument_list|,
operator|&
name|fieldindex
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|mantissa_low
operator||=
operator|(
name|u_long
operator|)
name|get_byte
argument_list|(
name|bufp
argument_list|,
name|offsets
argument_list|,
operator|&
name|fieldindex
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|mantissa_low
operator||=
name|get_byte
argument_list|(
name|bufp
argument_list|,
name|offsets
argument_list|,
operator|&
name|fieldindex
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|IEEE_BADCALL
return|;
block|}
ifdef|#
directive|ifdef
name|LIBDEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
block|{
name|double
name|d
decl_stmt|;
name|float
name|f
decl_stmt|;
if|if
condition|(
name|size
operator|==
name|IEEE_SINGLE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|&
name|f
operator|)
operator|+
name|i
operator|)
operator|=
operator|*
operator|(
operator|*
name|buffpp
operator|+
name|offsets
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
name|d
operator|=
name|f
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|&
name|d
operator|)
operator|+
name|i
operator|)
operator|=
operator|*
operator|(
operator|*
name|buffpp
operator|+
name|offsets
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"fetchieee754: FP: %s -> %s -> %e(=%s)\n"
argument_list|,
name|fmt_hex
argument_list|(
operator|*
name|buffpp
argument_list|,
name|length
argument_list|)
argument_list|,
name|fmt_flt
argument_list|(
name|sign
argument_list|,
name|mantissa_high
argument_list|,
name|mantissa_low
argument_list|,
name|characteristic
argument_list|)
argument_list|,
name|d
argument_list|,
name|fmt_hex
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|d
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|buffpp
operator|+=
name|fieldindex
expr_stmt|;
comment|/*    * detect funny numbers    */
if|if
condition|(
name|characteristic
operator|==
name|maxexp
condition|)
block|{
comment|/*        * NaN or Infinity        */
if|if
condition|(
name|mantissa_low
operator|||
name|mantissa_high
condition|)
block|{
comment|/* 	   * NaN 	   */
return|return
name|IEEE_NAN
return|;
block|}
else|else
block|{
comment|/* 	   * +Inf or -Inf 	   */
return|return
name|sign
condition|?
name|IEEE_NEGINFINITY
else|:
name|IEEE_POSINFINITY
return|;
block|}
block|}
else|else
block|{
comment|/*        * collect real numbers        */
name|L_CLR
argument_list|(
name|lfpp
argument_list|)
expr_stmt|;
comment|/*        * check for overflows        */
name|exponent
operator|=
name|characteristic
operator|-
name|bias
expr_stmt|;
if|if
condition|(
name|exponent
operator|>
literal|31
condition|)
comment|/* sorry - hardcoded */
block|{
comment|/* 	   * overflow only in respect to NTP-FP representation 	   */
return|return
name|sign
condition|?
name|IEEE_NEGOVERFLOW
else|:
name|IEEE_POSOVERFLOW
return|;
block|}
else|else
block|{
name|int
name|frac_offset
decl_stmt|;
comment|/* where the fraction starts */
name|frac_offset
operator|=
name|mbits
operator|-
name|exponent
expr_stmt|;
if|if
condition|(
name|characteristic
operator|==
literal|0
condition|)
block|{
comment|/* 	       * de-normalized or tiny number - fits only as 0 	       */
return|return
name|IEEE_OK
return|;
block|}
else|else
block|{
comment|/* 	       * adjust for implied 1 	       */
if|if
condition|(
name|mbits
operator|>
literal|31
condition|)
name|mantissa_high
operator||=
literal|1
operator|<<
operator|(
name|mbits
operator|-
literal|32
operator|)
expr_stmt|;
else|else
name|mantissa_low
operator||=
literal|1
operator|<<
name|mbits
expr_stmt|;
comment|/* 	       * take mantissa apart - if only all machine would support 	       * 64 bit operations 8-( 	       */
if|if
condition|(
name|frac_offset
operator|>
name|mbits
condition|)
block|{
name|lfpp
operator|->
name|l_ui
operator|=
literal|0
expr_stmt|;
comment|/* only fractional number */
name|frac_offset
operator|-=
name|mbits
operator|+
literal|1
expr_stmt|;
comment|/* will now contain right shift count - 1*/
if|if
condition|(
name|mbits
operator|>
literal|31
condition|)
block|{
name|lfpp
operator|->
name|l_uf
operator|=
name|mantissa_high
operator|<<
operator|(
literal|63
operator|-
name|mbits
operator|)
expr_stmt|;
name|lfpp
operator|->
name|l_uf
operator||=
name|mantissa_low
operator|>>
operator|(
name|mbits
operator|-
literal|33
operator|)
expr_stmt|;
name|lfpp
operator|->
name|l_uf
operator|>>=
name|frac_offset
expr_stmt|;
block|}
else|else
block|{
name|lfpp
operator|->
name|l_uf
operator|=
name|mantissa_low
operator|>>
name|frac_offset
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|frac_offset
operator|>
literal|32
condition|)
block|{
comment|/* 		       * must split in high word 		       */
name|lfpp
operator|->
name|l_ui
operator|=
name|mantissa_high
operator|>>
operator|(
name|frac_offset
operator|-
literal|32
operator|)
expr_stmt|;
name|lfpp
operator|->
name|l_uf
operator|=
operator|(
name|mantissa_high
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|frac_offset
operator|-
literal|32
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
literal|64
operator|-
name|frac_offset
operator|)
expr_stmt|;
name|lfpp
operator|->
name|l_uf
operator||=
name|mantissa_low
operator|>>
operator|(
name|frac_offset
operator|-
literal|32
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		       * must split in low word 		       */
name|lfpp
operator|->
name|l_ui
operator|=
name|mantissa_high
operator|<<
operator|(
literal|32
operator|-
name|frac_offset
operator|)
expr_stmt|;
name|lfpp
operator|->
name|l_ui
operator||=
operator|(
name|mantissa_low
operator|>>
name|frac_offset
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|-
name|frac_offset
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|lfpp
operator|->
name|l_uf
operator|=
operator|(
name|mantissa_low
operator|&
operator|(
operator|(
literal|1
operator|<<
name|frac_offset
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
literal|32
operator|-
name|frac_offset
operator|)
expr_stmt|;
block|}
block|}
comment|/* 	       * adjust for sign 	       */
if|if
condition|(
name|sign
condition|)
block|{
name|L_NEG
argument_list|(
name|lfpp
argument_list|)
expr_stmt|;
block|}
return|return
name|IEEE_OK
return|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|put_ieee754
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|bufpp
parameter_list|,
name|int
name|size
parameter_list|,
name|l_fp
modifier|*
name|lfpp
parameter_list|,
name|offsets_t
name|offsets
parameter_list|)
block|{
name|l_fp
name|outlfp
decl_stmt|;
ifdef|#
directive|ifdef
name|LIBDEBUG
name|unsigned
name|int
name|sign
decl_stmt|;
name|unsigned
name|int
name|bias
decl_stmt|;
endif|#
directive|endif
comment|/*unsigned int maxexp;*/
name|int
name|mbits
decl_stmt|;
name|int
name|msb
decl_stmt|;
name|u_long
name|mantissa_low
init|=
literal|0
decl_stmt|;
name|u_long
name|mantissa_high
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|LIBDEBUG
name|u_long
name|characteristic
init|=
literal|0
decl_stmt|;
name|long
name|exponent
decl_stmt|;
endif|#
directive|endif
comment|/*int length;*/
name|unsigned
name|long
name|mask
decl_stmt|;
name|outlfp
operator|=
operator|*
name|lfpp
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
name|IEEE_DOUBLE
case|:
comment|/*length = 8;*/
name|mbits
operator|=
literal|52
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBDEBUG
name|bias
operator|=
literal|1023
expr_stmt|;
endif|#
directive|endif
comment|/*maxexp = 2047;*/
break|break;
case|case
name|IEEE_SINGLE
case|:
comment|/*length = 4;*/
name|mbits
operator|=
literal|23
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBDEBUG
name|bias
operator|=
literal|127
expr_stmt|;
endif|#
directive|endif
comment|/*maxexp = 255;*/
break|break;
default|default:
return|return
name|IEEE_BADCALL
return|;
block|}
comment|/*    * find sign    */
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|outlfp
argument_list|)
condition|)
block|{
name|L_NEG
argument_list|(
operator|&
name|outlfp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBDEBUG
name|sign
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LIBDEBUG
name|sign
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|outlfp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LIBDEBUG
name|exponent
operator|=
name|mantissa_high
operator|=
name|mantissa_low
operator|=
literal|0
expr_stmt|;
comment|/* true zero */
endif|#
directive|endif
block|}
else|else
block|{
comment|/*        * find number of significant integer bits        */
name|mask
operator|=
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|outlfp
operator|.
name|l_ui
condition|)
block|{
name|msb
operator|=
literal|63
expr_stmt|;
while|while
condition|(
name|mask
operator|&&
operator|(
operator|(
name|outlfp
operator|.
name|l_ui
operator|&
name|mask
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mask
operator|>>=
literal|1
expr_stmt|;
name|msb
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|msb
operator|=
literal|31
expr_stmt|;
while|while
condition|(
name|mask
operator|&&
operator|(
operator|(
name|outlfp
operator|.
name|l_uf
operator|&
name|mask
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mask
operator|>>=
literal|1
expr_stmt|;
name|msb
operator|--
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|size
condition|)
block|{
case|case
name|IEEE_SINGLE
case|:
name|mantissa_high
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msb
operator|>=
literal|32
condition|)
block|{
name|mantissa_low
operator|=
operator|(
name|outlfp
operator|.
name|l_ui
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|msb
operator|-
literal|32
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|mbits
operator|-
operator|(
name|msb
operator|-
literal|32
operator|)
operator|)
expr_stmt|;
name|mantissa_low
operator||=
name|outlfp
operator|.
name|l_uf
operator|>>
operator|(
name|mbits
operator|-
operator|(
name|msb
operator|-
literal|32
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mantissa_low
operator|=
operator|(
name|outlfp
operator|.
name|l_uf
operator|<<
operator|(
name|mbits
operator|-
name|msb
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|mbits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE_DOUBLE
case|:
if|if
condition|(
name|msb
operator|>=
literal|32
condition|)
block|{
name|mantissa_high
operator|=
operator|(
name|outlfp
operator|.
name|l_ui
operator|<<
operator|(
name|mbits
operator|-
name|msb
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|mbits
operator|-
literal|32
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|mantissa_high
operator||=
name|outlfp
operator|.
name|l_uf
operator|>>
operator|(
literal|32
operator|-
operator|(
name|mbits
operator|-
name|msb
operator|)
operator|)
expr_stmt|;
name|mantissa_low
operator|=
operator|(
name|outlfp
operator|.
name|l_ui
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|msb
operator|-
name|mbits
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
literal|32
operator|-
operator|(
name|msb
operator|-
name|mbits
operator|)
operator|)
expr_stmt|;
name|mantissa_low
operator||=
name|outlfp
operator|.
name|l_uf
operator|>>
operator|(
name|msb
operator|-
name|mbits
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mantissa_high
operator|=
name|outlfp
operator|.
name|l_uf
operator|<<
operator|(
name|mbits
operator|-
literal|32
operator|-
name|msb
operator|)
expr_stmt|;
name|mantissa_low
operator|=
name|outlfp
operator|.
name|l_uf
operator|<<
operator|(
name|mbits
operator|-
literal|32
operator|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LIBDEBUG
name|exponent
operator|=
name|msb
operator|-
literal|32
expr_stmt|;
name|characteristic
operator|=
name|exponent
operator|+
name|bias
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"FP: %s\n"
argument_list|,
name|fmt_flt
argument_list|(
name|sign
argument_list|,
name|mantissa_high
argument_list|,
name|mantissa_low
argument_list|,
name|characteristic
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|IEEE_OK
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|LIBDEBUG
argument_list|)
end_if

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
name|offsets_t
name|native_off
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|}
decl_stmt|;
name|double
name|f
init|=
literal|1.0
decl_stmt|;
name|double
modifier|*
name|f_p
init|=
operator|&
name|f
decl_stmt|;
name|l_fp
name|fp
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|f
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"cannot convert %s to a float\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|printf
argument_list|(
literal|"double: %s %s\n"
argument_list|,
name|fmt_blong
argument_list|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|f
argument_list|,
literal|32
argument_list|)
argument_list|,
name|fmt_blong
argument_list|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|f
operator|)
operator|+
literal|4
operator|)
argument_list|,
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fetch from %f = %d\n"
argument_list|,
name|f
argument_list|,
name|fetch_ieee754
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|f_p
argument_list|,
name|IEEE_DOUBLE
argument_list|,
operator|&
name|fp
argument_list|,
name|native_off
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fp [%s %s] = %s\n"
argument_list|,
name|fmt_blong
argument_list|(
name|fp
operator|.
name|l_ui
argument_list|,
literal|32
argument_list|)
argument_list|,
name|fmt_blong
argument_list|(
name|fp
operator|.
name|l_uf
argument_list|,
literal|32
argument_list|)
argument_list|,
name|mfptoa
argument_list|(
name|fp
operator|.
name|l_ui
argument_list|,
name|fp
operator|.
name|l_uf
argument_list|,
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|f_p
operator|=
operator|&
name|f
expr_stmt|;
name|put_ieee754
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|f_p
argument_list|,
name|IEEE_DOUBLE
argument_list|,
operator|&
name|fp
argument_list|,
name|native_off
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * History:  *  * ieee754io.c,v  * Revision 4.12  2005/04/16 17:32:10  kardel  * update copyright  *  * Revision 4.11  2004/11/14 15:29:41  kardel  * support PPSAPI, upgrade Copyright to Berkeley style  *  * Revision 4.8  1999/02/21 12:17:36  kardel  * 4.91f reconcilation  *  * Revision 4.7  1999/02/21 11:26:03  kardel  * renamed index to fieldindex to avoid index() name clash  *  * Revision 4.6  1998/11/15 20:27:52  kardel  * Release 4.0.73e13 reconcilation  *  * Revision 4.5  1998/08/16 19:01:51  kardel  * debug information only compile for LIBDEBUG case  *  * Revision 4.4  1998/08/09 09:39:28  kardel  * Release 4.0.73e2 reconcilation  *  * Revision 4.3  1998/06/13 11:56:19  kardel  * disabled putbute() for the time being  *  * Revision 4.2  1998/06/12 15:16:58  kardel  * ansi2knr compatibility  *  * Revision 4.1  1998/05/24 07:59:56  kardel  * conditional debug support  *  * Revision 4.0  1998/04/10 19:46:29  kardel  * Start 4.0 release version numbering  *  * Revision 1.1  1998/04/10 19:27:46  kardel  * initial NTP VERSION 4 integration of PARSE with GPS166 binary support  *  * Revision 1.1  1997/10/06 21:05:45  kardel  * new parse structure  *  */
end_comment

end_unit

