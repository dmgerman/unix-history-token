begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/ntp-4/libparse/clk_wharton.c,v 4.1 1999/02/28 15:27:24 kardel RELEASE_19990228_A  *    * clk_wharton.c,v 4.1 1999/02/28 15:27:24 kardel RELEASE_19990228_A  *  * From Philippe De Muyter<phdm@macqel.be>, 1999  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_PARSE
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_WHARTON_400A
argument_list|)
end_if

begin_comment
comment|/*  * Support for WHARTON 400A Series clock + 404.2 serial interface.  *  * Copyright (C) 1999 by Philippe De Muyter<phdm@macqel.be>  *   * This program is distributed in the hope that it will be useful, but WITHOUT  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or  * FITNESS FOR A PARTICULAR PURPOSE.  *   */
end_comment

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ascii.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PARSESTREAM
end_ifndef

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"sys/parsestreams.h"
end_include

begin_decl_stmt
specifier|extern
name|void
name|printf
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * In private e-mail alastair@wharton.co.uk said :  * "If you are going to use the 400A and 404.2 system [for ntp] I recommend  * that you set the 400A to output the message every second.  The start of  * transmission of the first byte of the message is synchronised to the  * second edge."  * The WHARTON 400A Series is able to send date/time serial messages  * in 7 output formats.  We use format 1 here because it is the shortest.  * For use with this driver, the WHARTON 400A Series clock must be set-up  * as follows :  *					Programmable	Selected  *					Option No	Option  *	BST or CET display		3		9 or 11  *	No external controller		7		0  *	Serial Output Format 1		9		1  *	Baud rate 9600 bps		10		96  *	Bit length 8 bits		11		8  *	Parity even			12		E  *  * WHARTON 400A Series output format 1 is as follows :  *   * Timestamp	STXssmmhhDDMMYYSETX  * Pos		0  12345678901234  *		0  00000000011111  *  *	STX	start transmission (ASCII 0x02)  *	ETX	end transmission (ASCII 0x03)  *	ss	Second expressed in reversed decimal (units then tens)  *	mm	Minute expressed in reversed decimal  *	hh	Hour expressed in reversed decimal  *	DD	Day of month expressed in reversed decimal  *	MM	Month expressed in reversed decimal (January is 1)  *	YY	Year (without century) expressed in reversed decimal  *	S	Status byte : 0x30 +  *			bit 0	0 = MSF source		1 = DCF source  *			bit 1	0 = Winter time		1 = Summer time  *			bit 2	0 = not synchronised	1 = synchronised  *			bit 3	0 = no early warning	1 = early warning  *   */
end_comment

begin_comment
comment|/*  * cvt_wharton_400a  *   * convert simple type format  */
end_comment

begin_function
specifier|static
name|u_long
name|cvt_wharton_400a
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|format
modifier|*
name|format
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|,
name|void
modifier|*
name|local
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* The given `size' includes a terminating null-character. */
if|if
condition|(
name|size
operator|!=
literal|16
operator|||
name|buffer
index|[
literal|0
index|]
operator|!=
name|STX
operator|||
name|buffer
index|[
literal|14
index|]
operator|!=
name|ETX
condition|)
return|return
name|CVT_NONE
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|14
condition|;
name|i
operator|+=
literal|1
control|)
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|<
literal|'0'
operator|||
name|buffer
index|[
name|i
index|]
operator|>
literal|'9'
condition|)
return|return
name|CVT_NONE
return|;
name|clock_time
operator|->
name|second
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|buffer
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|clock_time
operator|->
name|minute
operator|=
operator|(
name|buffer
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|buffer
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
name|clock_time
operator|->
name|hour
operator|=
operator|(
name|buffer
index|[
literal|6
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|buffer
index|[
literal|5
index|]
operator|-
literal|'0'
expr_stmt|;
name|clock_time
operator|->
name|day
operator|=
operator|(
name|buffer
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|buffer
index|[
literal|7
index|]
operator|-
literal|'0'
expr_stmt|;
name|clock_time
operator|->
name|month
operator|=
operator|(
name|buffer
index|[
literal|10
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|buffer
index|[
literal|9
index|]
operator|-
literal|'0'
expr_stmt|;
name|clock_time
operator|->
name|year
operator|=
operator|(
name|buffer
index|[
literal|12
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|buffer
index|[
literal|11
index|]
operator|-
literal|'0'
expr_stmt|;
name|clock_time
operator|->
name|usecond
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|13
index|]
operator|&
literal|0x1
condition|)
comment|/* We have CET time */
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
literal|1
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
else|else
comment|/* We have BST time */
name|clock_time
operator|->
name|utcoffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|13
index|]
operator|&
literal|0x2
condition|)
block|{
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_DST
expr_stmt|;
name|clock_time
operator|->
name|utcoffset
operator|+=
operator|-
literal|1
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|buffer
index|[
literal|13
index|]
operator|&
literal|0x4
operator|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_NOSYNC
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|13
index|]
operator|&
literal|0x8
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_ANNOUNCE
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
end_function

begin_comment
comment|/*  * inp_wharton_400a  *  * grep data from input stream  */
end_comment

begin_function
specifier|static
name|u_long
name|inp_wharton_400a
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|unsigned
name|int
name|ch
parameter_list|,
name|timestamp_t
modifier|*
name|tstamp
parameter_list|)
block|{
name|unsigned
name|int
name|rtc
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"inp_wharton_400a(0x%x, 0x%x, ...)\n"
operator|,
operator|(
name|int
operator|)
name|parseio
operator|,
operator|(
name|int
operator|)
name|ch
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|STX
case|:
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"inp_wharton_400a: STX seen\n"
operator|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_index
operator|=
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|tstamp
expr_stmt|;
comment|/* collect timestamp */
return|return
name|PARSE_INP_SKIP
return|;
case|case
name|ETX
case|:
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"inp_wharton_400a: ETX seen\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtc
operator|=
name|parse_addchar
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|)
operator|)
operator|==
name|PARSE_INP_SKIP
condition|)
return|return
name|parse_end
argument_list|(
name|parseio
argument_list|)
return|;
else|else
return|return
name|rtc
return|;
default|default:
return|return
name|parse_addchar
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|)
return|;
block|}
block|}
end_function

begin_decl_stmt
name|clockformat_t
name|clock_wharton_400a
init|=
block|{
name|inp_wharton_400a
block|,
comment|/* input handling function */
name|cvt_wharton_400a
block|,
comment|/* conversion function */
literal|0
block|,
comment|/* no PPS monitoring */
literal|0
block|,
comment|/* conversion configuration */
literal|"WHARTON 400A Series clock Output Format 1"
block|,
comment|/* String format name */
literal|15
block|,
comment|/* string buffer */
literal|0
comment|/* no private data (complete pakets) */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_WHARTON_400A) */
end_comment

begin_decl_stmt
name|int
name|clk_wharton_400a_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_WHARTON_400A) */
end_comment

begin_comment
comment|/*  * clk_wharton.c,v  * Revision 4.1  1999/02/28 15:27:24  kardel  * wharton clock integration  *  */
end_comment

end_unit

