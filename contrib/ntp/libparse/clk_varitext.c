begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_PARSE
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_VARITEXT
argument_list|)
end_if

begin_comment
comment|/*  * clk_varitext.c,v 1.0 1997/01/19 A.McConnell  *   * Supports Varitext's Radio Clock  *   * Used the Meinberg/Computime clock as a template for Varitext Radio Clock  *  * Copyright (C) 1992-1996 by Frank Kardel  * Friedrich-Alexander Universitt Erlangen-Nrnberg, Germany  *   * This program is distributed in the hope that it will be useful, but WITHOUT  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or  * FITNESS FOR A PARTICULAR PURPOSE.  *   */
end_comment

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PARSESTREAM
end_ifndef

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"sys/parsestreams.h"
end_include

begin_decl_stmt
specifier|extern
name|void
name|printf
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|VT_INITIALISED
init|=
literal|0x01
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|VT_SYNCHRONISED
init|=
literal|0x02
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|VT_ALARM_STATE
init|=
literal|0x04
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|VT_BST
init|=
literal|0x08
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|VT_SEASON_CHANGE
init|=
literal|0x10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|VT_LAST_TELEGRAM_OK
init|=
literal|0x20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The Varitext receiver sends a datagram in the following format every minute  *   * Timestamp	T:YY:MM:MD:WD:HH:MM:SSCRLFSTXXX   * Pos          0123456789012345678901 2 3 4567  *              0000000000111111111122 2 2 2222  * Parse        T:  :  :  :  :  :  :  \r\n      *   * T	Startcharacter "T" specifies start of the timestamp   * YY	Year MM	Month 1-12   * MD	Day of the month   * WD	Day of week   * HH	Hour   * MM   Minute   * SS   Second  * CR   Carriage return   * LF   Linefeed  * ST	Status character  *	Bit 0 - Set= Initialised; Reset=Time Invalid (DO NOT USE)  *	Bit 1 - Set= Synchronised; Reset= Unsynchronised   * 	Bit 2 - Set= Alarm state; Reset= No alarm  * 	Bit 3 - Set= BST; Reset= GMT  * 	Bit 4 - Set= Seasonal change in approx hour; Reset= No seasonal change expected  *	Bit 5 - Set= Last MSF telegram was OK; Reset= Last telegram was in error;  * 	Bit 6 - Always set  *	Bit 7 - Unused  * XXX	Checksum calculated using Fletcher's method (ignored for now).   */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|format
name|varitext_fmt
init|=
block|{
block|{
block|{
literal|8
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* day, month, year */
block|{
literal|14
block|,
literal|2
block|}
block|,
block|{
literal|17
block|,
literal|2
block|}
block|,
block|{
literal|20
block|,
literal|2
block|}
block|,
comment|/* hour, minute, second */
block|{
literal|11
block|,
literal|2
block|}
block|,
block|{
literal|24
block|,
literal|1
block|}
comment|/* dayofweek, status */
block|}
block|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"T:  :  :  :  :  :  :  \r\n    "
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|cvt_varitext
name|P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|format
operator|*
operator|,
name|clocktime_t
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|inp_varitext
name|P
argument_list|(
operator|(
name|parse_t
operator|*
operator|,
name|unsigned
name|int
operator|,
name|timestamp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|varitext
block|{
name|unsigned
name|char
name|start_found
decl_stmt|;
name|unsigned
name|char
name|end_found
decl_stmt|;
name|unsigned
name|char
name|end_count
decl_stmt|;
name|unsigned
name|char
name|previous_ch
decl_stmt|;
name|timestamp_t
name|tstamp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|clockformat_t
name|clock_varitext
init|=
block|{
name|inp_varitext
block|,
comment|/* Because of the strange format we need to parse it ourselves */
name|cvt_varitext
block|,
comment|/* Varitext conversion */
literal|0
block|,
comment|/* no PPS monitoring */
operator|(
name|void
operator|*
operator|)
operator|&
name|varitext_fmt
block|,
comment|/* conversion configuration */
literal|"Varitext Radio Clock"
block|,
comment|/* Varitext Radio Clock */
literal|30
block|,
comment|/* string buffer */
sizeof|sizeof
argument_list|(
expr|struct
name|varitext
argument_list|)
block|,
comment|/* Private data size required to hold current parse state */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * cvt_varitext  *   * convert simple type format  */
end_comment

begin_function
specifier|static
name|u_long
name|cvt_varitext
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|format
modifier|*
name|format
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|,
name|void
modifier|*
name|local
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Strok
argument_list|(
name|buffer
argument_list|,
name|format
operator|->
name|fixed_string
argument_list|)
condition|)
block|{
return|return
name|CVT_NONE
return|;
block|}
else|else
block|{
if|if
condition|(
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_DAY
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|day
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_DAY
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_MONTH
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|month
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_MONTH
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_YEAR
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|year
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_YEAR
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_HOUR
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|hour
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_HOUR
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_MIN
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|minute
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_MIN
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_SEC
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock_time
operator|->
name|second
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_SEC
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
else|else
block|{
name|u_char
modifier|*
name|f
init|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_FLAGS
index|]
operator|.
name|offset
index|]
decl_stmt|;
name|clock_time
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|utcoffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|f
operator|)
operator|&
name|VT_BST
operator|)
condition|)
comment|/* BST flag is set so set to indicate daylight saving time is active and utc offset */
block|{
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
literal|1
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_DST
expr_stmt|;
block|}
comment|/* 	 if (!((*f)& VT_INITIALISED))  Clock not initialised  	 clock_time->flags |= PARSEB_POWERUP; 	  	 if (!((*f)& VT_SYNCHRONISED))   Clock not synchronised  	 clock_time->flags |= PARSEB_NOSYNC; 	  	 if (((*f)& VT_SEASON_CHANGE))  Seasonal change expected in the next hour  	 clock_time->flags |= PARSEB_ANNOUNCE; 	 */
return|return
name|CVT_OK
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|u_long
name|inp_varitext
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|unsigned
name|int
name|ch
parameter_list|,
name|timestamp_t
modifier|*
name|tstamp
parameter_list|)
block|{
name|struct
name|varitext
modifier|*
name|t
init|=
operator|(
expr|struct
name|varitext
operator|*
operator|)
name|parseio
operator|->
name|parse_pdata
decl_stmt|;
name|int
name|rtc
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"inp_varitext(0x%lx, 0x%x, ...)\n"
operator|,
operator|(
name|long
operator|)
name|parseio
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|PARSE_INP_SKIP
return|;
comment|/* local data not allocated - sigh! */
if|if
condition|(
name|ch
operator|==
literal|'T'
condition|)
name|t
operator|->
name|tstamp
operator|=
operator|*
name|tstamp
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|previous_ch
operator|==
literal|'T'
operator|)
operator|&&
operator|(
name|ch
operator|==
literal|':'
operator|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"inp_varitext: START seen\n"
operator|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
literal|0
index|]
operator|=
literal|'T'
expr_stmt|;
name|parseio
operator|->
name|parse_index
operator|=
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
name|t
operator|->
name|tstamp
expr_stmt|;
comment|/* Time stamp at packet start */
name|t
operator|->
name|start_found
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|end_found
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|end_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|start_found
condition|)
block|{
if|if
condition|(
operator|(
name|rtc
operator|=
name|parse_addchar
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|)
operator|)
operator|!=
name|PARSE_INP_SKIP
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"inp_varitext: ABORTED due to too many characters\n"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|varitext
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rtc
return|;
block|}
if|if
condition|(
name|t
operator|->
name|end_found
condition|)
block|{
if|if
condition|(
operator|++
operator|(
name|t
operator|->
name|end_count
operator|)
operator|==
literal|4
condition|)
comment|/* Finally found the end of the message */
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"inp_varitext: END seen\n"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|varitext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtc
operator|=
name|parse_addchar
argument_list|(
name|parseio
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|PARSE_INP_SKIP
condition|)
return|return
name|parse_end
argument_list|(
name|parseio
argument_list|)
return|;
else|else
return|return
name|rtc
return|;
block|}
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|previous_ch
operator|==
literal|'\r'
operator|)
operator|&&
operator|(
name|ch
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|t
operator|->
name|end_found
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|t
operator|->
name|previous_ch
operator|=
name|ch
expr_stmt|;
return|return
name|PARSE_INP_SKIP
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_VARITEXT) */
end_comment

begin_decl_stmt
name|int
name|clk_varitext_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_VARITEXT) */
end_comment

begin_comment
comment|/*  * Revision 1.0  1997/06/02 13:16:30  McConnell  * File created  *  */
end_comment

end_unit

