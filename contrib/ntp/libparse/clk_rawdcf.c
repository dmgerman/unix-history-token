begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/ntp-4/libparse/clk_rawdcf.c,v 4.6 1998/06/14 21:09:37 kardel RELEASE_19990228_A  *    * clk_rawdcf.c,v 4.6 1998/06/14 21:09:37 kardel RELEASE_19990228_A  *  * Raw DCF77 pulse clock support  *  * Copyright (C) 1992-1998 by Frank Kardel  * Friedrich-Alexander Universität Erlangen-Nürnberg, Germany  *                                      * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_PARSE
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_RAWDCF
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PARSESTREAM
end_ifdef

begin_include
include|#
directive|include
file|<sys/parsestreams.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PARSEKERNEL
end_ifndef

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * DCF77 raw time code  *  * From "Zur Zeit", Physikalisch-Technische Bundesanstalt (PTB), Braunschweig  * und Berlin, Maerz 1989  *  * Timecode transmission:  * AM:  *	time marks are send every second except for the second before the  *	next minute mark  *	time marks consist of a reduction of transmitter power to 25%  *	of the nominal level  *	the falling edge is the time indication (on time)  *	time marks of a 100ms duration constitute a logical 0  *	time marks of a 200ms duration constitute a logical 1  * FM:  *	see the spec. (basically a (non-)inverted psuedo random phase shift)  *  * Encoding:  * Second	Contents  * 0  - 10	AM: free, FM: 0  * 11 - 14	free  * 15		R     - alternate antenna  * 16		A1    - expect zone change (1 hour before)  * 17 - 18	Z1,Z2 - time zone  *		 0  0 illegal  *		 0  1 MEZ  (MET)  *		 1  0 MESZ (MED, MET DST)  *		 1  1 illegal  * 19		A2    - expect leap insertion/deletion (1 hour before)  * 20		S     - start of time code (1)  * 21 - 24	M1    - BCD (lsb first) Minutes  * 25 - 27	M10   - BCD (lsb first) 10 Minutes  * 28		P1    - Minute Parity (even)  * 29 - 32	H1    - BCD (lsb first) Hours  * 33 - 34      H10   - BCD (lsb first) 10 Hours  * 35		P2    - Hour Parity (even)  * 36 - 39	D1    - BCD (lsb first) Days  * 40 - 41	D10   - BCD (lsb first) 10 Days  * 42 - 44	DW    - BCD (lsb first) day of week (1: Monday -> 7: Sunday)  * 45 - 49	MO    - BCD (lsb first) Month  * 50           MO0   - 10 Months  * 51 - 53	Y1    - BCD (lsb first) Years  * 54 - 57	Y10   - BCD (lsb first) 10 Years  * 58 		P3    - Date Parity (even)  * 59		      - usually missing (minute indication), except for leap insertion  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|pps_rawdcf
name|P
argument_list|(
operator|(
name|parse_t
operator|*
operator|,
name|int
operator|,
name|timestamp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|cvt_rawdcf
name|P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|format
operator|*
operator|,
name|clocktime_t
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|inp_rawdcf
name|P
argument_list|(
operator|(
name|parse_t
operator|*
operator|,
name|unsigned
name|int
operator|,
name|timestamp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|clockformat_t
name|clock_rawdcf
init|=
block|{
name|inp_rawdcf
block|,
comment|/* DCF77 input handling */
name|cvt_rawdcf
block|,
comment|/* raw dcf input conversion */
name|pps_rawdcf
block|,
comment|/* examining PPS information */
literal|0
block|,
comment|/* no private configuration data */
literal|"RAW DCF77 Timecode"
block|,
comment|/* direct decoding / time synthesis */
literal|61
block|,
comment|/* bit buffer */
literal|0
comment|/* no private data (currently in input buffer) */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|dcfparam
block|{
name|unsigned
name|char
name|onebits
index|[
literal|60
index|]
decl_stmt|;
name|unsigned
name|char
name|zerobits
index|[
literal|60
index|]
decl_stmt|;
block|}
name|dcfparameter
init|=
block|{
literal|"###############RADMLS1248124P124812P1248121241248112481248P"
block|,
comment|/* 'ONE' representation */
literal|"--------------------s-------p------p----------------------p"
comment|/* 'ZERO' representation */
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|rawdcfcode
block|{
name|char
name|offset
decl_stmt|;
comment|/* start bit */
block|}
name|rawdcfcode
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|15
block|}
block|,
block|{
literal|16
block|}
block|,
block|{
literal|17
block|}
block|,
block|{
literal|19
block|}
block|,
block|{
literal|20
block|}
block|,
block|{
literal|21
block|}
block|,
block|{
literal|25
block|}
block|,
block|{
literal|28
block|}
block|,
block|{
literal|29
block|}
block|,
block|{
literal|33
block|}
block|,
block|{
literal|35
block|}
block|,
block|{
literal|36
block|}
block|,
block|{
literal|40
block|}
block|,
block|{
literal|42
block|}
block|,
block|{
literal|45
block|}
block|,
block|{
literal|49
block|}
block|,
block|{
literal|50
block|}
block|,
block|{
literal|54
block|}
block|,
block|{
literal|58
block|}
block|,
block|{
literal|59
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DCF_M
value|0
end_define

begin_define
define|#
directive|define
name|DCF_R
value|1
end_define

begin_define
define|#
directive|define
name|DCF_A1
value|2
end_define

begin_define
define|#
directive|define
name|DCF_Z
value|3
end_define

begin_define
define|#
directive|define
name|DCF_A2
value|4
end_define

begin_define
define|#
directive|define
name|DCF_S
value|5
end_define

begin_define
define|#
directive|define
name|DCF_M1
value|6
end_define

begin_define
define|#
directive|define
name|DCF_M10
value|7
end_define

begin_define
define|#
directive|define
name|DCF_P1
value|8
end_define

begin_define
define|#
directive|define
name|DCF_H1
value|9
end_define

begin_define
define|#
directive|define
name|DCF_H10
value|10
end_define

begin_define
define|#
directive|define
name|DCF_P2
value|11
end_define

begin_define
define|#
directive|define
name|DCF_D1
value|12
end_define

begin_define
define|#
directive|define
name|DCF_D10
value|13
end_define

begin_define
define|#
directive|define
name|DCF_DW
value|14
end_define

begin_define
define|#
directive|define
name|DCF_MO
value|15
end_define

begin_define
define|#
directive|define
name|DCF_MO0
value|16
end_define

begin_define
define|#
directive|define
name|DCF_Y1
value|17
end_define

begin_define
define|#
directive|define
name|DCF_Y10
value|18
end_define

begin_define
define|#
directive|define
name|DCF_P3
value|19
end_define

begin_struct
specifier|static
struct|struct
name|partab
block|{
name|char
name|offset
decl_stmt|;
comment|/* start bit of parity field */
block|}
name|partab
index|[]
init|=
block|{
block|{
literal|21
block|}
block|,
block|{
literal|29
block|}
block|,
block|{
literal|36
block|}
block|,
block|{
literal|59
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DCF_P_P1
value|0
end_define

begin_define
define|#
directive|define
name|DCF_P_P2
value|1
end_define

begin_define
define|#
directive|define
name|DCF_P_P3
value|2
end_define

begin_define
define|#
directive|define
name|DCF_Z_MET
value|0x2
end_define

begin_define
define|#
directive|define
name|DCF_Z_MED
value|0x1
end_define

begin_function
specifier|static
name|u_long
name|ext_bf
parameter_list|(
specifier|register
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
specifier|register
name|int
name|idx
parameter_list|,
specifier|register
name|unsigned
name|char
modifier|*
name|zero
parameter_list|)
block|{
specifier|register
name|u_long
name|sum
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
name|first
operator|=
name|rawdcfcode
index|[
name|idx
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rawdcfcode
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|offset
operator|-
literal|1
init|;
name|i
operator|>=
name|first
condition|;
name|i
operator|--
control|)
block|{
name|sum
operator|<<=
literal|1
expr_stmt|;
name|sum
operator||=
operator|(
name|buf
index|[
name|i
index|]
operator|!=
name|zero
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|pcheck
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|idx
parameter_list|,
name|unsigned
name|char
modifier|*
name|zero
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|last
decl_stmt|;
name|unsigned
name|psum
init|=
literal|1
decl_stmt|;
name|last
operator|=
name|partab
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|partab
index|[
name|idx
index|]
operator|.
name|offset
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
name|psum
operator|^=
operator|(
name|buf
index|[
name|i
index|]
operator|!=
name|zero
index|[
name|i
index|]
operator|)
expr_stmt|;
return|return
name|psum
return|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|convert_rawdcf
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|dcfparam
modifier|*
name|dcfprm
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
init|=
name|buffer
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|b
init|=
name|dcfprm
operator|->
name|onebits
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|c
init|=
name|dcfprm
operator|->
name|zerobits
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: \"%s\"\n"
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|57
condition|)
block|{
ifndef|#
directive|ifndef
name|PARSEKERNEL
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: convert_rawdcf: INCOMPLETE DATA - time code only has %d bits\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_NONE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|58
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|!=
operator|*
name|b
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
operator|*
name|c
operator|)
condition|)
block|{
comment|/* 			 * we only have two types of bytes (ones and zeros) 			 */
ifndef|#
directive|ifndef
name|PARSEKERNEL
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: convert_rawdcf: BAD DATA - no conversion for \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_NONE
return|;
block|}
name|b
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
comment|/* 	 * check Start and Parity bits 	 */
if|if
condition|(
operator|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_S
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P2
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P3
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
condition|)
block|{
comment|/* 		 * buffer OK 		 */
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: parity check passed\n"
operator|)
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|flags
operator|=
name|PARSEB_S_ANTENNA
operator||
name|PARSEB_S_LEAP
expr_stmt|;
name|clock_time
operator|->
name|utctime
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|usecond
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|second
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|minute
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_M10
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|minute
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|minute
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_M1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|hour
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_H10
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|hour
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|hour
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_H1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|day
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_D10
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|day
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|day
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_D1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|month
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_MO0
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|month
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|month
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_MO
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|year
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Y10
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|year
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|year
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Y1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Z
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
condition|)
block|{
case|case
name|DCF_Z_MET
case|:
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
literal|1
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
break|break;
case|case
name|DCF_Z_MED
case|:
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_DST
expr_stmt|;
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
literal|2
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
break|break;
default|default:
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: BAD TIME ZONE\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_A1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_ANNOUNCE
expr_stmt|;
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_A2
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPADD
expr_stmt|;
comment|/* default: DCF77 data format deficiency */
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_R
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_ALTERNATE
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: TIME CODE OK: %d:%d, %d.%d.%d, flags 0x%lx\n"
operator|,
operator|(
name|int
operator|)
name|clock_time
operator|->
name|hour
operator|,
operator|(
name|int
operator|)
name|clock_time
operator|->
name|minute
operator|,
operator|(
name|int
operator|)
name|clock_time
operator|->
name|day
operator|,
operator|(
name|int
operator|)
name|clock_time
operator|->
name|month
operator|,
operator|(
name|int
operator|)
name|clock_time
operator|->
name|year
operator|,
operator|(
name|u_long
operator|)
name|clock_time
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
else|else
block|{
comment|/* 		 * bad format - not for us 		 */
ifndef|#
directive|ifndef
name|PARSEKERNEL
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: convert_rawdcf: parity check FAILED for \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * raw dcf input routine - needs to fix up 50 baud  * characters for 1/0 decision  */
end_comment

begin_function
specifier|static
name|u_long
name|cvt_rawdcf
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|format
modifier|*
name|param
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|,
name|void
modifier|*
name|local
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|e
init|=
name|s
operator|+
name|size
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|b
init|=
name|dcfparameter
operator|.
name|onebits
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|c
init|=
name|dcfparameter
operator|.
name|zerobits
decl_stmt|;
specifier|register
name|unsigned
name|rtc
init|=
name|CVT_NONE
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
name|lowmax
decl_stmt|,
name|highmax
decl_stmt|,
name|cutoff
decl_stmt|,
name|span
decl_stmt|;
define|#
directive|define
name|BITS
value|9
name|unsigned
name|char
name|histbuf
index|[
name|BITS
index|]
decl_stmt|;
comment|/* 	 * the input buffer contains characters with runs of consecutive 	 * bits set. These set bits are an indication of the DCF77 pulse 	 * length. We assume that we receive the pulse at 50 Baud. Thus 	 * a 100ms pulse would generate a 4 bit train (20ms per bit and 	 * start bit) 	 * a 200ms pulse would create all zeroes (and probably a frame error) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BITS
condition|;
name|i
operator|++
control|)
block|{
name|histbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|cutoff
operator|=
literal|0
expr_stmt|;
name|lowmax
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
specifier|register
name|unsigned
name|int
name|ch
init|=
operator|*
name|s
operator|^
literal|0xFF
decl_stmt|;
comment|/* 		 * these lines are left as an excercise to the reader 8-) 		 */
if|if
condition|(
operator|!
operator|(
operator|(
name|ch
operator|+
literal|1
operator|)
operator|&
name|ch
operator|)
operator|||
operator|!
operator|*
name|s
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|i
expr_stmt|;
name|histbuf
index|[
name|i
index|]
operator|++
expr_stmt|;
name|cutoff
operator|+=
name|i
expr_stmt|;
name|lowmax
operator|++
expr_stmt|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: character check for 0x%x@%d FAILED\n"
operator|,
operator|*
name|s
operator|,
call|(
name|int
call|)
argument_list|(
name|s
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0
expr_stmt|;
name|rtc
operator|=
name|CVT_FAIL
operator||
name|CVT_BADFMT
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lowmax
condition|)
block|{
name|cutoff
operator|/=
name|lowmax
expr_stmt|;
block|}
else|else
block|{
name|cutoff
operator|=
literal|4
expr_stmt|;
comment|/* doesn't really matter - it'll fail anyway, but gives error output */
block|}
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: average bit count: %d\n"
operator|,
name|cutoff
operator|)
argument_list|)
expr_stmt|;
name|lowmax
operator|=
literal|0
expr_stmt|;
name|highmax
operator|=
literal|0
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: histogram:"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cutoff
condition|;
name|i
operator|++
control|)
block|{
name|lowmax
operator|+=
name|histbuf
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|highmax
operator|+=
name|histbuf
index|[
name|i
index|]
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|" %d"
operator|,
name|histbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"<M>"
operator|)
argument_list|)
expr_stmt|;
name|lowmax
operator|+=
name|highmax
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|highmax
condition|)
block|{
name|lowmax
operator|/=
name|highmax
expr_stmt|;
block|}
else|else
block|{
name|lowmax
operator|=
literal|0
expr_stmt|;
block|}
name|highmax
operator|=
literal|0
expr_stmt|;
name|cutoff
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|BITS
condition|;
name|i
operator|++
control|)
block|{
name|highmax
operator|+=
name|histbuf
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|cutoff
operator|+=
name|histbuf
index|[
name|i
index|]
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|" %d"
operator|,
name|histbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cutoff
condition|)
block|{
name|highmax
operator|/=
name|cutoff
expr_stmt|;
block|}
else|else
block|{
name|highmax
operator|=
name|BITS
operator|-
literal|1
expr_stmt|;
block|}
name|span
operator|=
name|cutoff
operator|=
name|lowmax
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lowmax
init|;
name|i
operator|<=
name|highmax
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|histbuf
index|[
name|cutoff
index|]
operator|>
name|histbuf
index|[
name|i
index|]
condition|)
block|{
name|cutoff
operator|=
name|i
expr_stmt|;
name|span
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|histbuf
index|[
name|cutoff
index|]
operator|==
name|histbuf
index|[
name|i
index|]
condition|)
block|{
name|span
operator|=
name|i
expr_stmt|;
block|}
block|}
name|cutoff
operator|=
operator|(
name|cutoff
operator|+
name|span
operator|)
operator|/
literal|2
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: lower maximum %d, higher maximum %d, cutoff %d\n"
operator|,
name|lowmax
operator|,
name|highmax
operator|,
name|cutoff
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|<
name|e
operator|)
operator|&&
operator|*
name|c
operator|&&
operator|*
name|b
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0
condition|)
block|{
operator|*
name|s
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|=
operator|(
operator|*
name|s
operator|>=
name|cutoff
operator|)
condition|?
operator|*
name|b
else|:
operator|*
name|c
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|rtc
operator|==
name|CVT_NONE
operator|)
condition|?
name|convert_rawdcf
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
operator|&
name|dcfparameter
argument_list|,
name|clock_time
argument_list|)
else|:
name|rtc
return|;
block|}
end_function

begin_comment
comment|/*  * pps_rawdcf  *  * currently a very stupid version - should be extended to decode  * also ones and zeros (which is easy)  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|u_long
name|pps_rawdcf
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|,
specifier|register
name|int
name|status
parameter_list|,
specifier|register
name|timestamp_t
modifier|*
name|ptime
parameter_list|)
block|{
if|if
condition|(
operator|!
name|status
condition|)
comment|/* negative edge for simpler wiring (Rx->DCD) */
block|{
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_ptime
operator|=
operator|*
name|ptime
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator||=
name|PARSEB_PPS
operator||
name|PARSEB_S_PPS
expr_stmt|;
block|}
return|return
name|CVT_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|snt_rawdcf
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|,
specifier|register
name|timestamp_t
modifier|*
name|ptime
parameter_list|)
block|{
if|if
condition|(
operator|(
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|==
name|CVT_OK
condition|)
block|{
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|ptime
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_sec
operator|++
expr_stmt|;
else|#
directive|else
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_ui
operator|++
expr_stmt|;
endif|#
directive|endif
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: snt_rawdcf: time stamp synthesized offset %d seconds\n"
operator|,
name|parseio
operator|->
name|parse_index
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|updatetimeinfo
argument_list|(
name|parseio
argument_list|,
name|parseio
operator|->
name|parse_lstate
argument_list|)
return|;
block|}
return|return
name|CVT_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * inp_rawdcf  *  * grep DCF77 data from input stream  */
end_comment

begin_function
specifier|static
name|u_long
name|inp_rawdcf
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|unsigned
name|int
name|ch
parameter_list|,
name|timestamp_t
modifier|*
name|tstamp
parameter_list|)
block|{
specifier|static
name|struct
name|timeval
name|timeout
init|=
block|{
literal|1
block|,
literal|500000
block|}
decl_stmt|;
comment|/* 1.5 secongs denote second #60 */
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"inp_rawdcf(0x%x, 0x%x, ...)\n"
operator|,
operator|(
name|int
operator|)
name|parseio
operator|,
operator|(
name|int
operator|)
name|ch
operator|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|tstamp
expr_stmt|;
comment|/* collect timestamp */
if|if
condition|(
name|parse_timedout
argument_list|(
name|parseio
argument_list|,
name|tstamp
argument_list|,
operator|&
name|timeout
argument_list|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"inp_rawdcf: time out seen\n"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parse_end
argument_list|(
name|parseio
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parse_addchar
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
name|PARSE_INP_TIME
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|rtc
decl_stmt|;
name|rtc
operator|=
name|parse_addchar
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtc
operator|==
name|PARSE_INP_SKIP
condition|)
block|{
if|if
condition|(
name|snt_rawdcf
argument_list|(
name|parseio
argument_list|,
name|tstamp
argument_list|)
operator|==
name|CVT_OK
condition|)
return|return
name|PARSE_INP_SYNTH
return|;
block|}
return|return
name|rtc
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_RAWDCF) */
end_comment

begin_decl_stmt
name|int
name|clk_rawdcf_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_RAWDCF) */
end_comment

begin_comment
comment|/*  * History:  *  * clk_rawdcf.c,v  * Revision 4.6  1998/06/14 21:09:37  kardel  * Sun acc cleanup  *  * Revision 4.5  1998/06/13 12:04:16  kardel  * fix SYSV clock name clash  *  * Revision 4.4  1998/06/12 15:22:28  kardel  * fix prototypes  *  * Revision 4.3  1998/06/06 18:33:36  kardel  * simplified condidional compile expression  *  * Revision 4.2  1998/05/24 11:04:18  kardel  * triggering PPS on negative edge for simpler wiring (Rx->DCD)  *  * Revision 4.1  1998/05/24 09:39:53  kardel  * implementation of the new IO handling model  *  * Revision 4.0  1998/04/10 19:45:30  kardel  * Start 4.0 release version numbering  *  * from V3 3.24 log info deleted 1998/04/11 kardel  *  */
end_comment

end_unit

