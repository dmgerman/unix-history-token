begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/REPOSITORY/ntp4-dev/libparse/clk_rawdcf.c,v 4.18 2006/06/22 18:40:01 kardel RELEASE_20060622_A  *  * clk_rawdcf.c,v 4.18 2006/06/22 18:40:01 kardel RELEASE_20060622_A  *  * Raw DCF77 pulse clock support  *  * Copyright (c) 1995-2015 by Frank Kardel<kardel<AT> ntp.org>  * Copyright (c) 1989-1994 by Frank Kardel, Friedrich-Alexander Universitaet Erlangen-Nuernberg, Germany  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_PARSE
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_RAWDCF
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"timevalops.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PARSESTREAM
end_ifdef

begin_include
include|#
directive|include
file|<sys/parsestreams.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PARSEKERNEL
end_ifndef

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * DCF77 raw time code  *  * From "Zur Zeit", Physikalisch-Technische Bundesanstalt (PTB), Braunschweig  * und Berlin, Maerz 1989  *  * Timecode transmission:  * AM:  *	time marks are send every second except for the second before the  *	next minute mark  *	time marks consist of a reduction of transmitter power to 25%  *	of the nominal level  *	the falling edge is the time indication (on time)  *	time marks of a 100ms duration constitute a logical 0  *	time marks of a 200ms duration constitute a logical 1  * FM:  *	see the spec. (basically a (non-)inverted psuedo random phase shift)  *  * Encoding:  * Second	Contents  * 0  - 10	AM: free, FM: 0  * 11 - 14	free  * 15		R     - "call bit" used to signalize irregularities in the control facilities  *		        (until 2003 indicated transmission via alternate antenna)  * 16		A1    - expect zone change (1 hour before)  * 17 - 18	Z1,Z2 - time zone  *		 0  0 illegal  *		 0  1 MEZ  (MET)  *		 1  0 MESZ (MED, MET DST)  *		 1  1 illegal  * 19		A2    - expect leap insertion/deletion (1 hour before)  * 20		S     - start of time code (1)  * 21 - 24	M1    - BCD (lsb first) Minutes  * 25 - 27	M10   - BCD (lsb first) 10 Minutes  * 28		P1    - Minute Parity (even)  * 29 - 32	H1    - BCD (lsb first) Hours  * 33 - 34      H10   - BCD (lsb first) 10 Hours  * 35		P2    - Hour Parity (even)  * 36 - 39	D1    - BCD (lsb first) Days  * 40 - 41	D10   - BCD (lsb first) 10 Days  * 42 - 44	DW    - BCD (lsb first) day of week (1: Monday -> 7: Sunday)  * 45 - 49	MO    - BCD (lsb first) Month  * 50           MO0   - 10 Months  * 51 - 53	Y1    - BCD (lsb first) Years  * 54 - 57	Y10   - BCD (lsb first) 10 Years  * 58 		P3    - Date Parity (even)  * 59		      - usually missing (minute indication), except for leap insertion  */
end_comment

begin_decl_stmt
specifier|static
name|parse_pps_fnc_t
name|pps_rawdcf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|parse_cvt_fnc_t
name|cvt_rawdcf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|parse_inp_fnc_t
name|inp_rawdcf
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|last_tcode
block|{
name|time_t
name|tcode
decl_stmt|;
comment|/* last converted time code */
name|timestamp_t
name|tminute
decl_stmt|;
comment|/* sample time for minute start */
name|timestamp_t
name|timeout
decl_stmt|;
comment|/* last timeout timestamp */
block|}
name|last_tcode_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BUFFER_MAX
value|61
end_define

begin_decl_stmt
name|clockformat_t
name|clock_rawdcf
init|=
block|{
name|inp_rawdcf
block|,
comment|/* DCF77 input handling */
name|cvt_rawdcf
block|,
comment|/* raw dcf input conversion */
name|pps_rawdcf
block|,
comment|/* examining PPS information */
literal|0
block|,
comment|/* no private configuration data */
literal|"RAW DCF77 Timecode"
block|,
comment|/* direct decoding / time synthesis */
name|BUFFER_MAX
block|,
comment|/* bit buffer */
expr|sizeof
operator|(
name|last_tcode_t
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|dcfparam
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|onebits
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|zerobits
decl_stmt|;
block|}
name|dcfparameter
init|=
block|{
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"###############RADMLS1248124P124812P1248121241248112481248P??"
block|,
comment|/* 'ONE' representation */
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"--------------------s-------p------p----------------------p__"
comment|/* 'ZERO' representation */
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|rawdcfcode
block|{
name|char
name|offset
decl_stmt|;
comment|/* start bit */
block|}
name|rawdcfcode
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|15
block|}
block|,
block|{
literal|16
block|}
block|,
block|{
literal|17
block|}
block|,
block|{
literal|19
block|}
block|,
block|{
literal|20
block|}
block|,
block|{
literal|21
block|}
block|,
block|{
literal|25
block|}
block|,
block|{
literal|28
block|}
block|,
block|{
literal|29
block|}
block|,
block|{
literal|33
block|}
block|,
block|{
literal|35
block|}
block|,
block|{
literal|36
block|}
block|,
block|{
literal|40
block|}
block|,
block|{
literal|42
block|}
block|,
block|{
literal|45
block|}
block|,
block|{
literal|49
block|}
block|,
block|{
literal|50
block|}
block|,
block|{
literal|54
block|}
block|,
block|{
literal|58
block|}
block|,
block|{
literal|59
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DCF_M
value|0
end_define

begin_define
define|#
directive|define
name|DCF_R
value|1
end_define

begin_define
define|#
directive|define
name|DCF_A1
value|2
end_define

begin_define
define|#
directive|define
name|DCF_Z
value|3
end_define

begin_define
define|#
directive|define
name|DCF_A2
value|4
end_define

begin_define
define|#
directive|define
name|DCF_S
value|5
end_define

begin_define
define|#
directive|define
name|DCF_M1
value|6
end_define

begin_define
define|#
directive|define
name|DCF_M10
value|7
end_define

begin_define
define|#
directive|define
name|DCF_P1
value|8
end_define

begin_define
define|#
directive|define
name|DCF_H1
value|9
end_define

begin_define
define|#
directive|define
name|DCF_H10
value|10
end_define

begin_define
define|#
directive|define
name|DCF_P2
value|11
end_define

begin_define
define|#
directive|define
name|DCF_D1
value|12
end_define

begin_define
define|#
directive|define
name|DCF_D10
value|13
end_define

begin_define
define|#
directive|define
name|DCF_DW
value|14
end_define

begin_define
define|#
directive|define
name|DCF_MO
value|15
end_define

begin_define
define|#
directive|define
name|DCF_MO0
value|16
end_define

begin_define
define|#
directive|define
name|DCF_Y1
value|17
end_define

begin_define
define|#
directive|define
name|DCF_Y10
value|18
end_define

begin_define
define|#
directive|define
name|DCF_P3
value|19
end_define

begin_struct
specifier|static
struct|struct
name|partab
block|{
name|char
name|offset
decl_stmt|;
comment|/* start bit of parity field */
block|}
name|partab
index|[]
init|=
block|{
block|{
literal|21
block|}
block|,
block|{
literal|29
block|}
block|,
block|{
literal|36
block|}
block|,
block|{
literal|59
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DCF_P_P1
value|0
end_define

begin_define
define|#
directive|define
name|DCF_P_P2
value|1
end_define

begin_define
define|#
directive|define
name|DCF_P_P3
value|2
end_define

begin_define
define|#
directive|define
name|DCF_Z_MET
value|0x2
end_define

begin_define
define|#
directive|define
name|DCF_Z_MED
value|0x1
end_define

begin_function
specifier|static
name|u_long
name|ext_bf
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|idx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|zero
parameter_list|)
block|{
name|u_long
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
name|first
operator|=
name|rawdcfcode
index|[
name|idx
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rawdcfcode
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|offset
operator|-
literal|1
init|;
name|i
operator|>=
name|first
condition|;
name|i
operator|--
control|)
block|{
name|sum
operator|<<=
literal|1
expr_stmt|;
name|sum
operator||=
operator|(
name|buf
index|[
name|i
index|]
operator|!=
name|zero
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|pcheck
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|idx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|zero
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|last
decl_stmt|;
name|unsigned
name|psum
init|=
literal|1
decl_stmt|;
name|last
operator|=
name|partab
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|partab
index|[
name|idx
index|]
operator|.
name|offset
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
name|psum
operator|^=
operator|(
name|buf
index|[
name|i
index|]
operator|!=
name|zero
index|[
name|i
index|]
operator|)
expr_stmt|;
return|return
name|psum
return|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|convert_rawdcf
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|dcfparam
modifier|*
name|dcfprm
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|s
init|=
name|buffer
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|b
init|=
name|dcfprm
operator|->
name|onebits
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|c
init|=
name|dcfprm
operator|->
name|zerobits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: \"%.*s\"\n"
operator|,
name|size
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|57
condition|)
block|{
ifndef|#
directive|ifndef
name|PARSEKERNEL
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: convert_rawdcf: INCOMPLETE DATA - time code only has %d bits"
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|!=
operator|*
name|b
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
operator|*
name|c
operator|)
condition|)
block|{
comment|/* 			 * we only have two types of bytes (ones and zeros) 			 */
ifndef|#
directive|ifndef
name|PARSEKERNEL
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: convert_rawdcf: BAD DATA - no conversion"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
if|if
condition|(
operator|*
name|b
condition|)
name|b
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
condition|)
name|c
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
comment|/* 	 * check Start and Parity bits 	 */
if|if
condition|(
operator|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_S
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P2
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P3
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
condition|)
block|{
comment|/* 		 * buffer OK 		 */
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: parity check passed\n"
operator|)
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|flags
operator|=
name|PARSEB_S_CALLBIT
operator||
name|PARSEB_S_LEAP
expr_stmt|;
name|clock_time
operator|->
name|utctime
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|usecond
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|second
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|minute
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_M10
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|minute
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|minute
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_M1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|hour
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_H10
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|hour
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|hour
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_H1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|day
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_D10
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|day
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|day
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_D1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|month
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_MO0
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|month
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|month
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_MO
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|year
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Y10
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|year
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|year
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Y1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Z
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
condition|)
block|{
case|case
name|DCF_Z_MET
case|:
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
literal|1
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
break|break;
case|case
name|DCF_Z_MED
case|:
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_DST
expr_stmt|;
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
literal|2
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
break|break;
default|default:
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: BAD TIME ZONE\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_A1
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_ANNOUNCE
expr_stmt|;
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_A2
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_LEAPADD
expr_stmt|;
comment|/* default: DCF77 data format deficiency */
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_R
argument_list|,
name|dcfprm
operator|->
name|zerobits
argument_list|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|PARSEB_CALLBIT
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: TIME CODE OK: %02d:%02d, %02d.%02d.%02d, flags 0x%lx\n"
operator|,
operator|(
name|int
operator|)
name|clock_time
operator|->
name|hour
operator|,
operator|(
name|int
operator|)
name|clock_time
operator|->
name|minute
operator|,
operator|(
name|int
operator|)
name|clock_time
operator|->
name|day
operator|,
operator|(
name|int
operator|)
name|clock_time
operator|->
name|month
operator|,
operator|(
name|int
operator|)
name|clock_time
operator|->
name|year
operator|,
operator|(
name|u_long
operator|)
name|clock_time
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
else|else
block|{
comment|/* 		 * bad format - not for us 		 */
ifndef|#
directive|ifndef
name|PARSEKERNEL
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: convert_rawdcf: start bit / parity check FAILED for \"%.*s\""
argument_list|,
name|size
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * parse_cvt_fnc_t cvt_rawdcf  * raw dcf input routine - needs to fix up 50 baud  * characters for 1/0 decision  */
end_comment

begin_function
specifier|static
name|u_long
name|cvt_rawdcf
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|format
modifier|*
name|param
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|,
name|void
modifier|*
name|local
parameter_list|)
block|{
name|last_tcode_t
modifier|*
name|t
init|=
operator|(
name|last_tcode_t
operator|*
operator|)
name|local
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|e
init|=
name|s
operator|+
name|size
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|b
init|=
name|dcfparameter
operator|.
name|onebits
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|c
init|=
name|dcfparameter
operator|.
name|zerobits
decl_stmt|;
name|u_long
name|rtc
init|=
name|CVT_NONE
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|lowmax
decl_stmt|,
name|highmax
decl_stmt|,
name|cutoff
decl_stmt|,
name|span
decl_stmt|;
define|#
directive|define
name|BITS
value|9
name|unsigned
name|char
name|histbuf
index|[
name|BITS
index|]
decl_stmt|;
comment|/* 	 * the input buffer contains characters with runs of consecutive 	 * bits set. These set bits are an indication of the DCF77 pulse 	 * length. We assume that we receive the pulse at 50 Baud. Thus 	 * a 100ms pulse would generate a 4 bit train (20ms per bit and 	 * start bit) 	 * a 200ms pulse would create all zeroes (and probably a frame error) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BITS
condition|;
name|i
operator|++
control|)
block|{
name|histbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|cutoff
operator|=
literal|0
expr_stmt|;
name|lowmax
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
name|unsigned
name|int
name|ch
init|=
operator|*
name|s
operator|^
literal|0xFF
decl_stmt|;
comment|/* 		 * these lines are left as an excercise to the reader 8-) 		 */
if|if
condition|(
operator|!
operator|(
operator|(
name|ch
operator|+
literal|1
operator|)
operator|&
name|ch
operator|)
operator|||
operator|!
operator|*
name|s
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|s
operator|=
operator|(
name|unsigned
name|char
operator|)
name|i
expr_stmt|;
name|histbuf
index|[
name|i
index|]
operator|++
expr_stmt|;
name|cutoff
operator|+=
name|i
expr_stmt|;
name|lowmax
operator|++
expr_stmt|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: character check for 0x%x@%d FAILED\n"
operator|,
operator|*
name|s
operator|,
call|(
name|int
call|)
argument_list|(
name|s
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0
expr_stmt|;
name|rtc
operator|=
name|CVT_FAIL
operator||
name|CVT_BADFMT
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lowmax
condition|)
block|{
name|cutoff
operator|/=
name|lowmax
expr_stmt|;
block|}
else|else
block|{
name|cutoff
operator|=
literal|4
expr_stmt|;
comment|/* doesn't really matter - it'll fail anyway, but gives error output */
block|}
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: average bit count: %d\n"
operator|,
name|cutoff
operator|)
argument_list|)
expr_stmt|;
name|lowmax
operator|=
literal|0
expr_stmt|;
name|highmax
operator|=
literal|0
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: histogram:"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cutoff
condition|;
name|i
operator|++
control|)
block|{
name|lowmax
operator|+=
name|histbuf
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|highmax
operator|+=
name|histbuf
index|[
name|i
index|]
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|" %d"
operator|,
name|histbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"<M>"
operator|)
argument_list|)
expr_stmt|;
name|lowmax
operator|+=
name|highmax
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|highmax
condition|)
block|{
name|lowmax
operator|/=
name|highmax
expr_stmt|;
block|}
else|else
block|{
name|lowmax
operator|=
literal|0
expr_stmt|;
block|}
name|highmax
operator|=
literal|0
expr_stmt|;
name|cutoff
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|BITS
condition|;
name|i
operator|++
control|)
block|{
name|highmax
operator|+=
name|histbuf
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|cutoff
operator|+=
name|histbuf
index|[
name|i
index|]
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|" %d"
operator|,
name|histbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cutoff
condition|)
block|{
name|highmax
operator|/=
name|cutoff
expr_stmt|;
block|}
else|else
block|{
name|highmax
operator|=
name|BITS
operator|-
literal|1
expr_stmt|;
block|}
name|span
operator|=
name|cutoff
operator|=
name|lowmax
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lowmax
init|;
name|i
operator|<=
name|highmax
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|histbuf
index|[
name|cutoff
index|]
operator|>
name|histbuf
index|[
name|i
index|]
condition|)
block|{
name|cutoff
operator|=
name|i
expr_stmt|;
name|span
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|histbuf
index|[
name|cutoff
index|]
operator|==
name|histbuf
index|[
name|i
index|]
condition|)
block|{
name|span
operator|=
name|i
expr_stmt|;
block|}
block|}
name|cutoff
operator|=
operator|(
name|cutoff
operator|+
name|span
operator|)
operator|/
literal|2
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: lower maximum %d, higher maximum %d, cutoff %d\n"
operator|,
name|lowmax
operator|,
name|highmax
operator|,
name|cutoff
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0
condition|)
block|{
operator|*
name|s
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|=
operator|(
operator|*
name|s
operator|>=
name|cutoff
operator|)
condition|?
operator|*
name|b
else|:
operator|*
name|c
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|b
condition|)
name|b
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
condition|)
name|c
operator|++
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rtc
operator|==
name|CVT_NONE
condition|)
block|{
name|rtc
operator|=
name|convert_rawdcf
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
operator|&
name|dcfparameter
argument_list|,
name|clock_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtc
operator|==
name|CVT_OK
condition|)
block|{
name|time_t
name|newtime
decl_stmt|;
name|newtime
operator|=
name|parse_to_unixtime
argument_list|(
name|clock_time
argument_list|,
operator|&
name|rtc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtc
operator|==
name|CVT_OK
operator|)
operator|&&
name|t
condition|)
block|{
if|if
condition|(
operator|(
name|newtime
operator|-
name|t
operator|->
name|tcode
operator|)
operator|<=
literal|600
condition|)
comment|/* require a successful telegram within last 10 minutes */
block|{
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: recent timestamp check OK\n"
operator|)
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|utctime
operator|=
name|newtime
expr_stmt|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: recent timestamp check FAIL - ignore timestamp\n"
operator|)
argument_list|)
expr_stmt|;
name|rtc
operator|=
name|CVT_SKIP
expr_stmt|;
block|}
name|t
operator|->
name|tcode
operator|=
name|newtime
expr_stmt|;
block|}
block|}
block|}
return|return
name|rtc
return|;
block|}
end_function

begin_comment
comment|/*  * parse_pps_fnc_t pps_rawdcf  *  * currently a very stupid version - should be extended to decode  * also ones and zeros (which is easy)  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|u_long
name|pps_rawdcf
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|int
name|status
parameter_list|,
name|timestamp_t
modifier|*
name|ptime
parameter_list|)
block|{
if|if
condition|(
operator|!
name|status
condition|)
comment|/* negative edge for simpler wiring (Rx->DCD) */
block|{
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_ptime
operator|=
operator|*
name|ptime
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator||=
name|PARSEB_PPS
operator||
name|PARSEB_S_PPS
expr_stmt|;
block|}
return|return
name|CVT_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|calc_usecdiff
parameter_list|(
name|timestamp_t
modifier|*
name|ref
parameter_list|,
name|timestamp_t
modifier|*
name|base
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
name|struct
name|timeval
name|delta
decl_stmt|;
name|long
name|delta_usec
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|delta
operator|.
name|tv_sec
operator|=
name|ref
operator|->
name|tv
operator|.
name|tv_sec
operator|-
name|offset
operator|-
name|base
operator|->
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|=
name|ref
operator|->
name|tv
operator|.
name|tv_usec
operator|-
name|base
operator|->
name|tv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|delta
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|delta
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
else|#
directive|else
name|l_fp
name|delt
decl_stmt|;
name|delt
operator|=
name|ref
operator|->
name|fp
expr_stmt|;
name|delt
operator|.
name|l_i
operator|-=
name|offset
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|delt
argument_list|,
operator|&
name|base
operator|->
name|fp
argument_list|)
expr_stmt|;
name|TSTOTV
argument_list|(
operator|&
name|delt
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|delta_usec
operator|=
literal|1000000
operator|*
operator|(
name|int32_t
operator|)
name|delta
operator|.
name|tv_sec
operator|+
name|delta
operator|.
name|tv_usec
expr_stmt|;
return|return
name|delta_usec
return|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|snt_rawdcf
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|timestamp_t
modifier|*
name|ptime
parameter_list|)
block|{
comment|/* 	 * only synthesize if all of following conditions are met: 	 * - CVT_OK parse_status (we have a time stamp base) 	 * - ABS(ptime - tminute - (parse_index - 1) sec)< 500ms (spaced by 1 sec +- 500ms) 	 * - minute marker is available (confirms minute raster as base) 	 */
name|last_tcode_t
modifier|*
name|t
init|=
operator|(
name|last_tcode_t
operator|*
operator|)
name|parseio
operator|->
name|parse_pdata
decl_stmt|;
name|long
name|delta_usec
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|tminute
operator|.
name|tv
operator|.
name|tv_sec
operator|!=
literal|0
condition|)
block|{
name|delta_usec
operator|=
name|calc_usecdiff
argument_list|(
name|ptime
argument_list|,
operator|&
name|t
operator|->
name|tminute
argument_list|,
name|parseio
operator|->
name|parse_index
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta_usec
operator|<
literal|0
condition|)
name|delta_usec
operator|=
operator|-
name|delta_usec
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: snt_rawdcf: synth for offset %d seconds - absolute usec error %ld\n"
operator|,
name|parseio
operator|->
name|parse_index
operator|-
literal|1
operator|,
name|delta_usec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|==
name|CVT_OK
operator|)
operator|&&
operator|(
name|delta_usec
operator|<
literal|500000
operator|&&
name|delta_usec
operator|>=
literal|0
operator|)
condition|)
comment|/* only if minute marker is available */
block|{
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|ptime
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_sec
operator|++
expr_stmt|;
else|#
directive|else
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_ui
operator|++
expr_stmt|;
endif|#
directive|endif
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: snt_rawdcf: time stamp synthesized offset %d seconds\n"
operator|,
name|parseio
operator|->
name|parse_index
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|updatetimeinfo
argument_list|(
name|parseio
argument_list|,
name|parseio
operator|->
name|parse_lstate
argument_list|)
return|;
block|}
return|return
name|CVT_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * parse_inp_fnc_t inp_rawdcf  *  * grab DCF77 data from input stream  */
end_comment

begin_function
specifier|static
name|u_long
name|inp_rawdcf
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|char
name|ch
parameter_list|,
name|timestamp_t
modifier|*
name|tstamp
parameter_list|)
block|{
specifier|static
name|struct
name|timeval
name|timeout
init|=
block|{
literal|1
block|,
literal|500000
block|}
decl_stmt|;
comment|/* 1.5 secongs denote second #60 */
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"inp_rawdcf(0x%lx, 0x%x, ...)\n"
operator|,
operator|(
name|long
operator|)
name|parseio
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|tstamp
expr_stmt|;
comment|/* collect timestamp */
if|if
condition|(
name|parse_timedout
argument_list|(
name|parseio
argument_list|,
name|tstamp
argument_list|,
operator|&
name|timeout
argument_list|)
condition|)
block|{
name|last_tcode_t
modifier|*
name|t
init|=
operator|(
name|last_tcode_t
operator|*
operator|)
name|parseio
operator|->
name|parse_pdata
decl_stmt|;
name|long
name|delta_usec
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"inp_rawdcf: time out seen\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* finish collection */
operator|(
name|void
operator|)
name|parse_end
argument_list|(
name|parseio
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
comment|/* remember minute start sample time if timeouts occur in minute raster */
if|if
condition|(
name|t
operator|->
name|timeout
operator|.
name|tv
operator|.
name|tv_sec
operator|!=
literal|0
condition|)
block|{
name|delta_usec
operator|=
name|calc_usecdiff
argument_list|(
name|tstamp
argument_list|,
operator|&
name|t
operator|->
name|timeout
argument_list|,
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta_usec
operator|<
literal|0
condition|)
name|delta_usec
operator|=
operator|-
name|delta_usec
expr_stmt|;
block|}
else|else
block|{
name|delta_usec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta_usec
operator|<
literal|500000
operator|&&
name|delta_usec
operator|>=
literal|0
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"inp_rawdcf: timeout time difference %ld usec - minute marker set\n"
operator|,
name|delta_usec
operator|)
argument_list|)
expr_stmt|;
comment|/* collect minute markers only if spaced by 60 seconds */
name|t
operator|->
name|tminute
operator|=
operator|*
name|tstamp
expr_stmt|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"inp_rawdcf: timeout time difference %ld usec - minute marker cleared\n"
operator|,
name|delta_usec
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|tminute
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|tminute
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|timeout
operator|=
operator|*
name|tstamp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|parse_addchar
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|)
expr_stmt|;
comment|/* pass up to higher layers */
return|return
name|PARSE_INP_TIME
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|rtc
decl_stmt|;
name|rtc
operator|=
name|parse_addchar
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtc
operator|==
name|PARSE_INP_SKIP
condition|)
block|{
if|if
condition|(
name|snt_rawdcf
argument_list|(
name|parseio
argument_list|,
name|tstamp
argument_list|)
operator|==
name|CVT_OK
condition|)
return|return
name|PARSE_INP_SYNTH
return|;
block|}
return|return
name|rtc
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_RAWDCF) */
end_comment

begin_decl_stmt
name|int
name|clk_rawdcf_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE&& CLOCK_RAWDCF) */
end_comment

begin_comment
comment|/*  * History:  *  * clk_rawdcf.c,v  * Revision 4.18  2006/06/22 18:40:01  kardel  * clean up signedness (gcc 4)  *  * Revision 4.17  2006/01/22 16:01:55  kardel  * update version information  *  * Revision 4.16  2006/01/22 15:51:22  kardel  * generate reasonable timecode output on invalid input  *  * Revision 4.15  2005/08/06 19:17:06  kardel  * clean log output  *  * Revision 4.14  2005/08/06 17:39:40  kardel  * cleanup size handling wrt/ to buffer boundaries  *  * Revision 4.13  2005/04/16 17:32:10  kardel  * update copyright  *  * Revision 4.12  2004/11/14 15:29:41  kardel  * support PPSAPI, upgrade Copyright to Berkeley style  *  * Revision 4.9  1999/12/06 13:42:23  kardel  * transfer correctly converted time codes always into tcode  *  * Revision 4.8  1999/11/28 09:13:50  kardel  * RECON_4_0_98F  *  * Revision 4.7  1999/04/01 20:07:20  kardel  * added checking for minutie increment of timestamps in clk_rawdcf.c  *  * Revision 4.6  1998/06/14 21:09:37  kardel  * Sun acc cleanup  *  * Revision 4.5  1998/06/13 12:04:16  kardel  * fix SYSV clock name clash  *  * Revision 4.4  1998/06/12 15:22:28  kardel  * fix prototypes  *  * Revision 4.3  1998/06/06 18:33:36  kardel  * simplified condidional compile expression  *  * Revision 4.2  1998/05/24 11:04:18  kardel  * triggering PPS on negative edge for simpler wiring (Rx->DCD)  *  * Revision 4.1  1998/05/24 09:39:53  kardel  * implementation of the new IO handling model  *  * Revision 4.0  1998/04/10 19:45:30  kardel  * Start 4.0 release version numbering  *  * from V3 3.24 log info deleted 1998/04/11 kardel  *  */
end_comment

end_unit

