begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/ntp4-dev/libparse/parsestreams.c,v 4.11 2005/04/16 17:32:10 kardel RELEASE_20050508_A  *    * parsestreams.c,v 4.11 2005/04/16 17:32:10 kardel RELEASE_20050508_A  *  * STREAMS module for reference clocks  * (SunOS4.x)  *  * Copyright (c) 1995-2005 by Frank Kardel<kardel<AT> ntp.org>  * Copyright (c) 1989-1994 by Frank Kardel, Friedrich-Alexander Universität Erlangen-Nürnberg, Germany  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_comment
comment|/* MUST */
end_comment

begin_define
define|#
directive|define
name|VDDRV
end_define

begin_comment
comment|/* SHOULD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"parsestreams.c,v 4.11 2005/04/16 17:32:10 kardel RELEASE_20050508_A"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL
end_ifndef

begin_include
include|#
directive|include
file|"Bletch: MUST COMPILE WITH KERNEL DEFINE"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sundev/mbvar.h>
end_include

begin_include
include|#
directive|include
file|<sun/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/termio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttold.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VDDRV
end_ifdef

begin_include
include|#
directive|include
file|<sun/vddrv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_comment
comment|/*  * just make checking compilers more silent  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|printf
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|putctl1
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|canput
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|putbq
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|mblk_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|freeb
name|P
argument_list|(
operator|(
name|mblk_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|qreply
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|mblk_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|freemsg
name|P
argument_list|(
operator|(
name|mblk_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|panic
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|usec_delay
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"sys/parsestreams.h"
end_include

begin_comment
comment|/*  * use microtime instead of uniqtime if advised to  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MICROTIME
end_ifdef

begin_define
define|#
directive|define
name|uniqtime
value|microtime
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VDDRV
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|parsebusy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------- loadable driver section -----------------------------*/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|streamtab
name|parseinfo
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PPS_SYNC
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|mnam
index|[]
init|=
literal|"PARSEPPS     "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name this baby - keep room for revision number */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|mnam
index|[]
init|=
literal|"PARSE        "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name this baby - keep room for revision number */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|vdldrv
name|parsesync_vd
init|=
block|{
name|VDMAGIC_PSEUDO
block|,
comment|/* nothing like a real driver - a STREAMS module */
name|mnam
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * strings support usually not in kernel  */
end_comment

begin_function
specifier|static
name|int
name|Strlen
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|++
condition|)
block|{
name|c
operator|++
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|Strncpy
parameter_list|(
specifier|register
name|char
modifier|*
name|t
parameter_list|,
specifier|register
name|char
modifier|*
name|s
parameter_list|,
specifier|register
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|s
operator|&&
name|t
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|--
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|Strcmp
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|t
parameter_list|)
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|t
operator|||
operator|(
name|s
operator|==
name|t
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|!
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|-
operator|*
name|t
operator|++
operator|)
operator|&&
operator|*
name|s
operator|&&
operator|*
name|t
condition|)
comment|/* empty loop */
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|Strncmp
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|,
specifier|register
name|char
modifier|*
name|t
parameter_list|,
specifier|register
name|int
name|n
parameter_list|)
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|t
operator|||
operator|(
name|s
operator|==
name|t
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
while|while
condition|(
name|n
operator|--
operator|&&
operator|!
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|-
operator|*
name|t
operator|++
operator|)
operator|&&
operator|*
name|s
operator|&&
operator|*
name|t
condition|)
comment|/* empty loop */
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|void
name|ntp_memset
parameter_list|(
name|char
modifier|*
name|a
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|c
parameter_list|)
block|{
while|while
condition|(
name|c
operator|--
operator|>
literal|0
condition|)
operator|*
name|a
operator|++
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * driver init routine  * since no mechanism gets us into and out of the fmodsw, we have to  * do it ourselves  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|xxxinit
parameter_list|(
name|unsigned
name|int
name|fc
parameter_list|,
name|struct
name|vddrv
modifier|*
name|vdp
parameter_list|,
name|addr_t
name|vdin
parameter_list|,
name|struct
name|vdstat
modifier|*
name|vds
parameter_list|)
block|{
specifier|extern
name|struct
name|fmodsw
name|fmodsw
index|[]
decl_stmt|;
specifier|extern
name|int
name|fmodcnt
decl_stmt|;
name|struct
name|fmodsw
modifier|*
name|fm
init|=
name|fmodsw
decl_stmt|;
name|struct
name|fmodsw
modifier|*
name|fmend
init|=
operator|&
name|fmodsw
index|[
name|fmodcnt
index|]
decl_stmt|;
name|struct
name|fmodsw
modifier|*
name|ifm
init|=
operator|(
expr|struct
name|fmodsw
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|mname
init|=
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
decl_stmt|;
switch|switch
condition|(
name|fc
condition|)
block|{
case|case
name|VDLOAD
case|:
name|vdp
operator|->
name|vdd_vdtab
operator|=
operator|(
expr|struct
name|vdlinkage
operator|*
operator|)
operator|&
name|parsesync_vd
expr_stmt|;
comment|/* 		 * now, jog along fmodsw scanning for an empty slot 		 * and deposit our name there 		 */
while|while
condition|(
name|fm
operator|<=
name|fmend
condition|)
block|{
if|if
condition|(
operator|!
name|Strncmp
argument_list|(
name|fm
operator|->
name|f_name
argument_list|,
name|mname
argument_list|,
name|FMNAMESZ
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"vddrinit[%s]: STREAMS module already loaded.\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifm
operator|==
operator|(
expr|struct
name|fmodsw
operator|*
operator|)
literal|0
operator|)
operator|&&
operator|(
name|fm
operator|->
name|f_name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|fm
operator|->
name|f_str
operator|==
operator|(
expr|struct
name|streamtab
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
comment|/* 				     * got one - so move in 				     */
name|ifm
operator|=
name|fm
expr_stmt|;
break|break;
block|}
name|fm
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ifm
operator|==
operator|(
expr|struct
name|fmodsw
operator|*
operator|)
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vddrinit[%s]: no slot free for STREAMS module\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
else|else
block|{
specifier|static
name|char
name|revision
index|[]
init|=
literal|"4.7"
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|S
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|s
operator|=
name|rcsid
expr_stmt|;
comment|/* NOOP - keep compilers happy */
name|Strncpy
argument_list|(
name|ifm
operator|->
name|f_name
argument_list|,
name|mname
argument_list|,
name|FMNAMESZ
argument_list|)
expr_stmt|;
name|ifm
operator|->
name|f_name
index|[
name|FMNAMESZ
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ifm
operator|->
name|f_str
operator|=
operator|&
name|parseinfo
expr_stmt|;
comment|/* 			 * copy RCS revision into Drv_name 			 * 			 * are we forcing RCS here to do things it was not built for ? 			 */
name|s
operator|=
name|revision
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
comment|/* 				 * skip "$Revision: " 				 * if present. - not necessary on a -kv co (cvs export) 				 */
while|while
condition|(
operator|*
name|s
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|' '
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|t
operator|=
name|parsesync_vd
operator|.
name|Drv_name
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|(
operator|*
name|t
operator|!=
literal|' '
operator|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|' '
condition|)
name|t
operator|++
expr_stmt|;
name|S
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|S
operator|&&
operator|(
operator|(
operator|(
operator|*
name|S
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|S
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|*
name|S
operator|==
literal|'.'
operator|)
operator|)
condition|)
block|{
name|S
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|&&
operator|*
name|t
operator|&&
operator|(
name|S
operator|>
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|Strlen
argument_list|(
name|t
argument_list|)
operator|>=
operator|(
name|S
operator|-
name|s
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|S
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|VDUNLOAD
case|:
if|if
condition|(
name|parsebusy
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vddrinit[%s]: STREAMS module has still %d instances active.\n"
argument_list|,
name|mname
argument_list|,
name|parsebusy
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
else|else
block|{
while|while
condition|(
name|fm
operator|<=
name|fmend
condition|)
block|{
if|if
condition|(
operator|!
name|Strncmp
argument_list|(
name|fm
operator|->
name|f_name
argument_list|,
name|mname
argument_list|,
name|FMNAMESZ
argument_list|)
condition|)
block|{
comment|/* 					 * got it - kill entry 					 */
name|fm
operator|->
name|f_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fm
operator|->
name|f_str
operator|=
operator|(
expr|struct
name|streamtab
operator|*
operator|)
literal|0
expr_stmt|;
name|fm
operator|++
expr_stmt|;
break|break;
block|}
name|fm
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fm
operator|>
name|fmend
condition|)
block|{
name|printf
argument_list|(
literal|"vddrinit[%s]: cannot find entry for STREAMS module\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|VDSTAT
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
name|EIO
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*--------------- stream module definition ----------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|parseopen
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|dev_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parseclose
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parsewput
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|mblk_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parserput
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|mblk_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parsersvc
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mn
index|[]
init|=
literal|"parse"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|module_info
name|driverinfo
init|=
block|{
literal|0
block|,
comment|/* module ID number */
name|mn
block|,
comment|/* module name */
literal|0
block|,
comment|/* minimum accepted packet size */
name|INFPSZ
block|,
comment|/* maximum accepted packet size */
literal|1
block|,
comment|/* high water mark - flow control */
literal|0
comment|/* low water mark - flow control */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|qinit
name|rinit
init|=
comment|/* read queue definition */
block|{
name|parserput
block|,
comment|/* put procedure */
name|parsersvc
block|,
comment|/* service procedure */
name|parseopen
block|,
comment|/* open procedure */
name|parseclose
block|,
comment|/* close procedure */
name|NULL
block|,
comment|/* admin procedure - NOT USED FOR NOW */
operator|&
name|driverinfo
block|,
comment|/* information structure */
name|NULL
comment|/* statistics */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|qinit
name|winit
init|=
comment|/* write queue definition */
block|{
name|parsewput
block|,
comment|/* put procedure */
name|NULL
block|,
comment|/* service procedure */
name|NULL
block|,
comment|/* open procedure */
name|NULL
block|,
comment|/* close procedure */
name|NULL
block|,
comment|/* admin procedure - NOT USED FOR NOW */
operator|&
name|driverinfo
block|,
comment|/* information structure */
name|NULL
comment|/* statistics */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|streamtab
name|parseinfo
init|=
comment|/* stream info element for dpr driver */
block|{
operator|&
name|rinit
block|,
comment|/* read queue */
operator|&
name|winit
block|,
comment|/* write queue */
name|NULL
block|,
comment|/* read mux */
name|NULL
block|,
comment|/* write mux */
name|NULL
comment|/* module auto push */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------- driver data structures ----------------------------*/
end_comment

begin_comment
comment|/*  * we usually have an inverted signal - but you  * can change this to suit your needs  */
end_comment

begin_decl_stmt
name|int
name|cd_invert
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* invert status of CD line - PPS support via CD input */
end_comment

begin_decl_stmt
name|int
name|parsedebug
init|=
operator|~
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|uniqtime
name|P
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------- module implementation -----------------------------*/
end_comment

begin_define
define|#
directive|define
name|TIMEVAL_USADD
parameter_list|(
name|_X_
parameter_list|,
name|_US_
parameter_list|)
value|{\                                    (_X_)->tv_usec += (_US_);\ 			           if ((_X_)->tv_usec>= 1000000)\                                      {\                                        (_X_)->tv_sec++;\ 			               (_X_)->tv_usec -= 1000000;\                                      }\ 				 } while (0)
end_define

begin_decl_stmt
specifier|static
name|int
name|init_linemon
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_linemon
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|queue_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M_PARSE
value|0x0001
end_define

begin_define
define|#
directive|define
name|M_NOPARSE
value|0x0002
end_define

begin_function
specifier|static
name|int
name|setup_stream
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|mblk_t
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stroptions
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|struct
name|stroptions
modifier|*
name|str
init|=
operator|(
expr|struct
name|stroptions
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|mp
operator|->
name|b_rptr
decl_stmt|;
name|str
operator|->
name|so_flags
operator|=
name|SO_READOPT
operator||
name|SO_HIWAT
operator||
name|SO_LOWAT
expr_stmt|;
name|str
operator|->
name|so_readopt
operator|=
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
name|RMSGD
else|:
name|RNORM
expr_stmt|;
name|str
operator|->
name|so_hiwat
operator|=
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
else|:
literal|256
expr_stmt|;
name|str
operator|->
name|so_lowat
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_SETOPTS
expr_stmt|;
name|mp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|stroptions
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|putctl1
argument_list|(
name|WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_next
argument_list|,
name|M_CTL
argument_list|,
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
name|MC_SERVICEIMM
else|:
name|MC_SERVICEDEF
argument_list|)
return|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: setup_stream - FAILED - no MEMORY for allocb\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|parseopen
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|sflag
parameter_list|)
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
decl_stmt|;
specifier|static
name|int
name|notice
init|=
literal|0
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflag
operator|!=
name|MODOPEN
condition|)
block|{
comment|/* open only for modules */
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - FAILED - not MODOPEN\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|OPENFAIL
return|;
block|}
if|if
condition|(
name|q
operator|->
name|q_ptr
operator|!=
operator|(
name|caddr_t
operator|)
name|NULL
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EBUSY
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - FAILED - EXCLUSIVE ONLY\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|OPENFAIL
return|;
block|}
ifdef|#
directive|ifdef
name|VDDRV
name|parsebusy
operator|++
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_ptr
operator|==
operator|(
name|caddr_t
operator|)
literal|0
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - FAILED - no memory\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VDDRV
name|parsebusy
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
name|OPENFAIL
return|;
block|}
name|WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_ptr
operator|=
name|q
operator|->
name|q_ptr
expr_stmt|;
name|parse
operator|=
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parse
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_queue
operator|=
name|q
expr_stmt|;
name|parse
operator|->
name|parse_status
operator|=
name|PARSE_ENABLE
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|parse_ioinit
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
condition|)
block|{
comment|/* 		 * ok guys - beat it 		 */
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VDDRV
name|parsebusy
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
name|OPENFAIL
return|;
block|}
if|if
condition|(
name|setup_stream
argument_list|(
name|q
argument_list|,
name|M_PARSE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|init_linemon
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* hook up PPS ISR routines if possible */
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - SUCCEEDED\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * I know that you know the delete key, but you didn't write this 		 * code, did you ? - So, keep the message in here. 		 */
if|if
condition|(
operator|!
name|notice
condition|)
block|{
ifdef|#
directive|ifdef
name|VDDRV
name|printf
argument_list|(
literal|"%s: Copyright (C) 1991-2005, Frank Kardel\n"
argument_list|,
name|parsesync_vd
operator|.
name|Drv_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s: Copyright (C) 1991-2005, Frank Kardel\n"
argument_list|,
literal|"parsestreams.c,v 4.11 2005/04/16 17:32:10 kardel RELEASE_20050508_A"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|notice
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|MODOPEN
return|;
block|}
else|else
block|{
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VDDRV
name|parsebusy
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
name|OPENFAIL
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|parseclose
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
specifier|register
name|unsigned
name|long
name|s
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_CLOSE
argument_list|,
operator|(
literal|"parse: CLOSE\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_dqueue
condition|)
name|close_linemon
argument_list|(
name|parse
operator|->
name|parse_dqueue
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_dqueue
operator|=
operator|(
name|queue_t
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|parse_ioend
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
name|WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|VDDRV
name|parsebusy
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * move unrecognized stuff upward  */
end_comment

begin_function
specifier|static
name|int
name|parsersvc
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|)
block|{
name|mblk_t
modifier|*
name|mp
decl_stmt|;
while|while
condition|(
operator|(
name|mp
operator|=
name|getq
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RSVC
argument_list|,
operator|(
literal|"parse: RSVC - putnext\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putbq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RSVC
argument_list|,
operator|(
literal|"parse: RSVC - flow control wait\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * do ioctls and  * send stuff down - dont care about  * flow control  */
end_comment

begin_function
specifier|static
name|int
name|parsewput
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
specifier|register
name|mblk_t
modifier|*
name|mp
parameter_list|)
block|{
specifier|register
name|int
name|ok
init|=
literal|1
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|datap
decl_stmt|;
specifier|register
name|struct
name|iocblk
modifier|*
name|iocp
decl_stmt|;
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
condition|)
block|{
default|default:
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_IOCTL
case|:
name|iocp
operator|=
operator|(
expr|struct
name|iocblk
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|mp
operator|->
name|b_rptr
expr_stmt|;
switch|switch
condition|(
name|iocp
operator|->
name|ioc_cmd
condition|)
block|{
default|default:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - forward M_IOCTL\n"
operator|)
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIOGETEV
case|:
comment|/* 			 * taken from Craig Leres ppsclock module (and modified) 			 */
name|datap
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
expr_stmt|;
if|if
condition|(
name|datap
operator|==
name|NULL
operator|||
name|mp
operator|->
name|b_cont
condition|)
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
name|iocp
operator|->
name|ioc_error
operator|=
operator|(
name|datap
operator|==
name|NULL
operator|)
condition|?
name|ENOMEM
else|:
name|EINVAL
expr_stmt|;
if|if
condition|(
name|datap
operator|!=
name|NULL
condition|)
name|freeb
argument_list|(
name|datap
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
name|mp
operator|->
name|b_cont
operator|=
name|datap
expr_stmt|;
operator|*
operator|(
expr|struct
name|ppsclockev
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|datap
operator|->
name|b_wptr
operator|=
name|parse
operator|->
name|parse_ppsclockev
expr_stmt|;
name|datap
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|datap
operator|->
name|b_wptr
argument_list|)
expr_stmt|;
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCACK
expr_stmt|;
name|iocp
operator|->
name|ioc_count
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_ENABLE
case|:
case|case
name|PARSEIOC_DISABLE
case|:
block|{
name|parse
operator|->
name|parse_status
operator|=
operator|(
name|parse
operator|->
name|parse_status
operator|&
operator|(
name|unsigned
operator|)
operator|~
name|PARSE_ENABLE
operator|)
operator||
operator|(
name|iocp
operator|->
name|ioc_cmd
operator|==
name|PARSEIOC_ENABLE
operator|)
condition|?
name|PARSE_ENABLE
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|setup_stream
argument_list|(
name|RD
argument_list|(
name|q
argument_list|)
argument_list|,
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
condition|?
name|M_PARSE
else|:
name|M_NOPARSE
argument_list|)
condition|)
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCACK
expr_stmt|;
block|}
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PARSEIOC_TIMECODE
case|:
case|case
name|PARSEIOC_SETFMT
case|:
case|case
name|PARSEIOC_GETFMT
case|:
case|case
name|PARSEIOC_SETCS
case|:
if|if
condition|(
name|iocp
operator|->
name|ioc_count
operator|==
sizeof|sizeof
argument_list|(
name|parsectl_t
argument_list|)
condition|)
block|{
name|parsectl_t
modifier|*
name|dct
init|=
operator|(
name|parsectl_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|mp
operator|->
name|b_cont
operator|->
name|b_rptr
decl_stmt|;
switch|switch
condition|(
name|iocp
operator|->
name|ioc_cmd
condition|)
block|{
case|case
name|PARSEIOC_TIMECODE
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_TIMECODE\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_timecode
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_SETFMT
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_SETFMT\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_setfmt
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_GETFMT
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_GETFMT\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_getfmt
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_SETCS
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_SETCS\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_setcs
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
block|}
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|ok
condition|?
name|M_IOCACK
else|:
name|M_IOCNAK
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput qreply - %s\n"
operator|,
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|==
name|M_IOCNAK
operator|)
condition|?
literal|"M_IOCNAK"
else|:
literal|"M_IOCACK"
operator|)
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * read characters from streams buffers  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|rdchar
parameter_list|(
specifier|register
name|mblk_t
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|mp
operator|!=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_wptr
operator|-
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_rptr
condition|)
block|{
return|return
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_rptr
operator|++
operator|)
argument_list|)
return|;
block|}
else|else
block|{
specifier|register
name|mblk_t
modifier|*
name|mmp
init|=
operator|*
name|mp
decl_stmt|;
operator|*
name|mp
operator|=
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_cont
expr_stmt|;
name|freeb
argument_list|(
name|mmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|unsigned
operator|)
operator|~
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * convert incoming data  */
end_comment

begin_function
specifier|static
name|int
name|parserput
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|mblk_t
modifier|*
name|mp
parameter_list|)
block|{
name|unsigned
name|char
name|type
decl_stmt|;
switch|switch
condition|(
name|type
operator|=
name|mp
operator|->
name|b_datap
operator|->
name|db_type
condition|)
block|{
default|default:
comment|/* 		 * anything we don't know will be put on queue 		 * the service routine will move it to the next one 		 */
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - forward type 0x%x\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BREAK
case|:
case|case
name|M_DATA
case|:
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|nmp
decl_stmt|;
specifier|register
name|unsigned
name|long
name|ch
decl_stmt|;
name|timestamp_t
name|ctime
decl_stmt|;
comment|/* 			     * get time on packet delivery 			     */
name|uniqtime
argument_list|(
operator|&
name|ctime
operator|.
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - parser disabled - forward type 0x%x\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - M_%s\n"
operator|,
operator|(
name|type
operator|==
name|M_DATA
operator|)
condition|?
literal|"DATA"
else|:
literal|"BREAK"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|M_DATA
condition|)
block|{
comment|/* 					     * parse packet looking for start an end characters 					     */
while|while
condition|(
name|mp
operator|!=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|ch
operator|=
name|rdchar
argument_list|(
operator|&
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
operator|~
literal|0
operator|&&
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ch
argument_list|,
operator|&
name|ctime
argument_list|)
condition|)
block|{
comment|/* 							     * up up and away (hopefully ...) 							     * don't press it if resources are tight or nobody wants it 							     */
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|parse
operator|->
name|parse_queue
operator|->
name|q_next
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|&
name|ctime
argument_list|)
condition|)
block|{
comment|/* 						     * up up and away (hopefully ...) 						     * don't press it if resources are tight or nobody wants it 						     */
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|parse
operator|->
name|parse_queue
operator|->
name|q_next
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
name|freemsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* 		     * CD PPS support for non direct ISR hack 		     */
case|case
name|M_HANGUP
case|:
case|case
name|M_UNHANGUP
case|:
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
name|timestamp_t
name|ctime
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|nmp
decl_stmt|;
specifier|register
name|int
name|status
init|=
name|cd_invert
operator|^
operator|(
name|type
operator|==
name|M_UNHANGUP
operator|)
decl_stmt|;
name|uniqtime
argument_list|(
operator|&
name|ctime
operator|.
name|tv
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - M_%sHANGUP\n"
operator|,
operator|(
name|type
operator|==
name|M_HANGUP
operator|)
condition|?
literal|""
else|:
literal|"UN"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
operator|&&
name|parse_iopps
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
call|(
name|int
call|)
argument_list|(
name|status
condition|?
name|SYNC_ONE
else|:
name|SYNC_ZERO
argument_list|)
argument_list|,
operator|&
name|ctime
argument_list|)
condition|)
block|{
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|parse
operator|->
name|parse_queue
operator|->
name|q_next
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
name|freemsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|=
name|ctime
operator|.
name|tv
expr_stmt|;
operator|++
operator|(
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|init_zs_linemon
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|queue_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle line monitor for "zs" driver */
end_comment

begin_decl_stmt
specifier|static
name|void
name|close_zs_linemon
name|P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|queue_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-------------------- CD isr status monitor ---------------*/
end_comment

begin_function
specifier|static
name|int
name|init_linemon
parameter_list|(
specifier|register
name|queue_t
modifier|*
name|q
parameter_list|)
block|{
specifier|register
name|queue_t
modifier|*
name|dq
decl_stmt|;
name|dq
operator|=
name|WR
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* 	 * we ARE doing very bad things down here (basically stealing ISR 	 * hooks) 	 * 	 * so we chase down the STREAMS stack searching for the driver 	 * and if this is a known driver we insert our ISR routine for 	 * status changes in to the ExternalStatus handling hook 	 */
while|while
condition|(
name|dq
operator|->
name|q_next
condition|)
block|{
name|dq
operator|=
name|dq
operator|->
name|q_next
expr_stmt|;
comment|/* skip down to driver */
block|}
comment|/* 	 * find appropriate driver dependent routine 	 */
if|if
condition|(
name|dq
operator|->
name|q_qinfo
operator|&&
name|dq
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
specifier|register
name|char
modifier|*
name|dname
init|=
name|dq
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_linemon: driver is \"%s\"\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|dname
operator|&&
operator|!
name|Strcmp
argument_list|(
name|dname
argument_list|,
literal|"zs"
argument_list|)
condition|)
block|{
return|return
name|init_zs_linemon
argument_list|(
name|dq
argument_list|,
name|q
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_linemon: driver \"%s\" not suitable for CD monitoring\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_linemon: cannot find driver\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_linemon
parameter_list|(
specifier|register
name|queue_t
modifier|*
name|q
parameter_list|,
specifier|register
name|queue_t
modifier|*
name|my_q
parameter_list|)
block|{
comment|/* 	 * find appropriate driver dependent routine 	 */
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
specifier|register
name|char
modifier|*
name|dname
init|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
decl_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|dname
operator|&&
operator|!
name|Strcmp
argument_list|(
name|dname
argument_list|,
literal|"zs"
argument_list|)
condition|)
block|{
name|close_zs_linemon
argument_list|(
name|q
argument_list|,
name|my_q
argument_list|)
expr_stmt|;
return|return;
block|}
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"close_linemon: cannot find driver close routine for \"%s\"\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"close_linemon: cannot find driver name\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<sundev/zsreg.h>
end_include

begin_include
include|#
directive|include
file|<sundev/zscom.h>
end_include

begin_include
include|#
directive|include
file|<sundev/zsvar.h>
end_include

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cdmask
init|=
name|ZSRR0_CD
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|savedzsops
block|{
name|struct
name|zsops
name|zsops
decl_stmt|;
name|struct
name|zsops
modifier|*
name|oldzsops
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|zsops
modifier|*
name|emergencyzs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|zsopinit
name|P
argument_list|(
operator|(
expr|struct
name|zscom
operator|*
operator|,
expr|struct
name|zsops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zs_xsisr
name|P
argument_list|(
operator|(
expr|struct
name|zscom
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zs external status interupt handler */
end_comment

begin_function
specifier|static
name|int
name|init_zs_linemon
parameter_list|(
specifier|register
name|queue_t
modifier|*
name|q
parameter_list|,
specifier|register
name|queue_t
modifier|*
name|my_q
parameter_list|)
block|{
specifier|register
name|struct
name|zscom
modifier|*
name|zs
decl_stmt|;
specifier|register
name|struct
name|savedzsops
modifier|*
name|szs
decl_stmt|;
specifier|register
name|parsestream_t
modifier|*
name|parsestream
init|=
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|my_q
operator|->
name|q_ptr
decl_stmt|;
comment|/* 	 * we expect the zsaline pointer in the q_data pointer 	 * from there on we insert our on EXTERNAL/STATUS ISR routine 	 * into the interrupt path, before the standard handler 	 */
name|zs
operator|=
operator|(
operator|(
expr|struct
name|zsaline
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|za_common
expr_stmt|;
if|if
condition|(
operator|!
name|zs
condition|)
block|{
comment|/* 		 * well - not found on startup - just say no (shouldn't happen though) 		 */
return|return
literal|0
return|;
block|}
else|else
block|{
name|unsigned
name|long
name|s
decl_stmt|;
comment|/* 		 * we do a direct replacement, in case others fiddle also 		 * if somebody else grabs our hook and we disconnect 		 * we are in DEEP trouble - panic is likely to be next, sorry 		 */
name|szs
operator|=
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|savedzsops
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|szs
operator|==
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
literal|0
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_zs_linemon: CD monitor NOT installed - no memory\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|parsestream
operator|->
name|parse_data
operator|=
operator|(
name|void
operator|*
operator|)
name|szs
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|parsestream
operator|->
name|parse_dqueue
operator|=
name|q
expr_stmt|;
comment|/* remember driver */
name|szs
operator|->
name|zsops
operator|=
operator|*
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|szs
operator|->
name|zsops
operator|.
name|zsop_xsint
operator|=
name|zs_xsisr
expr_stmt|;
comment|/* place our bastard */
name|szs
operator|->
name|oldzsops
operator|=
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|emergencyzs
operator|=
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|zsopinit
argument_list|(
name|zs
argument_list|,
operator|&
name|szs
operator|->
name|zsops
argument_list|)
expr_stmt|;
comment|/* hook it up */
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_zs_linemon: CD monitor installed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * unregister our ISR routine - must call under splhigh()  */
end_comment

begin_function
specifier|static
name|void
name|close_zs_linemon
parameter_list|(
specifier|register
name|queue_t
modifier|*
name|q
parameter_list|,
specifier|register
name|queue_t
modifier|*
name|my_q
parameter_list|)
block|{
specifier|register
name|struct
name|zscom
modifier|*
name|zs
decl_stmt|;
specifier|register
name|parsestream_t
modifier|*
name|parsestream
init|=
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|my_q
operator|->
name|q_ptr
decl_stmt|;
name|zs
operator|=
operator|(
operator|(
expr|struct
name|zsaline
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|za_common
expr_stmt|;
if|if
condition|(
operator|!
name|zs
condition|)
block|{
comment|/* 		 * well - not found on startup - just say no (shouldn't happen though) 		 */
return|return;
block|}
else|else
block|{
specifier|register
name|struct
name|savedzsops
modifier|*
name|szs
init|=
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
name|parsestream
operator|->
name|parse_data
decl_stmt|;
name|zsopinit
argument_list|(
name|zs
argument_list|,
name|szs
operator|->
name|oldzsops
argument_list|)
expr_stmt|;
comment|/* reset to previous handler functions */
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|szs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|savedzsops
argument_list|)
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"close_zs_linemon: CD monitor deleted\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAXDEPTH
value|50
end_define

begin_comment
comment|/* maximum allowed stream crawl */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PPS_SYNC
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|hardpps
name|P
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PPS_NEW
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|timestamp
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|pps_time
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * take external status interrupt (only CD interests us)  */
end_comment

begin_function
specifier|static
name|int
name|zs_xsisr
parameter_list|(
name|struct
name|zscom
modifier|*
name|zs
parameter_list|)
block|{
specifier|register
name|struct
name|zsaline
modifier|*
name|za
init|=
operator|(
expr|struct
name|zsaline
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|zs
operator|->
name|zs_priv
decl_stmt|;
specifier|register
name|struct
name|zscc_device
modifier|*
name|zsaddr
init|=
name|zs
operator|->
name|zs_addr
decl_stmt|;
specifier|register
name|queue_t
modifier|*
name|q
decl_stmt|;
specifier|register
name|unsigned
name|char
name|zsstatus
decl_stmt|;
specifier|register
name|int
name|loopcheck
decl_stmt|;
specifier|register
name|char
modifier|*
name|dname
decl_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
specifier|register
name|unsigned
name|int
name|s
decl_stmt|;
specifier|register
name|long
name|usec
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * pick up current state 	 */
name|zsstatus
operator|=
name|zsaddr
operator|->
name|zscc_control
expr_stmt|;
if|if
condition|(
operator|(
name|za
operator|->
name|za_rr0
operator|^
name|zsstatus
operator|)
operator|&
operator|(
name|cdmask
operator|)
condition|)
block|{
name|timestamp_t
name|cdevent
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
name|za
operator|->
name|za_rr0
operator|=
operator|(
name|za
operator|->
name|za_rr0
operator|&
operator|~
operator|(
name|cdmask
operator|)
operator|)
operator||
operator|(
name|zsstatus
operator|&
operator|(
name|cdmask
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_NEW
name|usec
operator|=
name|timestamp
operator|.
name|tv_usec
expr_stmt|;
else|#
directive|else
name|usec
operator|=
name|pps_time
operator|.
name|tv_usec
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 		 * time stamp 		 */
name|uniqtime
argument_list|(
operator|&
name|cdevent
operator|.
name|tv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * logical state 		 */
name|status
operator|=
name|cd_invert
condition|?
operator|(
name|zsstatus
operator|&
name|cdmask
operator|)
operator|==
literal|0
else|:
operator|(
name|zsstatus
operator|&
name|cdmask
operator|)
operator|!=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
if|if
condition|(
name|status
condition|)
block|{
name|usec
operator|=
name|cdevent
operator|.
name|tv
operator|.
name|tv_usec
operator|-
name|usec
expr_stmt|;
if|if
condition|(
name|usec
operator|<
literal|0
condition|)
name|usec
operator|+=
literal|1000000
expr_stmt|;
name|hardpps
argument_list|(
operator|&
name|cdevent
operator|.
name|tv
argument_list|,
name|usec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|q
operator|=
name|za
operator|->
name|za_ttycommon
operator|.
name|t_readq
expr_stmt|;
comment|/* 		 * ok - now the hard part - find ourself 		 */
name|loopcheck
operator|=
name|MAXDEPTH
expr_stmt|;
while|while
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
name|dname
operator|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
expr_stmt|;
if|if
condition|(
operator|!
name|Strcmp
argument_list|(
name|dname
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|)
condition|)
block|{
comment|/* 					 * back home - phew (hopping along stream queues might 					 * prove dangerous to your health) 					 */
if|if
condition|(
operator|(
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
operator|&&
name|parse_iopps
argument_list|(
operator|&
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_io
argument_list|,
call|(
name|int
call|)
argument_list|(
name|status
condition|?
name|SYNC_ONE
else|:
name|SYNC_ZERO
argument_list|)
argument_list|,
operator|&
name|cdevent
argument_list|)
condition|)
block|{
comment|/* 						 * XXX - currently we do not pass up the message, as 						 * we should. 						 * for a correct behaviour wee need to block out 						 * processing until parse_iodone has been posted via 						 * a softcall-ed routine which does the message pass-up 						 * right now PPS information relies on input being 						 * received 						 */
name|parse_iodone
argument_list|(
operator|&
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|=
name|cdevent
operator|.
name|tv
expr_stmt|;
operator|++
operator|(
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|)
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_ISR
argument_list|,
operator|(
literal|"zs_xsisr: CD event %s has been posted for \"%s\"\n"
operator|,
name|status
condition|?
literal|"ONE"
else|:
literal|"ZERO"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
if|if
condition|(
operator|!
name|loopcheck
operator|--
condition|)
block|{
name|panic
argument_list|(
literal|"zs_xsisr: STREAMS Queue corrupted - CD event"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * only pretend that CD has been handled 		 */
name|ZSDELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|za
operator|->
name|za_rr0
operator|^
name|zsstatus
operator|)
operator|&
operator|~
operator|(
name|cdmask
operator|)
operator|)
condition|)
block|{
comment|/* 			 * all done - kill status indication and return 			 */
name|zsaddr
operator|->
name|zscc_control
operator|=
name|ZSWR0_RESET_STATUS
expr_stmt|;
comment|/* might kill other conditions here */
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|zsstatus
operator|&
name|cdmask
condition|)
comment|/* fake CARRIER status */
name|za
operator|->
name|za_flags
operator||=
name|ZAS_CARR_ON
expr_stmt|;
else|else
name|za
operator|->
name|za_flags
operator|&=
operator|~
name|ZAS_CARR_ON
expr_stmt|;
comment|/* 	 * we are now gathered here to process some unusual external status 	 * interrupts. 	 * any CD events have also been handled and shouldn't be processed 	 * by the original routine (unless we have a VERY busy port pin) 	 * some initializations are done here, which could have been done before for 	 * both code paths but have been avoided for minimum path length to 	 * the uniq_time routine 	 */
name|dname
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|q
operator|=
name|za
operator|->
name|za_ttycommon
operator|.
name|t_readq
expr_stmt|;
name|loopcheck
operator|=
name|MAXDEPTH
expr_stmt|;
comment|/* 	 * the real thing for everything else ... 	 */
while|while
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
name|dname
operator|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
expr_stmt|;
if|if
condition|(
operator|!
name|Strcmp
argument_list|(
name|dname
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|)
condition|)
block|{
specifier|register
name|int
argument_list|(
argument|*zsisr
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|zscom
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * back home - phew (hopping along stream queues might 				 * prove dangerous to your health) 				 */
if|if
condition|(
operator|(
name|zsisr
operator|=
operator|(
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_data
operator|)
operator|->
name|oldzsops
operator|->
name|zsop_xsint
operator|)
condition|)
return|return
name|zsisr
argument_list|(
name|zs
argument_list|)
return|;
else|else
name|panic
argument_list|(
literal|"zs_xsisr: unable to locate original ISR"
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_ISR
argument_list|,
operator|(
literal|"zs_xsisr: non CD event was processed for \"%s\"\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * now back to our program ... 				 */
return|return
literal|0
return|;
block|}
block|}
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
if|if
condition|(
operator|!
name|loopcheck
operator|--
condition|)
block|{
name|panic
argument_list|(
literal|"zs_xsisr: STREAMS Queue corrupted - non CD event"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * last resort - shouldn't even come here as it indicates 	 * corrupted TTY structures 	 */
name|printf
argument_list|(
literal|"zs_zsisr: looking for \"%s\" - found \"%s\" - taking EMERGENCY path\n"
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|,
name|dname
condition|?
name|dname
else|:
literal|"-NIL-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|emergencyzs
operator|&&
name|emergencyzs
operator|->
name|zsop_xsint
condition|)
name|emergencyzs
operator|->
name|zsop_xsint
argument_list|(
name|zs
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"zs_xsisr: no emergency ISR handler"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_comment
comment|/*  * History:  *  * parsestreams.c,v  * Revision 4.11  2005/04/16 17:32:10  kardel  * update copyright  *  * Revision 4.10  2004/11/14 16:06:08  kardel  * update Id tags  *  * Revision 4.9  2004/11/14 15:29:41  kardel  * support PPSAPI, upgrade Copyright to Berkeley style  *  * Revision 4.7  1999/11/28 09:13:53  kardel  * RECON_4_0_98F  *  * Revision 4.6  1998/12/20 23:45:31  kardel  * fix types and warnings  *  * Revision 4.5  1998/11/15 21:23:38  kardel  * ntp_memset() replicated in Sun kernel files  *  * Revision 4.4  1998/06/13 12:15:59  kardel  * superfluous variable removed  *  * Revision 4.3  1998/06/12 15:23:08  kardel  * fix prototypes  * adjust for ansi2knr  *  * Revision 4.2  1998/05/24 18:16:22  kardel  * moved copy of shadow status to the beginning  *  * Revision 4.1  1998/05/24 09:38:47  kardel  * streams initiated iopps calls (M_xHANGUP) are now consistent with the  * respective calls from zs_xsisr()  * simulation of CARRIER status to avoid unecessary M_xHANGUP messages  *  * Revision 4.0  1998/04/10 19:45:38  kardel  * Start 4.0 release version numbering  *  * from V3 3.37 log info deleted 1998/04/11 kardel  */
end_comment

end_unit

