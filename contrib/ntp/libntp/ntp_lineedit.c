begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_lineedit.c - generic interface to various line editing libs  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_READLINE_HISTORY
argument_list|)
operator|&&
expr|\
operator|(
operator|!
name|defined
argument_list|(
name|HAVE_READLINE_HISTORY_H
argument_list|)
operator|||
expr|\
operator|!
name|defined
argument_list|(
name|HAVE_READLINE_READLINE_H
argument_list|)
operator|)
end_if

begin_undef
undef|#
directive|undef
name|HAVE_READLINE_HISTORY
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_READLINE_HISTORY
argument_list|)
end_if

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_define
define|#
directive|define
name|LE_READLINE
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_HISTEDIT_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<histedit.h>
end_include

begin_define
define|#
directive|define
name|LE_EDITLINE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LE_NONE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lineedit.h"
end_include

begin_define
define|#
directive|define
name|MAXEDITLINE
value|512
end_define

begin_comment
comment|/*  * external references  */
end_comment

begin_decl_stmt
specifier|extern
name|char
specifier|const
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * globals, private prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ntp_readline_initted
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lineedit_prompt
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LE_EDITLINE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|H_SETSIZE
end_ifndef

begin_define
define|#
directive|define
name|H_SETSIZE
value|H_EVENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|EditLine
modifier|*
name|ntp_el
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|History
modifier|*
name|ntp_hist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HistEvent
name|hev
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|ntp_prompt_callback
parameter_list|(
name|EditLine
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LE_EDITLINE */
end_comment

begin_comment
comment|/*  * ntp_readline_init - setup, set or reset prompt string  */
end_comment

begin_function
name|int
name|ntp_readline_init
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|)
block|{
name|int
name|success
decl_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
block|{
if|if
condition|(
name|lineedit_prompt
condition|)
name|free
argument_list|(
name|lineedit_prompt
argument_list|)
expr_stmt|;
name|lineedit_prompt
operator|=
name|estrdup
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LE_EDITLINE
if|if
condition|(
name|NULL
operator|==
name|ntp_el
condition|)
block|{
if|#
directive|if
literal|4
operator|==
name|EL_INIT_ARGS
name|ntp_el
operator|=
name|el_init
argument_list|(
name|progname
argument_list|,
name|stdin
argument_list|,
name|stdout
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|#
directive|else
name|ntp_el
operator|=
name|el_init
argument_list|(
name|progname
argument_list|,
name|stdin
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ntp_el
condition|)
block|{
name|el_set
argument_list|(
name|ntp_el
argument_list|,
name|EL_PROMPT
argument_list|,
name|ntp_prompt_callback
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|ntp_el
argument_list|,
name|EL_EDITOR
argument_list|,
literal|"emacs"
argument_list|)
expr_stmt|;
name|ntp_hist
operator|=
name|history_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ntp_hist
condition|)
block|{
name|mfprintf
argument_list|(
name|stderr
argument_list|,
literal|"history_init(): %m\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|el_end
argument_list|(
name|ntp_el
argument_list|)
expr_stmt|;
name|ntp_el
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ZERO
argument_list|(
name|hev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|H_SETSIZE
name|history
argument_list|(
name|ntp_hist
argument_list|,
operator|&
name|hev
argument_list|,
name|H_SETSIZE
argument_list|,
literal|128
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|el_set
argument_list|(
name|ntp_el
argument_list|,
name|EL_HIST
argument_list|,
name|history
argument_list|,
name|ntp_hist
argument_list|)
expr_stmt|;
comment|/* use any .editrc */
name|el_source
argument_list|(
name|ntp_el
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|success
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LE_EDITLINE */
name|ntp_readline_initted
operator|=
name|success
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * ntp_readline_uninit - release resources  */
end_comment

begin_function
name|void
name|ntp_readline_uninit
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|LE_EDITLINE
if|if
condition|(
name|ntp_el
condition|)
block|{
name|el_end
argument_list|(
name|ntp_el
argument_list|)
expr_stmt|;
name|ntp_el
operator|=
name|NULL
expr_stmt|;
name|history_end
argument_list|(
name|ntp_hist
argument_list|)
expr_stmt|;
name|ntp_hist
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LE_EDITLINE */
if|if
condition|(
name|lineedit_prompt
condition|)
block|{
name|free
argument_list|(
name|lineedit_prompt
argument_list|)
expr_stmt|;
name|lineedit_prompt
operator|=
name|NULL
expr_stmt|;
block|}
name|ntp_readline_initted
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ntp_readline - read a line with the line editor available  *  * The string returned must be released with free()  */
end_comment

begin_function
name|char
modifier|*
name|ntp_readline
parameter_list|(
name|int
modifier|*
name|pcount
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
ifdef|#
directive|ifdef
name|LE_NONE
name|char
name|line_buf
index|[
name|MAXEDITLINE
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LE_EDITLINE
specifier|const
name|char
modifier|*
name|cline
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ntp_readline_initted
condition|)
return|return
name|NULL
return|;
operator|*
name|pcount
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LE_READLINE
name|line
operator|=
name|readline
argument_list|(
name|lineedit_prompt
condition|?
name|lineedit_prompt
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|line
condition|)
block|{
if|if
condition|(
operator|*
name|line
condition|)
block|{
name|add_history
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
operator|*
name|pcount
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LE_READLINE */
ifdef|#
directive|ifdef
name|LE_EDITLINE
name|cline
operator|=
name|el_gets
argument_list|(
name|ntp_el
argument_list|,
name|pcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|cline
condition|)
block|{
name|history
argument_list|(
name|ntp_hist
argument_list|,
operator|&
name|hev
argument_list|,
name|H_ENTER
argument_list|,
name|cline
argument_list|)
expr_stmt|;
name|line
operator|=
name|estrdup
argument_list|(
name|cline
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pcount
operator|==
operator|-
literal|1
condition|)
block|{
name|line
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|line
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LE_EDITLINE */
ifdef|#
directive|ifdef
name|LE_NONE
comment|/* stone hammers */
if|if
condition|(
name|lineedit_prompt
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
comment|/* 			 * work around problem mixing 			 * stdout& stderr 			 */
name|fputs
argument_list|(
literal|""
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|fputs
argument_list|(
name|lineedit_prompt
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|fgets
argument_list|(
name|line_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|line_buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|line
operator|&&
operator|*
name|line
condition|)
block|{
operator|*
name|pcount
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|estrdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|line
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* LE_NONE */
if|if
condition|(
operator|!
name|line
condition|)
comment|/* EOF */
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LE_EDITLINE
end_ifdef

begin_comment
comment|/*  * ntp_prompt_callback - return prompt string to el_gets()  */
end_comment

begin_function
name|char
modifier|*
name|ntp_prompt_callback
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|UNUSED_ARG
argument_list|(
name|el
argument_list|)
expr_stmt|;
return|return
name|lineedit_prompt
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LE_EDITLINE */
end_comment

end_unit

