begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Modified by Dave Hart for integration into NTP 4.2.7<hart@ntp.org>  *  * Changed in a backwards-incompatible way to separate HAVE_SNPRINTF  * from HW_WANT_RPL_SNPRINTF, etc. for each of the four replaced  * functions.  *  * Changed to honor hw_force_rpl_snprintf=yes, etc.  This is used by NTP  * to test rpl_snprintf() and rpl_vsnprintf() on platforms which provide  * C99-compliant implementations.  */
end_comment

begin_comment
comment|/* $Id: snprintf.c,v 1.9 2008/01/20 14:02:00 holger Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Patrick Powell.  *  * This code is based on code written by Patrick Powell<papowell@astart.com>.  * It may be used for any purpose as long as this notice remains intact on all  * source code distributions.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008 Holger Weiss.  *  * This version of the code is maintained by Holger Weiss<holger@jhweiss.de>.  * My changes to the code may freely be used, modified and/or redistributed for  * any purpose.  It would be nice if additions and fixes to this file (including  * trivial code cleanups) would be sent back in order to let me include them in  * the version available at<http://www.jhweiss.de/software/snprintf.html>.  * However, this is not a requirement for using or redistributing (possibly  * modified) versions of this file, nor is leaving this notice intact mandatory.  */
end_comment

begin_comment
comment|/*  * History  *  * 2008-01-20 Holger Weiss<holger@jhweiss.de> for C99-snprintf 1.1:  *  * 	Fixed the detection of infinite floating point values on IRIX (and  * 	possibly other systems) and applied another few minor cleanups.  *  * 2008-01-06 Holger Weiss<holger@jhweiss.de> for C99-snprintf 1.0:  *  * 	Added a lot of new features, fixed many bugs, and incorporated various  * 	improvements done by Andrew Tridgell<tridge@samba.org>, Russ Allbery  *<rra@stanford.edu>, Hrvoje Niksic<hniksic@xemacs.org>, Damien Miller  *<djm@mindrot.org>, and others for the Samba, INN, Wget, and OpenSSH  * 	projects.  The additions include: support the "e", "E", "g", "G", and  * 	"F" conversion specifiers (and use conversion style "f" or "F" for the  * 	still unsupported "a" and "A" specifiers); support the "hh", "ll", "j",  * 	"t", and "z" length modifiers; support the "#" flag and the (non-C99)  * 	"'" flag; use localeconv(3) (if available) to get both the current  * 	locale's decimal point character and the separator between groups of  * 	digits; fix the handling of various corner cases of field width and  * 	precision specifications; fix various floating point conversion bugs;  * 	handle infinite and NaN floating point values; don't attempt to write to  * 	the output buffer (which may be NULL) if a size of zero was specified;  * 	check for integer overflow of the field width, precision, and return  * 	values and during the floating point conversion; use the OUTCHAR() macro  * 	instead of a function for better performance; provide asprintf(3) and  * 	vasprintf(3) functions; add new test cases.  The replacement functions  * 	have been renamed to use an "rpl_" prefix, the function calls in the  * 	main project (and in this file) must be redefined accordingly for each  * 	replacement function which is needed (by using Autoconf or other means).  * 	Various other minor improvements have been applied and the coding style  * 	was cleaned up for consistency.  *  * 2007-07-23 Holger Weiss<holger@jhweiss.de> for Mutt 1.5.13:  *  * 	C99 compliant snprintf(3) and vsnprintf(3) functions return the number  * 	of characters that would have been written to a sufficiently sized  * 	buffer (excluding the '\0').  The original code simply returned the  * 	length of the resulting output string, so that's been fixed.  *  * 1998-03-05 Michael Elkins<me@mutt.org> for Mutt 0.90.8:  *  * 	The original code assumed that both snprintf(3) and vsnprintf(3) were  * 	missing.  Some systems only have snprintf(3) but not vsnprintf(3), so  * 	the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.  *  * 1998-01-27 Thomas Roessler<roessler@does-not-exist.org> for Mutt 0.89i:  *  * 	The PGP code was using unsigned hexadecimal formats.  Unfortunately,  * 	unsigned formats simply didn't work.  *  * 1997-10-22 Brandon Long<blong@fiction.net> for Mutt 0.87.1:  *  * 	Ok, added some minimal floating point support, which means this probably  * 	requires libm on most operating systems.  Don't yet support the exponent  * 	(e,E) and sigfig (g,G).  Also, fmtint() was pretty badly broken, it just  * 	wasn't being exercised in ways which showed it, so that's been fixed.  * 	Also, formatted the code to Mutt conventions, and removed dead code left  * 	over from the original.  Also, there is now a builtin-test, run with:  * 	gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm&& ./snprintf  *  * 2996-09-15 Brandon Long<blong@fiction.net> for Mutt 0.43:  *  * 	This was ugly.  It is still ugly.  I opted out of floating point  * 	numbers, but the formatter understands just about everything from the  * 	normal C string format, at least as far as I can tell from the Solaris  * 	2.5 printf(3S) man page.  */
end_comment

begin_comment
comment|/*  * ToDo  *  * - Add wide character support.  * - Add support for "%a" and "%A" conversions.  * - Create test routines which predefine the expected results.  Our test cases  *   usually expose bugs in system implementations rather than in ours :-)  */
end_comment

begin_comment
comment|/*  * Usage  *  * 1) The following preprocessor macros should be defined to 1 if the feature or  *    file in question is available on the target system (by using Autoconf or  *    other means), though basic functionality should be available as long as  *    HAVE_STDARG_H and HAVE_STDLIB_H are defined correctly:  *  *	HW_WANT_RPL_VSNPRINTF  *	HW_WANT_RPL_SNPRINTF  *	HW_WANT_RPL_VASPRINTF  *	HW_WANT_RPL_ASPRINTF  *	HAVE_VSNPRINTF	// define to 1 #if HW_WANT_RPL_VSNPRINTF  *	HAVE_SNPRINTF	// define to 1 #if HW_WANT_RPL_SNPRINTF  *	HAVE_VASPRINTF	// define to 1 #if HW_WANT_RPL_VASPRINTF  *	HAVE_ASPRINTF	// define to 1 #if HW_WANT_RPL_ASPRINTF  *	HAVE_STDARG_H  *	HAVE_STDDEF_H  *	HAVE_STDINT_H  *	HAVE_STDLIB_H  *	HAVE_INTTYPES_H  *	HAVE_LOCALE_H  *	HAVE_LOCALECONV  *	HAVE_LCONV_DECIMAL_POINT  *	HAVE_LCONV_THOUSANDS_SEP  *	HAVE_LONG_DOUBLE  *	HAVE_LONG_LONG_INT  *	HAVE_UNSIGNED_LONG_LONG_INT  *	HAVE_INTMAX_T  *	HAVE_UINTMAX_T  *	HAVE_UINTPTR_T  *	HAVE_PTRDIFF_T  *	HAVE_VA_COPY  *	HAVE___VA_COPY  *  * 2) The calls to the functions which should be replaced must be redefined  *    throughout the project files (by using Autoconf or other means):  *  *	#if HW_WANT_RPL_VSNPRINTF  *	#define vsnprintf rpl_vsnprintf  *	#endif  *	#if HW_WANT_RPL_SNPRINTF  *	#define snprintf rpl_snprintf  *	#endif  *	#if HW_WANT_RPL_VASPRINTF  *	#define vasprintf rpl_vasprintf  *	#endif  *	#if HW_WANT_RPL_ASPRINTF  *	#define asprintf rpl_asprintf  *	#endif  *  * 3) The required replacement functions should be declared in some header file  *    included throughout the project files:  *  *	#if HAVE_CONFIG_H  *	#include<config.h>  *	#endif  *	#if HAVE_STDARG_H  *	#include<stdarg.h>  *	#if HW_WANT_RPL_VSNPRINTF  *	int rpl_vsnprintf(char *, size_t, const char *, va_list);  *	#endif  *	#if HW_WANT_RPL_SNPRINTF  *	int rpl_snprintf(char *, size_t, const char *, ...);  *	#endif  *	#if HW_WANT_RPL_VASPRINTF  *	int rpl_vasprintf(char **, const char *, va_list);  *	#endif  *	#if HW_WANT_RPL_ASPRINTF  *	int rpl_asprintf(char **, const char *, ...);  *	#endif  *	#endif  *  * Autoconf macros for handling step 1 and step 2 are available at  *<http://www.jhweiss.de/software/snprintf.html>.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_if
if|#
directive|if
name|TEST_SNPRINTF
end_if

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* For pow(3), NAN, and INFINITY. */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* For strcmp(3). */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__NeXT__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__bsd__
argument_list|)
end_if

begin_define
define|#
directive|define
name|OS_BSD
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|__sgi
argument_list|)
end_elif

begin_ifndef
ifndef|#
directive|ifndef
name|__c99
end_ifndef

begin_define
define|#
directive|define
name|__c99
end_define

begin_comment
comment|/* Force C99 mode to get<stdint.h> included on IRIX 6.5.30. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(__c99) */
end_comment

begin_define
define|#
directive|define
name|OS_IRIX
value|1
end_define

begin_define
define|#
directive|define
name|OS_SYSV
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__svr4__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|OS_SYSV
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__linux__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|OS_LINUX
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__NetBSD__) || defined(__FreeBSD__) || [...] */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_comment
comment|/* Undefine definitions possibly done in config.h. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SNPRINTF
end_ifdef

begin_undef
undef|#
directive|undef
name|HAVE_SNPRINTF
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(HAVE_SNPRINTF) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VSNPRINTF
end_ifdef

begin_undef
undef|#
directive|undef
name|HAVE_VSNPRINTF
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(HAVE_VSNPRINTF) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ASPRINTF
end_ifdef

begin_undef
undef|#
directive|undef
name|HAVE_ASPRINTF
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(HAVE_ASPRINTF) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VASPRINTF
end_ifdef

begin_undef
undef|#
directive|undef
name|HAVE_VASPRINTF
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(HAVE_VASPRINTF) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|snprintf
end_ifdef

begin_undef
undef|#
directive|undef
name|snprintf
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(snprintf) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vsnprintf
end_ifdef

begin_undef
undef|#
directive|undef
name|vsnprintf
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(vsnprintf) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|asprintf
end_ifdef

begin_undef
undef|#
directive|undef
name|asprintf
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(asprintf) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vasprintf
end_ifdef

begin_undef
undef|#
directive|undef
name|vasprintf
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(vasprintf) */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* By default, we assume a modern system for testing. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STDARG_H
end_ifndef

begin_define
define|#
directive|define
name|HAVE_STDARG_H
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDARG_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STDDEF_H
end_ifndef

begin_define
define|#
directive|define
name|HAVE_STDDEF_H
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDDEF_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STDINT_H
end_ifndef

begin_define
define|#
directive|define
name|HAVE_STDINT_H
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDINT_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STDLIB_H
end_ifndef

begin_define
define|#
directive|define
name|HAVE_STDLIB_H
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_INTTYPES_H
end_ifndef

begin_define
define|#
directive|define
name|HAVE_INTTYPES_H
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_INTTYPES_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_LOCALE_H
end_ifndef

begin_define
define|#
directive|define
name|HAVE_LOCALE_H
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LOCALE_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_LOCALECONV
end_ifndef

begin_define
define|#
directive|define
name|HAVE_LOCALECONV
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_LOCALECONV) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_LCONV_DECIMAL_POINT
end_ifndef

begin_define
define|#
directive|define
name|HAVE_LCONV_DECIMAL_POINT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LCONV_DECIMAL_POINT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_LCONV_THOUSANDS_SEP
end_ifndef

begin_define
define|#
directive|define
name|HAVE_LCONV_THOUSANDS_SEP
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LCONV_THOUSANDS_SEP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_LONG_DOUBLE
end_ifndef

begin_define
define|#
directive|define
name|HAVE_LONG_DOUBLE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_LONG_DOUBLE) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_LONG_LONG_INT
end_ifndef

begin_define
define|#
directive|define
name|HAVE_LONG_LONG_INT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_LONG_LONG_INT) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_UNSIGNED_LONG_LONG_INT
end_ifndef

begin_define
define|#
directive|define
name|HAVE_UNSIGNED_LONG_LONG_INT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_UNSIGNED_LONG_LONG_INT) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_INTMAX_T
end_ifndef

begin_define
define|#
directive|define
name|HAVE_INTMAX_T
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_INTMAX_T) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_UINTMAX_T
end_ifndef

begin_define
define|#
directive|define
name|HAVE_UINTMAX_T
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_UINTMAX_T) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_UINTPTR_T
end_ifndef

begin_define
define|#
directive|define
name|HAVE_UINTPTR_T
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_UINTPTR_T) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PTRDIFF_T
end_ifndef

begin_define
define|#
directive|define
name|HAVE_PTRDIFF_T
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_PTRDIFF_T) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_VA_COPY
end_ifndef

begin_define
define|#
directive|define
name|HAVE_VA_COPY
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_VA_COPY) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE___VA_COPY
end_ifndef

begin_define
define|#
directive|define
name|HAVE___VA_COPY
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE___VA_COPY) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_define
define|#
directive|define
name|snprintf
value|rpl_snprintf
end_define

begin_define
define|#
directive|define
name|vsnprintf
value|rpl_vsnprintf
end_define

begin_define
define|#
directive|define
name|asprintf
value|rpl_asprintf
end_define

begin_define
define|#
directive|define
name|vasprintf
value|rpl_vasprintf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_SNPRINTF */
end_comment

begin_if
if|#
directive|if
name|HW_WANT_RPL_SNPRINTF
operator|||
name|HW_WANT_RPL_VSNPRINTF
operator|||
name|HW_WANT_RPL_ASPRINTF
operator|||
name|HW_WANT_RPL_VASPRINTF
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* For NULL, size_t, vsnprintf(3), and vasprintf(3). */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VA_START
end_ifdef

begin_undef
undef|#
directive|undef
name|VA_START
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(VA_START) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VA_SHIFT
end_ifdef

begin_undef
undef|#
directive|undef
name|VA_SHIFT
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(VA_SHIFT) */
end_comment

begin_if
if|#
directive|if
name|HAVE_STDARG_H
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|ap
parameter_list|,
name|last
parameter_list|)
value|va_start(ap, last)
end_define

begin_define
define|#
directive|define
name|VA_SHIFT
parameter_list|(
name|ap
parameter_list|,
name|value
parameter_list|,
name|type
parameter_list|)
end_define

begin_comment
comment|/* No-op for ANSI C. */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Assume<varargs.h> is available. */
end_comment

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|ap
parameter_list|,
name|last
parameter_list|)
value|va_start(ap)
end_define

begin_comment
comment|/* "last" is ignored. */
end_comment

begin_define
define|#
directive|define
name|VA_SHIFT
parameter_list|(
name|ap
parameter_list|,
name|value
parameter_list|,
name|type
parameter_list|)
value|value = va_arg(ap, type)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDARG_H */
end_comment

begin_if
if|#
directive|if
name|HW_WANT_RPL_VASPRINTF
end_if

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* For malloc(3). */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VA_COPY
end_ifdef

begin_undef
undef|#
directive|undef
name|VA_COPY
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(VA_COPY) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VA_END_COPY
end_ifdef

begin_undef
undef|#
directive|undef
name|VA_END_COPY
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(VA_END_COPY) */
end_comment

begin_if
if|#
directive|if
name|HAVE_VA_COPY
end_if

begin_define
define|#
directive|define
name|VA_COPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|va_copy(dest, src)
end_define

begin_define
define|#
directive|define
name|VA_END_COPY
parameter_list|(
name|ap
parameter_list|)
value|va_end(ap)
end_define

begin_elif
elif|#
directive|elif
name|HAVE___VA_COPY
end_elif

begin_define
define|#
directive|define
name|VA_COPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|__va_copy(dest, src)
end_define

begin_define
define|#
directive|define
name|VA_END_COPY
parameter_list|(
name|ap
parameter_list|)
value|va_end(ap)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VA_COPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|(void)mymemcpy(&dest,&src, sizeof(va_list))
end_define

begin_define
define|#
directive|define
name|VA_END_COPY
parameter_list|(
name|ap
parameter_list|)
end_define

begin_comment
comment|/* No-op. */
end_comment

begin_define
define|#
directive|define
name|NEED_MYMEMCPY
value|1
end_define

begin_function_decl
specifier|static
name|void
modifier|*
name|mymemcpy
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_VA_COPY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HW_WANT_RPL_VASPRINTF */
end_comment

begin_if
if|#
directive|if
name|HW_WANT_RPL_VSNPRINTF
end_if

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* For ERANGE and errno. */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_comment
comment|/* For *_MAX. */
end_comment

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_comment
comment|/* For intmax_t (if not defined in<stdint.h>). */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_INTTYPES_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_LOCALE_H
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_comment
comment|/* For localeconv(3). */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LOCALE_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_STDDEF_H
end_if

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* For ptrdiff_t. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDDEF_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_STDINT_H
end_if

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_comment
comment|/* For intmax_t. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDINT_H */
end_comment

begin_comment
comment|/* Support for unsigned long long int.  We may also need ULLONG_MAX. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ULONG_MAX
end_ifndef

begin_comment
comment|/* We may need ULONG_MAX as a fallback. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UINT_MAX
end_ifdef

begin_define
define|#
directive|define
name|ULONG_MAX
value|UINT_MAX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ULONG_MAX
value|INT_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(UINT_MAX) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(ULONG_MAX) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ULLONG
end_ifdef

begin_undef
undef|#
directive|undef
name|ULLONG
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(ULLONG) */
end_comment

begin_if
if|#
directive|if
name|HAVE_UNSIGNED_LONG_LONG_INT
end_if

begin_define
define|#
directive|define
name|ULLONG
value|unsigned long long int
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ULLONG_MAX
end_ifndef

begin_define
define|#
directive|define
name|ULLONG_MAX
value|ULONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(ULLONG_MAX) */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ULLONG
value|unsigned long int
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ULLONG_MAX
end_ifdef

begin_undef
undef|#
directive|undef
name|ULLONG_MAX
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(ULLONG_MAX) */
end_comment

begin_define
define|#
directive|define
name|ULLONG_MAX
value|ULONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LONG_LONG_INT */
end_comment

begin_comment
comment|/* Support for uintmax_t.  We also need UINTMAX_MAX. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UINTMAX_T
end_ifdef

begin_undef
undef|#
directive|undef
name|UINTMAX_T
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(UINTMAX_T) */
end_comment

begin_if
if|#
directive|if
name|HAVE_UINTMAX_T
operator|||
name|defined
argument_list|(
name|uintmax_t
argument_list|)
end_if

begin_define
define|#
directive|define
name|UINTMAX_T
value|uintmax_t
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|UINTMAX_MAX
end_ifndef

begin_define
define|#
directive|define
name|UINTMAX_MAX
value|ULLONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(UINTMAX_MAX) */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UINTMAX_T
value|ULLONG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UINTMAX_MAX
end_ifdef

begin_undef
undef|#
directive|undef
name|UINTMAX_MAX
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(UINTMAX_MAX) */
end_comment

begin_define
define|#
directive|define
name|UINTMAX_MAX
value|ULLONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UINTMAX_T || defined(uintmax_t) */
end_comment

begin_comment
comment|/* Support for long double. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LDOUBLE
end_ifndef

begin_if
if|#
directive|if
name|HAVE_LONG_DOUBLE
end_if

begin_define
define|#
directive|define
name|LDOUBLE
value|long double
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LDOUBLE
value|double
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LONG_DOUBLE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(LDOUBLE) */
end_comment

begin_comment
comment|/* Support for long long int. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLONG
end_ifndef

begin_if
if|#
directive|if
name|HAVE_LONG_LONG_INT
end_if

begin_define
define|#
directive|define
name|LLONG
value|long long int
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LLONG
value|long int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LONG_LONG_INT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(LLONG) */
end_comment

begin_comment
comment|/* Support for intmax_t. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTMAX_T
end_ifndef

begin_if
if|#
directive|if
name|HAVE_INTMAX_T
operator|||
name|defined
argument_list|(
name|intmax_t
argument_list|)
end_if

begin_define
define|#
directive|define
name|INTMAX_T
value|intmax_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INTMAX_T
value|LLONG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_INTMAX_T || defined(intmax_t) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(INTMAX_T) */
end_comment

begin_comment
comment|/* Support for uintptr_t. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UINTPTR_T
end_ifndef

begin_if
if|#
directive|if
name|HAVE_UINTPTR_T
operator|||
name|defined
argument_list|(
name|uintptr_t
argument_list|)
end_if

begin_define
define|#
directive|define
name|UINTPTR_T
value|uintptr_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UINTPTR_T
value|unsigned long int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UINTPTR_T || defined(uintptr_t) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(UINTPTR_T) */
end_comment

begin_comment
comment|/* Support for ptrdiff_t. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_T
end_ifndef

begin_if
if|#
directive|if
name|HAVE_PTRDIFF_T
operator|||
name|defined
argument_list|(
name|ptrdiff_t
argument_list|)
end_if

begin_define
define|#
directive|define
name|PTRDIFF_T
value|ptrdiff_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTRDIFF_T
value|long int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PTRDIFF_T || defined(ptrdiff_t) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(PTRDIFF_T) */
end_comment

begin_comment
comment|/*  * We need an unsigned integer type corresponding to ptrdiff_t (cf. C99:  * 7.19.6.1, 7).  However, we'll simply use PTRDIFF_T and convert it to an  * unsigned type if necessary.  This should work just fine in practice.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UPTRDIFF_T
end_ifndef

begin_define
define|#
directive|define
name|UPTRDIFF_T
value|PTRDIFF_T
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(UPTRDIFF_T) */
end_comment

begin_comment
comment|/*  * We need a signed integer type corresponding to size_t (cf. C99: 7.19.6.1, 7).  * However, we'll simply use size_t and convert it to a signed type if  * necessary.  This should work just fine in practice.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SSIZE_T
end_ifndef

begin_define
define|#
directive|define
name|SSIZE_T
value|size_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(SSIZE_T) */
end_comment

begin_comment
comment|/* Either ERANGE or E2BIG should be available everywhere. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ERANGE
end_ifndef

begin_define
define|#
directive|define
name|ERANGE
value|E2BIG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(ERANGE) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EOVERFLOW
end_ifndef

begin_define
define|#
directive|define
name|EOVERFLOW
value|ERANGE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(EOVERFLOW) */
end_comment

begin_comment
comment|/*  * Buffer size to hold the octal string representation of UINT128_MAX without  * nul-termination ("3777777777777777777777777777777777777777777").  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAX_CONVERT_LENGTH
end_ifdef

begin_undef
undef|#
directive|undef
name|MAX_CONVERT_LENGTH
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(MAX_CONVERT_LENGTH) */
end_comment

begin_define
define|#
directive|define
name|MAX_CONVERT_LENGTH
value|43
end_define

begin_comment
comment|/* Format read states. */
end_comment

begin_define
define|#
directive|define
name|PRINT_S_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|PRINT_S_FLAGS
value|1
end_define

begin_define
define|#
directive|define
name|PRINT_S_WIDTH
value|2
end_define

begin_define
define|#
directive|define
name|PRINT_S_DOT
value|3
end_define

begin_define
define|#
directive|define
name|PRINT_S_PRECISION
value|4
end_define

begin_define
define|#
directive|define
name|PRINT_S_MOD
value|5
end_define

begin_define
define|#
directive|define
name|PRINT_S_CONV
value|6
end_define

begin_comment
comment|/* Format flags. */
end_comment

begin_define
define|#
directive|define
name|PRINT_F_MINUS
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|PRINT_F_PLUS
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|PRINT_F_SPACE
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|PRINT_F_NUM
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|PRINT_F_ZERO
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|PRINT_F_QUOTE
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|PRINT_F_UP
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|PRINT_F_UNSIGNED
value|(1<< 7)
end_define

begin_define
define|#
directive|define
name|PRINT_F_TYPE_G
value|(1<< 8)
end_define

begin_define
define|#
directive|define
name|PRINT_F_TYPE_E
value|(1<< 9)
end_define

begin_comment
comment|/* Conversion flags. */
end_comment

begin_define
define|#
directive|define
name|PRINT_C_CHAR
value|1
end_define

begin_define
define|#
directive|define
name|PRINT_C_SHORT
value|2
end_define

begin_define
define|#
directive|define
name|PRINT_C_LONG
value|3
end_define

begin_define
define|#
directive|define
name|PRINT_C_LLONG
value|4
end_define

begin_define
define|#
directive|define
name|PRINT_C_LDOUBLE
value|5
end_define

begin_define
define|#
directive|define
name|PRINT_C_SIZE
value|6
end_define

begin_define
define|#
directive|define
name|PRINT_C_PTRDIFF
value|7
end_define

begin_define
define|#
directive|define
name|PRINT_C_INTMAX
value|8
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x>= y) ? x : y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(MAX) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHARTOINT
end_ifndef

begin_define
define|#
directive|define
name|CHARTOINT
parameter_list|(
name|ch
parameter_list|)
value|(ch - '0')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(CHARTOINT) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISDIGIT
end_ifndef

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|ch
parameter_list|)
value|('0'<= (unsigned char)ch&& (unsigned char)ch<= '9')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(ISDIGIT) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISNAN
end_ifndef

begin_define
define|#
directive|define
name|ISNAN
parameter_list|(
name|x
parameter_list|)
value|(x != x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(ISNAN) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISINF
end_ifndef

begin_define
define|#
directive|define
name|ISINF
parameter_list|(
name|x
parameter_list|)
value|(x != 0.0&& x + x == x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(ISINF) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OUTCHAR
end_ifdef

begin_undef
undef|#
directive|undef
name|OUTCHAR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(OUTCHAR) */
end_comment

begin_define
define|#
directive|define
name|OUTCHAR
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|size
parameter_list|,
name|ch
parameter_list|)
define|\
value|do {                                                                         \ 	if (len + 1< size)                                                  \ 		str[len] = ch;                                               \ 	(len)++;                                                             \ } while (
comment|/* CONSTCOND */
value|0)
end_define

begin_function_decl
specifier|static
name|void
name|fmtstr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtint
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|INTMAX_T
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtflt
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|LDOUBLE
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printsep
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getnumsep
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getexponent
parameter_list|(
name|LDOUBLE
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|convert
parameter_list|(
name|UINTMAX_T
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|UINTMAX_T
name|cast
parameter_list|(
name|LDOUBLE
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|UINTMAX_T
name|myround
parameter_list|(
name|LDOUBLE
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LDOUBLE
name|mypow10
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rpl_vsnprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|rpl_vsnprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|LDOUBLE
name|fvalue
decl_stmt|;
name|INTMAX_T
name|value
decl_stmt|;
name|unsigned
name|char
name|cvalue
decl_stmt|;
specifier|const
name|char
modifier|*
name|strvalue
decl_stmt|;
name|INTMAX_T
modifier|*
name|intmaxptr
decl_stmt|;
name|PTRDIFF_T
modifier|*
name|ptrdiffptr
decl_stmt|;
name|SSIZE_T
modifier|*
name|sizeptr
decl_stmt|;
name|LLONG
modifier|*
name|llongptr
decl_stmt|;
name|long
name|int
modifier|*
name|longptr
decl_stmt|;
name|int
modifier|*
name|intptr
decl_stmt|;
name|short
name|int
modifier|*
name|shortptr
decl_stmt|;
name|signed
name|char
modifier|*
name|charptr
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|base
init|=
literal|0
decl_stmt|;
name|int
name|cflags
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|;
name|int
name|precision
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|state
init|=
name|PRINT_S_DEFAULT
decl_stmt|;
name|char
name|ch
init|=
operator|*
name|format
operator|++
decl_stmt|;
comment|/* 	 * C99 says: "If `n' is zero, nothing is written, and `s' may be a null 	 * pointer." (7.19.6.5, 2)  We're forgiving and allow a NULL pointer 	 * even if a size larger than zero was specified.  At least NetBSD's 	 * snprintf(3) does the same, as well as other versions of this file. 	 * (Though some of these versions will write to a non-NULL buffer even 	 * if a size of zero was specified, which violates the standard.) 	 */
if|if
condition|(
name|str
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
name|size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PRINT_S_DEFAULT
case|:
if|if
condition|(
name|ch
operator|==
literal|'%'
condition|)
name|state
operator|=
name|PRINT_S_FLAGS
expr_stmt|;
else|else
name|OUTCHAR
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|size
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
name|PRINT_S_FLAGS
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
name|flags
operator||=
name|PRINT_F_MINUS
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|flags
operator||=
name|PRINT_F_PLUS
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|flags
operator||=
name|PRINT_F_SPACE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|flags
operator||=
name|PRINT_F_NUM
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|flags
operator||=
name|PRINT_F_ZERO
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
comment|/* SUSv2 flag (not in C99). */
name|flags
operator||=
name|PRINT_F_QUOTE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
name|state
operator|=
name|PRINT_S_WIDTH
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PRINT_S_WIDTH
case|:
if|if
condition|(
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|ch
operator|=
name|CHARTOINT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
operator|(
name|INT_MAX
operator|-
name|ch
operator|)
operator|/
literal|10
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|width
operator|=
literal|10
operator|*
name|width
operator|+
name|ch
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
comment|/* 				 * C99 says: "A negative field width argument is 				 * taken as a `-' flag followed by a positive 				 * field width." (7.19.6.1, 5) 				 */
if|if
condition|(
operator|(
name|width
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|flags
operator||=
name|PRINT_F_MINUS
expr_stmt|;
name|width
operator|=
operator|-
name|width
expr_stmt|;
block|}
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|PRINT_S_DOT
expr_stmt|;
block|}
else|else
name|state
operator|=
name|PRINT_S_DOT
expr_stmt|;
break|break;
case|case
name|PRINT_S_DOT
case|:
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|state
operator|=
name|PRINT_S_PRECISION
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
else|else
name|state
operator|=
name|PRINT_S_MOD
expr_stmt|;
break|break;
case|case
name|PRINT_S_PRECISION
case|:
if|if
condition|(
name|precision
operator|==
operator|-
literal|1
condition|)
name|precision
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|ch
operator|=
name|CHARTOINT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|precision
operator|>
operator|(
name|INT_MAX
operator|-
name|ch
operator|)
operator|/
literal|10
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|precision
operator|=
literal|10
operator|*
name|precision
operator|+
name|ch
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
comment|/* 				 * C99 says: "A negative precision argument is 				 * taken as if the precision were omitted." 				 * (7.19.6.1, 5) 				 */
if|if
condition|(
operator|(
name|precision
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|precision
operator|=
operator|-
literal|1
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|PRINT_S_MOD
expr_stmt|;
block|}
else|else
name|state
operator|=
name|PRINT_S_MOD
expr_stmt|;
break|break;
case|case
name|PRINT_S_MOD
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'h'
case|:
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'h'
condition|)
block|{
comment|/* It's a char. */
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|cflags
operator|=
name|PRINT_C_CHAR
expr_stmt|;
block|}
else|else
name|cflags
operator|=
name|PRINT_C_SHORT
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'l'
condition|)
block|{
comment|/* It's a long long. */
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|cflags
operator|=
name|PRINT_C_LLONG
expr_stmt|;
block|}
else|else
name|cflags
operator|=
name|PRINT_C_LONG
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|cflags
operator|=
name|PRINT_C_LDOUBLE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|cflags
operator|=
name|PRINT_C_INTMAX
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|cflags
operator|=
name|PRINT_C_PTRDIFF
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|cflags
operator|=
name|PRINT_C_SIZE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|PRINT_S_CONV
expr_stmt|;
break|break;
case|case
name|PRINT_S_CONV
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* FALLTHROUGH */
case|case
literal|'i'
case|:
switch|switch
condition|(
name|cflags
condition|)
block|{
case|case
name|PRINT_C_CHAR
case|:
name|value
operator|=
operator|(
name|signed
name|char
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_SHORT
case|:
name|value
operator|=
operator|(
name|short
name|int
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_LONG
case|:
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long int
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_LLONG
case|:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LLONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_SIZE
case|:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|SSIZE_T
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_INTMAX
case|:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|INTMAX_T
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_PTRDIFF
case|:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|PTRDIFF_T
argument_list|)
expr_stmt|;
break|break;
default|default:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
block|}
name|fmtint
argument_list|(
name|str
argument_list|,
operator|&
name|len
argument_list|,
name|size
argument_list|,
name|value
argument_list|,
literal|10
argument_list|,
name|width
argument_list|,
name|precision
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|flags
operator||=
name|PRINT_F_UP
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'x'
case|:
name|base
operator|=
literal|16
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'o'
case|:
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|base
operator|=
literal|8
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'u'
case|:
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|base
operator|=
literal|10
expr_stmt|;
name|flags
operator||=
name|PRINT_F_UNSIGNED
expr_stmt|;
switch|switch
condition|(
name|cflags
condition|)
block|{
case|case
name|PRINT_C_CHAR
case|:
name|value
operator|=
operator|(
name|unsigned
name|char
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_SHORT
case|:
name|value
operator|=
operator|(
name|unsigned
name|short
name|int
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_LONG
case|:
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_LLONG
case|:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|ULLONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_SIZE
case|:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_INTMAX
case|:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|UINTMAX_T
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRINT_C_PTRDIFF
case|:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|UPTRDIFF_T
argument_list|)
expr_stmt|;
break|break;
default|default:
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
break|break;
block|}
name|fmtint
argument_list|(
name|str
argument_list|,
operator|&
name|len
argument_list|,
name|size
argument_list|,
name|value
argument_list|,
name|base
argument_list|,
name|width
argument_list|,
name|precision
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* Not yet supported, we'll use "%F". */
comment|/* FALLTHROUGH */
case|case
literal|'F'
case|:
name|flags
operator||=
name|PRINT_F_UP
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'a'
case|:
comment|/* Not yet supported, we'll use "%f". */
comment|/* FALLTHROUGH */
case|case
literal|'f'
case|:
if|if
condition|(
name|cflags
operator|==
name|PRINT_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LDOUBLE
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|fmtflt
argument_list|(
name|str
argument_list|,
operator|&
name|len
argument_list|,
name|size
argument_list|,
name|fvalue
argument_list|,
name|width
argument_list|,
name|precision
argument_list|,
name|flags
argument_list|,
operator|&
name|overflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
literal|'E'
case|:
name|flags
operator||=
name|PRINT_F_UP
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'e'
case|:
name|flags
operator||=
name|PRINT_F_TYPE_E
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|PRINT_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LDOUBLE
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|fmtflt
argument_list|(
name|str
argument_list|,
operator|&
name|len
argument_list|,
name|size
argument_list|,
name|fvalue
argument_list|,
name|width
argument_list|,
name|precision
argument_list|,
name|flags
argument_list|,
operator|&
name|overflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
literal|'G'
case|:
name|flags
operator||=
name|PRINT_F_UP
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'g'
case|:
name|flags
operator||=
name|PRINT_F_TYPE_G
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|PRINT_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LDOUBLE
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
comment|/* 				 * If the precision is zero, it is treated as 				 * one (cf. C99: 7.19.6.1, 8). 				 */
if|if
condition|(
name|precision
operator|==
literal|0
condition|)
name|precision
operator|=
literal|1
expr_stmt|;
name|fmtflt
argument_list|(
name|str
argument_list|,
operator|&
name|len
argument_list|,
name|size
argument_list|,
name|fvalue
argument_list|,
name|width
argument_list|,
name|precision
argument_list|,
name|flags
argument_list|,
operator|&
name|overflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
literal|'c'
case|:
name|cvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|OUTCHAR
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|size
argument_list|,
name|cvalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|strvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|fmtstr
argument_list|(
name|str
argument_list|,
operator|&
name|len
argument_list|,
name|size
argument_list|,
name|strvalue
argument_list|,
name|width
argument_list|,
name|precision
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* 				 * C99 says: "The value of the pointer is 				 * converted to a sequence of printing 				 * characters, in an implementation-defined 				 * manner." (C99: 7.19.6.1, 8) 				 */
if|if
condition|(
operator|(
name|strvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|void
operator|*
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* 					 * We use the glibc format.  BSD prints 					 * "0x0", SysV "0". 					 */
name|fmtstr
argument_list|(
name|str
argument_list|,
operator|&
name|len
argument_list|,
name|size
argument_list|,
literal|"(nil)"
argument_list|,
name|width
argument_list|,
operator|-
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 					 * We use the BSD/glibc format.  SysV 					 * omits the "0x" prefix (which we emit 					 * using the PRINT_F_NUM flag). 					 */
name|flags
operator||=
name|PRINT_F_NUM
expr_stmt|;
name|flags
operator||=
name|PRINT_F_UNSIGNED
expr_stmt|;
name|fmtint
argument_list|(
name|str
argument_list|,
operator|&
name|len
argument_list|,
name|size
argument_list|,
operator|(
name|UINTPTR_T
operator|)
name|strvalue
argument_list|,
literal|16
argument_list|,
name|width
argument_list|,
name|precision
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
switch|switch
condition|(
name|cflags
condition|)
block|{
case|case
name|PRINT_C_CHAR
case|:
name|charptr
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|signed char *
argument_list|)
expr_stmt|;
operator|*
name|charptr
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|PRINT_C_SHORT
case|:
name|shortptr
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|short int *
argument_list|)
expr_stmt|;
operator|*
name|shortptr
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|PRINT_C_LONG
case|:
name|longptr
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long int *
argument_list|)
expr_stmt|;
operator|*
name|longptr
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|PRINT_C_LLONG
case|:
name|llongptr
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LLONG
operator|*
argument_list|)
expr_stmt|;
operator|*
name|llongptr
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|PRINT_C_SIZE
case|:
comment|/* 					 * C99 says that with the "z" length 					 * modifier, "a following `n' conversion 					 * specifier applies to a pointer to a 					 * signed integer type corresponding to 					 * size_t argument." (7.19.6.1, 7) 					 */
name|sizeptr
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|SSIZE_T
operator|*
argument_list|)
expr_stmt|;
operator|*
name|sizeptr
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|PRINT_C_INTMAX
case|:
name|intmaxptr
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|INTMAX_T
operator|*
argument_list|)
expr_stmt|;
operator|*
name|intmaxptr
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|PRINT_C_PTRDIFF
case|:
name|ptrdiffptr
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|PTRDIFF_T
operator|*
argument_list|)
expr_stmt|;
operator|*
name|ptrdiffptr
operator|=
name|len
expr_stmt|;
break|break;
default|default:
name|intptr
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
name|intptr
operator|=
name|len
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'%'
case|:
comment|/* Print a "%" character verbatim. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|size
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Skip other characters. */
break|break;
block|}
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|PRINT_S_DEFAULT
expr_stmt|;
name|base
operator|=
name|cflags
operator|=
name|flags
operator|=
name|width
operator|=
literal|0
expr_stmt|;
name|precision
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|out
label|:
if|if
condition|(
name|len
operator|<
name|size
condition|)
name|str
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|str
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|overflow
operator|||
name|len
operator|>=
name|INT_MAX
condition|)
block|{
name|errno
operator|=
name|overflow
condition|?
name|EOVERFLOW
else|:
name|ERANGE
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|int
operator|)
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fmtstr
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|precision
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|padlen
decl_stmt|,
name|strln
decl_stmt|;
comment|/* Amount to pad. */
name|int
name|noprecision
init|=
operator|(
name|precision
operator|==
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
comment|/* We're forgiving. */
name|value
operator|=
literal|"(null)"
expr_stmt|;
comment|/* If a precision was specified, don't read the string past it. */
for|for
control|(
name|strln
operator|=
literal|0
init|;
name|value
index|[
name|strln
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|noprecision
operator|||
name|strln
operator|<
name|precision
operator|)
condition|;
name|strln
operator|++
control|)
continue|continue;
if|if
condition|(
operator|(
name|padlen
operator|=
name|width
operator|-
name|strln
operator|)
operator|<
literal|0
condition|)
name|padlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PRINT_F_MINUS
condition|)
comment|/* Left justify. */
name|padlen
operator|=
operator|-
name|padlen
expr_stmt|;
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
comment|/* Leading spaces. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|padlen
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|value
operator|!=
literal|'\0'
operator|&&
operator|(
name|noprecision
operator|||
name|precision
operator|--
operator|>
literal|0
operator|)
condition|)
block|{
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
operator|*
name|value
argument_list|)
expr_stmt|;
name|value
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|padlen
operator|<
literal|0
condition|)
block|{
comment|/* Trailing spaces. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|padlen
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fmtint
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|size_t
name|size
parameter_list|,
name|INTMAX_T
name|value
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|precision
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|UINTMAX_T
name|uvalue
decl_stmt|;
name|char
name|iconvert
index|[
name|MAX_CONVERT_LENGTH
index|]
decl_stmt|;
name|char
name|sign
init|=
literal|0
decl_stmt|;
name|char
name|hexprefix
init|=
literal|0
decl_stmt|;
name|int
name|spadlen
init|=
literal|0
decl_stmt|;
comment|/* Amount to space pad. */
name|int
name|zpadlen
init|=
literal|0
decl_stmt|;
comment|/* Amount to zero pad. */
name|int
name|pos
decl_stmt|;
name|int
name|separators
init|=
operator|(
name|flags
operator|&
name|PRINT_F_QUOTE
operator|)
decl_stmt|;
name|int
name|noprecision
init|=
operator|(
name|precision
operator|==
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|PRINT_F_UNSIGNED
condition|)
name|uvalue
operator|=
name|value
expr_stmt|;
else|else
block|{
name|uvalue
operator|=
operator|(
name|value
operator|>=
literal|0
operator|)
condition|?
name|value
else|:
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|sign
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|PRINT_F_PLUS
condition|)
comment|/* Do a sign. */
name|sign
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|PRINT_F_SPACE
condition|)
name|sign
operator|=
literal|' '
expr_stmt|;
block|}
name|pos
operator|=
name|convert
argument_list|(
name|uvalue
argument_list|,
name|iconvert
argument_list|,
sizeof|sizeof
argument_list|(
name|iconvert
argument_list|)
argument_list|,
name|base
argument_list|,
name|flags
operator|&
name|PRINT_F_UP
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PRINT_F_NUM
operator|&&
name|uvalue
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * C99 says: "The result is converted to an `alternative form'. 		 * For `o' conversion, it increases the precision, if and only 		 * if necessary, to force the first digit of the result to be a 		 * zero (if the value and precision are both 0, a single 0 is 		 * printed).  For `x' (or `X') conversion, a nonzero result has 		 * `0x' (or `0X') prefixed to it." (7.19.6.1, 6) 		 */
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
if|if
condition|(
name|precision
operator|<=
name|pos
condition|)
name|precision
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|hexprefix
operator|=
operator|(
name|flags
operator|&
name|PRINT_F_UP
operator|)
condition|?
literal|'X'
else|:
literal|'x'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|separators
condition|)
comment|/* Get the number of group separators we'll print. */
name|separators
operator|=
name|getnumsep
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|zpadlen
operator|=
name|precision
operator|-
name|pos
operator|-
name|separators
expr_stmt|;
name|spadlen
operator|=
name|width
comment|/* Minimum field width. */
operator|-
name|separators
comment|/* Number of separators. */
operator|-
name|MAX
argument_list|(
name|precision
argument_list|,
name|pos
argument_list|)
comment|/* Number of integer digits. */
operator|-
operator|(
operator|(
name|sign
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
comment|/* Will we print a sign? */
operator|-
operator|(
operator|(
name|hexprefix
operator|!=
literal|0
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Will we print a prefix? */
if|if
condition|(
name|zpadlen
operator|<
literal|0
condition|)
name|zpadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spadlen
operator|<
literal|0
condition|)
name|spadlen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * C99 says: "If the `0' and `-' flags both appear, the `0' flag is 	 * ignored.  For `d', `i', `o', `u', `x', and `X' conversions, if a 	 * precision is specified, the `0' flag is ignored." (7.19.6.1, 6) 	 */
if|if
condition|(
name|flags
operator|&
name|PRINT_F_MINUS
condition|)
comment|/* Left justify. */
name|spadlen
operator|=
operator|-
name|spadlen
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|PRINT_F_ZERO
operator|&&
name|noprecision
condition|)
block|{
name|zpadlen
operator|+=
name|spadlen
expr_stmt|;
name|spadlen
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|spadlen
operator|>
literal|0
condition|)
block|{
comment|/* Leading spaces. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|spadlen
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|sign
operator|!=
literal|0
condition|)
comment|/* Sign. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
name|sign
argument_list|)
expr_stmt|;
if|if
condition|(
name|hexprefix
operator|!=
literal|0
condition|)
block|{
comment|/* A "0x" or "0X" prefix. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
name|hexprefix
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
comment|/* Leading zeros. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|zpadlen
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|pos
operator|>
literal|0
condition|)
block|{
comment|/* The actual digits. */
name|pos
operator|--
expr_stmt|;
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
name|iconvert
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|separators
operator|>
literal|0
operator|&&
name|pos
operator|>
literal|0
operator|&&
name|pos
operator|%
literal|3
operator|==
literal|0
condition|)
name|printsep
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|spadlen
operator|<
literal|0
condition|)
block|{
comment|/* Trailing spaces. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|spadlen
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fmtflt
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|size_t
name|size
parameter_list|,
name|LDOUBLE
name|fvalue
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|precision
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|overflow
parameter_list|)
block|{
name|LDOUBLE
name|ufvalue
decl_stmt|;
name|UINTMAX_T
name|intpart
decl_stmt|;
name|UINTMAX_T
name|fracpart
decl_stmt|;
name|UINTMAX_T
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|infnan
init|=
name|NULL
decl_stmt|;
name|char
name|iconvert
index|[
name|MAX_CONVERT_LENGTH
index|]
decl_stmt|;
name|char
name|fconvert
index|[
name|MAX_CONVERT_LENGTH
index|]
decl_stmt|;
name|char
name|econvert
index|[
literal|4
index|]
decl_stmt|;
comment|/* "e-12" (without nul-termination). */
name|char
name|esign
init|=
literal|0
decl_stmt|;
name|char
name|sign
init|=
literal|0
decl_stmt|;
name|int
name|leadfraczeros
init|=
literal|0
decl_stmt|;
name|int
name|exponent
init|=
literal|0
decl_stmt|;
name|int
name|emitpoint
init|=
literal|0
decl_stmt|;
name|int
name|omitzeros
init|=
literal|0
decl_stmt|;
name|int
name|omitcount
init|=
literal|0
decl_stmt|;
name|int
name|padlen
init|=
literal|0
decl_stmt|;
name|int
name|epos
init|=
literal|0
decl_stmt|;
name|int
name|fpos
init|=
literal|0
decl_stmt|;
name|int
name|ipos
init|=
literal|0
decl_stmt|;
name|int
name|separators
init|=
operator|(
name|flags
operator|&
name|PRINT_F_QUOTE
operator|)
decl_stmt|;
name|int
name|estyle
init|=
operator|(
name|flags
operator|&
name|PRINT_F_TYPE_E
operator|)
decl_stmt|;
if|#
directive|if
name|HAVE_LOCALECONV
operator|&&
name|HAVE_LCONV_DECIMAL_POINT
name|struct
name|lconv
modifier|*
name|lc
init|=
name|localeconv
argument_list|()
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_LOCALECONV&& HAVE_LCONV_DECIMAL_POINT */
comment|/* 	 * AIX' man page says the default is 0, but C99 and at least Solaris' 	 * and NetBSD's man pages say the default is 6, and sprintf(3) on AIX 	 * defaults to 6. 	 */
if|if
condition|(
name|precision
operator|==
operator|-
literal|1
condition|)
name|precision
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|fvalue
operator|<
literal|0.0
condition|)
name|sign
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|PRINT_F_PLUS
condition|)
comment|/* Do a sign. */
name|sign
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|PRINT_F_SPACE
condition|)
name|sign
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|ISNAN
argument_list|(
name|fvalue
argument_list|)
condition|)
name|infnan
operator|=
operator|(
name|flags
operator|&
name|PRINT_F_UP
operator|)
condition|?
literal|"NAN"
else|:
literal|"nan"
expr_stmt|;
elseif|else
if|if
condition|(
name|ISINF
argument_list|(
name|fvalue
argument_list|)
condition|)
name|infnan
operator|=
operator|(
name|flags
operator|&
name|PRINT_F_UP
operator|)
condition|?
literal|"INF"
else|:
literal|"inf"
expr_stmt|;
if|if
condition|(
name|infnan
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sign
operator|!=
literal|0
condition|)
name|iconvert
index|[
name|ipos
operator|++
index|]
operator|=
name|sign
expr_stmt|;
while|while
condition|(
operator|*
name|infnan
operator|!=
literal|'\0'
condition|)
name|iconvert
index|[
name|ipos
operator|++
index|]
operator|=
operator|*
name|infnan
operator|++
expr_stmt|;
name|fmtstr
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|size
argument_list|,
name|iconvert
argument_list|,
name|width
argument_list|,
name|ipos
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* "%e" (or "%E") or "%g" (or "%G") conversion. */
if|if
condition|(
name|flags
operator|&
name|PRINT_F_TYPE_E
operator|||
name|flags
operator|&
name|PRINT_F_TYPE_G
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PRINT_F_TYPE_G
condition|)
block|{
comment|/* 			 * For "%g" (and "%G") conversions, the precision 			 * specifies the number of significant digits, which 			 * includes the digits in the integer part.  The 			 * conversion will or will not be using "e-style" (like 			 * "%e" or "%E" conversions) depending on the precision 			 * and on the exponent.  However, the exponent can be 			 * affected by rounding the converted value, so we'll 			 * leave this decision for later.  Until then, we'll 			 * assume that we're going to do an "e-style" conversion 			 * (in order to get the exponent calculated).  For 			 * "e-style", the precision must be decremented by one. 			 */
name|precision
operator|--
expr_stmt|;
comment|/* 			 * For "%g" (and "%G") conversions, trailing zeros are 			 * removed from the fractional portion of the result 			 * unless the "#" flag was specified. 			 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PRINT_F_NUM
operator|)
condition|)
name|omitzeros
operator|=
literal|1
expr_stmt|;
block|}
name|exponent
operator|=
name|getexponent
argument_list|(
name|fvalue
argument_list|)
expr_stmt|;
name|estyle
operator|=
literal|1
expr_stmt|;
block|}
name|again
label|:
comment|/* 	 * Sorry, we only support 9, 19, or 38 digits (that is, the number of 	 * digits of the 32-bit, the 64-bit, or the 128-bit UINTMAX_MAX value 	 * minus one) past the decimal point due to our conversion method. 	 */
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|UINTMAX_T
argument_list|)
condition|)
block|{
case|case
literal|16
case|:
if|if
condition|(
name|precision
operator|>
literal|38
condition|)
name|precision
operator|=
literal|38
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|precision
operator|>
literal|19
condition|)
name|precision
operator|=
literal|19
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|precision
operator|>
literal|9
condition|)
name|precision
operator|=
literal|9
expr_stmt|;
break|break;
block|}
name|ufvalue
operator|=
operator|(
name|fvalue
operator|>=
literal|0.0
operator|)
condition|?
name|fvalue
else|:
operator|-
name|fvalue
expr_stmt|;
if|if
condition|(
name|estyle
condition|)
comment|/* We want exactly one integer digit. */
name|ufvalue
operator|/=
name|mypow10
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intpart
operator|=
name|cast
argument_list|(
name|ufvalue
argument_list|)
operator|)
operator|==
name|UINTMAX_MAX
condition|)
block|{
operator|*
name|overflow
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 	 * Factor of ten with the number of digits needed for the fractional 	 * part.  For example, if the precision is 3, the mask will be 1000. 	 */
name|mask
operator|=
name|mypow10
argument_list|(
name|precision
argument_list|)
expr_stmt|;
comment|/* 	 * We "cheat" by converting the fractional part to integer by 	 * multiplying by a factor of ten. 	 */
if|if
condition|(
operator|(
name|fracpart
operator|=
name|myround
argument_list|(
name|mask
operator|*
operator|(
name|ufvalue
operator|-
name|intpart
operator|)
argument_list|)
operator|)
operator|>=
name|mask
condition|)
block|{
comment|/* 		 * For example, ufvalue = 2.99962, intpart = 2, and mask = 1000 		 * (because precision = 3).  Now, myround(1000 * 0.99962) will 		 * return 1000.  So, the integer part must be incremented by one 		 * and the fractional part must be set to zero. 		 */
name|intpart
operator|++
expr_stmt|;
name|fracpart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|estyle
operator|&&
name|intpart
operator|==
literal|10
condition|)
block|{
comment|/* 			 * The value was rounded up to ten, but we only want one 			 * integer digit if using "e-style".  So, the integer 			 * part must be set to one and the exponent must be 			 * incremented by one. 			 */
name|intpart
operator|=
literal|1
expr_stmt|;
name|exponent
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Now that we know the real exponent, we can check whether or not to 	 * use "e-style" for "%g" (and "%G") conversions.  If we don't need 	 * "e-style", the precision must be adjusted and the integer and 	 * fractional parts must be recalculated from the original value. 	 * 	 * C99 says: "Let P equal the precision if nonzero, 6 if the precision 	 * is omitted, or 1 if the precision is zero.  Then, if a conversion 	 * with style `E' would have an exponent of X: 	 * 	 * - if P> X>= -4, the conversion is with style `f' (or `F') and 	 *   precision P - (X + 1). 	 * 	 * - otherwise, the conversion is with style `e' (or `E') and precision 	 *   P - 1." (7.19.6.1, 8) 	 * 	 * Note that we had decremented the precision by one. 	 */
if|if
condition|(
name|flags
operator|&
name|PRINT_F_TYPE_G
operator|&&
name|estyle
operator|&&
name|precision
operator|+
literal|1
operator|>
name|exponent
operator|&&
name|exponent
operator|>=
operator|-
literal|4
condition|)
block|{
name|precision
operator|-=
name|exponent
expr_stmt|;
name|estyle
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|estyle
condition|)
block|{
if|if
condition|(
name|exponent
operator|<
literal|0
condition|)
block|{
name|exponent
operator|=
operator|-
name|exponent
expr_stmt|;
name|esign
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
name|esign
operator|=
literal|'+'
expr_stmt|;
comment|/* 		 * Convert the exponent.  The sizeof(econvert) is 4.  So, the 		 * econvert buffer can hold e.g. "e+99" and "e-99".  We don't 		 * support an exponent which contains more than two digits. 		 * Therefore, the following stores are safe. 		 */
name|epos
operator|=
name|convert
argument_list|(
name|exponent
argument_list|,
name|econvert
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * C99 says: "The exponent always contains at least two digits, 		 * and only as many more digits as necessary to represent the 		 * exponent." (7.19.6.1, 8) 		 */
if|if
condition|(
name|epos
operator|==
literal|1
condition|)
name|econvert
index|[
name|epos
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
name|econvert
index|[
name|epos
operator|++
index|]
operator|=
name|esign
expr_stmt|;
name|econvert
index|[
name|epos
operator|++
index|]
operator|=
operator|(
name|flags
operator|&
name|PRINT_F_UP
operator|)
condition|?
literal|'E'
else|:
literal|'e'
expr_stmt|;
block|}
comment|/* Convert the integer part and the fractional part. */
name|ipos
operator|=
name|convert
argument_list|(
name|intpart
argument_list|,
name|iconvert
argument_list|,
sizeof|sizeof
argument_list|(
name|iconvert
argument_list|)
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fracpart
operator|!=
literal|0
condition|)
comment|/* convert() would return 1 if fracpart == 0. */
name|fpos
operator|=
name|convert
argument_list|(
name|fracpart
argument_list|,
name|fconvert
argument_list|,
sizeof|sizeof
argument_list|(
name|fconvert
argument_list|)
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|leadfraczeros
operator|=
name|precision
operator|-
name|fpos
expr_stmt|;
if|if
condition|(
name|omitzeros
condition|)
block|{
if|if
condition|(
name|fpos
operator|>
literal|0
condition|)
comment|/* Omit trailing fractional part zeros. */
while|while
condition|(
name|omitcount
operator|<
name|fpos
operator|&&
name|fconvert
index|[
name|omitcount
index|]
operator|==
literal|'0'
condition|)
name|omitcount
operator|++
expr_stmt|;
else|else
block|{
comment|/* The fractional part is zero, omit it completely. */
name|omitcount
operator|=
name|precision
expr_stmt|;
name|leadfraczeros
operator|=
literal|0
expr_stmt|;
block|}
name|precision
operator|-=
name|omitcount
expr_stmt|;
block|}
comment|/* 	 * Print a decimal point if either the fractional part is non-zero 	 * and/or the "#" flag was specified. 	 */
if|if
condition|(
name|precision
operator|>
literal|0
operator|||
name|flags
operator|&
name|PRINT_F_NUM
condition|)
name|emitpoint
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|separators
condition|)
comment|/* Get the number of group separators we'll print. */
name|separators
operator|=
name|getnumsep
argument_list|(
name|ipos
argument_list|)
expr_stmt|;
name|padlen
operator|=
name|width
comment|/* Minimum field width. */
operator|-
name|ipos
comment|/* Number of integer digits. */
operator|-
name|epos
comment|/* Number of exponent characters. */
operator|-
name|precision
comment|/* Number of fractional digits. */
operator|-
name|separators
comment|/* Number of group separators. */
operator|-
operator|(
name|emitpoint
condition|?
literal|1
else|:
literal|0
operator|)
comment|/* Will we print a decimal point? */
operator|-
operator|(
operator|(
name|sign
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Will we print a sign character? */
if|if
condition|(
name|padlen
operator|<
literal|0
condition|)
name|padlen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * C99 says: "If the `0' and `-' flags both appear, the `0' flag is 	 * ignored." (7.19.6.1, 6) 	 */
if|if
condition|(
name|flags
operator|&
name|PRINT_F_MINUS
condition|)
comment|/* Left justifty. */
name|padlen
operator|=
operator|-
name|padlen
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|PRINT_F_ZERO
operator|&&
name|padlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sign
operator|!=
literal|0
condition|)
block|{
comment|/* Sign. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
comment|/* Leading zeros. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|padlen
operator|--
expr_stmt|;
block|}
block|}
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
comment|/* Leading spaces. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|padlen
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|sign
operator|!=
literal|0
condition|)
comment|/* Sign. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
name|sign
argument_list|)
expr_stmt|;
while|while
condition|(
name|ipos
operator|>
literal|0
condition|)
block|{
comment|/* Integer part. */
name|ipos
operator|--
expr_stmt|;
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
name|iconvert
index|[
name|ipos
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|separators
operator|>
literal|0
operator|&&
name|ipos
operator|>
literal|0
operator|&&
name|ipos
operator|%
literal|3
operator|==
literal|0
condition|)
name|printsep
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|emitpoint
condition|)
block|{
comment|/* Decimal point. */
if|#
directive|if
name|HAVE_LOCALECONV
operator|&&
name|HAVE_LCONV_DECIMAL_POINT
if|if
condition|(
name|lc
operator|->
name|decimal_point
operator|!=
name|NULL
operator|&&
operator|*
name|lc
operator|->
name|decimal_point
operator|!=
literal|'\0'
condition|)
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
operator|*
name|lc
operator|->
name|decimal_point
argument_list|)
expr_stmt|;
else|else
comment|/* We'll always print some decimal point character. */
endif|#
directive|endif
comment|/* HAVE_LOCALECONV&& HAVE_LCONV_DECIMAL_POINT */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|leadfraczeros
operator|>
literal|0
condition|)
block|{
comment|/* Leading fractional part zeros. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|leadfraczeros
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|fpos
operator|>
name|omitcount
condition|)
block|{
comment|/* The remaining fractional part. */
name|fpos
operator|--
expr_stmt|;
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
name|fconvert
index|[
name|fpos
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|epos
operator|>
literal|0
condition|)
block|{
comment|/* Exponent. */
name|epos
operator|--
expr_stmt|;
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
name|econvert
index|[
name|epos
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|padlen
operator|<
literal|0
condition|)
block|{
comment|/* Trailing spaces. */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|padlen
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|printsep
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|#
directive|if
name|HAVE_LOCALECONV
operator|&&
name|HAVE_LCONV_THOUSANDS_SEP
name|struct
name|lconv
modifier|*
name|lc
init|=
name|localeconv
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lc
operator|->
name|thousands_sep
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lc
operator|->
name|thousands_sep
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
name|lc
operator|->
name|thousands_sep
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_LOCALECONV&& HAVE_LCONV_THOUSANDS_SEP */
name|OUTCHAR
argument_list|(
name|str
argument_list|,
operator|*
name|len
argument_list|,
name|size
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|getnumsep
parameter_list|(
name|int
name|digits
parameter_list|)
block|{
name|int
name|separators
init|=
operator|(
name|digits
operator|-
operator|(
operator|(
name|digits
operator|%
literal|3
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator|/
literal|3
decl_stmt|;
if|#
directive|if
name|HAVE_LOCALECONV
operator|&&
name|HAVE_LCONV_THOUSANDS_SEP
name|int
name|strln
decl_stmt|;
name|struct
name|lconv
modifier|*
name|lc
init|=
name|localeconv
argument_list|()
decl_stmt|;
comment|/* We support an arbitrary separator length (including zero). */
if|if
condition|(
name|lc
operator|->
name|thousands_sep
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|strln
operator|=
literal|0
init|;
name|lc
operator|->
name|thousands_sep
index|[
name|strln
index|]
operator|!=
literal|'\0'
condition|;
name|strln
operator|++
control|)
continue|continue;
name|separators
operator|*=
name|strln
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_LOCALECONV&& HAVE_LCONV_THOUSANDS_SEP */
return|return
name|separators
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getexponent
parameter_list|(
name|LDOUBLE
name|value
parameter_list|)
block|{
name|LDOUBLE
name|tmp
init|=
operator|(
name|value
operator|>=
literal|0.0
operator|)
condition|?
name|value
else|:
operator|-
name|value
decl_stmt|;
name|int
name|exponent
init|=
literal|0
decl_stmt|;
comment|/* 	 * We check for 99> exponent> -99 in order to work around possible 	 * endless loops which could happen (at least) in the second loop (at 	 * least) if we're called with an infinite value.  However, we checked 	 * for infinity before calling this function using our ISINF() macro, so 	 * this might be somewhat paranoid. 	 */
while|while
condition|(
name|tmp
operator|<
literal|1.0
operator|&&
name|tmp
operator|>
literal|0.0
operator|&&
operator|--
name|exponent
operator|>
operator|-
literal|99
condition|)
name|tmp
operator|*=
literal|10
expr_stmt|;
while|while
condition|(
name|tmp
operator|>=
literal|10.0
operator|&&
operator|++
name|exponent
operator|<
literal|99
condition|)
name|tmp
operator|/=
literal|10
expr_stmt|;
return|return
name|exponent
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|convert
parameter_list|(
name|UINTMAX_T
name|value
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|caps
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digits
init|=
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
decl_stmt|;
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
comment|/* We return an unterminated buffer with the digits in reverse order. */
do|do
block|{
name|buf
index|[
name|pos
operator|++
index|]
operator|=
name|digits
index|[
name|value
operator|%
name|base
index|]
expr_stmt|;
name|value
operator|/=
name|base
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|!=
literal|0
operator|&&
name|pos
operator|<
name|size
condition|)
do|;
return|return
operator|(
name|int
operator|)
name|pos
return|;
block|}
end_function

begin_function
specifier|static
name|UINTMAX_T
name|cast
parameter_list|(
name|LDOUBLE
name|value
parameter_list|)
block|{
name|UINTMAX_T
name|result
decl_stmt|;
comment|/* 	 * We check for ">=" and not for ">" because if UINTMAX_MAX cannot be 	 * represented exactly as an LDOUBLE value (but is less than LDBL_MAX), 	 * it may be increased to the nearest higher representable value for the 	 * comparison (cf. C99: 6.3.1.4, 2).  It might then equal the LDOUBLE 	 * value although converting the latter to UINTMAX_T would overflow. 	 */
if|if
condition|(
name|value
operator|>=
name|UINTMAX_MAX
condition|)
return|return
name|UINTMAX_MAX
return|;
name|result
operator|=
name|value
expr_stmt|;
comment|/* 	 * At least on NetBSD/sparc64 3.0.2 and 4.99.30, casting long double to 	 * an integer type converts e.g. 1.9 to 2 instead of 1 (which violates 	 * the standard).  Sigh. 	 */
return|return
operator|(
name|result
operator|<=
name|value
operator|)
condition|?
name|result
else|:
name|result
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|UINTMAX_T
name|myround
parameter_list|(
name|LDOUBLE
name|value
parameter_list|)
block|{
name|UINTMAX_T
name|intpart
init|=
name|cast
argument_list|(
name|value
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|value
operator|-=
name|intpart
operator|)
operator|<
literal|0.5
operator|)
condition|?
name|intpart
else|:
name|intpart
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|LDOUBLE
name|mypow10
parameter_list|(
name|int
name|exponent
parameter_list|)
block|{
name|LDOUBLE
name|result
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|exponent
operator|>
literal|0
condition|)
block|{
name|result
operator|*=
literal|10
expr_stmt|;
name|exponent
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|exponent
operator|<
literal|0
condition|)
block|{
name|result
operator|/=
literal|10
expr_stmt|;
name|exponent
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HW_WANT_RPL_VSNPRINTF */
end_comment

begin_if
if|#
directive|if
name|HW_WANT_RPL_VASPRINTF
end_if

begin_if
if|#
directive|if
name|NEED_MYMEMCPY
end_if

begin_function
name|void
modifier|*
name|mymemcpy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|from
init|=
name|src
decl_stmt|;
name|char
modifier|*
name|to
init|=
name|dst
decl_stmt|;
comment|/* No need for optimization, we use this only to replace va_copy(3). */
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEED_MYMEMCPY */
end_comment

begin_function_decl
name|int
name|rpl_vasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|rpl_vasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|len
decl_stmt|;
name|va_list
name|aq
decl_stmt|;
name|VA_COPY
argument_list|(
name|aq
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|aq
argument_list|)
expr_stmt|;
name|VA_END_COPY
argument_list|(
name|aq
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
operator|(
operator|*
name|ret
operator|=
name|malloc
argument_list|(
name|size
operator|=
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|vsnprintf
argument_list|(
operator|*
name|ret
argument_list|,
name|size
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HW_WANT_RPL_VASPRINTF */
end_comment

begin_if
if|#
directive|if
name|HW_WANT_RPL_SNPRINTF
end_if

begin_if
if|#
directive|if
name|HAVE_STDARG_H
end_if

begin_function_decl
name|int
name|rpl_snprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|rpl_snprintf
argument_list|(
name|char
operator|*
name|str
argument_list|,
name|size_t
name|size
argument_list|,
specifier|const
name|char
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|int
name|rpl_snprintf
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
endif|#
directive|endif
comment|/* HAVE_STDARG_H */
block|{
if|#
directive|if
operator|!
name|HAVE_STDARG_H
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_STDARG_H */
name|va_list
name|ap
decl_stmt|;
name|int
name|len
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_SHIFT
argument_list|(
name|ap
argument_list|,
name|str
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|VA_SHIFT
argument_list|(
name|ap
argument_list|,
name|size
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|VA_SHIFT
argument_list|(
name|ap
argument_list|,
name|format
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|str
argument_list|,
name|size
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HW_WANT_RPL_SNPRINTF */
end_comment

begin_if
if|#
directive|if
name|HW_WANT_RPL_ASPRINTF
end_if

begin_if
if|#
directive|if
name|HAVE_STDARG_H
end_if

begin_function_decl
name|int
name|rpl_asprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|rpl_asprintf
argument_list|(
name|char
operator|*
operator|*
name|ret
argument_list|,
specifier|const
name|char
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|int
name|rpl_asprintf
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
endif|#
directive|endif
comment|/* HAVE_STDARG_H */
block|{
if|#
directive|if
operator|!
name|HAVE_STDARG_H
name|char
modifier|*
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_STDARG_H */
name|va_list
name|ap
decl_stmt|;
name|int
name|len
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_SHIFT
argument_list|(
name|ap
argument_list|,
name|ret
argument_list|,
name|char
operator|*
operator|*
argument_list|)
expr_stmt|;
name|VA_SHIFT
argument_list|(
name|ap
argument_list|,
name|format
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|vasprintf
argument_list|(
name|ret
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HW_WANT_RPL_ASPRINTF */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Dummy declaration to avoid empty translation unit warnings. */
end_comment

begin_function_decl
name|int
name|main
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HW_WANT_RPL_SNPRINTF || HW_WANT_RPL_VSNPRINTF || HW_WANT_RPL_ASPRINTF || [...] */
end_comment

begin_if
if|#
directive|if
name|TEST_SNPRINTF
end_if

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|float_fmt
index|[]
init|=
block|{
comment|/* "%E" and "%e" formats. */
if|#
directive|if
name|HAVE_LONG_LONG_INT
operator|&&
operator|!
name|OS_BSD
operator|&&
operator|!
name|OS_IRIX
literal|"%.16e"
block|,
literal|"%22.16e"
block|,
literal|"%022.16e"
block|,
literal|"%-22.16e"
block|,
literal|"%#+'022.16e"
block|,
endif|#
directive|endif
comment|/* HAVE_LONG_LONG_INT&& !OS_BSD&& !OS_IRIX */
literal|"foo|%#+0123.9E|bar"
block|,
literal|"%-123.9e"
block|,
literal|"%123.9e"
block|,
literal|"%+23.9e"
block|,
literal|"%+05.8e"
block|,
literal|"%-05.8e"
block|,
literal|"%05.8e"
block|,
literal|"%+5.8e"
block|,
literal|"%-5.8e"
block|,
literal|"% 5.8e"
block|,
literal|"%5.8e"
block|,
literal|"%+4.9e"
block|,
if|#
directive|if
operator|!
name|OS_LINUX
comment|/* glibc sometimes gets these wrong. */
literal|"%+#010.0e"
block|,
literal|"%#10.1e"
block|,
literal|"%10.5e"
block|,
literal|"% 10.5e"
block|,
literal|"%5.0e"
block|,
literal|"%5.e"
block|,
literal|"%#5.0e"
block|,
literal|"%#5.e"
block|,
literal|"%3.2e"
block|,
literal|"%3.1e"
block|,
literal|"%-1.5e"
block|,
literal|"%1.5e"
block|,
literal|"%01.3e"
block|,
literal|"%1.e"
block|,
literal|"%.1e"
block|,
literal|"%#.0e"
block|,
literal|"%+.0e"
block|,
literal|"% .0e"
block|,
literal|"%.0e"
block|,
literal|"%#.e"
block|,
literal|"%+.e"
block|,
literal|"% .e"
block|,
literal|"%.e"
block|,
literal|"%4e"
block|,
literal|"%e"
block|,
literal|"%E"
block|,
endif|#
directive|endif
comment|/* !OS_LINUX */
comment|/* "%F" and "%f" formats. */
if|#
directive|if
operator|!
name|OS_BSD
operator|&&
operator|!
name|OS_IRIX
literal|"% '022f"
block|,
literal|"%+'022f"
block|,
literal|"%-'22f"
block|,
literal|"%'22f"
block|,
if|#
directive|if
name|HAVE_LONG_LONG_INT
literal|"%.16f"
block|,
literal|"%22.16f"
block|,
literal|"%022.16f"
block|,
literal|"%-22.16f"
block|,
literal|"%#+'022.16f"
block|,
endif|#
directive|endif
comment|/* HAVE_LONG_LONG_INT */
endif|#
directive|endif
comment|/* !OS_BSD&& !OS_IRIX */
literal|"foo|%#+0123.9F|bar"
block|,
literal|"%-123.9f"
block|,
literal|"%123.9f"
block|,
literal|"%+23.9f"
block|,
literal|"%+#010.0f"
block|,
literal|"%#10.1f"
block|,
literal|"%10.5f"
block|,
literal|"% 10.5f"
block|,
literal|"%+05.8f"
block|,
literal|"%-05.8f"
block|,
literal|"%05.8f"
block|,
literal|"%+5.8f"
block|,
literal|"%-5.8f"
block|,
literal|"% 5.8f"
block|,
literal|"%5.8f"
block|,
literal|"%5.0f"
block|,
literal|"%5.f"
block|,
literal|"%#5.0f"
block|,
literal|"%#5.f"
block|,
literal|"%+4.9f"
block|,
literal|"%3.2f"
block|,
literal|"%3.1f"
block|,
literal|"%-1.5f"
block|,
literal|"%1.5f"
block|,
literal|"%01.3f"
block|,
literal|"%1.f"
block|,
literal|"%.1f"
block|,
literal|"%#.0f"
block|,
literal|"%+.0f"
block|,
literal|"% .0f"
block|,
literal|"%.0f"
block|,
literal|"%#.f"
block|,
literal|"%+.f"
block|,
literal|"% .f"
block|,
literal|"%.f"
block|,
literal|"%4f"
block|,
literal|"%f"
block|,
literal|"%F"
block|,
comment|/* "%G" and "%g" formats. */
if|#
directive|if
operator|!
name|OS_BSD
operator|&&
operator|!
name|OS_IRIX
operator|&&
operator|!
name|OS_LINUX
literal|"% '022g"
block|,
literal|"%+'022g"
block|,
literal|"%-'22g"
block|,
literal|"%'22g"
block|,
if|#
directive|if
name|HAVE_LONG_LONG_INT
literal|"%.16g"
block|,
literal|"%22.16g"
block|,
literal|"%022.16g"
block|,
literal|"%-22.16g"
block|,
literal|"%#+'022.16g"
block|,
endif|#
directive|endif
comment|/* HAVE_LONG_LONG_INT */
endif|#
directive|endif
comment|/* !OS_BSD&& !OS_IRIX&& !OS_LINUX */
literal|"foo|%#+0123.9G|bar"
block|,
literal|"%-123.9g"
block|,
literal|"%123.9g"
block|,
literal|"%+23.9g"
block|,
literal|"%+05.8g"
block|,
literal|"%-05.8g"
block|,
literal|"%05.8g"
block|,
literal|"%+5.8g"
block|,
literal|"%-5.8g"
block|,
literal|"% 5.8g"
block|,
literal|"%5.8g"
block|,
literal|"%+4.9g"
block|,
if|#
directive|if
operator|!
name|OS_LINUX
comment|/* glibc sometimes gets these wrong. */
literal|"%+#010.0g"
block|,
literal|"%#10.1g"
block|,
literal|"%10.5g"
block|,
literal|"% 10.5g"
block|,
literal|"%5.0g"
block|,
literal|"%5.g"
block|,
literal|"%#5.0g"
block|,
literal|"%#5.g"
block|,
literal|"%3.2g"
block|,
literal|"%3.1g"
block|,
literal|"%-1.5g"
block|,
literal|"%1.5g"
block|,
literal|"%01.3g"
block|,
literal|"%1.g"
block|,
literal|"%.1g"
block|,
literal|"%#.0g"
block|,
literal|"%+.0g"
block|,
literal|"% .0g"
block|,
literal|"%.0g"
block|,
literal|"%#.g"
block|,
literal|"%+.g"
block|,
literal|"% .g"
block|,
literal|"%.g"
block|,
literal|"%4g"
block|,
literal|"%g"
block|,
literal|"%G"
block|,
endif|#
directive|endif
comment|/* !OS_LINUX */
name|NULL
block|}
decl_stmt|;
name|double
name|float_val
index|[]
init|=
block|{
operator|-
literal|4.136
block|,
operator|-
literal|134.52
block|,
operator|-
literal|5.04030201
block|,
operator|-
literal|3410.01234
block|,
operator|-
literal|999999.999999
block|,
operator|-
literal|913450.29876
block|,
operator|-
literal|913450.2
block|,
operator|-
literal|91345.2
block|,
operator|-
literal|9134.2
block|,
operator|-
literal|913.2
block|,
operator|-
literal|91.2
block|,
operator|-
literal|9.2
block|,
operator|-
literal|9.9
block|,
literal|4.136
block|,
literal|134.52
block|,
literal|5.04030201
block|,
literal|3410.01234
block|,
literal|999999.999999
block|,
literal|913450.29876
block|,
literal|913450.2
block|,
literal|91345.2
block|,
literal|9134.2
block|,
literal|913.2
block|,
literal|91.2
block|,
literal|9.2
block|,
literal|9.9
block|,
literal|9.96
block|,
literal|9.996
block|,
literal|9.9996
block|,
literal|9.99996
block|,
literal|9.999996
block|,
literal|9.9999996
block|,
literal|9.99999996
block|,
literal|0.99999996
block|,
literal|0.99999999
block|,
literal|0.09999999
block|,
literal|0.00999999
block|,
literal|0.00099999
block|,
literal|0.00009999
block|,
literal|0.00000999
block|,
literal|0.00000099
block|,
literal|0.00000009
block|,
literal|0.00000001
block|,
literal|0.0000001
block|,
literal|0.000001
block|,
literal|0.00001
block|,
literal|0.0001
block|,
literal|0.001
block|,
literal|0.01
block|,
literal|0.1
block|,
literal|1.0
block|,
literal|1.5
block|,
operator|-
literal|1.5
block|,
operator|-
literal|1.0
block|,
operator|-
literal|0.1
block|,
if|#
directive|if
operator|!
name|OS_BSD
comment|/* BSD sometimes gets these wrong. */
ifdef|#
directive|ifdef
name|INFINITY
name|INFINITY
block|,
operator|-
name|INFINITY
block|,
endif|#
directive|endif
comment|/* defined(INFINITY) */
ifdef|#
directive|ifdef
name|NAN
name|NAN
block|,
endif|#
directive|endif
comment|/* defined(NAN) */
endif|#
directive|endif
comment|/* !OS_BSD */
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|long_fmt
index|[]
init|=
block|{
literal|"foo|%0123ld|bar"
block|,
if|#
directive|if
operator|!
name|OS_IRIX
literal|"% '0123ld"
block|,
literal|"%+'0123ld"
block|,
literal|"%-'123ld"
block|,
literal|"%'123ld"
block|,
endif|#
directive|endif
comment|/* !OS_IRiX */
literal|"%123.9ld"
block|,
literal|"% 123.9ld"
block|,
literal|"%+123.9ld"
block|,
literal|"%-123.9ld"
block|,
literal|"%0123ld"
block|,
literal|"% 0123ld"
block|,
literal|"%+0123ld"
block|,
literal|"%-0123ld"
block|,
literal|"%10.5ld"
block|,
literal|"% 10.5ld"
block|,
literal|"%+10.5ld"
block|,
literal|"%-10.5ld"
block|,
literal|"%010ld"
block|,
literal|"% 010ld"
block|,
literal|"%+010ld"
block|,
literal|"%-010ld"
block|,
literal|"%4.2ld"
block|,
literal|"% 4.2ld"
block|,
literal|"%+4.2ld"
block|,
literal|"%-4.2ld"
block|,
literal|"%04ld"
block|,
literal|"% 04ld"
block|,
literal|"%+04ld"
block|,
literal|"%-04ld"
block|,
literal|"%5.5ld"
block|,
literal|"%+22.33ld"
block|,
literal|"%01.3ld"
block|,
literal|"%1.5ld"
block|,
literal|"%-1.5ld"
block|,
literal|"%44ld"
block|,
literal|"%4ld"
block|,
literal|"%4.0ld"
block|,
literal|"%4.ld"
block|,
literal|"%.44ld"
block|,
literal|"%.4ld"
block|,
literal|"%.0ld"
block|,
literal|"%.ld"
block|,
literal|"%ld"
block|,
name|NULL
block|}
decl_stmt|;
name|long
name|int
name|long_val
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LONG_MAX
name|LONG_MAX
block|,
endif|#
directive|endif
comment|/* LONG_MAX */
ifdef|#
directive|ifdef
name|LONG_MIN
name|LONG_MIN
block|,
endif|#
directive|endif
comment|/* LONG_MIN */
operator|-
literal|91340
block|,
literal|91340
block|,
literal|341
block|,
literal|134
block|,
literal|0203
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|ulong_fmt
index|[]
init|=
block|{
comment|/* "%u" formats. */
literal|"foo|%0123lu|bar"
block|,
if|#
directive|if
operator|!
name|OS_IRIX
literal|"% '0123lu"
block|,
literal|"%+'0123lu"
block|,
literal|"%-'123lu"
block|,
literal|"%'123lu"
block|,
endif|#
directive|endif
comment|/* !OS_IRiX */
literal|"%123.9lu"
block|,
literal|"% 123.9lu"
block|,
literal|"%+123.9lu"
block|,
literal|"%-123.9lu"
block|,
literal|"%0123lu"
block|,
literal|"% 0123lu"
block|,
literal|"%+0123lu"
block|,
literal|"%-0123lu"
block|,
literal|"%5.5lu"
block|,
literal|"%+22.33lu"
block|,
literal|"%01.3lu"
block|,
literal|"%1.5lu"
block|,
literal|"%-1.5lu"
block|,
literal|"%44lu"
block|,
literal|"%lu"
block|,
comment|/* "%o" formats. */
literal|"foo|%#0123lo|bar"
block|,
literal|"%#123.9lo"
block|,
literal|"%# 123.9lo"
block|,
literal|"%#+123.9lo"
block|,
literal|"%#-123.9lo"
block|,
literal|"%#0123lo"
block|,
literal|"%# 0123lo"
block|,
literal|"%#+0123lo"
block|,
literal|"%#-0123lo"
block|,
literal|"%#5.5lo"
block|,
literal|"%#+22.33lo"
block|,
literal|"%#01.3lo"
block|,
literal|"%#1.5lo"
block|,
literal|"%#-1.5lo"
block|,
literal|"%#44lo"
block|,
literal|"%#lo"
block|,
literal|"%123.9lo"
block|,
literal|"% 123.9lo"
block|,
literal|"%+123.9lo"
block|,
literal|"%-123.9lo"
block|,
literal|"%0123lo"
block|,
literal|"% 0123lo"
block|,
literal|"%+0123lo"
block|,
literal|"%-0123lo"
block|,
literal|"%5.5lo"
block|,
literal|"%+22.33lo"
block|,
literal|"%01.3lo"
block|,
literal|"%1.5lo"
block|,
literal|"%-1.5lo"
block|,
literal|"%44lo"
block|,
literal|"%lo"
block|,
comment|/* "%X" and "%x" formats. */
literal|"foo|%#0123lX|bar"
block|,
literal|"%#123.9lx"
block|,
literal|"%# 123.9lx"
block|,
literal|"%#+123.9lx"
block|,
literal|"%#-123.9lx"
block|,
literal|"%#0123lx"
block|,
literal|"%# 0123lx"
block|,
literal|"%#+0123lx"
block|,
literal|"%#-0123lx"
block|,
literal|"%#5.5lx"
block|,
literal|"%#+22.33lx"
block|,
literal|"%#01.3lx"
block|,
literal|"%#1.5lx"
block|,
literal|"%#-1.5lx"
block|,
literal|"%#44lx"
block|,
literal|"%#lx"
block|,
literal|"%#lX"
block|,
literal|"%123.9lx"
block|,
literal|"% 123.9lx"
block|,
literal|"%+123.9lx"
block|,
literal|"%-123.9lx"
block|,
literal|"%0123lx"
block|,
literal|"% 0123lx"
block|,
literal|"%+0123lx"
block|,
literal|"%-0123lx"
block|,
literal|"%5.5lx"
block|,
literal|"%+22.33lx"
block|,
literal|"%01.3lx"
block|,
literal|"%1.5lx"
block|,
literal|"%-1.5lx"
block|,
literal|"%44lx"
block|,
literal|"%lx"
block|,
literal|"%lX"
block|,
name|NULL
block|}
decl_stmt|;
name|unsigned
name|long
name|int
name|ulong_val
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|ULONG_MAX
name|ULONG_MAX
block|,
endif|#
directive|endif
comment|/* ULONG_MAX */
literal|91340
block|,
literal|341
block|,
literal|134
block|,
literal|0203
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|llong_fmt
index|[]
init|=
block|{
literal|"foo|%0123lld|bar"
block|,
literal|"%123.9lld"
block|,
literal|"% 123.9lld"
block|,
literal|"%+123.9lld"
block|,
literal|"%-123.9lld"
block|,
literal|"%0123lld"
block|,
literal|"% 0123lld"
block|,
literal|"%+0123lld"
block|,
literal|"%-0123lld"
block|,
literal|"%5.5lld"
block|,
literal|"%+22.33lld"
block|,
literal|"%01.3lld"
block|,
literal|"%1.5lld"
block|,
literal|"%-1.5lld"
block|,
literal|"%44lld"
block|,
literal|"%lld"
block|,
name|NULL
block|}
decl_stmt|;
name|LLONG
name|llong_val
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LLONG_MAX
name|LLONG_MAX
block|,
endif|#
directive|endif
comment|/* LLONG_MAX */
ifdef|#
directive|ifdef
name|LLONG_MIN
name|LLONG_MIN
block|,
endif|#
directive|endif
comment|/* LLONG_MIN */
operator|-
literal|91340
block|,
literal|91340
block|,
literal|341
block|,
literal|134
block|,
literal|0203
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|string_fmt
index|[]
init|=
block|{
literal|"foo|%10.10s|bar"
block|,
literal|"%-10.10s"
block|,
literal|"%10.10s"
block|,
literal|"%10.5s"
block|,
literal|"%5.10s"
block|,
literal|"%10.1s"
block|,
literal|"%1.10s"
block|,
literal|"%10.0s"
block|,
literal|"%0.10s"
block|,
literal|"%-42.5s"
block|,
literal|"%2.s"
block|,
literal|"%.10s"
block|,
literal|"%.1s"
block|,
literal|"%.0s"
block|,
literal|"%.s"
block|,
literal|"%4s"
block|,
literal|"%s"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|string_val
index|[]
init|=
block|{
literal|"Hello"
block|,
literal|"Hello, world!"
block|,
literal|"Sound check: One, two, three."
block|,
literal|"This string is a little longer than the other strings."
block|,
literal|"1"
block|,
literal|""
block|,
name|NULL
block|}
decl_stmt|;
if|#
directive|if
operator|!
name|OS_SYSV
comment|/* SysV uses a different format than we do. */
specifier|const
name|char
modifier|*
name|pointer_fmt
index|[]
init|=
block|{
literal|"foo|%p|bar"
block|,
literal|"%42p"
block|,
literal|"%p"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|pointer_val
index|[]
init|=
block|{
operator|*
name|pointer_fmt
block|,
operator|*
name|string_fmt
block|,
operator|*
name|string_val
block|,
name|NULL
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* !OS_SYSV */
name|char
name|buf1
index|[
literal|1024
index|]
decl_stmt|,
name|buf2
index|[
literal|1024
index|]
decl_stmt|;
name|double
name|value
decl_stmt|,
name|digits
init|=
literal|9.123456789012345678901234567890123456789
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|failed
init|=
literal|0
decl_stmt|,
name|num
init|=
literal|0
decl_stmt|;
comment|/*  * Use -DTEST_NILS in order to also test the conversion of nil values.  Might  * segfault on systems which don't support converting a NULL pointer with "%s"  * and lets some test cases fail against BSD and glibc due to bugs in their  * implementations.  */
ifndef|#
directive|ifndef
name|TEST_NILS
define|#
directive|define
name|TEST_NILS
value|0
elif|#
directive|elif
name|TEST_NILS
undef|#
directive|undef
name|TEST_NILS
define|#
directive|define
name|TEST_NILS
value|1
endif|#
directive|endif
comment|/* !defined(TEST_NILS) */
ifdef|#
directive|ifdef
name|TEST
undef|#
directive|undef
name|TEST
endif|#
directive|endif
comment|/* defined(TEST) */
define|#
directive|define
name|TEST
parameter_list|(
name|fmt
parameter_list|,
name|val
parameter_list|)
define|\
value|do {                                                                           \ 	for (i = 0; fmt[i] != NULL; i++)                                       \ 		for (j = 0; j == 0 || val[j - TEST_NILS] != 0; j++) {          \ 			r1 = sprintf(buf1, fmt[i], val[j]);                    \ 			r2 = snprintf(buf2, sizeof(buf2), fmt[i], val[j]);     \ 			if (strcmp(buf1, buf2) != 0 || r1 != r2) {             \ 				(void)printf("Results don't match, "           \ 				    "format string: %s\n"                      \ 				    "\t sprintf(3): [%s] (%d)\n"               \ 				    "\tsnprintf(3): [%s] (%d)\n",              \ 				    fmt[i], buf1, r1, buf2, r2);               \ 				failed++;                                      \ 			}                                                      \ 			num++;                                                 \ 		}                                                              \ } while (
comment|/* CONSTCOND */
value|0)
if|#
directive|if
name|HAVE_LOCALE_H
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_LOCALE_H */
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"Testing our snprintf(3) against your system's sprintf(3)."
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|float_fmt
argument_list|,
name|float_val
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|long_fmt
argument_list|,
name|long_val
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|ulong_fmt
argument_list|,
name|ulong_val
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|llong_fmt
argument_list|,
name|llong_val
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|string_fmt
argument_list|,
name|string_val
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|OS_SYSV
comment|/* SysV uses a different format than we do. */
name|TEST
argument_list|(
name|pointer_fmt
argument_list|,
name|pointer_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !OS_SYSV */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Result: %d out of %d tests failed.\n"
argument_list|,
name|failed
argument_list|,
name|num
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Checking how many digits we support: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
name|pow
argument_list|(
literal|10
argument_list|,
name|i
argument_list|)
operator|*
name|digits
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf1
argument_list|,
literal|"%.1f"
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|,
literal|"%.1f"
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"apparently %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|failed
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_SNPRINTF */
end_comment

begin_comment
comment|/* vim: set joinspaces textwidth=80: */
end_comment

end_unit

