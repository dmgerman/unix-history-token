begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * authkeys.c - routines to manage the storage of authentication keys  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lists.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_malloc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_keyacc.h"
end_include

begin_comment
comment|/*  * Structure to store keys in in the hash table.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|savekey
name|symkey
typedef|;
end_typedef

begin_struct
struct|struct
name|savekey
block|{
name|symkey
modifier|*
name|hlink
decl_stmt|;
comment|/* next in hash bucket */
name|DECL_DLIST_LINK
argument_list|(
name|symkey
argument_list|,
name|llink
argument_list|)
expr_stmt|;
comment|/* for overall& free lists */
name|u_char
modifier|*
name|secret
decl_stmt|;
comment|/* shared secret */
name|KeyAccT
modifier|*
name|keyacclist
decl_stmt|;
comment|/* Private key access list */
name|u_long
name|lifetime
decl_stmt|;
comment|/* remaining lifetime */
name|keyid_t
name|keyid
decl_stmt|;
comment|/* key identifier */
name|u_short
name|type
decl_stmt|;
comment|/* OpenSSL digest NID */
name|size_t
name|secretsize
decl_stmt|;
comment|/* secret octets */
name|u_short
name|flags
decl_stmt|;
comment|/* KEY_ flags that wave */
block|}
struct|;
end_struct

begin_comment
comment|/* define the payload region of symkey beyond the list pointers */
end_comment

begin_define
define|#
directive|define
name|symkey_payload
value|secret
end_define

begin_define
define|#
directive|define
name|KEY_TRUSTED
value|0x001
end_define

begin_comment
comment|/* this key is trusted */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|symkey_alloc_tag
name|symkey_alloc
typedef|;
end_typedef

begin_struct
struct|struct
name|symkey_alloc_tag
block|{
name|symkey_alloc
modifier|*
name|link
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
comment|/* enable free() atexit */
block|}
struct|;
end_struct

begin_decl_stmt
name|symkey_alloc
modifier|*
name|authallocs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function_decl
specifier|static
name|u_short
name|auth_log2
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|auth_resize_hashtable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocsymkey
parameter_list|(
name|keyid_t
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|u_long
parameter_list|,
name|size_t
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|KeyAccT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freesymkey
parameter_list|(
name|symkey
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|free_auth_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|symkey
name|key_listhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all in-use keys */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * The hash table. This is indexed by the low order bits of the  * keyid. We make this fairly big for potentially busy servers.  */
end_comment

begin_define
define|#
directive|define
name|DEF_AUTHHASHSIZE
value|64
end_define

begin_comment
comment|/*#define	HASHMASK	((HASHSIZE)-1)*/
end_comment

begin_define
define|#
directive|define
name|KEYHASH
parameter_list|(
name|keyid
parameter_list|)
value|((keyid)& authhashmask)
end_define

begin_decl_stmt
name|int
name|authhashdisabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|authhashbuckets
init|=
name|DEF_AUTHHASHSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|authhashmask
init|=
name|DEF_AUTHHASHSIZE
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symkey
modifier|*
modifier|*
name|key_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|authkeynotfound
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keys not found */
end_comment

begin_decl_stmt
name|u_long
name|authkeylookups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to lookup keys */
end_comment

begin_decl_stmt
name|u_long
name|authnumkeys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of active keys */
end_comment

begin_decl_stmt
name|u_long
name|authkeyexpired
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key lifetime expirations */
end_comment

begin_decl_stmt
name|u_long
name|authkeyuncached
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache misses */
end_comment

begin_decl_stmt
name|u_long
name|authnokey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to encrypt with no key */
end_comment

begin_decl_stmt
name|u_long
name|authencryptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to encrypt */
end_comment

begin_decl_stmt
name|u_long
name|authdecryptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to decrypt */
end_comment

begin_comment
comment|/*  * Storage for free symkey structures.  We malloc() such things but  * never free them.  */
end_comment

begin_decl_stmt
name|symkey
modifier|*
name|authfreekeys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|authnumfreekeys
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MEMINC
value|16
end_define

begin_comment
comment|/* number of new free ones to get */
end_comment

begin_comment
comment|/*  * The key cache. We cache the last key we looked at here.  * Note: this should hold the last *trusted* key. Also the  * cache is only loaded when the digest type / MAC algorithm  * is valid.  */
end_comment

begin_decl_stmt
name|keyid_t
name|cache_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key identifier */
end_comment

begin_decl_stmt
name|u_char
modifier|*
name|cache_secret
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* secret */
end_comment

begin_decl_stmt
name|size_t
name|cache_secretsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* secret length */
end_comment

begin_decl_stmt
name|int
name|cache_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OpenSSL digest NID */
end_comment

begin_decl_stmt
name|u_short
name|cache_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags that wave */
end_comment

begin_decl_stmt
name|KeyAccT
modifier|*
name|cache_keyacclist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key access list */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------  * manage key access lists  * --------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* allocate and populate new access node and pushes it on the list.  * Returns the new head.  */
end_comment

begin_function
name|KeyAccT
modifier|*
name|keyacc_new_push
parameter_list|(
name|KeyAccT
modifier|*
name|head
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
name|KeyAccT
modifier|*
name|node
init|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|KeyAccT
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|node
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sockaddr_u
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|head
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_comment
comment|/* pop and deallocate the first node of a list of access nodes, if  * the list is not empty. Returns the tail of the list.  */
end_comment

begin_function
name|KeyAccT
modifier|*
name|keyacc_pop_free
parameter_list|(
name|KeyAccT
modifier|*
name|head
parameter_list|)
block|{
name|KeyAccT
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|head
condition|)
block|{
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_comment
comment|/* deallocate the list; returns an empty list. */
end_comment

begin_function
name|KeyAccT
modifier|*
name|keyacc_all_free
parameter_list|(
name|KeyAccT
modifier|*
name|head
parameter_list|)
block|{
while|while
condition|(
name|head
condition|)
name|head
operator|=
name|keyacc_pop_free
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_comment
comment|/* scan a list to see if it contains a given address. Return the  * default result value in case of an empty list.  */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|keyacc_contains
parameter_list|(
specifier|const
name|KeyAccT
modifier|*
name|head
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|int
name|defv
parameter_list|)
block|{
if|if
condition|(
name|head
condition|)
block|{
do|do
block|{
if|if
condition|(
name|SOCK_EQ
argument_list|(
operator|&
name|head
operator|->
name|addr
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
do|while
condition|(
name|NULL
operator|!=
operator|(
name|head
operator|=
name|head
operator|->
name|next
operator|)
condition|)
do|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
return|return
operator|!
operator|!
name|defv
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * init_auth - initialize internal data  */
end_comment

begin_function
name|void
name|init_auth
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|newalloc
decl_stmt|;
comment|/* 	 * Initialize hash table and free list 	 */
name|newalloc
operator|=
name|authhashbuckets
operator|*
sizeof|sizeof
argument_list|(
name|key_hash
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|key_hash
operator|=
name|erealloc
argument_list|(
name|key_hash
argument_list|,
name|newalloc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key_hash
argument_list|,
literal|'\0'
argument_list|,
name|newalloc
argument_list|)
expr_stmt|;
name|INIT_DLIST
argument_list|(
name|key_listhead
argument_list|,
name|llink
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|atexit
argument_list|(
operator|&
name|free_auth_mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * free_auth_mem - assist in leak detection by freeing all dynamic  *		   allocations from this module.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|free_auth_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|symkey_alloc
modifier|*
name|alloc
decl_stmt|;
name|symkey_alloc
modifier|*
name|next_alloc
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|sk
operator|=
name|HEAD_DLIST
argument_list|(
name|key_listhead
argument_list|,
name|llink
argument_list|)
operator|)
condition|)
block|{
name|freesymkey
argument_list|(
name|sk
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|key_hash
argument_list|)
expr_stmt|;
name|key_hash
operator|=
name|NULL
expr_stmt|;
name|cache_keyid
operator|=
literal|0
expr_stmt|;
name|cache_flags
operator|=
literal|0
expr_stmt|;
name|cache_keyacclist
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|alloc
operator|=
name|authallocs
init|;
name|alloc
operator|!=
name|NULL
condition|;
name|alloc
operator|=
name|next_alloc
control|)
block|{
name|next_alloc
operator|=
name|alloc
operator|->
name|link
expr_stmt|;
name|free
argument_list|(
name|alloc
operator|->
name|mem
argument_list|)
expr_stmt|;
block|}
name|authfreekeys
operator|=
name|NULL
expr_stmt|;
name|authnumfreekeys
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * auth_moremem - get some more free key structures  */
end_comment

begin_function
name|void
name|auth_moremem
parameter_list|(
name|int
name|keycount
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|void
modifier|*
name|base
decl_stmt|;
name|symkey_alloc
modifier|*
name|allocrec
decl_stmt|;
define|#
directive|define
name|MOREMEM_EXTRA_ALLOC
value|(sizeof(*allocrec))
else|#
directive|else
define|#
directive|define
name|MOREMEM_EXTRA_ALLOC
value|(0)
endif|#
directive|endif
name|i
operator|=
operator|(
name|keycount
operator|>
literal|0
operator|)
condition|?
name|keycount
else|:
name|MEMINC
expr_stmt|;
name|sk
operator|=
name|emalloc_zero
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sk
argument_list|)
operator|+
name|MOREMEM_EXTRA_ALLOC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|base
operator|=
name|sk
expr_stmt|;
endif|#
directive|endif
name|authnumfreekeys
operator|+=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|sk
operator|++
control|)
block|{
name|LINK_SLIST
argument_list|(
name|authfreekeys
argument_list|,
name|sk
argument_list|,
name|llink
operator|.
name|f
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|allocrec
operator|=
operator|(
name|void
operator|*
operator|)
name|sk
expr_stmt|;
name|allocrec
operator|->
name|mem
operator|=
name|base
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|authallocs
argument_list|,
name|allocrec
argument_list|,
name|link
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * auth_prealloc_symkeys  */
end_comment

begin_function
name|void
name|auth_prealloc_symkeys
parameter_list|(
name|int
name|keycount
parameter_list|)
block|{
name|int
name|allocated
decl_stmt|;
name|int
name|additional
decl_stmt|;
name|allocated
operator|=
name|authnumkeys
operator|+
name|authnumfreekeys
expr_stmt|;
name|additional
operator|=
name|keycount
operator|-
name|allocated
expr_stmt|;
if|if
condition|(
name|additional
operator|>
literal|0
condition|)
name|auth_moremem
argument_list|(
name|additional
argument_list|)
expr_stmt|;
name|auth_resize_hashtable
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_short
name|auth_log2
parameter_list|(
name|size_t
name|x
parameter_list|)
block|{
comment|/* 	** bithack to calculate floor(log2(x)) 	** 	** This assumes 	**   - (sizeof(size_t) is a power of two 	**   - CHAR_BITS is a power of two 	**   - returning zero for arguments<= 0 is OK. 	** 	** Does only shifts, masks and sums in integer arithmetic in 	** log2(CHAR_BIT*sizeof(size_t)) steps. (that is, 5/6 steps for 	** 32bit/64bit size_t) 	*/
name|int
name|s
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|size_t
name|m
init|=
operator|~
operator|(
name|size_t
operator|)
literal|0
decl_stmt|;
for|for
control|(
name|s
operator|=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|/
literal|2
operator|*
name|CHAR_BIT
init|;
name|s
operator|!=
literal|0
condition|;
name|s
operator|>>=
literal|1
control|)
block|{
name|m
operator|<<=
name|s
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|m
condition|)
name|r
operator|+=
name|s
expr_stmt|;
else|else
name|x
operator|<<=
name|s
expr_stmt|;
block|}
return|return
operator|(
name|u_short
operator|)
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|authcache_flush_id
parameter_list|(
name|keyid_t
name|id
parameter_list|)
block|{
if|if
condition|(
name|cache_keyid
operator|==
name|id
condition|)
block|{
name|cache_keyid
operator|=
literal|0
expr_stmt|;
name|cache_type
operator|=
literal|0
expr_stmt|;
name|cache_flags
operator|=
literal|0
expr_stmt|;
name|cache_secret
operator|=
name|NULL
expr_stmt|;
name|cache_secretsize
operator|=
literal|0
expr_stmt|;
name|cache_keyacclist
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * auth_resize_hashtable  *  * Size hash table to average 4 or fewer entries per bucket initially,  * within the bounds of at least 4 and no more than 15 bits for the hash  * table index.  Populate the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|auth_resize_hashtable
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|totalkeys
decl_stmt|;
name|u_short
name|hashbits
decl_stmt|;
name|u_short
name|hash
decl_stmt|;
name|size_t
name|newalloc
decl_stmt|;
name|symkey
modifier|*
name|sk
decl_stmt|;
name|totalkeys
operator|=
name|authnumkeys
operator|+
name|authnumfreekeys
expr_stmt|;
name|hashbits
operator|=
name|auth_log2
argument_list|(
name|totalkeys
operator|/
literal|4
argument_list|)
operator|+
literal|1
expr_stmt|;
name|hashbits
operator|=
name|max
argument_list|(
literal|4
argument_list|,
name|hashbits
argument_list|)
expr_stmt|;
name|hashbits
operator|=
name|min
argument_list|(
literal|15
argument_list|,
name|hashbits
argument_list|)
expr_stmt|;
name|authhashbuckets
operator|=
literal|1
operator|<<
name|hashbits
expr_stmt|;
name|authhashmask
operator|=
name|authhashbuckets
operator|-
literal|1
expr_stmt|;
name|newalloc
operator|=
name|authhashbuckets
operator|*
sizeof|sizeof
argument_list|(
name|key_hash
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|key_hash
operator|=
name|erealloc
argument_list|(
name|key_hash
argument_list|,
name|newalloc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key_hash
argument_list|,
literal|'\0'
argument_list|,
name|newalloc
argument_list|)
expr_stmt|;
name|ITER_DLIST_BEGIN
argument_list|(
argument|key_listhead
argument_list|,
argument|sk
argument_list|,
argument|llink
argument_list|,
argument|symkey
argument_list|)
name|hash
operator|=
name|KEYHASH
argument_list|(
name|sk
operator|->
name|keyid
argument_list|)
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|key_hash
index|[
name|hash
index|]
argument_list|,
name|sk
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
name|ITER_DLIST_END
argument_list|()
block|}
end_function

begin_comment
comment|/*  * allocsymkey - common code to allocate and link in symkey  *  * secret must be allocated with a free-compatible allocator.  It is  * owned by the referring symkey structure, and will be free()d by  * freesymkey().  */
end_comment

begin_function
specifier|static
name|void
name|allocsymkey
parameter_list|(
name|keyid_t
name|id
parameter_list|,
name|u_short
name|flags
parameter_list|,
name|u_short
name|type
parameter_list|,
name|u_long
name|lifetime
parameter_list|,
name|size_t
name|secretsize
parameter_list|,
name|u_char
modifier|*
name|secret
parameter_list|,
name|KeyAccT
modifier|*
name|ka
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|symkey
modifier|*
modifier|*
name|bucket
decl_stmt|;
name|bucket
operator|=
operator|&
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|authnumfreekeys
operator|<
literal|1
condition|)
name|auth_moremem
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|UNLINK_HEAD_SLIST
argument_list|(
name|sk
argument_list|,
name|authfreekeys
argument_list|,
name|llink
operator|.
name|f
argument_list|)
expr_stmt|;
name|DEBUG_ENSURE
argument_list|(
name|sk
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sk
operator|->
name|keyid
operator|=
name|id
expr_stmt|;
name|sk
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|sk
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|sk
operator|->
name|secretsize
operator|=
name|secretsize
expr_stmt|;
name|sk
operator|->
name|secret
operator|=
name|secret
expr_stmt|;
name|sk
operator|->
name|keyacclist
operator|=
name|ka
expr_stmt|;
name|sk
operator|->
name|lifetime
operator|=
name|lifetime
expr_stmt|;
name|LINK_SLIST
argument_list|(
operator|*
name|bucket
argument_list|,
name|sk
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
name|LINK_TAIL_DLIST
argument_list|(
name|key_listhead
argument_list|,
name|sk
argument_list|,
name|llink
argument_list|)
expr_stmt|;
name|authnumfreekeys
operator|--
expr_stmt|;
name|authnumkeys
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * freesymkey - common code to remove a symkey and recycle its entry.  */
end_comment

begin_function
specifier|static
name|void
name|freesymkey
parameter_list|(
name|symkey
modifier|*
name|sk
parameter_list|)
block|{
name|symkey
modifier|*
modifier|*
name|bucket
decl_stmt|;
name|symkey
modifier|*
name|unlinked
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|sk
condition|)
return|return;
name|authcache_flush_id
argument_list|(
name|sk
operator|->
name|keyid
argument_list|)
expr_stmt|;
name|keyacc_all_free
argument_list|(
name|sk
operator|->
name|keyacclist
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|sk
operator|->
name|keyid
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|sk
operator|->
name|secret
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|sk
operator|->
name|secret
argument_list|,
literal|'\0'
argument_list|,
name|sk
operator|->
name|secretsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sk
operator|->
name|secret
argument_list|)
expr_stmt|;
block|}
name|UNLINK_SLIST
argument_list|(
name|unlinked
argument_list|,
operator|*
name|bucket
argument_list|,
name|sk
argument_list|,
name|hlink
argument_list|,
name|symkey
argument_list|)
expr_stmt|;
name|DEBUG_ENSURE
argument_list|(
name|sk
operator|==
name|unlinked
argument_list|)
expr_stmt|;
name|UNLINK_DLIST
argument_list|(
name|sk
argument_list|,
name|llink
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sk
operator|+
name|offsetof
argument_list|(
name|symkey
argument_list|,
name|symkey_payload
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sk
argument_list|)
operator|-
name|offsetof
argument_list|(
name|symkey
argument_list|,
name|symkey_payload
argument_list|)
argument_list|)
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|authfreekeys
argument_list|,
name|sk
argument_list|,
name|llink
operator|.
name|f
argument_list|)
expr_stmt|;
name|authnumkeys
operator|--
expr_stmt|;
name|authnumfreekeys
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * auth_findkey - find a key in the hash table  */
end_comment

begin_function
name|struct
name|savekey
modifier|*
name|auth_findkey
parameter_list|(
name|keyid_t
name|id
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
for|for
control|(
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|id
argument_list|)
index|]
init|;
name|sk
operator|!=
name|NULL
condition|;
name|sk
operator|=
name|sk
operator|->
name|hlink
control|)
if|if
condition|(
name|id
operator|==
name|sk
operator|->
name|keyid
condition|)
return|return
name|sk
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * auth_havekey - return TRUE if the key id is zero or known. The  * key needs not to be trusted.  */
end_comment

begin_function
name|int
name|auth_havekey
parameter_list|(
name|keyid_t
name|id
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|==
name|id
operator|)
operator|||
operator|(
name|cache_keyid
operator|==
name|id
operator|)
operator|||
operator|(
name|NULL
operator|!=
name|auth_findkey
argument_list|(
name|id
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * authhavekey - return TRUE and cache the key, if zero or both known  *		 and trusted.  */
end_comment

begin_function
name|int
name|authhavekey
parameter_list|(
name|keyid_t
name|id
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|authkeylookups
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|id
operator|||
name|cache_keyid
operator|==
name|id
condition|)
return|return
operator|!
operator|!
operator|(
name|KEY_TRUSTED
operator|&
name|cache_flags
operator|)
return|;
comment|/* 	 * Search the bin for the key. If not found, or found but the key 	 * type is zero, somebody marked it trusted without specifying a 	 * key or key type. In this case consider the key missing. 	 */
name|authkeyuncached
operator|++
expr_stmt|;
name|sk
operator|=
name|auth_findkey
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sk
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sk
operator|->
name|type
operator|==
literal|0
operator|)
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	 * If the key is not trusted, the key is not considered found. 	 */
if|if
condition|(
operator|!
operator|(
name|KEY_TRUSTED
operator|&
name|sk
operator|->
name|flags
operator|)
condition|)
block|{
name|authnokey
operator|++
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	 * The key is found and trusted. Initialize the key cache. 	 */
name|cache_keyid
operator|=
name|sk
operator|->
name|keyid
expr_stmt|;
name|cache_type
operator|=
name|sk
operator|->
name|type
expr_stmt|;
name|cache_flags
operator|=
name|sk
operator|->
name|flags
expr_stmt|;
name|cache_secret
operator|=
name|sk
operator|->
name|secret
expr_stmt|;
name|cache_secretsize
operator|=
name|sk
operator|->
name|secretsize
expr_stmt|;
name|cache_keyacclist
operator|=
name|sk
operator|->
name|keyacclist
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * authtrust - declare a key to be trusted/untrusted  */
end_comment

begin_function
name|void
name|authtrust
parameter_list|(
name|keyid_t
name|id
parameter_list|,
name|u_long
name|trust
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|u_long
name|lifetime
decl_stmt|;
comment|/* 	 * Search bin for key; if it does not exist and is untrusted, 	 * forget it. 	 */
name|sk
operator|=
name|auth_findkey
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trust
operator|&&
name|sk
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * There are two conditions remaining. Either it does not 	 * exist and is to be trusted or it does exist and is or is 	 * not to be trusted. 	 */
if|if
condition|(
name|sk
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Key exists. If it is to be trusted, say so and update 		 * its lifetime. If no longer trusted, return it to the 		 * free list. Flush the cache first to be sure there are 		 * no discrepancies. 		 */
name|authcache_flush_id
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|trust
operator|>
literal|0
condition|)
block|{
name|sk
operator|->
name|flags
operator||=
name|KEY_TRUSTED
expr_stmt|;
if|if
condition|(
name|trust
operator|>
literal|1
condition|)
name|sk
operator|->
name|lifetime
operator|=
name|current_time
operator|+
name|trust
expr_stmt|;
else|else
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|freesymkey
argument_list|(
name|sk
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * keyid is not present, but the is to be trusted.  We allocate 	 * a new key, but do not specify a key type or secret. 	 */
if|if
condition|(
name|trust
operator|>
literal|1
condition|)
block|{
name|lifetime
operator|=
name|current_time
operator|+
name|trust
expr_stmt|;
block|}
else|else
block|{
name|lifetime
operator|=
literal|0
expr_stmt|;
block|}
name|allocsymkey
argument_list|(
name|id
argument_list|,
name|KEY_TRUSTED
argument_list|,
literal|0
argument_list|,
name|lifetime
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * authistrusted - determine whether a key is trusted  */
end_comment

begin_function
name|int
name|authistrusted
parameter_list|(
name|keyid_t
name|id
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|cache_keyid
condition|)
return|return
operator|!
operator|!
operator|(
name|KEY_TRUSTED
operator|&
name|cache_flags
operator|)
return|;
name|authkeyuncached
operator|++
expr_stmt|;
name|sk
operator|=
name|auth_findkey
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk
operator|==
name|NULL
operator|||
operator|!
operator|(
name|KEY_TRUSTED
operator|&
name|sk
operator|->
name|flags
operator|)
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * authistrustedip - determine if the IP is OK for the keyid  */
end_comment

begin_function
name|int
name|authistrustedip
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|sockaddr_u
modifier|*
name|sau
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
comment|/* That specific key was already used to authenticate the 	 * packet. Therefore, the key *must* exist...  There's a chance 	 * that is not trusted, though. 	 */
if|if
condition|(
name|keyno
operator|==
name|cache_keyid
condition|)
block|{
return|return
operator|(
name|KEY_TRUSTED
operator|&
name|cache_flags
operator|)
operator|&&
name|keyacc_contains
argument_list|(
name|cache_keyacclist
argument_list|,
name|sau
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
else|else
block|{
name|authkeyuncached
operator|++
expr_stmt|;
name|sk
operator|=
name|auth_findkey
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|NULL
operator|!=
name|sk
argument_list|)
expr_stmt|;
return|return
operator|(
name|KEY_TRUSTED
operator|&
name|sk
operator|->
name|flags
operator|)
operator|&&
name|keyacc_contains
argument_list|(
name|sk
operator|->
name|keyacclist
argument_list|,
name|sau
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Note: There are two locations below where 'strncpy()' is used. While  * this function is a hazard by itself, it's essential that it is used  * here. Bug 1243 involved that the secret was filled with NUL bytes  * after the first NUL encountered, and 'strlcpy()' simply does NOT have  * this behaviour. So disabling the fix and reverting to the buggy  * behaviour due to compatibility issues MUST also fill with NUL and  * this needs 'strncpy'. Also, the secret is managed as a byte blob of a  * given size, and eventually truncating it and replacing the last byte  * with a NUL would be a bug.  * perlinger@ntp.org 2015-10-10  */
end_comment

begin_function
name|void
name|MD5auth_setkey
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|int
name|keytype
parameter_list|,
specifier|const
name|u_char
modifier|*
name|key
parameter_list|,
name|size_t
name|secretsize
parameter_list|,
name|KeyAccT
modifier|*
name|ka
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|u_char
modifier|*
name|secret
decl_stmt|;
name|DEBUG_ENSURE
argument_list|(
name|keytype
operator|<=
name|USHRT_MAX
argument_list|)
expr_stmt|;
name|DEBUG_ENSURE
argument_list|(
name|secretsize
operator|<
literal|4
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* 	 * See if we already have the key.  If so just stick in the 	 * new value. 	 */
name|sk
operator|=
name|auth_findkey
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk
operator|!=
name|NULL
operator|&&
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
comment|/* TALOS-CAN-0054: make sure we have a new buffer! */
if|if
condition|(
name|NULL
operator|!=
name|sk
operator|->
name|secret
condition|)
block|{
name|memset
argument_list|(
name|sk
operator|->
name|secret
argument_list|,
literal|0
argument_list|,
name|sk
operator|->
name|secretsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sk
operator|->
name|secret
argument_list|)
expr_stmt|;
block|}
name|sk
operator|->
name|secret
operator|=
name|emalloc
argument_list|(
name|secretsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sk
operator|->
name|type
operator|=
operator|(
name|u_short
operator|)
name|keytype
expr_stmt|;
name|sk
operator|->
name|secretsize
operator|=
name|secretsize
expr_stmt|;
comment|/* make sure access lists don't leak here! */
if|if
condition|(
name|ka
operator|!=
name|sk
operator|->
name|keyacclist
condition|)
block|{
name|keyacc_all_free
argument_list|(
name|sk
operator|->
name|keyacclist
argument_list|)
expr_stmt|;
name|sk
operator|->
name|keyacclist
operator|=
name|ka
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DISABLE_BUG1243_FIX
name|memcpy
argument_list|(
name|sk
operator|->
name|secret
argument_list|,
name|key
argument_list|,
name|secretsize
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*>MUST< use 'strncpy()' here! See above! */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sk
operator|->
name|secret
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
name|secretsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|authcache_flush_id
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Need to allocate new structure.  Do it. 	 */
name|secret
operator|=
name|emalloc
argument_list|(
name|secretsize
operator|+
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DISABLE_BUG1243_FIX
name|memcpy
argument_list|(
name|secret
argument_list|,
name|key
argument_list|,
name|secretsize
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*>MUST< use 'strncpy()' here! See above! */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|secret
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
name|secretsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|allocsymkey
argument_list|(
name|keyno
argument_list|,
literal|0
argument_list|,
operator|(
name|u_short
operator|)
name|keytype
argument_list|,
literal|0
argument_list|,
name|secretsize
argument_list|,
name|secret
argument_list|,
name|ka
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
block|{
name|size_t
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"auth_setkey: key %d type %d len %d "
argument_list|,
operator|(
name|int
operator|)
name|keyno
argument_list|,
name|keytype
argument_list|,
operator|(
name|int
operator|)
name|secretsize
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|secretsize
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|secret
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * auth_delkeys - delete non-autokey untrusted keys, and clear all info  *                except the trusted bit of non-autokey trusted keys, in  *		  preparation for rereading the keys file.  */
end_comment

begin_function
name|void
name|auth_delkeys
parameter_list|(
name|void
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|ITER_DLIST_BEGIN
argument_list|(
argument|key_listhead
argument_list|,
argument|sk
argument_list|,
argument|llink
argument_list|,
argument|symkey
argument_list|)
if|if
condition|(
name|sk
operator|->
name|keyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
comment|/* autokey */
continue|continue;
block|}
comment|/* 		 * Don't lose info as to which keys are trusted. Make 		 * sure there are no dangling pointers! 		 */
if|if
condition|(
name|KEY_TRUSTED
operator|&
name|sk
operator|->
name|flags
condition|)
block|{
if|if
condition|(
name|sk
operator|->
name|secret
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|sk
operator|->
name|secret
argument_list|,
literal|0
argument_list|,
name|sk
operator|->
name|secretsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sk
operator|->
name|secret
argument_list|)
expr_stmt|;
name|sk
operator|->
name|secret
operator|=
name|NULL
expr_stmt|;
comment|/* TALOS-CAN-0054 */
block|}
name|sk
operator|->
name|keyacclist
operator|=
name|keyacc_all_free
argument_list|(
name|sk
operator|->
name|keyacclist
argument_list|)
expr_stmt|;
name|sk
operator|->
name|secretsize
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|freesymkey
argument_list|(
name|sk
argument_list|)
expr_stmt|;
block|}
name|ITER_DLIST_END
argument_list|()
block|}
end_function

begin_comment
comment|/*  * auth_agekeys - delete keys whose lifetimes have expired  */
end_comment

begin_function
name|void
name|auth_agekeys
parameter_list|(
name|void
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|ITER_DLIST_BEGIN
argument_list|(
argument|key_listhead
argument_list|,
argument|sk
argument_list|,
argument|llink
argument_list|,
argument|symkey
argument_list|)
if|if
condition|(
name|sk
operator|->
name|lifetime
operator|>
literal|0
operator|&&
name|current_time
operator|>
name|sk
operator|->
name|lifetime
condition|)
block|{
name|freesymkey
argument_list|(
name|sk
argument_list|)
expr_stmt|;
name|authkeyexpired
operator|++
expr_stmt|;
block|}
name|ITER_DLIST_END
argument_list|()
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"auth_agekeys: at %lu keys %lu expired %lu\n"
operator|,
name|current_time
operator|,
name|authnumkeys
operator|,
name|authkeyexpired
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * authencrypt - generate message authenticator  *  * Returns length of authenticator field, zero if key not found.  */
end_comment

begin_function
name|size_t
name|authencrypt
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|u_int32
modifier|*
name|pkt
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
comment|/* 	 * A zero key identifier means the sender has not verified 	 * the last message was correctly authenticated. The MAC 	 * consists of a single word with value zero. 	 */
name|authencryptions
operator|++
expr_stmt|;
name|pkt
index|[
name|length
operator|/
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|keyno
condition|)
block|{
return|return
literal|4
return|;
block|}
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|MD5authencrypt
argument_list|(
name|cache_type
argument_list|,
name|cache_secret
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * authdecrypt - verify message authenticator  *  * Returns TRUE if authenticator valid, FALSE if invalid or not found.  */
end_comment

begin_function
name|int
name|authdecrypt
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|u_int32
modifier|*
name|pkt
parameter_list|,
name|size_t
name|length
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
comment|/* 	 * A zero key identifier means the sender has not verified 	 * the last message was correctly authenticated.  For our 	 * purpose this is an invalid authenticator. 	 */
name|authdecryptions
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|keyno
operator|||
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
operator|||
name|size
operator|<
literal|4
condition|)
block|{
return|return
name|FALSE
return|;
block|}
return|return
name|MD5authdecrypt
argument_list|(
name|cache_type
argument_list|,
name|cache_secret
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

end_unit

