begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * authkeys.c - routines to manage the storage of authentication keys  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_malloc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Structure to store keys in in the hash table.  */
end_comment

begin_struct
struct|struct
name|savekey
block|{
name|struct
name|savekey
modifier|*
name|next
decl_stmt|;
union|union
block|{
name|long
name|bogon
decl_stmt|;
comment|/* Make sure nonempty */
ifdef|#
directive|ifdef
name|DES
name|u_int32
name|DES_key
index|[
literal|2
index|]
decl_stmt|;
comment|/* DES key */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD5
name|u_char
name|MD5_key
index|[
literal|32
index|]
decl_stmt|;
comment|/* MD5 key */
endif|#
directive|endif
block|}
name|k
union|;
name|u_long
name|keyid
decl_stmt|;
comment|/* key identifier */
name|u_short
name|flags
decl_stmt|;
comment|/* flags that wave */
name|u_long
name|lifetime
decl_stmt|;
comment|/* remaining lifetime */
ifdef|#
directive|ifdef
name|MD5
name|int
name|keylen
decl_stmt|;
comment|/* key length */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KEY_TRUSTED
value|0x001
end_define

begin_comment
comment|/* this key is trusted */
end_comment

begin_define
define|#
directive|define
name|KEY_DES
value|0x100
end_define

begin_comment
comment|/* this is a DES type key */
end_comment

begin_define
define|#
directive|define
name|KEY_MD5
value|0x200
end_define

begin_comment
comment|/* this is a MD5 type key */
end_comment

begin_comment
comment|/*  * The hash table. This is indexed by the low order bits of the  * keyid. We make this fairly big for potentially busy servers.  */
end_comment

begin_define
define|#
directive|define
name|HASHSIZE
value|64
end_define

begin_define
define|#
directive|define
name|HASHMASK
value|((HASHSIZE)-1)
end_define

begin_define
define|#
directive|define
name|KEYHASH
parameter_list|(
name|keyid
parameter_list|)
value|((keyid)& HASHMASK)
end_define

begin_decl_stmt
name|struct
name|savekey
modifier|*
name|key_hash
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|authkeynotfound
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keys not found */
end_comment

begin_decl_stmt
name|u_long
name|authkeylookups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to lookup keys */
end_comment

begin_decl_stmt
name|u_long
name|authnumkeys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of active keys */
end_comment

begin_decl_stmt
name|u_long
name|authkeyexpired
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key lifetime expirations */
end_comment

begin_decl_stmt
name|u_long
name|authkeyuncached
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache misses */
end_comment

begin_decl_stmt
name|u_long
name|authnokey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to encrypt with no key */
end_comment

begin_decl_stmt
name|u_long
name|authencryptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to encrypt */
end_comment

begin_decl_stmt
name|u_long
name|authdecryptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to decrypt */
end_comment

begin_comment
comment|/*  * Storage for free key structures.  We malloc() such things but  * never free them.  */
end_comment

begin_decl_stmt
name|struct
name|savekey
modifier|*
name|authfreekeys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|authnumfreekeys
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MEMINC
value|12
end_define

begin_comment
comment|/* number of new free ones to get */
end_comment

begin_comment
comment|/*  * The key cache. We cache the last key we looked at here.  */
end_comment

begin_decl_stmt
name|u_long
name|cache_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key identifier */
end_comment

begin_decl_stmt
name|u_char
modifier|*
name|cache_key
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key pointer */
end_comment

begin_decl_stmt
name|u_int
name|cache_keylen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key length */
end_comment

begin_decl_stmt
name|u_short
name|cache_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags that wave */
end_comment

begin_comment
comment|/*  * init_auth - initialize internal data  */
end_comment

begin_function
name|void
name|init_auth
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Initialize hash table and free list 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key_hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|key_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * auth_findkey - find a key in the hash table  */
end_comment

begin_function
name|struct
name|savekey
modifier|*
name|auth_findkey
parameter_list|(
name|u_long
name|keyno
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
return|return
operator|(
name|sk
operator|)
return|;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * auth_havekey - return one if the key is known  */
end_comment

begin_function
name|int
name|auth_havekey
parameter_list|(
name|u_long
name|keyno
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
if|if
condition|(
name|keyno
operator|==
literal|0
operator|||
operator|(
name|keyno
operator|==
name|cache_keyid
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * authhavekey - return one and cache the key, if known and trusted.  */
end_comment

begin_function
name|int
name|authhavekey
parameter_list|(
name|u_long
name|keyno
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|authkeylookups
operator|++
expr_stmt|;
if|if
condition|(
name|keyno
operator|==
literal|0
operator|||
name|keyno
operator|==
name|cache_keyid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|authkeyuncached
operator|++
expr_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
break|break;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sk
operator|==
literal|0
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|sk
operator|->
name|flags
operator|&
name|KEY_TRUSTED
operator|)
condition|)
block|{
name|authnokey
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cache_keyid
operator|=
name|sk
operator|->
name|keyid
expr_stmt|;
name|cache_flags
operator|=
name|sk
operator|->
name|flags
expr_stmt|;
ifdef|#
directive|ifdef
name|MD5
if|if
condition|(
name|sk
operator|->
name|flags
operator|&
name|KEY_MD5
condition|)
block|{
name|cache_key
operator|=
name|sk
operator|->
name|k
operator|.
name|MD5_key
expr_stmt|;
name|cache_keylen
operator|=
name|sk
operator|->
name|keylen
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DES
if|if
condition|(
name|sk
operator|->
name|flags
operator|&
name|KEY_DES
condition|)
block|{
name|cache_key
operator|=
operator|(
name|u_char
operator|*
operator|)
name|sk
operator|->
name|k
operator|.
name|DES_key
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * auth_moremem - get some more free key structures  */
end_comment

begin_function
name|int
name|auth_moremem
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sk
operator|=
operator|(
expr|struct
name|savekey
operator|*
operator|)
name|calloc
argument_list|(
name|MEMINC
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|savekey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
name|MEMINC
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sk
operator|->
name|next
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|++
expr_stmt|;
block|}
name|authnumfreekeys
operator|+=
name|MEMINC
expr_stmt|;
return|return
operator|(
name|authnumfreekeys
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * authtrust - declare a key to be trusted/untrusted  */
end_comment

begin_function
name|void
name|authtrust
parameter_list|(
name|u_long
name|keyno
parameter_list|,
name|int
name|trust
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"authtrust: keyid %08lx life %d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|keyno
argument_list|,
name|trust
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
break|break;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sk
operator|==
literal|0
operator|&&
operator|!
name|trust
condition|)
return|return;
if|if
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cache_keyid
operator|==
name|keyno
condition|)
block|{
name|cache_flags
operator|=
literal|0
expr_stmt|;
name|cache_keyid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|trust
operator|>
literal|0
condition|)
block|{
name|sk
operator|->
name|flags
operator||=
name|KEY_TRUSTED
expr_stmt|;
if|if
condition|(
name|trust
operator|>
literal|1
condition|)
name|sk
operator|->
name|lifetime
operator|=
name|current_time
operator|+
name|trust
expr_stmt|;
else|else
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sk
operator|->
name|flags
operator|&=
operator|~
name|KEY_TRUSTED
expr_stmt|;
block|{
name|struct
name|savekey
modifier|*
name|skp
decl_stmt|;
name|skp
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|skp
operator|==
name|sk
condition|)
block|{
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|skp
operator|->
name|next
operator|!=
name|sk
condition|)
name|skp
operator|=
name|skp
operator|->
name|next
expr_stmt|;
name|skp
operator|->
name|next
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
name|authnumkeys
operator|--
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
expr_stmt|;
name|authnumfreekeys
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|authnumfreekeys
operator|==
literal|0
condition|)
if|if
condition|(
name|auth_moremem
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|sk
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumfreekeys
operator|--
expr_stmt|;
name|sk
operator|->
name|keyid
operator|=
name|keyno
expr_stmt|;
name|sk
operator|->
name|flags
operator|=
name|KEY_TRUSTED
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
expr_stmt|;
name|authnumkeys
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * authistrusted - determine whether a key is trusted  */
end_comment

begin_function
name|int
name|authistrusted
parameter_list|(
name|u_long
name|keyno
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
if|if
condition|(
name|keyno
operator|==
name|cache_keyid
condition|)
return|return
operator|(
operator|(
name|cache_flags
operator|&
name|KEY_TRUSTED
operator|)
operator|!=
literal|0
operator|)
return|;
name|authkeyuncached
operator|++
expr_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
break|break;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sk
operator|==
literal|0
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|sk
operator|->
name|flags
operator|&
name|KEY_TRUSTED
operator|)
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DES
end_ifdef

begin_comment
comment|/*  * DESauth_setkey - set a key into the key array  */
end_comment

begin_function
name|void
name|DESauth_setkey
parameter_list|(
name|u_long
name|keyno
parameter_list|,
specifier|const
name|u_int32
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
comment|/* 	 * See if we already have the key.  If so just stick in the 	 * new value. 	 */
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
name|sk
operator|->
name|k
operator|.
name|DES_key
index|[
literal|0
index|]
operator|=
name|key
index|[
literal|0
index|]
expr_stmt|;
name|sk
operator|->
name|k
operator|.
name|DES_key
index|[
literal|1
index|]
operator|=
name|key
index|[
literal|1
index|]
expr_stmt|;
name|sk
operator|->
name|flags
operator||=
name|KEY_DES
expr_stmt|;
if|if
condition|(
name|cache_keyid
operator|==
name|keyno
condition|)
name|cache_flags
operator|=
literal|0
expr_stmt|;
name|cache_keyid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Need to allocate new structure.  Do it. 	 */
if|if
condition|(
name|authnumfreekeys
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|auth_moremem
argument_list|()
operator|==
literal|0
condition|)
return|return;
block|}
name|sk
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumfreekeys
operator|--
expr_stmt|;
name|sk
operator|->
name|k
operator|.
name|DES_key
index|[
literal|0
index|]
operator|=
name|key
index|[
literal|0
index|]
expr_stmt|;
name|sk
operator|->
name|k
operator|.
name|DES_key
index|[
literal|1
index|]
operator|=
name|key
index|[
literal|1
index|]
expr_stmt|;
name|sk
operator|->
name|keyid
operator|=
name|keyno
expr_stmt|;
name|sk
operator|->
name|flags
operator|=
name|KEY_DES
expr_stmt|;
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
expr_stmt|;
name|authnumkeys
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MD5
end_ifdef

begin_function
name|void
name|MD5auth_setkey
parameter_list|(
name|u_long
name|keyno
parameter_list|,
specifier|const
name|u_char
modifier|*
name|key
parameter_list|,
specifier|const
name|int
name|len
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
comment|/* 	 * See if we already have the key.  If so just stick in the 	 * new value. 	 */
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sk
operator|->
name|keylen
operator|=
name|len
operator|)
operator|>
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
condition|)
name|sk
operator|->
name|keylen
operator|=
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
expr_stmt|;
name|sk
operator|->
name|flags
operator||=
name|KEY_MD5
expr_stmt|;
if|if
condition|(
name|cache_keyid
operator|==
name|keyno
condition|)
block|{
name|cache_flags
operator|=
literal|0
expr_stmt|;
name|cache_keyid
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Need to allocate new structure.  Do it. 	 */
if|if
condition|(
name|authnumfreekeys
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|auth_moremem
argument_list|()
operator|==
literal|0
condition|)
return|return;
block|}
name|sk
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumfreekeys
operator|--
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sk
operator|->
name|keylen
operator|=
name|len
operator|)
operator|>
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
condition|)
name|sk
operator|->
name|keylen
operator|=
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
expr_stmt|;
name|sk
operator|->
name|keyid
operator|=
name|keyno
expr_stmt|;
name|sk
operator|->
name|flags
operator|=
name|KEY_MD5
expr_stmt|;
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
expr_stmt|;
name|authnumkeys
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * auth_delkeys - delete all known keys, in preparation for rereading  *		  the keys file (presumably)  */
end_comment

begin_function
name|void
name|auth_delkeys
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|struct
name|savekey
modifier|*
modifier|*
name|skp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|skp
operator|=
operator|&
operator|(
name|key_hash
index|[
name|i
index|]
operator|)
expr_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Leave autokey keys alone. 		 */
while|while
condition|(
name|sk
operator|!=
literal|0
operator|&&
name|sk
operator|->
name|keyid
operator|<=
name|NTP_MAXKEY
condition|)
block|{
comment|/* 			 * Don't loose info which keys are trusted. 			 */
if|if
condition|(
name|sk
operator|->
name|flags
operator|&
name|KEY_TRUSTED
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sk
operator|->
name|k
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MD5
name|sk
operator|->
name|keylen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
operator|*
name|skp
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumkeys
operator|--
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
expr_stmt|;
name|authnumfreekeys
operator|++
expr_stmt|;
name|sk
operator|=
operator|*
name|skp
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * auth_agekeys - delete keys whose lifetimes have expired  */
end_comment

begin_function
name|void
name|auth_agekeys
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|struct
name|savekey
modifier|*
name|skp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|sk
operator|=
name|skp
operator|=
name|key_hash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
name|skp
operator|=
name|sk
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|sk
operator|->
name|lifetime
operator|>
literal|0
operator|&&
name|current_time
operator|>
name|sk
operator|->
name|lifetime
condition|)
block|{
name|authtrust
argument_list|(
name|sk
operator|->
name|keyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|authkeyexpired
operator|++
expr_stmt|;
block|}
name|sk
operator|=
name|skp
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"auth_agekeys: at %lu keys %lu expired %lu\n"
argument_list|,
name|current_time
argument_list|,
name|authnumkeys
argument_list|,
name|authkeyexpired
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * authencrypt - generate message authenticator  *  * Returns length of authenticator field, zero if key not found.  */
end_comment

begin_function
name|int
name|authencrypt
parameter_list|(
name|u_long
name|keyno
parameter_list|,
name|u_int32
modifier|*
name|pkt
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|/* 	 * A zero key identifier means the sender has not verified 	 * the last message was correctly authenticated. The MAC 	 * consists of a single word with value zero. 	 */
name|authencryptions
operator|++
expr_stmt|;
name|pkt
index|[
name|length
operator|/
literal|4
index|]
operator|=
operator|(
name|u_long
operator|)
name|htonl
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyno
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|4
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DES
if|if
condition|(
name|cache_flags
operator|&
name|KEY_DES
condition|)
return|return
operator|(
name|DESauthencrypt
argument_list|(
name|cache_key
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD5
if|if
condition|(
name|cache_flags
operator|&
name|KEY_MD5
condition|)
return|return
operator|(
name|MD5authencrypt
argument_list|(
name|cache_key
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * authdecrypt - verify message authenticator  *  * Returns one if authenticator valid, zero if invalid or key not found.  */
end_comment

begin_function
name|int
name|authdecrypt
parameter_list|(
name|u_long
name|keyno
parameter_list|,
name|u_int32
modifier|*
name|pkt
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* 	 * A zero key identifier means the sender has not verified 	 * the last message was correctly authenticated. Nevertheless, 	 * the authenticator itself is considered valid. 	 */
name|authdecryptions
operator|++
expr_stmt|;
if|if
condition|(
name|keyno
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
operator|||
name|size
operator|<
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DES
if|if
condition|(
name|cache_flags
operator|&
name|KEY_DES
condition|)
return|return
operator|(
name|DESauthdecrypt
argument_list|(
name|cache_key
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|,
name|size
argument_list|)
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD5
if|if
condition|(
name|cache_flags
operator|&
name|KEY_MD5
condition|)
return|return
operator|(
name|MD5authdecrypt
argument_list|(
name|cache_key
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|,
name|size
argument_list|)
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

