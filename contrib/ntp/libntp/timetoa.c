begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * timetoa.c -- time_t related string formatting  *  * Written by Juergen Perlinger (perlinger@ntp.org) for the NTP project.  * The contents of 'html/copyright.html' apply.  *  * Printing a 'time_t' has a lot of portability pitfalls, due to it's  * opaque base type. The only requirement imposed by the standard is  * that it must be a numeric type. For all practical purposes it's a  * signed int, and 32 bits are common.  *  * Since the UN*X time epoch will cause a signed integer overflow for  * 32-bit signed int in the year 2038, implementations slowly move to  * 64bit base types for time_t, even in 32-bit environments.  *  * As the printf() family has no standardised type specifier for time_t,  * guessing the right output format specifier is a bit troublesome and  * best done with the help of the preprocessor and "config.h".  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"timetoa.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"lib_strbuf.h"
end_include

begin_comment
comment|/*  * Formatting to string needs at max 40 bytes (even with 64 bit time_t),  * so we check LIB_BUFLENGTH is big enough for our purpose.  */
end_comment

begin_if
if|#
directive|if
name|LIB_BUFLENGTH
operator|<
literal|40
end_if

begin_include
include|#
directive|include
file|"GRONK: LIB_BUFLENGTH is not sufficient"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * general fractional timestamp formatting  *  * Many pieces of ntpd require a machine with two's complement  * representation of signed integers, so we don't go through the whole  * rigamarole of creating fully portable code here. But we have to stay  * away from signed integer overflow, as this might cause trouble even  * with two's complement representation.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|format_time_fraction
parameter_list|(
name|time_t
name|secs
parameter_list|,
name|long
name|frac
parameter_list|,
name|int
name|prec
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|u_int
name|prec_u
decl_stmt|;
name|u_time
name|secs_u
decl_stmt|;
name|u_int
name|u
decl_stmt|;
name|long
name|fraclimit
decl_stmt|;
name|int
name|notneg
decl_stmt|;
comment|/* flag for non-negative value	*/
name|ldiv_t
name|qr
decl_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|prec
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|LIB_GETBUF
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|secs_u
operator|=
operator|(
name|u_time
operator|)
name|secs
expr_stmt|;
comment|/* check if we need signed or unsigned mode */
name|notneg
operator|=
operator|(
name|prec
operator|<
literal|0
operator|)
expr_stmt|;
name|prec_u
operator|=
name|abs
argument_list|(
name|prec
argument_list|)
expr_stmt|;
comment|/* fraclimit = (long)pow(10, prec_u); */
for|for
control|(
name|fraclimit
operator|=
literal|10
operator|,
name|u
operator|=
literal|1
init|;
name|u
operator|<
name|prec_u
condition|;
name|u
operator|++
control|)
block|{
name|DEBUG_INSIST
argument_list|(
name|fraclimit
operator|<
name|fraclimit
operator|*
literal|10
argument_list|)
expr_stmt|;
name|fraclimit
operator|*=
literal|10
expr_stmt|;
block|}
comment|/* 	 * Since conversion to string uses lots of divisions anyway, 	 * there's no big extra penalty for normalisation. We do it for 	 * consistency. 	 */
if|if
condition|(
name|frac
operator|<
literal|0
operator|||
name|frac
operator|>=
name|fraclimit
condition|)
block|{
name|qr
operator|=
name|ldiv
argument_list|(
name|frac
argument_list|,
name|fraclimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|qr
operator|.
name|rem
operator|<
literal|0
condition|)
block|{
name|qr
operator|.
name|quot
operator|--
expr_stmt|;
name|qr
operator|.
name|rem
operator|+=
name|fraclimit
expr_stmt|;
block|}
name|secs_u
operator|+=
operator|(
name|time_t
operator|)
name|qr
operator|.
name|quot
expr_stmt|;
name|frac
operator|=
name|qr
operator|.
name|rem
expr_stmt|;
block|}
comment|/* Get the absolute value of the split representation time. */
name|notneg
operator|=
name|notneg
operator|||
operator|(
operator|(
name|time_t
operator|)
name|secs_u
operator|>=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|notneg
condition|)
block|{
name|secs_u
operator|=
operator|~
name|secs_u
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|frac
condition|)
name|secs_u
operator|++
expr_stmt|;
else|else
name|frac
operator|=
name|fraclimit
operator|-
name|frac
expr_stmt|;
block|}
comment|/* finally format the data and return the result */
name|snprintf
argument_list|(
name|cp
argument_list|,
name|LIB_BUFLENGTH
argument_list|,
literal|"%s%"
name|UTIME_FORMAT
literal|".%0*ld"
argument_list|,
name|notneg
condition|?
literal|""
else|:
literal|"-"
argument_list|,
name|secs_u
argument_list|,
name|prec_u
argument_list|,
name|frac
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

end_unit

