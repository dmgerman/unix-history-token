begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_calendar.c - calendar and helper functions  *  * Written by Juergen Perlinger (perlinger@ntp.org) for the NTP project.  * The contents of 'html/copyright.html' apply.  *  * --------------------------------------------------------------------  * Some notes on the implementation:  *  * Calendar algorithms thrive on the division operation, which is one of  * the slowest numerical operations in any CPU. What saves us here from  * abysmal performance is the fact that all divisions are divisions by  * constant numbers, and most compilers can do this by a multiplication  * operation.  But this might not work when using the div/ldiv/lldiv  * function family, because many compilers are not able to do inline  * expansion of the code with following optimisation for the  * constant-divider case.  *  * Also div/ldiv/lldiv are defined in terms of int/long/longlong, which  * are inherently target dependent. Nothing that could not be cured with  * autoconf, but still a mess...  *  * Furthermore, we need floor division in many places. C either leaves  * the division behaviour undefined (< C99) or demands truncation to  * zero (>= C99), so additional steps are required to make sure the  * algorithms work. The {l,ll}div function family is requested to  * truncate towards zero, which is also the wrong direction for our  * purpose.  *  * For all this, all divisions by constant are coded manually, even when  * there is a joined div/mod operation: The optimiser should sort that  * out, if possible. Most of the calculations are done with unsigned  * types, explicitely using two's complement arithmetics where  * necessary. This minimises the dependecies to compiler and target,  * while still giving reasonable to good performance.  *  * The implementation uses a few tricks that exploit properties of the  * two's complement: Floor division on negative dividents can be  * executed by using the one's complement of the divident. One's  * complement can be easily created using XOR and a mask.  *  * Finally, check for overflow conditions is minimal. There are only two  * calculation steps in the whole calendar that suffer from an internal  * overflow, and these conditions are checked: errno is set to EDOM and  * the results are clamped/saturated in this case.  All other functions  * do not suffer from internal overflow and simply return the result  * truncated to 32 bits.  *  * This is a sacrifice made for execution speed.  Since a 32-bit day  * counter covers +/- 5,879,610 years and the clamp limits the effective  * range to +/-2.9 million years, this should not pose a problem here.  *  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_comment
comment|/* For now, let's take the conservative approach: if the target property  * macros are not defined, check a few well-known compiler/architecture  * settings. Default is to assume that the representation of signed  * integers is unknown and shift-arithmetic-right is not available.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_HAS_2CPL
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__arm__
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_HAS_2CPL
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TARGET_HAS_2CPL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_ARM
argument_list|)
end_if

begin_define
define|#
directive|define
name|TARGET_HAS_2CPL
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TARGET_HAS_2CPL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TARGET_HAS_2CPL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_HAS_SAR
end_ifndef

begin_define
define|#
directive|define
name|TARGET_HAS_SAR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *---------------------------------------------------------------------  * replacing the 'time()' function  *---------------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|static
name|systime_func_ptr
name|systime_func
init|=
operator|&
name|time
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|inline
name|time_t
name|now
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|systime_func_ptr
name|ntpcal_set_timefunc
parameter_list|(
name|systime_func_ptr
name|nfunc
parameter_list|)
block|{
name|systime_func_ptr
name|res
decl_stmt|;
name|res
operator|=
name|systime_func
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|nfunc
condition|)
name|nfunc
operator|=
operator|&
name|time
expr_stmt|;
name|systime_func
operator|=
name|nfunc
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|time_t
name|now
parameter_list|(
name|void
parameter_list|)
block|{
return|return
call|(
modifier|*
name|systime_func
call|)
argument_list|(
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Get sign extension mask and unsigned 2cpl rep for a signed integer  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|int32_sflag
parameter_list|(
specifier|const
name|int32_t
name|v
parameter_list|)
block|{
if|#
directive|if
name|TARGET_HAS_2CPL
operator|&&
name|TARGET_HAS_SAR
operator|&&
name|SIZEOF_INT
operator|>=
literal|4
comment|/* Let's assume that shift is the fastest way to get the sign 	 * extension of of a signed integer. This might not always be 	 * true, though -- On 8bit CPUs or machines without barrel 	 * shifter this will kill the performance. So we make sure 	 * we do this only if 'int' has at least 4 bytes. 	 */
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|v
operator|>>
literal|31
argument_list|)
return|;
else|#
directive|else
comment|/* This should be a rather generic approach for getting a sign 	 * extension mask... 	 */
return|return
name|UINT32_C
argument_list|(
literal|0
argument_list|)
operator|-
call|(
name|uint32_t
call|)
argument_list|(
name|v
operator|<
literal|0
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|int32_to_uint32_2cpl
parameter_list|(
specifier|const
name|int32_t
name|v
parameter_list|)
block|{
name|uint32_t
name|vu
decl_stmt|;
if|#
directive|if
name|TARGET_HAS_2CPL
comment|/* Just copy through the 32 bits from the signed value if we're 	 * on a two's complement target. 	 */
name|vu
operator|=
operator|(
name|uint32_t
operator|)
name|v
expr_stmt|;
else|#
directive|else
comment|/* Convert from signed int to unsigned int two's complement. Do 	 * not make any assumptions about the representation of signed 	 * integers, but make sure signed integer overflow cannot happen 	 * here. A compiler on a two's complement target *might* find 	 * out that this is just a complicated cast (as above), but your 	 * mileage might vary. 	 */
if|if
condition|(
name|v
operator|<
literal|0
condition|)
name|vu
operator|=
operator|~
call|(
name|uint32_t
call|)
argument_list|(
operator|-
operator|(
name|v
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
name|vu
operator|=
operator|(
name|uint32_t
operator|)
name|v
expr_stmt|;
endif|#
directive|endif
return|return
name|vu
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int32_t
name|uint32_2cpl_to_int32
parameter_list|(
specifier|const
name|uint32_t
name|vu
parameter_list|)
block|{
name|int32_t
name|v
decl_stmt|;
if|#
directive|if
name|TARGET_HAS_2CPL
comment|/* Just copy through the 32 bits from the unsigned value if 	 * we're on a two's complement target. 	 */
name|v
operator|=
operator|(
name|int32_t
operator|)
name|vu
expr_stmt|;
else|#
directive|else
comment|/* Convert to signed integer, making sure signed integer 	 * overflow cannot happen. Again, the optimiser might or might 	 * not find out that this is just a copy of 32 bits on a target 	 * with two's complement representation for signed integers. 	 */
if|if
condition|(
name|vu
operator|>
name|INT32_MAX
condition|)
name|v
operator|=
operator|-
call|(
name|int32_t
call|)
argument_list|(
operator|~
name|vu
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|v
operator|=
operator|(
name|int32_t
operator|)
name|vu
expr_stmt|;
endif|#
directive|endif
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Some of the calculations need to multiply the input by 4 before doing  * a division. This can cause overflow and strange results. Therefore we  * clamp / saturate the input operand. And since we do the calculations  * in unsigned int with an extra sign flag/mask, we only loose one bit  * of the input value range.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|uint32_saturate
parameter_list|(
name|uint32_t
name|vu
parameter_list|,
name|uint32_t
name|mu
parameter_list|)
block|{
specifier|static
specifier|const
name|uint32_t
name|limit
init|=
name|UINT32_MAX
operator|/
literal|4u
decl_stmt|;
if|if
condition|(
operator|(
name|mu
operator|^
name|vu
operator|)
operator|>
name|limit
condition|)
block|{
name|vu
operator|=
name|mu
operator|^
name|limit
expr_stmt|;
name|errno
operator|=
name|EDOM
expr_stmt|;
block|}
return|return
name|vu
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert between 'time_t' and 'vint64'  *---------------------------------------------------------------------  */
end_comment

begin_function
name|vint64
name|time_to_vint64
parameter_list|(
specifier|const
name|time_t
modifier|*
name|ptt
parameter_list|)
block|{
name|vint64
name|res
decl_stmt|;
name|time_t
name|tt
decl_stmt|;
name|tt
operator|=
operator|*
name|ptt
expr_stmt|;
if|#
directive|if
name|SIZEOF_TIME_T
operator|<=
literal|4
name|res
operator|.
name|D_s
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tt
operator|<
literal|0
condition|)
block|{
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|uint32_t
operator|)
operator|-
name|tt
expr_stmt|;
name|M_NEG
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|uint32_t
operator|)
name|tt
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_INT64
argument_list|)
name|res
operator|.
name|q_s
operator|=
name|tt
expr_stmt|;
else|#
directive|else
comment|/* 	 * shifting negative signed quantities is compiler-dependent, so 	 * we better avoid it and do it all manually. And shifting more 	 * than the width of a quantity is undefined. Also a don't do! 	 */
if|if
condition|(
name|tt
operator|<
literal|0
condition|)
block|{
name|tt
operator|=
operator|-
name|tt
expr_stmt|;
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|uint32_t
operator|)
name|tt
expr_stmt|;
name|res
operator|.
name|D_s
operator|.
name|hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|tt
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|M_NEG
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|uint32_t
operator|)
name|tt
expr_stmt|;
name|res
operator|.
name|D_s
operator|.
name|hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|tt
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|res
return|;
block|}
end_function

begin_function
name|time_t
name|vint64_to_time
parameter_list|(
specifier|const
name|vint64
modifier|*
name|tv
parameter_list|)
block|{
name|time_t
name|res
decl_stmt|;
if|#
directive|if
name|SIZEOF_TIME_T
operator|<=
literal|4
name|res
operator|=
operator|(
name|time_t
operator|)
name|tv
operator|->
name|D_s
operator|.
name|lo
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_INT64
argument_list|)
name|res
operator|=
operator|(
name|time_t
operator|)
name|tv
operator|->
name|q_s
expr_stmt|;
else|#
directive|else
name|res
operator|=
operator|(
operator|(
name|time_t
operator|)
name|tv
operator|->
name|d_s
operator|.
name|hi
operator|<<
literal|32
operator|)
operator||
name|tv
operator|->
name|D_s
operator|.
name|lo
expr_stmt|;
endif|#
directive|endif
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Get the build date& time  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_get_build_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
comment|/* The C standard tells us the format of '__DATE__': 	 * 	 * __DATE__ The date of translation of the preprocessing 	 * translation unit: a character string literal of the form "Mmm 	 * dd yyyy", where the names of the months are the same as those 	 * generated by the asctime function, and the first character of 	 * dd is a space character if the value is less than 10. If the 	 * date of translation is not available, an 	 * implementation-defined valid date shall be supplied. 	 * 	 * __TIME__ The time of translation of the preprocessing 	 * translation unit: a character string literal of the form 	 * "hh:mm:ss" as in the time generated by the asctime 	 * function. If the time of translation is not available, an 	 * implementation-defined valid time shall be supplied. 	 * 	 * Note that MSVC declares DATE and TIME to be in the local time 	 * zone, while neither the C standard nor the GCC docs make any 	 * statement about this. As a result, we may be +/-12hrs off 	 * UTC.  But for practical purposes, this should not be a 	 * problem. 	 * 	 */
ifdef|#
directive|ifdef
name|MKREPRO_DATE
specifier|static
specifier|const
name|char
name|build
index|[]
init|=
name|MKREPRO_TIME
literal|"/"
name|MKREPRO_DATE
decl_stmt|;
else|#
directive|else
specifier|static
specifier|const
name|char
name|build
index|[]
init|=
name|__TIME__
literal|"/"
name|__DATE__
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|const
name|char
name|mlist
index|[]
init|=
literal|"JanFebMarAprMayJunJulAugSepOctNovDec"
decl_stmt|;
name|char
name|monstr
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|short
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|day
decl_stmt|,
name|year
decl_stmt|;
comment|/* Note: The above quantities are used for sscanf 'hu' format, 	 * so using 'uint16_t' is contra-indicated! 	 */
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|int
name|ignore
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|ZERO
argument_list|(
operator|*
name|jd
argument_list|)
expr_stmt|;
name|jd
operator|->
name|year
operator|=
literal|1970
expr_stmt|;
name|jd
operator|->
name|month
operator|=
literal|1
expr_stmt|;
name|jd
operator|->
name|monthday
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* check environment if build date should be ignored */
if|if
condition|(
literal|0
operator|==
name|ignore
condition|)
block|{
specifier|const
name|char
modifier|*
name|envstr
decl_stmt|;
name|envstr
operator|=
name|getenv
argument_list|(
literal|"NTPD_IGNORE_BUILD_DATE"
argument_list|)
expr_stmt|;
name|ignore
operator|=
literal|1
operator|+
operator|(
name|envstr
operator|&&
operator|(
operator|!
operator|*
name|envstr
operator|||
operator|!
name|strcasecmp
argument_list|(
name|envstr
argument_list|,
literal|"yes"
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ignore
operator|>
literal|1
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
if|if
condition|(
literal|6
operator|==
name|sscanf
argument_list|(
name|build
argument_list|,
literal|"%hu:%hu:%hu/%3s %hu %hu"
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|minute
argument_list|,
operator|&
name|second
argument_list|,
name|monstr
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|year
argument_list|)
condition|)
block|{
name|cp
operator|=
name|strstr
argument_list|(
name|mlist
argument_list|,
name|monstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|cp
condition|)
block|{
name|jd
operator|->
name|year
operator|=
name|year
expr_stmt|;
name|jd
operator|->
name|month
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|mlist
operator|)
operator|/
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
name|jd
operator|->
name|monthday
operator|=
operator|(
name|uint8_t
operator|)
name|day
expr_stmt|;
name|jd
operator|->
name|hour
operator|=
operator|(
name|uint8_t
operator|)
name|hour
expr_stmt|;
name|jd
operator|->
name|minute
operator|=
operator|(
name|uint8_t
operator|)
name|minute
expr_stmt|;
name|jd
operator|->
name|second
operator|=
operator|(
name|uint8_t
operator|)
name|second
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * basic calendar stuff  *---------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* month table for a year starting with March,1st */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|shift_month_table
index|[
literal|13
index|]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|61
block|,
literal|92
block|,
literal|122
block|,
literal|153
block|,
literal|184
block|,
literal|214
block|,
literal|245
block|,
literal|275
block|,
literal|306
block|,
literal|337
block|,
literal|366
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* month tables for years starting with January,1st; regular& leap */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|real_month_table
index|[
literal|2
index|]
index|[
literal|13
index|]
init|=
block|{
comment|/* -*- table for regular years -*- */
block|{
literal|0
block|,
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|,
literal|365
block|}
block|,
comment|/* -*- table for leap years -*- */
block|{
literal|0
block|,
literal|31
block|,
literal|60
block|,
literal|91
block|,
literal|121
block|,
literal|152
block|,
literal|182
block|,
literal|213
block|,
literal|244
block|,
literal|274
block|,
literal|305
block|,
literal|335
block|,
literal|366
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Some notes on the terminology:  *  * We use the proleptic Gregorian calendar, which is the Gregorian  * calendar extended in both directions ad infinitum. This totally  * disregards the fact that this calendar was invented in 1582, and  * was adopted at various dates over the world; sometimes even after  * the start of the NTP epoch.  *  * Normally date parts are given as current cycles, while time parts  * are given as elapsed cycles:  *  * 1970-01-01/03:04:05 means 'IN the 1970st. year, IN the first month,  * ON the first day, with 3hrs, 4minutes and 5 seconds elapsed.  *  * The basic calculations for this calendar implementation deal with  * ELAPSED date units, which is the number of full years, full months  * and full days before a date: 1970-01-01 would be (1969, 0, 0) in  * that notation.  *  * To ease the numeric computations, month and day values outside the  * normal range are acceptable: 2001-03-00 will be treated as the day  * before 2001-03-01, 2000-13-32 will give the same result as  * 2001-02-01 and so on.  *  * 'rd' or 'RD' is used as an abbreviation for the latin 'rata die'  * (day number).  This is the number of days elapsed since 0000-12-31  * in the proleptic Gregorian calendar. The begin of the Christian Era  * (0001-01-01) is RD(1).  */
end_comment

begin_comment
comment|/*  * ====================================================================  *  * General algorithmic stuff  *  * ====================================================================  */
end_comment

begin_comment
comment|/*  *---------------------------------------------------------------------  * Do a periodic extension of 'value' around 'pivot' with a period of  * 'cycle'.  *  * The result 'res' is a number that holds to the following properties:  *  *   1)	 res MOD cycle == value MOD cycle  *   2)	 pivot<= res< pivot + cycle  *	 (replace</<= with>/>= for negative cycles)  *  * where 'MOD' denotes the modulo operator for FLOOR DIVISION, which  * is not the same as the '%' operator in C: C requires division to be  * a truncated division, where remainder and dividend have the same  * sign if the remainder is not zero, whereas floor division requires  * divider and modulus to have the same sign for a non-zero modulus.  *  * This function has some useful applications:  *  * + let Y be a calendar year and V a truncated 2-digit year: then  *	periodic_extend(Y-50, V, 100)  *   is the closest expansion of the truncated year with respect to  *   the full year, that is a 4-digit year with a difference of less  *   than 50 years to the year Y. ("century unfolding")  *  * + let T be a UN*X time stamp and V be seconds-of-day: then  *	perodic_extend(T-43200, V, 86400)  *   is a time stamp that has the same seconds-of-day as the input  *   value, with an absolute difference to T of<= 12hrs.  ("day  *   unfolding")  *  * + Wherever you have a truncated periodic value and a non-truncated  *   base value and you want to match them somehow...  *  * Basically, the function delivers 'pivot + (value - pivot) % cycle',  * but the implementation takes some pains to avoid internal signed  * integer overflows in the '(value - pivot) % cycle' part and adheres  * to the floor division convention.  *  * If 64bit scalars where available on all intended platforms, writing a  * version that uses 64 bit ops would be easy; writing a general  * division routine for 64bit ops on a platform that can only do  * 32/16bit divisions and is still performant is a bit more  * difficult. Since most usecases can be coded in a way that does only  * require the 32-bit version a 64bit version is NOT provided here.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_periodic_extend
parameter_list|(
name|int32_t
name|pivot
parameter_list|,
name|int32_t
name|value
parameter_list|,
name|int32_t
name|cycle
parameter_list|)
block|{
name|uint32_t
name|diff
decl_stmt|;
name|char
name|cpl
init|=
literal|0
decl_stmt|;
comment|/* modulo complement flag */
name|char
name|neg
init|=
literal|0
decl_stmt|;
comment|/* sign change flag	    */
comment|/* make the cycle positive and adjust the flags */
if|if
condition|(
name|cycle
operator|<
literal|0
condition|)
block|{
name|cycle
operator|=
operator|-
name|cycle
expr_stmt|;
name|neg
operator|^=
literal|1
expr_stmt|;
name|cpl
operator|^=
literal|1
expr_stmt|;
block|}
comment|/* guard against div by zero or one */
if|if
condition|(
name|cycle
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Get absolute difference as unsigned quantity and 		 * the complement flag. This is done by always 		 * subtracting the smaller value from the bigger 		 * one. 		 */
if|if
condition|(
name|value
operator|>=
name|pivot
condition|)
block|{
name|diff
operator|=
name|int32_to_uint32_2cpl
argument_list|(
name|value
argument_list|)
operator|-
name|int32_to_uint32_2cpl
argument_list|(
name|pivot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diff
operator|=
name|int32_to_uint32_2cpl
argument_list|(
name|pivot
argument_list|)
operator|-
name|int32_to_uint32_2cpl
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|cpl
operator|^=
literal|1
expr_stmt|;
block|}
name|diff
operator|%=
operator|(
name|uint32_t
operator|)
name|cycle
expr_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
if|if
condition|(
name|cpl
condition|)
name|diff
operator|=
operator|(
name|uint32_t
operator|)
name|cycle
operator|-
name|diff
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|diff
operator|=
operator|~
name|diff
operator|+
literal|1
expr_stmt|;
name|pivot
operator|+=
name|uint32_2cpl_to_int32
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pivot
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------  * Note to the casual reader  *  * In the next two functions you will find (or would have found...)  * the expression  *  *   res.Q_s -= 0x80000000;  *  * There was some ruckus about a possible programming error due to  * integer overflow and sign propagation.  *  * This assumption is based on a lack of understanding of the C  * standard. (Though this is admittedly not one of the most 'natural'  * aspects of the 'C' language and easily to get wrong.)  *  * see   *	http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf  *	"ISO/IEC 9899:201x Committee Draft â April 12, 2011"  *	6.4.4.1 Integer constants, clause 5  *  * why there is no sign extension/overflow problem here.  *  * But to ease the minds of the doubtful, I added back the 'u' qualifiers  * that somehow got lost over the last years.   */
end_comment

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert a timestamp in NTP scale to a 64bit seconds value in the UN*X  * scale with proper epoch unfolding around a given pivot or the current  * system time. This function happily accepts negative pivot values as  * timestamps befor 1970-01-01, so be aware of possible trouble on  * platforms with 32bit 'time_t'!  *  * This is also a periodic extension, but since the cycle is 2^32 and  * the shift is 2^31, we can do some *very* fast math without explicit  * divisions.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|vint64
name|ntpcal_ntp_to_time
parameter_list|(
name|uint32_t
name|ntp
parameter_list|,
specifier|const
name|time_t
modifier|*
name|pivot
parameter_list|)
block|{
name|vint64
name|res
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_INT64
argument_list|)
name|res
operator|.
name|q_s
operator|=
operator|(
name|pivot
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|pivot
else|:
name|now
argument_list|()
expr_stmt|;
name|res
operator|.
name|Q_s
operator|-=
literal|0x80000000u
expr_stmt|;
comment|/* unshift of half range */
name|ntp
operator|-=
operator|(
name|uint32_t
operator|)
name|JAN_1970
expr_stmt|;
comment|/* warp into UN*X domain */
name|ntp
operator|-=
name|res
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
comment|/* cycle difference	 */
name|res
operator|.
name|Q_s
operator|+=
operator|(
name|uint64_t
operator|)
name|ntp
expr_stmt|;
comment|/* get expanded time	 */
else|#
directive|else
comment|/* no 64bit scalars */
name|time_t
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|pivot
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|pivot
else|:
name|now
argument_list|()
expr_stmt|;
name|res
operator|=
name|time_to_vint64
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
literal|0
argument_list|,
literal|0x80000000u
argument_list|)
expr_stmt|;
name|ntp
operator|-=
operator|(
name|uint32_t
operator|)
name|JAN_1970
expr_stmt|;
comment|/* warp into UN*X domain */
name|ntp
operator|-=
name|res
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
comment|/* cycle difference	 */
name|M_ADD
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
literal|0
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no 64bit scalars */
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert a timestamp in NTP scale to a 64bit seconds value in the NTP  * scale with proper epoch unfolding around a given pivot or the current  * system time.  *  * Note: The pivot must be given in the UN*X time domain!  *  * This is also a periodic extension, but since the cycle is 2^32 and  * the shift is 2^31, we can do some *very* fast math without explicit  * divisions.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|vint64
name|ntpcal_ntp_to_ntp
parameter_list|(
name|uint32_t
name|ntp
parameter_list|,
specifier|const
name|time_t
modifier|*
name|pivot
parameter_list|)
block|{
name|vint64
name|res
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_INT64
argument_list|)
name|res
operator|.
name|q_s
operator|=
operator|(
name|pivot
operator|)
condition|?
operator|*
name|pivot
else|:
name|now
argument_list|()
expr_stmt|;
name|res
operator|.
name|Q_s
operator|-=
literal|0x80000000u
expr_stmt|;
comment|/* unshift of half range */
name|res
operator|.
name|Q_s
operator|+=
operator|(
name|uint32_t
operator|)
name|JAN_1970
expr_stmt|;
comment|/* warp into NTP domain	 */
name|ntp
operator|-=
name|res
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
comment|/* cycle difference	 */
name|res
operator|.
name|Q_s
operator|+=
operator|(
name|uint64_t
operator|)
name|ntp
expr_stmt|;
comment|/* get expanded time	 */
else|#
directive|else
comment|/* no 64bit scalars */
name|time_t
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|pivot
operator|)
condition|?
operator|*
name|pivot
else|:
name|now
argument_list|()
expr_stmt|;
name|res
operator|=
name|time_to_vint64
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
literal|0
argument_list|,
literal|0x80000000u
argument_list|)
expr_stmt|;
name|M_ADD
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
literal|0
argument_list|,
operator|(
name|uint32_t
operator|)
name|JAN_1970
argument_list|)
expr_stmt|;
comment|/*into NTP */
name|ntp
operator|-=
name|res
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
comment|/* cycle difference	 */
name|M_ADD
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
literal|0
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no 64bit scalars */
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * ====================================================================  *  * Splitting values to composite entities  *  * ====================================================================  */
end_comment

begin_comment
comment|/*  *---------------------------------------------------------------------  * Split a 64bit seconds value into elapsed days in 'res.hi' and  * elapsed seconds since midnight in 'res.lo' using explicit floor  * division. This function happily accepts negative time values as  * timestamps before the respective epoch start.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|ntpcal_split
name|ntpcal_daysplit
parameter_list|(
specifier|const
name|vint64
modifier|*
name|ts
parameter_list|)
block|{
name|ntpcal_split
name|res
decl_stmt|;
name|uint32_t
name|Q
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_INT64
argument_list|)
comment|/* Manual floor division by SECSPERDAY. This uses the one's 	 * complement trick, too, but without an extra flag value: The 	 * flag would be 64bit, and that's a bit of overkill on a 32bit 	 * target that has to use a register pair for a 64bit number. 	 */
if|if
condition|(
name|ts
operator|->
name|q_s
operator|<
literal|0
condition|)
name|Q
operator|=
operator|~
call|(
name|uint32_t
call|)
argument_list|(
operator|~
name|ts
operator|->
name|Q_s
operator|/
name|SECSPERDAY
argument_list|)
expr_stmt|;
else|else
name|Q
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ts
operator|->
name|Q_s
operator|/
name|SECSPERDAY
argument_list|)
expr_stmt|;
else|#
directive|else
name|uint32_t
name|ah
decl_stmt|,
name|al
decl_stmt|,
name|sflag
decl_stmt|,
name|A
decl_stmt|;
comment|/* get operand into ah/al (either ts or ts' one's complement, 	 * for later floor division) 	 */
name|sflag
operator|=
name|int32_sflag
argument_list|(
name|ts
operator|->
name|d_s
operator|.
name|hi
argument_list|)
expr_stmt|;
name|ah
operator|=
name|sflag
operator|^
name|ts
operator|->
name|D_s
operator|.
name|hi
expr_stmt|;
name|al
operator|=
name|sflag
operator|^
name|ts
operator|->
name|D_s
operator|.
name|lo
expr_stmt|;
comment|/* Since 86400 == 128*675 we can drop the least 7 bits and 	 * divide by 675 instead of 86400. Then the maximum remainder 	 * after each devision step is 674, and we need 10 bits for 	 * that. So in the next step we can shift in 22 bits from the 	 * numerator. 	 * 	 * Therefore we load the accu with the top 13 bits (51..63) in 	 * the first shot. We don't have to remember the quotient -- it 	 * would be shifted out anyway. 	 */
name|A
operator|=
name|ah
operator|>>
literal|19
expr_stmt|;
if|if
condition|(
name|A
operator|>=
literal|675
condition|)
name|A
operator|=
operator|(
name|A
operator|%
literal|675u
operator|)
expr_stmt|;
comment|/* Now assemble the remainder with bits 29..50 from the 	 * numerator and divide. This creates the upper ten bits of the 	 * quotient. (Well, the top 22 bits of a 44bit result. But that 	 * will be truncated to 32 bits anyway.) 	 */
name|A
operator|=
operator|(
name|A
operator|<<
literal|19
operator|)
operator||
operator|(
name|ah
operator|&
literal|0x0007FFFFu
operator|)
expr_stmt|;
name|A
operator|=
operator|(
name|A
operator|<<
literal|3
operator|)
operator||
operator|(
name|al
operator|>>
literal|29
operator|)
expr_stmt|;
name|Q
operator|=
name|A
operator|/
literal|675u
expr_stmt|;
name|A
operator|=
name|A
operator|%
literal|675u
expr_stmt|;
comment|/* Now assemble the remainder with bits 7..28 from the numerator 	 * and do a final division step. 	 */
name|A
operator|=
operator|(
name|A
operator|<<
literal|22
operator|)
operator||
operator|(
operator|(
name|al
operator|>>
literal|7
operator|)
operator|&
literal|0x003FFFFFu
operator|)
expr_stmt|;
name|Q
operator|=
operator|(
name|Q
operator|<<
literal|22
operator|)
operator||
operator|(
name|A
operator|/
literal|675u
operator|)
expr_stmt|;
comment|/* The last 7 bits get simply dropped, as they have no affect on 	 * the quotient when dividing by 86400. 	 */
comment|/* apply sign correction and calculate the true floor 	 * remainder. 	 */
name|Q
operator|^=
name|sflag
expr_stmt|;
endif|#
directive|endif
name|res
operator|.
name|hi
operator|=
name|uint32_2cpl_to_int32
argument_list|(
name|Q
argument_list|)
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|ts
operator|->
name|D_s
operator|.
name|lo
operator|-
name|Q
operator|*
name|SECSPERDAY
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Split a 32bit seconds value into h/m/s and excessive days.  This  * function happily accepts negative time values as timestamps before  * midnight.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int32_t
name|priv_timesplit
parameter_list|(
name|int32_t
name|split
index|[
literal|3
index|]
parameter_list|,
name|int32_t
name|ts
parameter_list|)
block|{
comment|/* Do 3 chained floor divisions by positive constants, using the 	 * one's complement trick and factoring out the intermediate XOR 	 * ops to reduce the number of operations. 	 */
name|uint32_t
name|us
decl_stmt|,
name|um
decl_stmt|,
name|uh
decl_stmt|,
name|ud
decl_stmt|,
name|sflag
decl_stmt|;
name|sflag
operator|=
name|int32_sflag
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|us
operator|=
name|int32_to_uint32_2cpl
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|um
operator|=
operator|(
name|sflag
operator|^
name|us
operator|)
operator|/
name|SECSPERMIN
expr_stmt|;
name|uh
operator|=
name|um
operator|/
name|MINSPERHR
expr_stmt|;
name|ud
operator|=
name|uh
operator|/
name|HRSPERDAY
expr_stmt|;
name|um
operator|^=
name|sflag
expr_stmt|;
name|uh
operator|^=
name|sflag
expr_stmt|;
name|ud
operator|^=
name|sflag
expr_stmt|;
name|split
index|[
literal|0
index|]
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|uh
operator|-
name|ud
operator|*
name|HRSPERDAY
argument_list|)
expr_stmt|;
name|split
index|[
literal|1
index|]
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|um
operator|-
name|uh
operator|*
name|MINSPERHR
argument_list|)
expr_stmt|;
name|split
index|[
literal|2
index|]
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|us
operator|-
name|um
operator|*
name|SECSPERMIN
argument_list|)
expr_stmt|;
return|return
name|uint32_2cpl_to_int32
argument_list|(
name|ud
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Given the number of elapsed days in the calendar era, split this  * number into the number of elapsed years in 'res.hi' and the number  * of elapsed days of that year in 'res.lo'.  *  * if 'isleapyear' is not NULL, it will receive an integer that is 0 for  * regular years and a non-zero value for leap years.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|ntpcal_split
name|ntpcal_split_eradays
parameter_list|(
name|int32_t
name|days
parameter_list|,
name|int
modifier|*
name|isleapyear
parameter_list|)
block|{
comment|/* Use the fast cyclesplit algorithm here, to calculate the 	 * centuries and years in a century with one division each. This 	 * reduces the number of division operations to two, but is 	 * susceptible to internal range overflow. We make sure the 	 * input operands are in the safe range; this still gives us 	 * approx +/-2.9 million years. 	 */
name|ntpcal_split
name|res
decl_stmt|;
name|int32_t
name|n100
decl_stmt|,
name|n001
decl_stmt|;
comment|/* calendar year cycles */
name|uint32_t
name|uday
decl_stmt|,
name|Q
decl_stmt|,
name|sflag
decl_stmt|;
comment|/* split off centuries first */
name|sflag
operator|=
name|int32_sflag
argument_list|(
name|days
argument_list|)
expr_stmt|;
name|uday
operator|=
name|uint32_saturate
argument_list|(
name|int32_to_uint32_2cpl
argument_list|(
name|days
argument_list|)
argument_list|,
name|sflag
argument_list|)
expr_stmt|;
name|uday
operator|=
operator|(
literal|4u
operator|*
name|uday
operator|)
operator||
literal|3u
expr_stmt|;
name|Q
operator|=
name|sflag
operator|^
operator|(
operator|(
name|sflag
operator|^
name|uday
operator|)
operator|/
name|GREGORIAN_CYCLE_DAYS
operator|)
expr_stmt|;
name|uday
operator|=
name|uday
operator|-
name|Q
operator|*
name|GREGORIAN_CYCLE_DAYS
expr_stmt|;
name|n100
operator|=
name|uint32_2cpl_to_int32
argument_list|(
name|Q
argument_list|)
expr_stmt|;
comment|/* Split off years in century -- days>= 0 here, and we're far 	 * away from integer overflow trouble now. */
name|uday
operator||=
literal|3
expr_stmt|;
name|n001
operator|=
name|uday
operator|/
name|GREGORIAN_NORMAL_LEAP_CYCLE_DAYS
expr_stmt|;
name|uday
operator|=
name|uday
operator|%
name|GREGORIAN_NORMAL_LEAP_CYCLE_DAYS
expr_stmt|;
comment|/* Assemble the year and day in year */
name|res
operator|.
name|hi
operator|=
name|n100
operator|*
literal|100
operator|+
name|n001
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|uday
operator|/
literal|4u
expr_stmt|;
comment|/* Eventually set the leap year flag. Note: 0<= n001<= 99 and 	 * Q is still the two's complement representation of the 	 * centuries: The modulo 4 ops can be done with masking here. 	 * We also shift the year and the century by one, so the tests 	 * can be done against zero instead of 3. 	 */
if|if
condition|(
name|isleapyear
condition|)
operator|*
name|isleapyear
operator|=
operator|!
operator|(
operator|(
name|n001
operator|+
literal|1
operator|)
operator|&
literal|3
operator|)
operator|&&
operator|(
operator|(
name|n001
operator|!=
literal|99
operator|)
operator|||
operator|!
operator|(
operator|(
name|Q
operator|+
literal|1
operator|)
operator|&
literal|3
operator|)
operator|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Given a number of elapsed days in a year and a leap year indicator,  * split the number of elapsed days into the number of elapsed months in  * 'res.hi' and the number of elapsed days of that month in 'res.lo'.  *  * This function will fail and return {-1,-1} if the number of elapsed  * days is not in the valid range!  *---------------------------------------------------------------------  */
end_comment

begin_function
name|ntpcal_split
name|ntpcal_split_yeardays
parameter_list|(
name|int32_t
name|eyd
parameter_list|,
name|int
name|isleapyear
parameter_list|)
block|{
name|ntpcal_split
name|res
decl_stmt|;
specifier|const
name|uint16_t
modifier|*
name|lt
decl_stmt|;
comment|/* month length table	*/
comment|/* check leap year flag and select proper table */
name|lt
operator|=
name|real_month_table
index|[
operator|(
name|isleapyear
operator|!=
literal|0
operator|)
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|eyd
operator|&&
name|eyd
operator|<
name|lt
index|[
literal|12
index|]
condition|)
block|{
comment|/* get zero-based month by approximation& correction step */
name|res
operator|.
name|hi
operator|=
name|eyd
operator|>>
literal|5
expr_stmt|;
comment|/* approx month; might be 1 too low */
if|if
condition|(
name|lt
index|[
name|res
operator|.
name|hi
operator|+
literal|1
index|]
operator|<=
name|eyd
condition|)
comment|/* fixup approximative month value  */
name|res
operator|.
name|hi
operator|+=
literal|1
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|eyd
operator|-
name|lt
index|[
name|res
operator|.
name|hi
index|]
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|lo
operator|=
name|res
operator|.
name|hi
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert a RD into the date part of a 'struct calendar'.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_rd_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|int32_t
name|rd
parameter_list|)
block|{
name|ntpcal_split
name|split
decl_stmt|;
name|int
name|leapy
decl_stmt|;
name|u_int
name|ymask
decl_stmt|;
comment|/* Get day-of-week first. Since rd is signed, the remainder can 	 * be in the range [-6..+6], but the assignment to an unsigned 	 * variable maps the negative values to positive values>=7. 	 * This makes the sign correction look strange, but adding 7 	 * causes the needed wrap-around into the desired value range of 	 * zero to six, both inclusive. 	 */
name|jd
operator|->
name|weekday
operator|=
name|rd
operator|%
name|DAYSPERWEEK
expr_stmt|;
if|if
condition|(
name|jd
operator|->
name|weekday
operator|>=
name|DAYSPERWEEK
condition|)
comment|/* weekday is unsigned! */
name|jd
operator|->
name|weekday
operator|+=
name|DAYSPERWEEK
expr_stmt|;
name|split
operator|=
name|ntpcal_split_eradays
argument_list|(
name|rd
operator|-
literal|1
argument_list|,
operator|&
name|leapy
argument_list|)
expr_stmt|;
comment|/* Get year and day-of-year, with overflow check. If any of the 	 * upper 16 bits is set after shifting to unity-based years, we 	 * will have an overflow when converting to an unsigned 16bit 	 * year. Shifting to the right is OK here, since it does not 	 * matter if the shift is logic or arithmetic. 	 */
name|split
operator|.
name|hi
operator|+=
literal|1
expr_stmt|;
name|ymask
operator|=
literal|0u
operator|-
operator|(
operator|(
name|split
operator|.
name|hi
operator|>>
literal|16
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|jd
operator|->
name|year
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|split
operator|.
name|hi
operator|&
name|ymask
argument_list|)
expr_stmt|;
name|jd
operator|->
name|yearday
operator|=
operator|(
name|uint16_t
operator|)
name|split
operator|.
name|lo
operator|+
literal|1
expr_stmt|;
comment|/* convert to month and mday */
name|split
operator|=
name|ntpcal_split_yeardays
argument_list|(
name|split
operator|.
name|lo
argument_list|,
name|leapy
argument_list|)
expr_stmt|;
name|jd
operator|->
name|month
operator|=
operator|(
name|uint8_t
operator|)
name|split
operator|.
name|hi
operator|+
literal|1
expr_stmt|;
name|jd
operator|->
name|monthday
operator|=
operator|(
name|uint8_t
operator|)
name|split
operator|.
name|lo
operator|+
literal|1
expr_stmt|;
return|return
name|ymask
condition|?
name|leapy
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert a RD into the date part of a 'struct tm'.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_rd_to_tm
parameter_list|(
name|struct
name|tm
modifier|*
name|utm
parameter_list|,
name|int32_t
name|rd
parameter_list|)
block|{
name|ntpcal_split
name|split
decl_stmt|;
name|int
name|leapy
decl_stmt|;
comment|/* get day-of-week first */
name|utm
operator|->
name|tm_wday
operator|=
name|rd
operator|%
name|DAYSPERWEEK
expr_stmt|;
if|if
condition|(
name|utm
operator|->
name|tm_wday
operator|<
literal|0
condition|)
name|utm
operator|->
name|tm_wday
operator|+=
name|DAYSPERWEEK
expr_stmt|;
comment|/* get year and day-of-year */
name|split
operator|=
name|ntpcal_split_eradays
argument_list|(
name|rd
operator|-
literal|1
argument_list|,
operator|&
name|leapy
argument_list|)
expr_stmt|;
name|utm
operator|->
name|tm_year
operator|=
name|split
operator|.
name|hi
operator|-
literal|1899
expr_stmt|;
name|utm
operator|->
name|tm_yday
operator|=
name|split
operator|.
name|lo
expr_stmt|;
comment|/* 0-based */
comment|/* convert to month and mday */
name|split
operator|=
name|ntpcal_split_yeardays
argument_list|(
name|split
operator|.
name|lo
argument_list|,
name|leapy
argument_list|)
expr_stmt|;
name|utm
operator|->
name|tm_mon
operator|=
name|split
operator|.
name|hi
expr_stmt|;
comment|/* 0-based */
name|utm
operator|->
name|tm_mday
operator|=
name|split
operator|.
name|lo
operator|+
literal|1
expr_stmt|;
comment|/* 1-based */
return|return
name|leapy
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Take a value of seconds since midnight and split it into hhmmss in a  * 'struct calendar'.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_daysec_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|int32_t
name|sec
parameter_list|)
block|{
name|int32_t
name|days
decl_stmt|;
name|int
name|ts
index|[
literal|3
index|]
decl_stmt|;
name|days
operator|=
name|priv_timesplit
argument_list|(
name|ts
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|jd
operator|->
name|hour
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|jd
operator|->
name|minute
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|jd
operator|->
name|second
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|2
index|]
expr_stmt|;
return|return
name|days
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Take a value of seconds since midnight and split it into hhmmss in a  * 'struct tm'.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_daysec_to_tm
parameter_list|(
name|struct
name|tm
modifier|*
name|utm
parameter_list|,
name|int32_t
name|sec
parameter_list|)
block|{
name|int32_t
name|days
decl_stmt|;
name|int32_t
name|ts
index|[
literal|3
index|]
decl_stmt|;
name|days
operator|=
name|priv_timesplit
argument_list|(
name|ts
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|utm
operator|->
name|tm_hour
operator|=
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|utm
operator|->
name|tm_min
operator|=
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|utm
operator|->
name|tm_sec
operator|=
name|ts
index|[
literal|2
index|]
expr_stmt|;
return|return
name|days
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * take a split representation for day/second-of-day and day offset  * and convert it to a 'struct calendar'. The seconds will be normalised  * into the range of a day, and the day will be adjusted accordingly.  *  * returns>0 if the result is in a leap year, 0 if in a regular  * year and<0 if the result did not fit into the calendar struct.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_daysplit_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
specifier|const
name|ntpcal_split
modifier|*
name|ds
parameter_list|,
name|int32_t
name|dof
parameter_list|)
block|{
name|dof
operator|+=
name|ntpcal_daysec_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|->
name|lo
argument_list|)
expr_stmt|;
return|return
name|ntpcal_rd_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|->
name|hi
operator|+
name|dof
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * take a split representation for day/second-of-day and day offset  * and convert it to a 'struct tm'. The seconds will be normalised  * into the range of a day, and the day will be adjusted accordingly.  *  * returns 1 if the result is in a leap year and zero if in a regular  * year.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_daysplit_to_tm
parameter_list|(
name|struct
name|tm
modifier|*
name|utm
parameter_list|,
specifier|const
name|ntpcal_split
modifier|*
name|ds
parameter_list|,
name|int32_t
name|dof
parameter_list|)
block|{
name|dof
operator|+=
name|ntpcal_daysec_to_tm
argument_list|(
name|utm
argument_list|,
name|ds
operator|->
name|lo
argument_list|)
expr_stmt|;
return|return
name|ntpcal_rd_to_tm
argument_list|(
name|utm
argument_list|,
name|ds
operator|->
name|hi
operator|+
name|dof
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Take a UN*X time and convert to a calendar structure.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_time_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
specifier|const
name|vint64
modifier|*
name|ts
parameter_list|)
block|{
name|ntpcal_split
name|ds
decl_stmt|;
name|ds
operator|=
name|ntpcal_daysplit
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|ds
operator|.
name|hi
operator|+=
name|ntpcal_daysec_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|.
name|lo
argument_list|)
expr_stmt|;
name|ds
operator|.
name|hi
operator|+=
name|DAY_UNIX_STARTS
expr_stmt|;
return|return
name|ntpcal_rd_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|.
name|hi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ====================================================================  *  * merging composite entities  *  * ====================================================================  */
end_comment

begin_comment
comment|/*  *---------------------------------------------------------------------  * Merge a number of days and a number of seconds into seconds,  * expressed in 64 bits to avoid overflow.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|vint64
name|ntpcal_dayjoin
parameter_list|(
name|int32_t
name|days
parameter_list|,
name|int32_t
name|secs
parameter_list|)
block|{
name|vint64
name|res
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_INT64
argument_list|)
name|res
operator|.
name|q_s
operator|=
name|days
expr_stmt|;
name|res
operator|.
name|q_s
operator|*=
name|SECSPERDAY
expr_stmt|;
name|res
operator|.
name|q_s
operator|+=
name|secs
expr_stmt|;
else|#
directive|else
name|uint32_t
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|int
name|isneg
decl_stmt|;
comment|/* 	 * res = days *86400 + secs, using manual 16/32 bit 	 * multiplications and shifts. 	 */
name|isneg
operator|=
operator|(
name|days
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
name|days
operator|=
operator|-
name|days
expr_stmt|;
comment|/* assemble days * 675 */
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|days
operator|&
literal|0xFFFF
operator|)
operator|*
literal|675u
expr_stmt|;
name|res
operator|.
name|D_s
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|p1
operator|=
operator|(
name|days
operator|>>
literal|16
operator|)
operator|*
literal|675u
expr_stmt|;
name|p2
operator|=
name|p1
operator|>>
literal|16
expr_stmt|;
name|p1
operator|=
name|p1
operator|<<
literal|16
expr_stmt|;
name|M_ADD
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
name|p2
argument_list|,
name|p1
argument_list|)
expr_stmt|;
comment|/* mul by 128, using shift */
name|res
operator|.
name|D_s
operator|.
name|hi
operator|=
operator|(
name|res
operator|.
name|D_s
operator|.
name|hi
operator|<<
literal|7
operator|)
operator||
operator|(
name|res
operator|.
name|D_s
operator|.
name|lo
operator|>>
literal|25
operator|)
expr_stmt|;
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|res
operator|.
name|D_s
operator|.
name|lo
operator|<<
literal|7
operator|)
expr_stmt|;
comment|/* fix sign */
if|if
condition|(
name|isneg
condition|)
name|M_NEG
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|)
expr_stmt|;
comment|/* properly add seconds */
name|p2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|secs
operator|<
literal|0
condition|)
block|{
name|p1
operator|=
operator|(
name|uint32_t
operator|)
operator|-
name|secs
expr_stmt|;
name|M_NEG
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p1
operator|=
operator|(
name|uint32_t
operator|)
name|secs
expr_stmt|;
block|}
name|M_ADD
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
name|p2
argument_list|,
name|p1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * get leap years since epoch in elapsed years  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_leapyears_in_years
parameter_list|(
name|int32_t
name|years
parameter_list|)
block|{
comment|/* We use the in-out-in algorithm here, using the one's 	 * complement division trick for negative numbers. The chained 	 * division sequence by 4/25/4 gives the compiler the chance to 	 * get away with only one true division and doing shifts otherwise. 	 */
name|uint32_t
name|sflag
decl_stmt|,
name|sum
decl_stmt|,
name|uyear
decl_stmt|;
name|sflag
operator|=
name|int32_sflag
argument_list|(
name|years
argument_list|)
expr_stmt|;
name|uyear
operator|=
name|int32_to_uint32_2cpl
argument_list|(
name|years
argument_list|)
expr_stmt|;
name|uyear
operator|^=
name|sflag
expr_stmt|;
name|sum
operator|=
operator|(
name|uyear
operator|/=
literal|4u
operator|)
expr_stmt|;
comment|/*   4yr rule --> IN  */
name|sum
operator|-=
operator|(
name|uyear
operator|/=
literal|25u
operator|)
expr_stmt|;
comment|/* 100yr rule --> OUT */
name|sum
operator|+=
operator|(
name|uyear
operator|/=
literal|4u
operator|)
expr_stmt|;
comment|/* 400yr rule --> IN  */
comment|/* Thanks to the alternation of IN/OUT/IN we can do the sum 	 * directly and have a single one's complement operation 	 * here. (Only if the years are negative, of course.) Otherwise 	 * the one's complement would have to be done when 	 * adding/subtracting the terms. 	 */
return|return
name|uint32_2cpl_to_int32
argument_list|(
name|sflag
operator|^
name|sum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert elapsed years in Era into elapsed days in Era.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_days_in_years
parameter_list|(
name|int32_t
name|years
parameter_list|)
block|{
return|return
name|years
operator|*
name|DAYSPERYEAR
operator|+
name|ntpcal_leapyears_in_years
argument_list|(
name|years
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert a number of elapsed month in a year into elapsed days in year.  *  * The month will be normalized, and 'res.hi' will contain the  * excessive years that must be considered when converting the years,  * while 'res.lo' will contain the number of elapsed days since start  * of the year.  *  * This code uses the shifted-month-approach to convert month to days,  * because then there is no need to have explicit leap year  * information.	 The slight disadvantage is that for most month values  * the result is a negative value, and the year excess is one; the  * conversion is then simply based on the start of the following year.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|ntpcal_split
name|ntpcal_days_in_months
parameter_list|(
name|int32_t
name|m
parameter_list|)
block|{
name|ntpcal_split
name|res
decl_stmt|;
comment|/* Add ten months and correct if needed. (It likely is...) */
name|res
operator|.
name|lo
operator|=
name|m
operator|+
literal|10
expr_stmt|;
name|res
operator|.
name|hi
operator|=
operator|(
name|res
operator|.
name|lo
operator|>=
literal|12
operator|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|hi
condition|)
name|res
operator|.
name|lo
operator|-=
literal|12
expr_stmt|;
comment|/* if still out of range, normalise by floor division ... */
if|if
condition|(
name|res
operator|.
name|lo
operator|<
literal|0
operator|||
name|res
operator|.
name|lo
operator|>=
literal|12
condition|)
block|{
name|uint32_t
name|mu
decl_stmt|,
name|Q
decl_stmt|,
name|sflag
decl_stmt|;
name|sflag
operator|=
name|int32_sflag
argument_list|(
name|res
operator|.
name|lo
argument_list|)
expr_stmt|;
name|mu
operator|=
name|int32_to_uint32_2cpl
argument_list|(
name|res
operator|.
name|lo
argument_list|)
expr_stmt|;
name|Q
operator|=
name|sflag
operator|^
operator|(
operator|(
name|sflag
operator|^
name|mu
operator|)
operator|/
literal|12u
operator|)
expr_stmt|;
name|res
operator|.
name|hi
operator|+=
name|uint32_2cpl_to_int32
argument_list|(
name|Q
argument_list|)
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|mu
operator|-
name|Q
operator|*
literal|12u
expr_stmt|;
block|}
comment|/* get cummulated days in year with unshift */
name|res
operator|.
name|lo
operator|=
name|shift_month_table
index|[
name|res
operator|.
name|lo
index|]
operator|-
literal|306
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert ELAPSED years/months/days of gregorian calendar to elapsed  * days in Gregorian epoch.  *  * If you want to convert years and days-of-year, just give a month of  * zero.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_edate_to_eradays
parameter_list|(
name|int32_t
name|years
parameter_list|,
name|int32_t
name|mons
parameter_list|,
name|int32_t
name|mdays
parameter_list|)
block|{
name|ntpcal_split
name|tmp
decl_stmt|;
name|int32_t
name|res
decl_stmt|;
if|if
condition|(
name|mons
condition|)
block|{
name|tmp
operator|=
name|ntpcal_days_in_months
argument_list|(
name|mons
argument_list|)
expr_stmt|;
name|res
operator|=
name|ntpcal_days_in_years
argument_list|(
name|years
operator|+
name|tmp
operator|.
name|hi
argument_list|)
operator|+
name|tmp
operator|.
name|lo
expr_stmt|;
block|}
else|else
name|res
operator|=
name|ntpcal_days_in_years
argument_list|(
name|years
argument_list|)
expr_stmt|;
name|res
operator|+=
name|mdays
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert ELAPSED years/months/days of gregorian calendar to elapsed  * days in year.  *  * Note: This will give the true difference to the start of the given  * year, even if months& days are off-scale.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_edate_to_yeardays
parameter_list|(
name|int32_t
name|years
parameter_list|,
name|int32_t
name|mons
parameter_list|,
name|int32_t
name|mdays
parameter_list|)
block|{
name|ntpcal_split
name|tmp
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|mons
operator|&&
name|mons
operator|<
literal|12
condition|)
block|{
name|years
operator|+=
literal|1
expr_stmt|;
name|mdays
operator|+=
name|real_month_table
index|[
name|is_leapyear
argument_list|(
name|years
argument_list|)
index|]
index|[
name|mons
index|]
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|ntpcal_days_in_months
argument_list|(
name|mons
argument_list|)
expr_stmt|;
name|mdays
operator|+=
name|tmp
operator|.
name|lo
operator|+
name|ntpcal_days_in_years
argument_list|(
name|years
operator|+
name|tmp
operator|.
name|hi
argument_list|)
operator|-
name|ntpcal_days_in_years
argument_list|(
name|years
argument_list|)
expr_stmt|;
block|}
return|return
name|mdays
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert elapsed days and the hour/minute/second information into  * total seconds.  *  * If 'isvalid' is not NULL, do a range check on the time specification  * and tell if the time input is in the normal range, permitting for a  * single leapsecond.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_etime_to_seconds
parameter_list|(
name|int32_t
name|hours
parameter_list|,
name|int32_t
name|minutes
parameter_list|,
name|int32_t
name|seconds
parameter_list|)
block|{
name|int32_t
name|res
decl_stmt|;
name|res
operator|=
operator|(
name|hours
operator|*
name|MINSPERHR
operator|+
name|minutes
operator|)
operator|*
name|SECSPERMIN
operator|+
name|seconds
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert the date part of a 'struct tm' (that is, year, month,  * day-of-month) into the RD of that day.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_tm_to_rd
parameter_list|(
specifier|const
name|struct
name|tm
modifier|*
name|utm
parameter_list|)
block|{
return|return
name|ntpcal_edate_to_eradays
argument_list|(
name|utm
operator|->
name|tm_year
operator|+
literal|1899
argument_list|,
name|utm
operator|->
name|tm_mon
argument_list|,
name|utm
operator|->
name|tm_mday
operator|-
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert the date part of a 'struct calendar' (that is, year, month,  * day-of-month) into the RD of that day.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_date_to_rd
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
return|return
name|ntpcal_edate_to_eradays
argument_list|(
operator|(
name|int32_t
operator|)
name|jd
operator|->
name|year
operator|-
literal|1
argument_list|,
operator|(
name|int32_t
operator|)
name|jd
operator|->
name|month
operator|-
literal|1
argument_list|,
operator|(
name|int32_t
operator|)
name|jd
operator|->
name|monthday
operator|-
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * convert a year number to rata die of year start  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_year_to_ystart
parameter_list|(
name|int32_t
name|year
parameter_list|)
block|{
return|return
name|ntpcal_days_in_years
argument_list|(
name|year
operator|-
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * For a given RD, get the RD of the associated year start,  * that is, the RD of the last January,1st on or before that day.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_rd_to_ystart
parameter_list|(
name|int32_t
name|rd
parameter_list|)
block|{
comment|/* 	 * Rather simple exercise: split the day number into elapsed 	 * years and elapsed days, then remove the elapsed days from the 	 * input value. Nice'n sweet... 	 */
return|return
name|rd
operator|-
name|ntpcal_split_eradays
argument_list|(
name|rd
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
operator|.
name|lo
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * For a given RD, get the RD of the associated month start.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_rd_to_mstart
parameter_list|(
name|int32_t
name|rd
parameter_list|)
block|{
name|ntpcal_split
name|split
decl_stmt|;
name|int
name|leaps
decl_stmt|;
name|split
operator|=
name|ntpcal_split_eradays
argument_list|(
name|rd
operator|-
literal|1
argument_list|,
operator|&
name|leaps
argument_list|)
expr_stmt|;
name|split
operator|=
name|ntpcal_split_yeardays
argument_list|(
name|split
operator|.
name|lo
argument_list|,
name|leaps
argument_list|)
expr_stmt|;
return|return
name|rd
operator|-
name|split
operator|.
name|lo
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * take a 'struct calendar' and get the seconds-of-day from it.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_date_to_daysec
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
return|return
name|ntpcal_etime_to_seconds
argument_list|(
name|jd
operator|->
name|hour
argument_list|,
name|jd
operator|->
name|minute
argument_list|,
name|jd
operator|->
name|second
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * take a 'struct tm' and get the seconds-of-day from it.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_tm_to_daysec
parameter_list|(
specifier|const
name|struct
name|tm
modifier|*
name|utm
parameter_list|)
block|{
return|return
name|ntpcal_etime_to_seconds
argument_list|(
name|utm
operator|->
name|tm_hour
argument_list|,
name|utm
operator|->
name|tm_min
argument_list|,
name|utm
operator|->
name|tm_sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * take a 'struct calendar' and convert it to a 'time_t'  *---------------------------------------------------------------------  */
end_comment

begin_function
name|time_t
name|ntpcal_date_to_time
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
name|vint64
name|join
decl_stmt|;
name|int32_t
name|days
decl_stmt|,
name|secs
decl_stmt|;
name|days
operator|=
name|ntpcal_date_to_rd
argument_list|(
name|jd
argument_list|)
operator|-
name|DAY_UNIX_STARTS
expr_stmt|;
name|secs
operator|=
name|ntpcal_date_to_daysec
argument_list|(
name|jd
argument_list|)
expr_stmt|;
name|join
operator|=
name|ntpcal_dayjoin
argument_list|(
name|days
argument_list|,
name|secs
argument_list|)
expr_stmt|;
return|return
name|vint64_to_time
argument_list|(
operator|&
name|join
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ====================================================================  *  * extended and unchecked variants of caljulian/caltontp  *  * ====================================================================  */
end_comment

begin_function
name|int
name|ntpcal_ntp64_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
specifier|const
name|vint64
modifier|*
name|ntp
parameter_list|)
block|{
name|ntpcal_split
name|ds
decl_stmt|;
name|ds
operator|=
name|ntpcal_daysplit
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
name|ds
operator|.
name|hi
operator|+=
name|ntpcal_daysec_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|.
name|lo
argument_list|)
expr_stmt|;
return|return
name|ntpcal_rd_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|.
name|hi
operator|+
name|DAY_NTP_STARTS
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ntpcal_ntp_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|uint32_t
name|ntp
parameter_list|,
specifier|const
name|time_t
modifier|*
name|piv
parameter_list|)
block|{
name|vint64
name|ntp64
decl_stmt|;
comment|/* 	 * Unfold ntp time around current time into NTP domain. Split 	 * into days and seconds, shift days into CE domain and 	 * process the parts. 	 */
name|ntp64
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|ntp
argument_list|,
name|piv
argument_list|)
expr_stmt|;
return|return
name|ntpcal_ntp64_to_date
argument_list|(
name|jd
argument_list|,
operator|&
name|ntp64
argument_list|)
return|;
block|}
end_function

begin_function
name|vint64
name|ntpcal_date_to_ntp64
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
comment|/* 	 * Convert date to NTP. Ignore yearday, use d/m/y only. 	 */
return|return
name|ntpcal_dayjoin
argument_list|(
name|ntpcal_date_to_rd
argument_list|(
name|jd
argument_list|)
operator|-
name|DAY_NTP_STARTS
argument_list|,
name|ntpcal_date_to_daysec
argument_list|(
name|jd
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|ntpcal_date_to_ntp
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
comment|/* 	 * Get lower half of 64-bit NTP timestamp from date/time. 	 */
return|return
name|ntpcal_date_to_ntp64
argument_list|(
name|jd
argument_list|)
operator|.
name|d_s
operator|.
name|lo
return|;
block|}
end_function

begin_comment
comment|/*  * ====================================================================  *  * day-of-week calculations  *  * ====================================================================  */
end_comment

begin_comment
comment|/*  * Given a RataDie and a day-of-week, calculate a RDN that is reater-than,  * greater-or equal, closest, less-or-equal or less-than the given RDN  * and denotes the given day-of-week  */
end_comment

begin_function
name|int32_t
name|ntpcal_weekday_gt
parameter_list|(
name|int32_t
name|rdn
parameter_list|,
name|int32_t
name|dow
parameter_list|)
block|{
return|return
name|ntpcal_periodic_extend
argument_list|(
name|rdn
operator|+
literal|1
argument_list|,
name|dow
argument_list|,
literal|7
argument_list|)
return|;
block|}
end_function

begin_function
name|int32_t
name|ntpcal_weekday_ge
parameter_list|(
name|int32_t
name|rdn
parameter_list|,
name|int32_t
name|dow
parameter_list|)
block|{
return|return
name|ntpcal_periodic_extend
argument_list|(
name|rdn
argument_list|,
name|dow
argument_list|,
literal|7
argument_list|)
return|;
block|}
end_function

begin_function
name|int32_t
name|ntpcal_weekday_close
parameter_list|(
name|int32_t
name|rdn
parameter_list|,
name|int32_t
name|dow
parameter_list|)
block|{
return|return
name|ntpcal_periodic_extend
argument_list|(
name|rdn
operator|-
literal|3
argument_list|,
name|dow
argument_list|,
literal|7
argument_list|)
return|;
block|}
end_function

begin_function
name|int32_t
name|ntpcal_weekday_le
parameter_list|(
name|int32_t
name|rdn
parameter_list|,
name|int32_t
name|dow
parameter_list|)
block|{
return|return
name|ntpcal_periodic_extend
argument_list|(
name|rdn
argument_list|,
name|dow
argument_list|,
operator|-
literal|7
argument_list|)
return|;
block|}
end_function

begin_function
name|int32_t
name|ntpcal_weekday_lt
parameter_list|(
name|int32_t
name|rdn
parameter_list|,
name|int32_t
name|dow
parameter_list|)
block|{
return|return
name|ntpcal_periodic_extend
argument_list|(
name|rdn
operator|-
literal|1
argument_list|,
name|dow
argument_list|,
operator|-
literal|7
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ====================================================================  *  * ISO week-calendar conversions  *  * The ISO8601 calendar defines a calendar of years, weeks and weekdays.  * It is related to the Gregorian calendar, and a ISO year starts at the  * Monday closest to Jan,1st of the corresponding Gregorian year.  A ISO  * calendar year has always 52 or 53 weeks, and like the Grogrian  * calendar the ISO8601 calendar repeats itself every 400 years, or  * 146097 days, or 20871 weeks.  *  * While it is possible to write ISO calendar functions based on the  * Gregorian calendar functions, the following implementation takes a  * different approach, based directly on years and weeks.  *  * Analysis of the tabulated data shows that it is not possible to  * interpolate from years to weeks over a full 400 year range; cyclic  * shifts over 400 years do not provide a solution here. But it *is*  * possible to interpolate over every single century of the 400-year  * cycle. (The centennial leap year rule seems to be the culprit here.)  *  * It can be shown that a conversion from years to weeks can be done  * using a linear transformation of the form  *  *   w = floor( y * a + b )  *  * where the slope a must hold to  *  *  52.1780821918<= a< 52.1791044776  *  * and b must be chosen according to the selected slope and the number  * of the century in a 400-year period.  *  * The inverse calculation can also be done in this way. Careful scaling  * provides an unlimited set of integer coefficients a,k,b that enable  * us to write the calulation in the form  *  *   w = (y * a	 + b ) / k  *   y = (w * a' + b') / k'  *  * In this implementation the values of k and k' are chosen to be  * smallest possible powers of two, so the division can be implemented  * as shifts if the optimiser chooses to do so.  *  * ====================================================================  */
end_comment

begin_comment
comment|/*  * Given a number of elapsed (ISO-)years since the begin of the  * christian era, return the number of elapsed weeks corresponding to  * the number of years.  */
end_comment

begin_function
name|int32_t
name|isocal_weeks_in_years
parameter_list|(
name|int32_t
name|years
parameter_list|)
block|{
comment|/* 	 * use: w = (y * 53431 + b[c]) / 1024 as interpolation 	 */
specifier|static
specifier|const
name|uint16_t
name|bctab
index|[
literal|4
index|]
init|=
block|{
literal|157
block|,
literal|449
block|,
literal|597
block|,
literal|889
block|}
decl_stmt|;
name|int32_t
name|cs
decl_stmt|,
name|cw
decl_stmt|;
name|uint32_t
name|cc
decl_stmt|,
name|ci
decl_stmt|,
name|yu
decl_stmt|,
name|sflag
decl_stmt|;
name|sflag
operator|=
name|int32_sflag
argument_list|(
name|years
argument_list|)
expr_stmt|;
name|yu
operator|=
name|int32_to_uint32_2cpl
argument_list|(
name|years
argument_list|)
expr_stmt|;
comment|/* split off centuries, using floor division */
name|cc
operator|=
name|sflag
operator|^
operator|(
operator|(
name|sflag
operator|^
name|yu
operator|)
operator|/
literal|100u
operator|)
expr_stmt|;
name|yu
operator|-=
name|cc
operator|*
literal|100u
expr_stmt|;
comment|/* calculate century cycles shift and cycle index: 	 * Assuming a century is 5217 weeks, we have to add a cycle 	 * shift that is 3 for every 4 centuries, because 3 of the four 	 * centuries have 5218 weeks. So '(cc*3 + 1) / 4' is the actual 	 * correction, and the second century is the defective one. 	 * 	 * Needs floor division by 4, which is done with masking and 	 * shifting. 	 */
name|ci
operator|=
name|cc
operator|*
literal|3u
operator|+
literal|1
expr_stmt|;
name|cs
operator|=
name|uint32_2cpl_to_int32
argument_list|(
name|sflag
operator|^
operator|(
operator|(
name|sflag
operator|^
name|ci
operator|)
operator|/
literal|4u
operator|)
argument_list|)
expr_stmt|;
name|ci
operator|=
name|ci
operator|%
literal|4u
expr_stmt|;
comment|/* Get weeks in century. Can use plain division here as all ops 	 * are>= 0,  and let the compiler sort out the possible 	 * optimisations. 	 */
name|cw
operator|=
operator|(
name|yu
operator|*
literal|53431u
operator|+
name|bctab
index|[
name|ci
index|]
operator|)
operator|/
literal|1024u
expr_stmt|;
return|return
name|uint32_2cpl_to_int32
argument_list|(
name|cc
argument_list|)
operator|*
literal|5217
operator|+
name|cs
operator|+
name|cw
return|;
block|}
end_function

begin_comment
comment|/*  * Given a number of elapsed weeks since the begin of the christian  * era, split this number into the number of elapsed years in res.hi  * and the excessive number of weeks in res.lo. (That is, res.lo is  * the number of elapsed weeks in the remaining partial year.)  */
end_comment

begin_function
name|ntpcal_split
name|isocal_split_eraweeks
parameter_list|(
name|int32_t
name|weeks
parameter_list|)
block|{
comment|/* 	 * use: y = (w * 157 + b[c]) / 8192 as interpolation 	 */
specifier|static
specifier|const
name|uint16_t
name|bctab
index|[
literal|4
index|]
init|=
block|{
literal|85
block|,
literal|130
block|,
literal|17
block|,
literal|62
block|}
decl_stmt|;
name|ntpcal_split
name|res
decl_stmt|;
name|int32_t
name|cc
decl_stmt|,
name|ci
decl_stmt|;
name|uint32_t
name|sw
decl_stmt|,
name|cy
decl_stmt|,
name|Q
decl_stmt|,
name|sflag
decl_stmt|;
comment|/* Use two fast cycle-split divisions here. This is again 	 * susceptible to internal overflow, so we check the range. This 	 * still permits more than +/-20 million years, so this is 	 * likely a pure academical problem. 	 * 	 * We want to execute '(weeks * 4 + 2) /% 20871' under floor 	 * division rules in the first step. 	 */
name|sflag
operator|=
name|int32_sflag
argument_list|(
name|weeks
argument_list|)
expr_stmt|;
name|sw
operator|=
name|uint32_saturate
argument_list|(
name|int32_to_uint32_2cpl
argument_list|(
name|weeks
argument_list|)
argument_list|,
name|sflag
argument_list|)
expr_stmt|;
name|sw
operator|=
literal|4u
operator|*
name|sw
operator|+
literal|2
expr_stmt|;
name|Q
operator|=
name|sflag
operator|^
operator|(
operator|(
name|sflag
operator|^
name|sw
operator|)
operator|/
name|GREGORIAN_CYCLE_WEEKS
operator|)
expr_stmt|;
name|sw
operator|-=
name|Q
operator|*
name|GREGORIAN_CYCLE_WEEKS
expr_stmt|;
name|ci
operator|=
name|Q
operator|%
literal|4u
expr_stmt|;
name|cc
operator|=
name|uint32_2cpl_to_int32
argument_list|(
name|Q
argument_list|)
expr_stmt|;
comment|/* Split off years; sw>= 0 here! The scaled weeks in the years 	 * are scaled up by 157 afterwards. 	 */
name|sw
operator|=
operator|(
name|sw
operator|/
literal|4u
operator|)
operator|*
literal|157u
operator|+
name|bctab
index|[
name|ci
index|]
expr_stmt|;
name|cy
operator|=
name|sw
operator|/
literal|8192u
expr_stmt|;
comment|/* ws>> 13 , let the compiler sort it out */
name|sw
operator|=
name|sw
operator|%
literal|8192u
expr_stmt|;
comment|/* ws& 8191, let the compiler sort it out */
comment|/* assemble elapsed years and downscale the elapsed weeks in 	 * the year. 	 */
name|res
operator|.
name|hi
operator|=
literal|100
operator|*
name|cc
operator|+
name|cy
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|sw
operator|/
literal|157u
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Given a second in the NTP time scale and a pivot, expand the NTP  * time stamp around the pivot and convert into an ISO calendar time  * stamp.  */
end_comment

begin_function
name|int
name|isocal_ntp64_to_date
parameter_list|(
name|struct
name|isodate
modifier|*
name|id
parameter_list|,
specifier|const
name|vint64
modifier|*
name|ntp
parameter_list|)
block|{
name|ntpcal_split
name|ds
decl_stmt|;
name|int32_t
name|ts
index|[
literal|3
index|]
decl_stmt|;
name|uint32_t
name|uw
decl_stmt|,
name|ud
decl_stmt|,
name|sflag
decl_stmt|;
comment|/* 	 * Split NTP time into days and seconds, shift days into CE 	 * domain and process the parts. 	 */
name|ds
operator|=
name|ntpcal_daysplit
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
comment|/* split time part */
name|ds
operator|.
name|hi
operator|+=
name|priv_timesplit
argument_list|(
name|ts
argument_list|,
name|ds
operator|.
name|lo
argument_list|)
expr_stmt|;
name|id
operator|->
name|hour
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|id
operator|->
name|minute
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|id
operator|->
name|second
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|2
index|]
expr_stmt|;
comment|/* split days into days and weeks, using floor division in unsigned */
name|ds
operator|.
name|hi
operator|+=
name|DAY_NTP_STARTS
operator|-
literal|1
expr_stmt|;
comment|/* shift from NTP to RDN */
name|sflag
operator|=
name|int32_sflag
argument_list|(
name|ds
operator|.
name|hi
argument_list|)
expr_stmt|;
name|ud
operator|=
name|int32_to_uint32_2cpl
argument_list|(
name|ds
operator|.
name|hi
argument_list|)
expr_stmt|;
name|uw
operator|=
name|sflag
operator|^
operator|(
operator|(
name|sflag
operator|^
name|ud
operator|)
operator|/
name|DAYSPERWEEK
operator|)
expr_stmt|;
name|ud
operator|-=
name|uw
operator|*
name|DAYSPERWEEK
expr_stmt|;
name|ds
operator|.
name|hi
operator|=
name|uint32_2cpl_to_int32
argument_list|(
name|uw
argument_list|)
expr_stmt|;
name|ds
operator|.
name|lo
operator|=
name|ud
expr_stmt|;
name|id
operator|->
name|weekday
operator|=
operator|(
name|uint8_t
operator|)
name|ds
operator|.
name|lo
operator|+
literal|1
expr_stmt|;
comment|/* weekday result    */
comment|/* get year and week in year */
name|ds
operator|=
name|isocal_split_eraweeks
argument_list|(
name|ds
operator|.
name|hi
argument_list|)
expr_stmt|;
comment|/* elapsed years&week*/
name|id
operator|->
name|year
operator|=
operator|(
name|uint16_t
operator|)
name|ds
operator|.
name|hi
operator|+
literal|1
expr_stmt|;
comment|/* shift to current  */
name|id
operator|->
name|week
operator|=
operator|(
name|uint8_t
operator|)
name|ds
operator|.
name|lo
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|ds
operator|.
name|hi
operator|>=
literal|0
operator|&&
name|ds
operator|.
name|hi
operator|<
literal|0x0000FFFF
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isocal_ntp_to_date
parameter_list|(
name|struct
name|isodate
modifier|*
name|id
parameter_list|,
name|uint32_t
name|ntp
parameter_list|,
specifier|const
name|time_t
modifier|*
name|piv
parameter_list|)
block|{
name|vint64
name|ntp64
decl_stmt|;
comment|/* 	 * Unfold ntp time around current time into NTP domain, then 	 * convert the full time stamp. 	 */
name|ntp64
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|ntp
argument_list|,
name|piv
argument_list|)
expr_stmt|;
return|return
name|isocal_ntp64_to_date
argument_list|(
name|id
argument_list|,
operator|&
name|ntp64
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a ISO date spec into a second in the NTP time scale,  * properly truncated to 32 bit.  */
end_comment

begin_function
name|vint64
name|isocal_date_to_ntp64
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|id
parameter_list|)
block|{
name|int32_t
name|weeks
decl_stmt|,
name|days
decl_stmt|,
name|secs
decl_stmt|;
name|weeks
operator|=
name|isocal_weeks_in_years
argument_list|(
operator|(
name|int32_t
operator|)
name|id
operator|->
name|year
operator|-
literal|1
argument_list|)
operator|+
operator|(
name|int32_t
operator|)
name|id
operator|->
name|week
operator|-
literal|1
expr_stmt|;
name|days
operator|=
name|weeks
operator|*
literal|7
operator|+
operator|(
name|int32_t
operator|)
name|id
operator|->
name|weekday
expr_stmt|;
comment|/* days is RDN of ISO date now */
name|secs
operator|=
name|ntpcal_etime_to_seconds
argument_list|(
name|id
operator|->
name|hour
argument_list|,
name|id
operator|->
name|minute
argument_list|,
name|id
operator|->
name|second
argument_list|)
expr_stmt|;
return|return
name|ntpcal_dayjoin
argument_list|(
name|days
operator|-
name|DAY_NTP_STARTS
argument_list|,
name|secs
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|isocal_date_to_ntp
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|id
parameter_list|)
block|{
comment|/* 	 * Get lower half of 64-bit NTP timestamp from date/time. 	 */
return|return
name|isocal_date_to_ntp64
argument_list|(
name|id
argument_list|)
operator|.
name|d_s
operator|.
name|lo
return|;
block|}
end_function

begin_comment
comment|/* -*-EOF-*- */
end_comment

end_unit

