begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * clocktime - compute the NTP date from a day of year, hour, minute  *	       and second.  */
end_comment

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Hacks to avoid excercising the multiplier.  I have no pride.  */
end_comment

begin_define
define|#
directive|define
name|MULBY10
parameter_list|(
name|x
parameter_list|)
value|(((x)<<3) + ((x)<<1))
end_define

begin_define
define|#
directive|define
name|MULBY60
parameter_list|(
name|x
parameter_list|)
value|(((x)<<6) - ((x)<<2))
end_define

begin_comment
comment|/* watch overflow */
end_comment

begin_define
define|#
directive|define
name|MULBY24
parameter_list|(
name|x
parameter_list|)
value|(((x)<<4) + ((x)<<3))
end_define

begin_comment
comment|/*  * Two days, in seconds.  */
end_comment

begin_define
define|#
directive|define
name|TWODAYS
value|(2*24*60*60)
end_define

begin_comment
comment|/*  * We demand that the time be within CLOSETIME seconds of the receive  * time stamp.  This is about 4 hours, which hopefully should be  * wide enough to collect most data, while close enough to keep things  * from getting confused.  */
end_comment

begin_define
define|#
directive|define
name|CLOSETIME
value|(4*60*60)
end_define

begin_function
name|int
name|clocktime
parameter_list|(
name|int
name|yday
parameter_list|,
name|int
name|hour
parameter_list|,
name|int
name|minute
parameter_list|,
name|int
name|second
parameter_list|,
name|int
name|tzoff
parameter_list|,
name|u_long
name|rec_ui
parameter_list|,
name|u_long
modifier|*
name|yearstart
parameter_list|,
name|u_int32
modifier|*
name|ts_ui
parameter_list|)
block|{
specifier|register
name|long
name|tmp
decl_stmt|;
specifier|register
name|u_long
name|date
decl_stmt|;
specifier|register
name|u_long
name|yst
decl_stmt|;
comment|/* 	 * Compute the offset into the year in seconds.  Note that 	 * this could come out to be a negative number. 	 */
name|tmp
operator|=
call|(
name|long
call|)
argument_list|(
name|MULBY24
argument_list|(
operator|(
name|yday
operator|-
literal|1
operator|)
argument_list|)
operator|+
name|hour
operator|+
name|tzoff
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|MULBY60
argument_list|(
name|tmp
argument_list|)
operator|+
operator|(
name|long
operator|)
name|minute
expr_stmt|;
name|tmp
operator|=
name|MULBY60
argument_list|(
name|tmp
argument_list|)
operator|+
operator|(
name|long
operator|)
name|second
expr_stmt|;
comment|/* 	 * Initialize yearstart, if necessary. 	 */
name|yst
operator|=
operator|*
name|yearstart
expr_stmt|;
if|if
condition|(
name|yst
operator|==
literal|0
condition|)
block|{
name|yst
operator|=
name|calyearstart
argument_list|(
name|rec_ui
argument_list|)
expr_stmt|;
operator|*
name|yearstart
operator|=
name|yst
expr_stmt|;
block|}
comment|/* 	 * Now the fun begins.  We demand that the received clock time 	 * be within CLOSETIME of the receive timestamp, but 	 * there is uncertainty about the year the timestamp is in. 	 * Use the current year start for the first check, this should 	 * work most of the time. 	 */
name|date
operator|=
call|(
name|u_long
call|)
argument_list|(
name|tmp
operator|+
operator|(
name|long
operator|)
name|yst
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|<
operator|(
name|rec_ui
operator|+
name|CLOSETIME
operator|)
operator|&&
name|date
operator|>
operator|(
name|rec_ui
operator|-
name|CLOSETIME
operator|)
condition|)
block|{
operator|*
name|ts_ui
operator|=
name|date
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Trouble.  Next check is to see if the year rolled over and, if 	 * so, try again with the new year's start. 	 */
name|yst
operator|=
name|calyearstart
argument_list|(
name|rec_ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|yst
operator|!=
operator|*
name|yearstart
condition|)
block|{
name|date
operator|=
call|(
name|u_long
call|)
argument_list|(
operator|(
name|long
operator|)
name|yst
operator|+
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|ts_ui
operator|=
name|date
expr_stmt|;
if|if
condition|(
name|date
operator|<
operator|(
name|rec_ui
operator|+
name|CLOSETIME
operator|)
operator|&&
name|date
operator|>
operator|(
name|rec_ui
operator|-
name|CLOSETIME
operator|)
condition|)
block|{
operator|*
name|yearstart
operator|=
name|yst
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 	 * Here we know the year start matches the current system 	 * time.  One remaining possibility is that the time code 	 * is in the year previous to that of the system time.  This 	 * is only worth checking if the receive timestamp is less 	 * than a couple of days into the new year. 	 */
if|if
condition|(
operator|(
name|rec_ui
operator|-
name|yst
operator|)
operator|<
name|TWODAYS
condition|)
block|{
name|yst
operator|=
name|calyearstart
argument_list|(
name|yst
operator|-
name|TWODAYS
argument_list|)
expr_stmt|;
if|if
condition|(
name|yst
operator|!=
operator|*
name|yearstart
condition|)
block|{
name|date
operator|=
call|(
name|u_long
call|)
argument_list|(
name|tmp
operator|+
operator|(
name|long
operator|)
name|yst
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|<
operator|(
name|rec_ui
operator|+
name|CLOSETIME
operator|)
operator|&&
name|date
operator|>
operator|(
name|rec_ui
operator|-
name|CLOSETIME
operator|)
condition|)
block|{
operator|*
name|yearstart
operator|=
name|yst
expr_stmt|;
operator|*
name|ts_ui
operator|=
name|date
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* 	 * One last possibility is that the time stamp is in the year 	 * following the year the system is in.  Try this one before 	 * giving up. 	 */
name|yst
operator|=
name|calyearstart
argument_list|(
name|rec_ui
operator|+
name|TWODAYS
argument_list|)
expr_stmt|;
if|if
condition|(
name|yst
operator|!=
operator|*
name|yearstart
condition|)
block|{
name|date
operator|=
call|(
name|u_long
call|)
argument_list|(
operator|(
name|long
operator|)
name|yst
operator|+
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|<
operator|(
name|rec_ui
operator|+
name|CLOSETIME
operator|)
operator|&&
name|date
operator|>
operator|(
name|rec_ui
operator|-
name|CLOSETIME
operator|)
condition|)
block|{
operator|*
name|yearstart
operator|=
name|yst
expr_stmt|;
operator|*
name|ts_ui
operator|=
name|date
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 	 * Give it up. 	 */
return|return
literal|0
return|;
block|}
end_function

end_unit

