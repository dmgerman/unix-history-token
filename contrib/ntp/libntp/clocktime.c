begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * clocktime - compute the NTP date from a day of year, hour, minute  *	       and second.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_comment
comment|/*  * We check that the time be within CLOSETIME seconds of the receive  * time stamp.	This is about 4 hours, which hopefully should be wide  * enough to collect most data, while close enough to keep things from  * getting confused.  */
end_comment

begin_define
define|#
directive|define
name|CLOSETIME
value|(4u*60u*60u)
end_define

begin_comment
comment|/*  * Since we try to match years, the result of a full search will not  * change when we are already less than a half year from the receive  * time stamp.	Since the length of a year is variable we use a  * slightly narrower limit; this might require a full evaluation near  * the edge, but will make sure we always get the correct result.  */
end_comment

begin_define
define|#
directive|define
name|NEARTIME
value|(182u * SECSPERDAY)
end_define

begin_comment
comment|/*  * local calendar helpers  */
end_comment

begin_function_decl
specifier|static
name|int32
name|ntp_to_year
parameter_list|(
name|u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|year_to_ntp
parameter_list|(
name|int32
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Take a time spec given as day-of-year, hour, minute and second as  * well as a GMT offset in hours and convert it to a NTP time stamp in  * '*ts_ui'. The value will be in the range (rec_ui-0.5yrs) to  * (rec_ui+0.5yrs). A hint for the current start-of-year will be  * read from '*yearstart'.  *  * On return '*ts_ui' will always the best matching solution, and  * '*yearstart' will receive the associated start-of-year.  *  * The function will tell if the result in 'ts_ui' is in CLOSETIME  * (+/-4hrs) around the receive time by returning a non-zero value.  *  * Note: The function puts no constraints on the value ranges for the  * time specification, but evaluates the effective seconds in  * 32-bit arithmetic.  */
end_comment

begin_function
name|int
name|clocktime
parameter_list|(
name|int
name|yday
parameter_list|,
comment|/* day-of-year */
name|int
name|hour
parameter_list|,
comment|/* hour of day */
name|int
name|minute
parameter_list|,
comment|/* minute of hour */
name|int
name|second
parameter_list|,
comment|/* second of minute */
name|int
name|tzoff
parameter_list|,
comment|/* hours west of GMT */
name|u_int32
name|rec_ui
parameter_list|,
comment|/* pivot value */
name|u_long
modifier|*
name|yearstart
parameter_list|,
comment|/* cached start-of-year, should be fixed to u_int32 */
name|u_int32
modifier|*
name|ts_ui
parameter_list|)
comment|/* effective time stamp */
block|{
name|u_int32
name|ystt
index|[
literal|3
index|]
decl_stmt|;
comment|/* year start */
name|u_int32
name|test
index|[
literal|3
index|]
decl_stmt|;
comment|/* result time stamp */
name|u_int32
name|diff
index|[
literal|3
index|]
decl_stmt|;
comment|/* abs difference to receive */
name|int32
name|y
decl_stmt|,
name|tmp
decl_stmt|,
name|idx
decl_stmt|,
name|min
decl_stmt|;
comment|/* 	 * Compute the offset into the year in seconds.	 Note that 	 * this could come out to be a negative number. 	 */
name|tmp
operator|=
operator|(
operator|(
name|int32
operator|)
name|second
operator|+
name|SECSPERMIN
operator|*
operator|(
operator|(
name|int32
operator|)
name|minute
operator|+
name|MINSPERHR
operator|*
operator|(
operator|(
name|int32
operator|)
name|hour
operator|+
operator|(
name|int32
operator|)
name|tzoff
operator|+
name|HRSPERDAY
operator|*
operator|(
operator|(
name|int32
operator|)
name|yday
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Based on the cached year start, do a first attempt. Be 	 * happy and return if this gets us better than NEARTIME to 	 * the receive time stamp. Do this only if the cached year 	 * start is not zero, which will not happen after 1900 for the 	 * next few thousand years. 	 */
if|if
condition|(
operator|*
name|yearstart
condition|)
block|{
comment|/* -- get time stamp of potential solution */
name|test
index|[
literal|0
index|]
operator|=
call|(
name|u_int32
call|)
argument_list|(
operator|*
name|yearstart
argument_list|)
operator|+
name|tmp
expr_stmt|;
comment|/* -- calc absolute difference to receive time */
name|diff
index|[
literal|0
index|]
operator|=
name|test
index|[
literal|0
index|]
operator|-
name|rec_ui
expr_stmt|;
if|if
condition|(
name|diff
index|[
literal|0
index|]
operator|>=
literal|0x80000000u
condition|)
name|diff
index|[
literal|0
index|]
operator|=
operator|~
name|diff
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
comment|/* -- can't get closer if diff< NEARTIME */
if|if
condition|(
name|diff
index|[
literal|0
index|]
operator|<
name|NEARTIME
condition|)
block|{
operator|*
name|ts_ui
operator|=
name|test
index|[
literal|0
index|]
expr_stmt|;
return|return
name|diff
index|[
literal|0
index|]
operator|<
name|CLOSETIME
return|;
block|}
block|}
comment|/* 	 * Now the dance begins. Based on the receive time stamp and 	 * the seconds offset in 'tmp', we make an educated guess 	 * about the year to start with. This takes us on the spot 	 * with a fuzz of +/-1 year. 	 * 	 * We calculate the effective timestamps for the three years 	 * around the guess and select the entry with the minimum 	 * absolute difference to the receive time stamp. 	 */
name|y
operator|=
name|ntp_to_year
argument_list|(
name|rec_ui
operator|-
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|3
condition|;
name|idx
operator|++
control|)
block|{
comment|/* -- get year start of potential solution */
name|ystt
index|[
name|idx
index|]
operator|=
name|year_to_ntp
argument_list|(
name|y
operator|+
name|idx
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* -- get time stamp of potential solution */
name|test
index|[
name|idx
index|]
operator|=
name|ystt
index|[
name|idx
index|]
operator|+
name|tmp
expr_stmt|;
comment|/* -- calc absolute difference to receive time */
name|diff
index|[
name|idx
index|]
operator|=
name|test
index|[
name|idx
index|]
operator|-
name|rec_ui
expr_stmt|;
if|if
condition|(
name|diff
index|[
name|idx
index|]
operator|>=
literal|0x80000000u
condition|)
name|diff
index|[
name|idx
index|]
operator|=
operator|~
name|diff
index|[
name|idx
index|]
operator|+
literal|1
expr_stmt|;
block|}
comment|/* -*- assume current year fits best, then search best fit */
for|for
control|(
name|min
operator|=
literal|1
operator|,
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|3
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|diff
index|[
name|idx
index|]
operator|<
name|diff
index|[
name|min
index|]
condition|)
name|min
operator|=
name|idx
expr_stmt|;
comment|/* -*- store results and update year start */
operator|*
name|ts_ui
operator|=
name|test
index|[
name|min
index|]
expr_stmt|;
operator|*
name|yearstart
operator|=
name|ystt
index|[
name|min
index|]
expr_stmt|;
comment|/* -*- tell if we could get into CLOSETIME*/
return|return
name|diff
index|[
name|min
index|]
operator|<
name|CLOSETIME
return|;
block|}
end_function

begin_function
specifier|static
name|int32
name|ntp_to_year
parameter_list|(
name|u_int32
name|ntp
parameter_list|)
block|{
name|vint64
name|t
decl_stmt|;
name|ntpcal_split
name|s
decl_stmt|;
name|t
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|ntp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|ntpcal_daysplit
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ntpcal_split_eradays
argument_list|(
name|s
operator|.
name|hi
operator|+
name|DAY_NTP_STARTS
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|hi
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32
name|year_to_ntp
parameter_list|(
name|int32
name|year
parameter_list|)
block|{
name|u_int32
name|days
decl_stmt|;
name|days
operator|=
name|ntpcal_days_in_years
argument_list|(
name|year
operator|-
literal|1
argument_list|)
operator|-
name|DAY_NTP_STARTS
operator|+
literal|1
expr_stmt|;
return|return
name|days
operator|*
name|SECSPERDAY
return|;
block|}
end_function

end_unit

