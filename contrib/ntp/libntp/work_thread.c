begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * work_thread.c - threads implementation for blocking worker child.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"ntp_workimpl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WORK_THREAD
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_malloc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"timespecops.h"
end_include

begin_include
include|#
directive|include
file|"ntp_worker.h"
end_include

begin_define
define|#
directive|define
name|CHILD_EXIT_REQ
value|((blocking_pipe_header *)(intptr_t)-1)
end_define

begin_define
define|#
directive|define
name|CHILD_GONE_RESP
value|CHILD_EXIT_REQ
end_define

begin_comment
comment|/* Queue size increments:  * The request queue grows a bit faster than the response queue -- the  * deamon can push requests and pull results faster on avarage than the  * worker can process requests and push results...  If this really pays  * off is debatable.  */
end_comment

begin_define
define|#
directive|define
name|WORKITEMS_ALLOC_INC
value|16
end_define

begin_define
define|#
directive|define
name|RESPONSES_ALLOC_INC
value|4
end_define

begin_comment
comment|/* Fiddle with min/max stack sizes. 64kB minimum seems to work, so we  * set the maximum to 256kB. If the minimum goes below the  * system-defined minimum stack size, we have to adjust accordingly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|THREAD_MINSTACKSIZE
end_ifndef

begin_define
define|#
directive|define
name|THREAD_MINSTACKSIZE
value|(64U * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__sun
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PTHREAD_STACK_MIN
argument_list|)
operator|&&
name|THREAD_MINSTACKSIZE
operator|<
name|PTHREAD_STACK_MIN
end_if

begin_undef
undef|#
directive|undef
name|THREAD_MINSTACKSIZE
end_undef

begin_define
define|#
directive|define
name|THREAD_MINSTACKSIZE
value|PTHREAD_STACK_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|THREAD_MAXSTACKSIZE
end_ifndef

begin_define
define|#
directive|define
name|THREAD_MAXSTACKSIZE
value|(256U * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|THREAD_MAXSTACKSIZE
operator|<
name|THREAD_MINSTACKSIZE
end_if

begin_undef
undef|#
directive|undef
name|THREAD_MAXSTACKSIZE
end_undef

begin_define
define|#
directive|define
name|THREAD_MAXSTACKSIZE
value|THREAD_MINSTACKSIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_define
define|#
directive|define
name|thread_exit
parameter_list|(
name|c
parameter_list|)
value|_endthreadex(c)
end_define

begin_define
define|#
directive|define
name|tickle_sem
parameter_list|(
name|sh
parameter_list|)
value|ReleaseSemaphore((sh->shnd), 1, NULL)
end_define

begin_function_decl
name|u_int
name|WINAPI
name|blocking_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|same_os_sema
parameter_list|(
specifier|const
name|sem_ref
name|obj
parameter_list|,
name|void
modifier|*
name|osobj
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|thread_exit
parameter_list|(
name|c
parameter_list|)
value|pthread_exit((void*)(size_t)(c))
end_define

begin_define
define|#
directive|define
name|tickle_sem
value|sem_post
end_define

begin_function_decl
name|void
modifier|*
name|blocking_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|block_thread_signals
parameter_list|(
name|sigset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WORK_PIPE
end_ifdef

begin_decl_stmt
name|addremove_io_fd_func
name|addremove_io_fd
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|addremove_io_semaphore_func
name|addremove_io_semaphore
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|start_blocking_thread
parameter_list|(
name|blocking_child
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_blocking_thread_internal
parameter_list|(
name|blocking_child
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prepare_child_sems
parameter_list|(
name|blocking_child
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wait_for_sem
parameter_list|(
name|sem_ref
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ensure_workitems_empty_slot
parameter_list|(
name|blocking_child
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ensure_workresp_empty_slot
parameter_list|(
name|blocking_child
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|queue_req_pointer
parameter_list|(
name|blocking_child
modifier|*
parameter_list|,
name|blocking_pipe_header
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleanup_after_child
parameter_list|(
name|blocking_child
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|exit_worker
parameter_list|(
name|int
name|exitcode
parameter_list|)
block|{
name|thread_exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
comment|/* see #define thread_exit */
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * sleep for a given time or until the wakup semaphore is tickled.  */
end_comment

begin_function
name|int
name|worker_sleep
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|,
name|time_t
name|seconds
parameter_list|)
block|{
name|struct
name|timespec
name|until
decl_stmt|;
name|int
name|rc
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_CLOCK_GETTIME
if|if
condition|(
literal|0
operator|!=
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|until
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"worker_sleep: clock_gettime() failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
if|if
condition|(
literal|0
operator|!=
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|until
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"worker_sleep: getclock() failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
name|until
operator|.
name|tv_sec
operator|+=
name|seconds
expr_stmt|;
name|rc
operator|=
name|wait_for_sem
argument_list|(
name|c
operator|->
name|wake_scheduled_sleep
argument_list|,
operator|&
name|until
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|rc
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
operator|&&
name|ETIMEDOUT
operator|==
name|errno
condition|)
return|return
literal|0
return|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"worker_sleep: sem_timedwait: %m"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Wake up a worker that takes a nap.  */
end_comment

begin_function
name|void
name|interrupt_worker_sleep
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|;
name|blocking_child
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|blocking_children_alloc
condition|;
name|idx
operator|++
control|)
block|{
name|c
operator|=
name|blocking_children
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|c
operator|||
name|NULL
operator|==
name|c
operator|->
name|wake_scheduled_sleep
condition|)
continue|continue;
name|tickle_sem
argument_list|(
name|c
operator|->
name|wake_scheduled_sleep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Make sure there is an empty slot at the head of the request  * queue. Tell if the queue is currently empty.  */
end_comment

begin_function
specifier|static
name|int
name|ensure_workitems_empty_slot
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
comment|/* 	** !!! PRECONDITION: caller holds access lock! 	** 	** This simply tries to increase the size of the buffer if it 	** becomes full. The resize operation does *not* maintain the 	** order of requests, but that should be irrelevant since the 	** processing is considered asynchronous anyway. 	** 	** Return if the buffer is currently empty. 	*/
specifier|static
specifier|const
name|size_t
name|each
init|=
sizeof|sizeof
argument_list|(
name|blocking_children
index|[
literal|0
index|]
operator|->
name|workitems
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|size_t
name|new_alloc
decl_stmt|;
name|size_t
name|slots_used
decl_stmt|;
name|size_t
name|sidx
decl_stmt|;
name|slots_used
operator|=
name|c
operator|->
name|head_workitem
operator|-
name|c
operator|->
name|tail_workitem
expr_stmt|;
if|if
condition|(
name|slots_used
operator|>=
name|c
operator|->
name|workitems_alloc
condition|)
block|{
name|new_alloc
operator|=
name|c
operator|->
name|workitems_alloc
operator|+
name|WORKITEMS_ALLOC_INC
expr_stmt|;
name|c
operator|->
name|workitems
operator|=
name|erealloc
argument_list|(
name|c
operator|->
name|workitems
argument_list|,
name|new_alloc
operator|*
name|each
argument_list|)
expr_stmt|;
for|for
control|(
name|sidx
operator|=
name|c
operator|->
name|workitems_alloc
init|;
name|sidx
operator|<
name|new_alloc
condition|;
operator|++
name|sidx
control|)
name|c
operator|->
name|workitems
index|[
name|sidx
index|]
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tail_workitem
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|head_workitem
operator|=
name|c
operator|->
name|workitems_alloc
expr_stmt|;
name|c
operator|->
name|workitems_alloc
operator|=
name|new_alloc
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|NULL
operator|==
name|c
operator|->
name|workitems
index|[
name|c
operator|->
name|head_workitem
operator|%
name|c
operator|->
name|workitems_alloc
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|==
name|slots_used
operator|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Make sure there is an empty slot at the head of the response  * queue. Tell if the queue is currently empty.  */
end_comment

begin_function
specifier|static
name|int
name|ensure_workresp_empty_slot
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
comment|/* 	** !!! PRECONDITION: caller holds access lock! 	** 	** Works like the companion function above. 	*/
specifier|static
specifier|const
name|size_t
name|each
init|=
sizeof|sizeof
argument_list|(
name|blocking_children
index|[
literal|0
index|]
operator|->
name|responses
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|size_t
name|new_alloc
decl_stmt|;
name|size_t
name|slots_used
decl_stmt|;
name|size_t
name|sidx
decl_stmt|;
name|slots_used
operator|=
name|c
operator|->
name|head_response
operator|-
name|c
operator|->
name|tail_response
expr_stmt|;
if|if
condition|(
name|slots_used
operator|>=
name|c
operator|->
name|responses_alloc
condition|)
block|{
name|new_alloc
operator|=
name|c
operator|->
name|responses_alloc
operator|+
name|RESPONSES_ALLOC_INC
expr_stmt|;
name|c
operator|->
name|responses
operator|=
name|erealloc
argument_list|(
name|c
operator|->
name|responses
argument_list|,
name|new_alloc
operator|*
name|each
argument_list|)
expr_stmt|;
for|for
control|(
name|sidx
operator|=
name|c
operator|->
name|responses_alloc
init|;
name|sidx
operator|<
name|new_alloc
condition|;
operator|++
name|sidx
control|)
name|c
operator|->
name|responses
index|[
name|sidx
index|]
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|tail_response
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|head_response
operator|=
name|c
operator|->
name|responses_alloc
expr_stmt|;
name|c
operator|->
name|responses_alloc
operator|=
name|new_alloc
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|NULL
operator|==
name|c
operator|->
name|responses
index|[
name|c
operator|->
name|head_response
operator|%
name|c
operator|->
name|responses_alloc
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|==
name|slots_used
operator|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * queue_req_pointer() - append a work item or idle exit request to  *			 blocking_workitems[]. Employ proper locking.  */
end_comment

begin_function
specifier|static
name|int
name|queue_req_pointer
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|,
name|blocking_pipe_header
modifier|*
name|hdr
parameter_list|)
block|{
name|size_t
name|qhead
decl_stmt|;
comment|/*>>>> ACCESS LOCKING STARTS>>>> */
name|wait_for_sem
argument_list|(
name|c
operator|->
name|accesslock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ensure_workitems_empty_slot
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|qhead
operator|=
name|c
operator|->
name|head_workitem
expr_stmt|;
name|c
operator|->
name|workitems
index|[
name|qhead
operator|%
name|c
operator|->
name|workitems_alloc
index|]
operator|=
name|hdr
expr_stmt|;
name|c
operator|->
name|head_workitem
operator|=
literal|1
operator|+
name|qhead
expr_stmt|;
name|tickle_sem
argument_list|(
name|c
operator|->
name|accesslock
argument_list|)
expr_stmt|;
comment|/*<<<< ACCESS LOCKING ENDS<<<< */
comment|/* queue consumer wake-up notification */
name|tickle_sem
argument_list|(
name|c
operator|->
name|workitems_pending
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * API function to make sure a worker is running, a proper private copy  * of the data is made, the data eneterd into the queue and the worker  * is signalled.  */
end_comment

begin_function
name|int
name|send_blocking_req_internal
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|,
name|blocking_pipe_header
modifier|*
name|hdr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|blocking_pipe_header
modifier|*
name|threadcopy
decl_stmt|;
name|size_t
name|payload_octets
decl_stmt|;
name|REQUIRE
argument_list|(
name|hdr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|BLOCKING_REQ_MAGIC
operator|==
name|hdr
operator|->
name|magic_sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|octets
operator|<=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* failure */
name|payload_octets
operator|=
name|hdr
operator|->
name|octets
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|c
operator|->
name|thread_ref
condition|)
name|start_blocking_thread
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|threadcopy
operator|=
name|emalloc
argument_list|(
name|hdr
operator|->
name|octets
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|threadcopy
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|threadcopy
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|data
argument_list|,
name|payload_octets
argument_list|)
expr_stmt|;
return|return
name|queue_req_pointer
argument_list|(
name|c
argument_list|,
name|threadcopy
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Wait for the 'incoming queue no longer empty' signal, lock the shared  * structure and dequeue an item.  */
end_comment

begin_function
name|blocking_pipe_header
modifier|*
name|receive_blocking_req_internal
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
name|blocking_pipe_header
modifier|*
name|req
decl_stmt|;
name|size_t
name|qhead
decl_stmt|,
name|qtail
decl_stmt|;
name|req
operator|=
name|NULL
expr_stmt|;
do|do
block|{
comment|/* wait for tickle from the producer side */
name|wait_for_sem
argument_list|(
name|c
operator|->
name|workitems_pending
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*>>>> ACCESS LOCKING STARTS>>>> */
name|wait_for_sem
argument_list|(
name|c
operator|->
name|accesslock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|qhead
operator|=
name|c
operator|->
name|head_workitem
expr_stmt|;
do|do
block|{
name|qtail
operator|=
name|c
operator|->
name|tail_workitem
expr_stmt|;
if|if
condition|(
name|qhead
operator|==
name|qtail
condition|)
break|break;
name|c
operator|->
name|tail_workitem
operator|=
name|qtail
operator|+
literal|1
expr_stmt|;
name|qtail
operator|%=
name|c
operator|->
name|workitems_alloc
expr_stmt|;
name|req
operator|=
name|c
operator|->
name|workitems
index|[
name|qtail
index|]
expr_stmt|;
name|c
operator|->
name|workitems
index|[
name|qtail
index|]
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|NULL
operator|==
name|req
condition|)
do|;
name|tickle_sem
argument_list|(
name|c
operator|->
name|accesslock
argument_list|)
expr_stmt|;
comment|/*<<<< ACCESS LOCKING ENDS<<<< */
block|}
do|while
condition|(
name|NULL
operator|==
name|req
condition|)
do|;
name|INSIST
argument_list|(
name|NULL
operator|!=
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHILD_EXIT_REQ
operator|==
name|req
condition|)
block|{
comment|/* idled out */
name|send_blocking_resp_internal
argument_list|(
name|c
argument_list|,
name|CHILD_GONE_RESP
argument_list|)
expr_stmt|;
name|req
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|req
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Push a response into the return queue and eventually tickle the  * receiver.  */
end_comment

begin_function
name|int
name|send_blocking_resp_internal
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|,
name|blocking_pipe_header
modifier|*
name|resp
parameter_list|)
block|{
name|size_t
name|qhead
decl_stmt|;
name|int
name|empty
decl_stmt|;
comment|/*>>>> ACCESS LOCKING STARTS>>>> */
name|wait_for_sem
argument_list|(
name|c
operator|->
name|accesslock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|empty
operator|=
name|ensure_workresp_empty_slot
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|qhead
operator|=
name|c
operator|->
name|head_response
expr_stmt|;
name|c
operator|->
name|responses
index|[
name|qhead
operator|%
name|c
operator|->
name|responses_alloc
index|]
operator|=
name|resp
expr_stmt|;
name|c
operator|->
name|head_response
operator|=
literal|1
operator|+
name|qhead
expr_stmt|;
name|tickle_sem
argument_list|(
name|c
operator|->
name|accesslock
argument_list|)
expr_stmt|;
comment|/*<<<< ACCESS LOCKING ENDS<<<< */
comment|/* queue consumer wake-up notification */
if|if
condition|(
name|empty
condition|)
block|{
ifdef|#
directive|ifdef
name|WORK_PIPE
name|write
argument_list|(
name|c
operator|->
name|resp_write_pipe
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|tickle_sem
argument_list|(
name|c
operator|->
name|responses_pending
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|WORK_PIPE
end_ifndef

begin_comment
comment|/* --------------------------------------------------------------------  * Check if a (Windows-)hanndle to a semaphore is actually the same we  * are using inside the sema wrapper.  */
end_comment

begin_function
specifier|static
name|BOOL
name|same_os_sema
parameter_list|(
specifier|const
name|sem_ref
name|obj
parameter_list|,
name|void
modifier|*
name|osh
parameter_list|)
block|{
return|return
name|obj
operator|&&
name|osh
operator|&&
operator|(
name|obj
operator|->
name|shnd
operator|==
operator|(
name|HANDLE
operator|)
name|osh
operator|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Find the shared context that associates to an OS handle and make sure  * the data is dequeued and processed.  */
end_comment

begin_function
name|void
name|handle_blocking_resp_sem
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|blocking_child
modifier|*
name|c
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|c
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|blocking_children_alloc
condition|;
name|idx
operator|++
control|)
block|{
name|c
operator|=
name|blocking_children
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|thread_ref
operator|!=
name|NULL
operator|&&
name|same_os_sema
argument_list|(
name|c
operator|->
name|responses_pending
argument_list|,
name|context
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|idx
operator|<
name|blocking_children_alloc
condition|)
name|process_blocking_resp
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !WORK_PIPE */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------  * Fetch the next response from the return queue. In case of signalling  * via pipe, make sure the pipe is flushed, too.  */
end_comment

begin_function
name|blocking_pipe_header
modifier|*
name|receive_blocking_resp_internal
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
name|blocking_pipe_header
modifier|*
name|removed
decl_stmt|;
name|size_t
name|qhead
decl_stmt|,
name|qtail
decl_stmt|,
name|slot
decl_stmt|;
ifdef|#
directive|ifdef
name|WORK_PIPE
name|int
name|rc
decl_stmt|;
name|char
name|scratch
index|[
literal|32
index|]
decl_stmt|;
do|do
name|rc
operator|=
name|read
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|,
name|scratch
argument_list|,
sizeof|sizeof
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
do|while
condition|(
operator|-
literal|1
operator|==
name|rc
operator|&&
name|EINTR
operator|==
name|errno
condition|)
do|;
endif|#
directive|endif
comment|/*>>>> ACCESS LOCKING STARTS>>>> */
name|wait_for_sem
argument_list|(
name|c
operator|->
name|accesslock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|qhead
operator|=
name|c
operator|->
name|head_response
expr_stmt|;
name|qtail
operator|=
name|c
operator|->
name|tail_response
expr_stmt|;
for|for
control|(
name|removed
operator|=
name|NULL
init|;
operator|!
name|removed
operator|&&
operator|(
name|qhead
operator|!=
name|qtail
operator|)
condition|;
operator|++
name|qtail
control|)
block|{
name|slot
operator|=
name|qtail
operator|%
name|c
operator|->
name|responses_alloc
expr_stmt|;
name|removed
operator|=
name|c
operator|->
name|responses
index|[
name|slot
index|]
expr_stmt|;
name|c
operator|->
name|responses
index|[
name|slot
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|c
operator|->
name|tail_response
operator|=
name|qtail
expr_stmt|;
name|tickle_sem
argument_list|(
name|c
operator|->
name|accesslock
argument_list|)
expr_stmt|;
comment|/*<<<< ACCESS LOCKING ENDS<<<< */
if|if
condition|(
name|NULL
operator|!=
name|removed
condition|)
block|{
name|DEBUG_ENSURE
argument_list|(
name|CHILD_GONE_RESP
operator|==
name|removed
operator|||
name|BLOCKING_RESP_MAGIC
operator|==
name|removed
operator|->
name|magic_sig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CHILD_GONE_RESP
operator|==
name|removed
condition|)
block|{
name|cleanup_after_child
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|removed
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Light up a new worker.  */
end_comment

begin_function
specifier|static
name|void
name|start_blocking_thread
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
name|DEBUG_INSIST
argument_list|(
operator|!
name|c
operator|->
name|reusable
argument_list|)
expr_stmt|;
name|prepare_child_sems
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|start_blocking_thread_internal
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Create a worker thread. There are several differences between POSIX  * and Windows, of course -- most notably the Windows thread is no  * detached thread, and we keep the handle around until we want to get  * rid of the thread. The notification scheme also differs: Windows  * makes use of semaphores in both directions, POSIX uses a pipe for  * integration with 'select()' or alike.  */
end_comment

begin_function
specifier|static
name|void
name|start_blocking_thread_internal
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
ifdef|#
directive|ifdef
name|SYS_WINNT
block|{
name|BOOL
name|resumed
decl_stmt|;
name|c
operator|->
name|thread_ref
operator|=
name|NULL
expr_stmt|;
call|(
modifier|*
name|addremove_io_semaphore
call|)
argument_list|(
name|c
operator|->
name|responses_pending
operator|->
name|shnd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|c
operator|->
name|thr_table
index|[
literal|0
index|]
operator|.
name|thnd
operator|=
operator|(
name|HANDLE
operator|)
name|_beginthreadex
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|blocking_thread
argument_list|,
name|c
argument_list|,
name|CREATE_SUSPENDED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|c
operator|->
name|thr_table
index|[
literal|0
index|]
operator|.
name|thnd
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"start blocking thread failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* remember the thread priority is only within the process class */
if|if
condition|(
operator|!
name|SetThreadPriority
argument_list|(
name|c
operator|->
name|thr_table
index|[
literal|0
index|]
operator|.
name|thnd
argument_list|,
name|THREAD_PRIORITY_BELOW_NORMAL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error lowering blocking thread priority: %m"
argument_list|)
expr_stmt|;
name|resumed
operator|=
name|ResumeThread
argument_list|(
name|c
operator|->
name|thr_table
index|[
literal|0
index|]
operator|.
name|thnd
argument_list|)
expr_stmt|;
name|DEBUG_INSIST
argument_list|(
name|resumed
argument_list|)
expr_stmt|;
name|c
operator|->
name|thread_ref
operator|=
operator|&
name|c
operator|->
name|thr_table
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* pthreads start_blocking_thread_internal() follows */
end_comment

begin_block
block|{
ifdef|#
directive|ifdef
name|NEED_PTHREAD_INIT
specifier|static
name|int
name|pthread_init_called
decl_stmt|;
endif|#
directive|endif
name|pthread_attr_t
name|thr_attr
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|pipe_ends
index|[
literal|2
index|]
decl_stmt|;
comment|/* read then write */
name|int
name|is_pipe
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|size_t
name|ostacksize
decl_stmt|;
name|size_t
name|nstacksize
decl_stmt|;
name|sigset_t
name|saved_sig_mask
decl_stmt|;
name|c
operator|->
name|thread_ref
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_PTHREAD_INIT
comment|/* 	 * from lib/isc/unix/app.c: 	 * BSDI 3.1 seg faults in pthread_sigmask() if we don't do this. 	 */
if|if
condition|(
operator|!
name|pthread_init_called
condition|)
block|{
name|pthread_init
argument_list|()
expr_stmt|;
name|pthread_init_called
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
name|rc
operator|=
name|pipe_socketpair
argument_list|(
operator|&
name|pipe_ends
index|[
literal|0
index|]
argument_list|,
operator|&
name|is_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|rc
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"start_blocking_thread: pipe_socketpair() %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|resp_read_pipe
operator|=
name|move_fd
argument_list|(
name|pipe_ends
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|c
operator|->
name|resp_write_pipe
operator|=
name|move_fd
argument_list|(
name|pipe_ends
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|c
operator|->
name|ispipe
operator|=
name|is_pipe
expr_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|flags
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"start_blocking_thread: fcntl(F_GETFL) %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|fcntl
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
operator||
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"start_blocking_thread: fcntl(F_SETFL, O_NONBLOCK) %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|addremove_io_fd
call|)
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|,
name|c
operator|->
name|ispipe
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pthread_attr_init
argument_list|(
operator|&
name|thr_attr
argument_list|)
expr_stmt|;
name|pthread_attr_setdetachstate
argument_list|(
operator|&
name|thr_attr
argument_list|,
name|PTHREAD_CREATE_DETACHED
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PTHREAD_ATTR_GETSTACKSIZE
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_PTHREAD_ATTR_SETSTACKSIZE
argument_list|)
name|rc
operator|=
name|pthread_attr_getstacksize
argument_list|(
operator|&
name|thr_attr
argument_list|,
operator|&
name|ostacksize
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|rc
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"start_blocking_thread: pthread_attr_getstacksize() -> %s"
argument_list|,
name|strerror
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ostacksize
operator|<
name|THREAD_MINSTACKSIZE
condition|)
name|nstacksize
operator|=
name|THREAD_MINSTACKSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|ostacksize
operator|>
name|THREAD_MAXSTACKSIZE
condition|)
name|nstacksize
operator|=
name|THREAD_MAXSTACKSIZE
expr_stmt|;
else|else
name|nstacksize
operator|=
name|ostacksize
expr_stmt|;
if|if
condition|(
name|nstacksize
operator|!=
name|ostacksize
condition|)
name|rc
operator|=
name|pthread_attr_setstacksize
argument_list|(
operator|&
name|thr_attr
argument_list|,
name|nstacksize
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|rc
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"start_blocking_thread: pthread_attr_setstacksize(0x%lx -> 0x%lx) -> %s"
argument_list|,
operator|(
name|u_long
operator|)
name|ostacksize
argument_list|,
operator|(
name|u_long
operator|)
name|nstacksize
argument_list|,
name|strerror
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|UNUSED_ARG
argument_list|(
name|nstacksize
argument_list|)
expr_stmt|;
name|UNUSED_ARG
argument_list|(
name|ostacksize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PTHREAD_SCOPE_SYSTEM
argument_list|)
operator|&&
name|defined
argument_list|(
name|NEED_PTHREAD_SCOPE_SYSTEM
argument_list|)
name|pthread_attr_setscope
argument_list|(
operator|&
name|thr_attr
argument_list|,
name|PTHREAD_SCOPE_SYSTEM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|->
name|thread_ref
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|c
operator|->
name|thread_ref
argument_list|)
argument_list|)
expr_stmt|;
name|block_thread_signals
argument_list|(
operator|&
name|saved_sig_mask
argument_list|)
expr_stmt|;
name|rc
operator|=
name|pthread_create
argument_list|(
operator|&
name|c
operator|->
name|thr_table
index|[
literal|0
index|]
argument_list|,
operator|&
name|thr_attr
argument_list|,
operator|&
name|blocking_thread
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|saved_sig_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_attr_destroy
argument_list|(
operator|&
name|thr_attr
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|rc
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"start_blocking_thread: pthread_create() -> %s"
argument_list|,
name|strerror
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|thread_ref
operator|=
operator|&
name|c
operator|->
name|thr_table
index|[
literal|0
index|]
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* --------------------------------------------------------------------  * block_thread_signals()  *  * Temporarily block signals used by ntpd main thread, so that signal  * mask inherited by child threads leaves them blocked.  Returns prior  * active signal mask via pmask, to be restored by the main thread  * after pthread_create().  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_function
name|void
name|block_thread_signals
parameter_list|(
name|sigset_t
modifier|*
name|pmask
parameter_list|)
block|{
name|sigset_t
name|block
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|block
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
ifdef|#
directive|ifdef
name|SIGIO
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPOLL
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGPOLL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAVE_SIGNALED_IO */
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|MOREDEBUGSIG
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|LESSDEBUGSIG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGDIE1
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGDIE1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGDIE2
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGDIE2
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGDIE3
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGDIE3
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGDIE4
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGDIE4
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGBUS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigemptyset
argument_list|(
name|pmask
argument_list|)
expr_stmt|;
name|pthread_sigmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|block
argument_list|,
name|pmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SYS_WINNT */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------  * Create& destroy semaphores. This is sufficiently different between  * POSIX and Windows to warrant wrapper functions and close enough to  * use the concept of synchronization via semaphore for all platforms.  */
end_comment

begin_function
specifier|static
name|sem_ref
name|create_sema
parameter_list|(
name|sema_type
modifier|*
name|semptr
parameter_list|,
name|u_int
name|inival
parameter_list|,
name|u_int
name|maxval
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYS_WINNT
name|long
name|svini
decl_stmt|,
name|svmax
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|semptr
condition|)
block|{
name|svini
operator|=
operator|(
name|inival
operator|<
name|LONG_MAX
operator|)
condition|?
operator|(
name|long
operator|)
name|inival
else|:
name|LONG_MAX
expr_stmt|;
name|svmax
operator|=
operator|(
name|maxval
operator|<
name|LONG_MAX
operator|&&
name|maxval
operator|>
literal|0
operator|)
condition|?
operator|(
name|long
operator|)
name|maxval
else|:
name|LONG_MAX
expr_stmt|;
name|semptr
operator|->
name|shnd
operator|=
name|CreateSemaphore
argument_list|(
name|NULL
argument_list|,
name|svini
argument_list|,
name|svmax
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|semptr
operator|->
name|shnd
condition|)
name|semptr
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|maxval
expr_stmt|;
if|if
condition|(
name|semptr
operator|&&
name|sem_init
argument_list|(
name|semptr
argument_list|,
name|FALSE
argument_list|,
name|inival
argument_list|)
condition|)
name|semptr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return
name|semptr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|sem_ref
name|delete_sema
parameter_list|(
name|sem_ref
name|obj
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYS_WINNT
if|if
condition|(
name|obj
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|shnd
condition|)
name|CloseHandle
argument_list|(
name|obj
operator|->
name|shnd
argument_list|)
expr_stmt|;
name|obj
operator|->
name|shnd
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|obj
condition|)
name|sem_destroy
argument_list|(
name|obj
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * prepare_child_sems()  *  * create sync& access semaphores  *  * All semaphores are cleared, only the access semaphore has 1 unit.  * Childs wait on 'workitems_pending', then grabs 'sema_access'  * and dequeues jobs. When done, 'sema_access' is given one unit back.  *  * The producer grabs 'sema_access', manages the queue, restores  * 'sema_access' and puts one unit into 'workitems_pending'.  *  * The story goes the same for the response queue.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_child_sems
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
name|c
operator|->
name|accesslock
operator|=
name|create_sema
argument_list|(
operator|&
name|c
operator|->
name|sem_table
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|workitems_pending
operator|=
name|create_sema
argument_list|(
operator|&
name|c
operator|->
name|sem_table
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|wake_scheduled_sleep
operator|=
name|create_sema
argument_list|(
operator|&
name|c
operator|->
name|sem_table
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WORK_PIPE
name|c
operator|->
name|responses_pending
operator|=
name|create_sema
argument_list|(
operator|&
name|c
operator|->
name|sem_table
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * wait for semaphore. Where the wait can be interrupted, it will  * internally resume -- When this function returns, there is either no  * semaphore at all, a timeout occurred, or the caller could  * successfully take a token from the semaphore.  *  * For untimed wait, not checking the result of this function at all is  * definitely an option.  */
end_comment

begin_function
specifier|static
name|int
name|wait_for_sem
parameter_list|(
name|sem_ref
name|sem
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
comment|/* wall-clock */
parameter_list|)
ifdef|#
directive|ifdef
name|SYS_WINNT
block|{
name|struct
name|timespec
name|now
decl_stmt|;
name|struct
name|timespec
name|delta
decl_stmt|;
name|DWORD
name|msec
decl_stmt|;
name|DWORD
name|rc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sem
operator|&&
name|sem
operator|->
name|shnd
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|NULL
operator|==
name|timeout
condition|)
block|{
name|msec
operator|=
name|INFINITE
expr_stmt|;
block|}
else|else
block|{
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|delta
operator|=
name|sub_tspec
argument_list|(
operator|*
name|timeout
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|.
name|tv_sec
operator|<
literal|0
condition|)
block|{
name|msec
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|delta
operator|.
name|tv_sec
operator|+
literal|1
operator|)
operator|>=
operator|(
name|MAXDWORD
operator|/
literal|1000
operator|)
condition|)
block|{
name|msec
operator|=
name|INFINITE
expr_stmt|;
block|}
else|else
block|{
name|msec
operator|=
literal|1000
operator|*
operator|(
name|DWORD
operator|)
name|delta
operator|.
name|tv_sec
expr_stmt|;
name|msec
operator|+=
name|delta
operator|.
name|tv_nsec
operator|/
operator|(
literal|1000
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|WaitForSingleObject
argument_list|(
name|sem
operator|->
name|shnd
argument_list|,
name|msec
argument_list|)
expr_stmt|;
if|if
condition|(
name|WAIT_OBJECT_0
operator|==
name|rc
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|WAIT_TIMEOUT
operator|==
name|rc
condition|)
block|{
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForSingleObject unexpected 0x%x"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* pthreads wait_for_sem() follows */
end_comment

begin_block
block|{
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|sem
condition|)
do|do
block|{
if|if
condition|(
name|NULL
operator|==
name|timeout
condition|)
name|rc
operator|=
name|sem_wait
argument_list|(
name|sem
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|sem_timedwait
argument_list|(
name|sem
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
else|else
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|rc
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* --------------------------------------------------------------------  * blocking_thread - thread functions have WINAPI (aka 'stdcall')  * calling conventions under Windows and POSIX-defined signature  * otherwise.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_function
name|u_int
name|WINAPI
else|#
directive|else
name|void
modifier|*
endif|#
directive|endif
name|blocking_thread
parameter_list|(
name|void
modifier|*
name|ThreadArg
parameter_list|)
block|{
name|blocking_child
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|ThreadArg
expr_stmt|;
name|exit_worker
argument_list|(
name|blocking_child_common
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * req_child_exit() runs in the parent.  *  * This function is called from from the idle timer, too, and possibly  * without a thread being there any longer. Since we have folded up our  * tent in that case and all the semaphores are already gone, we simply  * ignore this request in this case.  *  * Since the existence of the semaphores is controlled exclusively by  * the parent, there's no risk of data race here.  */
end_comment

begin_function
name|int
name|req_child_exit
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|->
name|accesslock
operator|)
condition|?
name|queue_req_pointer
argument_list|(
name|c
argument_list|,
name|CHILD_EXIT_REQ
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * cleanup_after_child() runs in parent.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_after_child
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
name|DEBUG_INSIST
argument_list|(
operator|!
name|c
operator|->
name|reusable
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* The thread was not created in detached state, so we better 	 * clean up. 	 */
if|if
condition|(
name|c
operator|->
name|thread_ref
operator|&&
name|c
operator|->
name|thread_ref
operator|->
name|thnd
condition|)
block|{
name|WaitForSingleObject
argument_list|(
name|c
operator|->
name|thread_ref
operator|->
name|thnd
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|CloseHandle
argument_list|(
name|c
operator|->
name|thread_ref
operator|->
name|thnd
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|thread_ref
operator|->
name|thnd
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|c
operator|->
name|thread_ref
operator|=
name|NULL
expr_stmt|;
comment|/* remove semaphores and (if signalling vi IO) pipes */
name|c
operator|->
name|accesslock
operator|=
name|delete_sema
argument_list|(
name|c
operator|->
name|accesslock
argument_list|)
expr_stmt|;
name|c
operator|->
name|workitems_pending
operator|=
name|delete_sema
argument_list|(
name|c
operator|->
name|workitems_pending
argument_list|)
expr_stmt|;
name|c
operator|->
name|wake_scheduled_sleep
operator|=
name|delete_sema
argument_list|(
name|c
operator|->
name|wake_scheduled_sleep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WORK_PIPE
name|DEBUG_INSIST
argument_list|(
operator|-
literal|1
operator|!=
name|c
operator|->
name|resp_read_pipe
argument_list|)
expr_stmt|;
name|DEBUG_INSIST
argument_list|(
operator|-
literal|1
operator|!=
name|c
operator|->
name|resp_write_pipe
argument_list|)
expr_stmt|;
call|(
modifier|*
name|addremove_io_fd
call|)
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|,
name|c
operator|->
name|ispipe
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|c
operator|->
name|resp_write_pipe
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|)
expr_stmt|;
name|c
operator|->
name|resp_write_pipe
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|resp_read_pipe
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|DEBUG_INSIST
argument_list|(
name|NULL
operator|!=
name|c
operator|->
name|responses_pending
argument_list|)
expr_stmt|;
call|(
modifier|*
name|addremove_io_semaphore
call|)
argument_list|(
name|c
operator|->
name|responses_pending
operator|->
name|shnd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|c
operator|->
name|responses_pending
operator|=
name|delete_sema
argument_list|(
name|c
operator|->
name|responses_pending
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Is it necessary to check if there are pending requests and 	 * responses? If so, and if there are, what to do with them? 	 */
comment|/* re-init buffer index sequencers */
name|c
operator|->
name|head_workitem
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tail_workitem
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|head_response
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tail_response
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|reusable
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !WORK_THREAD follows */
end_comment

begin_decl_stmt
name|char
name|work_thread_nonempty_compilation_unit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

