begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * systime -- routines to fiddle a UNIX clock.  *  * ATTENTION: Get approval from Dave Mills on all changes to this file!  *  */
end_comment

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_include
include|#
directive|include
file|"ntpsim.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMP_H
end_ifdef

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTMP_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
end_ifdef

begin_include
include|#
directive|include
file|<utmpx.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTMPX_H */
end_comment

begin_comment
comment|/*  * These routines (get_systime, step_systime, adj_systime) implement an  * interface between the system independent NTP clock and the Unix  * system clock in various architectures and operating systems.  *  * Time is a precious quantity in these routines and every effort is  * made to minimize errors by always rounding toward zero and amortizing  * adjustment residues. By default the adjustment quantum is 1 us for  * the usual Unix tickadj() system call, but this can be increased if  * necessary by a configuration command. For instance, when the  * adjtime() quantum is a clock tick for a 100-Hz clock, the quantum  * should be 10 ms.  */
end_comment

begin_decl_stmt
name|double
name|sys_tick
init|=
literal|1e-6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tickadj() quantum (s) */
end_comment

begin_decl_stmt
name|double
name|sys_residual
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* adjustment residue (s) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_comment
comment|/*  * get_systime - return system time in NTP timestamp format.  */
end_comment

begin_function
name|void
name|get_systime
parameter_list|(
name|l_fp
modifier|*
name|now
comment|/* system time */
parameter_list|)
block|{
name|double
name|dtemp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CLOCK_GETTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETCLOCK
argument_list|)
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* seconds and nanoseconds */
comment|/* 	 * Convert Unix clock from seconds and nanoseconds to seconds. 	 */
ifdef|#
directive|ifdef
name|HAVE_CLOCK_GETTIME
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|now
operator|->
name|l_i
operator|=
name|ts
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|dtemp
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1e9
expr_stmt|;
else|#
directive|else
comment|/* HAVE_CLOCK_GETTIME || HAVE_GETCLOCK */
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* seconds and microseconds */
comment|/* 	 * Convert Unix clock from seconds and microseconds to seconds. 	 */
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|now
operator|->
name|l_i
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|dtemp
operator|=
name|tv
operator|.
name|tv_usec
operator|/
literal|1e6
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_CLOCK_GETTIME || HAVE_GETCLOCK */
comment|/* 	 * Renormalize to seconds past 1900 and fraction. 	 */
name|dtemp
operator|+=
name|sys_residual
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>=
literal|1
condition|)
block|{
name|dtemp
operator|-=
literal|1
expr_stmt|;
name|now
operator|->
name|l_i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtemp
operator|<
operator|-
literal|1
condition|)
block|{
name|dtemp
operator|+=
literal|1
expr_stmt|;
name|now
operator|->
name|l_i
operator|--
expr_stmt|;
block|}
name|dtemp
operator|*=
name|FRAC
expr_stmt|;
name|now
operator|->
name|l_uf
operator|=
operator|(
name|u_int32
operator|)
name|dtemp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * adj_systime - adjust system time by the argument.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|SYS_WINNT
end_if

begin_function
name|int
comment|/* 0 okay, 1 error */
name|adj_systime
parameter_list|(
name|double
name|now
comment|/* adjustment (s) */
parameter_list|)
block|{
name|struct
name|timeval
name|adjtv
decl_stmt|;
comment|/* new adjustment */
name|struct
name|timeval
name|oadjtv
decl_stmt|;
comment|/* residual adjustment */
name|double
name|dtemp
decl_stmt|;
name|long
name|ticks
decl_stmt|;
name|int
name|isneg
init|=
literal|0
decl_stmt|;
comment|/* 	 * Most Unix adjtime() implementations adjust the system clock 	 * in microsecond quanta, but some adjust in 10-ms quanta. We 	 * carefully round the adjustment to the nearest quantum, then 	 * adjust in quanta and keep the residue for later. 	 */
name|dtemp
operator|=
name|now
operator|+
name|sys_residual
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|dtemp
operator|=
operator|-
name|dtemp
expr_stmt|;
block|}
name|adjtv
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|dtemp
expr_stmt|;
name|dtemp
operator|-=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|ticks
operator|=
call|(
name|long
call|)
argument_list|(
name|dtemp
operator|/
name|sys_tick
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
name|ticks
operator|*
name|sys_tick
operator|*
literal|1e6
argument_list|)
expr_stmt|;
name|dtemp
operator|-=
name|adjtv
operator|.
name|tv_usec
operator|/
literal|1e6
expr_stmt|;
name|sys_residual
operator|=
name|dtemp
expr_stmt|;
comment|/* 	 * Convert to signed seconds and microseconds for the Unix 	 * adjtime() system call. Note we purposely lose the adjtime() 	 * leftover. 	 */
if|if
condition|(
name|isneg
condition|)
block|{
name|adjtv
operator|.
name|tv_sec
operator|=
operator|-
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
operator|-
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
block|}
if|if
condition|(
name|adjtime
argument_list|(
operator|&
name|adjtv
argument_list|,
operator|&
name|oadjtv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"adj_systime: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * step_systime - step the system clock.  */
end_comment

begin_function
name|int
name|step_systime
parameter_list|(
name|double
name|now
parameter_list|)
block|{
name|struct
name|timeval
name|timetv
decl_stmt|,
name|adjtv
decl_stmt|,
name|oldtimetv
decl_stmt|;
name|int
name|isneg
init|=
literal|0
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CLOCK_GETTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETCLOCK
argument_list|)
name|struct
name|timespec
name|ts
decl_stmt|;
endif|#
directive|endif
name|dtemp
operator|=
name|sys_residual
operator|+
name|now
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|dtemp
operator|=
operator|-
name|dtemp
expr_stmt|;
name|adjtv
operator|.
name|tv_sec
operator|=
operator|(
name|int32
operator|)
name|dtemp
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
call|(
name|u_int32
call|)
argument_list|(
operator|(
name|dtemp
operator|-
operator|(
name|double
operator|)
name|adjtv
operator|.
name|tv_sec
operator|)
operator|*
literal|1e6
operator|+
literal|.5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adjtv
operator|.
name|tv_sec
operator|=
operator|(
name|int32
operator|)
name|dtemp
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
call|(
name|u_int32
call|)
argument_list|(
operator|(
name|dtemp
operator|-
operator|(
name|double
operator|)
name|adjtv
operator|.
name|tv_sec
operator|)
operator|*
literal|1e6
operator|+
literal|.5
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CLOCK_GETTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETCLOCK
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_CLOCK_GETTIME
operator|(
name|void
operator|)
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timetv
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
comment|/*  not HAVE_GETCLOCK */
operator|(
name|void
operator|)
name|GETTIMEOFDAY
argument_list|(
operator|&
name|timetv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_GETCLOCK */
name|oldtimetv
operator|=
name|timetv
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"step_systime: step %.6f residual %.6f\n"
argument_list|,
name|now
argument_list|,
name|sys_residual
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isneg
condition|)
block|{
name|timetv
operator|.
name|tv_sec
operator|-=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|-=
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timetv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|timetv
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
block|}
else|else
block|{
name|timetv
operator|.
name|tv_sec
operator|+=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|+=
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timetv
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|timetv
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ntp_set_tod
argument_list|(
operator|&
name|timetv
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"step-systime: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sys_residual
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_HPUX_ADJTIME
comment|/* 	 * CHECKME: is this correct when called by ntpdate????? 	 */
name|_clear_adjtime
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * FreeBSD, for example, has: 	 * struct utmp { 	 *	   char    ut_line[UT_LINESIZE]; 	 *	   char    ut_name[UT_NAMESIZE]; 	 *	   char    ut_host[UT_HOSTSIZE]; 	 *	   long    ut_time; 	 * }; 	 * and appends line="|", name="date", host="", time for the OLD 	 * and appends line="{", name="date", host="", time for the NEW 	 * to _PATH_WTMP . 	 * 	 * Some OSes have utmp, some have utmpx. 	 */
comment|/* 	 * Write old and new time entries in utmp and wtmp if step 	 * adjustment is greater than one second. 	 * 	 * This might become even Uglier... 	 */
if|if
condition|(
name|oldtimetv
operator|.
name|tv_sec
operator|!=
name|timetv
operator|.
name|tv_sec
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_UTMP_H
name|struct
name|utmp
name|ut
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
name|struct
name|utmpx
name|utx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UTMP_H
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ut
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|utx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UTMP */
ifdef|#
directive|ifdef
name|UPDATE_UTMP
ifdef|#
directive|ifdef
name|HAVE_PUTUTLINE
name|ut
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|oldtimetv
operator|.
name|tv_sec
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|timetv
operator|.
name|tv_sec
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|endutent
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* UPDATE_UTMP */
comment|/* UTMPX */
ifdef|#
directive|ifdef
name|UPDATE_UTMPX
ifdef|#
directive|ifdef
name|HAVE_PUTUTXLINE
name|utx
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|)
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|oldtimetv
expr_stmt|;
name|pututxline
argument_list|(
operator|&
name|utx
argument_list|)
expr_stmt|;
name|setutxent
argument_list|()
expr_stmt|;
name|utx
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|)
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|timetv
expr_stmt|;
name|pututxline
argument_list|(
operator|&
name|utx
argument_list|)
expr_stmt|;
name|endutxent
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* UPDATE_UTMPX */
comment|/* WTMP */
ifdef|#
directive|ifdef
name|UPDATE_WTMP
ifdef|#
directive|ifdef
name|HAVE_PUTUTLINE
name|utmpname
argument_list|(
name|WTMP_FILE
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|oldtimetv
operator|.
name|tv_sec
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|timetv
operator|.
name|tv_sec
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|endutent
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* UPDATE_WTMP */
comment|/* WTMPX */
ifdef|#
directive|ifdef
name|UPDATE_WTMPX
ifdef|#
directive|ifdef
name|HAVE_PUTUTXLINE
name|utx
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|oldtimetv
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_UPDWTMPX
name|updwtmpx
argument_list|(
name|WTMPX_FILE
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_UPDWTMPX */
endif|#
directive|endif
comment|/* not HAVE_UPDWTMPX */
else|#
directive|else
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTXLINE */
ifdef|#
directive|ifdef
name|HAVE_PUTUTXLINE
name|utx
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|timetv
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_UPDWTMPX
name|updwtmpx
argument_list|(
name|WTMPX_FILE
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_UPDWTMPX */
endif|#
directive|endif
comment|/* not HAVE_UPDWTMPX */
else|#
directive|else
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* UPDATE_WTMPX */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SIM */
end_comment

begin_comment
comment|/*  * Clock routines for the simulator - Harish Nair, with help  */
end_comment

begin_comment
comment|/*  * get_systime - return the system time in NTP timestamp format   */
end_comment

begin_function
name|void
name|get_systime
parameter_list|(
name|l_fp
modifier|*
name|now
comment|/* current system time in l_fp */
parameter_list|)
block|{
comment|/* 	 * To fool the code that determines the local clock precision, 	 * we advance the clock a minimum of 200 nanoseconds on every 	 * clock read. This is appropriate for a typical modern machine 	 * with nanosecond clocks. Note we make no attempt here to 	 * simulate reading error, since the error is so small. This may 	 * change when the need comes to implement picosecond clocks. 	 */
if|if
condition|(
name|ntp_node
operator|.
name|ntp_time
operator|==
name|ntp_node
operator|.
name|last_time
condition|)
name|ntp_node
operator|.
name|ntp_time
operator|+=
literal|200e-9
expr_stmt|;
name|ntp_node
operator|.
name|last_time
operator|=
name|ntp_node
operator|.
name|ntp_time
expr_stmt|;
name|DTOLFP
argument_list|(
name|ntp_node
operator|.
name|ntp_time
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * adj_systime - advance or retard the system clock exactly like the  * real thng.  */
end_comment

begin_function
name|int
comment|/* always succeeds */
name|adj_systime
parameter_list|(
name|double
name|now
comment|/* time adjustment (s) */
parameter_list|)
block|{
name|struct
name|timeval
name|adjtv
decl_stmt|;
comment|/* new adjustment */
name|double
name|dtemp
decl_stmt|;
name|long
name|ticks
decl_stmt|;
name|int
name|isneg
init|=
literal|0
decl_stmt|;
comment|/* 	 * Most Unix adjtime() implementations adjust the system clock 	 * in microsecond quanta, but some adjust in 10-ms quanta. We 	 * carefully round the adjustment to the nearest quantum, then 	 * adjust in quanta and keep the residue for later. 	 */
name|dtemp
operator|=
name|now
operator|+
name|sys_residual
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|dtemp
operator|=
operator|-
name|dtemp
expr_stmt|;
block|}
name|adjtv
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|dtemp
expr_stmt|;
name|dtemp
operator|-=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|ticks
operator|=
call|(
name|long
call|)
argument_list|(
name|dtemp
operator|/
name|sys_tick
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
name|ticks
operator|*
name|sys_tick
operator|*
literal|1e6
argument_list|)
expr_stmt|;
name|dtemp
operator|-=
name|adjtv
operator|.
name|tv_usec
operator|/
literal|1e6
expr_stmt|;
name|sys_residual
operator|=
name|dtemp
expr_stmt|;
comment|/* 	 * Convert to signed seconds and microseconds for the Unix 	 * adjtime() system call. Note we purposely lose the adjtime() 	 * leftover. 	 */
if|if
condition|(
name|isneg
condition|)
block|{
name|adjtv
operator|.
name|tv_sec
operator|=
operator|-
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
operator|-
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
name|sys_residual
operator|=
operator|-
name|sys_residual
expr_stmt|;
block|}
comment|/* 	 * We went to all the trouble just to be sure the emulation is 	 * precise. We now return to our regularly scheduled concert. 	 */
name|ntp_node
operator|.
name|clk_time
operator|-=
name|adjtv
operator|.
name|tv_sec
operator|+
name|adjtv
operator|.
name|tv_usec
operator|/
literal|1e6
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * step_systime - step the system clock. We are religious here.  */
end_comment

begin_function
name|int
comment|/* always succeeds */
name|step_systime
parameter_list|(
name|double
name|now
comment|/* step adjustment (s) */
parameter_list|)
block|{
name|ntp_node
operator|.
name|adj
operator|=
name|now
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * node_clock - update the clocks  */
end_comment

begin_function
name|int
comment|/* always succeeds */
name|node_clock
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|,
comment|/* global node pointer */
name|double
name|t
comment|/* node time */
parameter_list|)
block|{
name|double
name|dtemp
decl_stmt|;
comment|/* 	 * Advance client clock (ntp_time). Advance server clock 	 * (clk_time) adjusted for systematic and random frequency 	 * errors. The random error is a random walk computed as the 	 * integral of samples from a Gaussian distribution. 	 */
name|dtemp
operator|=
name|t
operator|-
name|n
operator|->
name|ntp_time
expr_stmt|;
name|n
operator|->
name|time
operator|=
name|t
expr_stmt|;
name|n
operator|->
name|ntp_time
operator|+=
name|dtemp
expr_stmt|;
name|n
operator|->
name|ferr
operator|+=
name|gauss
argument_list|(
literal|0
argument_list|,
name|dtemp
operator|*
name|n
operator|->
name|fnse
argument_list|)
expr_stmt|;
name|n
operator|->
name|clk_time
operator|+=
name|dtemp
operator|*
operator|(
literal|1
operator|+
name|n
operator|->
name|ferr
operator|)
expr_stmt|;
comment|/* 	 * Perform the adjtime() function. If the adjustment completed 	 * in the previous interval, amortize the entire amount; if not, 	 * carry the leftover to the next interval. 	 */
name|dtemp
operator|*=
name|n
operator|->
name|slew
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
name|fabs
argument_list|(
name|n
operator|->
name|adj
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|adj
operator|<
literal|0
condition|)
block|{
name|n
operator|->
name|adj
operator|+=
name|dtemp
expr_stmt|;
name|n
operator|->
name|ntp_time
operator|-=
name|dtemp
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|adj
operator|-=
name|dtemp
expr_stmt|;
name|n
operator|->
name|ntp_time
operator|+=
name|dtemp
expr_stmt|;
block|}
block|}
else|else
block|{
name|n
operator|->
name|ntp_time
operator|+=
name|n
operator|->
name|adj
expr_stmt|;
name|n
operator|->
name|adj
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gauss() - returns samples from a gaussion distribution  */
end_comment

begin_function
name|double
comment|/* Gaussian sample */
name|gauss
parameter_list|(
name|double
name|m
parameter_list|,
comment|/* sample mean */
name|double
name|s
comment|/* sample standard deviation (sigma) */
parameter_list|)
block|{
name|double
name|q1
decl_stmt|,
name|q2
decl_stmt|;
comment|/* 	 * Roll a sample from a Gaussian distribution with mean m and 	 * standard deviation s. For m = 0, s = 1, mean(y) = 0, 	 * std(y) = 1. 	 */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
operator|(
name|m
operator|)
return|;
while|while
condition|(
operator|(
name|q1
operator|=
name|drand48
argument_list|()
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|q2
operator|=
name|drand48
argument_list|()
expr_stmt|;
return|return
operator|(
name|m
operator|+
name|s
operator|*
name|sqrt
argument_list|(
operator|-
literal|2.
operator|*
name|log
argument_list|(
name|q1
argument_list|)
argument_list|)
operator|*
name|cos
argument_list|(
literal|2.
operator|*
name|PI
operator|*
name|q2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * poisson() - returns samples from a network delay distribution  */
end_comment

begin_function
name|double
comment|/* delay sample (s) */
name|poisson
parameter_list|(
name|double
name|m
parameter_list|,
comment|/* fixed propagation delay (s) */
name|double
name|s
comment|/* exponential parameter (mu) */
parameter_list|)
block|{
name|double
name|q1
decl_stmt|;
comment|/* 	 * Roll a sample from a composite distribution with propagation 	 * delay m and exponential distribution time with parameter s. 	 * For m = 0, s = 1, mean(y) = std(y) = 1. 	 */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
operator|(
name|m
operator|)
return|;
while|while
condition|(
operator|(
name|q1
operator|=
name|drand48
argument_list|()
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
return|return
operator|(
name|m
operator|-
name|s
operator|*
name|log
argument_list|(
name|q1
operator|*
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIM */
end_comment

end_unit

