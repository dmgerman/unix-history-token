begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * systime -- routines to fiddle a UNIX clock.  *  * ATTENTION: Get approval from Dave Mills on all changes to this file!  *  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_random.h"
end_include

begin_include
include|#
directive|include
file|"iosignal.h"
end_include

begin_include
include|#
directive|include
file|"timevalops.h"
end_include

begin_include
include|#
directive|include
file|"timespecops.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMP_H
end_ifdef

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTMP_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
end_ifdef

begin_include
include|#
directive|include
file|<utmpx.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTMPX_H */
end_comment

begin_decl_stmt
name|int
name|allow_panic
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allow panic correction (-g) */
end_comment

begin_decl_stmt
name|int
name|enable_panic_check
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Can we check allow_panic's state? */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_COMPILETIME_PIVOT
end_ifndef

begin_define
define|#
directive|define
name|USE_COMPILETIME_PIVOT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These routines (get_systime, step_systime, adj_systime) implement an  * interface between the system independent NTP clock and the Unix  * system clock in various architectures and operating systems. Time is  * a precious quantity in these routines and every effort is made to  * minimize errors by unbiased rounding and amortizing adjustment  * residues.  *  * In order to improve the apparent resolution, provide unbiased  * rounding and most importantly ensure that the readings cannot be  * predicted, the low-order unused portion of the time below the minimum  * time to read the clock is filled with an unbiased random fuzz.  *  * The sys_tick variable specifies the system clock tick interval in  * seconds, for stepping clocks, defined as those which return times  * less than MINSTEP greater than the previous reading. For systems that  * use a high-resolution counter such that each clock reading is always  * at least MINSTEP greater than the prior, sys_tick is the time to read  * the system clock.  *  * The sys_fuzz variable measures the minimum time to read the system  * clock, regardless of its precision.  When reading the system clock  * using get_systime() after sys_tick and sys_fuzz have been determined,  * ntpd ensures each unprocessed clock reading is no less than sys_fuzz  * later than the prior unprocessed reading, and then fuzzes the bits  * below sys_fuzz in the timestamp returned, ensuring each of its  * resulting readings is strictly later than the previous.  *  * When slewing the system clock using adj_systime() (with the kernel  * loop discipline unavailable or disabled), adjtime() offsets are  * quantized to sys_tick, if sys_tick is greater than sys_fuzz, which  * is to say if the OS presents a stepping clock.  Otherwise, offsets  * are quantized to the microsecond resolution of adjtime()'s timeval  * input.  The remaining correction sys_residual is carried into the  * next adjtime() and meanwhile is also factored into get_systime()  * readings.  */
end_comment

begin_decl_stmt
name|double
name|sys_tick
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tick size or time to read (s) */
end_comment

begin_decl_stmt
name|double
name|sys_fuzz
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min. time to read the clock (s) */
end_comment

begin_decl_stmt
name|long
name|sys_fuzz_nsec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min. time to read the clock (ns) */
end_comment

begin_decl_stmt
name|double
name|measured_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-overridable sys_tick (s) */
end_comment

begin_decl_stmt
name|double
name|sys_residual
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* adjustment residue (s) */
end_comment

begin_decl_stmt
name|int
name|trunc_os_clock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sys_tick> measured_tick */
end_comment

begin_decl_stmt
name|time_stepped_callback
name|step_callback
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_comment
comment|/* perlinger@ntp.org: As 'get_sysime()' does it's own check for clock  * backstepping, this could probably become a local variable in  * 'get_systime()' and the cruft associated with communicating via a  * static value could be removed after the v4.2.8 release.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lamport_violated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock was stepped back */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|systime_init_done
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DONE_SYSTIME_INIT
parameter_list|()
value|systime_init_done = TRUE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DONE_SYSTIME_INIT
parameter_list|()
value|do {} while (FALSE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
end_ifdef

begin_decl_stmt
name|int
name|using_sigio
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_decl_stmt
name|CRITICAL_SECTION
name|get_systime_cs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|set_sys_fuzz
parameter_list|(
name|double
name|fuzz_val
parameter_list|)
block|{
name|sys_fuzz
operator|=
name|fuzz_val
expr_stmt|;
name|INSIST
argument_list|(
name|sys_fuzz
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sys_fuzz
operator|<=
literal|1.0
argument_list|)
expr_stmt|;
name|sys_fuzz_nsec
operator|=
call|(
name|long
call|)
argument_list|(
name|sys_fuzz
operator|*
literal|1e9
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_systime
parameter_list|(
name|void
parameter_list|)
block|{
name|INIT_GET_SYSTIME_CRITSEC
argument_list|()
expr_stmt|;
name|INIT_WIN_PRECISE_TIME
argument_list|()
expr_stmt|;
name|DONE_SYSTIME_INIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_comment
comment|/* ntpsim.c has get_systime() and friends for sim */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|get_ostime
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|long
name|ticks
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CLOCK_GETTIME
argument_list|)
name|rc
operator|=
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_GETCLOCK
argument_list|)
name|rc
operator|=
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|timeval
name|tv
decl_stmt|;
name|rc
operator|=
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tsp
operator|->
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|tsp
operator|->
name|tv_nsec
operator|=
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"read system clock failed: %m (%d)"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trunc_os_clock
condition|)
block|{
name|ticks
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|tsp
operator|->
name|tv_nsec
operator|*
literal|1e-9
operator|)
operator|/
name|sys_tick
argument_list|)
expr_stmt|;
name|tsp
operator|->
name|tv_nsec
operator|=
call|(
name|long
call|)
argument_list|(
name|ticks
operator|*
literal|1e9
operator|*
name|sys_tick
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * get_systime - return system time in NTP timestamp format.  */
end_comment

begin_function
name|void
name|get_systime
parameter_list|(
name|l_fp
modifier|*
name|now
comment|/* system time */
parameter_list|)
block|{
specifier|static
name|struct
name|timespec
name|ts_last
decl_stmt|;
comment|/* last sampled os time */
specifier|static
name|struct
name|timespec
name|ts_prev
decl_stmt|;
comment|/* prior os time */
specifier|static
name|l_fp
name|lfp_prev
decl_stmt|;
comment|/* prior result */
specifier|static
name|double
name|dfuzz_prev
decl_stmt|;
comment|/* prior fuzz */
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* seconds and nanoseconds */
name|struct
name|timespec
name|ts_min
decl_stmt|;
comment|/* earliest permissible */
name|struct
name|timespec
name|ts_lam
decl_stmt|;
comment|/* lamport fictional increment */
name|struct
name|timespec
name|ts_prev_log
decl_stmt|;
comment|/* for msyslog only */
name|double
name|dfuzz
decl_stmt|;
name|double
name|ddelta
decl_stmt|;
name|l_fp
name|result
decl_stmt|;
name|l_fp
name|lfpfuzz
decl_stmt|;
name|l_fp
name|lfpdelta
decl_stmt|;
name|get_ostime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|systime_init_done
argument_list|)
expr_stmt|;
name|ENTER_GET_SYSTIME_CRITSEC
argument_list|()
expr_stmt|;
comment|/* First check if here was a Lamport violation, that is, two          * successive calls to 'get_ostime()' resulted in negative          * time difference. Use a few milliseconds of permissible          * tolerance -- being too sharp can hurt here. (This is intented          * for the Win32 target, where the HPC interpolation might          * introduce small steps backward. It should not be an issue on          * systems where get_ostime() results in a true syscall.)          */
if|if
condition|(
name|cmp_tspec
argument_list|(
name|add_tspec_ns
argument_list|(
name|ts
argument_list|,
literal|50000000
argument_list|)
argument_list|,
name|ts_last
argument_list|)
operator|<
literal|0
condition|)
name|lamport_violated
operator|=
literal|1
expr_stmt|;
name|ts_last
operator|=
name|ts
expr_stmt|;
comment|/* 	 * After default_get_precision() has set a nonzero sys_fuzz, 	 * ensure every reading of the OS clock advances by at least 	 * sys_fuzz over the prior reading, thereby assuring each 	 * fuzzed result is strictly later than the prior.  Limit the 	 * necessary fiction to 1 second. 	 */
if|if
condition|(
operator|!
name|USING_SIGIO
argument_list|()
condition|)
block|{
name|ts_min
operator|=
name|add_tspec_ns
argument_list|(
name|ts_prev
argument_list|,
name|sys_fuzz_nsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_tspec
argument_list|(
name|ts
argument_list|,
name|ts_min
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ts_lam
operator|=
name|sub_tspec
argument_list|(
name|ts_min
argument_list|,
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts_lam
operator|.
name|tv_sec
operator|>
literal|0
operator|&&
operator|!
name|lamport_violated
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get_systime Lamport advance exceeds one second (%.9f)"
argument_list|,
name|ts_lam
operator|.
name|tv_sec
operator|+
literal|1e-9
operator|*
name|ts_lam
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lamport_violated
condition|)
name|ts
operator|=
name|ts_min
expr_stmt|;
block|}
name|ts_prev_log
operator|=
name|ts_prev
expr_stmt|;
name|ts_prev
operator|=
name|ts
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Quiet "ts_prev_log.tv_sec may be used uninitialized" 		 * warning from x86 gcc 4.5.2. 		 */
name|ZERO
argument_list|(
name|ts_prev_log
argument_list|)
expr_stmt|;
block|}
comment|/* convert from timespec to l_fp fixed-point */
name|result
operator|=
name|tspec_stamp_to_lfp
argument_list|(
name|ts
argument_list|)
expr_stmt|;
comment|/* 	 * Add in the fuzz. 	 */
name|dfuzz
operator|=
name|ntp_random
argument_list|()
operator|*
literal|2.
operator|/
name|FRAC
operator|*
name|sys_fuzz
expr_stmt|;
name|DTOLFP
argument_list|(
name|dfuzz
argument_list|,
operator|&
name|lfpfuzz
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|lfpfuzz
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure result is strictly greater than prior result (ignoring 	 * sys_residual's effect for now) once sys_fuzz has been 	 * determined. 	 */
if|if
condition|(
operator|!
name|USING_SIGIO
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|L_ISZERO
argument_list|(
operator|&
name|lfp_prev
argument_list|)
operator|&&
operator|!
name|lamport_violated
condition|)
block|{
if|if
condition|(
operator|!
name|L_ISGTU
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|lfp_prev
argument_list|)
operator|&&
name|sys_fuzz
operator|>
literal|0.
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ts_prev %s ts_min %s"
argument_list|,
name|tspectoa
argument_list|(
name|ts_prev_log
argument_list|)
argument_list|,
name|tspectoa
argument_list|(
name|ts_min
argument_list|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ts %s"
argument_list|,
name|tspectoa
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sys_fuzz %ld nsec, prior fuzz %.9f"
argument_list|,
name|sys_fuzz_nsec
argument_list|,
name|dfuzz_prev
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"this fuzz %.9f"
argument_list|,
name|dfuzz
argument_list|)
expr_stmt|;
name|lfpdelta
operator|=
name|lfp_prev
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|lfpdelta
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|lfpdelta
argument_list|,
name|ddelta
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"prev get_systime 0x%x.%08x is %.9f later than 0x%x.%08x"
argument_list|,
name|lfp_prev
operator|.
name|l_ui
argument_list|,
name|lfp_prev
operator|.
name|l_uf
argument_list|,
name|ddelta
argument_list|,
name|result
operator|.
name|l_ui
argument_list|,
name|result
operator|.
name|l_uf
argument_list|)
expr_stmt|;
block|}
block|}
name|lfp_prev
operator|=
name|result
expr_stmt|;
name|dfuzz_prev
operator|=
name|dfuzz
expr_stmt|;
if|if
condition|(
name|lamport_violated
condition|)
name|lamport_violated
operator|=
name|FALSE
expr_stmt|;
block|}
name|LEAVE_GET_SYSTIME_CRITSEC
argument_list|()
expr_stmt|;
operator|*
name|now
operator|=
name|result
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * adj_systime - adjust system time by the argument.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|SYS_WINNT
end_if

begin_function
name|int
comment|/* 0 okay, 1 error */
name|adj_systime
parameter_list|(
name|double
name|now
comment|/* adjustment (s) */
parameter_list|)
block|{
name|struct
name|timeval
name|adjtv
decl_stmt|;
comment|/* new adjustment */
name|struct
name|timeval
name|oadjtv
decl_stmt|;
comment|/* residual adjustment */
name|double
name|quant
decl_stmt|;
comment|/* quantize to multiples of */
name|double
name|dtemp
decl_stmt|;
name|long
name|ticks
decl_stmt|;
name|int
name|isneg
init|=
literal|0
decl_stmt|;
comment|/* 	 * The Windows port adj_systime() depends on being called each 	 * second even when there's no additional correction, to allow 	 * emulation of adjtime() behavior on top of an API that simply 	 * sets the current rate.  This POSIX implementation needs to 	 * ignore invocations with zero correction, otherwise ongoing 	 * EVNT_NSET adjtime() can be aborted by a tiny adjtime() 	 * triggered by sys_residual. 	 */
if|if
condition|(
literal|0.
operator|==
name|now
condition|)
block|{
if|if
condition|(
name|enable_panic_check
operator|&&
name|allow_panic
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"adj_systime: allow_panic is TRUE!"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|allow_panic
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* 	 * Most Unix adjtime() implementations adjust the system clock 	 * in microsecond quanta, but some adjust in 10-ms quanta. We 	 * carefully round the adjustment to the nearest quantum, then 	 * adjust in quanta and keep the residue for later. 	 */
name|dtemp
operator|=
name|now
operator|+
name|sys_residual
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|dtemp
operator|=
operator|-
name|dtemp
expr_stmt|;
block|}
name|adjtv
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|dtemp
expr_stmt|;
name|dtemp
operator|-=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|sys_tick
operator|>
name|sys_fuzz
condition|)
name|quant
operator|=
name|sys_tick
expr_stmt|;
else|else
name|quant
operator|=
literal|1e-6
expr_stmt|;
name|ticks
operator|=
call|(
name|long
call|)
argument_list|(
name|dtemp
operator|/
name|quant
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
name|ticks
operator|*
name|quant
operator|*
literal|1.e6
operator|+
literal|.5
argument_list|)
expr_stmt|;
comment|/* The rounding in the conversions could us push over the 	 * limits: make sure the result is properly normalised! 	 * note: sign comes later, all numbers non-negative here. 	 */
if|if
condition|(
name|adjtv
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|adjtv
operator|.
name|tv_sec
operator|+=
literal|1
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
name|dtemp
operator|-=
literal|1.
expr_stmt|;
block|}
comment|/* set the new residual with leftover from correction */
name|sys_residual
operator|=
name|dtemp
operator|-
name|adjtv
operator|.
name|tv_usec
operator|*
literal|1.e-6
expr_stmt|;
comment|/* 	 * Convert to signed seconds and microseconds for the Unix 	 * adjtime() system call. Note we purposely lose the adjtime() 	 * leftover. 	 */
if|if
condition|(
name|isneg
condition|)
block|{
name|adjtv
operator|.
name|tv_sec
operator|=
operator|-
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
operator|-
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
name|sys_residual
operator|=
operator|-
name|sys_residual
expr_stmt|;
block|}
if|if
condition|(
name|adjtv
operator|.
name|tv_sec
operator|!=
literal|0
operator|||
name|adjtv
operator|.
name|tv_usec
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|adjtime
argument_list|(
operator|&
name|adjtv
argument_list|,
operator|&
name|oadjtv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"adj_systime: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable_panic_check
operator|&&
name|allow_panic
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"adj_systime: allow_panic is TRUE!"
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|enable_panic_check
operator|&&
name|allow_panic
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"adj_systime: allow_panic is TRUE!"
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * step_systime - step the system clock.  */
end_comment

begin_function
name|int
name|step_systime
parameter_list|(
name|double
name|step
parameter_list|)
block|{
name|time_t
name|pivot
decl_stmt|;
comment|/* for ntp era unfolding */
name|struct
name|timeval
name|timetv
decl_stmt|,
name|tvlast
decl_stmt|,
name|tvdiff
decl_stmt|;
name|struct
name|timespec
name|timets
decl_stmt|;
name|struct
name|calendar
name|jd
decl_stmt|;
name|l_fp
name|fp_ofs
decl_stmt|,
name|fp_sys
decl_stmt|;
comment|/* offset and target system time in FP */
comment|/* 	 * Get pivot time for NTP era unfolding. Since we don't step 	 * very often, we can afford to do the whole calculation from 	 * scratch. And we're not in the time-critical path yet. 	 */
if|#
directive|if
name|SIZEOF_TIME_T
operator|>
literal|4
comment|/* 	 * This code makes sure the resulting time stamp for the new 	 * system time is in the 2^32 seconds starting at 1970-01-01, 	 * 00:00:00 UTC. 	 */
name|pivot
operator|=
literal|0x80000000
expr_stmt|;
if|#
directive|if
name|USE_COMPILETIME_PIVOT
comment|/* 	 * Add the compile time minus 10 years to get a possible target 	 * area of (compile time - 10 years) to (compile time + 126 	 * years).  This should be sufficient for a given binary of 	 * NTPD. 	 */
if|if
condition|(
name|ntpcal_get_build_date
argument_list|(
operator|&
name|jd
argument_list|)
condition|)
block|{
name|jd
operator|.
name|year
operator|-=
literal|10
expr_stmt|;
name|pivot
operator|+=
name|ntpcal_date_to_time
argument_list|(
operator|&
name|jd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"step-systime: assume 1970-01-01 as build date"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|UNUSED_LOCAL
argument_list|(
name|jd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_COMPILETIME_PIVOT */
else|#
directive|else
name|UNUSED_LOCAL
argument_list|(
name|jd
argument_list|)
expr_stmt|;
comment|/* This makes sure the resulting time stamp is on or after 	 * 1969-12-31/23:59:59 UTC and gives us additional two years, 	 * from the change of NTP era in 2036 to the UNIX rollover in 	 * 2038. (Minus one second, but that won't hurt.) We *really* 	 * need a longer 'time_t' after that!  Or a different baseline, 	 * but that would cause other serious trouble, too. 	 */
name|pivot
operator|=
literal|0x7FFFFFFF
expr_stmt|;
endif|#
directive|endif
comment|/* get the complete jump distance as l_fp */
name|DTOLFP
argument_list|(
name|sys_residual
argument_list|,
operator|&
name|fp_sys
argument_list|)
expr_stmt|;
name|DTOLFP
argument_list|(
name|step
argument_list|,
operator|&
name|fp_ofs
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|fp_ofs
argument_list|,
operator|&
name|fp_sys
argument_list|)
expr_stmt|;
comment|/* ---> time-critical path starts ---> */
comment|/* get the current time as l_fp (without fuzz) and as struct timeval */
name|get_ostime
argument_list|(
operator|&
name|timets
argument_list|)
expr_stmt|;
name|fp_sys
operator|=
name|tspec_stamp_to_lfp
argument_list|(
name|timets
argument_list|)
expr_stmt|;
name|tvlast
operator|.
name|tv_sec
operator|=
name|timets
operator|.
name|tv_sec
expr_stmt|;
name|tvlast
operator|.
name|tv_usec
operator|=
operator|(
name|timets
operator|.
name|tv_nsec
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* get the target time as l_fp */
name|L_ADD
argument_list|(
operator|&
name|fp_sys
argument_list|,
operator|&
name|fp_ofs
argument_list|)
expr_stmt|;
comment|/* unfold the new system time */
name|timetv
operator|=
name|lfp_stamp_to_tval
argument_list|(
name|fp_sys
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
comment|/* now set new system time */
if|if
condition|(
name|ntp_set_tod
argument_list|(
operator|&
name|timetv
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"step-systime: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable_panic_check
operator|&&
name|allow_panic
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"step_systime: allow_panic is TRUE!"
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
comment|/*<--- time-critical path ended with 'ntp_set_tod()'<--- */
name|sys_residual
operator|=
literal|0
expr_stmt|;
name|lamport_violated
operator|=
operator|(
name|step
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|step_callback
condition|)
call|(
modifier|*
name|step_callback
call|)
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_HPUX_ADJTIME
comment|/* 	 * CHECKME: is this correct when called by ntpdate????? 	 */
name|_clear_adjtime
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * FreeBSD, for example, has: 	 * struct utmp { 	 *	   char    ut_line[UT_LINESIZE]; 	 *	   char    ut_name[UT_NAMESIZE]; 	 *	   char    ut_host[UT_HOSTSIZE]; 	 *	   long    ut_time; 	 * }; 	 * and appends line="|", name="date", host="", time for the OLD 	 * and appends line="{", name="date", host="", time for the NEW // } 	 * to _PATH_WTMP . 	 * 	 * Some OSes have utmp, some have utmpx. 	 */
comment|/* 	 * Write old and new time entries in utmp and wtmp if step 	 * adjustment is greater than one second. 	 * 	 * This might become even Uglier... 	 */
name|tvdiff
operator|=
name|abs_tval
argument_list|(
name|sub_tval
argument_list|(
name|timetv
argument_list|,
name|tvlast
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvdiff
operator|.
name|tv_sec
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_UTMP_H
name|struct
name|utmp
name|ut
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
name|struct
name|utmpx
name|utx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UTMP_H
name|ZERO
argument_list|(
name|ut
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
name|ZERO
argument_list|(
name|utx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UTMP */
ifdef|#
directive|ifdef
name|UPDATE_UTMP
ifdef|#
directive|ifdef
name|HAVE_PUTUTLINE
ifndef|#
directive|ifndef
name|_PATH_UTMP
define|#
directive|define
name|_PATH_UTMP
value|UTMP_FILE
endif|#
directive|endif
name|utmpname
argument_list|(
name|_PATH_UTMP
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
name|strlcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|tvlast
operator|.
name|tv_sec
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
name|strlcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|timetv
operator|.
name|tv_sec
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|endutent
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* UPDATE_UTMP */
comment|/* UTMPX */
ifdef|#
directive|ifdef
name|UPDATE_UTMPX
ifdef|#
directive|ifdef
name|HAVE_PUTUTXLINE
name|utx
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
name|strlcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|tvlast
expr_stmt|;
name|setutxent
argument_list|()
expr_stmt|;
name|pututxline
argument_list|(
operator|&
name|utx
argument_list|)
expr_stmt|;
name|utx
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
name|strlcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|timetv
expr_stmt|;
name|setutxent
argument_list|()
expr_stmt|;
name|pututxline
argument_list|(
operator|&
name|utx
argument_list|)
expr_stmt|;
name|endutxent
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* UPDATE_UTMPX */
comment|/* WTMP */
ifdef|#
directive|ifdef
name|UPDATE_WTMP
ifdef|#
directive|ifdef
name|HAVE_PUTUTLINE
ifndef|#
directive|ifndef
name|_PATH_WTMP
define|#
directive|define
name|_PATH_WTMP
value|WTMP_FILE
endif|#
directive|endif
name|utmpname
argument_list|(
name|_PATH_WTMP
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
name|strlcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|tvlast
operator|.
name|tv_sec
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
name|strlcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|timetv
operator|.
name|tv_sec
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|endutent
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* UPDATE_WTMP */
comment|/* WTMPX */
ifdef|#
directive|ifdef
name|UPDATE_WTMPX
ifdef|#
directive|ifdef
name|HAVE_PUTUTXLINE
name|utx
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|tvlast
expr_stmt|;
name|strlcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_UPDWTMPX
name|updwtmpx
argument_list|(
name|WTMPX_FILE
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_UPDWTMPX */
endif|#
directive|endif
comment|/* not HAVE_UPDWTMPX */
else|#
directive|else
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTXLINE */
ifdef|#
directive|ifdef
name|HAVE_PUTUTXLINE
name|utx
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|timetv
expr_stmt|;
name|strlcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_UPDWTMPX
name|updwtmpx
argument_list|(
name|WTMPX_FILE
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_UPDWTMPX */
endif|#
directive|endif
comment|/* not HAVE_UPDWTMPX */
else|#
directive|else
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* UPDATE_WTMPX */
block|}
if|if
condition|(
name|enable_panic_check
operator|&&
name|allow_panic
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"step_systime: allow_panic is TRUE!"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|allow_panic
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

end_unit

