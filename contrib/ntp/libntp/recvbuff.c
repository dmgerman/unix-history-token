begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lists.h"
end_include

begin_include
include|#
directive|include
file|"recvbuff.h"
end_include

begin_include
include|#
directive|include
file|"iosignal.h"
end_include

begin_comment
comment|/*  * Memory allocation  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|volatile
name|full_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recvbufs on full_recv_fifo */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|volatile
name|free_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recvbufs on free_recv_list */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|volatile
name|total_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total recvbufs currently in use */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|volatile
name|lowater_adds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times we have added memory */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|volatile
name|buffer_shortfall
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of missed free receive buffers 					   between replenishments */
end_comment

begin_expr_stmt
specifier|static
name|DECL_FIFO_ANCHOR
argument_list|(
argument|recvbuf_t
argument_list|)
name|full_recv_fifo
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|recvbuf_t
modifier|*
name|free_recv_list
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_comment
comment|/*  * For Windows we need to set up a lock to manipulate the  * recv buffers to prevent corruption. We keep it lock for as  * short a time as possible  */
end_comment

begin_decl_stmt
specifier|static
name|CRITICAL_SECTION
name|RecvLock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LOCK
parameter_list|()
value|EnterCriticalSection(&RecvLock)
end_define

begin_define
define|#
directive|define
name|UNLOCK
parameter_list|()
value|LeaveCriticalSection(&RecvLock)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LOCK
parameter_list|()
value|do {} while (FALSE)
end_define

begin_define
define|#
directive|define
name|UNLOCK
parameter_list|()
value|do {} while (FALSE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|uninit_recvbuff
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|u_long
name|free_recvbuffs
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|free_recvbufs
return|;
block|}
end_function

begin_function
name|u_long
name|full_recvbuffs
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|full_recvbufs
return|;
block|}
end_function

begin_function
name|u_long
name|total_recvbuffs
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|total_recvbufs
return|;
block|}
end_function

begin_function
name|u_long
name|lowater_additions
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|lowater_adds
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|initialise_buffer
parameter_list|(
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
name|ZERO
argument_list|(
operator|*
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_buffers
parameter_list|(
name|int
name|nbufs
parameter_list|)
block|{
specifier|register
name|recvbuf_t
modifier|*
name|bufp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|abuf
decl_stmt|;
name|abuf
operator|=
name|nbufs
operator|+
name|buffer_shortfall
expr_stmt|;
name|buffer_shortfall
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|bufp
operator|=
name|emalloc_zero
argument_list|(
name|abuf
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bufp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abuf
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 		 * Allocate each buffer individually so they can be 		 * free()d during ntpd shutdown on DEBUG builds to 		 * keep them out of heap leak reports. 		 */
name|bufp
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bufp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LINK_SLIST
argument_list|(
name|free_recv_list
argument_list|,
name|bufp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bufp
operator|++
expr_stmt|;
name|free_recvbufs
operator|++
expr_stmt|;
name|total_recvbufs
operator|++
expr_stmt|;
block|}
name|lowater_adds
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_recvbuff
parameter_list|(
name|int
name|nbufs
parameter_list|)
block|{
comment|/* 	 * Init buffer free list and stat counters 	 */
name|free_recvbufs
operator|=
name|total_recvbufs
operator|=
literal|0
expr_stmt|;
name|full_recvbufs
operator|=
name|lowater_adds
operator|=
literal|0
expr_stmt|;
name|create_buffers
argument_list|(
name|nbufs
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
name|InitializeCriticalSection
argument_list|(
operator|&
name|RecvLock
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|atexit
argument_list|(
operator|&
name|uninit_recvbuff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|uninit_recvbuff
parameter_list|(
name|void
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|rbunlinked
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|rbunlinked
argument_list|,
name|full_recv_fifo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbunlinked
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|rbunlinked
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_HEAD_SLIST
argument_list|(
name|rbunlinked
argument_list|,
name|free_recv_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbunlinked
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|rbunlinked
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * freerecvbuf - make a single recvbuf available for reuse  */
end_comment

begin_function
name|void
name|freerecvbuf
parameter_list|(
name|recvbuf_t
modifier|*
name|rb
parameter_list|)
block|{
if|if
condition|(
name|rb
condition|)
block|{
name|LOCK
argument_list|()
expr_stmt|;
name|rb
operator|->
name|used
operator|--
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|used
operator|!=
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"******** freerecvbuff non-zero usage: %d *******"
argument_list|,
name|rb
operator|->
name|used
argument_list|)
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|free_recv_list
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free_recvbufs
operator|++
expr_stmt|;
name|UNLOCK
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|add_full_recv_buffer
parameter_list|(
name|recvbuf_t
modifier|*
name|rb
parameter_list|)
block|{
if|if
condition|(
name|rb
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"add_full_recv_buffer received NULL buffer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOCK
argument_list|()
expr_stmt|;
name|LINK_FIFO
argument_list|(
name|full_recv_fifo
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|full_recvbufs
operator|++
expr_stmt|;
name|UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|recvbuf_t
modifier|*
name|get_free_recv_buffer
parameter_list|(
name|void
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|buffer
decl_stmt|;
name|LOCK
argument_list|()
expr_stmt|;
name|UNLINK_HEAD_SLIST
argument_list|(
name|buffer
argument_list|,
name|free_recv_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|free_recvbufs
operator|--
expr_stmt|;
name|initialise_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|used
operator|++
expr_stmt|;
block|}
else|else
block|{
name|buffer_shortfall
operator|++
expr_stmt|;
block|}
name|UNLOCK
argument_list|()
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IO_COMPLETION_PORT
end_ifdef

begin_function
name|recvbuf_t
modifier|*
name|get_free_recv_buffer_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|buffer
condition|)
block|{
name|create_buffers
argument_list|(
name|RECV_INC
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
block|}
name|ENSURE
argument_list|(
name|buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|recvbuf_t
modifier|*
name|get_full_recv_buffer
parameter_list|(
name|void
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|rbuf
decl_stmt|;
name|LOCK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
comment|/* 	 * make sure there are free buffers when we 	 * wander off to do lengthy packet processing with 	 * any buffer we grab from the full list. 	 *  	 * fixes malloc() interrupted by SIGIO risk 	 * (Bug 889) 	 */
if|if
condition|(
name|NULL
operator|==
name|free_recv_list
operator|||
name|buffer_shortfall
operator|>
literal|0
condition|)
block|{
comment|/* 		 * try to get us some more buffers 		 */
name|create_buffers
argument_list|(
name|RECV_INC
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * try to grab a full buffer 	 */
name|UNLINK_FIFO
argument_list|(
name|rbuf
argument_list|,
name|full_recv_fifo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbuf
operator|!=
name|NULL
condition|)
name|full_recvbufs
operator|--
expr_stmt|;
name|UNLOCK
argument_list|()
expr_stmt|;
return|return
name|rbuf
return|;
block|}
end_function

begin_comment
comment|/*  * purge_recv_buffers_for_fd() - purges any previously-received input  *				 from a given file descriptor.  */
end_comment

begin_function
name|void
name|purge_recv_buffers_for_fd
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|rbufp
decl_stmt|;
name|recvbuf_t
modifier|*
name|next
decl_stmt|;
name|recvbuf_t
modifier|*
name|punlinked
decl_stmt|;
name|LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|rbufp
operator|=
name|HEAD_FIFO
argument_list|(
name|full_recv_fifo
argument_list|)
init|;
name|rbufp
operator|!=
name|NULL
condition|;
name|rbufp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|rbufp
operator|->
name|link
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IO_COMPLETION_PORT
if|if
condition|(
name|rbufp
operator|->
name|dstadr
operator|==
name|NULL
operator|&&
name|rbufp
operator|->
name|fd
operator|==
name|fd
condition|)
else|#
directive|else
if|if
condition|(
name|rbufp
operator|->
name|fd
operator|==
name|fd
condition|)
endif|#
directive|endif
block|{
name|UNLINK_MID_FIFO
argument_list|(
name|punlinked
argument_list|,
name|full_recv_fifo
argument_list|,
name|rbufp
argument_list|,
name|link
argument_list|,
name|recvbuf_t
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|punlinked
operator|==
name|rbufp
argument_list|)
expr_stmt|;
name|full_recvbufs
operator|--
expr_stmt|;
name|freerecvbuf
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Checks to see if there are buffers to process  */
end_comment

begin_function
name|isc_boolean_t
name|has_full_recv_buffer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|HEAD_FIFO
argument_list|(
name|full_recv_fifo
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
else|else
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NTP_DEBUG_LISTS_H
end_ifdef

begin_function
name|void
name|check_gen_fifo_consistency
parameter_list|(
name|void
modifier|*
name|fifo
parameter_list|)
block|{
name|gen_fifo
modifier|*
name|pf
decl_stmt|;
name|gen_node
modifier|*
name|pthis
decl_stmt|;
name|gen_node
modifier|*
modifier|*
name|pptail
decl_stmt|;
name|pf
operator|=
name|fifo
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|NULL
operator|==
name|pf
operator|->
name|phead
operator|&&
name|NULL
operator|==
name|pf
operator|->
name|pptail
operator|)
operator|||
operator|(
name|NULL
operator|!=
name|pf
operator|->
name|phead
operator|&&
name|NULL
operator|!=
name|pf
operator|->
name|pptail
operator|)
argument_list|)
expr_stmt|;
name|pptail
operator|=
operator|&
name|pf
operator|->
name|phead
expr_stmt|;
for|for
control|(
name|pthis
operator|=
name|pf
operator|->
name|phead
init|;
name|pthis
operator|!=
name|NULL
condition|;
name|pthis
operator|=
name|pthis
operator|->
name|link
control|)
if|if
condition|(
name|NULL
operator|!=
name|pthis
operator|->
name|link
condition|)
name|pptail
operator|=
operator|&
name|pthis
operator|->
name|link
expr_stmt|;
name|REQUIRE
argument_list|(
name|NULL
operator|==
name|pf
operator|->
name|pptail
operator|||
name|pptail
operator|==
name|pf
operator|->
name|pptail
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NTP_DEBUG_LISTS_H */
end_comment

end_unit

