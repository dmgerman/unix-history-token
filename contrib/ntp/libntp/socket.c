begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * socket.c - low-level socket operations  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_net.h"
end_include

begin_include
include|#
directive|include
file|"ntp_debug.h"
end_include

begin_comment
comment|/*  * Windows C runtime ioctl() can't deal properly with sockets,   * map to ioctlsocket for this source file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_define
define|#
directive|define
name|ioctl
parameter_list|(
name|fd
parameter_list|,
name|opt
parameter_list|,
name|val
parameter_list|)
value|ioctlsocket(fd, opt, (u_long *)(val))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * on Unix systems the stdio library typically  * makes use of file descriptors in the lower  * integer range.  stdio usually will make use  * of the file descriptors in the range of  * [0..FOPEN_MAX)  * in order to keep this range clean, for socket  * file descriptors we attempt to move them above  * FOPEN_MAX. This is not as easy as it sounds as  * FOPEN_MAX changes from implementation to implementation  * and may exceed to current file decriptor limits.  * We are using following strategy:  * - keep a current socket fd boundary initialized with  *   max(0, min(GETDTABLESIZE() - FD_CHUNK, FOPEN_MAX))  * - attempt to move the descriptor to the boundary or  *   above.  *   - if that fails and boundary> 0 set boundary  *     to min(0, socket_fd_boundary - FD_CHUNK)  *     -> retry  *     if failure and boundary == 0 return old fd  *   - on success close old fd return new fd  *  * effects:  *   - fds will be moved above the socket fd boundary  *     if at all possible.  *   - the socket boundary will be reduced until  *     allocation is possible or 0 is reached - at this  *     point the algrithm will be disabled  */
end_comment

begin_function
name|SOCKET
name|move_fd
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_DUPFD
argument_list|)
ifndef|#
directive|ifndef
name|FD_CHUNK
define|#
directive|define
name|FD_CHUNK
value|10
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FOPEN_MAX
define|#
directive|define
name|FOPEN_MAX
value|20
endif|#
directive|endif
comment|/*  * number of fds we would like to have for  * stdio FILE* available.  * we can pick a "low" number as our use of  * FILE* is limited to log files and temporarily  * to data and config files. Except for log files  * we don't keep the other FILE* open beyond the  * scope of the function that opened it.  */
ifndef|#
directive|ifndef
name|FD_PREFERRED_SOCKBOUNDARY
define|#
directive|define
name|FD_PREFERRED_SOCKBOUNDARY
value|48
endif|#
directive|endif
specifier|static
name|SOCKET
name|socket_boundary
init|=
operator|-
literal|1
decl_stmt|;
name|SOCKET
name|newfd
decl_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|int
operator|)
name|fd
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * check whether boundary has be set up 	 * already 	 */
if|if
condition|(
name|socket_boundary
operator|==
operator|-
literal|1
condition|)
block|{
name|socket_boundary
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|min
argument_list|(
name|GETDTABLESIZE
argument_list|()
operator|-
name|FD_CHUNK
argument_list|,
name|min
argument_list|(
name|FOPEN_MAX
argument_list|,
name|FD_PREFERRED_SOCKBOUNDARY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"move_fd: estimated max descriptors: %d, "
literal|"initial socket boundary: %d\n"
operator|,
name|GETDTABLESIZE
argument_list|()
operator|,
name|socket_boundary
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Leave a space for stdio to work in. potentially moving the 	 * socket_boundary lower until allocation succeeds. 	 */
do|do
block|{
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fd
operator|<
name|socket_boundary
condition|)
block|{
comment|/* inside reserved range: attempt to move fd */
name|newfd
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
name|socket_boundary
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* success: drop the old one - return the new one */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|newfd
return|;
block|}
block|}
else|else
block|{
comment|/* outside reserved range: no work - return the original one */
return|return
name|fd
return|;
block|}
name|socket_boundary
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|socket_boundary
operator|-
name|FD_CHUNK
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"move_fd: selecting new socket boundary: %d\n"
operator|,
name|socket_boundary
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|socket_boundary
operator|>
literal|0
condition|)
do|;
else|#
directive|else
name|ENSURE
argument_list|(
operator|(
name|int
operator|)
name|fd
operator|>=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(SYS_WINNT)&& defined(F_DUPFD) */
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  * make_socket_nonblocking() - set up descriptor to be non blocking  */
end_comment

begin_function
name|void
name|make_socket_nonblocking
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
comment|/* 	 * set non-blocking, 	 */
ifdef|#
directive|ifdef
name|USE_FIONBIO
comment|/* in vxWorks we use FIONBIO, but the others are defined for old 	 * systems, so all hell breaks loose if we leave them defined 	 */
undef|#
directive|undef
name|O_NONBLOCK
undef|#
directive|undef
name|FNDELAY
undef|#
directive|undef
name|O_NDELAY
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
comment|/* POSIX */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NONBLOCK) fails on fd #%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY) fails on fd #%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
comment|/* generally the same as FNDELAY */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NDELAY) fails on fd #%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIONBIO
argument_list|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIONBIO) fails on fd #%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIOSNBIO
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOSNBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSNBIO) fails on fd #%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
include|#
directive|include
file|"Bletch: Need non-blocking I/O!"
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* The following subroutines should probably be moved here */
end_comment

begin_endif
unit|static SOCKET open_socket( 	sockaddr_u *	addr, 	int		bcast, 	int		turn_off_reuse, 	endpt *		interf 	) void sendpkt( 	sockaddr_u *		dest, 	struct interface *	ep, 	int			ttl, 	struct pkt *		pkt, 	int			len 	)  static inline int read_refclock_packet(SOCKET fd, struct refclockio *rp, l_fp ts)  static inline int read_network_packet( 	SOCKET			fd, 	struct interface *	itf, 	l_fp			ts 	)  void kill_asyncio(int startfd)
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

end_unit

