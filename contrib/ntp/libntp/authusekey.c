begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * authusekey - decode a key from ascii and use it  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Types of ascii representations for keys.  "Standard" means a 64 bit  * hex number in NBS format, i.e. with the low order bit of each byte  * a parity bit.  "NTP" means a 64 bit key in NTP format, with the  * high order bit of each byte a parity bit.  "Ascii" means a 1-to-8  * character string whose ascii representation is used as the key.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DES
end_ifdef

begin_define
define|#
directive|define
name|KEY_TYPE_STD
value|1
end_define

begin_define
define|#
directive|define
name|KEY_TYPE_NTP
value|2
end_define

begin_define
define|#
directive|define
name|KEY_TYPE_ASCII
value|3
end_define

begin_define
define|#
directive|define
name|STD_PARITY_BITS
value|((unsigned)0x01010101)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|KEY_TYPE_MD5
value|4
end_define

begin_function
name|int
name|authusekey
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|int
name|keytype
parameter_list|,
specifier|const
name|u_char
modifier|*
name|str
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DES
name|u_int32
name|key
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|keybytes
index|[
literal|8
index|]
decl_stmt|;
name|char
modifier|*
name|xdigit
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|hex
init|=
literal|"0123456789abcdef"
decl_stmt|;
endif|#
directive|endif
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|cp
operator|=
name|str
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|keytype
condition|)
block|{
ifdef|#
directive|ifdef
name|DES
case|case
name|KEY_TYPE_STD
case|:
case|case
name|KEY_TYPE_NTP
case|:
if|if
condition|(
name|len
operator|!=
literal|16
condition|)
comment|/* Lazy.  Should define constant */
return|return
literal|0
return|;
comment|/* 		 * Decode hex key. 		 */
name|key
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|key
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|xdigit
operator|=
name|strchr
argument_list|(
name|hex
argument_list|,
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
else|:
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|xdigit
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|key
index|[
name|i
operator|>>
literal|3
index|]
operator|<<=
literal|4
expr_stmt|;
name|key
index|[
name|i
operator|>>
literal|3
index|]
operator||=
call|(
name|u_int32
call|)
argument_list|(
name|xdigit
operator|-
name|hex
argument_list|)
operator|&
literal|0xf
expr_stmt|;
block|}
comment|/* 		 * If this is an NTP format key, put it into NBS format 		 */
if|if
condition|(
name|keytype
operator|==
name|KEY_TYPE_NTP
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|key
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|key
index|[
name|i
index|]
operator|<<
literal|1
operator|)
operator|&
operator|~
name|STD_PARITY_BITS
operator|)
operator||
operator|(
operator|(
name|key
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|&
name|STD_PARITY_BITS
operator|)
expr_stmt|;
block|}
comment|/* 		 * Check the parity, reject the key if the check fails 		 */
if|if
condition|(
operator|!
name|DESauth_parity
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* 		 * We can't find a good reason not to use this key. 		 * So use it. 		 */
name|DESauth_setkey
argument_list|(
name|keyno
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_TYPE_ASCII
case|:
comment|/* 		 * Make up key from ascii representation 		 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keybytes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|keybytes
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|keybytes
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
operator|<<
literal|1
expr_stmt|;
name|key
index|[
literal|0
index|]
operator|=
operator|(
name|u_int32
operator|)
name|keybytes
index|[
literal|0
index|]
operator|<<
literal|24
operator||
operator|(
name|u_int32
operator|)
name|keybytes
index|[
literal|1
index|]
operator|<<
literal|16
operator||
operator|(
name|u_int32
operator|)
name|keybytes
index|[
literal|2
index|]
operator|<<
literal|8
operator||
operator|(
name|u_int32
operator|)
name|keybytes
index|[
literal|3
index|]
expr_stmt|;
name|key
index|[
literal|1
index|]
operator|=
operator|(
name|u_int32
operator|)
name|keybytes
index|[
literal|4
index|]
operator|<<
literal|24
operator||
operator|(
name|u_int32
operator|)
name|keybytes
index|[
literal|5
index|]
operator|<<
literal|16
operator||
operator|(
name|u_int32
operator|)
name|keybytes
index|[
literal|6
index|]
operator|<<
literal|8
operator||
operator|(
name|u_int32
operator|)
name|keybytes
index|[
literal|7
index|]
expr_stmt|;
comment|/* 		 * Set parity on key 		 */
operator|(
name|void
operator|)
name|DESauth_parity
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* 		 * Now set key in. 		 */
name|DESauth_setkey
argument_list|(
name|keyno
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|KEY_TYPE_MD5
case|:
name|MD5auth_setkey
argument_list|(
name|keyno
argument_list|,
name|str
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Oh, well */
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

