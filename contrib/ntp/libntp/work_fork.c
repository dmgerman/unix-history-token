begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * work_fork.c - fork implementation for blocking worker child.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"ntp_workimpl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WORK_FORK
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|"iosignal.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_malloc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_worker.h"
end_include

begin_comment
comment|/* === variables === */
end_comment

begin_decl_stmt
name|int
name|worker_process
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|addremove_io_fd_func
name|addremove_io_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|worker_sighup_received
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|saved_argc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|saved_argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* === function prototypes === */
end_comment

begin_function_decl
specifier|static
name|void
name|fork_blocking_child
parameter_list|(
name|blocking_child
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RETSIGTYPE
name|worker_sighup
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_worker_home_atexit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleanup_after_child
parameter_list|(
name|blocking_child
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* === I/O helpers === */
end_comment

begin_comment
comment|/* Since we have signals enabled, there's a good chance that blocking IO  * via pipe suffers from EINTR -- and this goes for both directions.  * The next two wrappers will loop until either all the data is written  * or read, plus handling the EOF condition on read. They may return  * zero if no data was transferred at all, and effectively every return  * value that differs from the given transfer length signifies an error  * condition.  */
end_comment

begin_function
specifier|static
name|size_t
name|netread
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|vb
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|char
modifier|*
name|b
init|=
name|vb
decl_stmt|;
name|ssize_t
name|r
decl_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|b
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
block|{
name|l
operator|-=
name|r
expr_stmt|;
name|b
operator|+=
name|r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
operator|||
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|l
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
call|(
name|size_t
call|)
argument_list|(
name|b
operator|-
operator|(
name|char
operator|*
operator|)
name|vb
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|netwrite
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|b
init|=
name|vb
decl_stmt|;
name|ssize_t
name|w
decl_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|w
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|b
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|0
condition|)
block|{
name|l
operator|-=
name|w
expr_stmt|;
name|b
operator|+=
name|w
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|l
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
call|(
name|size_t
call|)
argument_list|(
name|b
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|vb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* === functions === */
end_comment

begin_comment
comment|/*  * exit_worker()  *  * On some systems _exit() is preferred to exit() for forked children.  * For example, http://netbsd.gw.com/cgi-bin/man-cgi?fork++NetBSD-5.0  * recommends _exit() to avoid double-flushing C runtime stream buffers  * and also to avoid calling the parent's atexit() routines in the  * child.  On those systems WORKER_CHILD_EXIT is _exit.  Since _exit  * bypasses CRT cleanup, fflush() files we know might have output  * buffered.  */
end_comment

begin_function
name|void
name|exit_worker
parameter_list|(
name|int
name|exitcode
parameter_list|)
block|{
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
condition|)
name|fflush
argument_list|(
name|syslog_file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|WORKER_CHILD_EXIT
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
comment|/* space before ( required */
block|}
end_function

begin_function
specifier|static
name|RETSIGTYPE
name|worker_sighup
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|SIGHUP
operator|==
name|sig
condition|)
name|worker_sighup_received
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|worker_sleep
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|,
name|time_t
name|seconds
parameter_list|)
block|{
name|u_int
name|sleep_remain
decl_stmt|;
name|sleep_remain
operator|=
operator|(
name|u_int
operator|)
name|seconds
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|worker_sighup_received
condition|)
name|sleep_remain
operator|=
name|sleep
argument_list|(
name|sleep_remain
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker_sighup_received
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"worker SIGHUP with %us left to sleep"
operator|,
name|sleep_remain
operator|)
argument_list|)
expr_stmt|;
name|worker_sighup_received
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|sleep_remain
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|interrupt_worker_sleep
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|;
name|blocking_child
modifier|*
name|c
decl_stmt|;
name|int
name|rc
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|blocking_children_alloc
condition|;
name|idx
operator|++
control|)
block|{
name|c
operator|=
name|blocking_children
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|c
operator|||
name|c
operator|->
name|reusable
operator|==
name|TRUE
condition|)
continue|continue;
name|rc
operator|=
name|kill
argument_list|(
name|c
operator|->
name|pid
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to signal HUP to wake child pid %d: %m"
argument_list|,
name|c
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * harvest_child_status() runs in the parent.  *  * Note the error handling -- this is an interaction with SIGCHLD.  * SIG_IGN on SIGCHLD on some OSes means do not wait but reap  * automatically. Since we're not really interested in the result code,  * we simply ignore the error.  */
end_comment

begin_function
specifier|static
name|void
name|harvest_child_status
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|pid
condition|)
block|{
comment|/* Wait on the child so it can finish terminating */
if|if
condition|(
name|waitpid
argument_list|(
name|c
operator|->
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|c
operator|->
name|pid
condition|)
name|TRACE
argument_list|(
literal|4
argument_list|,
operator|(
literal|"harvested child %d\n"
operator|,
name|c
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ECHILD
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error waiting on child %d: %m"
argument_list|,
name|c
operator|->
name|pid
argument_list|)
expr_stmt|;
name|c
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * req_child_exit() runs in the parent.  */
end_comment

begin_function
name|int
name|req_child_exit
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
operator|-
literal|1
operator|!=
name|c
operator|->
name|req_write_pipe
condition|)
block|{
name|close
argument_list|(
name|c
operator|->
name|req_write_pipe
argument_list|)
expr_stmt|;
name|c
operator|->
name|req_write_pipe
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Closing the pipe forces the child to exit */
name|harvest_child_status
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * cleanup_after_child() runs in parent.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_after_child
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
name|harvest_child_status
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|c
operator|->
name|resp_read_pipe
condition|)
block|{
call|(
modifier|*
name|addremove_io_fd
call|)
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|,
name|c
operator|->
name|ispipe
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|)
expr_stmt|;
name|c
operator|->
name|resp_read_pipe
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|c
operator|->
name|resp_read_ctx
operator|=
name|NULL
expr_stmt|;
name|DEBUG_INSIST
argument_list|(
operator|-
literal|1
operator|==
name|c
operator|->
name|req_read_pipe
argument_list|)
expr_stmt|;
name|DEBUG_INSIST
argument_list|(
operator|-
literal|1
operator|==
name|c
operator|->
name|resp_write_pipe
argument_list|)
expr_stmt|;
name|c
operator|->
name|reusable
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_worker_home_atexit
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|;
name|blocking_child
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|worker_process
condition|)
return|return;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|blocking_children_alloc
condition|;
name|idx
operator|++
control|)
block|{
name|c
operator|=
name|blocking_children
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|c
condition|)
continue|continue;
name|req_child_exit
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|send_blocking_req_internal
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|,
name|blocking_pipe_header
modifier|*
name|hdr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|size_t
name|octets
decl_stmt|;
name|size_t
name|rc
decl_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|hdr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|BLOCKING_REQ_MAGIC
operator|==
name|hdr
operator|->
name|magic_sig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|c
operator|->
name|req_write_pipe
condition|)
block|{
name|fork_blocking_child
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|DEBUG_INSIST
argument_list|(
operator|-
literal|1
operator|!=
name|c
operator|->
name|req_write_pipe
argument_list|)
expr_stmt|;
block|}
name|octets
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|netwrite
argument_list|(
name|c
operator|->
name|req_write_pipe
argument_list|,
name|hdr
argument_list|,
name|octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|octets
condition|)
block|{
name|octets
operator|=
name|hdr
operator|->
name|octets
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|netwrite
argument_list|(
name|c
operator|->
name|req_write_pipe
argument_list|,
name|data
argument_list|,
name|octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|octets
condition|)
return|return
literal|0
return|;
block|}
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"send_blocking_req_internal: short write (%zu of %zu), %m"
argument_list|,
name|rc
argument_list|,
name|octets
argument_list|)
expr_stmt|;
comment|/* Fatal error.  Clean up the child process.  */
name|req_child_exit
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* otherwise would be return -1 */
block|}
end_function

begin_function
name|blocking_pipe_header
modifier|*
name|receive_blocking_req_internal
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
name|blocking_pipe_header
name|hdr
decl_stmt|;
name|blocking_pipe_header
modifier|*
name|req
decl_stmt|;
name|size_t
name|rc
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
name|DEBUG_REQUIRE
argument_list|(
operator|-
literal|1
operator|!=
name|c
operator|->
name|req_read_pipe
argument_list|)
expr_stmt|;
name|req
operator|=
name|NULL
expr_stmt|;
name|rc
operator|=
name|netread
argument_list|(
name|c
operator|->
name|req_read_pipe
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|rc
condition|)
block|{
name|TRACE
argument_list|(
literal|4
argument_list|,
operator|(
literal|"parent closed request pipe, child %d terminating\n"
operator|,
name|c
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"receive_blocking_req_internal: short header read (%zu of %zu), %m"
argument_list|,
name|rc
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|<
name|hdr
operator|.
name|octets
operator|&&
name|hdr
operator|.
name|octets
operator|<
literal|4
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|req
operator|=
name|emalloc
argument_list|(
name|hdr
operator|.
name|octets
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|req
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|octets
operator|=
name|hdr
operator|.
name|octets
operator|-
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|netread
argument_list|(
name|c
operator|->
name|req_read_pipe
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|req
operator|+
literal|1
operator|)
argument_list|,
name|octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|octets
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"receive_blocking_req_internal: short read (%zu of %zu), %m"
argument_list|,
name|rc
argument_list|,
name|octets
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BLOCKING_REQ_MAGIC
operator|!=
name|req
operator|->
name|magic_sig
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"receive_blocking_req_internal: packet header mismatch (0x%x)"
argument_list|,
name|req
operator|->
name|magic_sig
argument_list|)
expr_stmt|;
else|else
return|return
name|req
return|;
block|}
if|if
condition|(
name|req
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|send_blocking_resp_internal
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|,
name|blocking_pipe_header
modifier|*
name|resp
parameter_list|)
block|{
name|size_t
name|octets
decl_stmt|;
name|size_t
name|rc
decl_stmt|;
name|DEBUG_REQUIRE
argument_list|(
operator|-
literal|1
operator|!=
name|c
operator|->
name|resp_write_pipe
argument_list|)
expr_stmt|;
name|octets
operator|=
name|resp
operator|->
name|octets
expr_stmt|;
name|rc
operator|=
name|netwrite
argument_list|(
name|c
operator|->
name|resp_write_pipe
argument_list|,
name|resp
argument_list|,
name|octets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|octets
operator|==
name|rc
condition|)
return|return
literal|0
return|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"send_blocking_resp_internal: short write (%zu of %zu), %m\n"
operator|,
name|rc
operator|,
name|octets
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|blocking_pipe_header
modifier|*
name|receive_blocking_resp_internal
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
name|blocking_pipe_header
name|hdr
decl_stmt|;
name|blocking_pipe_header
modifier|*
name|resp
decl_stmt|;
name|size_t
name|rc
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|c
operator|->
name|resp_read_pipe
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
name|rc
operator|=
name|netread
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|rc
condition|)
block|{
comment|/* this is the normal child exited indication */
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"receive_blocking_resp_internal: short header read (%zu of %zu), %m\n"
operator|,
name|rc
operator|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BLOCKING_RESP_MAGIC
operator|!=
name|hdr
operator|.
name|magic_sig
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"receive_blocking_resp_internal: header mismatch (0x%x)\n"
operator|,
name|hdr
operator|.
name|magic_sig
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|<
name|hdr
operator|.
name|octets
operator|&&
name|hdr
operator|.
name|octets
operator|<
literal|16
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|resp
operator|=
name|emalloc
argument_list|(
name|hdr
operator|.
name|octets
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|resp
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|octets
operator|=
name|hdr
operator|.
name|octets
operator|-
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|netread
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
argument_list|,
name|octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|octets
condition|)
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"receive_blocking_resp_internal: short read (%zu of %zu), %m\n"
operator|,
name|rc
operator|,
name|octets
operator|)
argument_list|)
expr_stmt|;
else|else
return|return
name|resp
return|;
block|}
name|cleanup_after_child
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DROPROOT
argument_list|)
operator|&&
name|defined
argument_list|(
name|WORK_FORK
argument_list|)
end_if

begin_function
name|void
name|fork_deferred_worker
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|;
name|blocking_child
modifier|*
name|c
decl_stmt|;
name|REQUIRE
argument_list|(
name|droproot
operator|&&
name|root_dropped
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|blocking_children_alloc
condition|;
name|idx
operator|++
control|)
block|{
name|c
operator|=
name|blocking_children
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|c
condition|)
continue|continue;
if|if
condition|(
operator|-
literal|1
operator|!=
name|c
operator|->
name|req_write_pipe
operator|&&
literal|0
operator|==
name|c
operator|->
name|pid
condition|)
name|fork_blocking_child
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|fork_blocking_child
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|)
block|{
specifier|static
name|int
name|atexit_installed
decl_stmt|;
specifier|static
name|int
name|blocking_pipes
index|[
literal|4
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|was_pipe
decl_stmt|;
name|int
name|is_pipe
decl_stmt|;
name|int
name|saved_errno
init|=
literal|0
decl_stmt|;
name|int
name|childpid
decl_stmt|;
name|int
name|keep_fd
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* 	 * parent and child communicate via a pair of pipes. 	 *  	 * 0 child read request 	 * 1 parent write request 	 * 2 parent read response 	 * 3 child write response 	 */
if|if
condition|(
operator|-
literal|1
operator|==
name|c
operator|->
name|req_write_pipe
condition|)
block|{
name|rc
operator|=
name|pipe_socketpair
argument_list|(
operator|&
name|blocking_pipes
index|[
literal|0
index|]
argument_list|,
operator|&
name|was_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|rc
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|pipe_socketpair
argument_list|(
operator|&
name|blocking_pipes
index|[
literal|2
index|]
argument_list|,
operator|&
name|is_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|rc
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|blocking_pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|blocking_pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|was_pipe
operator|==
name|is_pipe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|!=
name|rc
condition|)
block|{
name|errno
operator|=
name|saved_errno
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to create worker pipes: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Move the descriptors the parent will keep open out of the 		 * low descriptors preferred by C runtime buffered FILE *. 		 */
name|c
operator|->
name|req_write_pipe
operator|=
name|move_fd
argument_list|(
name|blocking_pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|c
operator|->
name|resp_read_pipe
operator|=
name|move_fd
argument_list|(
name|blocking_pipes
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * wake any worker child on orderly shutdown of the 		 * daemon so that it can notice the broken pipes and 		 * go away promptly. 		 */
if|if
condition|(
operator|!
name|atexit_installed
condition|)
block|{
name|atexit
argument_list|(
operator|&
name|send_worker_home_atexit
argument_list|)
expr_stmt|;
name|atexit_installed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DROPROOT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NEED_EARLY_FORK
argument_list|)
comment|/* defer the fork until after root is dropped */
if|if
condition|(
name|droproot
operator|&&
operator|!
name|root_dropped
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
condition|)
name|fflush
argument_list|(
name|syslog_file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* [BUG 3050] setting SIGCHLD to SIG_IGN likely causes unwanted 	 * or undefined effects. We don't do it and leave SIGCHLD alone. 	 */
comment|/* signal_no_reset(SIGCHLD, SIG_IGN); */
name|childpid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|childpid
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to fork worker: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|childpid
condition|)
block|{
comment|/* this is the parent */
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"forked worker child (pid %d)\n"
operator|,
name|childpid
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|pid
operator|=
name|childpid
expr_stmt|;
name|c
operator|->
name|ispipe
operator|=
name|is_pipe
expr_stmt|;
comment|/* close the child's pipe descriptors. */
name|close
argument_list|(
name|blocking_pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|blocking_pipes
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|blocking_pipes
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|blocking_pipes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* wire into I/O loop */
call|(
modifier|*
name|addremove_io_fd
call|)
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|,
name|is_pipe
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
comment|/* parent returns */
block|}
comment|/* 	 * The parent gets the child pid as the return value of fork(). 	 * The child must work for it. 	 */
name|c
operator|->
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|worker_process
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * Change the process name of the child to avoid confusion 	 * about ntpd trunning twice. 	 */
if|if
condition|(
name|saved_argc
operator|!=
literal|0
condition|)
block|{
name|int
name|argcc
decl_stmt|;
name|int
name|argvlen
init|=
literal|0
decl_stmt|;
comment|/* Clear argv */
for|for
control|(
name|argcc
operator|=
literal|0
init|;
name|argcc
operator|<
name|saved_argc
condition|;
name|argcc
operator|++
control|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|saved_argv
index|[
name|argcc
index|]
argument_list|)
decl_stmt|;
name|argvlen
operator|+=
name|l
operator|+
literal|1
expr_stmt|;
name|memset
argument_list|(
name|saved_argv
index|[
name|argcc
index|]
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|saved_argv
index|[
literal|0
index|]
argument_list|,
literal|"ntpd: asynchronous dns resolver"
argument_list|,
name|argvlen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * In the child, close all files except stdin, stdout, stderr, 	 * and the two child ends of the pipes. 	 */
name|DEBUG_INSIST
argument_list|(
operator|-
literal|1
operator|==
name|c
operator|->
name|req_read_pipe
argument_list|)
expr_stmt|;
name|DEBUG_INSIST
argument_list|(
operator|-
literal|1
operator|==
name|c
operator|->
name|resp_write_pipe
argument_list|)
expr_stmt|;
name|c
operator|->
name|req_read_pipe
operator|=
name|blocking_pipes
index|[
literal|0
index|]
expr_stmt|;
name|c
operator|->
name|resp_write_pipe
operator|=
name|blocking_pipes
index|[
literal|3
index|]
expr_stmt|;
name|kill_asyncio
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|syslog_file
argument_list|)
expr_stmt|;
name|syslog_file
operator|=
name|NULL
expr_stmt|;
name|syslogit
operator|=
name|TRUE
expr_stmt|;
block|}
name|keep_fd
operator|=
name|max
argument_list|(
name|c
operator|->
name|req_read_pipe
argument_list|,
name|c
operator|->
name|resp_write_pipe
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|3
init|;
name|fd
operator|<
name|keep_fd
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|fd
operator|!=
name|c
operator|->
name|req_read_pipe
operator|&&
name|fd
operator|!=
name|c
operator|->
name|resp_write_pipe
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close_all_beyond
argument_list|(
name|keep_fd
argument_list|)
expr_stmt|;
comment|/* 	 * We get signals from refclock serial I/O on NetBSD in the 	 * worker if we do not reset SIGIO's handler to the default. 	 * It is not conditionalized for NetBSD alone because on 	 * systems where it is not needed, it is harmless, and that 	 * allows us to handle unknown others with NetBSD behavior. 	 * [Bug 1386] 	 */
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
name|signal_no_reset
argument_list|(
name|SIGIO
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
name|signal_no_reset
argument_list|(
name|SIGPOLL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal_no_reset
argument_list|(
name|SIGHUP
argument_list|,
name|worker_sighup
argument_list|)
expr_stmt|;
name|init_logging
argument_list|(
literal|"ntp_intres"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|setup_logfile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * And now back to the portable code 	 */
name|exit_worker
argument_list|(
name|blocking_child_common
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_global_lock
parameter_list|(
name|int
name|inOrOut
parameter_list|)
block|{
operator|(
name|void
operator|)
name|inOrOut
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !WORK_FORK follows */
end_comment

begin_decl_stmt
name|char
name|work_fork_nonempty_compilation_unit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

