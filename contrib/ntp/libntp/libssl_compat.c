begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * libssl_compat.c -- OpenSSL v1.1 compatibility functions  *  * ---------------------------------------------------------------------  * Written by Juergen Perlinger<perlinger@ntp.org> for the NTP project  *  * Based on an idea by Kurt Roeckx<kurt@roeckx.be>  *  * ---------------------------------------------------------------------  * This is a clean room implementation of shim functions that have  * counterparts in the OpenSSL v1.1 API but not in earlier versions. So  * while OpenSSL broke binary compatibility with v1.1, this shim module  * should provide the necessary source code compatibility with older  * versions of OpenSSL.  * ---------------------------------------------------------------------  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OPENSSL
argument_list|)
operator|&&
name|OPENSSL_VERSION_NUMBER
operator|<
literal|0x10100000L
end_if

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_include
include|#
directive|include
file|"libssl_compat.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_comment
comment|/* --------------------------------------------------------------------  * replace a BIGNUM owned by the caller with another one if it's not  * NULL, taking over the ownership of the new value. This clears& frees  * the old value -- the clear might be overkill, but it's better to err  * on the side of paranoia here.  */
end_comment

begin_function
specifier|static
name|void
name|replace_bn_nn
parameter_list|(
name|BIGNUM
modifier|*
modifier|*
name|ps
parameter_list|,
name|BIGNUM
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|REQUIRE
argument_list|(
operator|*
name|ps
operator|!=
name|n
argument_list|)
expr_stmt|;
name|BN_clear_free
argument_list|(
operator|*
name|ps
argument_list|)
expr_stmt|;
operator|*
name|ps
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * allocation and deallocation of prime number callbacks  */
end_comment

begin_function
name|BN_GENCB
modifier|*
name|sslshimBN_GENCB_new
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|BN_GENCB
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|sslshimBN_GENCB_free
parameter_list|(
name|BN_GENCB
modifier|*
name|cb
parameter_list|)
block|{
name|free
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * allocation and deallocation of message digests  */
end_comment

begin_function
name|EVP_MD_CTX
modifier|*
name|sslshim_EVP_MD_CTX_new
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|EVP_MD_CTX
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|sslshim_EVP_MD_CTX_free
parameter_list|(
name|EVP_MD_CTX
modifier|*
name|pctx
parameter_list|)
block|{
name|free
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * get EVP keys and key type  */
end_comment

begin_function
name|int
name|sslshim_EVP_PKEY_id
parameter_list|(
specifier|const
name|EVP_PKEY
modifier|*
name|pkey
parameter_list|)
block|{
return|return
operator|(
name|pkey
operator|)
condition|?
name|pkey
operator|->
name|type
else|:
name|EVP_PKEY_NONE
return|;
block|}
end_function

begin_function
name|int
name|sslshim_EVP_PKEY_base_id
parameter_list|(
specifier|const
name|EVP_PKEY
modifier|*
name|pkey
parameter_list|)
block|{
return|return
operator|(
name|pkey
operator|)
condition|?
name|EVP_PKEY_type
argument_list|(
name|pkey
operator|->
name|type
argument_list|)
else|:
name|EVP_PKEY_NONE
return|;
block|}
end_function

begin_function
name|RSA
modifier|*
name|sslshim_EVP_PKEY_get0_RSA
parameter_list|(
name|EVP_PKEY
modifier|*
name|pkey
parameter_list|)
block|{
return|return
operator|(
name|pkey
operator|)
condition|?
name|pkey
operator|->
name|pkey
operator|.
name|rsa
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|DSA
modifier|*
name|sslshim_EVP_PKEY_get0_DSA
parameter_list|(
name|EVP_PKEY
modifier|*
name|pkey
parameter_list|)
block|{
return|return
operator|(
name|pkey
operator|)
condition|?
name|pkey
operator|->
name|pkey
operator|.
name|dsa
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * set/get RSA params  */
end_comment

begin_function
name|void
name|sslshim_RSA_get0_key
parameter_list|(
specifier|const
name|RSA
modifier|*
name|prsa
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|pn
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|pe
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|pd
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|prsa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
condition|)
operator|*
name|pn
operator|=
name|prsa
operator|->
name|n
expr_stmt|;
if|if
condition|(
name|pe
condition|)
operator|*
name|pe
operator|=
name|prsa
operator|->
name|e
expr_stmt|;
if|if
condition|(
name|pd
condition|)
operator|*
name|pd
operator|=
name|prsa
operator|->
name|d
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sslshim_RSA_set0_key
parameter_list|(
name|RSA
modifier|*
name|prsa
parameter_list|,
name|BIGNUM
modifier|*
name|n
parameter_list|,
name|BIGNUM
modifier|*
name|e
parameter_list|,
name|BIGNUM
modifier|*
name|d
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|prsa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|prsa
operator|->
name|n
operator|||
name|n
operator|)
operator|&&
operator|(
name|prsa
operator|->
name|e
operator|||
name|e
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|replace_bn_nn
argument_list|(
operator|&
name|prsa
operator|->
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|replace_bn_nn
argument_list|(
operator|&
name|prsa
operator|->
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|replace_bn_nn
argument_list|(
operator|&
name|prsa
operator|->
name|d
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|sslshim_RSA_get0_factors
parameter_list|(
specifier|const
name|RSA
modifier|*
name|prsa
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|pp
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|pq
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|prsa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
condition|)
operator|*
name|pp
operator|=
name|prsa
operator|->
name|p
expr_stmt|;
if|if
condition|(
name|pq
condition|)
operator|*
name|pq
operator|=
name|prsa
operator|->
name|q
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sslshim_RSA_set0_factors
parameter_list|(
name|RSA
modifier|*
name|prsa
parameter_list|,
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BIGNUM
modifier|*
name|q
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|prsa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|prsa
operator|->
name|p
operator|||
name|p
operator|)
operator|&&
operator|(
name|prsa
operator|->
name|q
operator|||
name|q
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|replace_bn_nn
argument_list|(
operator|&
name|prsa
operator|->
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|replace_bn_nn
argument_list|(
operator|&
name|prsa
operator|->
name|q
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|sslshim_RSA_set0_crt_params
parameter_list|(
name|RSA
modifier|*
name|prsa
parameter_list|,
name|BIGNUM
modifier|*
name|dmp1
parameter_list|,
name|BIGNUM
modifier|*
name|dmq1
parameter_list|,
name|BIGNUM
modifier|*
name|iqmp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|prsa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|prsa
operator|->
name|dmp1
operator|||
name|dmp1
operator|)
operator|&&
operator|(
name|prsa
operator|->
name|dmq1
operator|||
name|dmq1
operator|)
operator|&&
operator|(
name|prsa
operator|->
name|iqmp
operator|||
name|iqmp
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|replace_bn_nn
argument_list|(
operator|&
name|prsa
operator|->
name|dmp1
argument_list|,
name|dmp1
argument_list|)
expr_stmt|;
name|replace_bn_nn
argument_list|(
operator|&
name|prsa
operator|->
name|dmq1
argument_list|,
name|dmq1
argument_list|)
expr_stmt|;
name|replace_bn_nn
argument_list|(
operator|&
name|prsa
operator|->
name|iqmp
argument_list|,
name|iqmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * set/get DSA signature parameters  */
end_comment

begin_function
name|void
name|sslshim_DSA_SIG_get0
parameter_list|(
specifier|const
name|DSA_SIG
modifier|*
name|psig
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|pr
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|ps
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|psig
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|!=
name|NULL
condition|)
operator|*
name|pr
operator|=
name|psig
operator|->
name|r
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
operator|*
name|ps
operator|=
name|psig
operator|->
name|s
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sslshim_DSA_SIG_set0
parameter_list|(
name|DSA_SIG
modifier|*
name|psig
parameter_list|,
name|BIGNUM
modifier|*
name|r
parameter_list|,
name|BIGNUM
modifier|*
name|s
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|psig
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|&&
name|s
operator|)
condition|)
return|return
literal|0
return|;
name|replace_bn_nn
argument_list|(
operator|&
name|psig
operator|->
name|r
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|replace_bn_nn
argument_list|(
operator|&
name|psig
operator|->
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * get/set DSA parameters  */
end_comment

begin_function
name|void
name|sslshim_DSA_get0_pqg
parameter_list|(
specifier|const
name|DSA
modifier|*
name|pdsa
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|pp
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|pq
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|pg
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|pdsa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
operator|*
name|pp
operator|=
name|pdsa
operator|->
name|p
expr_stmt|;
if|if
condition|(
name|pq
operator|!=
name|NULL
condition|)
operator|*
name|pq
operator|=
name|pdsa
operator|->
name|q
expr_stmt|;
if|if
condition|(
name|pg
operator|!=
name|NULL
condition|)
operator|*
name|pg
operator|=
name|pdsa
operator|->
name|g
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sslshim_DSA_set0_pqg
parameter_list|(
name|DSA
modifier|*
name|pdsa
parameter_list|,
name|BIGNUM
modifier|*
name|p
parameter_list|,
name|BIGNUM
modifier|*
name|q
parameter_list|,
name|BIGNUM
modifier|*
name|g
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|pdsa
operator|->
name|p
operator|||
name|p
operator|)
operator|&&
operator|(
name|pdsa
operator|->
name|q
operator|||
name|q
operator|)
operator|&&
operator|(
name|pdsa
operator|->
name|g
operator|||
name|g
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|replace_bn_nn
argument_list|(
operator|&
name|pdsa
operator|->
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|replace_bn_nn
argument_list|(
operator|&
name|pdsa
operator|->
name|q
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|replace_bn_nn
argument_list|(
operator|&
name|pdsa
operator|->
name|g
argument_list|,
name|g
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|sslshim_DSA_get0_key
parameter_list|(
specifier|const
name|DSA
modifier|*
name|pdsa
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|ppub_key
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
modifier|*
name|ppriv_key
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|pdsa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppub_key
operator|!=
name|NULL
condition|)
operator|*
name|ppub_key
operator|=
name|pdsa
operator|->
name|pub_key
expr_stmt|;
if|if
condition|(
name|ppriv_key
operator|!=
name|NULL
condition|)
operator|*
name|ppriv_key
operator|=
name|pdsa
operator|->
name|priv_key
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sslshim_DSA_set0_key
parameter_list|(
name|DSA
modifier|*
name|pdsa
parameter_list|,
name|BIGNUM
modifier|*
name|pub_key
parameter_list|,
name|BIGNUM
modifier|*
name|priv_key
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|pdsa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pdsa
operator|->
name|pub_key
operator|||
name|pub_key
operator|)
condition|)
return|return
literal|0
return|;
name|replace_bn_nn
argument_list|(
operator|&
name|pdsa
operator|->
name|pub_key
argument_list|,
name|pub_key
argument_list|)
expr_stmt|;
name|replace_bn_nn
argument_list|(
operator|&
name|pdsa
operator|->
name|priv_key
argument_list|,
name|priv_key
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|sslshim_X509_get_signature_nid
parameter_list|(
specifier|const
name|X509
modifier|*
name|x
parameter_list|)
block|{
return|return
name|OBJ_obj2nid
argument_list|(
name|x
operator|->
name|sig_alg
operator|->
name|algorithm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* OPENSSL&& OPENSSL_VERSION_NUMBER>= v1.1.0 */
end_comment

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_macro
name|NONEMPTY_TRANSLATION_UNIT
end_macro

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

end_unit

