begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * msyslog - either send a message to the terminal or print it on  *	     the standard output.  *  * Converted to use varargs, much better ... jks  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_debug.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"..\ports\winnt\libntp\messages.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|syslogit
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msyslog_term
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* duplicate to stdout/err */
end_comment

begin_decl_stmt
name|int
name|msyslog_term_pid
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msyslog_include_timestamp
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|syslog_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|syslog_fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|syslog_abs_fname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* libntp default ntp_syslogmask is all bits lit */
end_comment

begin_define
define|#
directive|define
name|INIT_NTP_SYSLOGMASK
value|~(u_int32)0
end_define

begin_decl_stmt
name|u_int32
name|ntp_syslogmask
init|=
name|INIT_NTP_SYSLOGMASK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare the local functions */
end_comment

begin_function_decl
name|void
name|addto_syslog
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|VSNPRINTF_PERCENT_M
end_ifndef

begin_function_decl
name|void
name|format_errmsg
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* format_errmsg() is under #ifndef VSNPRINTF_PERCENT_M above */
end_comment

begin_function
name|void
name|format_errmsg
parameter_list|(
name|char
modifier|*
name|nfmt
parameter_list|,
name|size_t
name|lennfmt
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|errval
parameter_list|)
block|{
name|char
name|errmsg
index|[
literal|256
index|]
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|n
operator|=
name|nfmt
expr_stmt|;
name|f
operator|=
name|fmt
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|n
operator|<
operator|(
name|nfmt
operator|+
name|lennfmt
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
block|{
operator|*
name|n
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
operator|!=
literal|'m'
condition|)
block|{
operator|*
name|n
operator|++
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|c
condition|)
break|break;
operator|*
name|n
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
name|errno_to_str
argument_list|(
name|errval
argument_list|,
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
comment|/* Make sure we have enough space for the error message */
if|if
condition|(
operator|(
name|n
operator|+
name|len
operator|)
operator|<
operator|(
name|nfmt
operator|+
name|lennfmt
operator|-
literal|1
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|n
argument_list|,
name|errmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|n
operator|+=
name|len
expr_stmt|;
block|}
block|}
operator|*
name|n
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VSNPRINTF_PERCENT_M */
end_comment

begin_comment
comment|/*  * errno_to_str() - a thread-safe strerror() replacement.  *		    Hides the varied signatures of strerror_r().  *		    For Windows, we have:  *			#define errno_to_str isc_strerror  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|errno_to_str
end_ifndef

begin_function
name|void
name|errno_to_str
parameter_list|(
name|int
name|err
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsiz
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|STRERROR_R_CHAR_P
argument_list|)
operator|||
operator|!
name|HAVE_DECL_STRERROR_R
name|char
modifier|*
name|pstatic
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|STRERROR_R_CHAR_P
name|pstatic
operator|=
name|strerror_r
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
else|#
directive|else
name|pstatic
operator|=
name|strerror
argument_list|(
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|NULL
operator|==
name|pstatic
operator|&&
literal|'\0'
operator|==
name|buf
index|[
literal|0
index|]
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|bufsiz
argument_list|,
literal|"%s(%d): errno %d"
argument_list|,
ifdef|#
directive|ifdef
name|STRERROR_R_CHAR_P
literal|"strerror_r"
argument_list|,
else|#
directive|else
literal|"strerror"
argument_list|,
endif|#
directive|endif
name|err
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* protect against believing an int return is a pointer */
elseif|else
if|if
condition|(
name|pstatic
operator|!=
name|buf
operator|&&
name|pstatic
operator|>
operator|(
name|char
operator|*
operator|)
name|bufsiz
condition|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|pstatic
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|strerror_r
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|bufsiz
argument_list|,
literal|"strerror_r(%d): errno %d"
argument_list|,
name|err
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* errno_to_str */
end_comment

begin_comment
comment|/*  * addto_syslog()  * This routine adds the contents of a buffer to the syslog or an  * application-specific logfile.  */
end_comment

begin_function
name|void
name|addto_syslog
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|prevcall_progname
decl_stmt|;
specifier|static
name|char
modifier|*
name|prog
decl_stmt|;
specifier|const
name|char
name|nl
index|[]
init|=
literal|"\n"
decl_stmt|;
specifier|const
name|char
name|empty
index|[]
init|=
literal|""
decl_stmt|;
name|FILE
modifier|*
name|term_file
decl_stmt|;
name|int
name|log_to_term
decl_stmt|;
name|int
name|log_to_file
decl_stmt|;
name|int
name|pid
decl_stmt|;
specifier|const
name|char
modifier|*
name|nl_or_empty
decl_stmt|;
specifier|const
name|char
modifier|*
name|human_time
decl_stmt|;
comment|/* setup program basename static var prog if needed */
if|if
condition|(
name|progname
operator|!=
name|prevcall_progname
condition|)
block|{
name|prevcall_progname
operator|=
name|progname
expr_stmt|;
name|prog
operator|=
name|strrchr
argument_list|(
name|progname
argument_list|,
name|DIR_SEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog
operator|!=
name|NULL
condition|)
name|prog
operator|++
expr_stmt|;
else|else
name|prog
operator|=
name|progname
expr_stmt|;
block|}
name|log_to_term
operator|=
name|msyslog_term
expr_stmt|;
name|log_to_file
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
if|if
condition|(
name|syslogit
condition|)
name|syslog
argument_list|(
name|level
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
condition|)
name|log_to_file
operator|=
name|TRUE
expr_stmt|;
else|else
name|log_to_term
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|log_to_term
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|log_to_file
operator|||
name|log_to_term
operator|)
condition|)
return|return;
comment|/* syslog() adds the timestamp, name, and pid */
if|if
condition|(
name|msyslog_include_timestamp
condition|)
name|human_time
operator|=
name|humanlogtime
argument_list|()
expr_stmt|;
else|else
comment|/* suppress gcc pot. uninit. warning */
name|human_time
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|msyslog_term_pid
operator|||
name|log_to_file
condition|)
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
else|else
comment|/* suppress gcc pot. uninit. warning */
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* syslog() adds trailing \n if not present */
if|if
condition|(
literal|'\n'
operator|!=
name|msg
index|[
name|strlen
argument_list|(
name|msg
argument_list|)
operator|-
literal|1
index|]
condition|)
name|nl_or_empty
operator|=
name|nl
expr_stmt|;
else|else
name|nl_or_empty
operator|=
name|empty
expr_stmt|;
if|if
condition|(
name|log_to_term
condition|)
block|{
name|term_file
operator|=
operator|(
name|level
operator|<=
name|LOG_ERR
operator|)
condition|?
name|stderr
else|:
name|stdout
expr_stmt|;
if|if
condition|(
name|msyslog_include_timestamp
condition|)
name|fprintf
argument_list|(
name|term_file
argument_list|,
literal|"%s "
argument_list|,
name|human_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|msyslog_term_pid
condition|)
name|fprintf
argument_list|(
name|term_file
argument_list|,
literal|"%s[%d]: "
argument_list|,
name|prog
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|term_file
argument_list|,
literal|"%s%s"
argument_list|,
name|msg
argument_list|,
name|nl_or_empty
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|term_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_to_file
condition|)
block|{
if|if
condition|(
name|msyslog_include_timestamp
condition|)
name|fprintf
argument_list|(
name|syslog_file
argument_list|,
literal|"%s "
argument_list|,
name|human_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|syslog_file
argument_list|,
literal|"%s[%d]: %s%s"
argument_list|,
name|prog
argument_list|,
name|pid
argument_list|,
name|msg
argument_list|,
name|nl_or_empty
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|syslog_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mvsnprintf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsiz
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VSNPRINTF_PERCENT_M
name|char
name|nfmt
index|[
literal|256
index|]
decl_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|nfmt
init|=
name|fmt
decl_stmt|;
endif|#
directive|endif
name|int
name|errval
decl_stmt|;
comment|/* 	 * Save the error value as soon as possible 	 */
ifdef|#
directive|ifdef
name|SYS_WINNT
name|errval
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|NO_ERROR
operator|==
name|errval
condition|)
endif|#
directive|endif
comment|/* SYS_WINNT */
name|errval
operator|=
name|errno
expr_stmt|;
ifndef|#
directive|ifndef
name|VSNPRINTF_PERCENT_M
name|format_errmsg
argument_list|(
name|nfmt
argument_list|,
sizeof|sizeof
argument_list|(
name|nfmt
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|errval
argument_list|)
expr_stmt|;
else|#
directive|else
name|errno
operator|=
name|errval
expr_stmt|;
endif|#
directive|endif
return|return
name|vsnprintf
argument_list|(
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|nfmt
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mvfprintf
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VSNPRINTF_PERCENT_M
name|char
name|nfmt
index|[
literal|256
index|]
decl_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|nfmt
init|=
name|fmt
decl_stmt|;
endif|#
directive|endif
name|int
name|errval
decl_stmt|;
comment|/* 	 * Save the error value as soon as possible 	 */
ifdef|#
directive|ifdef
name|SYS_WINNT
name|errval
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|NO_ERROR
operator|==
name|errval
condition|)
endif|#
directive|endif
comment|/* SYS_WINNT */
name|errval
operator|=
name|errno
expr_stmt|;
ifndef|#
directive|ifndef
name|VSNPRINTF_PERCENT_M
name|format_errmsg
argument_list|(
name|nfmt
argument_list|,
sizeof|sizeof
argument_list|(
name|nfmt
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|errval
argument_list|)
expr_stmt|;
else|#
directive|else
name|errno
operator|=
name|errval
expr_stmt|;
endif|#
directive|endif
return|return
name|vfprintf
argument_list|(
name|fp
argument_list|,
name|nfmt
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mfprintf
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mvfprintf
argument_list|(
name|fp
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|mprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mvfprintf
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|msnprintf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsiz
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|size_t
name|rc
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mvsnprintf
argument_list|(
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|msyslog
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|mvsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|addto_syslog
argument_list|(
name|level
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the logging  *  * Called once per process, including forked children.  */
end_comment

begin_function
name|void
name|init_logging
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_int32
name|def_syslogmask
parameter_list|,
name|int
name|is_daemon
parameter_list|)
block|{
specifier|static
name|int
name|was_daemon
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname
decl_stmt|;
comment|/* 	 * ntpd defaults to only logging sync-category events, when 	 * NLOG() is used to conditionalize.  Other libntp clients 	 * leave it alone so that all NLOG() conditionals will fire. 	 * This presumes all bits lit in ntp_syslogmask can't be 	 * configured via logconfig and all lit is thereby a sentinel 	 * that ntp_syslogmask is still at its default from libntp, 	 * keeping in mind this function is called in forked children 	 * where it has already been called in the parent earlier. 	 * Forked children pass 0 for def_syslogmask. 	 */
if|if
condition|(
name|INIT_NTP_SYSLOGMASK
operator|==
name|ntp_syslogmask
operator|&&
literal|0
operator|!=
name|def_syslogmask
condition|)
name|ntp_syslogmask
operator|=
name|def_syslogmask
expr_stmt|;
comment|/* set more via logconfig */
comment|/* 	 * Logging.  This may actually work on the gizmo board.  Find a name 	 * to log with by using the basename 	 */
name|cp
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
name|DIR_SEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|cp
condition|)
name|pname
operator|=
name|name
expr_stmt|;
else|else
name|pname
operator|=
literal|1
operator|+
name|cp
expr_stmt|;
comment|/* skip DIR_SEP */
name|progname
operator|=
name|estrdup
argument_list|(
name|pname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* strip ".exe" */
name|cp
operator|=
name|strrchr
argument_list|(
name|progname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|cp
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|cp
argument_list|,
literal|".exe"
argument_list|)
condition|)
name|progname
index|[
name|cp
operator|-
name|progname
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|is_daemon
condition|)
name|was_daemon
operator|=
name|TRUE
expr_stmt|;
ifndef|#
directive|ifndef
name|LOG_DAEMON
name|openlog
argument_list|(
name|progname
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LOG_DAEMON */
ifndef|#
directive|ifndef
name|LOG_NTP
define|#
directive|define
name|LOG_NTP
value|LOG_DAEMON
endif|#
directive|endif
name|openlog
argument_list|(
name|progname
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
operator|(
name|was_daemon
operator|)
condition|?
name|LOG_NTP
else|:
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* DEBUG */
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* @@@ was INFO */
endif|#
directive|endif
comment|/* LOG_DAEMON */
endif|#
directive|endif
comment|/* !VMS */
block|}
end_function

begin_comment
comment|/*  * change_logfile()  *  * Used to change from syslog to a logfile, or from one logfile to  * another, and to reopen logfiles after forking.  On systems where  * ntpd forks, deals with converting relative logfile paths to  * absolute (root-based) because we reopen logfiles after the current  * directory has changed.  */
end_comment

begin_function
name|int
name|change_logfile
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|leave_crumbs
parameter_list|)
block|{
name|FILE
modifier|*
name|new_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|log_fname
decl_stmt|;
name|char
modifier|*
name|abs_fname
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
name|char
name|curdir
index|[
literal|512
index|]
decl_stmt|;
name|size_t
name|cd_octets
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
endif|#
directive|endif
comment|/* POSIX */
name|NTP_REQUIRE
argument_list|(
name|fname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|log_fname
operator|=
name|fname
expr_stmt|;
comment|/* 	 * In a forked child of a parent which is logging to a file 	 * instead of syslog, syslog_file will be NULL and both 	 * syslog_fname and syslog_abs_fname will be non-NULL. 	 * If we are given the same filename previously opened 	 * and it's still open, there's nothing to do here. 	 */
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
operator|&&
name|syslog_fname
operator|!=
name|NULL
operator|&&
literal|0
operator|==
name|strcmp
argument_list|(
name|syslog_fname
argument_list|,
name|log_fname
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|log_fname
argument_list|,
literal|"stderr"
argument_list|)
condition|)
block|{
name|new_file
operator|=
name|stderr
expr_stmt|;
name|abs_fname
operator|=
name|estrdup
argument_list|(
name|log_fname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|log_fname
argument_list|,
literal|"stdout"
argument_list|)
condition|)
block|{
name|new_file
operator|=
name|stdout
expr_stmt|;
name|abs_fname
operator|=
name|estrdup
argument_list|(
name|log_fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|syslog_fname
operator|!=
name|NULL
operator|&&
literal|0
operator|==
name|strcmp
argument_list|(
name|log_fname
argument_list|,
name|syslog_fname
argument_list|)
condition|)
name|log_fname
operator|=
name|syslog_abs_fname
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|log_fname
operator|!=
name|syslog_abs_fname
operator|&&
name|DIR_SEP
operator|!=
name|log_fname
index|[
literal|0
index|]
operator|&&
literal|0
operator|!=
name|strcmp
argument_list|(
name|log_fname
argument_list|,
literal|"stderr"
argument_list|)
operator|&&
literal|0
operator|!=
name|strcmp
argument_list|(
name|log_fname
argument_list|,
literal|"stdout"
argument_list|)
operator|&&
name|NULL
operator|!=
name|getcwd
argument_list|(
name|curdir
argument_list|,
sizeof|sizeof
argument_list|(
name|curdir
argument_list|)
argument_list|)
condition|)
block|{
name|cd_octets
operator|=
name|strlen
argument_list|(
name|curdir
argument_list|)
expr_stmt|;
comment|/* trim any trailing '/' */
if|if
condition|(
name|cd_octets
operator|>
literal|1
operator|&&
name|DIR_SEP
operator|==
name|curdir
index|[
name|cd_octets
operator|-
literal|1
index|]
condition|)
name|cd_octets
operator|--
expr_stmt|;
name|octets
operator|=
name|cd_octets
expr_stmt|;
name|octets
operator|+=
literal|1
expr_stmt|;
comment|/* separator '/' */
name|octets
operator|+=
name|strlen
argument_list|(
name|log_fname
argument_list|)
expr_stmt|;
name|octets
operator|+=
literal|1
expr_stmt|;
comment|/* NUL terminator */
name|abs_fname
operator|=
name|emalloc
argument_list|(
name|octets
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|abs_fname
argument_list|,
name|octets
argument_list|,
literal|"%.*s%c%s"
argument_list|,
operator|(
name|int
operator|)
name|cd_octets
argument_list|,
name|curdir
argument_list|,
name|DIR_SEP
argument_list|,
name|log_fname
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|abs_fname
operator|=
name|estrdup
argument_list|(
name|log_fname
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"attempting to open log %s\n"
operator|,
name|abs_fname
operator|)
argument_list|)
expr_stmt|;
name|new_file
operator|=
name|fopen
argument_list|(
name|abs_fname
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|new_file
condition|)
block|{
name|free
argument_list|(
name|abs_fname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* leave a pointer in the old log */
if|if
condition|(
name|leave_crumbs
operator|&&
operator|(
name|syslogit
operator|||
name|log_fname
operator|!=
name|syslog_abs_fname
operator|)
condition|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"switching logging to file %s"
argument_list|,
name|abs_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
operator|&&
name|syslog_file
operator|!=
name|stderr
operator|&&
name|syslog_file
operator|!=
name|stdout
operator|&&
name|fileno
argument_list|(
name|syslog_file
argument_list|)
operator|!=
name|fileno
argument_list|(
name|new_file
argument_list|)
condition|)
name|fclose
argument_list|(
name|syslog_file
argument_list|)
expr_stmt|;
name|syslog_file
operator|=
name|new_file
expr_stmt|;
if|if
condition|(
name|log_fname
operator|==
name|syslog_abs_fname
condition|)
block|{
name|free
argument_list|(
name|abs_fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|syslog_abs_fname
operator|!=
name|NULL
operator|&&
name|syslog_abs_fname
operator|!=
name|syslog_fname
condition|)
name|free
argument_list|(
name|syslog_abs_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|syslog_fname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|syslog_fname
argument_list|)
expr_stmt|;
name|syslog_fname
operator|=
name|estrdup
argument_list|(
name|log_fname
argument_list|)
expr_stmt|;
name|syslog_abs_fname
operator|=
name|abs_fname
expr_stmt|;
block|}
name|syslogit
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * setup_logfile()  *  * Redirect logging to a file if requested with -l/--logfile or via  * ntp.conf logfile directive.  *  * This routine is invoked three different times in the sequence of a  * typical daemon ntpd with DNS lookups to do.  First it is invoked in  * the original ntpd process, then again in the daemon after closing  * all descriptors.  In both of those cases, ntp.conf has not been  * processed, so only -l/--logfile will trigger logfile redirection in  * those invocations.  Finally, if DNS names are resolved, the worker  * child invokes this routine after its fork and close of all  * descriptors.  In this case, ntp.conf has been processed and any  * "logfile" directive needs to be honored in the child as well.  */
end_comment

begin_function
name|void
name|setup_logfile
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|syslog_fname
operator|&&
name|NULL
operator|!=
name|name
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|change_logfile
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot open log file %s, %m"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return ;
block|}
if|if
condition|(
name|NULL
operator|==
name|syslog_fname
condition|)
return|return;
if|if
condition|(
operator|-
literal|1
operator|==
name|change_logfile
argument_list|(
name|syslog_fname
argument_list|,
name|FALSE
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot reopen log file %s, %m"
argument_list|,
name|syslog_fname
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

