begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_io.c - input/output routines for ntpd.	The socket-opening code  *		   was shamelessly stolen from ntpd.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_PARAM_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKIO_H
end_ifdef

begin_comment
comment|/* UXPV: SIOC* #defines (Frank Vance<fvance@waii.com>) */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_if
if|#
directive|if
name|_BSDI_VERSION
operator|>=
literal|199510
end_if

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*	98/06/01  */
end_comment

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_comment
comment|/*  98/06/01  */
end_comment

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_if.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"iosignal.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|sigio_block_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|input_handler
name|P
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SIGPOLL and SIGIO ROUTINES.  */
end_comment

begin_comment
comment|/*  * Some systems (MOST) define SIGPOLL == SIGIO, others SIGIO == SIGPOLL, and  * a few have separate SIGIO and SIGPOLL signals.  This code checks for the  * SIGIO == SIGPOLL case at compile time.  * Do not defined USE_SIGPOLL or USE_SIGIO.  * these are interal only to ntp_io.c!  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|USE_SIGPOLL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|USE_SIGIO
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_TTY_SIGPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_UDP_SIGPOLL
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_SIGPOLL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_TTY_SIGPOLL
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|USE_UDP_SIGPOLL
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_SIGIO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
end_if

begin_if
if|#
directive|if
name|SIGIO
operator|==
name|SIGPOLL
end_if

begin_define
define|#
directive|define
name|USE_SIGIO
end_define

begin_undef
undef|#
directive|undef
name|USE_SIGPOLL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGIO == SIGPOLL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_SIGIO&& USE_SIGIO */
end_comment

begin_comment
comment|/*  * TTY initialization routines.  */
end_comment

begin_function
name|int
name|init_clock_sig
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_TTY_SIGPOLL
block|{
comment|/* DO NOT ATTEMPT TO MAKE CLOCK-FD A CTTY: not portable, unreliable */
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|I_SETSIG
argument_list|,
name|S_INPUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"init_clock_sig: ioctl(I_SETSIG, S_INPUT) failed: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
else|#
directive|else
comment|/* 	 * Special cases first! 	 */
comment|/* Was: defined(SYS_HPUX) */
if|#
directive|if
name|defined
argument_list|(
name|FIOSSAIOOWN
argument_list|)
operator|&&
name|defined
argument_list|(
name|FIOSNBIO
argument_list|)
operator|&&
name|defined
argument_list|(
name|FIOSSAIOSTAT
argument_list|)
define|#
directive|define
name|CLOCK_DONE
block|{
name|int
name|pgrp
decl_stmt|,
name|on
init|=
literal|1
decl_stmt|;
comment|/* DO NOT ATTEMPT TO MAKE CLOCK-FD A CTTY: not portable, unreliable */
name|pgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FIOSSAIOOWN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSSAIOOWN) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* 		 * set non-blocking, async I/O on the descriptor 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FIOSNBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSNBIO) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FIOSSAIOSTAT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSSAIOSTAT) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* SYS_HPUX: FIOSSAIOOWN&& FIOSNBIO&& FIOSSAIOSTAT */
comment|/* Was: defined(SYS_AIX)&& !defined(_BSD) */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_BSD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|FIOASYNC
argument_list|)
operator|&&
name|defined
argument_list|(
name|FIOSETOWN
argument_list|)
comment|/* 	 * SYSV compatibility mode under AIX. 	 */
define|#
directive|define
name|CLOCK_DONE
block|{
name|int
name|pgrp
decl_stmt|,
name|on
init|=
literal|1
decl_stmt|;
comment|/* DO NOT ATTEMPT TO MAKE CLOCK-FD A CTTY: not portable, unreliable */
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FIOASYNC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOASYNC) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|pgrp
operator|=
operator|-
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FIOSETOWN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSETOWN) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
operator||
name|FASYNC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* AIX&& !BSD: !_BSD&& FIOASYNC&& FIOSETOWN */
ifndef|#
directive|ifndef
name|CLOCK_DONE
block|{
comment|/* DO NOT ATTEMPT TO MAKE CLOCK-FD A CTTY: not portable, unreliable */
if|#
directive|if
name|defined
argument_list|(
name|TIOCSCTTY
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_FSETOWNCTTY
argument_list|)
comment|/* 		 * there are, however, always exceptions to the rules 		 * one is, that OSF accepts SETOWN on TTY fd's only, iff they are 		 * CTTYs. SunOS and HPUX do not semm to have this restriction. 		 * another question is: how can you do multiple SIGIO from several 		 * ttys (as they all should be CTTYs), wondering... 		 * 		 * kd 95-07-16 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|TIOCSCTTY
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSCTTY, 0) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* TIOCSCTTY&& USE_FSETOWNCTTY */
if|if
condition|(
name|fcntl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_SETOWN) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
operator||
name|FASYNC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* CLOCK_DONE */
endif|#
directive|endif
comment|/* !USE_TTY_SIGPOLL  */
block|}
end_function

begin_function
name|void
name|init_socket_sig
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_UDP_SIGPOLL
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_SETSIG
argument_list|,
name|S_INPUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"init_socket_sig: ioctl(I_SETSIG, S_INPUT) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* USE_UDP_SIGPOLL */
block|{
name|int
name|pgrp
decl_stmt|;
ifdef|#
directive|ifdef
name|FIOASYNC
name|int
name|on
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FIOASYNC
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOASYNC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FASYNC
argument_list|)
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_GETFL) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|FASYNC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(...|FASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
else|#
directive|else
include|#
directive|include
file|"Bletch: Need asynchronous I/O!"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UDP_BACKWARDS_SETOWN
name|pgrp
operator|=
operator|-
name|getpid
argument_list|()
expr_stmt|;
else|#
directive|else
name|pgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIOCSPGRP
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCSPGRP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(SIOCSPGRP) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIOSETOWN
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOSETOWN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSETOWN) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|F_SETOWN
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETOWN
argument_list|,
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_SETOWN) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
include|#
directive|include
file|"Bletch: Need to set process(group) to receive SIG(IO|POLL)"
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* USE_UDP_SIGPOLL */
block|}
end_function

begin_function
name|RETSIGTYPE
name|sigio_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|input_handler
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signal support routines.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
end_ifdef

begin_function
name|void
name|set_signal
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_SIGIO
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGIO
argument_list|,
name|sigio_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SIGPOLL
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGPOLL
argument_list|,
name|sigio_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|block_io_and_alarm
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|set
decl_stmt|;
if|if
condition|(
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_io_and_alarm: sigemptyset() failed: %m"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGIO
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_io_and_alarm: sigaddset(SIGIO) failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGPOLL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_io_and_alarm: sigaddset(SIGPOLL) failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGALRM
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_io_and_alarm: sigaddset(SIGALRM) failed: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_io_and_alarm: sigprocmask() failed: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|block_sigio
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|set
decl_stmt|;
operator|++
name|sigio_block_count
expr_stmt|;
if|if
condition|(
name|sigio_block_count
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"block_sigio: sigio_block_count> 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigio_block_count
operator|<
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"block_sigio: sigio_block_count< 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_sigio: sigemptyset() failed: %m"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGIO
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_sigio: sigaddset(SIGIO) failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGPOLL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_sigio: sigaddset(SIGPOLL) failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_sigio: sigprocmask() failed: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unblock_io_and_alarm
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|unset
decl_stmt|;
if|if
condition|(
name|sigemptyset
argument_list|(
operator|&
name|unset
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unblock_io_and_alarm: sigemptyset() failed: %m"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|unset
argument_list|,
name|SIGIO
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unblock_io_and_alarm: sigaddset(SIGIO) failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|unset
argument_list|,
name|SIGPOLL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unblock_io_and_alarm: sigaddset(SIGPOLL) failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|unset
argument_list|,
name|SIGALRM
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unblock_io_and_alarm: sigaddset(SIGALRM) failed: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|unset
argument_list|,
name|NULL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unblock_io_and_alarm: sigprocmask() failed: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unblock_sigio
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|unset
decl_stmt|;
operator|--
name|sigio_block_count
expr_stmt|;
if|if
condition|(
name|sigio_block_count
operator|>
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"unblock_sigio: sigio_block_count> 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigio_block_count
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"unblock_sigio: sigio_block_count< 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigemptyset
argument_list|(
operator|&
name|unset
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unblock_sigio: sigemptyset() failed: %m"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|unset
argument_list|,
name|SIGIO
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unblock_sigio: sigaddset(SIGIO) failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|unset
argument_list|,
name|SIGPOLL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unblock_sigio: sigaddset(SIGPOLL) failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|unset
argument_list|,
name|NULL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unblock_sigio: sigprocmask() failed: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wait_for_signal
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|old
decl_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
name|NULL
argument_list|,
operator|&
name|old
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wait_for_signal: sigprocmask() failed: %m"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
if|if
condition|(
name|sigdelset
argument_list|(
operator|&
name|old
argument_list|,
name|SIGIO
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wait_for_signal: sigdelset(SIGIO) failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
if|if
condition|(
name|sigdelset
argument_list|(
operator|&
name|old
argument_list|,
name|SIGPOLL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wait_for_signal: sigdelset(SIGPOLL) failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sigdelset
argument_list|(
operator|&
name|old
argument_list|,
name|SIGALRM
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wait_for_signal: sigdelset(SIGALRM) failed: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigsuspend
argument_list|(
operator|&
name|old
argument_list|)
operator|&&
operator|(
name|errno
operator|!=
name|EINTR
operator|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wait_for_signal: sigsuspend() failed: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_SIGACTION */
end_comment

begin_comment
comment|/*  * Must be an old bsd system.  * We assume there is no SIGPOLL.  */
end_comment

begin_function
name|void
name|block_io_and_alarm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|mask
decl_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigblock
argument_list|(
name|mask
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_io_and_alarm: sigblock() failed: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|block_sigio
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|mask
decl_stmt|;
operator|++
name|sigio_block_count
expr_stmt|;
if|if
condition|(
name|sigio_block_count
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"block_sigio: sigio_block_count> 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigio_block_count
operator|<
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"block_sigio: sigio_block_count< 1"
argument_list|)
expr_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigblock
argument_list|(
name|mask
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"block_sigio: sigblock() failed: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_signal
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGIO
argument_list|,
name|sigio_handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unblock_io_and_alarm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|mask
decl_stmt|,
name|omask
decl_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|omask
operator|&=
operator|~
name|mask
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unblock_sigio
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|mask
decl_stmt|,
name|omask
decl_stmt|;
operator|--
name|sigio_block_count
expr_stmt|;
if|if
condition|(
name|sigio_block_count
operator|>
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"unblock_sigio: sigio_block_count> 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigio_block_count
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"unblock_sigio: sigio_block_count< 0"
argument_list|)
expr_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|omask
operator|&=
operator|~
name|mask
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wait_for_signal
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|mask
decl_stmt|,
name|omask
decl_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|omask
operator|&=
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|sigpause
argument_list|(
name|omask
argument_list|)
operator|&&
operator|(
name|errno
operator|!=
name|EINTR
operator|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wait_for_signal: sigspause() failed: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SIGACTION */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|NotAnEmptyCompilationUnit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

