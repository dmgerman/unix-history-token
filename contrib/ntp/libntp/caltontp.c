begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * caltontp - convert a date to an NTP time  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_comment
comment|/*  * Juergen Perlinger, 2008-11-12  * Add support for full calendar calculatios. If the day-of-year is provided  * (that is, not zero) it will be used instead of month and day-of-month;  * otherwise a full turn through the calendar calculations will be taken.  *  * I know that Harlan Stenn likes to see assertions in production code, and I  * agree there, but it would be a tricky thing here. The algorithm is quite  * capable of producing sensible answers even to seemingly weird inputs: the  * date<any year here>-03-00, the 0.th March of the year, will be automtically  * treated as the last day of February, no matter whether the year is a leap  * year or not. So adding constraints is merely for the benefit of the callers,  * because the only thing we can check for consistency is our input, produced  * by somebody else.  *  * BTW: A total roundtrip using 'caljulian' would be a quite shaky thing:  * Because of the truncation of the NTP time stamp to 32 bits and the epoch  * unfolding around the current time done by 'caljulian' the roundtrip does  * *not* necessarily reproduce the input, especially if the time spec is more  * than 68 years off from the current time...  */
end_comment

begin_function
name|uint32_t
name|caltontp
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jt
parameter_list|)
block|{
name|int32_t
name|eraday
decl_stmt|;
comment|/* CE Rata Die number	*/
name|vint64
name|ntptime
decl_stmt|;
comment|/* resulting NTP time	*/
name|REQUIRE
argument_list|(
name|jt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|jt
operator|->
name|month
operator|<=
literal|13
argument_list|)
expr_stmt|;
comment|/* permit month 0..13! */
name|REQUIRE
argument_list|(
name|jt
operator|->
name|monthday
operator|<=
literal|32
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|jt
operator|->
name|yearday
operator|<=
literal|366
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|jt
operator|->
name|hour
operator|<=
literal|24
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|jt
operator|->
name|minute
operator|<=
name|MINSPERHR
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|jt
operator|->
name|second
operator|<=
name|SECSPERMIN
argument_list|)
expr_stmt|;
comment|/* 	 * First convert the date to he corresponding RataDie 	 * number. If yearday is not zero, assume that it contains a 	 * useable value and avoid all calculations involving month 	 * and day-of-month. Do a full evaluation otherwise. 	 */
if|if
condition|(
name|jt
operator|->
name|yearday
condition|)
name|eraday
operator|=
name|ntpcal_year_to_ystart
argument_list|(
name|jt
operator|->
name|year
argument_list|)
operator|+
name|jt
operator|->
name|yearday
operator|-
literal|1
expr_stmt|;
else|else
name|eraday
operator|=
name|ntpcal_date_to_rd
argument_list|(
name|jt
argument_list|)
expr_stmt|;
name|ntptime
operator|=
name|ntpcal_dayjoin
argument_list|(
name|eraday
operator|-
name|DAY_NTP_STARTS
argument_list|,
name|ntpcal_etime_to_seconds
argument_list|(
name|jt
operator|->
name|hour
argument_list|,
name|jt
operator|->
name|minute
argument_list|,
name|jt
operator|->
name|second
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ntptime
operator|.
name|d_s
operator|.
name|lo
return|;
block|}
end_function

end_unit

