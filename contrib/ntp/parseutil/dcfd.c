begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/ntp-4/parseutil/dcfd.c,v 4.9 1999/02/28 13:06:27 kardel RELEASE_19990228_A  *    * dcfd.c,v 4.9 1999/02/28 13:06:27 kardel RELEASE_19990228_A  *  * DCF77 100/200ms pulse synchronisation daemon program (via 50Baud serial line)  *  * Features:  *  DCF77 decoding  *  simple NTP loopfilter logic for local clock  *  interactive display for debugging  *  * Lacks:  *  Leap second handling (at that level you should switch to NTP Version 4 - really!)  *  * Copyright (C) 1995-1999 by Frank Kardel<kardel@acm.org>  * Copyright (C) 1993-1994 by Frank Kardel  * Friedrich-Alexander Universität Erlangen-Nürnberg, Germany  *                                      * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * This program may not be sold or used for profit without prior  * written consent of the author.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/*  * NTP compilation environment  */
end_comment

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_comment
comment|/* indirectly include ntp.h to get YEAR_PIVOT   Y2KFixes */
end_comment

begin_comment
comment|/*  * select which terminal handling to use (currently only SysV variants)  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
operator|||
name|defined
argument_list|(
name|STREAM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_define
define|#
directive|define
name|TTY_GETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|tcgetattr((_FD_), (_ARG_))
end_define

begin_define
define|#
directive|define
name|TTY_SETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|tcsetattr((_FD_), TCSANOW, (_ARG_))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HAVE_TERMIOS_H || STREAM */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIO_H
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_define
define|#
directive|define
name|TTY_GETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|ioctl((_FD_), TCGETA, (_ARG_))
end_define

begin_define
define|#
directive|define
name|TTY_SETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|ioctl((_FD_), TCSETAW, (_ARG_))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TERMIO_H || HAVE_SYSV_TTYS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_TERMIOS_H || STREAM */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TTY_GETATTR
end_ifndef

begin_include
include|#
directive|include
file|"Bletch: MUST DEFINE ONE OF 'HAVE_TERMIOS_H' or 'HAVE_TERMIO_H'"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|days_per_year
end_ifndef

begin_define
define|#
directive|define
name|days_per_year
parameter_list|(
name|_x_
parameter_list|)
value|(((_x_) % 4) ? 365 : (((_x_) % 400) ? 365 : 366))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|timernormalize
parameter_list|(
name|_a_
parameter_list|)
define|\
value|if ((_a_)->tv_usec>= 1000000) \ 	{ \ 		(_a_)->tv_sec  += (_a_)->tv_usec / 1000000; \ 		(_a_)->tv_usec  = (_a_)->tv_usec % 1000000; \ 	} \ 	if ((_a_)->tv_usec< 0) \ 	{ \ 		(_a_)->tv_sec  -= 1 + (-(_a_)->tv_usec / 1000000); \ 		(_a_)->tv_usec = 999999 - (-(_a_)->tv_usec - 1); \ 	}
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|timeradd
end_ifdef

begin_undef
undef|#
directive|undef
name|timeradd
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|timeradd
parameter_list|(
name|_a_
parameter_list|,
name|_b_
parameter_list|)
define|\
value|(_a_)->tv_sec  += (_b_)->tv_sec; \ 	(_a_)->tv_usec += (_b_)->tv_usec; \ 	timernormalize((_a_))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|timersub
end_ifdef

begin_undef
undef|#
directive|undef
name|timersub
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|timersub
parameter_list|(
name|_a_
parameter_list|,
name|_b_
parameter_list|)
define|\
value|(_a_)->tv_sec  -= (_b_)->tv_sec; \ 	(_a_)->tv_usec -= (_b_)->tv_usec; \ 	timernormalize((_a_))
end_define

begin_comment
comment|/*  * debug macros  */
end_comment

begin_define
define|#
directive|define
name|PRINTF
value|if (interactive) printf
end_define

begin_define
define|#
directive|define
name|LPRINTF
value|if (interactive&& loop_filter_debug) printf
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|_x_
parameter_list|)
value|LPRINTF _x_
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|_x_
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * display received data (avoids also detaching from tty)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * display loopfilter (clock control) variables  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_filter_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * do not set/adjust system time  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * time that passes between start of DCF impulse and time stamping (fine  * adjustment) in microseconds (receiver/OS dependent)  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_DELAY
value|230000
end_define

begin_comment
comment|/* rough estimate */
end_comment

begin_comment
comment|/*  * The two states we can be in - eithe we receive nothing  * usable or we have the correct time  */
end_comment

begin_define
define|#
directive|define
name|NO_SYNC
value|0x01
end_define

begin_define
define|#
directive|define
name|SYNC
value|0x02
end_define

begin_decl_stmt
specifier|static
name|int
name|sync_state
init|=
name|NO_SYNC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|last_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|ticks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pat
index|[]
init|=
literal|"-\\|/"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINES
value|(24-2)
end_define

begin_comment
comment|/* error lines after which the two headlines are repeated */
end_comment

begin_define
define|#
directive|define
name|MAX_UNSYNC
value|(10*60)
end_define

begin_comment
comment|/* allow synchronisation loss for 10 minutes */
end_comment

begin_define
define|#
directive|define
name|NOTICE_INTERVAL
value|(20*60)
end_define

begin_comment
comment|/* mention missing synchronisation every 20 minutes */
end_comment

begin_comment
comment|/*  * clock adjustment PLL - see NTP protocol spec (RFC1305) for details  */
end_comment

begin_define
define|#
directive|define
name|USECSCALE
value|10
end_define

begin_define
define|#
directive|define
name|TIMECONSTANT
value|2
end_define

begin_define
define|#
directive|define
name|ADJINTERVAL
value|0
end_define

begin_define
define|#
directive|define
name|FREQ_WEIGHT
value|18
end_define

begin_define
define|#
directive|define
name|PHASE_WEIGHT
value|7
end_define

begin_define
define|#
directive|define
name|MAX_DRIFT
value|0x3FFFFFFF
end_define

begin_define
define|#
directive|define
name|R_SHIFT
parameter_list|(
name|_X_
parameter_list|,
name|_Y_
parameter_list|)
value|(((_X_)< 0) ? -(-(_X_)>> (_Y_)) : ((_X_)>> (_Y_)))
end_define

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|max_adj_offset
init|=
block|{
literal|0
block|,
literal|128000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|clock_adjust
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current adjustment value (usec * 2^USECSCALE) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|accum_drift
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated drift value  (usec / ADJINTERVAL) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|adjustments
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|skip_adjust
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard first adjustment (bad samples) */
end_comment

begin_comment
comment|/*  * DCF77 state flags  */
end_comment

begin_define
define|#
directive|define
name|DCFB_ANNOUNCE
value|0x0001
end_define

begin_comment
comment|/* switch time zone warning (DST switch) */
end_comment

begin_define
define|#
directive|define
name|DCFB_DST
value|0x0002
end_define

begin_comment
comment|/* DST in effect */
end_comment

begin_define
define|#
directive|define
name|DCFB_LEAP
value|0x0004
end_define

begin_comment
comment|/* LEAP warning (1 hour prior to occurence) */
end_comment

begin_define
define|#
directive|define
name|DCFB_ALTERNATE
value|0x0008
end_define

begin_comment
comment|/* alternate antenna used */
end_comment

begin_struct
struct|struct
name|clocktime
comment|/* clock time broken up from time code */
block|{
name|long
name|wday
decl_stmt|;
comment|/* Day of week: 1: Monday - 7: Sunday */
name|long
name|day
decl_stmt|;
name|long
name|month
decl_stmt|;
name|long
name|year
decl_stmt|;
name|long
name|hour
decl_stmt|;
name|long
name|minute
decl_stmt|;
name|long
name|second
decl_stmt|;
name|long
name|usecond
decl_stmt|;
name|long
name|utcoffset
decl_stmt|;
comment|/* in minutes */
name|long
name|flags
decl_stmt|;
comment|/* current clock status  (DCF77 state flags) */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|clocktime
name|clocktime_t
typedef|;
end_typedef

begin_comment
comment|/*  * (usually) quick constant multiplications  */
end_comment

begin_define
define|#
directive|define
name|TIMES10
parameter_list|(
name|_X_
parameter_list|)
value|(((_X_)<< 3) + ((_X_)<< 1))
end_define

begin_comment
comment|/* *8 + *2 */
end_comment

begin_define
define|#
directive|define
name|TIMES24
parameter_list|(
name|_X_
parameter_list|)
value|(((_X_)<< 4) + ((_X_)<< 3))
end_define

begin_comment
comment|/* *16 + *8 */
end_comment

begin_define
define|#
directive|define
name|TIMES60
parameter_list|(
name|_X_
parameter_list|)
value|((((_X_)<< 4)  - (_X_))<< 2)
end_define

begin_comment
comment|/* *(16 - 1) *4 */
end_comment

begin_comment
comment|/*  * generic l_abs() function  */
end_comment

begin_define
define|#
directive|define
name|l_abs
parameter_list|(
name|_x_
parameter_list|)
value|(((_x_)< 0) ? -(_x_) : (_x_))
end_define

begin_comment
comment|/*  * conversion related return/error codes  */
end_comment

begin_define
define|#
directive|define
name|CVT_MASK
value|0x0000000F
end_define

begin_comment
comment|/* conversion exit code */
end_comment

begin_define
define|#
directive|define
name|CVT_NONE
value|0x00000001
end_define

begin_comment
comment|/* format not applicable */
end_comment

begin_define
define|#
directive|define
name|CVT_FAIL
value|0x00000002
end_define

begin_comment
comment|/* conversion failed - error code returned */
end_comment

begin_define
define|#
directive|define
name|CVT_OK
value|0x00000004
end_define

begin_comment
comment|/* conversion succeeded */
end_comment

begin_define
define|#
directive|define
name|CVT_BADFMT
value|0x00000010
end_define

begin_comment
comment|/* general format error - (unparsable) */
end_comment

begin_define
define|#
directive|define
name|CVT_BADDATE
value|0x00000020
end_define

begin_comment
comment|/* invalid date */
end_comment

begin_define
define|#
directive|define
name|CVT_BADTIME
value|0x00000040
end_define

begin_comment
comment|/* invalid time */
end_comment

begin_comment
comment|/*  * DCF77 raw time code  *  * From "Zur Zeit", Physikalisch-Technische Bundesanstalt (PTB), Braunschweig  * und Berlin, Maerz 1989  *  * Timecode transmission:  * AM:  *	time marks are send every second except for the second before the  *	next minute mark  *	time marks consist of a reduction of transmitter power to 25%  *	of the nominal level  *	the falling edge is the time indication (on time)  *	time marks of a 100ms duration constitute a logical 0  *	time marks of a 200ms duration constitute a logical 1  * FM:  *	see the spec. (basically a (non-)inverted psuedo random phase shift)  *  * Encoding:  * Second	Contents  * 0  - 10	AM: free, FM: 0  * 11 - 14	free  * 15		R     - alternate antenna  * 16		A1    - expect zone change (1 hour before)  * 17 - 18	Z1,Z2 - time zone  *		 0  0 illegal  *		 0  1 MEZ  (MET)  *		 1  0 MESZ (MED, MET DST)  *		 1  1 illegal  * 19		A2    - expect leap insertion/deletion (1 hour before)  * 20		S     - start of time code (1)  * 21 - 24	M1    - BCD (lsb first) Minutes  * 25 - 27	M10   - BCD (lsb first) 10 Minutes  * 28		P1    - Minute Parity (even)  * 29 - 32	H1    - BCD (lsb first) Hours  * 33 - 34      H10   - BCD (lsb first) 10 Hours  * 35		P2    - Hour Parity (even)  * 36 - 39	D1    - BCD (lsb first) Days  * 40 - 41	D10   - BCD (lsb first) 10 Days  * 42 - 44	DW    - BCD (lsb first) day of week (1: Monday -> 7: Sunday)  * 45 - 49	MO    - BCD (lsb first) Month  * 50           MO0   - 10 Months  * 51 - 53	Y1    - BCD (lsb first) Years  * 54 - 57	Y10   - BCD (lsb first) 10 Years  * 58 		P3    - Date Parity (even)  * 59		      - usually missing (minute indication), except for leap insertion  */
end_comment

begin_comment
comment|/*-----------------------------------------------------------------------  * conversion table to map DCF77 bit stream into data fields.  * Encoding:  *   Each field of the DCF77 code is described with two adjacent entries in  *   this table. The first entry specifies the offset into the DCF77 data stream  *   while the length is given as the difference between the start index and  *   the start index of the following field.  */
end_comment

begin_struct
specifier|static
struct|struct
name|rawdcfcode
block|{
name|char
name|offset
decl_stmt|;
comment|/* start bit */
block|}
name|rawdcfcode
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|15
block|}
block|,
block|{
literal|16
block|}
block|,
block|{
literal|17
block|}
block|,
block|{
literal|19
block|}
block|,
block|{
literal|20
block|}
block|,
block|{
literal|21
block|}
block|,
block|{
literal|25
block|}
block|,
block|{
literal|28
block|}
block|,
block|{
literal|29
block|}
block|,
block|{
literal|33
block|}
block|,
block|{
literal|35
block|}
block|,
block|{
literal|36
block|}
block|,
block|{
literal|40
block|}
block|,
block|{
literal|42
block|}
block|,
block|{
literal|45
block|}
block|,
block|{
literal|49
block|}
block|,
block|{
literal|50
block|}
block|,
block|{
literal|54
block|}
block|,
block|{
literal|58
block|}
block|,
block|{
literal|59
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*-----------------------------------------------------------------------  * symbolic names for the fields of DCF77 describes in "rawdcfcode".  * see comment above for the structure of the DCF77 data  */
end_comment

begin_define
define|#
directive|define
name|DCF_M
value|0
end_define

begin_define
define|#
directive|define
name|DCF_R
value|1
end_define

begin_define
define|#
directive|define
name|DCF_A1
value|2
end_define

begin_define
define|#
directive|define
name|DCF_Z
value|3
end_define

begin_define
define|#
directive|define
name|DCF_A2
value|4
end_define

begin_define
define|#
directive|define
name|DCF_S
value|5
end_define

begin_define
define|#
directive|define
name|DCF_M1
value|6
end_define

begin_define
define|#
directive|define
name|DCF_M10
value|7
end_define

begin_define
define|#
directive|define
name|DCF_P1
value|8
end_define

begin_define
define|#
directive|define
name|DCF_H1
value|9
end_define

begin_define
define|#
directive|define
name|DCF_H10
value|10
end_define

begin_define
define|#
directive|define
name|DCF_P2
value|11
end_define

begin_define
define|#
directive|define
name|DCF_D1
value|12
end_define

begin_define
define|#
directive|define
name|DCF_D10
value|13
end_define

begin_define
define|#
directive|define
name|DCF_DW
value|14
end_define

begin_define
define|#
directive|define
name|DCF_MO
value|15
end_define

begin_define
define|#
directive|define
name|DCF_MO0
value|16
end_define

begin_define
define|#
directive|define
name|DCF_Y1
value|17
end_define

begin_define
define|#
directive|define
name|DCF_Y10
value|18
end_define

begin_define
define|#
directive|define
name|DCF_P3
value|19
end_define

begin_comment
comment|/*-----------------------------------------------------------------------  * parity field table (same encoding as rawdcfcode)  * This table describes the sections of the DCF77 code that are  * parity protected  */
end_comment

begin_struct
specifier|static
struct|struct
name|partab
block|{
name|char
name|offset
decl_stmt|;
comment|/* start bit of parity field */
block|}
name|partab
index|[]
init|=
block|{
block|{
literal|21
block|}
block|,
block|{
literal|29
block|}
block|,
block|{
literal|36
block|}
block|,
block|{
literal|59
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*-----------------------------------------------------------------------  * offsets for parity field descriptions  */
end_comment

begin_define
define|#
directive|define
name|DCF_P_P1
value|0
end_define

begin_define
define|#
directive|define
name|DCF_P_P2
value|1
end_define

begin_define
define|#
directive|define
name|DCF_P_P3
value|2
end_define

begin_comment
comment|/*-----------------------------------------------------------------------  * legal values for time zone information  */
end_comment

begin_define
define|#
directive|define
name|DCF_Z_MET
value|0x2
end_define

begin_define
define|#
directive|define
name|DCF_Z_MED
value|0x1
end_define

begin_comment
comment|/*-----------------------------------------------------------------------  * symbolic representation if the DCF77 data stream  */
end_comment

begin_struct
specifier|static
struct|struct
name|dcfparam
block|{
name|unsigned
name|char
name|onebits
index|[
literal|60
index|]
decl_stmt|;
name|unsigned
name|char
name|zerobits
index|[
literal|60
index|]
decl_stmt|;
block|}
name|dcfparam
init|=
block|{
literal|"###############RADMLS1248124P124812P1248121241248112481248P"
block|,
comment|/* 'ONE' representation */
literal|"--------------------s-------p------p----------------------p"
comment|/* 'ZERO' representation */
block|}
struct|;
end_struct

begin_comment
comment|/*-----------------------------------------------------------------------  * extract a bitfield from DCF77 datastream  * All numeric fields are LSB first.  * buf holds a pointer to a DCF77 data buffer in symbolic  *     representation  * idx holds the index to the field description in rawdcfcode  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ext_bf
parameter_list|(
specifier|register
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
specifier|register
name|int
name|idx
parameter_list|)
block|{
specifier|register
name|unsigned
name|long
name|sum
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
name|first
operator|=
name|rawdcfcode
index|[
name|idx
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rawdcfcode
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|offset
operator|-
literal|1
init|;
name|i
operator|>=
name|first
condition|;
name|i
operator|--
control|)
block|{
name|sum
operator|<<=
literal|1
expr_stmt|;
name|sum
operator||=
operator|(
name|buf
index|[
name|i
index|]
operator|!=
name|dcfparam
operator|.
name|zerobits
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * check even parity integrity for a bitfield  *  * buf holds a pointer to a DCF77 data buffer in symbolic  *     representation  * idx holds the index to the field description in partab  */
end_comment

begin_function
specifier|static
name|unsigned
name|pcheck
parameter_list|(
specifier|register
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
specifier|register
name|int
name|idx
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|last
decl_stmt|;
specifier|register
name|unsigned
name|psum
init|=
literal|1
decl_stmt|;
name|last
operator|=
name|partab
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|partab
index|[
name|idx
index|]
operator|.
name|offset
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
name|psum
operator|^=
operator|(
name|buf
index|[
name|i
index|]
operator|!=
name|dcfparam
operator|.
name|zerobits
index|[
name|i
index|]
operator|)
expr_stmt|;
return|return
name|psum
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * convert a DCF77 data buffer into wall clock time + flags  *  * buffer holds a pointer to a DCF77 data buffer in symbolic  *        representation  * size   describes the length of DCF77 information in bits (represented  *        as chars in symbolic notation  * clock  points to a wall clock time description of the DCF77 data (result)  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|convert_rawdcf
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
literal|57
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%-30s"
argument_list|,
literal|"*** INCOMPLETE"
argument_list|)
expr_stmt|;
return|return
name|CVT_NONE
return|;
block|}
comment|/* 	 * check Start and Parity bits 	 */
if|if
condition|(
operator|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_S
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P1
argument_list|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P2
argument_list|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P3
argument_list|)
condition|)
block|{
comment|/* 		 * buffer OK - extract all fields and build wall clock time from them 		 */
name|clock_time
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|usecond
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|second
operator|=
literal|0
expr_stmt|;
name|clock_time
operator|->
name|minute
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_M10
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|minute
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|minute
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_M1
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|hour
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_H10
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|hour
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|hour
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_H1
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|day
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_D10
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|day
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|day
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_D1
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|month
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_MO0
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|month
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|month
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_MO
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|year
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Y10
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|year
operator|=
name|TIMES10
argument_list|(
name|clock_time
operator|->
name|year
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Y1
argument_list|)
expr_stmt|;
name|clock_time
operator|->
name|wday
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_DW
argument_list|)
expr_stmt|;
comment|/* 		 * determine offset to UTC by examining the time zone 		 */
switch|switch
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Z
argument_list|)
condition|)
block|{
case|case
name|DCF_Z_MET
case|:
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
literal|60
expr_stmt|;
break|break;
case|case
name|DCF_Z_MED
case|:
name|clock_time
operator|->
name|flags
operator||=
name|DCFB_DST
expr_stmt|;
name|clock_time
operator|->
name|utcoffset
operator|=
operator|-
literal|120
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%-30s"
argument_list|,
literal|"*** BAD TIME ZONE"
argument_list|)
expr_stmt|;
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
comment|/* 		 * extract various warnings from DCF77 		 */
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_A1
argument_list|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|DCFB_ANNOUNCE
expr_stmt|;
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_A2
argument_list|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|DCFB_LEAP
expr_stmt|;
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_R
argument_list|)
condition|)
name|clock_time
operator|->
name|flags
operator||=
name|DCFB_ALTERNATE
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
else|else
block|{
comment|/* 		 * bad format - not for us 		 */
name|PRINTF
argument_list|(
literal|"%-30s"
argument_list|,
literal|"*** BAD FORMAT (invalid/parity)"
argument_list|)
expr_stmt|;
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * raw dcf input routine - fix up 50 baud  * characters for 1/0 decision  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|cvt_rawdcf
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|clocktime_t
modifier|*
name|clock_time
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
init|=
name|buffer
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|e
init|=
name|buffer
operator|+
name|size
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|b
init|=
name|dcfparam
operator|.
name|onebits
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|c
init|=
name|dcfparam
operator|.
name|zerobits
decl_stmt|;
specifier|register
name|unsigned
name|rtc
init|=
name|CVT_NONE
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
name|lowmax
decl_stmt|,
name|highmax
decl_stmt|,
name|cutoff
decl_stmt|,
name|span
decl_stmt|;
define|#
directive|define
name|BITS
value|9
name|unsigned
name|char
name|histbuf
index|[
name|BITS
index|]
decl_stmt|;
comment|/* 	 * the input buffer contains characters with runs of consecutive 	 * bits set. These set bits are an indication of the DCF77 pulse 	 * length. We assume that we receive the pulse at 50 Baud. Thus 	 * a 100ms pulse would generate a 4 bit train (20ms per bit and 	 * start bit) 	 * a 200ms pulse would create all zeroes (and probably a frame error) 	 * 	 * The basic idea is that on corret reception we must have two 	 * maxima in the pulse length distribution histogram. (one for 	 * the zero representing pulses and one for the one representing 	 * pulses) 	 * There will always be ones in the datastream, thus we have to see 	 * two maxima. 	 * The best point to cut for a 1/0 decision is the minimum between those 	 * between the maxima. The following code tries to find this cutoff point. 	 */
comment|/* 	 * clear histogram buffer 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BITS
condition|;
name|i
operator|++
control|)
block|{
name|histbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|cutoff
operator|=
literal|0
expr_stmt|;
name|lowmax
operator|=
literal|0
expr_stmt|;
comment|/* 	 * convert sequences of set bits into bits counts updating 	 * the histogram alongway 	 */
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
specifier|register
name|unsigned
name|int
name|ch
init|=
operator|*
name|s
operator|^
literal|0xFF
decl_stmt|;
comment|/* 		 * check integrity and update histogramm 		 */
if|if
condition|(
operator|!
operator|(
operator|(
name|ch
operator|+
literal|1
operator|)
operator|&
name|ch
operator|)
operator|||
operator|!
operator|*
name|s
condition|)
block|{
comment|/* 			 * character ok 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|i
expr_stmt|;
name|histbuf
index|[
name|i
index|]
operator|++
expr_stmt|;
name|cutoff
operator|+=
name|i
expr_stmt|;
name|lowmax
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * invalid character (no consecutive bit sequence) 			 */
name|dprintf
argument_list|(
operator|(
literal|"parse: cvt_rawdcf: character check for 0x%x@%d FAILED\n"
operator|,
operator|*
name|s
operator|,
name|s
operator|-
name|buffer
operator|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0
expr_stmt|;
name|rtc
operator|=
name|CVT_FAIL
operator||
name|CVT_BADFMT
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
comment|/* 	 * first cutoff estimate (average bit count - must be between both 	 * maxima) 	 */
if|if
condition|(
name|lowmax
condition|)
block|{
name|cutoff
operator|/=
name|lowmax
expr_stmt|;
block|}
else|else
block|{
name|cutoff
operator|=
literal|4
expr_stmt|;
comment|/* doesn't really matter - it'll fail anyway, but gives error output */
block|}
name|dprintf
argument_list|(
operator|(
literal|"parse: cvt_rawdcf: average bit count: %d\n"
operator|,
name|cutoff
operator|)
argument_list|)
expr_stmt|;
name|lowmax
operator|=
literal|0
expr_stmt|;
comment|/* weighted sum */
name|highmax
operator|=
literal|0
expr_stmt|;
comment|/* bitcount */
comment|/* 	 * collect weighted sum of lower bits (left of initial guess) 	 */
name|dprintf
argument_list|(
operator|(
literal|"parse: cvt_rawdcf: histogram:"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cutoff
condition|;
name|i
operator|++
control|)
block|{
name|lowmax
operator|+=
name|histbuf
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|highmax
operator|+=
name|histbuf
index|[
name|i
index|]
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|" %d"
operator|,
name|histbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"<M>"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * round up 	 */
name|lowmax
operator|+=
name|highmax
operator|/
literal|2
expr_stmt|;
comment|/* 	 * calculate lower bit maximum (weighted sum / bit count) 	 * 	 * avoid divide by zero 	 */
if|if
condition|(
name|highmax
condition|)
block|{
name|lowmax
operator|/=
name|highmax
expr_stmt|;
block|}
else|else
block|{
name|lowmax
operator|=
literal|0
expr_stmt|;
block|}
name|highmax
operator|=
literal|0
expr_stmt|;
comment|/* weighted sum of upper bits counts */
name|cutoff
operator|=
literal|0
expr_stmt|;
comment|/* bitcount */
comment|/* 	 * collect weighted sum of lower bits (right of initial guess) 	 */
for|for
control|(
init|;
name|i
operator|<
name|BITS
condition|;
name|i
operator|++
control|)
block|{
name|highmax
operator|+=
name|histbuf
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|cutoff
operator|+=
name|histbuf
index|[
name|i
index|]
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|" %d"
operator|,
name|histbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * determine upper maximum (weighted sum / bit count) 	 */
if|if
condition|(
name|cutoff
condition|)
block|{
name|highmax
operator|/=
name|cutoff
expr_stmt|;
block|}
else|else
block|{
name|highmax
operator|=
name|BITS
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * following now holds: 	 * lowmax<= cutoff(initial guess)<= highmax 	 * best cutoff is the minimum nearest to higher bits 	 */
comment|/* 	 * find the minimum between lowmax and highmax (detecting 	 * possibly a minimum span) 	 */
name|span
operator|=
name|cutoff
operator|=
name|lowmax
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lowmax
init|;
name|i
operator|<=
name|highmax
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|histbuf
index|[
name|cutoff
index|]
operator|>
name|histbuf
index|[
name|i
index|]
condition|)
block|{
comment|/* 			 * got a new minimum move beginning of minimum (cutoff) and 			 * end of minimum (span) there 			 */
name|cutoff
operator|=
name|span
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|histbuf
index|[
name|cutoff
index|]
operator|==
name|histbuf
index|[
name|i
index|]
condition|)
block|{
comment|/* 			     * minimum not better yet - but it spans more than 			     * one bit value - follow it 			     */
name|span
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * cutoff point for 1/0 decision is the middle of the minimum section 	 * in the histogram 	 */
name|cutoff
operator|=
operator|(
name|cutoff
operator|+
name|span
operator|)
operator|/
literal|2
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"parse: cvt_rawdcf: lower maximum %d, higher maximum %d, cutoff %d\n"
operator|,
name|lowmax
operator|,
name|highmax
operator|,
name|cutoff
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * convert the bit counts to symbolic 1/0 information for data conversion 	 */
name|s
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|<
name|e
operator|)
operator|&&
operator|*
name|c
operator|&&
operator|*
name|b
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0
condition|)
block|{
comment|/* 			 * invalid character 			 */
operator|*
name|s
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * symbolic 1/0 representation 			 */
operator|*
name|s
operator|=
operator|(
operator|*
name|s
operator|>=
name|cutoff
operator|)
condition|?
operator|*
name|b
else|:
operator|*
name|c
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
comment|/* 	 * if everything went well so far return the result of the symbolic 	 * conversion routine else just the accumulated errors 	 */
if|if
condition|(
name|rtc
operator|!=
name|CVT_NONE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%-30s"
argument_list|,
literal|"*** BAD DATA"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rtc
operator|==
name|CVT_NONE
operator|)
condition|?
name|convert_rawdcf
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
name|clock_time
argument_list|)
else|:
name|rtc
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * convert a wall clock time description of DCF77 to a Unix time (seconds  * since 1.1. 1970 UTC)  */
end_comment

begin_function
name|time_t
name|dcf_to_unixtime
parameter_list|(
name|clocktime_t
modifier|*
name|clock_time
parameter_list|,
name|unsigned
modifier|*
name|cvtrtc
parameter_list|)
block|{
define|#
directive|define
name|SETRTC
parameter_list|(
name|_X_
parameter_list|)
value|{ if (cvtrtc) *cvtrtc = (_X_); }
specifier|static
name|int
name|days_of_month
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|time_t
name|t
decl_stmt|;
comment|/* 	 * map 2 digit years to 19xx (DCF77 is a 20th century item) 	 */
if|if
condition|(
name|clock_time
operator|->
name|year
operator|<
name|YEAR_PIVOT
condition|)
comment|/* in case of	   Y2KFixes [ */
name|clock_time
operator|->
name|year
operator|+=
literal|100
expr_stmt|;
comment|/* *year%100, make tm_year */
comment|/* *(do we need this?) */
if|if
condition|(
name|clock_time
operator|->
name|year
operator|<
name|YEAR_BREAK
condition|)
comment|/* (failsafe if) */
name|clock_time
operator|->
name|year
operator|+=
literal|1900
expr_stmt|;
comment|/* Y2KFixes ] */
comment|/* 	 * must have been a really bad year code - drop it 	 */
if|if
condition|(
name|clock_time
operator|->
name|year
operator|<
operator|(
name|YEAR_PIVOT
operator|+
literal|1900
operator|)
condition|)
comment|/* Y2KFixes */
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * sorry, slow section here - but it's not time critical anyway 	 */
comment|/* 	 * calculate days since 1970 (watching leap years) 	 */
name|t
operator|=
name|julian0
argument_list|(
name|clock_time
operator|->
name|year
argument_list|)
operator|-
name|julian0
argument_list|(
literal|1970
argument_list|)
expr_stmt|;
comment|/* month */
if|if
condition|(
name|clock_time
operator|->
name|month
operator|<=
literal|0
operator|||
name|clock_time
operator|->
name|month
operator|>
literal|12
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad month */
block|}
comment|/* adjust current leap year */
if|#
directive|if
literal|0
block|if (clock_time->month< 3&& days_per_year(clock_time->year) == 366) 	    t--;
endif|#
directive|endif
comment|/* 	 * collect days from months excluding the current one 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|clock_time
operator|->
name|month
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|+=
name|days_of_month
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* day */
if|if
condition|(
name|clock_time
operator|->
name|day
operator|<
literal|1
operator|||
operator|(
operator|(
name|clock_time
operator|->
name|month
operator|==
literal|2
operator|&&
name|days_per_year
argument_list|(
name|clock_time
operator|->
name|year
argument_list|)
operator|==
literal|366
operator|)
condition|?
name|clock_time
operator|->
name|day
operator|>
literal|29
else|:
name|clock_time
operator|->
name|day
operator|>
name|days_of_month
index|[
name|clock_time
operator|->
name|month
index|]
operator|)
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad day */
block|}
comment|/* 	 * collect days from date excluding the current one 	 */
name|t
operator|+=
name|clock_time
operator|->
name|day
operator|-
literal|1
expr_stmt|;
comment|/* hour */
if|if
condition|(
name|clock_time
operator|->
name|hour
operator|<
literal|0
operator|||
name|clock_time
operator|->
name|hour
operator|>=
literal|24
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad hour */
block|}
comment|/* 	 * calculate hours from 1. 1. 1970 	 */
name|t
operator|=
name|TIMES24
argument_list|(
name|t
argument_list|)
operator|+
name|clock_time
operator|->
name|hour
expr_stmt|;
comment|/* min */
if|if
condition|(
name|clock_time
operator|->
name|minute
operator|<
literal|0
operator|||
name|clock_time
operator|->
name|minute
operator|>
literal|59
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad min */
block|}
comment|/* 	 * calculate minutes from 1. 1. 1970 	 */
name|t
operator|=
name|TIMES60
argument_list|(
name|t
argument_list|)
operator|+
name|clock_time
operator|->
name|minute
expr_stmt|;
comment|/* sec */
comment|/* 	 * calculate UTC in minutes 	 */
name|t
operator|+=
name|clock_time
operator|->
name|utcoffset
expr_stmt|;
if|if
condition|(
name|clock_time
operator|->
name|second
operator|<
literal|0
operator|||
name|clock_time
operator|->
name|second
operator|>
literal|60
condition|)
comment|/* allow for LEAPs */
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad sec */
block|}
comment|/* 	 * calculate UTC in seconds - phew ! 	 */
name|t
operator|=
name|TIMES60
argument_list|(
name|t
argument_list|)
operator|+
name|clock_time
operator|->
name|second
expr_stmt|;
comment|/* done */
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * cheap half baked 1/0 decision - for interactive operation only  */
end_comment

begin_function
specifier|static
name|char
name|type
parameter_list|(
name|unsigned
name|int
name|c
parameter_list|)
block|{
name|c
operator|^=
literal|0xFF
expr_stmt|;
return|return
operator|(
name|c
operator|>
literal|0xF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * week day representation  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|wday
index|[
literal|8
index|]
init|=
block|{
literal|"??"
block|,
literal|"Mo"
block|,
literal|"Tu"
block|,
literal|"We"
block|,
literal|"Th"
block|,
literal|"Fr"
block|,
literal|"Sa"
block|,
literal|"Su"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-----------------------------------------------------------------------  * generate a string representation for a timeval  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|pr_timeval
parameter_list|(
name|struct
name|timeval
modifier|*
name|val
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|val
operator|->
name|tv_sec
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%c0.%06ld"
argument_list|,
operator|(
name|val
operator|->
name|tv_usec
operator|<
literal|0
operator|)
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
operator|(
name|long
name|int
operator|)
name|l_abs
argument_list|(
name|val
operator|->
name|tv_usec
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld.%06ld"
argument_list|,
operator|(
name|long
name|int
operator|)
name|val
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
name|int
operator|)
name|l_abs
argument_list|(
name|val
operator|->
name|tv_usec
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * correct the current time by an offset by setting the time rigorously  */
end_comment

begin_function
specifier|static
name|void
name|set_time
parameter_list|(
name|struct
name|timeval
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|timeval
name|the_time
decl_stmt|;
if|if
condition|(
name|no_set
condition|)
return|return;
name|LPRINTF
argument_list|(
literal|"set_time: %s "
argument_list|,
name|pr_timeval
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"setting time (offset %s)"
argument_list|,
name|pr_timeval
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|the_time
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"gettimeofday()"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timeradd
argument_list|(
operator|&
name|the_time
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|settimeofday
argument_list|(
operator|&
name|the_time
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"settimeofday()"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * slew the time by a given offset  */
end_comment

begin_function
specifier|static
name|void
name|adj_time
parameter_list|(
name|long
name|offset
parameter_list|)
block|{
name|struct
name|timeval
name|time_offset
decl_stmt|;
if|if
condition|(
name|no_set
condition|)
return|return;
name|time_offset
operator|.
name|tv_sec
operator|=
name|offset
operator|/
literal|1000000
expr_stmt|;
name|time_offset
operator|.
name|tv_usec
operator|=
name|offset
operator|%
literal|1000000
expr_stmt|;
name|LPRINTF
argument_list|(
literal|"adj_time: %ld us "
argument_list|,
operator|(
name|long
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjtime
argument_list|(
operator|&
name|time_offset
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"adjtime()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * read in a possibly previously written drift value  */
end_comment

begin_function
specifier|static
name|void
name|read_drift
parameter_list|(
specifier|const
name|char
modifier|*
name|drift_file
parameter_list|)
block|{
name|FILE
modifier|*
name|df
decl_stmt|;
name|df
operator|=
name|fopen
argument_list|(
name|drift_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|!=
name|NULL
condition|)
block|{
name|int
name|idrift
init|=
literal|0
decl_stmt|,
name|fdrift
init|=
literal|0
decl_stmt|;
name|fscanf
argument_list|(
name|df
argument_list|,
literal|"%4d.%03d"
argument_list|,
operator|&
name|idrift
argument_list|,
operator|&
name|fdrift
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|LPRINTF
argument_list|(
literal|"read_drift: %d.%03d ppm "
argument_list|,
name|idrift
argument_list|,
name|fdrift
argument_list|)
expr_stmt|;
name|accum_drift
operator|=
name|idrift
operator|<<
name|USECSCALE
expr_stmt|;
name|fdrift
operator|=
operator|(
name|fdrift
operator|<<
name|USECSCALE
operator|)
operator|/
literal|1000
expr_stmt|;
name|accum_drift
operator|+=
name|fdrift
operator|&
operator|(
literal|1
operator|<<
name|USECSCALE
operator|)
expr_stmt|;
name|LPRINTF
argument_list|(
literal|"read_drift: drift_comp %ld "
argument_list|,
operator|(
name|long
name|int
operator|)
name|accum_drift
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * write out the current drift value  */
end_comment

begin_function
specifier|static
name|void
name|update_drift
parameter_list|(
specifier|const
name|char
modifier|*
name|drift_file
parameter_list|,
name|long
name|offset
parameter_list|,
name|time_t
name|reftime
parameter_list|)
block|{
name|FILE
modifier|*
name|df
decl_stmt|;
name|df
operator|=
name|fopen
argument_list|(
name|drift_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|!=
name|NULL
condition|)
block|{
name|int
name|idrift
init|=
name|R_SHIFT
argument_list|(
name|accum_drift
argument_list|,
name|USECSCALE
argument_list|)
decl_stmt|;
name|int
name|fdrift
init|=
name|accum_drift
operator|&
operator|(
operator|(
literal|1
operator|<<
name|USECSCALE
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|LPRINTF
argument_list|(
literal|"update_drift: drift_comp %ld "
argument_list|,
operator|(
name|long
name|int
operator|)
name|accum_drift
argument_list|)
expr_stmt|;
name|fdrift
operator|=
operator|(
name|fdrift
operator|*
literal|1000
operator|)
operator|/
operator|(
literal|1
operator|<<
name|USECSCALE
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%4d.%03d %c%ld.%06ld %.24s\n"
argument_list|,
name|idrift
argument_list|,
name|fdrift
argument_list|,
operator|(
name|offset
operator|<
literal|0
operator|)
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|l_abs
argument_list|(
name|offset
argument_list|)
operator|/
literal|1000000
argument_list|)
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|l_abs
argument_list|(
name|offset
argument_list|)
operator|%
literal|1000000
argument_list|)
argument_list|,
name|asctime
argument_list|(
name|localtime
argument_list|(
operator|&
name|reftime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|LPRINTF
argument_list|(
literal|"update_drift: %d.%03d ppm "
argument_list|,
name|idrift
argument_list|,
name|fdrift
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * process adjustments derived from the DCF77 observation  * (controls clock PLL)  */
end_comment

begin_function
specifier|static
name|void
name|adjust_clock
parameter_list|(
name|struct
name|timeval
modifier|*
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
name|drift_file
parameter_list|,
name|time_t
name|reftime
parameter_list|)
block|{
name|struct
name|timeval
name|toffset
decl_stmt|;
specifier|register
name|long
name|usecoffset
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|no_set
condition|)
return|return;
if|if
condition|(
name|skip_adjust
condition|)
block|{
name|skip_adjust
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|toffset
operator|=
operator|*
name|offset
expr_stmt|;
name|toffset
operator|.
name|tv_sec
operator|=
name|l_abs
argument_list|(
name|toffset
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|toffset
operator|.
name|tv_usec
operator|=
name|l_abs
argument_list|(
name|toffset
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|toffset
argument_list|,
operator|&
name|max_adj_offset
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* 		 * hopeless - set the clock - and clear the timing 		 */
name|set_time
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|clock_adjust
operator|=
literal|0
expr_stmt|;
name|skip_adjust
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|usecoffset
operator|=
name|offset
operator|->
name|tv_sec
operator|*
literal|1000000
operator|+
name|offset
operator|->
name|tv_usec
expr_stmt|;
name|clock_adjust
operator|=
name|R_SHIFT
argument_list|(
name|usecoffset
argument_list|,
name|TIMECONSTANT
argument_list|)
expr_stmt|;
comment|/* adjustment to make for next period */
name|tmp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|adjustments
operator|>
operator|(
literal|1
operator|<<
name|tmp
operator|)
condition|)
name|tmp
operator|++
expr_stmt|;
name|adjustments
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|FREQ_WEIGHT
condition|)
name|tmp
operator|=
name|FREQ_WEIGHT
expr_stmt|;
name|accum_drift
operator|+=
name|R_SHIFT
argument_list|(
name|usecoffset
operator|<<
name|USECSCALE
argument_list|,
name|TIMECONSTANT
operator|+
name|TIMECONSTANT
operator|+
name|FREQ_WEIGHT
operator|-
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|accum_drift
operator|>
name|MAX_DRIFT
condition|)
comment|/* clamp into interval */
name|accum_drift
operator|=
name|MAX_DRIFT
expr_stmt|;
elseif|else
if|if
condition|(
name|accum_drift
operator|<
operator|-
name|MAX_DRIFT
condition|)
name|accum_drift
operator|=
operator|-
name|MAX_DRIFT
expr_stmt|;
name|update_drift
argument_list|(
name|drift_file
argument_list|,
name|usecoffset
argument_list|,
name|reftime
argument_list|)
expr_stmt|;
name|LPRINTF
argument_list|(
literal|"clock_adjust: %s, clock_adjust %ld, drift_comp %ld(%ld) "
argument_list|,
name|pr_timeval
argument_list|(
name|offset
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|R_SHIFT
argument_list|(
name|clock_adjust
argument_list|,
name|USECSCALE
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|R_SHIFT
argument_list|(
name|accum_drift
argument_list|,
name|USECSCALE
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|accum_drift
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * adjust the clock by a small mount to simulate frequency correction  */
end_comment

begin_function
specifier|static
name|void
name|periodic_adjust
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|long
name|adjustment
decl_stmt|;
name|adjustments
operator|++
expr_stmt|;
name|adjustment
operator|=
name|R_SHIFT
argument_list|(
name|clock_adjust
argument_list|,
name|PHASE_WEIGHT
argument_list|)
expr_stmt|;
name|clock_adjust
operator|-=
name|adjustment
expr_stmt|;
name|adjustment
operator|+=
name|R_SHIFT
argument_list|(
name|accum_drift
argument_list|,
name|USECSCALE
operator|+
name|ADJINTERVAL
argument_list|)
expr_stmt|;
name|adj_time
argument_list|(
name|adjustment
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * control synchronisation status (warnings) and do periodic adjusts  * (frequency control simulation)  */
end_comment

begin_function
specifier|static
name|void
name|tick
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|unsigned
name|long
name|last_notice
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SIGACTION
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_SIGVEC
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|periodic_adjust
argument_list|()
expr_stmt|;
name|ticks
operator|+=
literal|1
operator|<<
name|ADJINTERVAL
expr_stmt|;
if|if
condition|(
operator|(
name|ticks
operator|-
name|last_sync
operator|)
operator|>
name|MAX_UNSYNC
condition|)
block|{
comment|/* 		 * not getting time for a while 		 */
if|if
condition|(
name|sync_state
operator|==
name|SYNC
condition|)
block|{
comment|/* 			 * completely lost information 			 */
name|sync_state
operator|=
name|NO_SYNC
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DCF77 reception lost (timeout)"
argument_list|)
expr_stmt|;
name|last_notice
operator|=
name|ticks
expr_stmt|;
block|}
elseif|else
comment|/* 		     * in NO_SYNC state - look whether its time to speak up again 		     */
if|if
condition|(
operator|(
name|ticks
operator|-
name|last_notice
operator|)
operator|>
name|NOTICE_INTERVAL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"still not synchronized to DCF77 - check receiver/signal"
argument_list|)
expr_stmt|;
name|last_notice
operator|=
name|ticks
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|ITIMER_REAL
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|1
operator|<<
name|ADJINTERVAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * break association from terminal to avoid catching terminal  * or process group related signals (-> daemon operation)  */
end_comment

begin_function
specifier|static
name|void
name|detach
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_DAEMON
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_DAEMON */
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|{
name|u_long
name|s
decl_stmt|;
name|int
name|max_fd
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
name|max_fd
operator|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_SYSCONF&& _SC_OPEN_MAX */
name|max_fd
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SYSCONF&& _SC_OPEN_MAX */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|max_fd
condition|;
name|s
operator|++
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
operator|(
name|int
operator|)
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_DOMAINOS
block|{
name|uid_$t
name|puid
decl_stmt|;
name|status_$t
name|st
decl_stmt|;
name|proc2_$who_am_i
argument_list|(
operator|&
name|puid
argument_list|)
expr_stmt|;
name|proc2_$make_server
argument_list|(
operator|&
name|puid
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_DOMAINOS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETPGID
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SETSID
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_SETSID
if|if
condition|(
name|setsid
argument_list|()
operator|==
operator|(
name|pid_t
operator|)
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dcfd: setsid(): %m"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|setpgid
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dcfd: setpgid(): %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* HAVE_SETPGID || HAVE_SETSID */
block|{
name|int
name|fid
decl_stmt|;
name|fid
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fid
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fid
argument_list|,
operator|(
name|u_long
operator|)
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fid
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_SETPGRP_0
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* HAVE_SETPGRP_0 */
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SETPGRP_0 */
block|}
endif|#
directive|endif
comment|/* HAVE_SETPGID || HAVE_SETSID */
block|}
endif|#
directive|endif
comment|/* not HAVE_DAEMON */
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * list possible arguments and options  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|char
modifier|*
name|program
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-n] [-f] [-l] [-t] [-i] [-o] [-d<drift_file>] [-D<input delay>]<device>\n"
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-n              do not change time\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-i              interactive\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-t              trace (print all datagrams)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-f              print all databits (includes PTB private data)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-l              print loop filter debug information\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-o              print offet average for current minute\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-Y              make internal Y2K checks then exit\n"
argument_list|)
expr_stmt|;
comment|/* Y2KFixes */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-d<drift_file> specify alternate drift file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-D<input delay>specify delay from input edge to processing in micro seconds\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * check_y2k() - internal check of Y2K logic  *	(a lot of this logic lifted from ../ntpd/check_y2k.c)  */
end_comment

begin_function
name|int
name|check_y2k
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|year
decl_stmt|;
comment|/* current working year */
name|int
name|year0
init|=
literal|1900
decl_stmt|;
comment|/* sarting year for NTP time */
name|int
name|yearend
decl_stmt|;
comment|/* ending year we test for NTP time. 				    * 32-bit systems: through 2036, the 				      **year in which NTP time overflows. 				    * 64-bit systems: a reasonable upper 				      **limit (well, maybe somewhat beyond 				      **reasonable, but well before the 				      **max time, by which time the earth 				      **will be dead.) */
name|time_t
name|Time
decl_stmt|;
name|struct
name|tm
name|LocalTime
decl_stmt|;
name|int
name|Fatals
decl_stmt|,
name|Warnings
decl_stmt|;
define|#
directive|define
name|Error
parameter_list|(
name|year
parameter_list|)
value|if ( (year)>=2036&& LocalTime.tm_year< 110 ) \ 	Warnings++; else Fatals++
name|Fatals
operator|=
name|Warnings
operator|=
literal|0
expr_stmt|;
name|Time
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|LocalTime
operator|=
operator|*
name|localtime
argument_list|(
operator|&
name|Time
argument_list|)
expr_stmt|;
name|year
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|>
literal|4
operator|)
comment|/* save max span using year as temp */
condition|?
operator|(
literal|400
operator|*
literal|3
operator|)
comment|/* three greater gregorian cycles */
else|:
operator|(
call|(
name|int
call|)
argument_list|(
literal|0x7FFFFFFF
operator|/
literal|365.242
operator|/
literal|24
operator|/
literal|60
operator|/
literal|60
argument_list|)
operator|*
literal|2
operator|)
expr_stmt|;
comment|/*32-bit limit*/
comment|/* NOTE: will automacially expand test years on 			 * 64 bit machines.... this may cause some of the 			 * existing ntp logic to fail for years beyond 			 * 2036 (the current 32-bit limit). If all checks 			 * fail ONLY beyond year 2036 you may ignore such 			 * errors, at least for a decade or so. */
name|yearend
operator|=
name|year0
operator|+
name|year
expr_stmt|;
name|year
operator|=
literal|1900
operator|+
name|YEAR_PIVOT
expr_stmt|;
name|printf
argument_list|(
literal|"  starting year %04d\n"
argument_list|,
operator|(
name|int
operator|)
name|year
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ending year   %04d\n"
argument_list|,
operator|(
name|int
operator|)
name|yearend
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|year
operator|<
name|yearend
condition|;
name|year
operator|++
control|)
block|{
name|clocktime_t
name|ct
decl_stmt|;
name|time_t
name|Observed
decl_stmt|;
name|time_t
name|Expected
decl_stmt|;
name|unsigned
name|Flag
decl_stmt|;
name|unsigned
name|long
name|t
decl_stmt|;
name|ct
operator|.
name|day
operator|=
literal|1
expr_stmt|;
name|ct
operator|.
name|month
operator|=
literal|1
expr_stmt|;
name|ct
operator|.
name|year
operator|=
name|year
expr_stmt|;
name|ct
operator|.
name|hour
operator|=
name|ct
operator|.
name|minute
operator|=
name|ct
operator|.
name|second
operator|=
name|ct
operator|.
name|usecond
operator|=
literal|0
expr_stmt|;
name|ct
operator|.
name|utcoffset
operator|=
literal|0
expr_stmt|;
name|ct
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|Flag
operator|=
literal|0
expr_stmt|;
name|Observed
operator|=
name|dcf_to_unixtime
argument_list|(
operator|&
name|ct
argument_list|,
operator|&
name|Flag
argument_list|)
expr_stmt|;
comment|/* seems to be a clone of parse_to_unixtime() with 		 * *a minor difference to arg2 type */
if|if
condition|(
name|ct
operator|.
name|year
operator|!=
name|year
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%04d: dcf_to_unixtime(,%d) CORRUPTED ct.year: was %d\n"
argument_list|,
operator|(
name|int
operator|)
name|year
argument_list|,
operator|(
name|int
operator|)
name|Flag
argument_list|,
operator|(
name|int
operator|)
name|ct
operator|.
name|year
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|year
argument_list|)
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|julian0
argument_list|(
name|year
argument_list|)
operator|-
name|julian0
argument_list|(
literal|1970
argument_list|)
expr_stmt|;
comment|/* Julian day from 1970 */
name|Expected
operator|=
name|t
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
if|if
condition|(
name|Observed
operator|!=
name|Expected
operator|||
name|Flag
condition|)
block|{
comment|/* time difference */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%04d: dcf_to_unixtime(,%d) FAILURE: was=%lu s/b=%lu  (%ld)\n"
argument_list|,
name|year
argument_list|,
operator|(
name|int
operator|)
name|Flag
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|Observed
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|Expected
argument_list|,
operator|(
operator|(
name|long
operator|)
name|Observed
operator|-
operator|(
name|long
operator|)
name|Expected
operator|)
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|year
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|year
operator|>=
name|YEAR_PIVOT
operator|+
literal|1900
condition|)
block|{
comment|/* check year % 100 code we put into dcf_to_unixtime() */
name|ct
operator|.
name|year
operator|=
name|year
operator|%
literal|100
expr_stmt|;
name|Flag
operator|=
literal|0
expr_stmt|;
name|Observed
operator|=
name|dcf_to_unixtime
argument_list|(
operator|&
name|ct
argument_list|,
operator|&
name|Flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|Observed
operator|!=
name|Expected
operator|||
name|Flag
condition|)
block|{
comment|/* time difference */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%04d: dcf_to_unixtime(%d,%d) FAILURE: was=%lu s/b=%lu  (%ld)\n"
argument_list|,
name|year
argument_list|,
operator|(
name|int
operator|)
name|ct
operator|.
name|year
argument_list|,
operator|(
name|int
operator|)
name|Flag
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|Observed
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|Expected
argument_list|,
operator|(
operator|(
name|long
operator|)
name|Observed
operator|-
operator|(
name|long
operator|)
name|Expected
operator|)
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|year
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check year - 1900 code we put into dcf_to_unixtime() */
name|ct
operator|.
name|year
operator|=
name|year
operator|-
literal|1900
expr_stmt|;
name|Flag
operator|=
literal|0
expr_stmt|;
name|Observed
operator|=
name|dcf_to_unixtime
argument_list|(
operator|&
name|ct
argument_list|,
operator|&
name|Flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|Observed
operator|!=
name|Expected
operator|||
name|Flag
condition|)
block|{
comment|/* time difference */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%04d: dcf_to_unixtime(%d,%d) FAILURE: was=%lu s/b=%lu  (%ld)\n"
argument_list|,
name|year
argument_list|,
operator|(
name|int
operator|)
name|ct
operator|.
name|year
argument_list|,
operator|(
name|int
operator|)
name|Flag
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|Observed
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|Expected
argument_list|,
operator|(
operator|(
name|long
operator|)
name|Observed
operator|-
operator|(
name|long
operator|)
name|Expected
operator|)
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|year
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|Fatals
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * rawdcf_init - set up modem lines for RAWDCF receivers  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCMSET
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TIOCM_DTR
argument_list|)
operator|||
name|defined
argument_list|(
name|CIOCM_DTR
argument_list|)
operator|)
end_if

begin_function
specifier|static
name|void
name|rawdcf_init
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
comment|/* 	 * You can use the RS232 to supply the power for a DCF77 receiver. 	 * Here a voltage between the DTR and the RTS line is used. Unfortunately 	 * the name has changed from CIOCM_DTR to TIOCM_DTR recently. 	 */
ifdef|#
directive|ifdef
name|TIOCM_DTR
name|int
name|sl232
init|=
name|TIOCM_DTR
decl_stmt|;
comment|/* turn on DTR for power supply */
else|#
directive|else
name|int
name|sl232
init|=
name|CIOCM_DTR
decl_stmt|;
comment|/* turn on DTR for power supply */
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sl232
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"rawdcf_init: WARNING: ioctl(fd, TIOCMSET, [C|T]IOCM_DTR): %m"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|rawdcf_init
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"rawdcf_init: WARNING: OS interface incapable of setting DTR to power DCF modules"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DTR initialisation type */
end_comment

begin_comment
comment|/*-----------------------------------------------------------------------  * main loop - argument interpreter / setup / main loop  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|a
init|=
name|argv
decl_stmt|;
name|int
name|ac
init|=
name|argc
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|drift_file
init|=
literal|"/etc/dcfd.drift"
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|offset
init|=
literal|15
decl_stmt|;
name|int
name|offsets
init|=
literal|0
decl_stmt|;
name|int
name|delay
init|=
name|DEFAULT_DELAY
decl_stmt|;
comment|/* average delay from input edge to time stamping */
name|int
name|trace
init|=
literal|0
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
comment|/* 	 * process arguments 	 */
while|while
condition|(
operator|--
name|ac
condition|)
block|{
name|char
modifier|*
name|arg
init|=
operator|*
operator|++
name|a
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|arg
operator|)
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'t'
case|:
name|trace
operator|=
literal|1
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|offset
operator|=
literal|0
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|loop_filter_debug
operator|=
literal|1
expr_stmt|;
name|offsets
operator|=
literal|1
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|no_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|offsets
operator|=
literal|1
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
block|{
name|delay
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -D requires integer argument\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
block|{
name|drift_file
operator|=
operator|*
operator|++
name|a
expr_stmt|;
name|ac
operator|--
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -d requires file name argument\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'Y'
case|:
name|errs
operator|=
name|check_y2k
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|errs
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown option -%c\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
name|arg
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: device specified twice\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errs
condition|)
block|{
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: device not specified\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|errs
operator|=
name|LINES
operator|+
literal|1
expr_stmt|;
comment|/* 	 * get access to DCF77 tty port 	 */
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|rrc
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|,
name|tt
decl_stmt|,
name|tlast
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|struct
name|timeval
name|phase
decl_stmt|;
name|struct
name|timeval
name|time_offset
decl_stmt|;
name|char
name|pbuf
index|[
literal|61
index|]
decl_stmt|;
comment|/* printable version */
name|char
name|buf
index|[
literal|61
index|]
decl_stmt|;
comment|/* raw data */
name|clocktime_t
name|clock_time
decl_stmt|;
comment|/* wall clock time */
name|time_t
name|utc_time
init|=
literal|0
decl_stmt|;
name|time_t
name|last_utc_time
init|=
literal|0
decl_stmt|;
name|long
name|usecerror
init|=
literal|0
decl_stmt|;
name|long
name|lasterror
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
operator|||
name|defined
argument_list|(
name|STREAM
argument_list|)
name|struct
name|termios
name|term
decl_stmt|;
else|#
directive|else
comment|/* not HAVE_TERMIOS_H || STREAM */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIO_H
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
name|struct
name|termio
name|term
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TERMIO_H || HAVE_SYSV_TTYS */
endif|#
directive|endif
comment|/* not HAVE_TERMIOS_H || STREAM */
name|unsigned
name|int
name|rtc
init|=
name|CVT_NONE
decl_stmt|;
name|rawdcf_init
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
name|phase
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|phase
operator|.
name|tv_usec
operator|=
name|delay
expr_stmt|;
comment|/* 		 * setup TTY (50 Baud, Read, 8Bit, No Hangup, 1 character IO) 		 */
if|if
condition|(
name|TTY_GETATTR
argument_list|(
name|fd
argument_list|,
operator|&
name|term
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|term
operator|.
name|c_cc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|term
operator|.
name|c_cc
argument_list|)
argument_list|)
expr_stmt|;
name|term
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_PARENB_IGNPAR
name|term
operator|.
name|c_cflag
operator|=
name|B50
operator||
name|CS8
operator||
name|CREAD
operator||
name|CLOCAL
expr_stmt|;
else|#
directive|else
name|term
operator|.
name|c_cflag
operator|=
name|B50
operator||
name|CS8
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|PARENB
expr_stmt|;
endif|#
directive|endif
name|term
operator|.
name|c_iflag
operator|=
name|IGNPAR
expr_stmt|;
name|term
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|term
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TTY_SETATTR
argument_list|(
name|fd
argument_list|,
operator|&
name|term
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"tcsetattr"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * loose terminal if in daemon operation 		 */
if|if
condition|(
operator|!
name|interactive
condition|)
name|detach
argument_list|()
expr_stmt|;
comment|/* 		 * get syslog() initialized 		 */
ifdef|#
directive|ifdef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"dcfd"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"dcfd"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * setup periodic operations (state control / frequency control) 		 */
ifdef|#
directive|ifdef
name|HAVE_SIGVEC
block|{
name|struct
name|sigvec
name|vec
decl_stmt|;
name|vec
operator|.
name|sv_handler
operator|=
name|tick
expr_stmt|;
name|vec
operator|.
name|sv_mask
operator|=
literal|0
expr_stmt|;
name|vec
operator|.
name|sv_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|vec
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec(SIGALRM): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|tick
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_SIGACTION_IN_STRUCT_SIGACTION
name|act
operator|.
name|sa_sigaction
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|P
argument_list|(
operator|(
name|int
operator|,
name|siginfo_t
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SA_SIGACTION_IN_STRUCT_SIGACTION */
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|act
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction(SIGALRM): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ITIMER_REAL
block|{
name|struct
name|itimerval
name|it
decl_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|1
operator|<<
name|ADJINTERVAL
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|1
operator|<<
name|ADJINTERVAL
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|it
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setitimer: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|1
operator|<<
name|ADJINTERVAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PRINTF
argument_list|(
literal|"  DCF77 monitor - Copyright (C) 1993-1998 by Frank Kardel\n\n"
argument_list|)
expr_stmt|;
name|pbuf
index|[
literal|60
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|60
condition|;
name|i
operator|++
control|)
name|pbuf
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
name|read_drift
argument_list|(
name|drift_file
argument_list|)
expr_stmt|;
comment|/* 		 * what time is it now (for interval measurement) 		 */
name|gettimeofday
argument_list|(
operator|&
name|tlast
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* 		 * loop until input trouble ... 		 */
do|do
block|{
comment|/* 			 * get an impulse 			 */
while|while
condition|(
operator|(
name|rrc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|t
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|tt
operator|=
name|t
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|tlast
argument_list|)
expr_stmt|;
if|if
condition|(
name|errs
operator|>
name|LINES
condition|)
block|{
name|PRINTF
argument_list|(
literal|"  %s"
argument_list|,
operator|&
literal|"PTB private....RADMLSMin....PHour..PMDay..DayMonthYear....P\n"
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"  %s"
argument_list|,
operator|&
literal|"---------------RADMLS1248124P124812P1248121241248112481248P\n"
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 				 * timeout -> possible minute mark -> interpretation 				 */
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|timeout
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%c %.*s "
argument_list|,
name|pat
index|[
name|i
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|pat
argument_list|)
operator|-
literal|1
operator|)
index|]
argument_list|,
literal|59
operator|-
name|offset
argument_list|,
operator|&
name|pbuf
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtc
operator|=
name|cvt_rawdcf
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
name|i
argument_list|,
operator|&
name|clock_time
argument_list|)
operator|)
operator|!=
name|CVT_OK
condition|)
block|{
comment|/* 						 * this data was bad - well - forget synchronisation for now 						 */
name|PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync_state
operator|==
name|SYNC
condition|)
block|{
name|sync_state
operator|=
name|NO_SYNC
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DCF77 reception lost (bad data)"
argument_list|)
expr_stmt|;
block|}
name|errs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trace
condition|)
block|{
name|PRINTF
argument_list|(
literal|"\r  %.*s "
argument_list|,
literal|59
operator|-
name|offset
argument_list|,
operator|&
name|buf
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/* 					 * collect first character 					 */
if|if
condition|(
operator|(
operator|(
name|c
operator|^
literal|0xFF
operator|)
operator|+
literal|1
operator|)
operator|&
operator|(
name|c
operator|^
literal|0xFF
operator|)
condition|)
name|pbuf
index|[
literal|0
index|]
operator|=
literal|'?'
expr_stmt|;
else|else
name|pbuf
index|[
literal|0
index|]
operator|=
name|type
argument_list|(
name|c
argument_list|)
condition|?
literal|'#'
else|:
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|60
condition|;
name|i
operator|++
control|)
name|pbuf
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * collect character 					 */
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
comment|/* 					 * initial guess (usually correct) 					 */
if|if
condition|(
operator|(
operator|(
name|c
operator|^
literal|0xFF
operator|)
operator|+
literal|1
operator|)
operator|&
operator|(
name|c
operator|^
literal|0xFF
operator|)
condition|)
name|pbuf
index|[
name|i
index|]
operator|=
literal|'?'
expr_stmt|;
else|else
name|pbuf
index|[
name|i
index|]
operator|=
name|type
argument_list|(
name|c
argument_list|)
condition|?
literal|'#'
else|:
literal|'-'
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%c %.*s "
argument_list|,
name|pat
index|[
name|i
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|pat
argument_list|)
operator|-
literal|1
operator|)
index|]
argument_list|,
literal|59
operator|-
name|offset
argument_list|,
operator|&
name|pbuf
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|rtc
operator|==
name|CVT_OK
condition|)
block|{
comment|/* 					 * we got a good time code here - try to convert it to 					 * UTC 					 */
if|if
condition|(
operator|(
name|utc_time
operator|=
name|dcf_to_unixtime
argument_list|(
operator|&
name|clock_time
argument_list|,
operator|&
name|rtc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|PRINTF
argument_list|(
literal|"*** BAD CONVERSION\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|utc_time
operator|!=
operator|(
name|last_utc_time
operator|+
literal|60
operator|)
condition|)
block|{
comment|/* 						 * well, two successive sucessful telegrams are not 60 seconds 						 * apart 						 */
name|PRINTF
argument_list|(
literal|"*** NO MINUTE INC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync_state
operator|==
name|SYNC
condition|)
block|{
name|sync_state
operator|=
name|NO_SYNC
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DCF77 reception lost (data mismatch)"
argument_list|)
expr_stmt|;
block|}
name|errs
operator|++
expr_stmt|;
name|rtc
operator|=
name|CVT_FAIL
operator||
name|CVT_BADTIME
operator||
name|CVT_BADDATE
expr_stmt|;
block|}
else|else
name|usecerror
operator|=
literal|0
expr_stmt|;
name|last_utc_time
operator|=
name|utc_time
expr_stmt|;
block|}
if|if
condition|(
name|rtc
operator|==
name|CVT_OK
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 						 * valid time code - determine offset and 						 * note regained reception 						 */
name|last_sync
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|sync_state
operator|==
name|NO_SYNC
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"receiving DCF77"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 							 * we had at least one minute SYNC - thus 							 * last error is valid 							 */
name|time_offset
operator|.
name|tv_sec
operator|=
name|lasterror
operator|/
literal|1000000
expr_stmt|;
name|time_offset
operator|.
name|tv_usec
operator|=
name|lasterror
operator|%
literal|1000000
expr_stmt|;
name|adjust_clock
argument_list|(
operator|&
name|time_offset
argument_list|,
name|drift_file
argument_list|,
name|utc_time
argument_list|)
expr_stmt|;
block|}
name|sync_state
operator|=
name|SYNC
expr_stmt|;
block|}
name|time_offset
operator|.
name|tv_sec
operator|=
name|utc_time
operator|+
name|i
expr_stmt|;
name|time_offset
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timeradd
argument_list|(
operator|&
name|time_offset
argument_list|,
operator|&
name|phase
argument_list|)
expr_stmt|;
name|usecerror
operator|+=
operator|(
name|time_offset
operator|.
name|tv_sec
operator|-
name|tt
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|+
name|time_offset
operator|.
name|tv_usec
operator|-
name|tt
operator|.
name|tv_usec
expr_stmt|;
comment|/* 					 * output interpreted DCF77 data 					 */
name|PRINTF
argument_list|(
name|offsets
condition|?
literal|"%s, %2d:%02d:%02d, %d.%02d.%02d,<%s%s%s%s> (%c%d.%06ds)"
else|:
literal|"%s, %2d:%02d:%02d, %d.%02d.%02d,<%s%s%s%s>"
argument_list|,
name|wday
index|[
name|clock_time
operator|.
name|wday
index|]
argument_list|,
name|clock_time
operator|.
name|hour
argument_list|,
name|clock_time
operator|.
name|minute
argument_list|,
name|i
argument_list|,
name|clock_time
operator|.
name|day
argument_list|,
name|clock_time
operator|.
name|month
argument_list|,
name|clock_time
operator|.
name|year
argument_list|,
operator|(
name|clock_time
operator|.
name|flags
operator|&
name|DCFB_ALTERNATE
operator|)
condition|?
literal|"R"
else|:
literal|"_"
argument_list|,
operator|(
name|clock_time
operator|.
name|flags
operator|&
name|DCFB_ANNOUNCE
operator|)
condition|?
literal|"A"
else|:
literal|"_"
argument_list|,
operator|(
name|clock_time
operator|.
name|flags
operator|&
name|DCFB_DST
operator|)
condition|?
literal|"D"
else|:
literal|"_"
argument_list|,
operator|(
name|clock_time
operator|.
name|flags
operator|&
name|DCFB_LEAP
operator|)
condition|?
literal|"L"
else|:
literal|"_"
argument_list|,
operator|(
name|lasterror
operator|<
literal|0
operator|)
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|l_abs
argument_list|(
name|lasterror
argument_list|)
operator|/
literal|1000000
argument_list|,
name|l_abs
argument_list|(
name|lasterror
argument_list|)
operator|%
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
name|lasterror
operator|=
name|usecerror
operator|/
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|lasterror
operator|=
literal|0
expr_stmt|;
comment|/* we cannot calculate phase errors on bad reception */
block|}
name|PRINTF
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|60
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
name|tlast
operator|=
name|tt
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|rrc
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
do|;
comment|/* 		 * lost IO - sorry guys 		 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TERMINATING - cannot read from device %s (%m)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|closelog
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

