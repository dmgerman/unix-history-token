begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_chu - clock driver for Canadian CHU time/frequency station  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_CHU
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_include
include|#
directive|include
file|"audio.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_define
define|#
directive|define
name|ICOM
value|1
end_define

begin_comment
comment|/* undefine to suppress ICOM code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_include
include|#
directive|include
file|"icom.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * Audio CHU demodulator/decoder  *  * This driver synchronizes the computer time using data encoded in  * radio transmissions from Canadian time/frequency station CHU in  * Ottawa, Ontario. Transmissions are made continuously on 3330 kHz,  * 7335 kHz and 14670 kHz in upper sideband, compatible AM mode. An  * ordinary shortwave receiver can be tuned manually to one of these  * frequencies or, in the case of ICOM receivers, the receiver can be  * tuned automatically using this program as propagation conditions  * change throughout the day and night.  *  * The driver receives, demodulates and decodes the radio signals when  * connected to the audio codec of a Sun workstation running SunOS or  * Solaris, and with a little help, other workstations with similar  * codecs or sound cards. In this implementation, only one audio driver  * and codec can be supported on a single machine.  *  * The driver can be compiled to use a Bell 103 compatible modem or  * modem chip to receive the radio signal and demodulate the data.  * Alternatively, the driver can be compiled to use the audio codec of  * the Sun workstation or another with compatible audio drivers. In the  * latter case, the driver implements the modem using DSP routines, so  * the radio can be connected directly to either the microphone on line  * input port. In either case, the driver decodes the data using a  * maximum likelihood technique which exploits the considerable degree  * of redundancy available to maximize accuracy and minimize errors.  *  * The CHU time broadcast includes an audio signal compatible with the  * Bell 103 modem standard (mark = 2225 Hz, space = 2025 Hz). It consist  * of nine, ten-character bursts transmitted at 300 bps and beginning  * each second from second 31 to second 39 of the minute. Each character  * consists of eight data bits plus one start bit and two stop bits to  * encode two hex digits. The burst data consist of five characters (ten  * hex digits) followed by a repeat of these characters. In format A,  * the characters are repeated in the same polarity; in format B, the  * characters are repeated in the opposite polarity.  *  * Format A bursts are sent at seconds 32 through 39 of the minute in  * hex digits  *  *	6dddhhmmss6dddhhmmss  *  * The first ten digits encode a frame marker (6) followed by the day  * (ddd), hour (hh in UTC), minute (mm) and the second (ss). Since  * format A bursts are sent during the third decade of seconds the tens  * digit of ss is always 3. The driver uses this to determine correct  * burst synchronization. These digits are then repeated with the same  * polarity.  *  * Format B bursts are sent at second 31 of the minute in hex digits  *  *	xdyyyyttaaxdyyyyttaa  *  * The first ten digits encode a code (x described below) followed by  * the DUT1 (d in deciseconds), Gregorian year (yyyy), difference TAI -  * UTC (tt) and daylight time indicator (aa) peculiar to Canada. These  * digits are then repeated with inverted polarity.  *  * The x is coded  *  * 1 Sign of DUT (0 = +)  * 2 Leap second warning. One second will be added.  * 4 Leap second warning. One second will be subtracted.  * 8 Even parity bit for this nibble.  *  * By design, the last stop bit of the last character in the burst  * coincides with 0.5 second. Since characters have 11 bits and are  * transmitted at 300 bps, the last stop bit of the first character  * coincides with 0.5 - 10 * 11/300 = 0.133 second. Depending on the  * UART, character interrupts can vary somewhere between the beginning  * of bit 9 and end of bit 11. These eccentricities can be corrected  * along with the radio propagation delay using fudge time 1.  *  * Debugging aids  *  * The timecode format used for debugging and data recording includes  * data helpful in diagnosing problems with the radio signal and serial  * connections. With debugging enabled (-d -d -d on the ntpd command  * line), the driver produces one line for each burst in two formats  * corresponding to format A and B. Following is format A:  *  *	n b f s m code  *  * where n is the number of characters in the burst (0-11), b the burst  * distance (0-40), f the field alignment (-1, 0, 1), s the  * synchronization distance (0-16), m the burst number (2-9) and code  * the burst characters as received. Note that the hex digits in each  * character are reversed, so the burst  *  *	10 38 0 16 9 06851292930685129293  *  * is interpreted as containing 11 characters with burst distance 38,  * field alignment 0, synchronization distance 16 and burst number 9.  * The nibble-swapped timecode shows day 58, hour 21, minute 29 and  * second 39.  *  * When the audio driver is compiled, format A is preceded by  * the current gain (0-255) and relative signal level (0-9999). The  * receiver folume control should be set so that the gain is somewhere  * near the middle of the range 0-255, which results in a signal level  * near 1000.  *  * Following is format B:  *   *	n b s code  *  * where n is the number of characters in the burst (0-11), b the burst  * distance (0-40), s the synchronization distance (0-40) and code the  * burst characters as received. Note that the hex digits in each  * character are reversed and the last ten digits inverted, so the burst  *  *	11 40 1091891300ef6e76ecff  *  * is interpreted as containing 11 characters with burst distance 40.  * The nibble-swapped timecode shows DUT1 +0.1 second, year 1998 and TAI  * - UTC 31 seconds.  *  * In addition to the above, the reference timecode is updated and  * written to the clockstats file and debug score after the last burst  * received in the minute. The format is  *  *	qq yyyy ddd hh:mm:ss nn dd tt  *  * where qq are the error flags, as described below, yyyy is the year,  * ddd the day, hh:mm:ss the time of day, nn the number of format A  * bursts received during the previous minute, dd the decoding distance  * and tt the number of timestamps. The error flags are cleared after  * every update.  *  * Fudge factors  *  * For accuracies better than the low millisceconds, fudge time1 can be  * set to the radio propagation delay from CHU to the receiver. This can  * be done conviently using the minimuf program. When the modem driver  * is compiled, fudge flag3 enables the ppsclock line discipline. Fudge  * flag4 causes the dubugging output described above to be recorded in  * the clockstats file.  *  * When the audio driver is compiled, fudge flag2 selects the audio  * input port, where 0 is the mike port (default) and 1 is the line-in  * port. It does not seem useful to select the compact disc player port.  * Fudge flag3 enables audio monitoring of the input signal. For this  * purpose, the speaker volume must be set before the driver is started.  *  * The audio codec code is normally compiled in the driver if the  * architecture supports it (HAVE_AUDIO defined), but is used only if the  * link /dev/chu_audio is defined and valid. The serial port  * code is alwasy compiled in the driver, but is used only if the autdio  * codec is not available and the link /dev/chu%d is defined and valid.  * The ICOM code is normally compiled in the driver if selected (ICOM  * defined), but is used only if the link /dev/icom%d is defined and  * valid and the mode keyword on the server configuration command  * specifies a nonzero mode (ICOM ID select code). The C-IV speed is  * 9600 bps if the high order 0x80 bit of the mode is zero and 1200 bps  * if one. The C-IV trace is turned on if the debug level is greater  * than one.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B300
end_define

begin_comment
comment|/* uart speed (300 baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"CHU"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/chu%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B300
end_define

begin_comment
comment|/* UART speed (300 baud) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_define
define|#
directive|define
name|DWELL
value|5
end_define

begin_comment
comment|/* minutes before qsy */
end_comment

begin_define
define|#
directive|define
name|NCHAN
value|3
end_define

begin_comment
comment|/* number of channels */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_comment
comment|/*  * Audio demodulator definitions  */
end_comment

begin_define
define|#
directive|define
name|SECOND
value|8000
end_define

begin_comment
comment|/* nominal sample rate (Hz) */
end_comment

begin_define
define|#
directive|define
name|BAUD
value|300
end_define

begin_comment
comment|/* modulation rate (bps) */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|128
end_define

begin_comment
comment|/* companded sample offset */
end_comment

begin_define
define|#
directive|define
name|SIZE
value|256
end_define

begin_comment
comment|/* decompanding table size */
end_comment

begin_define
define|#
directive|define
name|MAXSIG
value|6000.
end_define

begin_comment
comment|/* maximum signal level */
end_comment

begin_define
define|#
directive|define
name|LIMIT
value|1000.
end_define

begin_comment
comment|/* soft limiter threshold */
end_comment

begin_define
define|#
directive|define
name|AGAIN
value|6.
end_define

begin_comment
comment|/* baseband gain */
end_comment

begin_define
define|#
directive|define
name|LAG
value|10
end_define

begin_comment
comment|/* discriminator lag */
end_comment

begin_define
define|#
directive|define
name|DEVICE_AUDIO
value|"/dev/chu_audio"
end_define

begin_comment
comment|/* device name */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"CHU Audio/Modem Receiver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DESCRIPTION
value|"CHU Modem Receiver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_comment
comment|/*  * Decoder definitions  */
end_comment

begin_define
define|#
directive|define
name|CHAR
value|(11. / 300.)
end_define

begin_comment
comment|/* character time (s) */
end_comment

begin_define
define|#
directive|define
name|FUDGE
value|.185
end_define

begin_comment
comment|/* offset to first stop bit (s) */
end_comment

begin_define
define|#
directive|define
name|BURST
value|11
end_define

begin_comment
comment|/* max characters per burst */
end_comment

begin_define
define|#
directive|define
name|MINCHAR
value|9
end_define

begin_comment
comment|/* min characters per burst */
end_comment

begin_define
define|#
directive|define
name|MINDIST
value|28
end_define

begin_comment
comment|/* min burst distance (of 40)  */
end_comment

begin_define
define|#
directive|define
name|MINSYNC
value|8
end_define

begin_comment
comment|/* min sync distance (of 16) */
end_comment

begin_define
define|#
directive|define
name|MINSTAMP
value|20
end_define

begin_comment
comment|/* min timestamps (of 60) */
end_comment

begin_define
define|#
directive|define
name|PANIC
value|(4 * 1440)
end_define

begin_comment
comment|/* panic restart */
end_comment

begin_comment
comment|/*  * Hex extension codes (>= 16)  */
end_comment

begin_define
define|#
directive|define
name|HEX_MISS
value|16
end_define

begin_comment
comment|/* miss */
end_comment

begin_define
define|#
directive|define
name|HEX_SOFT
value|17
end_define

begin_comment
comment|/* soft error */
end_comment

begin_define
define|#
directive|define
name|HEX_HARD
value|18
end_define

begin_comment
comment|/* hard error */
end_comment

begin_comment
comment|/*  * Status bits (status)  */
end_comment

begin_define
define|#
directive|define
name|RUNT
value|0x0001
end_define

begin_comment
comment|/* runt burst */
end_comment

begin_define
define|#
directive|define
name|NOISE
value|0x0002
end_define

begin_comment
comment|/* noise burst */
end_comment

begin_define
define|#
directive|define
name|BFRAME
value|0x0004
end_define

begin_comment
comment|/* invalid format B frame sync */
end_comment

begin_define
define|#
directive|define
name|BFORMAT
value|0x0008
end_define

begin_comment
comment|/* invalid format B data */
end_comment

begin_define
define|#
directive|define
name|AFRAME
value|0x0010
end_define

begin_comment
comment|/* invalid format A frame sync */
end_comment

begin_define
define|#
directive|define
name|AFORMAT
value|0x0020
end_define

begin_comment
comment|/* invalid format A data */
end_comment

begin_define
define|#
directive|define
name|DECODE
value|0x0040
end_define

begin_comment
comment|/* invalid data decode */
end_comment

begin_define
define|#
directive|define
name|STAMP
value|0x0080
end_define

begin_comment
comment|/* too few timestamps */
end_comment

begin_define
define|#
directive|define
name|INYEAR
value|0x0100
end_define

begin_comment
comment|/* valid B frame */
end_comment

begin_define
define|#
directive|define
name|INSYNC
value|0x0200
end_define

begin_comment
comment|/* clock synchronized */
end_comment

begin_comment
comment|/*  * Alarm status bits (alarm)  *  * These alarms are set at the end of a minute in which at least one  * burst was received. SYNERR is raised if the AFRAME or BFRAME status  * bits are set during the minute, FMTERR is raised if the AFORMAT or  * BFORMAT status bits are set, DECERR is raised if the DECODE status  * bit is set and TSPERR is raised if the STAMP status bit is set.  */
end_comment

begin_define
define|#
directive|define
name|SYNERR
value|0x01
end_define

begin_comment
comment|/* frame sync error */
end_comment

begin_define
define|#
directive|define
name|FMTERR
value|0x02
end_define

begin_comment
comment|/* data format error */
end_comment

begin_define
define|#
directive|define
name|DECERR
value|0x04
end_define

begin_comment
comment|/* data decoding error */
end_comment

begin_define
define|#
directive|define
name|TSPERR
value|0x08
end_define

begin_comment
comment|/* insufficient data */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_struct
struct|struct
name|surv
block|{
name|double
name|shift
index|[
literal|12
index|]
decl_stmt|;
comment|/* mark register */
name|double
name|es_max
decl_stmt|,
name|es_min
decl_stmt|;
comment|/* max/min envelope signals */
name|double
name|dist
decl_stmt|;
comment|/* sample distance */
name|int
name|uart
decl_stmt|;
comment|/* decoded character */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_comment
comment|/*  * CHU unit control structure  */
end_comment

begin_struct
struct|struct
name|chuunit
block|{
name|u_char
name|decode
index|[
literal|20
index|]
index|[
literal|16
index|]
decl_stmt|;
comment|/* maximum likelihood decoding matrix */
name|l_fp
name|cstamp
index|[
name|BURST
index|]
decl_stmt|;
comment|/* character timestamps */
name|l_fp
name|tstamp
index|[
name|MAXSTAGE
index|]
decl_stmt|;
comment|/* timestamp samples */
name|l_fp
name|timestamp
decl_stmt|;
comment|/* current buffer timestamp */
name|l_fp
name|laststamp
decl_stmt|;
comment|/* last buffer timestamp */
name|l_fp
name|charstamp
decl_stmt|;
comment|/* character time as a l_fp */
name|int
name|errflg
decl_stmt|;
comment|/* error flags */
name|int
name|status
decl_stmt|;
comment|/* status bits */
name|int
name|bufptr
decl_stmt|;
comment|/* buffer index pointer */
name|char
name|ident
index|[
literal|10
index|]
decl_stmt|;
comment|/* transmitter frequency */
ifdef|#
directive|ifdef
name|ICOM
name|int
name|fd_icom
decl_stmt|;
comment|/* ICOM file descriptor */
name|int
name|chan
decl_stmt|;
comment|/* frequency identifier */
name|int
name|dwell
decl_stmt|;
comment|/* dwell minutes at current frequency */
endif|#
directive|endif
comment|/* ICOM */
comment|/* 	 * Character burst variables 	 */
name|int
name|cbuf
index|[
name|BURST
index|]
decl_stmt|;
comment|/* character buffer */
name|int
name|ntstamp
decl_stmt|;
comment|/* number of timestamp samples */
name|int
name|ndx
decl_stmt|;
comment|/* buffer start index */
name|int
name|prevsec
decl_stmt|;
comment|/* previous burst second */
name|int
name|burdist
decl_stmt|;
comment|/* burst distance */
name|int
name|mindist
decl_stmt|;
comment|/* minimum distance */
name|int
name|syndist
decl_stmt|;
comment|/* sync distance */
name|int
name|burstcnt
decl_stmt|;
comment|/* format A bursts this minute */
comment|/* 	 * Format particulars 	 */
name|int
name|leap
decl_stmt|;
comment|/* leap/dut code */
name|int
name|dut
decl_stmt|;
comment|/* UTC1 correction */
name|int
name|tai
decl_stmt|;
comment|/* TAI - UTC correction */
name|int
name|dst
decl_stmt|;
comment|/* Canadian DST code */
ifdef|#
directive|ifdef
name|HAVE_AUDIO
comment|/* 	 * Audio codec variables 	 */
name|int
name|fd_audio
decl_stmt|;
comment|/* audio port file descriptor */
name|double
name|comp
index|[
name|SIZE
index|]
decl_stmt|;
comment|/* decompanding table */
name|int
name|port
decl_stmt|;
comment|/* codec port */
name|int
name|gain
decl_stmt|;
comment|/* codec gain */
name|int
name|bufcnt
decl_stmt|;
comment|/* samples in buffer */
name|int
name|clipcnt
decl_stmt|;
comment|/* sample clip count */
name|int
name|seccnt
decl_stmt|;
comment|/* second interval counter */
comment|/* 	 * Modem variables 	 */
name|l_fp
name|tick
decl_stmt|;
comment|/* audio sample increment */
name|double
name|bpf
index|[
literal|9
index|]
decl_stmt|;
comment|/* IIR bandpass filter */
name|double
name|disc
index|[
name|LAG
index|]
decl_stmt|;
comment|/* discriminator shift register */
name|double
name|lpf
index|[
literal|27
index|]
decl_stmt|;
comment|/* FIR lowpass filter */
name|double
name|monitor
decl_stmt|;
comment|/* audio monitor */
name|double
name|maxsignal
decl_stmt|;
comment|/* signal level */
name|int
name|discptr
decl_stmt|;
comment|/* discriminator pointer */
comment|/* 	 * Maximum likelihood UART variables 	 */
name|double
name|baud
decl_stmt|;
comment|/* baud interval */
name|struct
name|surv
name|surv
index|[
literal|8
index|]
decl_stmt|;
comment|/* UART survivor structures */
name|int
name|decptr
decl_stmt|;
comment|/* decode pointer */
name|int
name|dbrk
decl_stmt|;
comment|/* holdoff counter */
endif|#
directive|endif
comment|/* HAVE_AUDIO */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chu_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * More function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|chu_decode
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_burst
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_clear
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_a
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_b
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chu_dist
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chu_major
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|chu_uart
name|P
argument_list|(
operator|(
expr|struct
name|surv
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_rf
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_gain
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_audio_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
name|rbufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_decl_stmt
specifier|static
name|void
name|chu_serial_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
name|rbufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hexchar
index|[]
init|=
literal|"0123456789abcdef_-="
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_decl_stmt
specifier|static
name|double
name|qsy
index|[
name|NCHAN
index|]
init|=
block|{
literal|3.33
block|,
literal|7.335
block|,
literal|14.67
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequencies (MHz) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_chu
init|=
block|{
name|chu_start
block|,
comment|/* start up driver */
name|chu_shutdown
block|,
comment|/* shut down driver */
name|chu_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old chu_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old chu_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * chu_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|chu_start
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* device name */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
ifdef|#
directive|ifdef
name|ICOM
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* trace buffer */
name|int
name|temp
decl_stmt|;
endif|#
directive|endif
comment|/* ICOM */
ifdef|#
directive|ifdef
name|HAVE_AUDIO
name|int
name|fd_audio
decl_stmt|;
comment|/* audio port file descriptor */
name|int
name|i
decl_stmt|;
comment|/* index */
name|double
name|step
decl_stmt|;
comment|/* codec adjustment */
comment|/* 	 * Open audio device. 	 */
name|fd_audio
operator|=
name|audio_init
argument_list|(
name|DEVICE_AUDIO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|fd_audio
operator|>
literal|0
operator|&&
name|debug
condition|)
name|audio_show
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Open serial port in raw mode. 	 */
if|if
condition|(
name|fd_audio
operator|>
literal|0
condition|)
block|{
name|fd
operator|=
name|fd_audio
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_RAW
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* HAVE_AUDIO */
comment|/* 	 * Open serial port in raw mode. 	 */
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_RAW
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUDIO */
if|if
condition|(
name|fd
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|chuunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|chuunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|chu_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DTOLFP
argument_list|(
name|CHAR
argument_list|,
operator|&
name|up
operator|->
name|charstamp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AUDIO
comment|/* 	 * The companded samples are encoded sign-magnitude. The table 	 * contains all the 256 values in the interest of speed. We do 	 * this even if the audio codec is not available. C'est la lazy. 	 */
name|up
operator|->
name|fd_audio
operator|=
name|fd_audio
expr_stmt|;
name|up
operator|->
name|gain
operator|=
literal|127
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|0
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|OFFSET
index|]
operator|=
literal|0.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|1
index|]
operator|=
operator|-
literal|1.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|2
index|]
operator|=
operator|-
literal|3.
expr_stmt|;
name|step
operator|=
literal|2.
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|OFFSET
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|comp
index|[
name|i
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|step
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
name|i
index|]
operator|=
operator|-
name|up
operator|->
name|comp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
name|step
operator|*=
literal|2.
expr_stmt|;
block|}
name|DTOLFP
argument_list|(
literal|1.
operator|/
name|SECOND
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUDIO */
name|strcpy
argument_list|(
name|up
operator|->
name|ident
argument_list|,
literal|"X"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICOM
name|temp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|temp
operator|=
name|P_TRACE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|ttlmax
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|ttlmax
operator|&
literal|0x80
condition|)
name|up
operator|->
name|fd_icom
operator|=
name|icom_init
argument_list|(
literal|"/dev/icom"
argument_list|,
name|B1200
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|fd_icom
operator|=
name|icom_init
argument_list|(
literal|"/dev/icom"
argument_list|,
name|B9600
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|icom_freq
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|,
name|peer
operator|->
name|ttlmax
operator|&
literal|0x7f
argument_list|,
name|qsy
index|[
name|up
operator|->
name|chan
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_SYNCEVENT | NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ICOM bus error; autotune disabled"
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator|=
name|CEVNT_FAULT
expr_stmt|;
name|close
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|)
expr_stmt|;
name|up
operator|->
name|fd_icom
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|up
operator|->
name|ident
argument_list|,
literal|"%.1f"
argument_list|,
name|qsy
index|[
name|up
operator|->
name|chan
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"chu: QSY to %s MHz"
argument_list|,
name|up
operator|->
name|ident
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* ICOM */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * chu_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|chu_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|==
name|NULL
condition|)
return|return;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
name|close
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_receive - receive data from the audio or serial device  */
end_comment

begin_function
specifier|static
name|void
name|chu_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_AUDIO
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * If the audio codec is warmed up, the buffer contains codec 	 * samples which need to be demodulated and decoded into CHU 	 * characters using the software UART. Otherwise, the buffer 	 * contains CHU characters from the serial port, so the software 	 * UART is bypassed. In this case the CPU will probably run a 	 * few degrees cooler. 	 */
if|if
condition|(
name|up
operator|->
name|fd_audio
operator|>
literal|0
condition|)
name|chu_audio_receive
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
else|else
name|chu_serial_receive
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
else|#
directive|else
name|chu_serial_receive
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUDIO */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_comment
comment|/*  * chu_audio_receive - receive data from the audio device  */
end_comment

begin_function
specifier|static
name|void
name|chu_audio_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|double
name|sample
decl_stmt|;
comment|/* codec sample */
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* buffer pointer */
name|l_fp
name|ltemp
decl_stmt|;
comment|/* l_fp temp */
name|int
name|isneg
decl_stmt|;
comment|/* parity flag */
name|double
name|dtemp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Main loop - read until there ain't no more. Note codec 	 * samples are bit-inverted. 	 */
name|up
operator|->
name|timestamp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|up
operator|->
name|bufcnt
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|DTOLFP
argument_list|(
name|up
operator|->
name|bufcnt
operator|*
literal|1.
operator|/
name|SECOND
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|dpt
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
for|for
control|(
name|up
operator|->
name|bufptr
operator|=
literal|0
init|;
name|up
operator|->
name|bufptr
operator|<
name|up
operator|->
name|bufcnt
condition|;
name|up
operator|->
name|bufptr
operator|++
control|)
block|{
name|sample
operator|=
name|up
operator|->
name|comp
index|[
operator|~
operator|*
name|dpt
operator|&
literal|0xff
index|]
expr_stmt|;
comment|/* 		 * Clip noise spikes greater than MAXSIG. If no clips, 		 * increase the gain a tad; if the clips are too high,  		 * decrease a tad. 		 */
if|if
condition|(
name|sample
operator|>
name|MAXSIG
condition|)
block|{
name|sample
operator|=
name|MAXSIG
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sample
operator|<
operator|-
name|MAXSIG
condition|)
block|{
name|sample
operator|=
operator|-
name|MAXSIG
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
name|up
operator|->
name|seccnt
operator|=
operator|(
name|up
operator|->
name|seccnt
operator|+
literal|1
operator|)
operator|%
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|seccnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
name|up
operator|->
name|port
operator|=
literal|2
expr_stmt|;
else|else
name|up
operator|->
name|port
operator|=
literal|1
expr_stmt|;
name|chu_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|chu_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
comment|/* 		 * During development, it is handy to have an audio 		 * monitor that can be switched to various signals. This 		 * code converts the linear signal left in up->monitor 		 * to codec format. If we can get the grass out of this 		 * thing and improve modem performance, this expensive 		 * code will be permanently nixed. 		 */
name|isneg
operator|=
literal|0
expr_stmt|;
name|dtemp
operator|=
name|up
operator|->
name|monitor
expr_stmt|;
if|if
condition|(
name|sample
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|dtemp
operator|-=
name|dtemp
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|OFFSET
operator|>>
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dtemp
operator|>
name|up
operator|->
name|comp
index|[
name|i
index|]
condition|)
name|i
operator|+=
name|j
expr_stmt|;
elseif|else
if|if
condition|(
name|dtemp
operator|<
name|up
operator|->
name|comp
index|[
name|i
index|]
condition|)
name|i
operator|-=
name|j
expr_stmt|;
else|else
break|break;
name|j
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isneg
condition|)
operator|*
name|dpt
operator|=
operator|~
operator|(
name|i
operator|+
name|OFFSET
operator|)
expr_stmt|;
else|else
operator|*
name|dpt
operator|=
operator|~
name|i
expr_stmt|;
name|dpt
operator|++
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Squawk to the monitor speaker if enabled. 	 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
condition|)
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
argument_list|,
operator|(
name|u_int
operator|)
name|up
operator|->
name|bufcnt
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"chu:"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_rf - filter and demodulate the FSK signal  *  * This routine implements a 300-baud Bell 103 modem with mark 2225 Hz  * and space 2025 Hz. It uses a bandpass filter followed by a soft  * limiter, FM discriminator and lowpass filter. A maximum likelihood  * decoder samples the baseband signal at eight times the baud rate and  * detects the start bit of each character.  *  * The filters are built for speed, which explains the rather clumsy  * code. Hopefully, the compiler will efficiently implement the move-  * and-muiltiply-and-add operations.  */
end_comment

begin_function
specifier|static
name|void
name|chu_rf
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample
comment|/* analog sample */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|surv
modifier|*
name|sp
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|signal
decl_stmt|;
comment|/* bandpass signal */
name|double
name|limit
decl_stmt|;
comment|/* limiter signal */
name|double
name|disc
decl_stmt|;
comment|/* discriminator signal */
name|double
name|lpf
decl_stmt|;
comment|/* lowpass signal */
name|double
name|span
decl_stmt|;
comment|/* UART signal span */
name|double
name|dist
decl_stmt|;
comment|/* UART signal distance */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Bandpass filter. 4th-order elliptic, 500-Hz bandpass centered 	 * at 2125 Hz. Passband ripple 0.3 dB, stopband ripple 50 dB. 	 */
name|signal
operator|=
operator|(
name|up
operator|->
name|bpf
index|[
literal|8
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|)
operator|*
literal|5.844676e-01
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|)
operator|*
literal|4.884860e-01
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|)
operator|*
literal|2.704384e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|)
operator|*
literal|1.645032e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|)
operator|*
literal|4.644557e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|)
operator|*
literal|1.879165e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|)
operator|*
literal|3.522634e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|)
operator|*
literal|7.315738e-01
expr_stmt|;
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|=
name|sample
operator|-
name|signal
expr_stmt|;
name|signal
operator|=
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|*
literal|6.176213e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|*
literal|3.156599e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|*
literal|7.567487e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|*
literal|4.344580e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|*
literal|1.190128e-02
operator|+
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|*
literal|4.344580e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|*
literal|7.567487e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|*
literal|3.156599e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|8
index|]
operator|*
literal|6.176213e-03
expr_stmt|;
name|up
operator|->
name|monitor
operator|=
name|signal
operator|/
literal|4.
expr_stmt|;
comment|/* note monitor after filter */
comment|/* 	 * Soft limiter/discriminator. The 11-sample discriminator lag 	 * interval corresponds to three cycles of 2125 Hz, which 	 * requires the sample frequency to be 2125 * 11 / 3 = 7791.7 	 * Hz. The discriminator output varies +-0.5 interval for input 	 * frequency 2025-2225 Hz. However, we don't get to sample at 	 * this frequency, so the discriminator output is biased. Life 	 * at 8000 Hz sucks. 	 */
name|limit
operator|=
name|signal
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|LIMIT
condition|)
name|limit
operator|=
name|LIMIT
expr_stmt|;
elseif|else
if|if
condition|(
name|limit
operator|<
operator|-
name|LIMIT
condition|)
name|limit
operator|=
operator|-
name|LIMIT
expr_stmt|;
name|disc
operator|=
name|up
operator|->
name|disc
index|[
name|up
operator|->
name|discptr
index|]
operator|*
operator|-
name|limit
expr_stmt|;
name|up
operator|->
name|disc
index|[
name|up
operator|->
name|discptr
index|]
operator|=
name|limit
expr_stmt|;
name|up
operator|->
name|discptr
operator|=
operator|(
name|up
operator|->
name|discptr
operator|+
literal|1
operator|)
operator|%
name|LAG
expr_stmt|;
if|if
condition|(
name|disc
operator|>=
literal|0
condition|)
name|disc
operator|=
name|SQRT
argument_list|(
name|disc
argument_list|)
expr_stmt|;
else|else
name|disc
operator|=
operator|-
name|SQRT
argument_list|(
operator|-
name|disc
argument_list|)
expr_stmt|;
comment|/* 	 * Lowpass filter. Raised cosine, Ts = 1 / 300, beta = 0.1. 	 */
name|lpf
operator|=
operator|(
name|up
operator|->
name|lpf
index|[
literal|26
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|25
index|]
operator|)
operator|*
literal|2.538771e-02
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|25
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|24
index|]
operator|)
operator|*
literal|1.084671e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|24
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|23
index|]
operator|)
operator|*
literal|2.003159e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|23
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|22
index|]
operator|)
operator|*
literal|2.985303e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|22
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|21
index|]
operator|)
operator|*
literal|4.003697e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|21
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|20
index|]
operator|)
operator|*
literal|5.028552e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|20
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|19
index|]
operator|)
operator|*
literal|6.028795e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|19
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|18
index|]
operator|)
operator|*
literal|6.973249e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|18
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|17
index|]
operator|)
operator|*
literal|7.831828e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|17
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|16
index|]
operator|)
operator|*
literal|8.576717e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|16
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|15
index|]
operator|)
operator|*
literal|9.183463e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|15
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|14
index|]
operator|)
operator|*
literal|9.631951e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|14
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|13
index|]
operator|)
operator|*
literal|9.907208e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|13
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|12
index|]
operator|)
operator|*
literal|1.000000e+00
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|12
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|11
index|]
operator|)
operator|*
literal|9.907208e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|11
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|10
index|]
operator|)
operator|*
literal|9.631951e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|10
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|9
index|]
operator|)
operator|*
literal|9.183463e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|9
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|8
index|]
operator|)
operator|*
literal|8.576717e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|8
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|7
index|]
operator|)
operator|*
literal|7.831828e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|7
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|6
index|]
operator|)
operator|*
literal|6.973249e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|6
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|5
index|]
operator|)
operator|*
literal|6.028795e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|5
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|4
index|]
operator|)
operator|*
literal|5.028552e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|4
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|)
operator|*
literal|4.003697e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|)
operator|*
literal|2.985303e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|)
operator|*
literal|2.003159e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|)
operator|*
literal|1.084671e-01
expr_stmt|;
name|lpf
operator|+=
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|=
name|disc
operator|*
literal|2.538771e-02
expr_stmt|;
comment|/* 	 * Maximum likelihood decoder. The UART updates each of the 	 * eight survivors and determines the span, slice level and 	 * tentative decoded character. Valid 11-bit characters are 	 * framed so that bit 1 and bit 11 (stop bits) are mark and bit 	 * 2 (start bit) is space. When a valid character is found, the 	 * survivor with maximum distance determines the final decoded 	 * character. 	 */
name|up
operator|->
name|baud
operator|+=
literal|1.
operator|/
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|baud
operator|>
literal|1.
operator|/
operator|(
name|BAUD
operator|*
literal|8.
operator|)
condition|)
block|{
name|up
operator|->
name|baud
operator|-=
literal|1.
operator|/
operator|(
name|BAUD
operator|*
literal|8.
operator|)
expr_stmt|;
name|sp
operator|=
operator|&
name|up
operator|->
name|surv
index|[
name|up
operator|->
name|decptr
index|]
expr_stmt|;
name|span
operator|=
name|sp
operator|->
name|es_max
operator|-
name|sp
operator|->
name|es_min
expr_stmt|;
name|up
operator|->
name|maxsignal
operator|+=
operator|(
name|span
operator|-
name|up
operator|->
name|maxsignal
operator|)
operator|/
literal|80.
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|dbrk
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|dbrk
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|uart
operator|&
literal|0x403
operator|)
operator|==
literal|0x401
operator|&&
name|span
operator|>
literal|1000.
condition|)
block|{
name|dist
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|up
operator|->
name|surv
index|[
name|i
index|]
operator|.
name|dist
operator|>
name|dist
condition|)
block|{
name|dist
operator|=
name|up
operator|->
name|surv
index|[
name|i
index|]
operator|.
name|dist
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
block|}
name|chu_decode
argument_list|(
name|peer
argument_list|,
operator|(
name|up
operator|->
name|surv
index|[
name|j
index|]
operator|.
name|uart
operator|>>
literal|2
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|up
operator|->
name|dbrk
operator|=
literal|80
expr_stmt|;
block|}
name|up
operator|->
name|decptr
operator|=
operator|(
name|up
operator|->
name|decptr
operator|+
literal|1
operator|)
operator|%
literal|8
expr_stmt|;
name|chu_uart
argument_list|(
name|sp
argument_list|,
operator|-
name|lpf
operator|*
name|AGAIN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_uart - maximum likelihood UART  *  * This routine updates a shift register holding the last 11 envelope  * samples. It then computes the slice level and span over these samples  * and determines the tentative data bits and distance. The calling  * program selects over the last eight survivors the one with maximum  * distance to determine the decoded character.  */
end_comment

begin_function
specifier|static
name|void
name|chu_uart
parameter_list|(
name|struct
name|surv
modifier|*
name|sp
parameter_list|,
comment|/* survivor structure pointer */
name|double
name|sample
comment|/* baseband signal */
parameter_list|)
block|{
name|double
name|es_max
decl_stmt|,
name|es_min
decl_stmt|;
comment|/* max/min envelope */
name|double
name|slice
decl_stmt|;
comment|/* slice level */
name|double
name|dist
decl_stmt|;
comment|/* distance */
name|double
name|dtemp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Save the sample and shift right. At the same time, measure 	 * the maximum and minimum over all eleven samples. 	 */
name|es_max
operator|=
operator|-
literal|1e6
expr_stmt|;
name|es_min
operator|=
literal|1e6
expr_stmt|;
name|sp
operator|->
name|shift
index|[
literal|0
index|]
operator|=
name|sample
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|11
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sp
operator|->
name|shift
index|[
name|i
index|]
operator|=
name|sp
operator|->
name|shift
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|shift
index|[
name|i
index|]
operator|>
name|es_max
condition|)
name|es_max
operator|=
name|sp
operator|->
name|shift
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|shift
index|[
name|i
index|]
operator|<
name|es_min
condition|)
name|es_min
operator|=
name|sp
operator|->
name|shift
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* 	 * Determine the slice level midway beteen the maximum and 	 * minimum and the span as the maximum less the minimum. Compute 	 * the distance on the assumption the first and last bits must 	 * be mark, the second space and the rest either mark or space. 	 */
name|slice
operator|=
operator|(
name|es_max
operator|+
name|es_min
operator|)
operator|/
literal|2.
expr_stmt|;
name|dist
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|uart
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|->
name|uart
operator|<<=
literal|1
expr_stmt|;
name|dtemp
operator|=
name|sp
operator|->
name|shift
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
name|slice
condition|)
name|sp
operator|->
name|uart
operator||=
literal|0x1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
operator|||
name|i
operator|==
literal|11
condition|)
block|{
name|dist
operator|+=
name|dtemp
operator|-
name|es_min
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|10
condition|)
block|{
name|dist
operator|+=
name|es_max
operator|-
name|dtemp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dtemp
operator|>
name|slice
condition|)
name|dist
operator|+=
name|dtemp
operator|-
name|es_min
expr_stmt|;
else|else
name|dist
operator|+=
name|es_max
operator|-
name|dtemp
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|es_max
operator|=
name|es_max
expr_stmt|;
name|sp
operator|->
name|es_min
operator|=
name|es_min
expr_stmt|;
name|sp
operator|->
name|dist
operator|=
name|dist
operator|/
operator|(
literal|11
operator|*
operator|(
name|es_max
operator|-
name|es_min
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_comment
comment|/*  * chu_serial_receive - receive data from the serial device  */
end_comment

begin_function
specifier|static
name|void
name|chu_serial_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* receive buffer pointer */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Initialize pointers and read the timecode and timestamp. 	 */
name|up
operator|->
name|timestamp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|dpt
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
name|chu_decode
argument_list|(
name|peer
argument_list|,
operator|*
name|dpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_decode - decode the character data  */
end_comment

begin_function
specifier|static
name|void
name|chu_decode
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|hexhex
comment|/* data character */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|l_fp
name|tstmp
decl_stmt|;
comment|/* timestamp temp */
name|double
name|dtemp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * If the interval since the last character is greater than the 	 * longest burst, process the last burst and start a new one. If 	 * the interval is less than this but greater than two 	 * characters, consider this a noise burst and reject it. 	 */
name|tstmp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|up
operator|->
name|laststamp
argument_list|)
condition|)
name|up
operator|->
name|laststamp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tstmp
argument_list|,
operator|&
name|up
operator|->
name|laststamp
argument_list|)
expr_stmt|;
name|up
operator|->
name|laststamp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|tstmp
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
name|BURST
operator|*
name|CHAR
condition|)
block|{
name|chu_burst
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|ndx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtemp
operator|>
literal|2.5
operator|*
name|CHAR
condition|)
block|{
name|up
operator|->
name|ndx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Append the character to the current burst and append the 	 * timestamp to the timestamp list. 	 */
if|if
condition|(
name|up
operator|->
name|ndx
operator|<
name|BURST
condition|)
block|{
name|up
operator|->
name|cbuf
index|[
name|up
operator|->
name|ndx
index|]
operator|=
name|hexhex
operator|&
literal|0xff
expr_stmt|;
name|up
operator|->
name|cstamp
index|[
name|up
operator|->
name|ndx
index|]
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|up
operator|->
name|ndx
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_burst - search for valid burst format  */
end_comment

begin_function
specifier|static
name|void
name|chu_burst
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Correlate a block of five characters with the next block of 	 * five characters. The burst distance is defined as the number 	 * of bits that match in the two blocks for format A and that 	 * match the inverse for format B. 	 */
if|if
condition|(
name|up
operator|->
name|ndx
operator|<
name|MINCHAR
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|RUNT
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|burdist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
operator|&&
name|i
operator|<
name|up
operator|->
name|ndx
operator|-
literal|5
condition|;
name|i
operator|++
control|)
name|up
operator|->
name|burdist
operator|+=
name|chu_dist
argument_list|(
name|up
operator|->
name|cbuf
index|[
name|i
index|]
argument_list|,
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If the burst distance is at least MINDIST, this must be a 	 * format A burst; if the value is not greater than -MINDIST, it 	 * must be a format B burst. If the B burst is perfect, we 	 * believe it; otherwise, it is a noise burst and of no use to 	 * anybody. 	 */
if|if
condition|(
name|up
operator|->
name|burdist
operator|>=
name|MINDIST
condition|)
block|{
name|chu_a
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|ndx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|burdist
operator|<=
operator|-
name|MINDIST
condition|)
block|{
name|chu_b
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|ndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|status
operator||=
name|NOISE
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is a valid burst, wait a guard time of ten seconds to 	 * allow for more bursts, then arm the poll update routine to 	 * process the minute. Don't do this if this is called from the 	 * timer interrupt routine. 	 */
if|if
condition|(
name|peer
operator|->
name|outdate
operator|!=
name|current_time
condition|)
name|peer
operator|->
name|nextdate
operator|=
name|current_time
operator|+
literal|10
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_b - decode format B burst  */
end_comment

begin_function
specifier|static
name|void
name|chu_b
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|nchar
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|u_char
name|code
index|[
literal|11
index|]
decl_stmt|;
comment|/* decoded timecode */
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* trace buffer */
name|l_fp
name|offset
decl_stmt|;
comment|/* timestamp offset */
name|int
name|i
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * In a format B burst, a character is considered valid only if 	 * the first occurrence matches the last occurrence. The burst 	 * is considered valid only if all characters are valid; that 	 * is, only if the distance is 40.  	 */
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"chuB %04x %2d %2d "
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|nchar
argument_list|,
operator|-
name|up
operator|->
name|burdist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchar
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
operator|&
name|tbuf
index|[
name|strlen
argument_list|(
name|tbuf
argument_list|)
index|]
argument_list|,
literal|"%02x"
argument_list|,
name|up
operator|->
name|cbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|up
operator|->
name|burdist
operator|>
operator|-
literal|40
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|BFRAME
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|status
operator||=
name|INYEAR
expr_stmt|;
comment|/* 	 * Convert the burst data to internal format. If this succeeds, 	 * save the timestamps for later. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|code
index|[
literal|2
operator|*
name|i
index|]
operator|=
name|hexchar
index|[
name|up
operator|->
name|cbuf
index|[
name|i
index|]
operator|&
literal|0xf
index|]
expr_stmt|;
name|code
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|hexchar
index|[
operator|(
name|up
operator|->
name|cbuf
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|code
argument_list|,
literal|"%1x%1d%4d%2d%2x"
argument_list|,
operator|&
name|up
operator|->
name|leap
argument_list|,
operator|&
name|up
operator|->
name|dut
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|up
operator|->
name|tai
argument_list|,
operator|&
name|up
operator|->
name|dst
argument_list|)
operator|!=
literal|5
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|BFORMAT
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|up
operator|->
name|leap
operator|&
literal|0x8
condition|)
name|up
operator|->
name|dut
operator|=
operator|-
name|up
operator|->
name|dut
expr_stmt|;
name|offset
operator|.
name|l_ui
operator|=
literal|31
expr_stmt|;
name|offset
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchar
operator|&&
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|tstamp
index|[
name|up
operator|->
name|ntstamp
index|]
operator|=
name|up
operator|->
name|cstamp
index|[
name|i
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|tstamp
index|[
name|up
operator|->
name|ntstamp
index|]
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|up
operator|->
name|charstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ntstamp
operator|<
name|MAXSTAGE
condition|)
name|up
operator|->
name|ntstamp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_a - decode format A burst  */
end_comment

begin_function
specifier|static
name|void
name|chu_a
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|nchar
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* trace buffer */
name|l_fp
name|offset
decl_stmt|;
comment|/* timestamp offset */
name|int
name|val
decl_stmt|;
comment|/* distance */
name|int
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Determine correct burst phase. There are three cases 	 * corresponding to in-phase, one character early or one 	 * character late. These cases are distinguished by the position 	 * of the framing digits x6 at positions 0 and 5 and x3 at 	 * positions 4 and 9. The correct phase is when the distance 	 * relative to the framing digits is maximum. The burst is valid 	 * only if the maximum distance is at least MINSYNC. 	 */
name|up
operator|->
name|syndist
operator|=
name|k
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|-
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|4
index|]
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|temp
operator||=
operator|(
name|up
operator|->
name|cbuf
index|[
name|i
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
name|val
operator|=
name|chu_dist
argument_list|(
name|temp
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|5
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|9
operator|<
name|nchar
condition|)
name|temp
operator||=
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|9
index|]
operator|&
literal|0xf
expr_stmt|;
name|val
operator|+=
name|chu_dist
argument_list|(
name|temp
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|up
operator|->
name|syndist
condition|)
block|{
name|up
operator|->
name|syndist
operator|=
name|val
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
block|}
name|temp
operator|=
operator|(
name|up
operator|->
name|cbuf
index|[
name|k
operator|+
literal|4
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|9
operator|||
name|k
operator|+
literal|9
operator|>=
name|nchar
operator|||
name|temp
operator|!=
operator|(
operator|(
name|up
operator|->
name|cbuf
index|[
name|k
operator|+
literal|9
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AUDIO
if|if
condition|(
name|up
operator|->
name|fd_audio
condition|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"chuA %04x %4.0f %2d %2d %2d %2d %1d "
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|maxsignal
argument_list|,
name|nchar
argument_list|,
name|up
operator|->
name|burdist
argument_list|,
name|k
argument_list|,
name|up
operator|->
name|syndist
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"chuA %04x %2d %2d %2d %2d %1d "
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|nchar
argument_list|,
name|up
operator|->
name|burdist
argument_list|,
name|k
argument_list|,
name|up
operator|->
name|syndist
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"chuA %04x %2d %2d %2d %2d %1d "
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|nchar
argument_list|,
name|up
operator|->
name|burdist
argument_list|,
name|k
argument_list|,
name|up
operator|->
name|syndist
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUDIO */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchar
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
operator|&
name|tbuf
index|[
name|strlen
argument_list|(
name|tbuf
argument_list|)
index|]
argument_list|,
literal|"%02x"
argument_list|,
name|up
operator|->
name|cbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|up
operator|->
name|syndist
operator|<
name|MINSYNC
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|AFRAME
expr_stmt|;
return|return;
block|}
comment|/* 	 * A valid burst requires the first seconds number to match the 	 * last seconds number. If so, the burst timestamps are 	 * corrected to the current minute and saved for later 	 * processing. In addition, the seconds decode is advanced from 	 * the previous burst to the current one. 	 */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
name|offset
operator|.
name|l_ui
operator|=
literal|30
operator|+
name|temp
expr_stmt|;
name|offset
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|offset
operator|=
name|up
operator|->
name|charstamp
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nchar
operator|&&
name|i
operator|<
name|k
operator|+
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|tstamp
index|[
name|up
operator|->
name|ntstamp
index|]
operator|=
name|up
operator|->
name|cstamp
index|[
name|i
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|tstamp
index|[
name|up
operator|->
name|ntstamp
index|]
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|up
operator|->
name|charstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ntstamp
operator|<
name|MAXSTAGE
condition|)
name|up
operator|->
name|ntstamp
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|temp
operator|>
name|up
operator|->
name|prevsec
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|up
operator|->
name|decode
index|[
literal|9
index|]
index|[
name|j
index|]
operator|=
name|up
operator|->
name|decode
index|[
literal|9
index|]
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|up
operator|->
name|decode
index|[
literal|19
index|]
index|[
name|j
index|]
operator|=
name|up
operator|->
name|decode
index|[
literal|19
index|]
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|up
operator|->
name|decode
index|[
literal|9
index|]
index|[
name|j
index|]
operator|=
name|up
operator|->
name|decode
index|[
literal|19
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|prevsec
operator|++
expr_stmt|;
block|}
block|}
name|i
operator|=
operator|-
operator|(
literal|2
operator|*
name|k
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nchar
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|19
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
name|up
operator|->
name|decode
index|[
name|i
index|]
index|[
name|up
operator|->
name|cbuf
index|[
name|j
index|]
operator|&
literal|0xf
index|]
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|up
operator|->
name|decode
index|[
name|i
index|]
index|[
operator|(
name|up
operator|->
name|cbuf
index|[
name|j
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|up
operator|->
name|burstcnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|chu_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|char
name|synchar
decl_stmt|,
name|qual
decl_stmt|,
name|leapchar
decl_stmt|;
name|int
name|minset
decl_stmt|;
name|int
name|temp
decl_stmt|;
ifdef|#
directive|ifdef
name|ICOM
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* trace buffer */
endif|#
directive|endif
comment|/* ICOM */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
name|up
operator|->
name|errflg
operator|=
name|CEVNT_TIMEOUT
expr_stmt|;
else|else
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
name|minset
operator|=
operator|(
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
operator|+
literal|30
operator|)
operator|/
literal|60
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|INSYNC
condition|)
block|{
if|if
condition|(
name|minset
operator|>
name|PANIC
condition|)
name|up
operator|->
name|status
operator|=
literal|0
expr_stmt|;
else|else
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Process the last burst, if still in the burst buffer. 	 * Don't mess with anything if nothing has been heard. 	 */
name|chu_burst
argument_list|(
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICOM
if|if
condition|(
name|up
operator|->
name|burstcnt
operator|>
literal|2
condition|)
block|{
name|up
operator|->
name|dwell
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|dwell
operator|<
name|DWELL
condition|)
block|{
name|up
operator|->
name|dwell
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|dwell
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|chan
operator|=
operator|(
name|up
operator|->
name|chan
operator|+
literal|1
operator|)
operator|%
name|NCHAN
expr_stmt|;
name|icom_freq
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|,
name|peer
operator|->
name|ttlmax
operator|&
literal|0x7f
argument_list|,
name|qsy
index|[
name|up
operator|->
name|chan
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|up
operator|->
name|ident
argument_list|,
literal|"%.3f"
argument_list|,
name|qsy
index|[
name|up
operator|->
name|chan
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"chu: QSY to %s MHz"
argument_list|,
name|up
operator|->
name|ident
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* ICOM */
if|if
condition|(
name|up
operator|->
name|burstcnt
operator|==
literal|0
condition|)
return|return;
name|temp
operator|=
name|chu_major
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|INYEAR
condition|)
name|up
operator|->
name|status
operator||=
name|INSYNC
expr_stmt|;
name|qual
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
operator|(
name|BFRAME
operator||
name|AFRAME
operator|)
condition|)
name|qual
operator||=
name|SYNERR
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
operator|(
name|BFORMAT
operator||
name|AFORMAT
operator|)
condition|)
name|qual
operator||=
name|FMTERR
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|DECODE
condition|)
name|qual
operator||=
name|DECERR
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|STAMP
condition|)
name|qual
operator||=
name|TSPERR
expr_stmt|;
name|synchar
operator|=
name|leapchar
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|synchar
operator|=
literal|'?'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|leap
operator|&
literal|0x2
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|leapchar
operator|=
literal|'L'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|leap
operator|&
literal|0x4
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|leapchar
operator|=
literal|'l'
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_AUDIO
if|if
condition|(
name|up
operator|->
name|fd_audio
condition|)
name|sprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%c%1X %4d %3d %02d:%02d:%02d.000 %c%x %+d %d %d %s %d %d %d %d"
argument_list|,
name|synchar
argument_list|,
name|qual
argument_list|,
name|pp
operator|->
name|year
argument_list|,
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|leapchar
argument_list|,
name|up
operator|->
name|dst
argument_list|,
name|up
operator|->
name|dut
argument_list|,
name|minset
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|ident
argument_list|,
name|up
operator|->
name|tai
argument_list|,
name|up
operator|->
name|burstcnt
argument_list|,
name|up
operator|->
name|mindist
argument_list|,
name|up
operator|->
name|ntstamp
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%c%1X %4d %3d %02d:%02d:%02d.000 %c%x %+d %d %s %d %d %d %d"
argument_list|,
name|synchar
argument_list|,
name|qual
argument_list|,
name|pp
operator|->
name|year
argument_list|,
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|leapchar
argument_list|,
name|up
operator|->
name|dst
argument_list|,
name|up
operator|->
name|dut
argument_list|,
name|minset
argument_list|,
name|up
operator|->
name|ident
argument_list|,
name|up
operator|->
name|tai
argument_list|,
name|up
operator|->
name|burstcnt
argument_list|,
name|up
operator|->
name|mindist
argument_list|,
name|up
operator|->
name|ntstamp
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%c%1X %4d %3d %02d:%02d:%02d.000 %c%x %+d %d %s %d %d %d %d"
argument_list|,
name|synchar
argument_list|,
name|qual
argument_list|,
name|pp
operator|->
name|year
argument_list|,
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|leapchar
argument_list|,
name|up
operator|->
name|dst
argument_list|,
name|up
operator|->
name|dut
argument_list|,
name|minset
argument_list|,
name|up
operator|->
name|ident
argument_list|,
name|up
operator|->
name|tai
argument_list|,
name|up
operator|->
name|burstcnt
argument_list|,
name|up
operator|->
name|mindist
argument_list|,
name|up
operator|->
name|ntstamp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUDIO */
name|pp
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
comment|/* 	 * If timestamps have been stuffed, the timecode is ipso fatso 	 * correct and can be selected to discipline the clock. 	 */
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"chu: timecode %d %s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|chu_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errflg
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|errflg
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_major - majority decoder  */
end_comment

begin_function
specifier|static
name|int
name|chu_major
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|u_char
name|code
index|[
literal|11
index|]
decl_stmt|;
comment|/* decoded timecode */
name|l_fp
name|toffset
decl_stmt|,
name|offset
decl_stmt|;
comment|/* l_fp temps */
name|int
name|val1
decl_stmt|,
name|val2
decl_stmt|;
comment|/* maximum distance */
name|int
name|synchar
decl_stmt|;
comment|/* stray cat */
name|double
name|dtemp
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Majority decoder. Each burst encodes two replications at each 	 * digit position in the timecode. Each row of the decoding 	 * matrix encodes the number of occurences of each digit found 	 * at the corresponding position. The maximum over all 	 * occurences at each position is the distance for this position 	 * and the corresponding digit is the maximumn likelihood 	 * candidate. If the distance is zero, assume a miss '_'; if the 	 * distance is not more than half the total number of 	 * occurences, assume a soft error '-'; if two different digits 	 * with the same distance are found, assume a hard error '='. 	 * These will later cause a format error when the timecode is 	 * interpreted. The decoding distance is defined as the minimum 	 * distance over the first nine digits. The tenth digit varies 	 * over the seconds, so we don't count it. 	 */
name|up
operator|->
name|mindist
operator|=
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|val1
operator|=
name|val2
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
name|temp
operator|=
name|up
operator|->
name|decode
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|up
operator|->
name|decode
index|[
name|i
operator|+
literal|10
index|]
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|val1
condition|)
block|{
name|val2
operator|=
name|val1
expr_stmt|;
name|val1
operator|=
name|temp
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val1
operator|==
literal|0
condition|)
name|code
index|[
name|i
index|]
operator|=
name|HEX_MISS
expr_stmt|;
elseif|else
if|if
condition|(
name|val1
operator|==
name|val2
condition|)
name|code
index|[
name|i
index|]
operator|=
name|HEX_HARD
expr_stmt|;
elseif|else
if|if
condition|(
name|val1
operator|<=
name|up
operator|->
name|burstcnt
condition|)
name|code
index|[
name|i
index|]
operator|=
name|HEX_SOFT
expr_stmt|;
else|else
name|code
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|val1
operator|<
name|up
operator|->
name|mindist
condition|)
name|up
operator|->
name|mindist
operator|=
name|val1
expr_stmt|;
name|code
index|[
name|i
index|]
operator|=
name|hexchar
index|[
name|code
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
name|code
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * A valid timecode requires at least three bursts and a 	 * decoding distance greater than half the total number of 	 * occurences. A valid timecode also requires at least 20 valid 	 * timestamps. 	 */
if|if
condition|(
name|up
operator|->
name|burstcnt
operator|<
literal|3
operator|||
name|up
operator|->
name|mindist
operator|<=
name|up
operator|->
name|burstcnt
condition|)
name|up
operator|->
name|status
operator||=
name|DECODE
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ntstamp
operator|<
name|MINSTAMP
condition|)
name|up
operator|->
name|status
operator||=
name|STAMP
expr_stmt|;
comment|/* 	 * Compute the timecode timestamp from the days, hours and 	 * minutes of the timecode. Use clocktime() for the aggregate 	 * minutes and the minute offset computed from the burst 	 * seconds. Note that this code relies on the filesystem time 	 * for the years and does not use the years of the timecode. 	 */
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|code
argument_list|,
literal|"%1x%3d%2d%2d"
argument_list|,
operator|&
name|synchar
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|AFORMAT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|up
operator|->
name|status
operator|&
operator|(
name|DECODE
operator||
name|STAMP
operator|)
condition|)
block|{
name|up
operator|->
name|errflg
operator|=
name|CEVNT_BADREPLY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|L_CLR
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
literal|0
argument_list|,
name|GMT
argument_list|,
name|up
operator|->
name|tstamp
index|[
literal|0
index|]
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|&
name|offset
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|up
operator|->
name|errflg
operator|=
name|CEVNT_BADTIME
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|lastref
operator|=
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|up
operator|->
name|ntstamp
condition|;
name|i
operator|++
control|)
block|{
name|toffset
operator|=
name|offset
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|toffset
argument_list|,
operator|&
name|up
operator|->
name|tstamp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|toffset
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
name|SAMPLE
argument_list|(
name|dtemp
operator|+
name|FUDGE
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * chu_clear - clear decoding matrix  */
end_comment

begin_function
specifier|static
name|void
name|chu_clear
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Clear stuff for the minute. 	 */
name|up
operator|->
name|ndx
operator|=
name|up
operator|->
name|prevsec
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|burstcnt
operator|=
name|up
operator|->
name|mindist
operator|=
name|up
operator|->
name|ntstamp
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|status
operator|&=
name|INSYNC
operator||
name|INYEAR
expr_stmt|;
name|up
operator|->
name|burstcnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
name|up
operator|->
name|decode
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_dist - determine the distance of two octet arguments  */
end_comment

begin_function
specifier|static
name|int
name|chu_dist
parameter_list|(
name|int
name|x
parameter_list|,
comment|/* an octet of bits */
name|int
name|y
comment|/* another octet of bits */
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
comment|/* bit count */
name|int
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * The distance is determined as the weight of the exclusive OR 	 * of the two arguments. The weight is determined by the number 	 * of one bits in the result. Each one bit increases the weight, 	 * while each zero bit decreases it. 	 */
name|temp
operator|=
name|x
operator|^
name|y
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|temp
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
name|val
operator|++
expr_stmt|;
else|else
name|val
operator|--
expr_stmt|;
name|temp
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_comment
comment|/*  * chu_gain - adjust codec gain  *  * This routine is called once each second. If the signal envelope  * amplitude is too low, the codec gain is bumped up by four units; if  * too high, it is bumped down. The decoder is relatively insensitive to  * amplitude, so this crudity works just fine. The input port is set and  * the error flag is cleared, mostly to be ornery.  */
end_comment

begin_function
specifier|static
name|void
name|chu_gain
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Apparently, the codec uses only the high order bits of the 	 * gain control field. Thus, it may take awhile for changes to 	 * wiggle the hardware bits. 	 */
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|gain
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|>
literal|255
condition|)
name|up
operator|->
name|gain
operator|=
literal|255
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|>
name|SECOND
operator|/
literal|100
condition|)
block|{
name|up
operator|->
name|gain
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|<
literal|0
condition|)
name|up
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
block|}
name|audio_gain
argument_list|(
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|port
argument_list|)
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_chu_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

