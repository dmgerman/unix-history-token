begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_chu - clock driver for Canadian radio CHU receivers  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_CHU
argument_list|)
end_if

begin_comment
comment|/* #define AUDIO_CHUa */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIO_CHU
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_AUDIOIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/audioio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_AUDIOIO_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SUN_AUDIOIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sun/audioio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SUN_AUDIOIO_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUDIO_CHU */
end_comment

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Clock driver for Canadian radio CHU receivers  *  * This driver synchronizes the computer time using data encoded in  * radio transmissions from Canadian time/frequency station CHU in  * Ottawa, Ontario. Transmissions are made continuously on 3330 kHz,  * 7335 kHz and 14670 kHz in upper sideband, compatible AM mode. An  * ordinary shortwave receiver can be tuned manually to one of these  * frequencies or, in the case of ICOM receivers, the receiver can be  * tuned automatically using the minimuf and icom programs as  * propagation conditions change throughout the day and night.  *  * The driver can be compiled to use a Bell 103 compatible modem or  * modem chip to receive the radio signal and demodulate the data.  * Alternatively, the driver can be compiled to use the audio codec of  * the Sun workstation or another with compatible audio drivers. In the  * latter case, the driver implements the modem using DSP routines, so  * the radio can be connected directly to either the microphone on line  * input port. In either case, the driver decodes the data using a  * maximum likelihood technique which exploits the considerable degree  * of redundancy available to maximize accuracy and minimize errors.  *  * The CHU time broadcast includes an audio signal compatible with the  * Bell 103 modem standard (mark = 2225 Hz, space = 2025 Hz). It consist  * of nine, ten-character bursts transmitted at 300 bps and beginning  * each second from second 31 to second 39 of the minute. Each character  * consists of eight data bits plus one start bit and two stop bits to  * encode two hex digits. The burst data consist of five characters (ten  * hex digits) followed by a repeat of these characters. In format A,  * the characters are repeated in the same polarity; in format B, the  * characters are repeated in the opposite polarity.  *  * Format A bursts are sent at seconds 32 through 39 of the minute in  * hex digits  *  *	6dddhhmmss6dddhhmmss  *  * The first ten digits encode a frame marker (6) followed by the day  * (ddd), hour (hh in UTC), minute (mm) and the second (ss). Since  * format A bursts are sent during the third decade of seconds the tens  * digit of ss is always 3. The driver uses this to determine correct  * burst synchronization. These digits are then repeated with the same  * polarity.  *  * Format B bursts are sent at second 31 of the minute in hex digits  *  *	xdyyyyttaaxdyyyyttaa  *  * The first ten digits encode a code (x described below) followed by  * the DUT1 (d in deciseconds), Gregorian year (yyyy), difference TAI -  * UTC (tt) and daylight time indicator (aa) peculiar to Canada. These  * digits are then repeated with inverted polarity.  *  * The x is coded  *  * 1 Sign of DUT (0 = +)  * 2 Leap second warning. One second will be added.  * 4 Leap second warning. One second will be subtracted.  * 8 Even parity bit for this nibble.  *  * By design, the last stop bit of the last character in the burst  * coincides with 0.5 second. Since characters have 11 bits and are  * transmitted at 300 bps, the last stop bit of the first character  * coincides with 0.5 - 10 * 11/300 = 0.133 second. Depending on the  * UART, character interrupts can vary somewhere between the beginning  * of bit 9 and end of bit 11. These eccentricities can be corrected  * along with the radio propagation delay using fudge time 1.  *  * Debugging aids  *  * The timecode format used for debugging and data recording includes  * data helpful in diagnosing problems with the radio signal and serial  * connections. With debugging enabled (-d -d -d on the ntpd command  * line), the driver produces one line for each burst in two formats  * corresponding to format A and B. Following is format A:  *  *	n b f s m code  *  * where n is the number of characters in the burst (0-11), b the burst  * distance (0-40), f the field alignment (-1, 0, 1), s the  * synchronization distance (0-16), m the burst number (2-9) and code  * the burst characters as received. Note that the hex digits in each  * character are reversed, so the burst  *  *	10 38 0 16 9 06851292930685129293  *  * is interpreted as containing 11 characters with burst distance 38,  * field alignment 0, synchronization distance 16 and burst number 9.  * The nibble-swapped timecode shows day 58, hour 21, minute 29 and  * second 39.  *  * When the audio driver is compiled, format A is preceded by  * the current gain (0-255) and relative signal level (0-9999). The  * receiver folume control should be set so that the gain is somewhere  * near the middle of the range 0-255, which results in a signal level  * near 1000.  *  * Following is format B:  *   *	n b s code  *  * where n is the number of characters in the burst (0-11), b the burst  * distance (0-40), s the synchronization distance (0-40) and code the  * burst characters as received. Note that the hex digits in each  * character are reversed and the last ten digits inverted, so the burst  *  *	11 40 1091891300ef6e76ecff  *  * is interpreted as containing 11 characters with burst distance 40.  * The nibble-swapped timecode shows DUT1 +0.1 second, year 1998 and TAI  * - UTC 31 seconds.  *  * In addition to the above, the reference timecode is updated and  * written to the clockstats file and debug score after the last burst  * received in the minute. The format is  *  *	qq yyyy ddd hh:mm:ss nn dd tt  *  * where qq are the error flags, as described below, yyyy is the year,  * ddd the day, hh:mm:ss the time of day, nn the number of format A  * bursts received during the previous minute, dd the decoding distance  * and tt the number of timestamps. The error flags are cleared after  * every update.  *  * Fudge factors  *  * For accuracies better than the low millisceconds, fudge time1 can be  * set to the radio propagation delay from CHU to the receiver. This can  * be done conviently using the minimuf program. When the modem driver  * is compiled, fudge flag3 enables the ppsclock line discipline. Fudge  * flag4 causes the dubugging output described above to be recorded in  * the clockstats file.  *  * When the audio driver is compiled, fudge flag2 selects the audio  * input port, where 0 is the mike port (default) and 1 is the line-in  * port. It does not seem useful to select the compact disc player port.  * Fudge flag3 enables audio monitoring of the input signal. For this  * purpose, the speaker volume must be set before the driver is started.   */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B300
end_define

begin_comment
comment|/* uart speed (300 baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"CHU"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIO_CHU
end_ifdef

begin_define
define|#
directive|define
name|DESCRIPTION
value|"CHU Modem Receiver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_comment
comment|/*  * Audio demodulator definitions  */
end_comment

begin_define
define|#
directive|define
name|AUDIO_BUFSIZ
value|160
end_define

begin_comment
comment|/* codec buffer size (Solaris only) */
end_comment

begin_define
define|#
directive|define
name|SAMPLE
value|8000
end_define

begin_comment
comment|/* nominal sample rate (Hz) */
end_comment

begin_define
define|#
directive|define
name|BAUD
value|300
end_define

begin_comment
comment|/* modulation rate (bps) */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|128
end_define

begin_comment
comment|/* companded sample offset */
end_comment

begin_define
define|#
directive|define
name|SIZE
value|256
end_define

begin_comment
comment|/* decompanding table size */
end_comment

begin_define
define|#
directive|define
name|MAXSIG
value|6000.
end_define

begin_comment
comment|/* maximum signal level */
end_comment

begin_define
define|#
directive|define
name|DRPOUT
value|100.
end_define

begin_comment
comment|/* dropout signal level */
end_comment

begin_define
define|#
directive|define
name|LIMIT
value|1000.
end_define

begin_comment
comment|/* soft limiter threshold */
end_comment

begin_define
define|#
directive|define
name|AGAIN
value|6.
end_define

begin_comment
comment|/* baseband gain */
end_comment

begin_define
define|#
directive|define
name|LAG
value|10
end_define

begin_comment
comment|/* discriminator lag */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/chu%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B300
end_define

begin_comment
comment|/* UART speed (300 baud) */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"CHU Audio Receiver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUDIO_CHU */
end_comment

begin_comment
comment|/*  * Decoder definitions  */
end_comment

begin_define
define|#
directive|define
name|CHAR
value|(11. / 300.)
end_define

begin_comment
comment|/* character time (s) */
end_comment

begin_define
define|#
directive|define
name|FUDGE
value|.185
end_define

begin_comment
comment|/* offset to first stop bit (s) */
end_comment

begin_define
define|#
directive|define
name|BURST
value|11
end_define

begin_comment
comment|/* max characters per burst */
end_comment

begin_define
define|#
directive|define
name|MINCHAR
value|9
end_define

begin_comment
comment|/* min characters per burst */
end_comment

begin_define
define|#
directive|define
name|MINDIST
value|28
end_define

begin_comment
comment|/* min burst distance (of 40)  */
end_comment

begin_define
define|#
directive|define
name|MINSYNC
value|8
end_define

begin_comment
comment|/* min sync distance (of 16) */
end_comment

begin_define
define|#
directive|define
name|MINDEC
value|.5
end_define

begin_comment
comment|/* decoder majority rule (of 1.) */
end_comment

begin_define
define|#
directive|define
name|MINSTAMP
value|20
end_define

begin_comment
comment|/* min timestamps (of 60) */
end_comment

begin_comment
comment|/*  * Hex extension codes (>= 16)  */
end_comment

begin_define
define|#
directive|define
name|HEX_MISS
value|16
end_define

begin_comment
comment|/* miss */
end_comment

begin_define
define|#
directive|define
name|HEX_SOFT
value|17
end_define

begin_comment
comment|/* soft error */
end_comment

begin_define
define|#
directive|define
name|HEX_HARD
value|18
end_define

begin_comment
comment|/* hard error */
end_comment

begin_comment
comment|/*  * Error flags (up->errflg)  */
end_comment

begin_define
define|#
directive|define
name|CHU_ERR_RUNT
value|0x001
end_define

begin_comment
comment|/* runt burst */
end_comment

begin_define
define|#
directive|define
name|CHU_ERR_NOISE
value|0x002
end_define

begin_comment
comment|/* noise burst */
end_comment

begin_define
define|#
directive|define
name|CHU_ERR_BFRAME
value|0x004
end_define

begin_comment
comment|/* invalid format B frame sync */
end_comment

begin_define
define|#
directive|define
name|CHU_ERR_BFORMAT
value|0x008
end_define

begin_comment
comment|/* invalid format B data */
end_comment

begin_define
define|#
directive|define
name|CHU_ERR_AFRAME
value|0x010
end_define

begin_comment
comment|/* invalid format A frame sync */
end_comment

begin_define
define|#
directive|define
name|CHU_ERR_DECODE
value|0x020
end_define

begin_comment
comment|/* invalid data decode */
end_comment

begin_define
define|#
directive|define
name|CHU_ERR_STAMP
value|0x040
end_define

begin_comment
comment|/* too few timestamps */
end_comment

begin_define
define|#
directive|define
name|CHU_ERR_AFORMAT
value|0x080
end_define

begin_comment
comment|/* invalid format A data */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIO_CHU
end_ifdef

begin_define
define|#
directive|define
name|CHU_ERR_ERROR
value|0x100
end_define

begin_comment
comment|/* codec error (overrun) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUDIO_CHU */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIO_CHU
end_ifdef

begin_struct
struct|struct
name|surv
block|{
name|double
name|shift
index|[
literal|12
index|]
decl_stmt|;
comment|/* mark register */
name|double
name|max
decl_stmt|,
name|min
decl_stmt|;
comment|/* max/min envelope signals */
name|double
name|dist
decl_stmt|;
comment|/* sample distance */
name|int
name|uart
decl_stmt|;
comment|/* decoded character */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUDIO_CHU */
end_comment

begin_comment
comment|/*  * CHU unit control structure  */
end_comment

begin_struct
struct|struct
name|chuunit
block|{
name|u_char
name|decode
index|[
literal|20
index|]
index|[
literal|16
index|]
decl_stmt|;
comment|/* maximum likelihood decoding matrix */
name|l_fp
name|cstamp
index|[
name|BURST
index|]
decl_stmt|;
comment|/* character timestamps */
name|l_fp
name|tstamp
index|[
name|MAXSTAGE
index|]
decl_stmt|;
comment|/* timestamp samples */
name|l_fp
name|timestamp
decl_stmt|;
comment|/* current buffer timestamp */
name|l_fp
name|laststamp
decl_stmt|;
comment|/* last buffer timestamp */
name|l_fp
name|charstamp
decl_stmt|;
comment|/* character time as a l_fp */
name|int
name|errflg
decl_stmt|;
comment|/* error flags */
name|int
name|bufptr
decl_stmt|;
comment|/* buffer index pointer */
name|int
name|pollcnt
decl_stmt|;
comment|/* poll message counter */
comment|/* 	 * Character burst variables 	 */
name|int
name|cbuf
index|[
name|BURST
index|]
decl_stmt|;
comment|/* character buffer */
name|int
name|ntstamp
decl_stmt|;
comment|/* number of timestamp samples */
name|int
name|ndx
decl_stmt|;
comment|/* buffer start index */
name|int
name|prevsec
decl_stmt|;
comment|/* previous burst second */
name|int
name|burdist
decl_stmt|;
comment|/* burst distance */
name|int
name|syndist
decl_stmt|;
comment|/* sync distance */
name|int
name|burstcnt
decl_stmt|;
comment|/* format A bursts this minute */
ifdef|#
directive|ifdef
name|AUDIO_CHU
comment|/* 	 * Audio codec variables 	 */
name|double
name|comp
index|[
name|SIZE
index|]
decl_stmt|;
comment|/* decompanding table */
name|int
name|port
decl_stmt|;
comment|/* codec port */
name|int
name|gain
decl_stmt|;
comment|/* codec gain */
name|int
name|bufcnt
decl_stmt|;
comment|/* samples in buffer */
name|int
name|clipcnt
decl_stmt|;
comment|/* sample clip count */
name|int
name|seccnt
decl_stmt|;
comment|/* second interval counter */
comment|/* 	 * Modem variables 	 */
name|l_fp
name|tick
decl_stmt|;
comment|/* audio sample increment */
name|double
name|bpf
index|[
literal|9
index|]
decl_stmt|;
comment|/* IIR bandpass filter */
name|double
name|disc
index|[
name|LAG
index|]
decl_stmt|;
comment|/* discriminator shift register */
name|double
name|lpf
index|[
literal|27
index|]
decl_stmt|;
comment|/* FIR lowpass filter */
name|double
name|monitor
decl_stmt|;
comment|/* audio monitor */
name|double
name|maxsignal
decl_stmt|;
comment|/* signal level */
name|int
name|discptr
decl_stmt|;
comment|/* discriminator pointer */
comment|/* 	 * Maximum likelihood UART variables 	 */
name|double
name|baud
decl_stmt|;
comment|/* baud interval */
name|struct
name|surv
name|surv
index|[
literal|8
index|]
decl_stmt|;
comment|/* UART survivor structures */
name|int
name|decptr
decl_stmt|;
comment|/* decode pointer */
name|int
name|dbrk
decl_stmt|;
comment|/* holdoff counter */
endif|#
directive|endif
comment|/* AUDIO_CHU */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chu_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * More function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|chu_decode
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_burst
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_clear
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_update
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_year
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chu_dist
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIO_CHU
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|chu_uart
name|P
argument_list|(
operator|(
expr|struct
name|surv
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_rf
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_gain
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chu_audio
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_debug
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUDIO_CHU */
end_comment

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hexchar
index|[]
init|=
literal|"0123456789abcdef_-="
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIO_CHU
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_AUDIOIO_H
end_ifdef

begin_decl_stmt
name|struct
name|audio_device
name|device
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* audio device ident */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_AUDIOIO_H */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|audio_info
name|info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* audio device info */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chu_ctl_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* audio control file descriptor */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUDIO_CHU */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_chu
init|=
block|{
name|chu_start
block|,
comment|/* start up driver */
name|chu_shutdown
block|,
comment|/* shut down driver */
name|chu_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old chu_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old chu_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * chu_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|chu_start
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
ifdef|#
directive|ifdef
name|AUDIO_CHU
name|int
name|i
decl_stmt|;
comment|/* index */
name|double
name|step
decl_stmt|;
comment|/* codec adjustment */
comment|/* 	 * Open audio device 	 */
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/audio"
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"chu: audio"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* device name */
comment|/* 	 * Open serial port. Use RAW line discipline (required). 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_RAW
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* AUDIO_CHU */
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|chuunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|chuunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|chu_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DTOLFP
argument_list|(
name|CHAR
argument_list|,
operator|&
name|up
operator|->
name|charstamp
argument_list|)
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|AUDIO_CHU
name|up
operator|->
name|gain
operator|=
operator|(
name|AUDIO_MAX_GAIN
operator|-
name|AUDIO_MIN_GAIN
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|chu_audio
argument_list|()
operator|<
literal|0
condition|)
block|{
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * The companded samples are encoded sign-magnitude. The table 	 * contains all the 256 values in the interest of speed. 	 */
name|up
operator|->
name|comp
index|[
literal|0
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|OFFSET
index|]
operator|=
literal|0.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|1
index|]
operator|=
operator|-
literal|1.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|2
index|]
operator|=
operator|-
literal|3.
expr_stmt|;
name|step
operator|=
literal|2.
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|OFFSET
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|comp
index|[
name|i
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|step
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
name|i
index|]
operator|=
operator|-
name|up
operator|->
name|comp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
name|step
operator|*=
literal|2.
expr_stmt|;
block|}
name|DTOLFP
argument_list|(
literal|1.
operator|/
name|SAMPLE
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUDIO_CHU */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * chu_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|chu_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIO_CHU
end_ifdef

begin_comment
comment|/*  * chu_receive - receive data from the audio device  */
end_comment

begin_function
specifier|static
name|void
name|chu_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|sample
decl_stmt|;
comment|/* codec sample */
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* buffer pointer */
name|l_fp
name|ltemp
decl_stmt|;
comment|/* l_fp temp */
name|double
name|dtemp
decl_stmt|;
comment|/* double temp */
name|int
name|isneg
decl_stmt|;
comment|/* parity flag */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* index temps */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Main loop - read until there ain't no more. Note codec 	 * samples are bit-inverted. 	 */
name|up
operator|->
name|timestamp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|up
operator|->
name|bufcnt
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|DTOLFP
argument_list|(
name|up
operator|->
name|bufcnt
operator|*
literal|1.
operator|/
name|SAMPLE
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|dpt
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
for|for
control|(
name|up
operator|->
name|bufptr
operator|=
literal|0
init|;
name|up
operator|->
name|bufptr
operator|<
name|up
operator|->
name|bufcnt
condition|;
name|up
operator|->
name|bufptr
operator|++
control|)
block|{
name|sample
operator|=
name|up
operator|->
name|comp
index|[
operator|~
operator|*
name|dpt
operator|&
literal|0xff
index|]
expr_stmt|;
comment|/* 		 * Clip noise spikes greater than MAXSIG. If no clips, 		 * increase the gain a tad; if the clips are too high,  		 * decrease a tad. 		 */
if|if
condition|(
name|sample
operator|>
name|MAXSIG
condition|)
block|{
name|sample
operator|=
name|MAXSIG
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sample
operator|<
operator|-
name|MAXSIG
condition|)
block|{
name|sample
operator|=
operator|-
name|MAXSIG
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
name|up
operator|->
name|seccnt
operator|=
operator|(
name|up
operator|->
name|seccnt
operator|+
literal|1
operator|)
operator|%
name|SAMPLE
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|seccnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
name|up
operator|->
name|port
operator|=
name|AUDIO_LINE_IN
expr_stmt|;
else|else
name|up
operator|->
name|port
operator|=
name|AUDIO_MICROPHONE
expr_stmt|;
name|chu_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|=
literal|0
expr_stmt|;
block|}
name|chu_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
comment|/* 		 * During development, it is handy to have an audio 		 * monitor that can be switched to various signals. This 		 * code converts the linear signal left in up->monitor 		 * to codec format. If we can get the grass out of this 		 * thing and improve modem performance, this expensive 		 * code will be permanently nixed. 		 */
name|isneg
operator|=
literal|0
expr_stmt|;
name|dtemp
operator|=
name|up
operator|->
name|monitor
expr_stmt|;
if|if
condition|(
name|sample
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|dtemp
operator|-=
name|dtemp
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|OFFSET
operator|>>
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dtemp
operator|>
name|up
operator|->
name|comp
index|[
name|i
index|]
condition|)
name|i
operator|+=
name|j
expr_stmt|;
elseif|else
if|if
condition|(
name|dtemp
operator|<
name|up
operator|->
name|comp
index|[
name|i
index|]
condition|)
name|i
operator|-=
name|j
expr_stmt|;
else|else
break|break;
name|j
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isneg
condition|)
operator|*
name|dpt
operator|=
operator|~
operator|(
name|i
operator|+
name|OFFSET
operator|)
expr_stmt|;
else|else
operator|*
name|dpt
operator|=
operator|~
name|i
expr_stmt|;
name|dpt
operator|++
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Squawk to the monitor speaker if enabled. 	 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
condition|)
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
argument_list|,
operator|(
name|u_int
operator|)
name|up
operator|->
name|bufcnt
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"chu:"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_rf - filter and demodulate the FSK signal  *  * This routine implements a 300-baud Bell 103 modem with mark 2225 Hz  * and space 2025 Hz. It uses a bandpass filter followed by a soft  * limiter, FM discriminator and lowpass filter. A maximum likelihood  * decoder samples the baseband signal at eight times the baud rate and  * detects the start bit of each character.  *  * The filters are built for speed, which explains the rather clumsy  * code. Hopefully, the compiler will efficiently implement the move-  * and-muiltiply-and-add operations.  */
end_comment

begin_function
name|void
name|chu_rf
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample
comment|/* analog sample */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|surv
modifier|*
name|sp
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|signal
decl_stmt|;
comment|/* bandpass signal */
name|double
name|limit
decl_stmt|;
comment|/* limiter signal */
name|double
name|disc
decl_stmt|;
comment|/* discriminator signal */
name|double
name|lpf
decl_stmt|;
comment|/* lowpass signal */
name|double
name|span
decl_stmt|;
comment|/* UART signal span */
name|double
name|dist
decl_stmt|;
comment|/* UART signal distance */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* index temps */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Bandpass filter. 4th-order elliptic, 500-Hz bandpass centered 	 * at 2125 Hz. Passband ripple 0.3 dB, stopband ripple 50 dB. 	 */
name|signal
operator|=
operator|(
name|up
operator|->
name|bpf
index|[
literal|8
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|)
operator|*
literal|5.844676e-01
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|)
operator|*
literal|4.884860e-01
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|)
operator|*
literal|2.704384e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|)
operator|*
literal|1.645032e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|)
operator|*
literal|4.644557e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|)
operator|*
literal|1.879165e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|)
operator|*
literal|3.522634e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|)
operator|*
literal|7.315738e-01
expr_stmt|;
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|=
name|sample
operator|-
name|signal
expr_stmt|;
name|signal
operator|=
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|*
literal|6.176213e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|*
literal|3.156599e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|*
literal|7.567487e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|*
literal|4.344580e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|*
literal|1.190128e-02
operator|+
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|*
literal|4.344580e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|*
literal|7.567487e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|*
literal|3.156599e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|8
index|]
operator|*
literal|6.176213e-03
expr_stmt|;
name|up
operator|->
name|monitor
operator|=
name|signal
operator|/
literal|4.
expr_stmt|;
comment|/* note monitor after filter */
comment|/* 	 * Soft limiter/discriminator. The 11-sample discriminator lag 	 * interval corresponds to three cycles of 2125 Hz, which 	 * requires the sample frequency to be 2125 * 11 / 3 = 7791.7 	 * Hz. The discriminator output varies +-0.5 interval for input 	 * frequency 2025-2225 Hz. However, we don't get to sample at 	 * this frequency, so the discriminator output is biased. Life 	 * at 8000 Hz sucks. 	 */
name|limit
operator|=
name|signal
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|LIMIT
condition|)
name|limit
operator|=
name|LIMIT
expr_stmt|;
elseif|else
if|if
condition|(
name|limit
operator|<
operator|-
name|LIMIT
condition|)
name|limit
operator|=
operator|-
name|LIMIT
expr_stmt|;
name|disc
operator|=
name|up
operator|->
name|disc
index|[
name|up
operator|->
name|discptr
index|]
operator|*
operator|-
name|limit
expr_stmt|;
name|up
operator|->
name|disc
index|[
name|up
operator|->
name|discptr
index|]
operator|=
name|limit
expr_stmt|;
name|up
operator|->
name|discptr
operator|=
operator|(
name|up
operator|->
name|discptr
operator|+
literal|1
operator|)
operator|%
name|LAG
expr_stmt|;
if|if
condition|(
name|disc
operator|>=
literal|0
condition|)
name|disc
operator|=
name|sqrt
argument_list|(
name|disc
argument_list|)
expr_stmt|;
else|else
name|disc
operator|=
operator|-
name|sqrt
argument_list|(
operator|-
name|disc
argument_list|)
expr_stmt|;
comment|/* 	 * Lowpass filter. Raised cosine, Ts = 1 / 300, beta = 0.1. 	 */
name|lpf
operator|=
operator|(
name|up
operator|->
name|lpf
index|[
literal|26
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|25
index|]
operator|)
operator|*
literal|2.538771e-02
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|25
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|24
index|]
operator|)
operator|*
literal|1.084671e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|24
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|23
index|]
operator|)
operator|*
literal|2.003159e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|23
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|22
index|]
operator|)
operator|*
literal|2.985303e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|22
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|21
index|]
operator|)
operator|*
literal|4.003697e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|21
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|20
index|]
operator|)
operator|*
literal|5.028552e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|20
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|19
index|]
operator|)
operator|*
literal|6.028795e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|19
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|18
index|]
operator|)
operator|*
literal|6.973249e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|18
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|17
index|]
operator|)
operator|*
literal|7.831828e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|17
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|16
index|]
operator|)
operator|*
literal|8.576717e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|16
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|15
index|]
operator|)
operator|*
literal|9.183463e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|15
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|14
index|]
operator|)
operator|*
literal|9.631951e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|14
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|13
index|]
operator|)
operator|*
literal|9.907208e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|13
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|12
index|]
operator|)
operator|*
literal|1.000000e+00
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|12
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|11
index|]
operator|)
operator|*
literal|9.907208e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|11
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|10
index|]
operator|)
operator|*
literal|9.631951e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|10
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|9
index|]
operator|)
operator|*
literal|9.183463e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|9
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|8
index|]
operator|)
operator|*
literal|8.576717e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|8
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|7
index|]
operator|)
operator|*
literal|7.831828e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|7
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|6
index|]
operator|)
operator|*
literal|6.973249e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|6
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|5
index|]
operator|)
operator|*
literal|6.028795e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|5
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|4
index|]
operator|)
operator|*
literal|5.028552e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|4
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|)
operator|*
literal|4.003697e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|)
operator|*
literal|2.985303e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|)
operator|*
literal|2.003159e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|)
operator|*
literal|1.084671e-01
expr_stmt|;
name|lpf
operator|+=
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|=
name|disc
operator|*
literal|2.538771e-02
expr_stmt|;
comment|/* printf("%8.3f %8.3f\n", disc, lpf); return; */
comment|/* 	 * Maximum likelihood decoder. The UART updates each of the 	 * eight survivors and determines the span, slice level and 	 * tentative decoded character. Valid 11-bit characters are 	 * framed so that bit 1 and bit 11 (stop bits) are mark and bit 	 * 2 (start bit) is space. When a valid character is found, the 	 * survivor with maximum distance determines the final decoded 	 * character. 	 */
name|up
operator|->
name|baud
operator|+=
literal|1.
operator|/
name|SAMPLE
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|baud
operator|>
literal|1.
operator|/
operator|(
name|BAUD
operator|*
literal|8.
operator|)
condition|)
block|{
name|up
operator|->
name|baud
operator|-=
literal|1.
operator|/
operator|(
name|BAUD
operator|*
literal|8.
operator|)
expr_stmt|;
name|sp
operator|=
operator|&
name|up
operator|->
name|surv
index|[
name|up
operator|->
name|decptr
index|]
expr_stmt|;
name|span
operator|=
name|sp
operator|->
name|max
operator|-
name|sp
operator|->
name|min
expr_stmt|;
name|up
operator|->
name|maxsignal
operator|+=
operator|(
name|span
operator|-
name|up
operator|->
name|maxsignal
operator|)
operator|/
literal|80.
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|dbrk
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|dbrk
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|uart
operator|&
literal|0x403
operator|)
operator|==
literal|0x401
operator|&&
name|span
operator|>
literal|1000.
condition|)
block|{
name|dist
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|up
operator|->
name|surv
index|[
name|i
index|]
operator|.
name|dist
operator|>
name|dist
condition|)
block|{
name|dist
operator|=
name|up
operator|->
name|surv
index|[
name|i
index|]
operator|.
name|dist
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
block|}
name|chu_decode
argument_list|(
name|peer
argument_list|,
operator|(
name|up
operator|->
name|surv
index|[
name|j
index|]
operator|.
name|uart
operator|>>
literal|2
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|up
operator|->
name|dbrk
operator|=
literal|80
expr_stmt|;
block|}
name|up
operator|->
name|decptr
operator|=
operator|(
name|up
operator|->
name|decptr
operator|+
literal|1
operator|)
operator|%
literal|8
expr_stmt|;
name|chu_uart
argument_list|(
name|sp
argument_list|,
operator|-
name|lpf
operator|*
name|AGAIN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_uart - maximum likelihood UART  *  * This routine updates a shift register holding the last 11 envelope  * samples. It then computes the slice level and span over these samples  * and determines the tentative data bits and distance. The calling  * program selects over the last eight survivors the one with maximum  * distance to determine the decoded character.  */
end_comment

begin_function
name|void
name|chu_uart
parameter_list|(
name|struct
name|surv
modifier|*
name|sp
parameter_list|,
comment|/* survivor structure pointer */
name|double
name|sample
comment|/* baseband signal */
parameter_list|)
block|{
comment|/* 	 * Local variables 	 */
name|double
name|max
decl_stmt|,
name|min
decl_stmt|;
comment|/* max/min envelope */
name|double
name|slice
decl_stmt|;
comment|/* slice level */
name|double
name|dist
decl_stmt|;
comment|/* distance */
name|double
name|dtemp
decl_stmt|;
comment|/* double temp */
name|int
name|i
decl_stmt|;
comment|/* index temp */
comment|/* 	 * Save the sample and shift right. At the same time, measure 	 * the maximum and minimum over all eleven samples. 	 */
name|max
operator|=
operator|-
literal|1e6
expr_stmt|;
name|min
operator|=
literal|1e6
expr_stmt|;
name|sp
operator|->
name|shift
index|[
literal|0
index|]
operator|=
name|sample
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|11
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sp
operator|->
name|shift
index|[
name|i
index|]
operator|=
name|sp
operator|->
name|shift
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|shift
index|[
name|i
index|]
operator|>
name|max
condition|)
name|max
operator|=
name|sp
operator|->
name|shift
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|shift
index|[
name|i
index|]
operator|<
name|min
condition|)
name|min
operator|=
name|sp
operator|->
name|shift
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* 	 * Determine the slice level midway beteen the maximum and 	 * minimum and the span as the maximum less the minimum. Compute 	 * the distance on the assumption the first and last bits must 	 * be mark, the second space and the rest either mark or space. 	 */
name|slice
operator|=
operator|(
name|max
operator|+
name|min
operator|)
operator|/
literal|2.
expr_stmt|;
name|dist
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|uart
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|->
name|uart
operator|<<=
literal|1
expr_stmt|;
name|dtemp
operator|=
name|sp
operator|->
name|shift
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
name|slice
condition|)
name|sp
operator|->
name|uart
operator||=
literal|0x1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
operator|||
name|i
operator|==
literal|11
condition|)
block|{
name|dist
operator|+=
name|dtemp
operator|-
name|min
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|10
condition|)
block|{
name|dist
operator|+=
name|max
operator|-
name|dtemp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dtemp
operator|>
name|slice
condition|)
name|dist
operator|+=
name|dtemp
operator|-
name|min
expr_stmt|;
else|else
name|dist
operator|+=
name|max
operator|-
name|dtemp
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|max
operator|=
name|max
expr_stmt|;
name|sp
operator|->
name|min
operator|=
name|min
expr_stmt|;
name|sp
operator|->
name|dist
operator|=
name|dist
operator|/
operator|(
literal|11
operator|*
operator|(
name|max
operator|-
name|min
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* AUDIO_CHU */
end_comment

begin_comment
comment|/*  * chu_receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|chu_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* receive buffer pointer */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Initialize pointers and read the timecode and timestamp. 	 */
name|up
operator|->
name|timestamp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|dpt
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
name|chu_decode
argument_list|(
name|peer
argument_list|,
operator|*
name|dpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUDIO_CHU */
end_comment

begin_comment
comment|/*  * chu_decode - decode the data  */
end_comment

begin_function
specifier|static
name|void
name|chu_decode
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|hexhex
comment|/* data character */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|l_fp
name|tstmp
decl_stmt|;
comment|/* timestamp temp */
name|double
name|dtemp
decl_stmt|;
comment|/* double temp */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * If the interval since the last character is greater than the 	 * longest burst, process the last burst and start a new one. If 	 * the interval is less than this but greater than two 	 * characters, consider this a noise burst and reject it. 	 */
name|tstmp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|up
operator|->
name|laststamp
argument_list|)
condition|)
name|up
operator|->
name|laststamp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tstmp
argument_list|,
operator|&
name|up
operator|->
name|laststamp
argument_list|)
expr_stmt|;
name|up
operator|->
name|laststamp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|tstmp
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
name|BURST
operator|*
name|CHAR
condition|)
block|{
name|chu_burst
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|ndx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtemp
operator|>
literal|2.5
operator|*
name|CHAR
condition|)
block|{
name|up
operator|->
name|ndx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Append the character to the current burst and append the 	 * timestamp to the timestamp list. 	 */
if|if
condition|(
name|up
operator|->
name|ndx
operator|<
name|BURST
condition|)
block|{
name|up
operator|->
name|cbuf
index|[
name|up
operator|->
name|ndx
index|]
operator|=
name|hexhex
operator|&
literal|0xff
expr_stmt|;
name|up
operator|->
name|cstamp
index|[
name|up
operator|->
name|ndx
index|]
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|up
operator|->
name|ndx
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_burst - search for valid burst format  */
end_comment

begin_function
specifier|static
name|void
name|chu_burst
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|int
name|i
decl_stmt|;
comment|/* index temp */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Correlate a block of five characters with the next block of 	 * five characters. The burst distance is defined as the number 	 * of bits that match in the two blocks for format A and that 	 * match the inverse for format B. 	 */
if|if
condition|(
name|up
operator|->
name|ndx
operator|<
name|MINCHAR
condition|)
block|{
name|up
operator|->
name|errflg
operator||=
name|CHU_ERR_RUNT
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|burdist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
operator|&&
name|i
operator|<
name|up
operator|->
name|ndx
operator|-
literal|5
condition|;
name|i
operator|++
control|)
name|up
operator|->
name|burdist
operator|+=
name|chu_dist
argument_list|(
name|up
operator|->
name|cbuf
index|[
name|i
index|]
argument_list|,
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If the burst distance is at least MINDIST, this must be a 	 * format A burst; if the value is not greater than -MINDIST, it 	 * must be a format B burst; otherwise, it is a noise burst and 	 * of no use to anybody. 	 */
if|if
condition|(
name|up
operator|->
name|burdist
operator|>=
name|MINDIST
condition|)
block|{
name|chu_update
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|ndx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|burdist
operator|<=
operator|-
name|MINDIST
condition|)
block|{
name|chu_year
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|ndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|errflg
operator||=
name|CHU_ERR_NOISE
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is a valid burst, wait a guard time of ten seconds to 	 * allow for more bursts, then arm the poll update routine to 	 * process the minute. Don't do this if this is called from the 	 * timer interrupt routine. 	 */
if|if
condition|(
name|peer
operator|->
name|outdate
operator|==
name|current_time
condition|)
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
else|else
name|peer
operator|->
name|nextdate
operator|=
name|current_time
operator|+
literal|10
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_year - decode format B burst  */
end_comment

begin_function
specifier|static
name|void
name|chu_year
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|nchar
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|u_char
name|code
index|[
literal|11
index|]
decl_stmt|;
comment|/* decoded timecode */
name|l_fp
name|offset
decl_stmt|;
comment|/* timestamp offset */
name|int
name|leap
decl_stmt|;
comment|/* leap/dut code */
name|int
name|dut
decl_stmt|;
comment|/* UTC1 correction */
name|int
name|tai
decl_stmt|;
comment|/* TAI - UTC correction */
name|int
name|dst
decl_stmt|;
comment|/* Canadian DST code */
name|int
name|i
decl_stmt|;
comment|/* index temp */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * In a format B burst, a character is considered valid only if 	 * the first occurrence matches the last occurrence. The burst 	 * is considered valid only if all characters are valid; that 	 * is, only if the distance is 40.  	 */
name|sprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%2d %2d "
argument_list|,
name|nchar
argument_list|,
operator|-
name|up
operator|->
name|burdist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchar
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
index|]
argument_list|,
literal|"%02x"
argument_list|,
name|up
operator|->
name|cbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"chu: %s\n"
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|-
name|up
operator|->
name|burdist
operator|<
literal|40
condition|)
block|{
name|up
operator|->
name|errflg
operator||=
name|CHU_ERR_BFRAME
expr_stmt|;
return|return;
block|}
comment|/* 	 * Convert the burst data to internal format. If this succeeds, 	 * save the timestamps for later. The leap, dut, tai and dst are 	 * presently unused. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|code
index|[
literal|2
operator|*
name|i
index|]
operator|=
name|hexchar
index|[
name|up
operator|->
name|cbuf
index|[
name|i
index|]
operator|&
literal|0xf
index|]
expr_stmt|;
name|code
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|hexchar
index|[
operator|(
name|up
operator|->
name|cbuf
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|code
argument_list|,
literal|"%1x%1d%4d%2d%2x"
argument_list|,
operator|&
name|leap
argument_list|,
operator|&
name|dut
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|tai
argument_list|,
operator|&
name|dst
argument_list|)
operator|!=
literal|5
condition|)
block|{
name|up
operator|->
name|errflg
operator||=
name|CHU_ERR_BFORMAT
expr_stmt|;
return|return;
block|}
name|offset
operator|.
name|l_ui
operator|=
literal|31
expr_stmt|;
name|offset
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchar
operator|&&
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|tstamp
index|[
name|up
operator|->
name|ntstamp
index|]
operator|=
name|up
operator|->
name|cstamp
index|[
name|i
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|tstamp
index|[
name|up
operator|->
name|ntstamp
index|]
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|up
operator|->
name|charstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ntstamp
operator|<
name|MAXSTAGE
condition|)
name|up
operator|->
name|ntstamp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_update - decode format A burst  */
end_comment

begin_function
specifier|static
name|void
name|chu_update
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|nchar
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|l_fp
name|offset
decl_stmt|;
comment|/* timestamp offset */
name|int
name|val
decl_stmt|;
comment|/* distance */
name|int
name|temp
decl_stmt|;
comment|/* common temp */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* index temps */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Determine correct burst phase. There are three cases 	 * corresponding to in-phase, one character early or one 	 * character late. These cases are distinguished by the position 	 * of the framing digits x6 at positions 0 and 5 and x3 at 	 * positions 4 and 9. The correct phase is when the distance 	 * relative to the framing digits is maximum. The burst is valid 	 * only if the maximum distance is at least MINSYNC. 	 */
name|up
operator|->
name|syndist
operator|=
name|k
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|-
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|4
index|]
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|temp
operator||=
operator|(
name|up
operator|->
name|cbuf
index|[
name|i
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
name|val
operator|=
name|chu_dist
argument_list|(
name|temp
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|5
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|9
operator|<
name|nchar
condition|)
name|temp
operator||=
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|9
index|]
operator|&
literal|0xf
expr_stmt|;
name|val
operator|+=
name|chu_dist
argument_list|(
name|temp
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|up
operator|->
name|syndist
condition|)
block|{
name|up
operator|->
name|syndist
operator|=
name|val
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
block|}
name|temp
operator|=
operator|(
name|up
operator|->
name|cbuf
index|[
name|k
operator|+
literal|4
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|9
operator|||
name|k
operator|+
literal|9
operator|>=
name|nchar
operator|||
name|temp
operator|!=
operator|(
operator|(
name|up
operator|->
name|cbuf
index|[
name|k
operator|+
literal|9
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AUDIO_CHU
name|sprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%3d %4.0f %2d %2d %2d %2d %1d "
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|maxsignal
argument_list|,
name|nchar
argument_list|,
name|up
operator|->
name|burdist
argument_list|,
name|k
argument_list|,
name|up
operator|->
name|syndist
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%2d %2d %2d %2d %1d "
argument_list|,
name|nchar
argument_list|,
name|up
operator|->
name|burdist
argument_list|,
name|k
argument_list|,
name|up
operator|->
name|syndist
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUDIO_CHU */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchar
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
index|]
argument_list|,
literal|"%02x"
argument_list|,
name|up
operator|->
name|cbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"chu: %s\n"
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|up
operator|->
name|syndist
operator|<
name|MINSYNC
condition|)
block|{
name|up
operator|->
name|errflg
operator||=
name|CHU_ERR_AFRAME
expr_stmt|;
return|return;
block|}
comment|/* 	 * A valid burst requires the first seconds number to match the 	 * last seconds number. If so, the burst timestamps are 	 * corrected to the current minute and saved for later 	 * processing. In addition, the seconds decode is advanced from 	 * the previous burst to the current one. 	 */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
name|offset
operator|.
name|l_ui
operator|=
literal|30
operator|+
name|temp
expr_stmt|;
name|offset
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|offset
operator|=
name|up
operator|->
name|charstamp
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nchar
operator|&&
name|i
operator|<
name|k
operator|+
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|tstamp
index|[
name|up
operator|->
name|ntstamp
index|]
operator|=
name|up
operator|->
name|cstamp
index|[
name|i
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|tstamp
index|[
name|up
operator|->
name|ntstamp
index|]
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|up
operator|->
name|charstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ntstamp
operator|<
name|MAXSTAGE
condition|)
name|up
operator|->
name|ntstamp
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|temp
operator|>
name|up
operator|->
name|prevsec
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|up
operator|->
name|decode
index|[
literal|9
index|]
index|[
name|j
index|]
operator|=
name|up
operator|->
name|decode
index|[
literal|9
index|]
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|up
operator|->
name|decode
index|[
literal|19
index|]
index|[
name|j
index|]
operator|=
name|up
operator|->
name|decode
index|[
literal|19
index|]
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|up
operator|->
name|decode
index|[
literal|9
index|]
index|[
name|j
index|]
operator|=
name|up
operator|->
name|decode
index|[
literal|19
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|prevsec
operator|++
expr_stmt|;
block|}
block|}
name|i
operator|=
operator|-
operator|(
literal|2
operator|*
name|k
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nchar
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|19
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
name|up
operator|->
name|decode
index|[
name|i
operator|++
index|]
index|[
name|up
operator|->
name|cbuf
index|[
name|j
index|]
operator|&
literal|0xf
index|]
operator|++
expr_stmt|;
name|up
operator|->
name|decode
index|[
name|i
operator|++
index|]
index|[
operator|(
name|up
operator|->
name|cbuf
index|[
name|j
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
operator|++
expr_stmt|;
block|}
name|up
operator|->
name|burstcnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|chu_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|u_char
name|code
index|[
literal|11
index|]
decl_stmt|;
comment|/* decoded timecode */
name|l_fp
name|toffset
decl_stmt|,
name|offset
decl_stmt|;
comment|/* l_fp temps */
name|int
name|mindist
decl_stmt|;
comment|/* minimum distance */
name|int
name|val1
decl_stmt|,
name|val2
decl_stmt|;
comment|/* maximum distance */
name|int
name|synchar
decl_stmt|;
comment|/* should be a 6 in traffic */
name|double
name|dtemp
decl_stmt|;
comment|/* double temp */
name|int
name|temp
decl_stmt|;
comment|/* common temp */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* index temps */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Process the last burst, if still in the burst buffer. 	 * Don't mess with anything if nothing has been heard. 	 */
name|chu_burst
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|pollcnt
operator|==
literal|0
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|pollcnt
operator|--
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|burstcnt
operator|==
literal|0
condition|)
block|{
name|chu_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Majority decoder. Select the character with the most 	 * occurrences for each burst position. The distance for the 	 * character is this number of occurrences. If no occurrences 	 * are found, assume a miss '_'; if only a single occurrence is 	 * found, assume a soft error '-'; if two different characters 	 * with the same distance are found, assume a hard error '='. 	 * The decoding distance is defined as the minimum of the 	 * character distances. 	 */
name|mindist
operator|=
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|val1
operator|=
name|val2
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
name|temp
operator|=
name|up
operator|->
name|decode
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|up
operator|->
name|decode
index|[
name|i
operator|+
literal|10
index|]
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|val1
condition|)
block|{
name|val2
operator|=
name|val1
expr_stmt|;
name|val1
operator|=
name|temp
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val1
operator|>
literal|0
operator|&&
name|val1
operator|==
name|val2
condition|)
name|code
index|[
name|i
index|]
operator|=
name|HEX_HARD
expr_stmt|;
elseif|else
if|if
condition|(
name|val1
operator|<
literal|2
condition|)
name|code
index|[
name|i
index|]
operator|=
name|HEX_SOFT
expr_stmt|;
else|else
name|code
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|val1
operator|<
name|mindist
condition|)
name|mindist
operator|=
name|val1
expr_stmt|;
name|code
index|[
name|i
index|]
operator|=
name|hexchar
index|[
name|code
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
name|code
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mindist
operator|<
name|up
operator|->
name|burstcnt
operator|*
literal|2
operator|*
name|MINDEC
condition|)
name|up
operator|->
name|errflg
operator||=
name|CHU_ERR_DECODE
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ntstamp
operator|<
name|MINSTAMP
condition|)
name|up
operator|->
name|errflg
operator||=
name|CHU_ERR_STAMP
expr_stmt|;
comment|/* 	 * Compute the timecode timestamp from the days, hours and 	 * minutes of the timecode. Use clocktime() for the aggregate 	 * minutes and the minute offset computed from the burst 	 * seconds. Note that this code relies on the filesystem time 	 * for the years and does not use the years of the timecode. 	 */
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|code
argument_list|,
literal|"%1x%3d%2d%2d"
argument_list|,
operator|&
name|synchar
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|)
operator|!=
literal|4
condition|)
name|up
operator|->
name|errflg
operator||=
name|CHU_ERR_AFORMAT
expr_stmt|;
name|sprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%02x %4d %3d %02d:%02d:%02d %2d %2d %2d"
argument_list|,
name|up
operator|->
name|errflg
argument_list|,
name|pp
operator|->
name|year
argument_list|,
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|up
operator|->
name|burstcnt
argument_list|,
name|mindist
argument_list|,
name|up
operator|->
name|ntstamp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"chu: %s\n"
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|up
operator|->
name|errflg
operator|&
operator|(
name|CHU_ERR_DECODE
operator||
name|CHU_ERR_STAMP
operator||
name|CHU_ERR_AFORMAT
operator|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|chu_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
name|L_CLR
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
literal|0
argument_list|,
name|GMT
argument_list|,
name|up
operator|->
name|tstamp
index|[
literal|0
index|]
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|&
name|offset
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
name|chu_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|pp
operator|->
name|lastref
operator|=
name|offset
expr_stmt|;
name|pp
operator|->
name|variance
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|up
operator|->
name|ntstamp
condition|;
name|i
operator|++
control|)
block|{
name|toffset
operator|=
name|offset
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|toffset
argument_list|,
operator|&
name|up
operator|->
name|tstamp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|toffset
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
name|SAMPLE
argument_list|(
name|dtemp
operator|+
name|FUDGE
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|chu_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_clear - clear decoding matrix  */
end_comment

begin_function
specifier|static
name|void
name|chu_clear
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* index temps */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Clear stuff for following minute. 	 */
name|up
operator|->
name|ndx
operator|=
name|up
operator|->
name|ntstamp
operator|=
name|up
operator|->
name|prevsec
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|errflg
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|burstcnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
name|up
operator|->
name|decode
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_dist - determine the distance of two octet arguments  */
end_comment

begin_function
specifier|static
name|int
name|chu_dist
parameter_list|(
name|int
name|x
parameter_list|,
comment|/* an octet of bits */
name|int
name|y
comment|/* another octet of bits */
parameter_list|)
block|{
comment|/* 	 * Local variables 	 */
name|int
name|val
decl_stmt|;
comment|/* bit count */
name|int
name|temp
decl_stmt|;
comment|/* misc temporary */
name|int
name|i
decl_stmt|;
comment|/* index temporary */
comment|/* 	 * The distance is determined as the weight of the exclusive OR 	 * of the two arguments. The weight is determined by the number 	 * of one bits in the result. Each one bit increases the weight, 	 * while each zero bit decreases it. 	 */
name|temp
operator|=
name|x
operator|^
name|y
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|temp
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
name|val
operator|++
expr_stmt|;
else|else
name|val
operator|--
expr_stmt|;
name|temp
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUDIO_CHU
end_ifdef

begin_comment
comment|/*  * chu_gain - adjust codec gain  *  * This routine is called once each second. If the signal envelope  * amplitude is too low, the codec gain is bumped up by four units; if  * too high, it is bumped down. The decoder is relatively insensitive to  * amplitude, so this crudity works just fine. The input port is set and  * the error flag is cleared, mostly to be ornery.  */
end_comment

begin_function
specifier|static
name|void
name|chu_gain
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Apparently, the codec uses only the high order bits of the 	 * gain control field. Thus, it may take awhile for changes to 	 * wiggle the hardware bits. Set the new bits in the structure 	 * and call AUDIO_SETINFO. Upon return, the old bits are in the 	 * structure. 	 */
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|gain
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|>
name|AUDIO_MAX_GAIN
condition|)
name|up
operator|->
name|gain
operator|=
name|AUDIO_MAX_GAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|>
name|SAMPLE
operator|/
literal|100
condition|)
block|{
name|up
operator|->
name|gain
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|<
name|AUDIO_MIN_GAIN
condition|)
name|up
operator|->
name|gain
operator|=
name|AUDIO_MIN_GAIN
expr_stmt|;
block|}
name|AUDIO_INITINFO
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|record
operator|.
name|port
operator|=
name|up
operator|->
name|port
expr_stmt|;
name|info
operator|.
name|record
operator|.
name|gain
operator|=
name|up
operator|->
name|gain
expr_stmt|;
name|info
operator|.
name|record
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|chu_ctl_fd
argument_list|,
operator|(
name|int
operator|)
name|AUDIO_SETINFO
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|record
operator|.
name|error
condition|)
name|up
operator|->
name|errflg
operator||=
name|CHU_ERR_ERROR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_audio - initialize audio device  *  * This code works with SunOS 4.1.3 and Solaris 2.6; however, it is  * believed generic and applicable to other systems with a minor twid  * or two. All it does is open the device, set the buffer size (Solaris  * only), preset the gain and set the input port. It assumes that the  * codec sample rate (8000 Hz), precision (8 bits), number of channels  * (1) and encoding (ITU-T G.711 mu-law companded) have been set by  * default.  */
end_comment

begin_function
specifier|static
name|int
name|chu_audio
parameter_list|( 	)
block|{
comment|/* 	 * Open audio control device 	 */
if|if
condition|(
operator|(
name|chu_ctl_fd
operator|=
name|open
argument_list|(
literal|"/dev/audioctl"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"audioctl"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_SYS_AUDIOIO_H
comment|/* 	 * Set audio device parameters. 	 */
name|AUDIO_INITINFO
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|record
operator|.
name|buffer_size
operator|=
name|AUDIO_BUFSIZ
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|chu_ctl_fd
argument_list|,
operator|(
name|int
operator|)
name|AUDIO_SETINFO
argument_list|,
operator|&
name|info
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"AUDIO_SETINFO"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|chu_ctl_fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_SYS_AUDIOIO_H */
ifdef|#
directive|ifdef
name|DEBUG
name|chu_debug
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * chu_debug - display audio parameters  *  * This code doesn't really do anything, except satisfy curiousity and  * verify the ioctl's work.  */
end_comment

begin_function
specifier|static
name|void
name|chu_debug
parameter_list|( 	)
block|{
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|HAVE_SYS_AUDIOIO_H
name|ioctl
argument_list|(
name|chu_ctl_fd
argument_list|,
operator|(
name|int
operator|)
name|AUDIO_GETDEV
argument_list|,
operator|&
name|device
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chu: name %s, version %s, config %s\n"
argument_list|,
name|device
operator|.
name|name
argument_list|,
name|device
operator|.
name|version
argument_list|,
name|device
operator|.
name|config
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SYS_AUDIOIO_H */
name|ioctl
argument_list|(
name|chu_ctl_fd
argument_list|,
operator|(
name|int
operator|)
name|AUDIO_GETINFO
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chu: samples %d, channels %d, precision %d, encoding %d\n"
argument_list|,
name|info
operator|.
name|record
operator|.
name|sample_rate
argument_list|,
name|info
operator|.
name|record
operator|.
name|channels
argument_list|,
name|info
operator|.
name|record
operator|.
name|precision
argument_list|,
name|info
operator|.
name|record
operator|.
name|encoding
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYS_AUDIOIO_H
name|printf
argument_list|(
literal|"chu: gain %d, port %d, buffer %d\n"
argument_list|,
name|info
operator|.
name|record
operator|.
name|gain
argument_list|,
name|info
operator|.
name|record
operator|.
name|port
argument_list|,
name|info
operator|.
name|record
operator|.
name|buffer_size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_SYS_AUDIOIO_H */
name|printf
argument_list|(
literal|"chu: gain %d, port %d\n"
argument_list|,
name|info
operator|.
name|record
operator|.
name|gain
argument_list|,
name|info
operator|.
name|record
operator|.
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SYS_AUDIOIO_H */
name|printf
argument_list|(
literal|"chu: samples %d, eof %d, pause %d, error %d, waiting %d, balance %d\n"
argument_list|,
name|info
operator|.
name|record
operator|.
name|samples
argument_list|,
name|info
operator|.
name|record
operator|.
name|eof
argument_list|,
name|info
operator|.
name|record
operator|.
name|pause
argument_list|,
name|info
operator|.
name|record
operator|.
name|error
argument_list|,
name|info
operator|.
name|record
operator|.
name|waiting
argument_list|,
name|info
operator|.
name|record
operator|.
name|balance
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chu: monitor %d, muted %d\n"
argument_list|,
name|info
operator|.
name|monitor_gain
argument_list|,
name|info
operator|.
name|output_muted
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUDIO_CHU */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_chu_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

