begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_timer.c - event timer support routines  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_leapsec.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntp_iocompletionport.h"
end_include

begin_include
include|#
directive|include
file|"ntp_timer.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SIGNAL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL_PLL
end_ifdef

begin_include
include|#
directive|include
file|"ntp_syscall.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOKEY */
end_comment

begin_comment
comment|/* TC_ERR represents the timer_create() error return value. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_VXWORKS
end_ifdef

begin_define
define|#
directive|define
name|TC_ERR
value|ERROR
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TC_ERR
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|check_leapsec
parameter_list|(
name|u_int32
parameter_list|,
specifier|const
name|time_t
modifier|*
parameter_list|,
name|int
comment|/*BOOL*/
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These routines provide support for the event timer.  The timer is  * implemented by an interrupt routine which sets a flag once every  * second, and a timer routine which is called when the mainline code  * gets around to seeing the flag.  The timer routine dispatches the  * clock adjustment code if its time has come, then searches the timer  * queue for expiries which are dispatched to the transmit procedure.  * Finally, we call the hourly procedure to do cleanup and print a  * message.  */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|interface_interval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* init_io() sets def. 300s */
end_comment

begin_comment
comment|/*  * Initializing flag.  All async routines watch this and only do their  * thing when it is clear.  */
end_comment

begin_decl_stmt
name|int
name|initializing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Alarm flag. The mainline code imports this.  */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|alarm_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The counters and timeouts  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|interface_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interface update timer */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|adjust_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* second timer */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|stats_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stats timer */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|leapf_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report leapfile problems once/day */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|huffpuff_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* huff-n'-puff timer */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|worker_idle_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next check for idle intres */
end_comment

begin_decl_stmt
name|u_long
name|leapsec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seconds to next leap (proximity class) */
end_comment

begin_decl_stmt
name|int
name|leapdif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TAI difference step at next leap second*/
end_comment

begin_decl_stmt
name|u_long
name|orphwait
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* orphan wait time */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_decl_stmt
specifier|static
name|u_long
name|revoke_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keys revoke timer */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|keys_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* session key timer */
end_comment

begin_decl_stmt
name|u_long
name|sys_revoke
init|=
name|KEY_REVOKE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keys revoke timeout (log2 s) */
end_comment

begin_decl_stmt
name|u_long
name|sys_automax
init|=
name|NTP_AUTOMAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key list timeout (log2 s) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOKEY */
end_comment

begin_comment
comment|/*  * Statistics counter for the interested.  */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|alarm_overflow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seconds since startup */
end_comment

begin_comment
comment|/*  * Stats.  Number of overflows and number of calls to transmit().  */
end_comment

begin_decl_stmt
name|u_long
name|timer_timereset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|timer_overflows
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|timer_xmtcalls
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|vmstimer
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time for next timer AST */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vmsinc
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timer increment */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_decl_stmt
name|HANDLE
name|WaitableTimerHandle
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|RETSIGTYPE
name|alarming
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
name|SYS_WINNT
operator|||
name|defined
argument_list|(
name|SYS_CYGWIN32
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMER_CREATE
end_ifdef

begin_decl_stmt
specifier|static
name|timer_t
name|timer_id
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|itimerspec
name|intervaltimer
typedef|;
end_typedef

begin_define
define|#
directive|define
name|itv_frac
value|tv_nsec
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|struct
name|itimerval
name|intervaltimer
typedef|;
end_typedef

begin_define
define|#
directive|define
name|itv_frac
value|tv_usec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|intervaltimer
name|itimer
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_function_decl
name|void
name|set_timer_or_die
parameter_list|(
specifier|const
name|intervaltimer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_function
name|void
name|set_timer_or_die
parameter_list|(
specifier|const
name|intervaltimer
modifier|*
name|ptimer
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|setfunc
decl_stmt|;
name|int
name|rc
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMER_CREATE
name|setfunc
operator|=
literal|"timer_settime"
expr_stmt|;
name|rc
operator|=
name|timer_settime
argument_list|(
name|timer_id
argument_list|,
literal|0
argument_list|,
operator|&
name|itimer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|setfunc
operator|=
literal|"setitimer"
expr_stmt|;
name|rc
operator|=
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"interval timer %s failed, %m"
argument_list|,
name|setfunc
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SYS_WINNT&& !VMS */
end_comment

begin_comment
comment|/*  * reinit_timer - reinitialize interval timer after a clock step.  */
end_comment

begin_function
name|void
name|reinit_timer
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
name|ZERO
argument_list|(
name|itimer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMER_CREATE
name|timer_gettime
argument_list|(
name|timer_id
argument_list|,
operator|&
name|itimer
argument_list|)
expr_stmt|;
else|#
directive|else
name|getitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|>
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
condition|)
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
if|if
condition|(
name|itimer
operator|.
name|it_value
operator|.
name|itv_frac
operator|<
literal|0
condition|)
name|itimer
operator|.
name|it_value
operator|.
name|itv_frac
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|&&
literal|0
operator|==
name|itimer
operator|.
name|it_value
operator|.
name|itv_frac
condition|)
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|itv_frac
operator|=
literal|0
expr_stmt|;
name|set_timer_or_die
argument_list|(
operator|&
name|itimer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
block|}
end_function

begin_comment
comment|/*  * init_timer - initialize the timer data structures  */
end_comment

begin_function
name|void
name|init_timer
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Initialize... 	 */
name|alarm_flag
operator|=
name|FALSE
expr_stmt|;
name|alarm_overflow
operator|=
literal|0
expr_stmt|;
name|adjust_timer
operator|=
literal|1
expr_stmt|;
name|stats_timer
operator|=
name|SECSPERHR
expr_stmt|;
name|leapf_timer
operator|=
name|SECSPERDAY
expr_stmt|;
name|huffpuff_timer
operator|=
literal|0
expr_stmt|;
name|interface_timer
operator|=
literal|0
expr_stmt|;
name|current_time
operator|=
literal|0
expr_stmt|;
name|timer_overflows
operator|=
literal|0
expr_stmt|;
name|timer_xmtcalls
operator|=
literal|0
expr_stmt|;
name|timer_timereset
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* 	 * Set up the alarm interrupt.	The first comes 2**EVENT_TIMEOUT 	 * seconds from now and they continue on every 2**EVENT_TIMEOUT 	 * seconds. 	 */
ifndef|#
directive|ifndef
name|VMS
ifdef|#
directive|ifdef
name|HAVE_TIMER_CREATE
if|if
condition|(
name|TC_ERR
operator|==
name|timer_create
argument_list|(
name|CLOCK_REALTIME
argument_list|,
name|NULL
argument_list|,
operator|&
name|timer_id
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"timer_create failed, %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|signal_no_reset
argument_list|(
name|SIGALRM
argument_list|,
name|alarming
argument_list|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|itv_frac
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|itv_frac
operator|=
literal|0
expr_stmt|;
name|set_timer_or_die
argument_list|(
operator|&
name|itimer
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS follows */
name|vmsinc
index|[
literal|0
index|]
operator|=
literal|10000000
expr_stmt|;
comment|/* 1 sec */
name|vmsinc
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|lib$emul
argument_list|(
operator|&
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
argument_list|,
operator|&
name|vmsinc
argument_list|,
operator|&
literal|0
argument_list|,
operator|&
name|vmsinc
argument_list|)
expr_stmt|;
name|sys$gettim
argument_list|(
operator|&
name|vmstimer
argument_list|)
expr_stmt|;
comment|/* that's "now" as abstime */
name|lib$addx
argument_list|(
operator|&
name|vmsinc
argument_list|,
operator|&
name|vmstimer
argument_list|,
operator|&
name|vmstimer
argument_list|)
expr_stmt|;
name|sys$setimr
argument_list|(
literal|0
argument_list|,
operator|&
name|vmstimer
argument_list|,
name|alarming
argument_list|,
name|alarming
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
else|#
directive|else
comment|/* SYS_WINNT follows */
comment|/* 	 * Set up timer interrupts for every 2**EVENT_TIMEOUT seconds 	 * Under Windows/NT, 	 */
name|WaitableTimerHandle
operator|=
name|CreateWaitableTimer
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|WaitableTimerHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"CreateWaitableTimer failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DWORD
name|Period
decl_stmt|;
name|LARGE_INTEGER
name|DueTime
decl_stmt|;
name|BOOL
name|rc
decl_stmt|;
name|Period
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
operator|*
literal|1000
expr_stmt|;
name|DueTime
operator|.
name|QuadPart
operator|=
name|Period
operator|*
literal|10000i
literal|64
expr_stmt|;
name|rc
operator|=
name|SetWaitableTimer
argument_list|(
name|WaitableTimerHandle
argument_list|,
operator|&
name|DueTime
argument_list|,
name|Period
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SetWaitableTimer failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
end_function

begin_comment
comment|/*  * intres_timeout_req(s) is invoked in the parent to schedule an idle  * timeout to fire in s seconds, if not reset earlier by a call to  * intres_timeout_req(0), which clears any pending timeout.  When the  * timeout expires, worker_idle_timer_fired() is invoked (again, in the  * parent).  *  * sntp and ntpd each provide implementations adapted to their timers.  */
end_comment

begin_function
name|void
name|intres_timeout_req
parameter_list|(
name|u_int
name|seconds
comment|/* 0 cancels */
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|seconds
condition|)
block|{
name|worker_idle_timer
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|worker_idle_timer
operator|=
name|current_time
operator|+
name|seconds
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * timer - event timer  */
end_comment

begin_function
name|void
name|timer
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|p
decl_stmt|;
name|struct
name|peer
modifier|*
name|next_peer
decl_stmt|;
name|l_fp
name|now
decl_stmt|;
name|time_t
name|tnow
decl_stmt|;
comment|/* 	 * The basic timerevent is one second.  This is used to adjust the 	 * system clock in time and frequency, implement the kiss-o'-death 	 * function and the association polling function. 	 */
name|current_time
operator|++
expr_stmt|;
if|if
condition|(
name|adjust_timer
operator|<=
name|current_time
condition|)
block|{
name|adjust_timer
operator|+=
literal|1
expr_stmt|;
name|adj_host_clock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
for|for
control|(
name|p
operator|=
name|peer_list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next_peer
control|)
block|{
name|next_peer
operator|=
name|p
operator|->
name|p_link
expr_stmt|;
if|if
condition|(
name|FLAG_REFCLOCK
operator|&
name|p
operator|->
name|flags
condition|)
name|refclock_timer
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
block|}
comment|/* 	 * Now dispatch any peers whose event timer has expired. Be 	 * careful here, since the peer structure might go away as the 	 * result of the call. 	 */
for|for
control|(
name|p
operator|=
name|peer_list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next_peer
control|)
block|{
name|next_peer
operator|=
name|p
operator|->
name|p_link
expr_stmt|;
comment|/* 		 * Restrain the non-burst packet rate not more 		 * than one packet every 16 seconds. This is 		 * usually tripped using iburst and minpoll of 		 * 128 s or less. 		 */
if|if
condition|(
name|p
operator|->
name|throttle
operator|>
literal|0
condition|)
name|p
operator|->
name|throttle
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nextdate
operator|<=
name|current_time
condition|)
block|{
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|FLAG_REFCLOCK
operator|&
name|p
operator|->
name|flags
condition|)
name|refclock_transmit
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* REFCLOCK */
name|transmit
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Orphan mode is active when enabled and when no servers less 	 * than the orphan stratum are available. A server with no other 	 * synchronization source is an orphan. It shows offset zero and 	 * reference ID the loopback address. 	 */
if|if
condition|(
name|sys_orphan
operator|<
name|STRATUM_UNSPEC
operator|&&
name|sys_peer
operator|==
name|NULL
operator|&&
name|current_time
operator|>
name|orphwait
condition|)
block|{
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
condition|)
block|{
name|set_sys_leap
argument_list|(
name|LEAP_NOWARNING
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|crypto_flags
condition|)
name|crypto_update
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
block|}
name|sys_stratum
operator|=
operator|(
name|u_char
operator|)
name|sys_orphan
expr_stmt|;
if|if
condition|(
name|sys_stratum
operator|>
literal|1
condition|)
name|sys_refid
operator|=
name|htonl
argument_list|(
name|LOOPBACKADR
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"LOOP"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sys_offset
operator|=
literal|0
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdisp
operator|=
literal|0
expr_stmt|;
block|}
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|tnow
argument_list|)
expr_stmt|;
comment|/* 	 * Leapseconds. Get time and defer to worker if either something 	 * is imminent or every 8th second. 	 */
if|if
condition|(
name|leapsec
operator|>
name|LSPROX_NOWARN
operator|||
literal|0
operator|==
operator|(
name|current_time
operator|&
literal|7
operator|)
condition|)
name|check_leapsec
argument_list|(
name|now
operator|.
name|l_ui
argument_list|,
operator|&
name|tnow
argument_list|,
operator|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
block|{
if|if
condition|(
name|leapsec
operator|>=
name|LSPROX_ANNOUNCE
operator|&&
name|leapdif
condition|)
block|{
if|if
condition|(
name|leapdif
operator|>
literal|0
condition|)
name|set_sys_leap
argument_list|(
name|LEAP_ADDSECOND
argument_list|)
expr_stmt|;
else|else
name|set_sys_leap
argument_list|(
name|LEAP_DELSECOND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_sys_leap
argument_list|(
name|LEAP_NOWARNING
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Update huff-n'-puff filter. 	 */
if|if
condition|(
name|huffpuff_timer
operator|<=
name|current_time
condition|)
block|{
name|huffpuff_timer
operator|+=
name|HUFFPUFF
expr_stmt|;
name|huffpuff
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * Garbage collect expired keys. 	 */
if|if
condition|(
name|keys_timer
operator|<=
name|current_time
condition|)
block|{
name|keys_timer
operator|+=
literal|1
operator|<<
name|sys_automax
expr_stmt|;
name|auth_agekeys
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Generate new private value. This causes all associations 	 * to regenerate cookies. 	 */
if|if
condition|(
name|revoke_timer
operator|&&
name|revoke_timer
operator|<=
name|current_time
condition|)
block|{
name|revoke_timer
operator|+=
literal|1
operator|<<
name|sys_revoke
expr_stmt|;
name|RAND_bytes
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sys_private
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 	 * Interface update timer 	 */
if|if
condition|(
name|interface_interval
operator|&&
name|interface_timer
operator|<=
name|current_time
condition|)
block|{
name|timer_interfacetimeout
argument_list|(
name|current_time
operator|+
name|interface_interval
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"timer: interface update\n"
operator|)
argument_list|)
expr_stmt|;
name|interface_update
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|worker_idle_timer
operator|&&
name|worker_idle_timer
operator|<=
name|current_time
condition|)
name|worker_idle_timer_fired
argument_list|()
expr_stmt|;
comment|/* 	 * Finally, write hourly stats and do the hourly 	 * and daily leapfile checks. 	 */
if|if
condition|(
name|stats_timer
operator|<=
name|current_time
condition|)
block|{
name|stats_timer
operator|+=
name|SECSPERHR
expr_stmt|;
name|write_stats
argument_list|()
expr_stmt|;
if|if
condition|(
name|leapf_timer
operator|<=
name|current_time
condition|)
block|{
name|leapf_timer
operator|+=
name|SECSPERDAY
expr_stmt|;
name|check_leap_file
argument_list|(
name|TRUE
argument_list|,
name|now
operator|.
name|l_ui
argument_list|,
operator|&
name|tnow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|check_leap_file
argument_list|(
name|FALSE
argument_list|,
name|now
operator|.
name|l_ui
argument_list|,
operator|&
name|tnow
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_comment
comment|/*  * alarming - tell the world we've been alarmed  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|alarming
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"alarming: initializing TRUE\n"
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|initializing
condition|)
block|{
if|if
condition|(
name|alarm_flag
condition|)
block|{
name|alarm_overflow
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|msg
operator|=
literal|"alarming: overflow\n"
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|VMS
name|alarm_flag
operator|++
expr_stmt|;
else|#
directive|else
comment|/* VMS AST routine, increment is no good */
name|alarm_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|msg
operator|=
literal|"alarming: normal\n"
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|VMS
name|lib$addx
argument_list|(
operator|&
name|vmsinc
argument_list|,
operator|&
name|vmstimer
argument_list|,
operator|&
name|vmstimer
argument_list|)
expr_stmt|;
name|sys$setimr
argument_list|(
literal|0
argument_list|,
operator|&
name|vmstimer
argument_list|,
name|alarming
argument_list|,
name|alarming
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
call|(
name|void
call|)
argument_list|(
operator|-
literal|1
operator|==
name|write
argument_list|(
literal|1
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_function
name|void
name|timer_interfacetimeout
parameter_list|(
name|u_long
name|timeout
parameter_list|)
block|{
name|interface_timer
operator|=
name|timeout
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * timer_clr_stats - clear timer module stat counters  */
end_comment

begin_function
name|void
name|timer_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|timer_overflows
operator|=
literal|0
expr_stmt|;
name|timer_xmtcalls
operator|=
literal|0
expr_stmt|;
name|timer_timereset
operator|=
name|current_time
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_leap_sec_in_progress
parameter_list|(
specifier|const
name|leap_result_t
modifier|*
name|lsdata
parameter_list|)
block|{
name|int
name|prv_leap_sec_in_progress
init|=
name|leap_sec_in_progress
decl_stmt|;
name|leap_sec_in_progress
operator|=
name|lsdata
operator|->
name|tai_diff
operator|&&
operator|(
name|lsdata
operator|->
name|ddist
operator|<
literal|3
operator|)
expr_stmt|;
comment|/* if changed we may have to update the leap status sent to clients */
if|if
condition|(
name|leap_sec_in_progress
operator|!=
name|prv_leap_sec_in_progress
condition|)
name|set_sys_leap
argument_list|(
name|sys_leap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_leapsec
parameter_list|(
name|u_int32
name|now
parameter_list|,
specifier|const
name|time_t
modifier|*
name|tpiv
parameter_list|,
name|int
comment|/*BOOL*/
name|reset
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|leapmsg_p_step
index|[]
init|=
literal|"Positive leap second, stepped backward."
decl_stmt|;
specifier|static
specifier|const
name|char
name|leapmsg_p_slew
index|[]
init|=
literal|"Positive leap second, no step correction. "
literal|"System clock will be inaccurate for a long time."
decl_stmt|;
specifier|static
specifier|const
name|char
name|leapmsg_n_step
index|[]
init|=
literal|"Negative leap second, stepped forward."
decl_stmt|;
specifier|static
specifier|const
name|char
name|leapmsg_n_slew
index|[]
init|=
literal|"Negative leap second, no step correction. "
literal|"System clock will be inaccurate for a long time."
decl_stmt|;
name|leap_result_t
name|lsdata
decl_stmt|;
name|u_int32
name|lsprox
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|int
comment|/*BOOL*/
name|update_autokey
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* WinNT port has its own leap second handling */
ifdef|#
directive|ifdef
name|KERNEL_PLL
name|leapsec_electric
argument_list|(
name|pll_control
operator|&&
name|kern_enable
argument_list|)
expr_stmt|;
else|#
directive|else
name|leapsec_electric
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LEAP_SMEAR
name|leap_smear
operator|.
name|enabled
operator|=
name|leap_smear_intv
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|reset
condition|)
block|{
name|lsprox
operator|=
name|LSPROX_NOWARN
expr_stmt|;
name|leapsec_reset_frame
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|lsdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lsdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|fired
decl_stmt|;
name|fired
operator|=
name|leapsec_query
argument_list|(
operator|&
name|lsdata
argument_list|,
name|now
argument_list|,
name|tpiv
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"*** leapsec_query: fired %i, now %u (0x%08X), tai_diff %i, ddist %u\n"
operator|,
name|fired
operator|,
name|now
operator|,
name|now
operator|,
name|lsdata
operator|.
name|tai_diff
operator|,
name|lsdata
operator|.
name|ddist
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAP_SMEAR
name|leap_smear
operator|.
name|in_progress
operator|=
literal|0
expr_stmt|;
name|leap_smear
operator|.
name|doffset
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|leap_smear
operator|.
name|enabled
condition|)
block|{
if|if
condition|(
name|lsdata
operator|.
name|tai_diff
condition|)
block|{
if|if
condition|(
name|leap_smear
operator|.
name|interval
operator|==
literal|0
condition|)
block|{
name|leap_smear
operator|.
name|interval
operator|=
name|leap_smear_intv
expr_stmt|;
name|leap_smear
operator|.
name|intv_end
operator|=
name|lsdata
operator|.
name|ttime
operator|.
name|Q_s
expr_stmt|;
name|leap_smear
operator|.
name|intv_start
operator|=
name|leap_smear
operator|.
name|intv_end
operator|-
name|leap_smear
operator|.
name|interval
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"*** leapsec_query: setting leap_smear interval %li, begin %.0f, end %.0f\n"
operator|,
name|leap_smear
operator|.
name|interval
operator|,
name|leap_smear
operator|.
name|intv_start
operator|,
name|leap_smear
operator|.
name|intv_end
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|leap_smear
operator|.
name|interval
condition|)
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"*** leapsec_query: clearing leap_smear interval\n"
operator|)
argument_list|)
expr_stmt|;
name|leap_smear
operator|.
name|interval
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|leap_smear
operator|.
name|interval
condition|)
block|{
name|double
name|dtemp
init|=
name|now
decl_stmt|;
if|if
condition|(
name|dtemp
operator|>=
name|leap_smear
operator|.
name|intv_start
operator|&&
name|dtemp
operator|<=
name|leap_smear
operator|.
name|intv_end
condition|)
block|{
name|double
name|leap_smear_time
init|=
name|dtemp
operator|-
name|leap_smear
operator|.
name|intv_start
decl_stmt|;
comment|/* 				 * For now we just do a linear interpolation over the smear interval 				 */
if|#
directive|if
literal|0
comment|// linear interpolation
block|leap_smear.doffset = -(leap_smear_time * lsdata.tai_diff / leap_smear.interval);
else|#
directive|else
comment|// Google approach: lie(t) = (1.0 - cos(pi * t / w)) / 2.0
name|leap_smear
operator|.
name|doffset
operator|=
operator|-
operator|(
operator|(
name|double
operator|)
name|lsdata
operator|.
name|tai_diff
operator|-
name|cos
argument_list|(
name|M_PI
operator|*
name|leap_smear_time
operator|/
name|leap_smear
operator|.
name|interval
argument_list|)
operator|)
operator|/
literal|2.0
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * TODO see if we're inside an inserted leap second, so we need to compute 				 * leap_smear.doffset = 1.0 - leap_smear.doffset 				 */
name|leap_smear
operator|.
name|in_progress
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|DEBUG
argument_list|)
block|msyslog(LOG_NOTICE, "*** leapsec_query: [%.0f:%.0f] (%li), now %u (%.0f), smear offset %.6f ms\n", 					leap_smear.intv_start, leap_smear.intv_end, leap_smear.interval, 					now, leap_smear_time, leap_smear.doffset);
else|#
directive|else
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"*** leapsec_query: [%.0f:%.0f] (%li), now %u (%.0f), smear offset %.6f ms\n"
operator|,
name|leap_smear
operator|.
name|intv_start
operator|,
name|leap_smear
operator|.
name|intv_end
operator|,
name|leap_smear
operator|.
name|interval
operator|,
name|now
operator|,
name|leap_smear_time
operator|,
name|leap_smear
operator|.
name|doffset
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
name|leap_smear
operator|.
name|interval
operator|=
literal|0
expr_stmt|;
comment|/* 	   * Update the current leap smear offset, eventually 0.0 if outside smear interval. 	   */
name|DTOLFP
argument_list|(
name|leap_smear
operator|.
name|doffset
argument_list|,
operator|&
name|leap_smear
operator|.
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LEAP_SMEAR */
if|if
condition|(
name|fired
condition|)
block|{
comment|/* Full hit. Eventually step the clock, but always 		 * announce the leap event has happened. 		 */
specifier|const
name|char
modifier|*
name|leapmsg
init|=
name|NULL
decl_stmt|;
name|double
name|lswarp
init|=
name|lsdata
operator|.
name|warped
decl_stmt|;
if|if
condition|(
name|lswarp
operator|<
literal|0.0
condition|)
block|{
if|if
condition|(
name|clock_max_back
operator|>
literal|0.0
operator|&&
name|clock_max_back
operator|<
operator|-
name|lswarp
condition|)
block|{
name|step_systime
argument_list|(
name|lswarp
argument_list|)
expr_stmt|;
name|leapmsg
operator|=
name|leapmsg_p_step
expr_stmt|;
block|}
else|else
block|{
name|leapmsg
operator|=
name|leapmsg_p_slew
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lswarp
operator|>
literal|0.0
condition|)
block|{
if|if
condition|(
name|clock_max_fwd
operator|>
literal|0.0
operator|&&
name|clock_max_fwd
operator|<
name|lswarp
condition|)
block|{
name|step_systime
argument_list|(
name|lswarp
argument_list|)
expr_stmt|;
name|leapmsg
operator|=
name|leapmsg_n_step
expr_stmt|;
block|}
else|else
block|{
name|leapmsg
operator|=
name|leapmsg_n_slew
expr_stmt|;
block|}
block|}
if|if
condition|(
name|leapmsg
condition|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s"
argument_list|,
name|leapmsg
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_LEAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|update_autokey
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|lsprox
operator|=
name|LSPROX_NOWARN
expr_stmt|;
name|leapsec
operator|=
name|LSPROX_NOWARN
expr_stmt|;
name|sys_tai
operator|=
name|lsdata
operator|.
name|tai_offs
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|AUTOKEY
name|update_autokey
operator|=
operator|(
name|sys_tai
operator|!=
operator|(
name|u_int
operator|)
name|lsdata
operator|.
name|tai_offs
operator|)
expr_stmt|;
endif|#
directive|endif
name|lsprox
operator|=
name|lsdata
operator|.
name|proximity
expr_stmt|;
name|sys_tai
operator|=
name|lsdata
operator|.
name|tai_offs
expr_stmt|;
block|}
block|}
comment|/* We guard against panic alarming during the red alert phase. 	 * Strange and evil things might happen if we go from stone cold 	 * to piping hot in one step. If things are already that wobbly, 	 * we let the normal clock correction take over, even if a jump 	 * is involved.          * Also make sure the alarming events are edge-triggered, that is,          * ceated only when the threshold is crossed.          */
if|if
condition|(
operator|(
name|leapsec
operator|>
literal|0
operator|||
name|lsprox
operator|<
name|LSPROX_ALERT
operator|)
operator|&&
name|leapsec
operator|<
name|lsprox
condition|)
block|{
if|if
condition|(
name|leapsec
operator|<
name|LSPROX_SCHEDULE
operator|&&
name|lsprox
operator|>=
name|LSPROX_SCHEDULE
condition|)
block|{
if|if
condition|(
name|lsdata
operator|.
name|dynamic
condition|)
name|report_event
argument_list|(
name|PEVNT_ARMED
argument_list|,
name|sys_peer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|report_event
argument_list|(
name|EVNT_ARMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|leapsec
operator|=
name|lsprox
expr_stmt|;
block|}
if|if
condition|(
name|leapsec
operator|>
name|lsprox
condition|)
block|{
if|if
condition|(
name|leapsec
operator|>=
name|LSPROX_SCHEDULE
operator|&&
name|lsprox
operator|<
name|LSPROX_SCHEDULE
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_DISARMED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|leapsec
operator|=
name|lsprox
expr_stmt|;
block|}
if|if
condition|(
name|leapsec
operator|>=
name|LSPROX_SCHEDULE
condition|)
name|leapdif
operator|=
name|lsdata
operator|.
name|tai_diff
expr_stmt|;
else|else
name|leapdif
operator|=
literal|0
expr_stmt|;
name|check_leap_sec_in_progress
argument_list|(
operator|&
name|lsdata
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|update_autokey
condition|)
name|crypto_update_taichange
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

