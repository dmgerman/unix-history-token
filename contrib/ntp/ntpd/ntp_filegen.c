begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_filegen.c,v 3.12 1994/01/25 19:06:11 kardel Exp  *  *  implements file generations support for NTP  *  logfiles and statistic files  *  *  * Copyright (C) 1992, 1996 by Rainer Pruy  * Friedrich-Alexander Universität Erlangen-Nürnberg, Germany  *  * This code may be modified and used freely  * provided credits remain intact.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_filegen.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * NTP is intended to run long periods of time without restart.  * Thus log and statistic files generated by NTP will grow large.  *  * this set of routines provides a central interface   * to generating files using file generations  *  * the generation of a file is changed according to file generation type  */
end_comment

begin_comment
comment|/*  * redefine this if your system dislikes filename suffixes like  * X.19910101 or X.1992W50 or ....  */
end_comment

begin_define
define|#
directive|define
name|SUFFIX_SEP
value|'.'
end_define

begin_comment
comment|/*  * other constants  */
end_comment

begin_define
define|#
directive|define
name|FGEN_AGE_SECS
value|(24*60*60)
end_define

begin_comment
comment|/* life time of FILEGEN_AGE in seconds */
end_comment

begin_decl_stmt
specifier|static
name|void
name|filegen_open
name|P
argument_list|(
operator|(
name|FILEGEN
operator|*
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|valid_fileref
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_decl_stmt
specifier|static
name|FILEGEN
modifier|*
name|filegen_unregister
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_comment
comment|/*  * open a file generation according to the current settings of gen  * will also provide a link to basename if requested to do so  */
end_comment

begin_function
specifier|static
name|void
name|filegen_open
parameter_list|(
name|FILEGEN
modifier|*
name|gen
parameter_list|,
name|u_long
name|newid
parameter_list|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|basename
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|calendar
name|cal
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|gen
operator|->
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|gen
operator|->
name|basename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|basename
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|basename
argument_list|,
literal|"%s%s"
argument_list|,
name|gen
operator|->
name|prefix
argument_list|,
name|gen
operator|->
name|basename
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gen
operator|->
name|type
condition|)
block|{
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unsupported file generations type %d for \"%s\" - reverting to FILEGEN_NONE"
argument_list|,
name|gen
operator|->
name|type
argument_list|,
name|basename
argument_list|)
expr_stmt|;
name|gen
operator|->
name|type
operator|=
name|FILEGEN_NONE
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|FILEGEN_NONE
case|:
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s"
argument_list|,
name|basename
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILEGEN_PID
case|:
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
operator|+
literal|1
operator|+
literal|1
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s%c#%ld"
argument_list|,
name|basename
argument_list|,
name|SUFFIX_SEP
argument_list|,
name|newid
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILEGEN_DAY
case|:
comment|/* You can argue here in favor of using MJD, but 		 * I would assume it to be easier for humans to interpret dates 		 * in a format they are used to in everyday life. 		 */
name|caljulian
argument_list|(
name|newid
argument_list|,
operator|&
name|cal
argument_list|)
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
operator|+
literal|1
operator|+
literal|4
operator|+
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s%c%04d%02d%02d"
argument_list|,
name|basename
argument_list|,
name|SUFFIX_SEP
argument_list|,
name|cal
operator|.
name|year
argument_list|,
name|cal
operator|.
name|month
argument_list|,
name|cal
operator|.
name|monthday
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILEGEN_WEEK
case|:
comment|/* 		 * This is still a hack 		 * - the term week is not correlated to week as it is used 		 *   normally - it just refers to a period of 7 days 		 *   starting at Jan 1 - 'weeks' are counted starting from zero 		 */
name|caljulian
argument_list|(
name|newid
argument_list|,
operator|&
name|cal
argument_list|)
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s%c%04dw%02d"
argument_list|,
name|basename
argument_list|,
name|SUFFIX_SEP
argument_list|,
name|cal
operator|.
name|year
argument_list|,
name|cal
operator|.
name|yearday
operator|/
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILEGEN_MONTH
case|:
name|caljulian
argument_list|(
name|newid
argument_list|,
operator|&
name|cal
argument_list|)
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
operator|+
literal|1
operator|+
literal|4
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s%c%04d%02d"
argument_list|,
name|basename
argument_list|,
name|SUFFIX_SEP
argument_list|,
name|cal
operator|.
name|year
argument_list|,
name|cal
operator|.
name|month
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILEGEN_YEAR
case|:
name|caljulian
argument_list|(
name|newid
argument_list|,
operator|&
name|cal
argument_list|)
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
operator|+
literal|1
operator|+
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s%c%04d"
argument_list|,
name|basename
argument_list|,
name|SUFFIX_SEP
argument_list|,
name|cal
operator|.
name|year
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILEGEN_AGE
case|:
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
operator|+
literal|1
operator|+
literal|2
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s%ca%08ld"
argument_list|,
name|basename
argument_list|,
name|SUFFIX_SEP
argument_list|,
name|newid
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gen
operator|->
name|type
operator|!=
name|FILEGEN_NONE
condition|)
block|{
comment|/* 		 * check for existence of a file with name 'basename' 		 * as we disallow such a file 		 * if FGEN_FLAG_LINK is set create a link 		 */
name|struct
name|stat
name|stats
decl_stmt|;
comment|/* 		 * try to resolve name collisions 		 */
specifier|static
name|u_long
name|conflicts
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|S_ISREG
define|#
directive|define
name|S_ISREG
parameter_list|(
name|mode
parameter_list|)
value|(((mode)& S_IFREG) == S_IFREG)
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|basename
argument_list|,
operator|&
name|stats
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Hm, file exists... */
if|if
condition|(
name|S_ISREG
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|stats
operator|.
name|st_nlink
operator|<=
literal|1
condition|)
block|{
comment|/* 					 * Oh, it is not linked - try to save it 					 */
name|char
modifier|*
name|savename
init|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
operator|+
literal|1
operator|+
literal|1
operator|+
literal|10
operator|+
literal|10
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|savename
argument_list|,
literal|"%s%c%dC%lu"
argument_list|,
name|basename
argument_list|,
name|SUFFIX_SEP
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
operator|(
name|u_long
operator|)
name|conflicts
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|basename
argument_list|,
name|savename
argument_list|)
operator|!=
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|" couldn't save %s: %m"
argument_list|,
name|basename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|savename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * there is at least a second link tpo this file 					 * just remove the conflicting one 					 */
if|if
condition|(
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
name|unlink
argument_list|(
name|basename
argument_list|)
operator|!=
literal|0
else|#
directive|else
name|delete
argument_list|(
name|basename
argument_list|)
operator|!=
literal|0
endif|#
directive|endif
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't unlink %s: %m"
argument_list|,
name|basename
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * Ehh? Not a regular file ?? strange !!!! 				 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"expected regular file for %s (found mode 0%lo)"
argument_list|,
name|basename
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|stats
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * stat(..) failed, but it is absolutely correct for 			 * 'basename' not to exist 			 */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"stat(%s) failed: %m"
argument_list|,
name|basename
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * now, try to open new file generation... 	 */
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"opening filegen (type=%d/id=%lu) \"%s\"\n"
argument_list|,
name|gen
operator|->
name|type
argument_list|,
operator|(
name|u_long
operator|)
name|newid
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* open failed -- keep previous state 		 * 		 * If the file was open before keep the previous generation. 		 * This will cause output to end up in the 'wrong' file, 		 * but I think this is still better than losing output 		 * 		 * ignore errors due to missing directories 		 */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't open %s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gen
operator|->
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|gen
operator|->
name|fp
argument_list|)
expr_stmt|;
block|}
name|gen
operator|->
name|fp
operator|=
name|fp
expr_stmt|;
name|gen
operator|->
name|id
operator|=
name|newid
expr_stmt|;
if|if
condition|(
name|gen
operator|->
name|flag
operator|&
name|FGEN_FLAG_LINK
condition|)
block|{
comment|/* 			 * need to link file to basename 			 * have to use hardlink for now as I want to allow 			 * gen->basename spanning directory levels 			 * this would make it more complex to get the correct 			 * filename for symlink 			 * 			 * Ok, it would just mean taking the part following 			 * the last '/' in the name.... Should add it later.... 			 */
comment|/* Windows NT does not support file links -Greg Schueman 1/18/97 */
if|#
directive|if
name|defined
name|SYS_WINNT
operator|||
name|defined
name|SYS_VXWORKS
name|SetLastError
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* On WinNT, don't support FGEN_FLAG_LINK */
elif|#
directive|elif
name|defined
argument_list|(
name|VMS
argument_list|)
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* On VMS, don't support FGEN_FLAG_LINK */
else|#
directive|else
comment|/* not (VMS) / VXWORKS / WINNT ; DO THE LINK) */
if|if
condition|(
name|link
argument_list|(
name|filename
argument_list|,
name|basename
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't link(%s, %s): %m"
argument_list|,
name|filename
argument_list|,
name|basename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT || VXWORKS */
block|}
comment|/* flags& FGEN_FLAG_LINK */
block|}
comment|/* else fp == NULL */
name|free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * this function sets up gen->fp to point to the correct  * generation of the file for the time specified by 'now'  *  * 'now' usually is interpreted as second part of a l_fp as is in the cal...  * library routines  */
end_comment

begin_function
name|void
name|filegen_setup
parameter_list|(
name|FILEGEN
modifier|*
name|gen
parameter_list|,
name|u_long
name|now
parameter_list|)
block|{
name|u_long
name|new_gen
init|=
operator|~
operator|(
name|u_long
operator|)
literal|0
decl_stmt|;
name|struct
name|calendar
name|cal
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|gen
operator|->
name|flag
operator|&
name|FGEN_FLAG_ENABLED
operator|)
condition|)
block|{
if|if
condition|(
name|gen
operator|->
name|fp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|gen
operator|->
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|gen
operator|->
name|type
condition|)
block|{
case|case
name|FILEGEN_NONE
case|:
if|if
condition|(
name|gen
operator|->
name|fp
operator|!=
name|NULL
condition|)
return|return;
comment|/* file already open */
break|break;
case|case
name|FILEGEN_PID
case|:
name|new_gen
operator|=
name|getpid
argument_list|()
expr_stmt|;
break|break;
case|case
name|FILEGEN_DAY
case|:
name|caljulian
argument_list|(
name|now
argument_list|,
operator|&
name|cal
argument_list|)
expr_stmt|;
name|cal
operator|.
name|hour
operator|=
name|cal
operator|.
name|minute
operator|=
name|cal
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|new_gen
operator|=
name|caltontp
argument_list|(
operator|&
name|cal
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILEGEN_WEEK
case|:
comment|/* Would be nice to have a calweekstart() routine */
comment|/* so just use a hack ... */
comment|/* just round time to integral 7 day period for actual year  */
name|new_gen
operator|=
name|now
operator|-
operator|(
name|now
operator|-
name|calyearstart
argument_list|(
name|now
argument_list|)
operator|)
operator|%
name|TIMES7
argument_list|(
name|SECSPERDAY
argument_list|)
operator|+
literal|60
expr_stmt|;
comment|/* 		 * just to be sure - 		 * the computation above would fail in the presence of leap seconds 		 * so at least carry the date to the next day (+60 (seconds)) 		 * and go back to the start of the day via calendar computations 		 */
name|caljulian
argument_list|(
name|new_gen
argument_list|,
operator|&
name|cal
argument_list|)
expr_stmt|;
name|cal
operator|.
name|hour
operator|=
name|cal
operator|.
name|minute
operator|=
name|cal
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|new_gen
operator|=
name|caltontp
argument_list|(
operator|&
name|cal
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILEGEN_MONTH
case|:
name|caljulian
argument_list|(
name|now
argument_list|,
operator|&
name|cal
argument_list|)
expr_stmt|;
name|cal
operator|.
name|yearday
operator|=
call|(
name|u_short
call|)
argument_list|(
name|cal
operator|.
name|yearday
operator|-
name|cal
operator|.
name|monthday
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cal
operator|.
name|monthday
operator|=
literal|1
expr_stmt|;
name|cal
operator|.
name|hour
operator|=
name|cal
operator|.
name|minute
operator|=
name|cal
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|new_gen
operator|=
name|caltontp
argument_list|(
operator|&
name|cal
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILEGEN_YEAR
case|:
name|new_gen
operator|=
name|calyearstart
argument_list|(
name|now
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILEGEN_AGE
case|:
name|new_gen
operator|=
name|current_time
operator|-
operator|(
name|current_time
operator|%
name|FGEN_AGE_SECS
operator|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * try to open file if not yet open 	 * reopen new file generation file on change of generation id 	 */
if|if
condition|(
name|gen
operator|->
name|fp
operator|==
name|NULL
operator|||
name|gen
operator|->
name|id
operator|!=
name|new_gen
condition|)
block|{
name|filegen_open
argument_list|(
name|gen
argument_list|,
name|new_gen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * change settings for filegen files  */
end_comment

begin_function
name|void
name|filegen_config
parameter_list|(
name|FILEGEN
modifier|*
name|gen
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|u_int
name|type
parameter_list|,
name|u_int
name|flag
parameter_list|)
block|{
comment|/* 	 * if nothing would be changed... 	 */
if|if
condition|(
operator|(
name|basename
operator|==
name|gen
operator|->
name|basename
operator|||
name|strcmp
argument_list|(
name|basename
argument_list|,
name|gen
operator|->
name|basename
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|type
operator|==
name|gen
operator|->
name|type
operator|&&
name|flag
operator|==
name|gen
operator|->
name|flag
condition|)
return|return;
comment|/* 	 * validate parameters 	 */
if|if
condition|(
operator|!
name|valid_fileref
argument_list|(
name|gen
operator|->
name|prefix
argument_list|,
name|basename
argument_list|)
condition|)
return|return;
if|if
condition|(
name|gen
operator|->
name|fp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|gen
operator|->
name|fp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"configuring filegen:\n\tprefix:\t%s\n\tbasename:\t%s -> %s\n\ttype:\t%d -> %d\n\tflag: %x -> %x\n"
argument_list|,
name|gen
operator|->
name|prefix
argument_list|,
name|gen
operator|->
name|basename
argument_list|,
name|basename
argument_list|,
name|gen
operator|->
name|type
argument_list|,
name|type
argument_list|,
name|gen
operator|->
name|flag
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|gen
operator|->
name|basename
operator|!=
name|basename
operator|||
name|strcmp
argument_list|(
name|gen
operator|->
name|basename
argument_list|,
name|basename
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|gen
operator|->
name|basename
argument_list|)
expr_stmt|;
name|gen
operator|->
name|basename
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|basename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|gen
operator|->
name|basename
argument_list|,
name|basename
argument_list|)
expr_stmt|;
block|}
name|gen
operator|->
name|type
operator|=
operator|(
name|u_char
operator|)
name|type
expr_stmt|;
name|gen
operator|->
name|flag
operator|=
operator|(
name|u_char
operator|)
name|flag
expr_stmt|;
comment|/* 	 * make filegen use the new settings 	 * special action is only required when a generation file 	 * is currently open 	 * otherwise the new settings will be used anyway at the next open 	 */
if|if
condition|(
name|gen
operator|->
name|fp
operator|!=
name|NULL
condition|)
block|{
name|l_fp
name|now
decl_stmt|;
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|filegen_setup
argument_list|(
name|gen
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * check whether concatenating prefix and basename  * yields a legal filename  */
end_comment

begin_function
specifier|static
name|int
name|valid_fileref
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|)
block|{
comment|/* 	 * prefix cannot be changed dynamically 	 * (within the context of filegen) 	 * so just reject basenames containing '..' 	 * 	 * ASSUMPTION: 	 * 		file system parts 'below' prefix may be 	 *		specified without infringement of security 	 * 	 *              restricing prefix to legal values 	 *		has to be ensured by other means 	 * (however, it would be possible to perform some checks here...) 	 */
specifier|register
name|char
modifier|*
name|p
init|=
name|basename
decl_stmt|;
comment|/* 	 * Just to catch, dumb errors opening up the world... 	 */
if|if
condition|(
name|prefix
operator|==
name|NULL
operator|||
operator|*
name|prefix
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|basename
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|basename
init|;
name|p
condition|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'.'
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
operator|==
literal|'\0'
operator|||
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
operator|==
literal|'/'
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * filegen registry  */
end_comment

begin_struct
specifier|static
struct|struct
name|filegen_entry
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|FILEGEN
modifier|*
name|filegen
decl_stmt|;
name|struct
name|filegen_entry
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|filegen_registry
init|=
name|NULL
struct|;
end_struct

begin_function
name|FILEGEN
modifier|*
name|filegen_get
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|filegen_entry
modifier|*
name|f
init|=
name|filegen_registry
decl_stmt|;
while|while
condition|(
name|f
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|name
operator|==
name|name
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|f
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|XXX
comment|/* this gives the Alpha compiler fits */
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"filegen_get(\"%s\") = %x\n"
argument_list|,
name|name
argument_list|,
operator|(
name|u_int
operator|)
name|f
operator|->
name|filegen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|f
operator|->
name|filegen
return|;
block|}
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"filegen_get(\"%s\") = NULL\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|filegen_register
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILEGEN
modifier|*
name|filegen
parameter_list|)
block|{
name|struct
name|filegen_entry
modifier|*
modifier|*
name|f
init|=
operator|&
name|filegen_registry
decl_stmt|;
ifdef|#
directive|ifdef
name|XXX
comment|/* this gives the Alpha compiler fits */
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"filegen_register(\"%s\",%x)\n"
argument_list|,
name|name
argument_list|,
operator|(
name|u_int
operator|)
name|filegen
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|f
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|f
operator|)
operator|->
name|name
operator|==
name|name
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
operator|(
operator|*
name|f
operator|)
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|XXX
comment|/* this gives the Alpha compiler fits */
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"replacing filegen %x\n"
argument_list|,
call|(
name|u_int
call|)
argument_list|(
operator|*
name|f
argument_list|)
operator|->
name|filegen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
operator|*
name|f
operator|)
operator|->
name|filegen
operator|=
name|filegen
expr_stmt|;
return|return;
block|}
name|f
operator|=
operator|&
operator|(
operator|(
operator|*
name|f
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
operator|*
name|f
operator|=
operator|(
expr|struct
name|filegen_entry
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|filegen_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|f
condition|)
block|{
operator|(
operator|*
name|f
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|f
operator|)
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
operator|*
name|f
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|f
operator|)
operator|->
name|filegen
operator|=
name|filegen
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"adding new filegen\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_function
specifier|static
name|FILEGEN
modifier|*
name|filegen_unregister
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|filegen_entry
modifier|*
modifier|*
name|f
init|=
operator|&
name|filegen_registry
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"filegen_unregister(\"%s\")\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|f
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|f
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|filegen_entry
modifier|*
name|ff
init|=
operator|*
name|f
decl_stmt|;
name|FILEGEN
modifier|*
name|fg
decl_stmt|;
operator|*
name|f
operator|=
operator|(
operator|*
name|f
operator|)
operator|->
name|next
expr_stmt|;
name|fg
operator|=
name|ff
operator|->
name|filegen
expr_stmt|;
name|free
argument_list|(
name|ff
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ff
argument_list|)
expr_stmt|;
return|return
name|fg
return|;
block|}
name|f
operator|=
operator|&
operator|(
operator|(
operator|*
name|f
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

end_unit

