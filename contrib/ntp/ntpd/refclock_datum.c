begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** refclock_datum - clock driver for the Datum Programmable Time Server ** ** Important note: This driver assumes that you have termios. If you have ** a system that does not have termios, you will have to modify this driver. ** ** Sorry, I have only tested this driver on SUN and HP platforms. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_DATUM
argument_list|)
end_if

begin_comment
comment|/* ** Include Files */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BSD_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSV_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STREAM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WWVBCLK
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/clkdefs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WWVBCLK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAM */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WWVBPPS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WWVBPPS */
end_comment

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/* ** This driver supports the Datum Programmable Time System (PTS) clock. ** The clock works in very straight forward manner. When it receives a ** time code request (e.g., the ascii string "//k/mn"), it responds with ** a seven byte BCD time code. This clock only responds with a ** time code after it first receives the "//k/mn" message. It does not ** periodically send time codes back at some rate once it is started. ** the returned time code can be broken down into the following fields. ** **            _______________________________ ** Bit Index | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | **            =============================== ** byte 0:   | -   -   -   - |      H D      | **            =============================== ** byte 1:   |      T D      |      U D      | **            =============================== ** byte 2:   | -   - |  T H  |      U H      | **            =============================== ** byte 3:   | - |    T M    |      U M      | **            =============================== ** byte 4:   | - |    T S    |      U S      | **            =============================== ** byte 5:   |      t S      |      h S      | **            =============================== ** byte 6:   |      m S      | -   -   -   - | **            =============================== ** ** In the table above: ** **	"-" means don't care **	"H D", "T D", and "U D" means Hundreds, Tens, and Units of Days **	"T H", and "UH" means Tens and Units of Hours **	"T M", and "U M" means Tens and Units of Minutes **	"T S", and "U S" means Tens and Units of Seconds **	"t S", "h S", and "m S" means tenths, hundredths, and thousandths **				of seconds ** ** The Datum PTS communicates throught the RS232 port on your machine. ** Right now, it assumes that you have termios. This driver has been tested ** on SUN and HP workstations. The Datum PTS supports various IRIG and ** NASA input codes. This driver assumes that the name of the device is ** /dev/datum. You will need to make a soft link to your RS232 device or ** create a new driver to use this refclock. */
end_comment

begin_comment
comment|/* ** Datum PTS defines */
end_comment

begin_comment
comment|/* ** Note that if GMT is defined, then the Datum PTS must use Greenwich ** time. Otherwise, this driver allows the Datum PTS to use the current ** wall clock for its time. It determines the time zone offset by minimizing ** the error after trying several time zone offsets. If the Datum PTS ** time is Greenwich time and GMT is not defined, everything should still ** work since the time zone will be found to be 0. What this really means ** is that your system time (at least to start with) must be within the ** correct time by less than +- 30 minutes. The default is for GMT to not ** defined. If you really want to force GMT without the funny +- 30 minute ** stuff then you must define (uncomment) GMT below. */
end_comment

begin_comment
comment|/* #define GMT #define DEBUG_DATUM_PTC #define LOG_TIME_ERRORS */
end_comment

begin_define
define|#
directive|define
name|PTSPRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed 1/1024 ms */
end_comment

begin_define
define|#
directive|define
name|DATMREFID
value|"DATM"
end_define

begin_comment
comment|/* reference id */
end_comment

begin_define
define|#
directive|define
name|DATUM_DISPERSION
value|0
end_define

begin_comment
comment|/* fixed dispersion = 0 ms */
end_comment

begin_define
define|#
directive|define
name|DATUM_MAX_ERROR
value|0.100
end_define

begin_comment
comment|/* limits on sigma squared */
end_comment

begin_define
define|#
directive|define
name|DATUM_MAX_ERROR2
value|(DATUM_MAX_ERROR*DATUM_MAX_ERROR)
end_define

begin_comment
comment|/* ** The Datum PTS structure */
end_comment

begin_comment
comment|/* ** I don't use a fixed array of MAXUNITS like everyone else just because ** I don't like to program that way. Sorry if this bothers anyone. I assume ** that you can use any id for your unit and I will search for it in a ** dynamic array of units until I find it. I was worried that users might ** enter a bad id in their configuration file (larger than MAXUNITS) and ** besides, it is just cleaner not to have to assume that you have a fixed ** number of anything in a program. */
end_comment

begin_struct
struct|struct
name|datum_pts_unit
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* peer used by ntp */
name|struct
name|refclockio
name|io
decl_stmt|;
comment|/* io structure used by ntp */
name|int
name|PTS_fd
decl_stmt|;
comment|/* file descriptor for PTS */
name|u_int
name|unit
decl_stmt|;
comment|/* id for unit */
name|u_long
name|timestarted
decl_stmt|;
comment|/* time started */
name|l_fp
name|lastrec
decl_stmt|;
comment|/* time tag for the receive time (system) */
name|l_fp
name|lastref
decl_stmt|;
comment|/* reference time (Datum time) */
name|u_long
name|yearstart
decl_stmt|;
comment|/* the year that this clock started */
name|int
name|coderecv
decl_stmt|;
comment|/* number of time codes received */
name|int
name|day
decl_stmt|;
comment|/* day */
name|int
name|hour
decl_stmt|;
comment|/* hour */
name|int
name|minute
decl_stmt|;
comment|/* minutes */
name|int
name|second
decl_stmt|;
comment|/* seconds */
name|int
name|msec
decl_stmt|;
comment|/* miliseconds */
name|int
name|usec
decl_stmt|;
comment|/* miliseconds */
name|u_char
name|leap
decl_stmt|;
comment|/* funny leap character code */
name|char
name|retbuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* returned time from the datum pts */
name|char
name|nbytes
decl_stmt|;
comment|/* number of bytes received from datum pts */
name|double
name|sigma2
decl_stmt|;
comment|/* average squared error (roughly) */
name|int
name|tzoff
decl_stmt|;
comment|/* time zone offest from GMT */
block|}
struct|;
end_struct

begin_comment
comment|/* ** PTS static constant variables for internal use */
end_comment

begin_decl_stmt
specifier|static
name|char
name|TIME_REQUEST
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request message sent to datum for time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nunits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of active units */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|datum_pts_unit
modifier|*
modifier|*
name|datum_pts_unit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dynamic array of datum PTS structures */
end_comment

begin_comment
comment|/* ** Callback function prototypes that ntpd needs to know about. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|datum_pts_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|datum_pts_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|datum_pts_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|datum_pts_control
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|datum_pts_init
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|datum_pts_buginfo
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockbug
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** This is the call back function structure that ntpd actually uses for ** this refclock. */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_datum
init|=
block|{
name|datum_pts_start
block|,
comment|/* start up a new Datum refclock */
name|datum_pts_shutdown
block|,
comment|/* shutdown a Datum refclock */
name|datum_pts_poll
block|,
comment|/* sends out the time request */
name|datum_pts_control
block|,
comment|/* not used */
name|datum_pts_init
block|,
comment|/* initialization (called first) */
name|datum_pts_buginfo
block|,
comment|/* not used */
name|NOFLAGS
comment|/* we are not setting any special flags */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** The datum_pts_receive callback function is handled differently from the ** rest. It is passed to the ntpd io data structure. Basically, every ** 64 seconds, the datum_pts_poll() routine is called. It sends out the time ** request message to the Datum Programmable Time System. Then, ntpd ** waits on a select() call to receive data back. The datum_pts_receive() ** function is called as data comes back. We expect a seven byte time ** code to be returned but the datum_pts_receive() function may only get ** a few bytes passed to it at a time. In other words, this routine may ** get called by the io stuff in ntpd a few times before we get all seven ** bytes. Once the last byte is received, we process it and then pass the ** new time measurement to ntpd for updating the system time. For now, ** there is no 3 state filtering done on the time measurements. The ** jitter may be a little high but at least for its current use, it is not ** a problem. We have tried to keep things as simple as possible. This ** clock should not jitter more than 1 or 2 mseconds at the most once ** things settle down. It is important to get the right drift calibrated ** in the ntpd.drift file as well as getting the right tick set up right ** using tickadj for SUNs. Tickadj is not used for the HP but you need to ** remember to bring up the adjtime daemon because HP does not support ** the adjtime() call. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|datum_pts_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*......................................................................*/
end_comment

begin_comment
comment|/*	datum_pts_start - start up the datum PTS. This means open the	*/
end_comment

begin_comment
comment|/*	RS232 device and set up the data structure for my unit.		*/
end_comment

begin_comment
comment|/*......................................................................*/
end_comment

begin_function
specifier|static
name|int
name|datum_pts_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|datum_pts_unit
modifier|*
modifier|*
name|temp_datum_pts_unit
decl_stmt|;
name|struct
name|datum_pts_unit
modifier|*
name|datum_pts
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|arg
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Starting Datum PTS unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Create the memory for the new unit 	*/
name|temp_datum_pts_unit
operator|=
operator|(
expr|struct
name|datum_pts_unit
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nunits
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|datum_pts_unit
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nunits
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|temp_datum_pts_unit
argument_list|,
name|datum_pts_unit
argument_list|,
name|nunits
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|datum_pts_unit
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|datum_pts_unit
argument_list|)
expr_stmt|;
name|datum_pts_unit
operator|=
name|temp_datum_pts_unit
expr_stmt|;
name|datum_pts_unit
index|[
name|nunits
index|]
operator|=
operator|(
expr|struct
name|datum_pts_unit
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|datum_pts_unit
argument_list|)
argument_list|)
expr_stmt|;
name|datum_pts
operator|=
name|datum_pts_unit
index|[
name|nunits
index|]
expr_stmt|;
name|datum_pts
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
comment|/* set my unit id */
name|datum_pts
operator|->
name|yearstart
operator|=
literal|0
expr_stmt|;
comment|/* initialize the yearstart to 0 */
name|datum_pts
operator|->
name|sigma2
operator|=
literal|0.0
expr_stmt|;
comment|/* initialize the sigma2 to 0 */
comment|/* 	** Open the Datum PTS device 	*/
name|datum_pts
operator|->
name|PTS_fd
operator|=
name|open
argument_list|(
literal|"/dev/datum"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|datum_pts
operator|->
name|PTS_fd
argument_list|,
name|F_SETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear the descriptor flags */
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Opening RS232 port with file descriptor %d\n"
argument_list|,
name|datum_pts
operator|->
name|PTS_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Set up the RS232 terminal device information. Note that we assume that 	** we have termios. This code has only been tested on SUNs and HPs. If your 	** machine does not have termios this driver cannot be initialized. You can change this 	** if you want by editing this source. Please give the changes back to the 	** ntp folks so that it can become part of their regular distribution. 	*/
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|arg
operator|.
name|c_iflag
operator|=
name|IGNBRK
expr_stmt|;
name|arg
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|arg
operator|.
name|c_cflag
operator|=
name|B9600
operator||
name|CS8
operator||
name|CREAD
operator||
name|PARENB
operator||
name|CLOCAL
expr_stmt|;
name|arg
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|arg
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|0
expr_stmt|;
comment|/* start timeout timer right away (not used) */
name|arg
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|30
expr_stmt|;
comment|/* 3 second timout on reads (not used) */
name|tcsetattr
argument_list|(
name|datum_pts
operator|->
name|PTS_fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
else|#
directive|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Datum_PTS: Termios not supported in this driver"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|datum_pts
operator|->
name|PTS_fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* 	** Initialize the ntpd IO structure 	*/
name|datum_pts
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|datum_pts
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|datum_pts_receive
expr_stmt|;
name|datum_pts
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|datum_pts
expr_stmt|;
name|datum_pts
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|datum_pts
operator|->
name|io
operator|.
name|fd
operator|=
name|datum_pts
operator|->
name|PTS_fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
operator|(
name|datum_pts
operator|->
name|io
operator|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Problem adding clock\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Datum_PTS: Problem adding clock"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|datum_pts
operator|->
name|PTS_fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|peer
operator|->
name|precision
operator|=
name|PTSPRECISION
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|DATMREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	** Now add one to the number of units and return a successful code 	*/
name|nunits
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*......................................................................*/
end_comment

begin_comment
comment|/*	datum_pts_shutdown - this routine shuts doen the device and	*/
end_comment

begin_comment
comment|/*	removes the memory for the unit.				*/
end_comment

begin_comment
comment|/*......................................................................*/
end_comment

begin_function
specifier|static
name|void
name|datum_pts_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|datum_pts_unit
modifier|*
modifier|*
name|temp_datum_pts_unit
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Shutdown Datum PTS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Datum_PTS: Shutdown Datum PTS"
argument_list|)
expr_stmt|;
comment|/* 	** First we have to find the right unit (i.e., the one with the same id). 	** We do this by looping through the dynamic array of units intil we find 	** it. Note, that I don't simply use an array with a maximimum number of 	** Datum PTS units. Everything is completely dynamic. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nunits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|datum_pts_unit
index|[
name|i
index|]
operator|->
name|unit
operator|==
name|unit
condition|)
block|{
comment|/* 			** We found the unit so close the file descriptor and free up the memory used 			** by the structure. 			*/
name|io_closeclock
argument_list|(
operator|&
name|datum_pts_unit
index|[
name|i
index|]
operator|->
name|io
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|datum_pts_unit
index|[
name|i
index|]
operator|->
name|PTS_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|datum_pts_unit
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 			** Now clean up the datum_pts_unit dynamic array so that there are no holes. 			** This may mean moving pointers around, etc., to keep things compact. 			*/
if|if
condition|(
name|nunits
operator|>
literal|1
condition|)
block|{
name|temp_datum_pts_unit
operator|=
operator|(
expr|struct
name|datum_pts_unit
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nunits
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|datum_pts_unit
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|temp_datum_pts_unit
argument_list|,
name|datum_pts_unit
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|datum_pts_unit
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nunits
condition|;
name|j
operator|++
control|)
block|{
name|temp_datum_pts_unit
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|datum_pts_unit
index|[
name|j
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|datum_pts_unit
argument_list|)
expr_stmt|;
name|datum_pts_unit
operator|=
name|temp_datum_pts_unit
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|datum_pts_unit
argument_list|)
expr_stmt|;
name|datum_pts_unit
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Error, could not shut down unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Datum_PTS: Could not shut down Datum PTS unit %d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*......................................................................*/
end_comment

begin_comment
comment|/*	datum_pts_poll - this routine sends out the time request to the */
end_comment

begin_comment
comment|/*	Datum PTS device. The time will be passed back in the 		*/
end_comment

begin_comment
comment|/*	datum_pts_receive() routine.					*/
end_comment

begin_comment
comment|/*......................................................................*/
end_comment

begin_function
specifier|static
name|void
name|datum_pts_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|error_code
decl_stmt|;
name|struct
name|datum_pts_unit
modifier|*
name|datum_pts
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Poll Datum PTS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Find the right unit and send out a time request once it is found. 	*/
name|index
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nunits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|datum_pts_unit
index|[
name|i
index|]
operator|->
name|unit
operator|==
name|unit
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
name|datum_pts
operator|=
name|datum_pts_unit
index|[
name|i
index|]
expr_stmt|;
name|error_code
operator|=
name|write
argument_list|(
name|datum_pts
operator|->
name|PTS_fd
argument_list|,
name|TIME_REQUEST
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|6
condition|)
name|perror
argument_list|(
literal|"TIME_REQUEST"
argument_list|)
expr_stmt|;
name|datum_pts
operator|->
name|nbytes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	** Print out an error message if we could not find the right unit. 	*/
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Error, could not poll unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Datum_PTS: Could not poll unit %d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*......................................................................*/
end_comment

begin_comment
comment|/*	datum_pts_control - not used					*/
end_comment

begin_comment
comment|/*......................................................................*/
end_comment

begin_function
specifier|static
name|void
name|datum_pts_control
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|in
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Control Datum PTS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*......................................................................*/
end_comment

begin_comment
comment|/*	datum_pts_init - initializes things for all possible Datum	*/
end_comment

begin_comment
comment|/*	time code generators that might be used. In practice, this is	*/
end_comment

begin_comment
comment|/*	only called once at the beginning before anything else is	*/
end_comment

begin_comment
comment|/*	called.								*/
end_comment

begin_comment
comment|/*......................................................................*/
end_comment

begin_function
specifier|static
name|void
name|datum_pts_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*									*/
comment|/*...... open up the log file if we are debugging ......................*/
comment|/*									*/
comment|/* 	** Open up the log file if we are debugging. For now, send data out to the 	** screen (stdout). 	*/
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Init Datum PTS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Initialize the time request command string. This is the only message 	** that we ever have to send to the Datum PTS (although others are defined). 	*/
name|memcpy
argument_list|(
name|TIME_REQUEST
argument_list|,
literal|"//k/mn"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* 	** Initialize the number of units to 0 and set the dynamic array of units to 	** NULL since there are no units defined yet. 	*/
name|datum_pts_unit
operator|=
name|NULL
expr_stmt|;
name|nunits
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*......................................................................*/
end_comment

begin_comment
comment|/*	datum_pts_buginfo - not used					*/
end_comment

begin_comment
comment|/*......................................................................*/
end_comment

begin_function
specifier|static
name|void
name|datum_pts_buginfo
parameter_list|(
name|int
name|unit
parameter_list|,
specifier|register
name|struct
name|refclockbug
modifier|*
name|bug
parameter_list|,
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Buginfo Datum PTS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*......................................................................*/
end_comment

begin_comment
comment|/*	datum_pts_receive - receive the time buffer that was read in	*/
end_comment

begin_comment
comment|/*	by the ntpd io handling routines. When 7 bytes have been	*/
end_comment

begin_comment
comment|/*	received (it may take several tries before all 7 bytes are	*/
end_comment

begin_comment
comment|/*	received), then the time code must be unpacked and sent to	*/
end_comment

begin_comment
comment|/*	the ntpd clock_receive() routine which causes the systems	*/
end_comment

begin_comment
comment|/*	clock to be updated (several layers down).			*/
end_comment

begin_comment
comment|/*......................................................................*/
end_comment

begin_function
specifier|static
name|void
name|datum_pts_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|l_fp
name|tstmp
decl_stmt|;
name|struct
name|datum_pts_unit
modifier|*
name|datum_pts
decl_stmt|;
name|char
modifier|*
name|dpt
decl_stmt|;
name|int
name|dpend
decl_stmt|;
name|int
name|tzoff
decl_stmt|;
name|int
name|timerr
decl_stmt|;
name|double
name|ftimerr
decl_stmt|,
name|abserr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
name|double
name|dispersion
decl_stmt|;
endif|#
directive|endif
name|int
name|goodtime
decl_stmt|;
comment|/*double doffset;*/
comment|/* 	** Get the time code (maybe partial) message out of the rbufp buffer. 	*/
name|datum_pts
operator|=
operator|(
expr|struct
name|datum_pts_unit
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|dpt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
name|dpend
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Receive Datum PTS: %d bytes\n"
argument_list|,
name|dpend
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*									*/
comment|/*...... save the ntp system time when the first byte is received ......*/
comment|/*									*/
comment|/* 	** Save the ntp system time when the first byte is received. Note that 	** because it may take several calls to this routine before all seven 	** bytes of our return message are finally received by the io handlers in 	** ntpd, we really do want to use the time tag when the first byte is 	** received to reduce the jitter. 	*/
if|if
condition|(
name|datum_pts
operator|->
name|nbytes
operator|==
literal|0
condition|)
block|{
name|datum_pts
operator|->
name|lastrec
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
block|}
comment|/* 	** Increment our count to the number of bytes received so far. Return if we 	** haven't gotten all seven bytes yet. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dpend
condition|;
name|i
operator|++
control|)
block|{
name|datum_pts
operator|->
name|retbuf
index|[
name|datum_pts
operator|->
name|nbytes
operator|+
name|i
index|]
operator|=
name|dpt
index|[
name|i
index|]
expr_stmt|;
block|}
name|datum_pts
operator|->
name|nbytes
operator|+=
name|dpend
expr_stmt|;
if|if
condition|(
name|datum_pts
operator|->
name|nbytes
operator|!=
literal|7
condition|)
block|{
return|return;
block|}
comment|/* 	** Convert the seven bytes received in our time buffer to day, hour, minute, 	** second, and msecond values. The usec value is not used for anything 	** currently. It is just the fractional part of the time stored in units 	** of microseconds. 	*/
name|datum_pts
operator|->
name|day
operator|=
literal|100
operator|*
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|0
index|]
operator|&
literal|0x0f
operator|)
operator|+
literal|10
operator|*
operator|(
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|1
index|]
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|1
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|datum_pts
operator|->
name|hour
operator|=
literal|10
operator|*
operator|(
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|2
index|]
operator|&
literal|0x30
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|datum_pts
operator|->
name|minute
operator|=
literal|10
operator|*
operator|(
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|3
index|]
operator|&
literal|0x70
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|3
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|datum_pts
operator|->
name|second
operator|=
literal|10
operator|*
operator|(
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|4
index|]
operator|&
literal|0x70
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|4
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|datum_pts
operator|->
name|msec
operator|=
literal|100
operator|*
operator|(
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|5
index|]
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator|+
literal|10
operator|*
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|5
index|]
operator|&
literal|0x0f
operator|)
operator|+
operator|(
operator|(
name|datum_pts
operator|->
name|retbuf
index|[
literal|6
index|]
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|datum_pts
operator|->
name|usec
operator|=
literal|1000
operator|*
name|datum_pts
operator|->
name|msec
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"day %d, hour %d, minute %d, second %d, msec %d\n"
argument_list|,
name|datum_pts
operator|->
name|day
argument_list|,
name|datum_pts
operator|->
name|hour
argument_list|,
name|datum_pts
operator|->
name|minute
argument_list|,
name|datum_pts
operator|->
name|second
argument_list|,
name|datum_pts
operator|->
name|msec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Get the GMT time zone offset. Note that GMT should be zero if the Datum 	** reference time is using GMT as its time base. Otherwise we have to 	** determine the offset if the Datum PTS is using time of day as its time 	** base. 	*/
name|goodtime
operator|=
literal|0
expr_stmt|;
comment|/* We are not sure about the time and offset yet */
ifdef|#
directive|ifdef
name|GMT
comment|/* 	** This is the case where the Datum PTS is using GMT so there is no time 	** zone offset. 	*/
name|tzoff
operator|=
literal|0
expr_stmt|;
comment|/* set time zone offset to 0 */
else|#
directive|else
comment|/* 	** This is the case where the Datum PTS is using regular time of day for its 	** time so we must compute the time zone offset. The way we do it is kind of 	** funny but it works. We loop through different time zones (0 to 24) and 	** pick the one that gives the smallest error (+- one half hour). The time 	** zone offset is stored in the datum_pts structure for future use. Normally, 	** the clocktime() routine is only called once (unless the time zone offset 	** changes due to daylight savings) since the goodtime flag is set when a 	** good time is found (with a good offset). Note that even if the Datum 	** PTS is using GMT, this mechanism will still work since it should come up 	** with a value for tzoff = 0 (assuming that your system clock is within 	** a half hour of the Datum time (even with time zone differences). 	*/
for|for
control|(
name|tzoff
operator|=
literal|0
init|;
name|tzoff
operator|<
literal|24
condition|;
name|tzoff
operator|++
control|)
block|{
if|if
condition|(
name|clocktime
argument_list|(
name|datum_pts
operator|->
name|day
argument_list|,
name|datum_pts
operator|->
name|hour
argument_list|,
name|datum_pts
operator|->
name|minute
argument_list|,
name|datum_pts
operator|->
name|second
argument_list|,
operator|(
name|tzoff
operator|+
name|datum_pts
operator|->
name|tzoff
operator|)
operator|%
literal|24
argument_list|,
name|datum_pts
operator|->
name|lastrec
operator|.
name|l_ui
argument_list|,
operator|&
name|datum_pts
operator|->
name|yearstart
argument_list|,
operator|&
name|datum_pts
operator|->
name|lastref
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|error
operator|=
name|datum_pts
operator|->
name|lastref
operator|.
name|l_ui
operator|-
name|datum_pts
operator|->
name|lastrec
operator|.
name|l_ui
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
name|printf
argument_list|(
literal|"Time Zone (clocktime method) = %d, error = %d\n"
argument_list|,
name|tzoff
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|<
literal|1799
operator|)
operator|&&
operator|(
name|error
operator|>
operator|-
literal|1799
operator|)
condition|)
block|{
name|tzoff
operator|=
operator|(
name|tzoff
operator|+
name|datum_pts
operator|->
name|tzoff
operator|)
operator|%
literal|24
expr_stmt|;
name|datum_pts
operator|->
name|tzoff
operator|=
name|tzoff
expr_stmt|;
name|goodtime
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
name|printf
argument_list|(
literal|"Time Zone found (clocktime method) = %d\n"
argument_list|,
name|tzoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* 	** Make sure that we have a good time from the Datum PTS. Clocktime() also 	** sets yearstart and lastref.l_ui. We will have to set astref.l_uf (i.e., 	** the fraction of a second) stuff later. 	*/
if|if
condition|(
operator|!
name|goodtime
condition|)
block|{
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|datum_pts
operator|->
name|day
argument_list|,
name|datum_pts
operator|->
name|hour
argument_list|,
name|datum_pts
operator|->
name|minute
argument_list|,
name|datum_pts
operator|->
name|second
argument_list|,
name|tzoff
argument_list|,
name|datum_pts
operator|->
name|lastrec
operator|.
name|l_ui
argument_list|,
operator|&
name|datum_pts
operator|->
name|yearstart
argument_list|,
operator|&
name|datum_pts
operator|->
name|lastref
operator|.
name|l_ui
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"Error: bad clocktime\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GMT %d, lastrec %d, yearstart %d, lastref %d\n"
argument_list|,
name|tzoff
argument_list|,
name|datum_pts
operator|->
name|lastrec
operator|.
name|l_ui
argument_list|,
name|datum_pts
operator|->
name|yearstart
argument_list|,
name|datum_pts
operator|->
name|lastref
operator|.
name|l_ui
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Datum_PTS: Bad clocktime"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Good clocktime\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* 	** We have datum_pts->lastref.l_ui set (which is the integer part of the 	** time. Now set the microseconds field. 	*/
name|TVUTOTSF
argument_list|(
name|datum_pts
operator|->
name|usec
argument_list|,
name|datum_pts
operator|->
name|lastref
operator|.
name|l_uf
argument_list|)
expr_stmt|;
comment|/* 	** Compute the time correction as the difference between the reference 	** time (i.e., the Datum time) minus the receive time (system time). 	*/
name|tstmp
operator|=
name|datum_pts
operator|->
name|lastref
expr_stmt|;
comment|/* tstmp is the datum ntp time */
name|L_SUB
argument_list|(
operator|&
name|tstmp
argument_list|,
operator|&
name|datum_pts
operator|->
name|lastrec
argument_list|)
expr_stmt|;
comment|/* tstmp is now the correction */
name|datum_pts
operator|->
name|coderecv
operator|++
expr_stmt|;
comment|/* increment a counter */
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
name|dispersion
operator|=
name|DATUM_DISPERSION
expr_stmt|;
comment|/* set the dispersion to 0 */
name|ftimerr
operator|=
name|dispersion
expr_stmt|;
name|ftimerr
operator|/=
operator|(
literal|1024.0
operator|*
literal|64.0
operator|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"dispersion = %d, %f\n"
argument_list|,
name|dispersion
argument_list|,
name|ftimerr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Pass the new time to ntpd through the refclock_receive function. Note 	** that we are not trying to make any corrections due to the time it takes 	** for the Datum PTS to send the message back. I am (erroneously) assuming 	** that the time for the Datum PTS to send the time back to us is negligable. 	** I suspect that this time delay may be as much as 15 ms or so (but probably 	** less). For our needs at JPL, this kind of error is ok so it is not 	** necessary to use fudge factors in the ntp.conf file. Maybe later we will. 	*/
comment|/*LFPTOD(&tstmp, doffset);*/
name|refclock_receive
argument_list|(
name|datum_pts
operator|->
name|peer
argument_list|)
expr_stmt|;
comment|/* 	** Compute sigma squared (not used currently). Maybe later, this could be 	** used for the dispersion estimate. The problem is that ntpd does not link 	** in the math library so sqrt() is not available. Anyway, this is useful 	** for debugging. Maybe later I will just use absolute values for the time 	** error to come up with my dispersion estimate. Anyway, for now my dispersion 	** is set to 0. 	*/
name|timerr
operator|=
name|tstmp
operator|.
name|l_ui
operator|<<
literal|20
expr_stmt|;
name|timerr
operator||=
operator|(
name|tstmp
operator|.
name|l_uf
operator|>>
literal|12
operator|)
operator|&
literal|0x000fffff
expr_stmt|;
name|ftimerr
operator|=
name|timerr
expr_stmt|;
name|ftimerr
operator|/=
literal|1024
operator|*
literal|1024
expr_stmt|;
name|abserr
operator|=
name|ftimerr
expr_stmt|;
if|if
condition|(
name|ftimerr
operator|<
literal|0.0
condition|)
name|abserr
operator|=
operator|-
name|ftimerr
expr_stmt|;
if|if
condition|(
name|datum_pts
operator|->
name|sigma2
operator|==
literal|0.0
condition|)
block|{
if|if
condition|(
name|abserr
operator|<
name|DATUM_MAX_ERROR
condition|)
block|{
name|datum_pts
operator|->
name|sigma2
operator|=
name|abserr
operator|*
name|abserr
expr_stmt|;
block|}
else|else
block|{
name|datum_pts
operator|->
name|sigma2
operator|=
name|DATUM_MAX_ERROR2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|abserr
operator|<
name|DATUM_MAX_ERROR
condition|)
block|{
name|datum_pts
operator|->
name|sigma2
operator|=
literal|0.95
operator|*
name|datum_pts
operator|->
name|sigma2
operator|+
literal|0.05
operator|*
name|abserr
operator|*
name|abserr
expr_stmt|;
block|}
else|else
block|{
name|datum_pts
operator|->
name|sigma2
operator|=
literal|0.95
operator|*
name|datum_pts
operator|->
name|sigma2
operator|+
literal|0.05
operator|*
name|DATUM_MAX_ERROR2
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_DATUM_PTC
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Time error = %f seconds\n"
argument_list|,
name|ftimerr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_DATUM_PTC
argument_list|)
operator|||
name|defined
argument_list|(
name|LOG_TIME_ERRORS
argument_list|)
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"PTS: day %d, hour %d, minute %d, second %d, msec %d, Time Error %f\n"
argument_list|,
name|datum_pts
operator|->
name|day
argument_list|,
name|datum_pts
operator|->
name|hour
argument_list|,
name|datum_pts
operator|->
name|minute
argument_list|,
name|datum_pts
operator|->
name|second
argument_list|,
name|datum_pts
operator|->
name|msec
argument_list|,
name|ftimerr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_datum_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

