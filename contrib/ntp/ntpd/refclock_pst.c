begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_pst - clock driver for PSTI/Traconex WWV/WWVH receivers  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_PST
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*  * This driver supports the PSTI 1010 and Traconex 1020 WWV/WWVH  * Receivers. No specific claim of accuracy is made for these receiver,  * but actual experience suggests that 10 ms would be a conservative  * assumption.  *   * The DIPswitches should be set for 9600 bps line speed, 24-hour day-  * of-year format and UTC time zone. Automatic correction for DST should  * be disabled. It is very important that the year be set correctly in  * the DIPswitches; otherwise, the day of year will be incorrect after  * 28 April of a normal or leap year. The propagation delay DIPswitches  * should be set according to the distance from the transmitter for both  * WWV and WWVH, as described in the instructions. While the delay can  * be set only to within 11 ms, the fudge time1 parameter can be used  * for vernier corrections.  *  * Using the poll sequence QTQDQM, the response timecode is in three  * sections totalling 50 ASCII printing characters, as concatenated by  * the driver, in the following format:  *  * ahh:mm:ss.fffs<cr> yy/dd/mm/ddd<cr> frdzycchhSSFTttttuuxx<cr>  *  *	on-time = first<cr>  *	hh:mm:ss.fff = hours, minutes, seconds, milliseconds  *	a = AM/PM indicator (' ' for 24-hour mode)  *	yy = year (from internal switches)  *	dd/mm/ddd = day of month, month, day of year  *	s = daylight-saving indicator (' ' for 24-hour mode)  *	f = frequency enable (O = all frequencies enabled)  *	r = baud rate (3 = 1200, 6 = 9600)  *	d = features indicator (@ = month/day display enabled)  *	z = time zone (0 = UTC)  *	y = year (5 = 91)  *	cc = WWV propagation delay (52 = 22 ms)  *	hh = WWVH propagation delay (81 = 33 ms)  *	SS = status (80 or 82 = operating correctly)  *	F = current receive frequency (4 = 15 MHz)  *	T = transmitter (C = WWV, H = WWVH)  *	tttt = time since last update (0000 = minutes)  *	uu = flush character (03 = ^c)  *	xx = 94 (unknown)  *  * The alarm condition is indicated by other than '8' at A, which occurs  * during initial synchronization and when received signal is lost for  * an extended period; unlock condition is indicated by other than  * "0000" in the tttt subfield at Q.  *  * Fudge Factors  *  * There are no special fudge factors other than the generic.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/wwv%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B9600
end_define

begin_comment
comment|/* uart speed (9600 baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|WWVREFID
value|"WWV\0"
end_define

begin_comment
comment|/* WWV reference ID */
end_comment

begin_define
define|#
directive|define
name|WWVHREFID
value|"WWVH"
end_define

begin_comment
comment|/* WWVH reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"PSTI/Traconex WWV/WWVH Receiver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|PST_PHI
value|(10e-6)
end_define

begin_comment
comment|/* max clock oscillator offset */
end_comment

begin_define
define|#
directive|define
name|LENPST
value|46
end_define

begin_comment
comment|/* min timecode length */
end_comment

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|pstunit
block|{
name|int
name|tcswitch
decl_stmt|;
comment|/* timecode switch */
name|char
modifier|*
name|lastptr
decl_stmt|;
comment|/* pointer to timecode data */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pst_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pst_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_pst
init|=
block|{
name|pst_start
block|,
comment|/* start up driver */
name|pst_shutdown
block|,
comment|/* shut down driver */
name|pst_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old pst_control) */
name|noentry
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* not used (old pst_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pst_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|pst_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|pstunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Open serial port. Use CLK line discipline, if available. 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_CLK
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|pstunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pstunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pstunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|pst_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|WWVREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|MAXSTAGE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pst_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|pst_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|pstunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|pstunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pst_receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|pst_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|pstunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|l_fp
name|trtmp
decl_stmt|;
name|u_long
name|ltemp
decl_stmt|;
name|char
name|ampmchar
decl_stmt|;
comment|/* AM/PM indicator */
name|char
name|daychar
decl_stmt|;
comment|/* standard/daylight indicator */
name|char
name|junque
index|[
literal|10
index|]
decl_stmt|;
comment|/* "yy/dd/mm/" discard */
name|char
name|info
index|[
literal|14
index|]
decl_stmt|;
comment|/* "frdzycchhSSFT" clock info */
comment|/* 	 * Initialize pointers and read the timecode and timestamp 	 */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|pstunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|up
operator|->
name|lastptr
operator|+=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|up
operator|->
name|lastptr
argument_list|,
name|pp
operator|->
name|a_lastcode
operator|+
name|BMAX
operator|-
literal|2
operator|-
name|up
operator|->
name|lastptr
argument_list|,
operator|&
name|trtmp
argument_list|)
expr_stmt|;
operator|*
name|up
operator|->
name|lastptr
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|up
operator|->
name|lastptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Note we get a buffer and timestamp for each<cr>, but only 	 * the first timestamp is retained. 	 */
if|if
condition|(
name|up
operator|->
name|tcswitch
operator|==
literal|0
condition|)
name|pp
operator|->
name|lastrec
operator|=
name|trtmp
expr_stmt|;
name|up
operator|->
name|tcswitch
operator|++
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|up
operator|->
name|lastptr
operator|-
name|pp
operator|->
name|a_lastcode
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|tcswitch
operator|<
literal|3
condition|)
return|return;
comment|/* 	 * We get down to business, check the timecode format and decode 	 * its contents. If the timecode has invalid length or is not in 	 * proper format, we declare bad format and exit. 	 */
if|if
condition|(
name|pp
operator|->
name|lencode
operator|<
name|LENPST
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Timecode format: 	 * "ahh:mm:ss.fffs yy/dd/mm/ddd frdzycchhSSFTttttuuxx" 	 */
if|if
condition|(
name|sscanf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%c%2d:%2d:%2d.%3ld%c %9s%3d%13s%4ld"
argument_list|,
operator|&
name|ampmchar
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|pp
operator|->
name|nsec
argument_list|,
operator|&
name|daychar
argument_list|,
name|junque
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
name|info
argument_list|,
operator|&
name|ltemp
argument_list|)
operator|!=
literal|10
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|nsec
operator|*=
literal|1000000
expr_stmt|;
comment|/* 	 * Decode synchronization, quality and last update. If 	 * unsynchronized, set the leap bits accordingly and exit. Once 	 * synchronized, the dispersion depends only on when the clock 	 * was last heard, which depends on the time since last update, 	 * as reported by the clock. 	 */
if|if
condition|(
name|info
index|[
literal|9
index|]
operator|!=
literal|'8'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
if|if
condition|(
name|info
index|[
literal|12
index|]
operator|==
literal|'H'
condition|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|WWVHREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|WWVREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
literal|1
condition|)
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
if|if
condition|(
name|ltemp
operator|==
literal|0
condition|)
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|pp
operator|->
name|disp
operator|=
name|PST_PHI
operator|*
name|ltemp
operator|*
literal|60
expr_stmt|;
comment|/* 	 * Process the new sample in the median filter and determine the 	 * timecode timestamp. 	 */
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|)
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pst_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|pst_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|pstunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * Time to poll the clock. The PSTI/Traconex clock responds to a 	 * "QTQDQMT" by returning a timecode in the format specified 	 * above. Note there is no checking on state, since this may not 	 * be the only customer reading the clock. Only one customer 	 * need poll the clock; all others just listen in. If the clock 	 * becomes unreachable, declare a timeout and keep going. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|pstunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|up
operator|->
name|tcswitch
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|lastptr
operator|=
name|pp
operator|->
name|a_lastcode
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"QTQDQMT"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|6
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"pst: timecode %d %s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|peer
operator|->
name|burst
operator|=
name|MAXSTAGE
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_pst_int
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

