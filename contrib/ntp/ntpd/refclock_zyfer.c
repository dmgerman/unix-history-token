begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_zyfer - clock driver for the Zyfer GPSTarplus Clock  *  * Harlan Stenn, Jan 2002  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_ZYFER
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TERMIOS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PPSCLOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This driver provides support for the TOD serial port of a Zyfer GPStarplus.  * This clock also provides PPS as well as IRIG outputs.  * Precision is limited by the serial driver, etc.  *  * If I was really brave I'd hack/generalize the serial driver to deal  * with arbitrary on-time characters.  This clock *begins* the stream with  * `!`, the on-time character, and the string is *not* EOL-terminated.  *  * Configure the beast for 9600, 8N1.  While I see leap-second stuff  * in the documentation, the published specs on the TOD format only show  * the seconds going to '59'.  I see no leap warning in the TOD format.  *  * The clock sends the following message once per second:  *  *	!TIME,2002,017,07,59,32,2,4,1  *	      YYYY DDD HH MM SS m T O  *  *	!		On-time character  *	YYYY		Year  *	DDD	001-366	Day of Year  *	HH	00-23	Hour  *	MM	00-59	Minute  *	SS	00-59	Second (probably 00-60)  *	m	1-5	Time Mode:  *			1 = GPS time  *			2 = UTC time  *			3 = LGPS time (Local GPS)  *			4 = LUTC time (Local UTC)  *			5 = Manual time  *	T	4-9	Time Figure Of Merit:  *			4         x<= 1us  *			5   1us< x<= 10 us  *			6  10us< x<= 100us  *			7 100us< x<= 1ms  *			8   1ms< x<= 10ms  *			9  10ms< x  *	O	0-4	Operation Mode:  *			0 Warm-up  *			1 Time Locked  *			2 Coasting  *			3 Recovering  *			4 Manual  *  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/zyfer%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B9600
end_define

begin_comment
comment|/* uart speed (9600 baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (about 1 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"GPS\0"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"Zyfer GPStarplus"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|LENZYFER
value|29
end_define

begin_comment
comment|/* timecode length */
end_comment

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|zyferunit
block|{
name|u_char
name|Rcvbuf
index|[
name|LENZYFER
operator|+
literal|1
index|]
decl_stmt|;
name|u_char
name|polled
decl_stmt|;
comment|/* poll message flag */
name|int
name|pollcnt
decl_stmt|;
name|l_fp
name|tstamp
decl_stmt|;
comment|/* timestamp of last poll */
name|int
name|Rcvptr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|zyfer_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zyfer_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zyfer_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zyfer_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_zyfer
init|=
block|{
name|zyfer_start
block|,
comment|/* start up driver */
name|zyfer_shutdown
block|,
comment|/* shut down driver */
name|zyfer_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old zyfer_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old zyfer_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * zyfer_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|zyfer_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|zyferunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Open serial port. 	 * Something like LDISC_ACTS that looked for ! would be nice... 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_RAW
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"zyfer(%d) fd: %d dev<%s>"
argument_list|,
name|unit
argument_list|,
name|fd
argument_list|,
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|zyferunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zyferunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|zyferunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|zyfer_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
name|up
operator|->
name|polled
operator|=
literal|0
expr_stmt|;
comment|/* May not be needed... */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zyfer_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|zyfer_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|zyferunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|zyferunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zyfer_receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|zyfer_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|zyferunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|tmode
decl_stmt|;
comment|/* Time mode */
name|int
name|tfom
decl_stmt|;
comment|/* Time Figure Of Merit */
name|int
name|omode
decl_stmt|;
comment|/* Operation mode */
name|u_char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|PPS
name|struct
name|ppsclockev
name|ppsev
decl_stmt|;
name|int
name|request
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_CIOGETEV
name|request
operator|=
name|CIOGETEV
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIOCGPPSEV
name|request
operator|=
name|TIOCGPPSEV
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* PPS */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|zyferunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
comment|/* 	 * If lencode is 0: 	 * - if *rbufp->recv_space is ! 	 * - - call refclock_gtlin to get things going 	 * - else flush 	 * else stuff it on the end of lastcode 	 * If we don't have LENZYFER bytes 	 * - wait for more data 	 * Crack the beast, and if it's OK, process it. 	 * 	 * We use refclock_getlin() because we might use LDISC_CLK. 	 * 	 * Under FreeBSD, we get the ! followed by two 14-byte packets. 	 */
if|if
condition|(
name|pp
operator|->
name|lencode
operator|>=
name|LENZYFER
condition|)
name|pp
operator|->
name|lencode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pp
operator|->
name|lencode
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|pp
operator|->
name|a_lastcode
operator|+
name|pp
operator|->
name|lencode
argument_list|,
name|p
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lencode
operator|+=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|pp
operator|->
name|a_lastcode
index|[
name|pp
operator|->
name|lencode
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|lencode
operator|<
name|LENZYFER
condition|)
return|return;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
comment|/* 	 * We get down to business, check the timecode format and decode 	 * its contents. If the timecode has invalid length or is not in 	 * proper format, we declare bad format and exit. 	 */
if|if
condition|(
name|pp
operator|->
name|lencode
operator|!=
name|LENZYFER
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Timecode sample: "!TIME,2002,017,07,59,32,2,4,1" 	 */
if|if
condition|(
name|sscanf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"!TIME,%4d,%3d,%2d,%2d,%2d,%d,%d,%d"
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|tmode
argument_list|,
operator|&
name|tfom
argument_list|,
operator|&
name|omode
argument_list|)
operator|!=
literal|8
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tmode
operator|!=
literal|2
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Should we make sure tfom is 4? */
if|if
condition|(
name|omode
operator|!=
literal|1
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PPS
if|if
condition|(
name|ioctl
argument_list|(
name|fdpps
argument_list|,
name|request
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ppsev
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|ppsev
operator|.
name|tv
operator|.
name|tv_sec
operator|+=
operator|(
name|u_int32
operator|)
name|JAN_1970
expr_stmt|;
name|TVTOTS
argument_list|(
operator|&
name|ppsev
operator|.
name|tv
argument_list|,
operator|&
name|up
operator|->
name|tstamp
argument_list|)
expr_stmt|;
block|}
comment|/* record the last ppsclock event time stamp */
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|tstamp
expr_stmt|;
endif|#
directive|endif
comment|/* PPS */
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Good place for record_clock_stats() 	 */
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|polled
condition|)
block|{
name|up
operator|->
name|polled
operator|=
literal|0
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * zyfer_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|zyfer_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|zyferunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * We don't really do anything here, except arm the receiving 	 * side to capture a sample and check for timeouts. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|zyferunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
name|up
operator|->
name|pollcnt
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|pollcnt
operator|--
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
name|up
operator|->
name|polled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_zyfer_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

