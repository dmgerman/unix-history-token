begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_irig - audio IRIG-B/E demodulator/decoder  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_IRIG
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_IOCTL_H */
end_comment

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"audio.h"
end_include

begin_comment
comment|/*  * Audio IRIG-B/E demodulator/decoder  *  * This driver receives, demodulates and decodes IRIG-B/E signals when  * connected to the audio codec /dev/audio. The IRIG signal format is an  * amplitude-modulated carrier with pulse-width modulated data bits. For  * IRIG-B, the carrier frequency is 1000 Hz and bit rate 100 b/s; for  * IRIG-E, the carrier frequenchy is 100 Hz and bit rate 10 b/s. The  * driver automatically recognizes which format is in use.  *  * The program processes 8000-Hz mu-law companded samples using separate  * signal filters for IRIG-B and IRIG-E, a comb filter, envelope  * detector and automatic threshold corrector. Cycle crossings relative  * to the corrected slice level determine the width of each pulse and  * its value - zero, one or position identifier. The data encode 20 BCD  * digits which determine the second, minute, hour and day of the year  * and sometimes the year and synchronization condition. The comb filter  * exponentially averages the corresponding samples of successive baud  * intervals in order to reliably identify the reference carrier cycle.  * A type-II phase-lock loop (PLL) performs additional integration and  * interpolation to accurately determine the zero crossing of that  * cycle, which determines the reference timestamp. A pulse-width  * discriminator demodulates the data pulses, which are then encoded as  * the BCD digits of the timecode.  *  * The timecode and reference timestamp are updated once each second  * with IRIG-B (ten seconds with IRIG-E) and local clock offset samples  * saved for later processing. At poll intervals of 64 s, the saved  * samples are processed by a trimmed-mean filter and used to update the  * system clock.  *  * An automatic gain control feature provides protection against  * overdriven or underdriven input signal amplitudes. It is designed to  * maintain adequate demodulator signal amplitude while avoiding  * occasional noise spikes. In order to assure reliable capture, the  * decompanded input signal amplitude must be greater than 100 units and  * the codec sample frequency error less than 250 PPM (.025 percent).  *  * The program performs a number of error checks to protect against  * overdriven or underdriven input signal levels, incorrect signal  * format or improper hardware configuration. Specifically, if any of  * the following errors occur for a time measurement, the data are  * rejected.  *  * o The peak carrier amplitude is less than DRPOUT (100). This usually  *   means dead IRIG signal source, broken cable or wrong input port.  *  * o The frequency error is greater than MAXFREQ +-250 PPM (.025%). This  *   usually means broken codec hardware or wrong codec configuration.  *  * o The modulation index is less than MODMIN (0.5). This usually means  *   overdriven IRIG signal or wrong IRIG format.  *  * o A frame synchronization error has occurred. This usually means wrong  *   IRIG signal format or the IRIG signal source has lost  *   synchronization (signature control).  *  * o A data decoding error has occurred. This usually means wrong IRIG  *   signal format.  *  * o The current second of the day is not exactly one greater than the  *   previous one. This usually means a very noisy IRIG signal or  *   insufficient CPU resources.  *  * o An audio codec error (overrun) occurred. This usually means  *   insufficient CPU resources, as sometimes happens with Sun SPARC  *   IPCs when doing something useful.  *  * Note that additional checks are done elsewhere in the reference clock  * interface routines.  *  * Debugging aids  *  * The timecode format used for debugging and data recording includes  * data helpful in diagnosing problems with the IRIG signal and codec  * connections. With debugging enabled (-d -d -d on the ntpd command  * line), the driver produces one line for each timecode in the  * following format:  *  * 00 1 98 23 19:26:52 721 143 0.694 47 20 0.083 66.5 3094572411.00027  *  * The most recent line is also written to the clockstats file at 64-s  * intervals.  *  * The first field contains the error flags in hex, where the hex bits  * are interpreted as below. This is followed by the IRIG status  * indicator, year of century, day of year and time of day. The status  * indicator and year are not produced by some IRIG devices. Following  * these fields are the signal amplitude (0-8100), codec gain (0-255),  * field phase (0-79), time constant (2-20), modulation index (0-1),  * carrier phase error (0+-0.5) and carrier frequency error (PPM). The  * last field is the on-time timestamp in NTP format.  *  * The fraction part of the on-time timestamp is a good indicator of how  * well the driver is doing. With an UltrSPARC 30, this thing can keep  * the clock within a few tens of microseconds relative to the IRIG-B  * signal. Accuracy with IRIG-E is about ten times worse.  *  * Unlike other drivers, which can have multiple instantiations, this  * one supports only one. It does not seem likely that more than one  * audio codec would be useful in a single machine. More than one would  * probably chew up too much CPU time anyway.  *  * Fudge factors  *  * Fudge flag2 selects the audio input port, where 0 is the mike port  * (default) and 1 is the line-in port. It does not seem useful to  * select the compact disc player port. Fudge flag3 enables audio  * monitoring of the input signal. For this purpose, the speaker volume  * must be set before the driver is started. Fudge flag4 causes the  * debugging output described above to be recorded in the clockstats  * file. Any of these flags can be changed during operation with the  * ntpdc program.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-17)
end_define

begin_comment
comment|/* precision assumed (about 10 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"IRIG"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"Generic IRIG Audio Driver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|SECOND
value|8000
end_define

begin_comment
comment|/* nominal sample rate (Hz) */
end_comment

begin_define
define|#
directive|define
name|BAUD
value|80
end_define

begin_comment
comment|/* samples per baud interval */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|128
end_define

begin_comment
comment|/* companded sample offset */
end_comment

begin_define
define|#
directive|define
name|SIZE
value|256
end_define

begin_comment
comment|/* decompanding table size */
end_comment

begin_define
define|#
directive|define
name|CYCLE
value|8
end_define

begin_comment
comment|/* samples per carrier cycle */
end_comment

begin_define
define|#
directive|define
name|SUBFLD
value|10
end_define

begin_comment
comment|/* bits per subfield */
end_comment

begin_define
define|#
directive|define
name|FIELD
value|10
end_define

begin_comment
comment|/* subfields per field */
end_comment

begin_define
define|#
directive|define
name|MINTC
value|2
end_define

begin_comment
comment|/* min PLL time constant */
end_comment

begin_define
define|#
directive|define
name|MAXTC
value|20
end_define

begin_comment
comment|/* max PLL time constant max */
end_comment

begin_define
define|#
directive|define
name|MAXSIG
value|6000.
end_define

begin_comment
comment|/* maximum signal level */
end_comment

begin_define
define|#
directive|define
name|DRPOUT
value|100.
end_define

begin_comment
comment|/* dropout signal level */
end_comment

begin_define
define|#
directive|define
name|MODMIN
value|0.5
end_define

begin_comment
comment|/* minimum modulation index */
end_comment

begin_define
define|#
directive|define
name|MAXFREQ
value|(250e-6 * SECOND)
end_define

begin_comment
comment|/* freq tolerance (.025%) */
end_comment

begin_define
define|#
directive|define
name|PI
value|3.1415926535
end_define

begin_comment
comment|/* the real thing */
end_comment

begin_comment
comment|/*  * Experimentally determined fudge factors  */
end_comment

begin_define
define|#
directive|define
name|IRIG_B
value|.0019
end_define

begin_comment
comment|/* IRIG-B phase delay */
end_comment

begin_define
define|#
directive|define
name|IRIG_E
value|.0019
end_define

begin_comment
comment|/* IRIG-E phase delay */
end_comment

begin_comment
comment|/*  * Data bit definitions  */
end_comment

begin_define
define|#
directive|define
name|BIT0
value|0
end_define

begin_comment
comment|/* zero */
end_comment

begin_define
define|#
directive|define
name|BIT1
value|1
end_define

begin_comment
comment|/* one */
end_comment

begin_define
define|#
directive|define
name|BITP
value|2
end_define

begin_comment
comment|/* position identifier */
end_comment

begin_comment
comment|/*  * Error flags (up->errflg)  */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_AMP
value|0x01
end_define

begin_comment
comment|/* low carrier amplitude */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_FREQ
value|0x02
end_define

begin_comment
comment|/* frequency tolerance exceeded */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_MOD
value|0x04
end_define

begin_comment
comment|/* low modulation index */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_SYNCH
value|0x08
end_define

begin_comment
comment|/* frame synch error */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_DECODE
value|0x10
end_define

begin_comment
comment|/* frame decoding error */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_CHECK
value|0x20
end_define

begin_comment
comment|/* second numbering discrepancy */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_ERROR
value|0x40
end_define

begin_comment
comment|/* codec error (overrun) */
end_comment

begin_comment
comment|/*  * IRIG unit control structure  */
end_comment

begin_struct
struct|struct
name|irigunit
block|{
name|u_char
name|timecode
index|[
literal|21
index|]
decl_stmt|;
comment|/* timecode string */
name|l_fp
name|timestamp
decl_stmt|;
comment|/* audio sample timestamp */
name|l_fp
name|tick
decl_stmt|;
comment|/* audio sample increment */
name|double
name|comp
index|[
name|SIZE
index|]
decl_stmt|;
comment|/* decompanding table */
name|double
name|integ
index|[
name|BAUD
index|]
decl_stmt|;
comment|/* baud integrator */
name|double
name|phase
decl_stmt|,
name|freq
decl_stmt|;
comment|/* logical clock phase and frequency */
name|double
name|zxing
decl_stmt|;
comment|/* phase detector integrator */
name|double
name|yxing
decl_stmt|;
comment|/* phase detector display */
name|double
name|modndx
decl_stmt|;
comment|/* modulation index */
name|double
name|irig_b
decl_stmt|;
comment|/* IRIG-B signal amplitude */
name|double
name|irig_e
decl_stmt|;
comment|/* IRIG-E signal amplitude */
name|int
name|errflg
decl_stmt|;
comment|/* error flags */
name|int
name|bufcnt
decl_stmt|;
comment|/* samples in buffer */
name|int
name|bufptr
decl_stmt|;
comment|/* buffer index pointer */
name|int
name|pollcnt
decl_stmt|;
comment|/* poll counter */
name|int
name|port
decl_stmt|;
comment|/* codec port */
name|int
name|gain
decl_stmt|;
comment|/* codec gain */
name|int
name|clipcnt
decl_stmt|;
comment|/* sample clipped count */
name|int
name|seccnt
decl_stmt|;
comment|/* second interval counter */
name|int
name|decim
decl_stmt|;
comment|/* sample decimation factor */
comment|/* 	 * RF variables 	 */
name|double
name|hpf
index|[
literal|5
index|]
decl_stmt|;
comment|/* IRIG-B filter shift register */
name|double
name|lpf
index|[
literal|5
index|]
decl_stmt|;
comment|/* IRIG-E filter shift register */
name|double
name|intmin
decl_stmt|,
name|intmax
decl_stmt|;
comment|/* integrated envelope min and max */
name|double
name|envmax
decl_stmt|;
comment|/* peak amplitude */
name|double
name|envmin
decl_stmt|;
comment|/* noise amplitude */
name|double
name|maxsignal
decl_stmt|;
comment|/* integrated peak amplitude */
name|double
name|noise
decl_stmt|;
comment|/* integrated noise amplitude */
name|double
name|lastenv
index|[
name|CYCLE
index|]
decl_stmt|;
comment|/* last cycle amplitudes */
name|double
name|lastint
index|[
name|CYCLE
index|]
decl_stmt|;
comment|/* last integrated cycle amplitudes */
name|double
name|lastsig
decl_stmt|;
comment|/* last carrier sample */
name|double
name|xxing
decl_stmt|;
comment|/* phase detector interpolated output */
name|double
name|fdelay
decl_stmt|;
comment|/* filter delay */
name|int
name|envphase
decl_stmt|;
comment|/* envelope phase */
name|int
name|envptr
decl_stmt|;
comment|/* envelope phase pointer */
name|int
name|carphase
decl_stmt|;
comment|/* carrier phase */
name|int
name|envsw
decl_stmt|;
comment|/* envelope state */
name|int
name|envxing
decl_stmt|;
comment|/* envelope slice crossing */
name|int
name|tc
decl_stmt|;
comment|/* time constant */
name|int
name|tcount
decl_stmt|;
comment|/* time constant counter */
name|int
name|badcnt
decl_stmt|;
comment|/* decimation interval counter */
comment|/* 	 * Decoder variables 	 */
name|l_fp
name|montime
decl_stmt|;
comment|/* reference timestamp for eyeball */
name|int
name|timecnt
decl_stmt|;
comment|/* timecode counter */
name|int
name|pulse
decl_stmt|;
comment|/* cycle counter */
name|int
name|cycles
decl_stmt|;
comment|/* carrier cycles */
name|int
name|dcycles
decl_stmt|;
comment|/* data cycles */
name|int
name|xptr
decl_stmt|;
comment|/* translate table pointer */
name|int
name|lastbit
decl_stmt|;
comment|/* last code element length */
name|int
name|second
decl_stmt|;
comment|/* previous second */
name|int
name|fieldcnt
decl_stmt|;
comment|/* subfield count in field */
name|int
name|bits
decl_stmt|;
comment|/* demodulated bits */
name|int
name|bitcnt
decl_stmt|;
comment|/* bit count in subfield */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|irig_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|irig_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|irig_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|irig_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * More function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|irig_base
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|irig_rf
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|irig_decode
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|irig_gain
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_irig
init|=
block|{
name|irig_start
block|,
comment|/* start up driver */
name|irig_shutdown
block|,
comment|/* shut down driver */
name|irig_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old irig_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old irig_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hexchar
index|[]
init|=
block|{
comment|/* really quick decoding table */
literal|'0'
block|,
literal|'8'
block|,
literal|'4'
block|,
literal|'c'
block|,
comment|/* 0000 0001 0010 0011 */
literal|'2'
block|,
literal|'a'
block|,
literal|'6'
block|,
literal|'e'
block|,
comment|/* 0100 0101 0110 0111 */
literal|'1'
block|,
literal|'9'
block|,
literal|'5'
block|,
literal|'d'
block|,
comment|/* 1000 1001 1010 1011 */
literal|'3'
block|,
literal|'b'
block|,
literal|'7'
block|,
literal|'f'
comment|/* 1100 1101 1110 1111 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * irig_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|irig_start
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|i
decl_stmt|;
comment|/* index */
name|double
name|step
decl_stmt|;
comment|/* codec adjustment */
comment|/* 	 * Open audio device 	 */
name|fd
operator|=
name|audio_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|audio_show
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|irigunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|irigunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|irigunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|irig_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|tc
operator|=
name|MINTC
expr_stmt|;
name|up
operator|->
name|decim
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|fdelay
operator|=
name|IRIG_B
expr_stmt|;
name|up
operator|->
name|gain
operator|=
literal|127
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
comment|/* 	 * The companded samples are encoded sign-magnitude. The table 	 * contains all the 256 values in the interest of speed. 	 */
name|up
operator|->
name|comp
index|[
literal|0
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|OFFSET
index|]
operator|=
literal|0.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|1
index|]
operator|=
operator|-
literal|1.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|2
index|]
operator|=
operator|-
literal|3.
expr_stmt|;
name|step
operator|=
literal|2.
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|OFFSET
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|comp
index|[
name|i
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|step
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
name|i
index|]
operator|=
operator|-
name|up
operator|->
name|comp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
name|step
operator|*=
literal|2.
expr_stmt|;
block|}
name|DTOLFP
argument_list|(
literal|1.
operator|/
name|SECOND
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * irig_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|irig_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|irigunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * irig_receive - receive data from the audio device  *  * This routine reads input samples and adjusts the logical clock to  * track the irig clock by dropping or duplicating codec samples.  */
end_comment

begin_function
specifier|static
name|void
name|irig_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|sample
decl_stmt|;
comment|/* codec sample */
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* buffer pointer */
name|l_fp
name|ltemp
decl_stmt|;
comment|/* l_fp temp */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|irigunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Main loop - read until there ain't no more. Note codec 	 * samples are bit-inverted. 	 */
name|up
operator|->
name|timestamp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|up
operator|->
name|bufcnt
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|DTOLFP
argument_list|(
operator|(
name|double
operator|)
name|up
operator|->
name|bufcnt
operator|/
name|SECOND
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|dpt
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
for|for
control|(
name|up
operator|->
name|bufptr
operator|=
literal|0
init|;
name|up
operator|->
name|bufptr
operator|<
name|up
operator|->
name|bufcnt
condition|;
name|up
operator|->
name|bufptr
operator|++
control|)
block|{
name|sample
operator|=
name|up
operator|->
name|comp
index|[
operator|~
operator|*
name|dpt
operator|++
operator|&
literal|0xff
index|]
expr_stmt|;
comment|/* 		 * Clip noise spikes greater than MAXSIG. If no clips, 		 * increase the gain a tad; if the clips are too high,  		 * decrease a tad. Choose either IRIG-B or IRIG-E 		 * according to the energy at the respective filter 		 * output. 		 */
if|if
condition|(
name|sample
operator|>
name|MAXSIG
condition|)
block|{
name|sample
operator|=
name|MAXSIG
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sample
operator|<
operator|-
name|MAXSIG
condition|)
block|{
name|sample
operator|=
operator|-
name|MAXSIG
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
comment|/* 		 * Variable frequency oscillator. A phase change of one 		 * unit produces a change of 360 degrees; a frequency 		 * change of one unit produces a change of 1 Hz. 		 */
name|up
operator|->
name|phase
operator|+=
name|up
operator|->
name|freq
operator|/
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|phase
operator|>=
literal|.5
condition|)
block|{
name|up
operator|->
name|phase
operator|-=
literal|1.
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|phase
operator|<
operator|-
literal|.5
condition|)
block|{
name|up
operator|->
name|phase
operator|+=
literal|1.
expr_stmt|;
name|irig_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
name|irig_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|irig_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
name|L_ADD
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
comment|/* 		 * Once each second, determine the IRIG format, codec 		 * port and gain. 		 */
name|up
operator|->
name|seccnt
operator|=
operator|(
name|up
operator|->
name|seccnt
operator|+
literal|1
operator|)
operator|%
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|seccnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|irig_b
operator|>
name|up
operator|->
name|irig_e
condition|)
block|{
name|up
operator|->
name|decim
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|fdelay
operator|=
name|IRIG_B
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|decim
operator|=
literal|10
expr_stmt|;
name|up
operator|->
name|fdelay
operator|=
name|IRIG_E
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
name|up
operator|->
name|port
operator|=
literal|2
expr_stmt|;
else|else
name|up
operator|->
name|port
operator|=
literal|1
expr_stmt|;
name|irig_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|irig_b
operator|=
name|up
operator|->
name|irig_e
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Squawk to the monitor speaker if enabled. 	 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
condition|)
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
argument_list|,
operator|(
name|u_int
operator|)
name|up
operator|->
name|bufcnt
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"irig:"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * irig_rf - RF processing  *  * This routine filters the RF signal using a highpass filter for IRIG-B  * and a lowpass filter for IRIG-E. In case of IRIG-E, the samples are  * decimated by a factor of ten. The lowpass filter functions also as a  * decimation filter in this case. Note that the codec filters function  * as roofing filters to attenuate both the high and low ends of the  * passband. IIR filter coefficients were determined using Matlab Signal  * Processing Toolkit.  */
end_comment

begin_function
specifier|static
name|void
name|irig_rf
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample
comment|/* current signal sample */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|irig_b
decl_stmt|,
name|irig_e
decl_stmt|;
comment|/* irig filter outputs */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|irigunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * IRIG-B filter. 4th-order elliptic, 800-Hz highpass, 0.3 dB 	 * passband ripple, -50 dB stopband ripple, phase delay -.0022 	 * s) 	 */
name|irig_b
operator|=
operator|(
name|up
operator|->
name|hpf
index|[
literal|4
index|]
operator|=
name|up
operator|->
name|hpf
index|[
literal|3
index|]
operator|)
operator|*
literal|2.322484e-01
expr_stmt|;
name|irig_b
operator|+=
operator|(
name|up
operator|->
name|hpf
index|[
literal|3
index|]
operator|=
name|up
operator|->
name|hpf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|1.103929e+00
expr_stmt|;
name|irig_b
operator|+=
operator|(
name|up
operator|->
name|hpf
index|[
literal|2
index|]
operator|=
name|up
operator|->
name|hpf
index|[
literal|1
index|]
operator|)
operator|*
literal|2.351081e+00
expr_stmt|;
name|irig_b
operator|+=
operator|(
name|up
operator|->
name|hpf
index|[
literal|1
index|]
operator|=
name|up
operator|->
name|hpf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|2.335036e+00
expr_stmt|;
name|up
operator|->
name|hpf
index|[
literal|0
index|]
operator|=
name|sample
operator|-
name|irig_b
expr_stmt|;
name|irig_b
operator|=
name|up
operator|->
name|hpf
index|[
literal|0
index|]
operator|*
literal|4.335855e-01
operator|+
name|up
operator|->
name|hpf
index|[
literal|1
index|]
operator|*
operator|-
literal|1.695859e+00
operator|+
name|up
operator|->
name|hpf
index|[
literal|2
index|]
operator|*
literal|2.525004e+00
operator|+
name|up
operator|->
name|hpf
index|[
literal|3
index|]
operator|*
operator|-
literal|1.695859e+00
operator|+
name|up
operator|->
name|hpf
index|[
literal|4
index|]
operator|*
literal|4.335855e-01
expr_stmt|;
name|up
operator|->
name|irig_b
operator|+=
name|irig_b
operator|*
name|irig_b
expr_stmt|;
comment|/* 	 * IRIG-E filter. 4th-order elliptic, 130-Hz lowpass, 0.3 dB 	 * passband ripple, -50 dB stopband ripple, phase delay .0219 s. 	 */
name|irig_e
operator|=
operator|(
name|up
operator|->
name|lpf
index|[
literal|4
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|)
operator|*
literal|8.694604e-01
expr_stmt|;
name|irig_e
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|3.589893e+00
expr_stmt|;
name|irig_e
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|)
operator|*
literal|5.570154e+00
expr_stmt|;
name|irig_e
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|3.849667e+00
expr_stmt|;
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|=
name|sample
operator|-
name|irig_e
expr_stmt|;
name|irig_e
operator|=
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|*
literal|3.215696e-03
operator|+
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|*
operator|-
literal|1.174951e-02
operator|+
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|*
literal|1.712074e-02
operator|+
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|*
operator|-
literal|1.174951e-02
operator|+
name|up
operator|->
name|lpf
index|[
literal|4
index|]
operator|*
literal|3.215696e-03
expr_stmt|;
name|up
operator|->
name|irig_e
operator|+=
name|irig_e
operator|*
name|irig_e
expr_stmt|;
comment|/* 	 * Decimate by a factor of either 1 (IRIG-B) or 10 (IRIG-E). 	 */
name|up
operator|->
name|badcnt
operator|=
operator|(
name|up
operator|->
name|badcnt
operator|+
literal|1
operator|)
operator|%
name|up
operator|->
name|decim
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|badcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|decim
operator|==
literal|1
condition|)
name|irig_base
argument_list|(
name|peer
argument_list|,
name|irig_b
argument_list|)
expr_stmt|;
else|else
name|irig_base
argument_list|(
name|peer
argument_list|,
name|irig_e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * irig_base - baseband processing  *  * This routine processes the baseband signal and demodulates the AM  * carrier using a synchronous detector. It then synchronizes to the  * data frame at the baud rate and decodes the data pulses.  */
end_comment

begin_function
specifier|static
name|void
name|irig_base
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample
comment|/* current signal sample */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|lope
decl_stmt|;
comment|/* integrator output */
name|double
name|env
decl_stmt|;
comment|/* envelope detector output */
name|double
name|dtemp
decl_stmt|;
comment|/* double temp */
name|int
name|i
decl_stmt|;
comment|/* index temp */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|irigunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Synchronous baud integrator. Corresponding samples of current 	 * and past baud intervals are integrated to refine the envelope 	 * amplitude and phase estimate. We keep one cycle of both the 	 * raw and integrated data for later use. 	 */
name|up
operator|->
name|envphase
operator|=
operator|(
name|up
operator|->
name|envphase
operator|+
literal|1
operator|)
operator|%
name|BAUD
expr_stmt|;
name|up
operator|->
name|carphase
operator|=
operator|(
name|up
operator|->
name|carphase
operator|+
literal|1
operator|)
operator|%
name|CYCLE
expr_stmt|;
name|up
operator|->
name|integ
index|[
name|up
operator|->
name|envphase
index|]
operator|+=
operator|(
name|sample
operator|-
name|up
operator|->
name|integ
index|[
name|up
operator|->
name|envphase
index|]
operator|)
operator|/
operator|(
literal|5
operator|*
name|up
operator|->
name|tc
operator|)
expr_stmt|;
name|lope
operator|=
name|up
operator|->
name|integ
index|[
name|up
operator|->
name|envphase
index|]
expr_stmt|;
name|up
operator|->
name|lastenv
index|[
name|up
operator|->
name|carphase
index|]
operator|=
name|sample
expr_stmt|;
name|up
operator|->
name|lastint
index|[
name|up
operator|->
name|carphase
index|]
operator|=
name|lope
expr_stmt|;
comment|/* 	 * Phase detector. Sample amplitudes are integrated over the 	 * baud interval. Cycle phase is determined from these 	 * amplitudes using an eight-sample cyclic buffer. A phase 	 * change of 360 degrees produces an output change of one unit. 	 */
if|if
condition|(
name|up
operator|->
name|lastsig
operator|>
literal|0
operator|&&
name|lope
operator|<=
literal|0
condition|)
block|{
name|up
operator|->
name|xxing
operator|=
name|lope
operator|/
operator|(
name|up
operator|->
name|lastsig
operator|-
name|lope
operator|)
expr_stmt|;
name|up
operator|->
name|zxing
operator|+=
operator|(
name|up
operator|->
name|carphase
operator|-
literal|4
operator|+
name|up
operator|->
name|xxing
operator|)
operator|/
literal|8.
expr_stmt|;
block|}
name|up
operator|->
name|lastsig
operator|=
name|lope
expr_stmt|;
comment|/* 	 * Update signal/noise estimates and PLL phase/frequency. 	 */
if|if
condition|(
name|up
operator|->
name|envphase
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Update envelope signal and noise estimates and mess 		 * with error bits. 		 */
name|up
operator|->
name|maxsignal
operator|=
name|up
operator|->
name|intmax
expr_stmt|;
name|up
operator|->
name|noise
operator|=
name|up
operator|->
name|intmin
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|maxsignal
operator|<
name|DRPOUT
condition|)
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_AMP
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|intmax
operator|>
literal|0
condition|)
name|up
operator|->
name|modndx
operator|=
operator|(
name|up
operator|->
name|intmax
operator|-
name|up
operator|->
name|intmin
operator|)
operator|/
name|up
operator|->
name|intmax
expr_stmt|;
else|else
name|up
operator|->
name|modndx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|modndx
operator|<
name|MODMIN
condition|)
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_MOD
expr_stmt|;
name|up
operator|->
name|intmin
operator|=
literal|1e6
expr_stmt|;
name|up
operator|->
name|intmax
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errflg
operator|&
operator|(
name|IRIG_ERR_AMP
operator||
name|IRIG_ERR_FREQ
operator||
name|IRIG_ERR_MOD
operator||
name|IRIG_ERR_SYNCH
operator|)
condition|)
block|{
name|up
operator|->
name|tc
operator|=
name|MINTC
expr_stmt|;
name|up
operator|->
name|tcount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Update PLL phase and frequency. The PLL time constant 		 * is set initially to stabilize the frequency within a 		 * minute or two, then increases to the maximum. The 		 * frequency is clamped so that the PLL capture range 		 * cannot be exceeded. 		 */
name|dtemp
operator|=
name|up
operator|->
name|zxing
operator|*
name|up
operator|->
name|decim
operator|/
name|BAUD
expr_stmt|;
name|up
operator|->
name|yxing
operator|=
name|dtemp
expr_stmt|;
name|up
operator|->
name|zxing
operator|=
literal|0.
expr_stmt|;
name|up
operator|->
name|phase
operator|+=
name|dtemp
operator|/
name|up
operator|->
name|tc
expr_stmt|;
name|up
operator|->
name|freq
operator|+=
name|dtemp
operator|/
operator|(
literal|4.
operator|*
name|up
operator|->
name|tc
operator|*
name|up
operator|->
name|tc
operator|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|freq
operator|>
name|MAXFREQ
condition|)
block|{
name|up
operator|->
name|freq
operator|=
name|MAXFREQ
expr_stmt|;
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_FREQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|freq
operator|<
operator|-
name|MAXFREQ
condition|)
block|{
name|up
operator|->
name|freq
operator|=
operator|-
name|MAXFREQ
expr_stmt|;
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_FREQ
expr_stmt|;
block|}
block|}
comment|/* 	 * Synchronous demodulator. There are eight samples in the cycle 	 * and ten cycles in the baud interval. The amplitude of each 	 * cycle is determined at the last sample in the cycle. The 	 * beginning of the data pulse is determined from the integrated 	 * samples, while the end of the pulse is determined from the 	 * raw samples. The raw data bits are demodulated relative to 	 * the slice level and left-shifted in the decoding register. 	 */
if|if
condition|(
name|up
operator|->
name|carphase
operator|!=
literal|7
condition|)
return|return;
name|env
operator|=
operator|(
name|up
operator|->
name|lastenv
index|[
literal|2
index|]
operator|-
name|up
operator|->
name|lastenv
index|[
literal|6
index|]
operator|)
operator|/
literal|2.
expr_stmt|;
name|lope
operator|=
operator|(
name|up
operator|->
name|lastint
index|[
literal|2
index|]
operator|-
name|up
operator|->
name|lastint
index|[
literal|6
index|]
operator|)
operator|/
literal|2.
expr_stmt|;
if|if
condition|(
name|lope
operator|>
name|up
operator|->
name|intmax
condition|)
name|up
operator|->
name|intmax
operator|=
name|lope
expr_stmt|;
if|if
condition|(
name|lope
operator|<
name|up
operator|->
name|intmin
condition|)
name|up
operator|->
name|intmin
operator|=
name|lope
expr_stmt|;
comment|/* 	 * Pulse code demodulator and reference timestamp. The decoder 	 * looks for a sequence of ten bits; the first two bits must be 	 * one, the last two bits must be zero. Frame synch is asserted 	 * when three correct frames have been found. 	 */
name|up
operator|->
name|pulse
operator|=
operator|(
name|up
operator|->
name|pulse
operator|+
literal|1
operator|)
operator|%
literal|10
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|pulse
operator|==
literal|1
condition|)
name|up
operator|->
name|envmax
operator|=
name|env
expr_stmt|;
elseif|else
if|if
condition|(
name|up
operator|->
name|pulse
operator|==
literal|9
condition|)
name|up
operator|->
name|envmin
operator|=
name|env
expr_stmt|;
name|up
operator|->
name|dcycles
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|env
operator|>=
operator|(
name|up
operator|->
name|envmax
operator|+
name|up
operator|->
name|envmin
operator|)
operator|/
literal|2.
condition|)
name|up
operator|->
name|dcycles
operator||=
literal|1
expr_stmt|;
name|up
operator|->
name|cycles
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|lope
operator|>=
operator|(
name|up
operator|->
name|maxsignal
operator|+
name|up
operator|->
name|noise
operator|)
operator|/
literal|2.
condition|)
name|up
operator|->
name|cycles
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|up
operator|->
name|cycles
operator|&
literal|0x303c0f03
operator|)
operator|==
literal|0x300c0300
condition|)
block|{
name|l_fp
name|ltemp
decl_stmt|;
name|int
name|bitz
decl_stmt|;
comment|/* 		 * The PLL time constant starts out small, in order to 		 * sustain a frequency tolerance of 250 PPM. It 		 * gradually increases as the loop settles down. Note 		 * that small wiggles are not believed, unless they 		 * persist for lots of samples. 		 */
if|if
condition|(
name|up
operator|->
name|pulse
operator|!=
literal|9
condition|)
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_SYNCH
expr_stmt|;
name|up
operator|->
name|pulse
operator|=
literal|9
expr_stmt|;
name|dtemp
operator|=
name|BAUD
operator|-
name|up
operator|->
name|zxing
expr_stmt|;
name|i
operator|=
name|up
operator|->
name|envxing
operator|-
name|up
operator|->
name|envphase
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|1
condition|)
block|{
name|up
operator|->
name|tcount
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|tcount
operator|>
literal|50
operator|*
name|up
operator|->
name|tc
condition|)
block|{
name|up
operator|->
name|tc
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|tc
operator|>
name|MAXTC
condition|)
name|up
operator|->
name|tc
operator|=
name|MAXTC
expr_stmt|;
name|up
operator|->
name|tcount
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|envxing
operator|=
name|up
operator|->
name|envphase
expr_stmt|;
block|}
else|else
block|{
name|dtemp
operator|-=
name|up
operator|->
name|envxing
operator|-
name|up
operator|->
name|envphase
expr_stmt|;
block|}
block|}
else|else
block|{
name|up
operator|->
name|tcount
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|envxing
operator|=
name|up
operator|->
name|envphase
expr_stmt|;
block|}
comment|/* 		 * Determine a reference timestamp, accounting for the 		 * codec delay and filter delay. Note the timestamp is 		 * for the previous frame, so we have to backtrack for 		 * this plus the delay since the last carrier positive 		 * zero crossing. 		 */
name|DTOLFP
argument_list|(
name|up
operator|->
name|decim
operator|*
operator|(
name|dtemp
operator|/
name|SECOND
operator|+
literal|1.
operator|)
operator|+
name|up
operator|->
name|fdelay
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
comment|/* 		 * The data bits are collected in ten-bit frames. The 		 * first two and last two bits are determined by frame 		 * sync and ignored here; the resulting patterns 		 * represent zero (0-1 bits), one (2-4 bits) and 		 * position identifier (5-6 bits). The remaining 		 * patterns represent errors and are treated as zeros. 		 */
name|bitz
operator|=
name|up
operator|->
name|dcycles
operator|&
literal|0xfc
expr_stmt|;
switch|switch
condition|(
name|bitz
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x80
case|:
name|irig_decode
argument_list|(
name|peer
argument_list|,
name|BIT0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
case|case
literal|0xe0
case|:
case|case
literal|0xf0
case|:
name|irig_decode
argument_list|(
name|peer
argument_list|,
name|BIT1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xf8
case|:
case|case
literal|0xfc
case|:
name|irig_decode
argument_list|(
name|peer
argument_list|,
name|BITP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|irig_decode
argument_list|(
name|peer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_DECODE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * irig_decode - decode the data  *  * This routine assembles bits into digits, digits into subfields and  * subfields into the timecode field. Bits can have values of zero, one  * or position identifier. There are four bits per digit, two digits per  * subfield and ten subfields per field. The last bit in every subfield  * and the first bit in the first subfield are position identifiers.  */
end_comment

begin_function
specifier|static
name|void
name|irig_decode
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|bit
comment|/* data bit (0, 1 or 2) */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|char
name|syncchar
decl_stmt|;
comment|/* sync character (Spectracom only) */
name|char
name|sbs
index|[
literal|6
index|]
decl_stmt|;
comment|/* binary seconds since 0h */
name|char
name|spare
index|[
literal|2
index|]
decl_stmt|;
comment|/* mulligan digits */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|irigunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Assemble subfield bits. 	 */
name|up
operator|->
name|bits
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|bit
operator|==
name|BIT1
condition|)
block|{
name|up
operator|->
name|bits
operator||=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bit
operator|==
name|BITP
operator|&&
name|up
operator|->
name|lastbit
operator|==
name|BITP
condition|)
block|{
comment|/* 		 * Frame sync - two adjacent position identifiers. 		 * Monitor the reference timestamp and wiggle the 		 * clock, but only if no errors have occurred. 		 */
name|up
operator|->
name|bitcnt
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|fieldcnt
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|lastbit
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|montime
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errflg
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|timecnt
operator|++
expr_stmt|;
name|refclock_process
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|timecnt
operator|>=
name|MAXSTAGE
condition|)
block|{
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|timecnt
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
block|}
name|up
operator|->
name|errflg
operator|=
literal|0
expr_stmt|;
block|}
name|up
operator|->
name|bitcnt
operator|=
operator|(
name|up
operator|->
name|bitcnt
operator|+
literal|1
operator|)
operator|%
name|SUBFLD
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|bitcnt
operator|==
literal|0
condition|)
block|{
comment|/* 		 * End of subfield. Encode two hexadecimal digits in 		 * little-endian timecode field. 		 */
if|if
condition|(
name|up
operator|->
name|fieldcnt
operator|==
literal|0
condition|)
name|up
operator|->
name|bits
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|xptr
operator|<
literal|2
condition|)
name|up
operator|->
name|xptr
operator|=
literal|2
operator|*
name|FIELD
expr_stmt|;
name|up
operator|->
name|timecode
index|[
operator|--
name|up
operator|->
name|xptr
index|]
operator|=
name|hexchar
index|[
operator|(
name|up
operator|->
name|bits
operator|>>
literal|5
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|up
operator|->
name|timecode
index|[
operator|--
name|up
operator|->
name|xptr
index|]
operator|=
name|hexchar
index|[
name|up
operator|->
name|bits
operator|&
literal|0xf
index|]
expr_stmt|;
name|up
operator|->
name|fieldcnt
operator|=
operator|(
name|up
operator|->
name|fieldcnt
operator|+
literal|1
operator|)
operator|%
name|FIELD
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fieldcnt
operator|==
literal|0
condition|)
block|{
comment|/* 			 * End of field. Decode the timecode, adjust the 			 * gain and set the input port. Set the port 			 * here on the assumption somebody might even 			 * change it on-wing. 			 */
name|up
operator|->
name|xptr
operator|=
literal|2
operator|*
name|FIELD
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
operator|->
name|timecode
argument_list|,
literal|"%6s%2d%c%2s%3d%2d%2d%2d"
argument_list|,
name|sbs
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|syncchar
argument_list|,
name|spare
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|)
operator|!=
literal|8
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
else|else
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|up
operator|->
name|second
operator|=
operator|(
name|up
operator|->
name|second
operator|+
name|up
operator|->
name|decim
operator|)
operator|%
literal|60
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|second
operator|!=
name|up
operator|->
name|second
condition|)
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_CHECK
expr_stmt|;
name|up
operator|->
name|second
operator|=
name|pp
operator|->
name|second
expr_stmt|;
name|sprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%02x %c %2d %3d %02d:%02d:%02d %4.0f %3d %6.3f %2d %2d %6.3f %6.1f %s"
argument_list|,
name|up
operator|->
name|errflg
argument_list|,
name|syncchar
argument_list|,
name|pp
operator|->
name|year
argument_list|,
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|up
operator|->
name|maxsignal
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|modndx
argument_list|,
name|up
operator|->
name|envxing
argument_list|,
name|up
operator|->
name|tc
argument_list|,
name|up
operator|->
name|yxing
argument_list|,
name|up
operator|->
name|freq
operator|*
literal|1e6
operator|/
name|SECOND
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|up
operator|->
name|montime
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|timecnt
operator|==
literal|0
operator|||
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"irig: %s\n"
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
name|up
operator|->
name|lastbit
operator|=
name|bit
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * irig_poll - called by the transmit procedure  *  * This routine keeps track of status. If nothing is heard for two  * successive poll intervals, a timeout event is declared and any  * orphaned timecode updates are sent to foster care.   */
end_comment

begin_function
specifier|static
name|void
name|irig_poll
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|irigunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Keep book for tattletales 	 */
if|if
condition|(
name|up
operator|->
name|pollcnt
operator|==
literal|0
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
name|up
operator|->
name|timecnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|pollcnt
operator|--
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * irig_gain - adjust codec gain  *  * This routine is called once each second. If the signal envelope  * amplitude is too low, the codec gain is bumped up by four units; if  * too high, it is bumped down. The decoder is relatively insensitive to  * amplitude, so this crudity works just fine. The input port is set and  * the error flag is cleared, mostly to be ornery.  */
end_comment

begin_function
specifier|static
name|void
name|irig_gain
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|irigunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Apparently, the codec uses only the high order bits of the 	 * gain control field. Thus, it may take awhile for changes to 	 * wiggle the hardware bits. 	 */
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|gain
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|>
literal|255
condition|)
name|up
operator|->
name|gain
operator|=
literal|255
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|>
name|SECOND
operator|/
literal|100
condition|)
block|{
name|up
operator|->
name|gain
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|<
literal|0
condition|)
name|up
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
block|}
name|audio_gain
argument_list|(
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|port
argument_list|)
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_irig_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

