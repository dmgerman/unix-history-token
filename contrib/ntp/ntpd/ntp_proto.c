begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_proto.c - NTP version 4 protocol machinery  *  * $FreeBSD$  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|VMS_LOCALUNIT
argument_list|)
end_if

begin_comment
comment|/*wjm*/
end_comment

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * System variables are declared here.	See Section 3.2 of the  * specification.  */
end_comment

begin_decl_stmt
name|u_char
name|sys_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system leap indicator */
end_comment

begin_decl_stmt
name|u_char
name|sys_stratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stratum of system */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision */
end_comment

begin_decl_stmt
name|double
name|sys_rootdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* distance to current sync source */
end_comment

begin_decl_stmt
name|double
name|sys_rootdispersion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dispersion of system clock */
end_comment

begin_decl_stmt
name|u_int32
name|sys_refid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference source for local clock */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current local clock offset */
end_comment

begin_decl_stmt
name|l_fp
name|sys_reftime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time we were last updated */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our current peer */
end_comment

begin_decl_stmt
name|u_long
name|sys_automax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum session key lifetime */
end_comment

begin_comment
comment|/*  * Nonspecified system state variables.  */
end_comment

begin_decl_stmt
name|int
name|sys_bclient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we set our time to broadcasts */
end_comment

begin_decl_stmt
name|double
name|sys_bdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* broadcast client default delay */
end_comment

begin_decl_stmt
name|int
name|sys_authenticate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* requre authentication for config */
end_comment

begin_decl_stmt
name|l_fp
name|sys_authdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|sys_authdly
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay shift reg */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|leap_consensus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* consensus of survivor leap bits */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_maxd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* select error (squares) */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_epsil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system error (squares) */
end_comment

begin_decl_stmt
name|u_long
name|sys_private
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private value for session seed */
end_comment

begin_decl_stmt
name|int
name|sys_manycastserver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => respond to manycast client pkts */
end_comment

begin_comment
comment|/*  * Statistics counters  */
end_comment

begin_decl_stmt
name|u_long
name|sys_stattime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time when we started recording */
end_comment

begin_decl_stmt
name|u_long
name|sys_badstratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets with invalid stratum */
end_comment

begin_decl_stmt
name|u_long
name|sys_oldversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* old version packets received */
end_comment

begin_decl_stmt
name|u_long
name|sys_newversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new version packets received */
end_comment

begin_decl_stmt
name|u_long
name|sys_unknownversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't know version packets */
end_comment

begin_decl_stmt
name|u_long
name|sys_badlength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets with bad length */
end_comment

begin_decl_stmt
name|u_long
name|sys_processed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets processed */
end_comment

begin_decl_stmt
name|u_long
name|sys_badauth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets dropped because of auth */
end_comment

begin_decl_stmt
name|u_long
name|sys_limitrejected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pkts rejected due to client count per net */
end_comment

begin_decl_stmt
specifier|static
name|double
name|root_distance
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|clock_combine
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|peer_xmit
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fast_xmit
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clock_update
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_get_precision
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MD5
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|make_keylist
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MD5 */
end_comment

begin_comment
comment|/*  * transmit - Transmit Procedure. See Section 3.4.2 of the  *	specification.  */
end_comment

begin_function
name|void
name|transmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|int
name|hpoll
decl_stmt|;
name|hpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
name|u_char
name|oreach
decl_stmt|;
comment|/* 		 * Determine reachability and diddle things if we 		 * haven't heard from the host for a while. If the peer 		 * is not configured and not likely to stay around, 		 * we exhaust it. 		 */
name|oreach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
if|if
condition|(
name|oreach
operator|&
literal|0x01
condition|)
name|peer
operator|->
name|valid
operator|++
expr_stmt|;
if|if
condition|(
name|oreach
operator|&
literal|0x80
condition|)
name|peer
operator|->
name|valid
operator|--
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
name|peer
operator|->
name|valid
operator|>
name|NTP_SHIFT
operator|/
literal|2
operator|&&
operator|(
name|peer
operator|->
name|reach
operator|&
literal|0x80
operator|)
operator|&&
name|peer
operator|->
name|status
operator|<
name|CTL_PST_SEL_SYNCCAND
condition|)
name|peer
operator|->
name|reach
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If this is an uncofigured association and 			 * has become unreachable, demobilize it. 			 */
if|if
condition|(
name|oreach
operator|!=
literal|0
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_UNREACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 			 * We would like to respond quickly when the 			 * peer comes back to life. If the probes since 			 * becoming unreachable are less than 			 * NTP_UNREACH, clamp the poll interval to the 			 * minimum. In order to minimize the network 			 * traffic, the interval gradually ramps up the 			 * the maximum after that. 			 */
name|peer
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|unreach
operator|<
name|NTP_UNREACH
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_CLIENT
condition|)
name|peer
operator|->
name|unreach
operator|++
expr_stmt|;
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
block|}
else|else
block|{
name|hpoll
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_BURST
condition|)
name|peer
operator|->
name|burst
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Here the peer is reachable. If there is no 			 * system peer or if the stratum of the system 			 * peer is greater than this peer, clamp the 			 * poll interval to the minimum. If less than 			 * two samples are in the reachability register, 			 * reduce the interval; if more than six samples 			 * are in the register, increase the interval. 			 */
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sys_peer
operator|==
literal|0
condition|)
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_peer
operator|->
name|stratum
operator|>
name|peer
operator|->
name|stratum
condition|)
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
if|if
condition|(
operator|(
name|peer
operator|->
name|reach
operator|&
literal|0x03
operator|)
operator|==
literal|0
condition|)
block|{
name|clock_filter
argument_list|(
name|peer
argument_list|,
literal|0.
argument_list|,
literal|0.
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|valid
operator|<=
literal|2
condition|)
name|hpoll
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|valid
operator|>=
name|NTP_SHIFT
operator|-
literal|2
condition|)
name|hpoll
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_BURST
condition|)
name|peer
operator|->
name|burst
operator|=
name|NTP_SHIFT
expr_stmt|;
block|}
block|}
else|else
block|{
name|peer
operator|->
name|burst
operator|--
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST2
condition|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_BURST
expr_stmt|;
name|peer
operator|->
name|hmode
operator|=
name|MODE_BCLIENT
expr_stmt|;
block|}
name|clock_select
argument_list|()
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * We need to be very careful about honking uncivilized time. If 	 * not operating in broadcast mode, honk in all except broadcast 	 * client mode. If operating in broadcast mode and synchronized 	 * to a real source, honk except when the peer is the local- 	 * clock driver and the prefer flag is not set. In other words, 	 * in broadcast mode we never honk unless known to be 	 * synchronized to real time. 	 */
if|if
condition|(
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BCLIENT
condition|)
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sys_peer
operator|!=
literal|0
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sys_peer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
operator|&&
operator|!
operator|(
name|sys_peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
operator|)
condition|)
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * receive - Receive Procedure.  See section 3.4.3 in the specification.  */
end_comment

begin_function
name|void
name|receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
name|int
name|hismode
decl_stmt|;
name|int
name|oflags
decl_stmt|;
name|int
name|restrict_mask
decl_stmt|;
name|int
name|has_mac
decl_stmt|;
comment|/* has MAC field */
name|int
name|authlen
decl_stmt|;
comment|/* length of MAC field */
name|int
name|is_authentic
decl_stmt|;
comment|/* cryptosum ok */
name|int
name|is_mystic
decl_stmt|;
comment|/* session key exists */
name|int
name|is_error
decl_stmt|;
comment|/* parse error */
comment|/*	u_long pkeyid; */
name|u_long
name|skeyid
decl_stmt|,
name|tkeyid
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer2
decl_stmt|;
name|int
name|retcode
init|=
name|AM_NOMATCH
decl_stmt|;
comment|/* 	 * Monitor the packet and get restrictions 	 */
name|ntp_monitor
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
name|restrict_mask
operator|=
name|restrictions
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive: from %s restrict %02x\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|restrict_mask
operator|&
name|RES_IGNORE
condition|)
return|return;
comment|/* 	 * Discard packets with invalid version number. 	 */
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|>=
name|NTP_VERSION
condition|)
name|sys_newversionpkt
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|>=
name|NTP_OLDVERSION
condition|)
name|sys_oldversionpkt
operator|++
expr_stmt|;
else|else
block|{
name|sys_unknownversion
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Restrict control/private mode packets. Note that packet 	 * length has to be checked in the control/private mode protocol 	 * module. 	 */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_PRIVATE
condition|)
block|{
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOQUERY
condition|)
return|return;
name|process_private
argument_list|(
name|rbufp
argument_list|,
operator|(
operator|(
name|restrict_mask
operator|&
name|RES_NOMODIFY
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_CONTROL
condition|)
block|{
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOQUERY
condition|)
return|return;
name|process_control
argument_list|(
name|rbufp
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Restrict revenue packets. 	 */
if|if
condition|(
name|restrict_mask
operator|&
name|RES_DONTSERVE
condition|)
return|return;
comment|/* 	 * See if we only accept limited number of clients from the net 	 * this guy is from. Note: the flag is determined dynamically 	 * within restrictions() 	 */
if|if
condition|(
name|restrict_mask
operator|&
name|RES_LIMITED
condition|)
block|{
name|sys_limitrejected
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we are not a broadcast client, ignore broadcast packets. 	 */
if|if
condition|(
operator|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_BROADCAST
operator|&&
operator|!
name|sys_bclient
operator|)
condition|)
return|return;
comment|/* 	 * This is really awful ugly. We figure out whether an extension 	 * field is present and then measure the MAC size. If the number 	 * of words following the packet header is less than or equal to 	 * 5, no extension field is present and these words constitute 	 * the MAC. If the number of words is greater than 5, an 	 * extension field is present and the first word contains the 	 * length of the extension field and the MAC follows that. 	 */
name|has_mac
operator|=
literal|0
expr_stmt|;
comment|/*	pkeyid = 0; */
name|skeyid
operator|=
name|tkeyid
operator|=
literal|0
expr_stmt|;
name|authlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
name|has_mac
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|authlen
expr_stmt|;
if|if
condition|(
name|has_mac
operator|<=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
condition|)
block|{
name|skeyid
operator|=
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|pkt
operator|->
name|keyid1
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|authlen
operator|+=
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|pkt
operator|->
name|keyid1
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
name|has_mac
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|authlen
expr_stmt|;
if|if
condition|(
name|authlen
operator|<=
literal|0
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 		 * Note that keyid3 is actually the key ident of the 		 * MAC itself. 		 */
comment|/* 		pkeyid = (u_long)ntohl(pkt->keyid2)& 0xffffffff; */
name|skeyid
operator|=
name|tkeyid
operator|=
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|pkt
operator|->
name|keyid3
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
block|}
comment|/* 	 * Figure out his mode and validate it. 	 */
name|hismode
operator|=
operator|(
name|int
operator|)
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|NTP_OLDVERSION
operator|&&
name|hismode
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Easy.  If it is from the NTP port it is 		 * a sym act, else client. 		 */
if|if
condition|(
name|SRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
operator|==
name|NTP_PORT
condition|)
name|hismode
operator|=
name|MODE_ACTIVE
expr_stmt|;
else|else
name|hismode
operator|=
name|MODE_CLIENT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hismode
operator|!=
name|MODE_ACTIVE
operator|&&
name|hismode
operator|!=
name|MODE_PASSIVE
operator|&&
name|hismode
operator|!=
name|MODE_SERVER
operator|&&
name|hismode
operator|!=
name|MODE_CLIENT
operator|&&
name|hismode
operator|!=
name|MODE_BROADCAST
condition|)
return|return;
block|}
comment|/* 	 * If he included a mac field, decrypt it to see if it is 	 * authentic. 	 */
name|is_authentic
operator|=
name|is_mystic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|has_mac
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld from %s mode %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|is_mystic
operator|=
name|authistrusted
argument_list|(
name|skeyid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MD5
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
operator|&&
operator|!
name|is_mystic
condition|)
block|{
comment|/* 			 * For multicast mode, generate the session key 			 * and install in the key cache. For client 			 * mode, generate the session key for the 			 * unicast address. For server mode, the session 			 * key should already be in the key cache, since 			 * it was generated when the last request was 			 * sent. 			 */
if|if
condition|(
name|hismode
operator|==
name|MODE_BROADCAST
condition|)
block|{
name|tkeyid
operator|=
name|session_key
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|rbufp
operator|->
name|dstadr
operator|->
name|bcast
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|skeyid
argument_list|,
call|(
name|u_long
call|)
argument_list|(
literal|4
operator|*
operator|(
literal|1
operator|<<
name|pkt
operator|->
name|ppoll
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hismode
operator|!=
name|MODE_SERVER
condition|)
block|{
name|tkeyid
operator|=
name|session_key
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|skeyid
argument_list|,
call|(
name|u_long
call|)
argument_list|(
literal|4
operator|*
operator|(
literal|1
operator|<<
name|pkt
operator|->
name|ppoll
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MD5 */
comment|/* 		 * Compute the cryptosum. Note a clogging attack may 		 * succceed in bloating the key cache. 		 */
if|if
condition|(
name|authdecrypt
argument_list|(
name|skeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|pkt
argument_list|,
name|authlen
argument_list|,
name|has_mac
argument_list|)
condition|)
name|is_authentic
operator|=
literal|1
expr_stmt|;
else|else
name|sys_badauth
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s mode %d keyid %08lx mac %d auth %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|skeyid
argument_list|,
name|has_mac
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Find the peer.  This will return a null if this guy isn't in 	 * the database. 	 */
name|peer
operator|=
name|findpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|rbufp
operator|->
name|fd
argument_list|,
name|hismode
argument_list|,
operator|&
name|retcode
argument_list|)
expr_stmt|;
comment|/* 	 * The new association matching rules are driven by a table 	 * specified in ntp.h. We have replaced the *default* behaviour 	 * of replying to bogus packets in server mode in this version. 	 * A packet must now match an association in order to be 	 * processed. In the event that no association exists, then an 	 * association is mobilized if need be. Two different 	 * associations can be mobilized a) passive associations b) 	 * client associations due to broadcasts or manycasts. 	 */
name|is_error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|retcode
condition|)
block|{
case|case
name|AM_FXMIT
case|:
comment|/* 		 * If the client is configured purely as a broadcast 		 * client and not as an manycast server, it has no 		 * business being a server. Simply go home. Otherwise, 		 * send a MODE_SERVER response and go home. Note that we 		 * don't do a authentication check here, since we can't 		 * set the system clock; but, we do set the key ID to 		 * zero to tell the caller about this. 		 */
if|if
condition|(
operator|!
name|sys_bclient
operator|||
name|sys_manycastserver
condition|)
block|{
if|if
condition|(
name|is_authentic
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
name|skeyid
argument_list|)
expr_stmt|;
else|else
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We can't get here if an association is mobilized, so 		 * just toss the key, if appropriate. 		 */
if|if
condition|(
operator|!
name|is_mystic
operator|&&
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|skeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|AM_MANYCAST
case|:
comment|/* 		 * This could be in response to a multicast packet sent 		 * by the "manycast" mode association. Find peer based 		 * on the originate timestamp in the packet. Note that 		 * we don't mobilize a new association, unless the 		 * packet is properly authenticated. The response must 		 * be properly authenticated and it's darn funny of the 		 * manycaster isn't around now.  		 */
if|if
condition|(
operator|(
name|sys_authenticate
operator|&&
operator|!
name|is_authentic
operator|)
condition|)
block|{
name|is_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peer2
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|findmanycastpeer
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer2
operator|==
literal|0
condition|)
block|{
name|is_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * Create a new association and copy the peer variables 		 * to it. If something goes wrong, carefully pry the new 		 * association away and return its marbles to the candy 		 * store. 		*/
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_CLIENT
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
name|is_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peer_config_manycast
argument_list|(
name|peer2
argument_list|,
name|peer
argument_list|)
expr_stmt|;
break|break;
case|case
name|AM_ERR
case|:
comment|/* 		 * Something bad happened. Dirty floor will be mopped by 		 * the code at the end of this adventure. 		 */
name|is_error
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AM_NEWPASS
case|:
comment|/* 		 * Okay, we're going to keep him around.  Allocate him 		 * some memory. But, don't do that unless the packet is 		 * properly authenticated. 		 */
if|if
condition|(
operator|(
name|sys_authenticate
operator|&&
operator|!
name|is_authentic
operator|)
condition|)
block|{
name|is_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_PASSIVE
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
expr_stmt|;
break|break;
case|case
name|AM_NEWBCL
case|:
comment|/* 		 * Broadcast client being set up now. Do this only if 		 * the packet is properly authenticated. 		 */
if|if
condition|(
operator|(
name|restrict_mask
operator|&
name|RES_NOPEER
operator|)
operator|||
operator|!
name|sys_bclient
operator|||
operator|(
name|sys_authenticate
operator|&&
operator|!
name|is_authentic
operator|)
condition|)
block|{
name|is_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_MCLIENT
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
break|break;
name|peer
operator|->
name|flags
operator||=
name|FLAG_MCAST1
operator||
name|FLAG_MCAST2
operator||
name|FLAG_BURST
expr_stmt|;
name|peer
operator|->
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
break|break;
case|case
name|AM_POSSBCL
case|:
case|case
name|AM_PROCPKT
case|:
comment|/* 		 * It seems like it is okay to process the packet now 		 */
break|break;
default|default:
comment|/* 		 * shouldn't be getting here, but simply return anyway! 		 */
name|is_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_error
condition|)
block|{
comment|/* 		 * Error stub. If we get here, something broke. We 		 * scuttle the autokey if necessary and sink the ship. 		 * This can occur only upon mobilization, so we can 		 * throw the structure away without fear of breaking 		 * anything. 		 */
if|if
condition|(
operator|!
name|is_mystic
operator|&&
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|skeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"match error code %d assoc %d\n"
argument_list|,
name|retcode
argument_list|,
name|peer_associations
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * If the peer isn't configured, set his keyid and authenable 	 * status based on the packet. 	 */
name|oflags
operator|=
name|peer
operator|->
name|flags
expr_stmt|;
name|peer
operator|->
name|timereceived
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
name|has_mac
condition|)
block|{
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENABLE
expr_stmt|;
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST2
condition|)
name|peer
operator|->
name|keyid
operator|=
name|skeyid
expr_stmt|;
else|else
name|peer
operator|->
name|flags
operator||=
name|FLAG_SKEY
expr_stmt|;
block|}
block|}
comment|/* 	 * Determine if this guy is basically trustable. If not, flush 	 * the bugger. If this is the first packet that is 	 * authenticated, flush the clock filter. This is to foil 	 * clogging attacks that might starve the poor dear. 	 */
name|peer
operator|->
name|flash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_authentic
condition|)
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENTIC
expr_stmt|;
else|else
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_AUTHENTIC
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
operator|&&
operator|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
operator|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST10
expr_stmt|;
comment|/* access denied */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENTIC
operator|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST5
expr_stmt|;
comment|/* auth failed */
elseif|else
if|if
condition|(
name|skeyid
operator|==
literal|0
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST9
expr_stmt|;
comment|/* peer not auth */
elseif|else
if|if
condition|(
operator|!
operator|(
name|oflags
operator|&
name|FLAG_AUTHENABLE
operator|)
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_PEERAUTH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|peer
operator|->
name|flash
operator|&
operator|~
operator|(
name|u_int
operator|)
name|TEST9
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The packet is bogus, so we throw it away before 		 * becoming a denial-of-service hazard. We don't throw 		 * the current association away if it is configured or 		 * if it has prior reachable friends. 		 */
if|if
condition|(
operator|!
name|is_mystic
operator|&&
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|skeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"invalid packet 0x%02x code %d assoc %d\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|,
name|retcode
argument_list|,
name|peer_associations
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|MD5
comment|/* 	 * The autokey dance. The cha-cha requires that the hash of the 	 * current session key matches the previous key identifier. 	 * Heaps of trouble if the steps falter. 	 */
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * In the case of a new autokey, verify the hash matches 		 * one of the previous four hashes. If not, raise the 		 * authentication flasher and hope the next one works. 		 */
if|if
condition|(
name|hismode
operator|==
name|MODE_SERVER
condition|)
block|{
name|peer
operator|->
name|pkeyid
operator|=
name|peer
operator|->
name|keyid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST2
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|pkeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|peer
operator|->
name|pkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|tkeyid
operator|!=
name|peer
operator|->
name|pkeyid
condition|;
name|i
operator|++
control|)
block|{
name|tkeyid
operator|=
name|session_key
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|rbufp
operator|->
name|dstadr
operator|->
name|bcast
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|tkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|pkeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|peer
operator|->
name|pkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|tkeyid
operator|!=
name|peer
operator|->
name|pkeyid
condition|;
name|i
operator|++
control|)
block|{
name|tkeyid
operator|=
name|session_key
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|tkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|XXX
comment|/* temp until certificate code is mplemented */
if|if
condition|(
name|tkeyid
operator|!=
name|peer
operator|->
name|pkeyid
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST9
expr_stmt|;
comment|/* peer not authentic */
endif|#
directive|endif
name|peer
operator|->
name|pkeyid
operator|=
name|skeyid
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MD5 */
comment|/* 	 * Gawdz, it's come to this. Process the dang packet. If 	 * something breaks and the association doesn't deserve to live, 	 * toss it. Be careful in active mode and return a packet 	 * anyway. 	 */
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
operator|&
operator|(
name|rbufp
operator|->
name|recv_time
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_PASSIVE
condition|)
block|{
if|if
condition|(
name|is_authentic
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_PASSIVE
argument_list|,
name|skeyid
argument_list|)
expr_stmt|;
else|else
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_PASSIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process_packet - Packet Procedure, a la Section 3.4.4 of the  *	specification. Or almost, at least. If we're in here we have a  *	reasonable expectation that we will be having a long term  *	relationship with this host.  */
end_comment

begin_function
name|int
name|process_packet
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|l_fp
modifier|*
name|recv_ts
parameter_list|)
block|{
name|l_fp
name|t10
decl_stmt|,
name|t23
decl_stmt|;
name|double
name|p_offset
decl_stmt|,
name|p_del
decl_stmt|,
name|p_disp
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
name|l_fp
name|p_rec
decl_stmt|,
name|p_xmt
decl_stmt|,
name|p_org
decl_stmt|,
name|p_reftime
decl_stmt|;
name|l_fp
name|ci
decl_stmt|;
name|int
name|pmode
decl_stmt|;
comment|/* 	 * Swap header fields and keep the books. 	 */
name|sys_processed
operator|++
expr_stmt|;
name|peer
operator|->
name|processed
operator|++
expr_stmt|;
name|p_del
operator|=
name|FPTOD
argument_list|(
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|p_disp
operator|=
name|FPTOD
argument_list|(
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|reftime
argument_list|,
operator|&
name|p_reftime
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|,
operator|&
name|p_rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_BROADCAST
condition|)
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
else|else
name|p_org
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
name|peer
operator|->
name|rec
operator|=
operator|*
name|recv_ts
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|pkt
operator|->
name|ppoll
expr_stmt|;
name|pmode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
comment|/* 	 * Test for old or duplicate packets (tests 1 through 3). 	 */
if|if
condition|(
name|L_ISHIS
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* count old packets */
name|peer
operator|->
name|oldpkt
operator|++
expr_stmt|;
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* test 1 */
name|peer
operator|->
name|flash
operator||=
name|TEST1
expr_stmt|;
comment|/* duplicate packet */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|p_org
argument_list|)
condition|)
block|{
comment|/* test 2 */
name|peer
operator|->
name|bogusorg
operator|++
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST2
expr_stmt|;
comment|/* bogus packet */
block|}
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_rec
argument_list|)
operator|||
name|L_ISZERO
argument_list|(
operator|&
name|p_org
argument_list|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynchronized */
block|}
else|else
block|{
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_org
argument_list|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynchronized */
block|}
name|peer
operator|->
name|org
operator|=
name|p_xmt
expr_stmt|;
comment|/* 	 * Test for valid header (tests 5 through 10) 	 */
name|ci
operator|=
name|p_xmt
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|p_reftime
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|LEAP_NOTINSYNC
operator|||
comment|/* test 6 */
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
operator|>=
name|NTP_MAXSTRATUM
operator|||
name|dtemp
operator|<
literal|0
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST6
expr_stmt|;
comment|/* peer clock unsynchronized */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
name|sys_peer
operator|!=
literal|0
condition|)
block|{
comment|/* test 7 */
if|if
condition|(
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
operator|>
name|sys_stratum
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST7
expr_stmt|;
comment|/* peer stratum too high */
name|sys_badstratum
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fabs
argument_list|(
name|p_del
argument_list|)
operator|>=
name|MAXDISPERSE
comment|/* test 8 */
operator|||
name|p_disp
operator|>=
name|MAXDISPERSE
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST8
expr_stmt|;
comment|/* delay/dispersion too high */
comment|/* 	 * If the packet header is invalid (tests 5 through 10), exit. 	 * XXX we let TEST9 sneak by until the certificate code is 	 * implemented, but only to mobilize the association. 	 */
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
operator|(
name|TEST5
operator||
name|TEST6
operator||
name|TEST7
operator||
name|TEST8
operator||
name|TEST10
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"invalid packet header 0x%02x mode %d\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|,
name|pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Valid header; update our state. 	 */
name|record_raw_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|p_org
argument_list|,
operator|&
name|p_rec
argument_list|,
operator|&
name|p_xmt
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
name|peer
operator|->
name|leap
operator|=
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pmode
operator|=
name|pmode
expr_stmt|;
comment|/* unspec */
name|peer
operator|->
name|stratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|pkt
operator|->
name|precision
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
name|p_del
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
name|p_disp
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pkt
operator|->
name|refid
expr_stmt|;
name|peer
operator|->
name|reftime
operator|=
name|p_reftime
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_REACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
block|}
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
comment|/* 	 * If running in a client/server association, calculate the 	 * clock offset c, roundtrip delay d and dispersion e. We use 	 * the equations (reordered from those in the spec). Note that, 	 * in a broadcast association, org has been set to the time of 	 * last reception. Note the computation of dispersion includes 	 * the system precision plus that due to the frequency error 	 * since the originate time. 	 * 	 * c = ((t2 - t3) + (t1 - t0)) / 2 	 * d = (t2 - t3) - (t1 - t0) 	 * e = (org - rec) (seconds only) 	 */
name|t10
operator|=
name|p_xmt
expr_stmt|;
comment|/* compute t1 - t0 */
name|L_SUB
argument_list|(
operator|&
name|t10
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
name|t23
operator|=
name|p_rec
expr_stmt|;
comment|/* compute t2 - t3 */
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|ci
operator|=
name|t10
expr_stmt|;
name|p_disp
operator|=
name|CLOCK_PHI
operator|*
operator|(
name|peer
operator|->
name|rec
operator|.
name|l_ui
operator|-
name|p_org
operator|.
name|l_ui
operator|)
expr_stmt|;
comment|/* 	 * If running in a broadcast association, the clock offset is 	 * (t1 - t0) corrected by the one-way delay, but we can't 	 * measure that directly; therefore, we start up in 	 * client/server mode, calculate the clock offset, using the 	 * engineered refinement algorithms, while also receiving 	 * broadcasts. When a broadcast is received in client/server 	 * mode, we calculate a correction factor to use after switching 	 * back to broadcast mode. We know NTP_SKEWFACTOR == 16, which 	 * accounts for the simplified ei calculation. 	 * 	 * If FLAG_MCAST2 is set, we are a broadcast/multicast client. 	 * If FLAG_MCAST1 is set, we haven't calculated the propagation 	 * delay. If hmode is MODE_CLIENT, we haven't set the local 	 * clock in client/server mode. Initially, we come up 	 * MODE_CLIENT. When the clock is first updated and FLAG_MCAST2 	 * is set, we switch from MODE_CLIENT to MODE_BCLIENT. 	 */
if|if
condition|(
name|pmode
operator|==
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST1
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BCLIENT
condition|)
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_MCAST1
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|p_offset
argument_list|)
expr_stmt|;
name|peer
operator|->
name|estbdelay
operator|=
name|peer
operator|->
name|offset
operator|-
name|p_offset
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|DTOLFP
argument_list|(
name|peer
operator|->
name|estbdelay
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|p_del
operator|=
name|peer
operator|->
name|delay
expr_stmt|;
block|}
else|else
block|{
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|t23
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|t23
argument_list|,
name|p_del
argument_list|)
expr_stmt|;
block|}
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|p_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|p_del
argument_list|)
operator|>=
name|MAXDISPERSE
operator|||
name|p_disp
operator|>=
name|MAXDISPERSE
condition|)
comment|/* test 4 */
name|peer
operator|->
name|flash
operator||=
name|TEST4
expr_stmt|;
comment|/* delay/dispersion too big */
comment|/* 	 * If the packet data are invalid (tests 1 through 4), exit. 	 */
if|if
condition|(
name|peer
operator|->
name|flash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"invalid packet data 0x%02x mode %d\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|,
name|pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * This one is valid. Mark it so, give it to clock_filter(). 	 */
name|clock_filter
argument_list|(
name|peer
argument_list|,
name|p_offset
argument_list|,
name|p_del
argument_list|,
name|fabs
argument_list|(
name|p_disp
argument_list|)
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
name|record_peer_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|disp
argument_list|,
name|SQRT
argument_list|(
name|peer
operator|->
name|variance
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * clock_update - Called at system process update intervals.  */
end_comment

begin_function
specifier|static
name|void
name|clock_update
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|oleap
decl_stmt|;
name|u_char
name|ostratum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* 	 * Reset/adjust the system clock. Do this only if there is a 	 * system peer and we haven't seen that peer lately. Watch for 	 * timewarps here. 	 */
if|if
condition|(
name|sys_peer
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sys_peer
operator|->
name|pollsw
operator|==
name|FALSE
operator|||
name|sys_peer
operator|->
name|burst
operator|>
literal|0
condition|)
return|return;
name|sys_peer
operator|->
name|pollsw
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_update: at %ld assoc %d \n"
argument_list|,
name|current_time
argument_list|,
name|peer_associations
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oleap
operator|=
name|sys_leap
expr_stmt|;
name|ostratum
operator|=
name|sys_stratum
expr_stmt|;
switch|switch
condition|(
name|local_clock
argument_list|(
name|sys_peer
argument_list|,
name|sys_offset
argument_list|,
name|sys_epsil
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* 		 * Clock is too screwed up. Just exit for now. 		 */
name|report_event
argument_list|(
name|EVNT_SYSFAULT
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|1
case|:
comment|/* 		 * Clock was stepped. Clear filter registers 		 * of all peers. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|i
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|NLOG
argument_list|(
argument|NLOG_SYNCSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"synchronisation lost"
argument_list|)
expr_stmt|;
name|sys_peer
operator|=
literal|0
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_CLOCKRESET
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Update the system stratum, leap bits, root delay, 		 * root dispersion, reference ID and reference time. We 		 * also update select dispersion and max frequency 		 * error. 		 */
name|sys_stratum
operator|=
name|sys_peer
operator|->
name|stratum
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sys_stratum
operator|==
literal|1
condition|)
name|sys_refid
operator|=
name|sys_peer
operator|->
name|refid
expr_stmt|;
else|else
name|sys_refid
operator|=
name|sys_peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|sys_reftime
operator|=
name|sys_peer
operator|->
name|rec
expr_stmt|;
name|sys_rootdelay
operator|=
name|sys_peer
operator|->
name|rootdelay
operator|+
name|fabs
argument_list|(
name|sys_peer
operator|->
name|delay
argument_list|)
expr_stmt|;
name|sys_leap
operator|=
name|leap_consensus
expr_stmt|;
block|}
if|if
condition|(
name|oleap
operator|!=
name|sys_leap
condition|)
name|report_event
argument_list|(
name|EVNT_SYNCCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostratum
operator|!=
name|sys_stratum
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * poll_update - update peer poll interval. See Section 3.4.9 of the  *	   spec.  */
end_comment

begin_function
name|void
name|poll_update
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|hpoll
parameter_list|)
block|{
name|long
name|update
decl_stmt|;
comment|/* 	 * The wiggle-the-poll-interval dance. Broadcasters dance only 	 * the minpoll beat. Reference clock partners sit this one out. 	 * Dancers surviving the clustering algorithm beat to the system 	 * clock. Broadcast clients are usually lead by their broadcast 	 * partner, but faster in the initial mating dance. 	 */
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
condition|)
block|{
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SYSPEER
condition|)
block|{
name|peer
operator|->
name|hpoll
operator|=
name|sys_poll
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hpoll
operator|>
name|peer
operator|->
name|maxpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
elseif|else
if|if
condition|(
name|hpoll
operator|<
name|peer
operator|->
name|minpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
else|else
name|peer
operator|->
name|hpoll
operator|=
name|hpoll
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|!=
name|current_time
condition|)
return|return;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|peer
operator|->
name|nextdate
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|reach
operator|&
literal|0x1
condition|)
name|peer
operator|->
name|nextdate
operator|+=
name|RANDPOLL
argument_list|(
name|BURST_INTERVAL2
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|nextdate
operator|+=
name|RANDPOLL
argument_list|(
name|BURST_INTERVAL1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|update
operator|=
name|max
argument_list|(
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
name|peer
operator|->
name|nextdate
operator|=
name|peer
operator|->
name|outdate
operator|+
name|RANDPOLL
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"poll_update: at %lu %s poll %d burst %d last %lu next %lu\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|hpoll
argument_list|,
name|peer
operator|->
name|burst
argument_list|,
name|peer
operator|->
name|outdate
argument_list|,
name|peer
operator|->
name|nextdate
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * clear - clear peer filter registers.  See Section 3.4.8 of the spec.  */
end_comment

begin_function
name|void
name|peer_clear
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|CLEAR_TO_ZERO
argument_list|(
name|peer
argument_list|)
argument_list|,
literal|0
argument_list|,
name|LEN_CLEAR_TO_ZERO
argument_list|)
expr_stmt|;
name|peer
operator|->
name|estbdelay
operator|=
name|sys_bdelay
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|pollsw
operator|=
name|FALSE
expr_stmt|;
name|peer
operator|->
name|variance
operator|=
name|MAXDISPERSE
expr_stmt|;
name|peer
operator|->
name|epoch
operator|=
name|current_time
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|peer
operator|->
name|filter_disp
index|[
name|i
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
name|peer
operator|->
name|filter_epoch
index|[
name|i
index|]
operator|=
name|current_time
expr_stmt|;
block|}
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
comment|/* 	 * Since we have a chance to correct possible funniness in 	 * our selection of interfaces on a multihomed host, do so 	 * by setting us to no particular interface. 	 * WARNING: do so only in non-broadcast mode! 	 */
if|if
condition|(
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BROADCAST
condition|)
name|peer
operator|->
name|dstadr
operator|=
name|any_interface
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_filter - add incoming clock sample to filter register and run  *		  the filter procedure to find the best sample.  */
end_comment

begin_function
name|void
name|clock_filter
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|double
name|sample_offset
parameter_list|,
name|double
name|sample_delay
parameter_list|,
name|double
name|sample_disp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|ord
decl_stmt|;
name|double
name|distance
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
name|off
decl_stmt|;
comment|/* 	 * Update error bounds and calculate distances. Also initialize 	 * sort index vector. 	 */
name|x
operator|=
name|CLOCK_PHI
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
expr_stmt|;
name|peer
operator|->
name|update
operator|=
name|current_time
expr_stmt|;
name|ord
operator|=
name|peer
operator|->
name|filter_order
expr_stmt|;
name|j
operator|=
name|peer
operator|->
name|filter_nextpt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|+=
name|x
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|>
name|MAXDISPERSE
condition|)
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
name|distance
index|[
name|i
index|]
operator|=
name|fabs
argument_list|(
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
argument_list|)
operator|/
literal|2
operator|+
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
if|if
condition|(
operator|--
name|j
operator|<
literal|0
condition|)
name|j
operator|+=
name|NTP_SHIFT
expr_stmt|;
block|}
comment|/* 	 * Insert the new sample at the beginning of the register. 	 */
name|peer
operator|->
name|filter_offset
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|sample_offset
expr_stmt|;
name|peer
operator|->
name|filter_delay
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|sample_delay
expr_stmt|;
name|x
operator|=
name|LOGTOD
argument_list|(
name|peer
operator|->
name|precision
argument_list|)
operator|+
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
operator|+
name|sample_disp
expr_stmt|;
name|peer
operator|->
name|filter_disp
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|min
argument_list|(
name|x
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
name|peer
operator|->
name|filter_epoch
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|current_time
expr_stmt|;
name|distance
index|[
literal|0
index|]
operator|=
name|min
argument_list|(
name|x
operator|+
name|fabs
argument_list|(
name|sample_delay
argument_list|)
operator|/
literal|2
argument_list|,
name|MAXDISTANCE
argument_list|)
expr_stmt|;
name|peer
operator|->
name|filter_nextpt
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_nextpt
operator|>=
name|NTP_SHIFT
condition|)
name|peer
operator|->
name|filter_nextpt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Sort the samples in the register by distance. The winning 	 * sample will be in ord[0]. Sort the samples only if they 	 * are younger than the Allen intercept. 	 */
name|y
operator|=
name|min
argument_list|(
name|allan_xpt
argument_list|,
name|NTP_SHIFT
operator|*
name|ULOGTOD
argument_list|(
name|sys_poll
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NTP_SHIFT
operator|&&
name|current_time
operator|-
name|peer
operator|->
name|filter_epoch
index|[
name|ord
index|[
name|n
index|]
index|]
operator|<=
name|y
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|distance
index|[
name|j
index|]
operator|>
name|distance
index|[
name|n
index|]
condition|)
block|{
name|x
operator|=
name|distance
index|[
name|j
index|]
expr_stmt|;
name|k
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|distance
index|[
name|j
index|]
operator|=
name|distance
index|[
name|n
index|]
expr_stmt|;
name|ord
index|[
name|j
index|]
operator|=
name|ord
index|[
name|n
index|]
expr_stmt|;
name|distance
index|[
name|n
index|]
operator|=
name|x
expr_stmt|;
name|ord
index|[
name|n
index|]
operator|=
name|k
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Compute the error bound and standard error. 	 */
name|x
operator|=
name|y
operator|=
name|z
operator|=
name|off
operator|=
literal|0.
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|x
operator|=
name|NTP_FWEIGHT
operator|*
operator|(
name|x
operator|+
name|peer
operator|->
name|filter_disp
index|[
name|ord
index|[
name|i
index|]
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|z
operator|+=
literal|1.
operator|/
name|distance
index|[
name|i
index|]
expr_stmt|;
name|off
operator|+=
name|peer
operator|->
name|filter_offset
index|[
name|ord
index|[
name|i
index|]
index|]
operator|/
name|distance
index|[
name|i
index|]
expr_stmt|;
name|y
operator|+=
name|DIFF
argument_list|(
name|peer
operator|->
name|filter_offset
index|[
name|ord
index|[
name|i
index|]
index|]
argument_list|,
name|peer
operator|->
name|filter_offset
index|[
name|ord
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|peer
operator|->
name|delay
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|peer
operator|->
name|variance
operator|=
name|min
argument_list|(
name|y
operator|/
name|n
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
name|peer
operator|->
name|disp
operator|=
name|min
argument_list|(
name|x
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
name|peer
operator|->
name|epoch
operator|=
name|current_time
expr_stmt|;
name|x
operator|=
name|peer
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_BURST
condition|)
name|peer
operator|->
name|offset
operator|=
name|off
operator|/
name|z
expr_stmt|;
else|else
name|peer
operator|->
name|offset
operator|=
name|peer
operator|->
name|filter_offset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
comment|/* 	 * A new sample is useful only if it is younger than the last 	 * one used. 	 */
if|if
condition|(
name|peer
operator|->
name|filter_epoch
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|>
name|peer
operator|->
name|epoch
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: discard %lu\n"
argument_list|,
name|peer
operator|->
name|filter_epoch
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|-
name|peer
operator|->
name|epoch
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * If the offset exceeds the dispersion by CLOCK_SGATE and the 	 * interval since the last update is less than twice the system 	 * poll interval, consider the update a popcorn spike and ignore 	 * it. 	 */
if|if
condition|(
name|fabs
argument_list|(
name|x
operator|-
name|peer
operator|->
name|offset
argument_list|)
operator|>
name|CLOCK_SGATE
operator|&&
name|peer
operator|->
name|filter_epoch
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|-
name|peer
operator|->
name|epoch
operator|<
operator|(
literal|1
operator|<<
operator|(
name|sys_poll
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: popcorn spike %.6f\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|peer
operator|->
name|epoch
operator|=
name|peer
operator|->
name|filter_epoch
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|peer
operator|->
name|pollsw
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: offset %.6f delay %.6f disp %.6f std %.6f, age %lu\n"
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|disp
argument_list|,
name|SQRT
argument_list|(
name|peer
operator|->
name|variance
argument_list|)
argument_list|,
name|current_time
operator|-
name|peer
operator|->
name|epoch
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * clock_select - find the pick-of-the-litter clock  */
end_comment

begin_function
name|void
name|clock_select
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nlist
decl_stmt|,
name|nl3
decl_stmt|;
name|double
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|allow
decl_stmt|,
name|found
decl_stmt|,
name|k
decl_stmt|;
name|double
name|high
decl_stmt|,
name|low
decl_stmt|;
name|double
name|synch
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|,
name|error
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|struct
name|peer
modifier|*
name|osys_peer
decl_stmt|;
name|struct
name|peer
modifier|*
name|typeacts
init|=
literal|0
decl_stmt|;
name|struct
name|peer
modifier|*
name|typelocal
init|=
literal|0
decl_stmt|;
name|struct
name|peer
modifier|*
name|typepps
init|=
literal|0
decl_stmt|;
name|struct
name|peer
modifier|*
name|typeprefer
init|=
literal|0
decl_stmt|;
name|struct
name|peer
modifier|*
name|typesystem
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|list_alloc
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|endpoint
modifier|*
name|endpoint
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
modifier|*
name|index
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|peer
modifier|*
modifier|*
name|peer_list
init|=
name|NULL
decl_stmt|;
specifier|static
name|u_int
name|endpoint_size
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|index_size
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|peer_list_size
init|=
literal|0
decl_stmt|;
comment|/* 	 * Initialize. If a prefer peer does not survive this thing, 	 * the pps_update switch will remain zero. 	 */
name|pps_update
operator|=
literal|0
expr_stmt|;
name|nlist
operator|=
literal|0
expr_stmt|;
name|low
operator|=
literal|1e9
expr_stmt|;
name|high
operator|=
operator|-
literal|1e9
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_SIZE
condition|;
name|n
operator|++
control|)
name|nlist
operator|+=
name|peer_hash_count
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
name|list_alloc
condition|)
block|{
if|if
condition|(
name|list_alloc
operator|>
literal|0
condition|)
block|{
name|free
argument_list|(
name|endpoint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer_list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|list_alloc
operator|<
name|nlist
condition|)
block|{
name|list_alloc
operator|+=
literal|5
expr_stmt|;
name|endpoint_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
expr|*
name|endpoint
expr_stmt|;
name|index_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
expr|*
name|index
expr_stmt|;
name|peer_list_size
operator|+=
literal|5
operator|*
sizeof|sizeof
expr|*
name|peer_list
expr_stmt|;
block|}
name|endpoint
operator|=
operator|(
expr|struct
name|endpoint
operator|*
operator|)
name|emalloc
argument_list|(
name|endpoint_size
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|int
operator|*
operator|)
name|emalloc
argument_list|(
name|index_size
argument_list|)
expr_stmt|;
name|peer_list
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
name|peer_list_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This first chunk of code is supposed to go through all 	 * peers we know about to find the peers which are most likely 	 * to succeed. We run through the list doing the sanity checks 	 * and trying to insert anyone who looks okay. 	 */
name|nlist
operator|=
name|nl3
operator|=
literal|0
expr_stmt|;
comment|/* none yet */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_SIZE
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|n
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_SYSPEER
expr_stmt|;
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_REJECT
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_NOSELECT
condition|)
continue|continue;
comment|/* noselect (survey) */
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
continue|continue;
comment|/* unreachable */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>
literal|1
operator|&&
name|peer
operator|->
name|refid
operator|==
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
continue|continue;
comment|/* sync loop */
if|if
condition|(
name|root_distance
argument_list|(
name|peer
argument_list|)
operator|>=
name|MAXDISTANCE
operator|+
literal|2
operator|*
name|CLOCK_PHI
operator|*
name|ULOGTOD
argument_list|(
name|sys_poll
argument_list|)
condition|)
block|{
name|peer
operator|->
name|seldisptoolarge
operator|++
expr_stmt|;
continue|continue;
comment|/* noisy or broken */
block|}
comment|/* 			 * Don't allow the local-clock or acts drivers 			 * in the kitchen at this point, unless the 			 * prefer peer. Do that later, but only if 			 * nobody else is around. 			 */
if|if
condition|(
name|peer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|VMS_LOCALUNIT
argument_list|)
comment|/* wjm: local unit VMS_LOCALUNIT taken seriously */
operator|&&
name|REFCLOCKUNIT
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|!=
name|VMS_LOCALUNIT
endif|#
directive|endif
comment|/* VMS&& VMS_LOCALUNIT */
condition|)
block|{
name|typelocal
operator|=
name|peer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
continue|continue;
comment|/* no local clock */
block|}
if|if
condition|(
name|peer
operator|->
name|sstclktype
operator|==
name|CTL_SST_TS_TELEPHONE
condition|)
block|{
name|typeacts
operator|=
name|peer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
continue|continue;
comment|/* no acts */
block|}
comment|/* 			 * If we get this far, we assume the peer is 			 * acceptable. 			 */
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|peer_list
index|[
name|nlist
operator|++
index|]
operator|=
name|peer
expr_stmt|;
comment|/* 			 * Insert each interval endpoint on the sorted 			 * list. 			 */
name|e
operator|=
name|peer
operator|->
name|offset
expr_stmt|;
comment|/* Upper end */
name|f
operator|=
name|root_distance
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|+
name|f
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nl3
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|index
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|index
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|-
name|f
expr_stmt|;
comment|/* Center point */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|index
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|index
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|-
name|f
expr_stmt|;
comment|/* Lower end */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|index
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|index
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl3
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: endpoint %2d %.6f\n"
argument_list|,
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|type
argument_list|,
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|nl3
operator|-
literal|1
expr_stmt|;
name|allow
operator|=
name|nlist
expr_stmt|;
comment|/* falsetickers assumed */
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|allow
operator|>
literal|0
condition|)
block|{
name|allow
operator|--
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|+=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|j
operator|--
control|)
block|{
name|n
operator|+=
name|endpoint
index|[
name|index
index|[
name|j
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|index
index|[
name|j
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|>
name|allow
condition|)
break|break;
name|low
operator|=
name|endpoint
index|[
name|index
index|[
name|i
operator|++
index|]
index|]
operator|.
name|val
expr_stmt|;
name|high
operator|=
name|endpoint
index|[
name|index
index|[
name|j
operator|--
index|]
index|]
operator|.
name|val
expr_stmt|;
block|}
comment|/* 	 * If no survivors remain at this point, check if the acts or 	 * local clock drivers have been found. If so, nominate one of 	 * them as the only survivor. Otherwise, give up and declare us 	 * unsynchronized. 	 */
if|if
condition|(
operator|(
name|allow
operator|<<
literal|1
operator|)
operator|>=
name|nlist
condition|)
block|{
if|if
condition|(
name|typeacts
operator|!=
literal|0
condition|)
block|{
name|typeacts
operator|->
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|peer_list
index|[
literal|0
index|]
operator|=
name|typeacts
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typelocal
operator|!=
literal|0
condition|)
block|{
name|typelocal
operator|->
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|peer_list
index|[
literal|0
index|]
operator|=
name|typelocal
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sys_peer
operator|!=
literal|0
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYNCSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"synchronisation lost"
argument_list|)
expr_stmt|;
block|}
name|sys_peer
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: low %.6f high %.6f\n"
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Clustering algorithm. Process intersection list to discard 	 * outlyers. Construct candidate list in cluster order 	 * determined by the sum of peer synchronization distance plus 	 * scaled stratum. We must find at least one peer. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
literal|1
operator|&&
operator|(
name|low
operator|>=
name|peer
operator|->
name|offset
operator|||
name|peer
operator|->
name|offset
operator|>=
name|high
operator|)
condition|)
continue|continue;
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_CORRECT
expr_stmt|;
name|d
operator|=
name|root_distance
argument_list|(
name|peer
argument_list|)
operator|+
name|peer
operator|->
name|stratum
operator|*
name|MAXDISPERSE
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|NTP_MAXCLOCK
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|j
operator|-
literal|1
index|]
condition|)
continue|continue;
else|else
name|j
operator|--
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|k
operator|-
literal|1
index|]
condition|)
break|break;
name|synch
index|[
name|k
index|]
operator|=
name|synch
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|peer_list
index|[
name|k
index|]
operator|=
name|peer_list
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|peer_list
index|[
name|k
index|]
operator|=
name|peer
expr_stmt|;
name|synch
index|[
name|k
index|]
operator|=
name|d
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|nlist
operator|=
name|j
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: %s distance %.6f\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|synch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now, prune outlyers by root dispersion. Continue as long as 	 * there are more than NTP_MINCLOCK survivors and the minimum 	 * select dispersion is greater than the maximum peer 	 * dispersion. Stop if we are about to discard a prefer peer. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
name|error
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|variance
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|NTP_CANCLOCK
condition|)
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SELCAND
expr_stmt|;
else|else
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_DISTSYSPEER
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|sys_maxd
operator|=
literal|0
expr_stmt|;
name|d
operator|=
name|error
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
operator|=
name|nlist
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|double
name|sdisp
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
name|nlist
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|sdisp
operator|=
name|NTP_SWEIGHT
operator|*
operator|(
name|sdisp
operator|+
name|DIFF
argument_list|(
name|peer_list
index|[
name|i
index|]
operator|->
name|offset
argument_list|,
name|peer_list
index|[
name|j
index|]
operator|->
name|offset
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sdisp
operator|>
name|sys_maxd
condition|)
block|{
name|sys_maxd
operator|=
name|sdisp
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|error
index|[
name|i
index|]
operator|<
name|d
condition|)
name|d
operator|=
name|error
index|[
name|i
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: survivors %d select %.6f peer %.6f\n"
argument_list|,
name|nlist
argument_list|,
name|SQRT
argument_list|(
name|sys_maxd
argument_list|)
argument_list|,
name|SQRT
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nlist
operator|<=
name|NTP_MINCLOCK
operator|||
name|sys_maxd
operator|<=
name|d
operator|||
name|peer_list
index|[
name|k
index|]
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|k
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
name|peer_list
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|peer_list
index|[
name|j
index|]
expr_stmt|;
name|error
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|error
index|[
name|j
index|]
expr_stmt|;
block|}
name|nlist
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: %s offset %.6f, distance %.6f poll %d\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer_list
index|[
name|i
index|]
operator|->
name|offset
argument_list|,
name|synch
index|[
name|i
index|]
argument_list|,
name|peer_list
index|[
name|i
index|]
operator|->
name|pollsw
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * What remains is a list of not greater than NTP_MINCLOCK 	 * peers. We want only a peer at the lowest stratum to become 	 * the system peer, although all survivors are eligible for the 	 * combining algorithm. First record their order, diddle the 	 * flags and clamp the poll intervals. Then, consider the peers 	 * at the lowest stratum. Of these, OR the leap bits on the 	 * assumption that, if some of them honk nonzero bits, they must 	 * know what they are doing. Also, check for prefer and pps 	 * peers. If a prefer peer is found within clock_max, update the 	 * pps switch. Of the other peers not at the lowest stratum, 	 * check if the system peer is among them and, if found, zap 	 * him. We note that the head of the list is at the lowest 	 * stratum and that unsynchronized peers cannot survive this 	 * far. 	 */
name|leap_consensus
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nlist
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|peer_list
index|[
name|i
index|]
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYNCCAND
expr_stmt|;
name|peer_list
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|FLAG_SYSPEER
expr_stmt|;
name|poll_update
argument_list|(
name|peer_list
index|[
name|i
index|]
argument_list|,
name|peer_list
index|[
name|i
index|]
operator|->
name|hpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|->
name|stratum
operator|==
name|peer_list
index|[
literal|0
index|]
operator|->
name|stratum
condition|)
block|{
name|leap_consensus
operator||=
name|peer_list
index|[
name|i
index|]
operator|->
name|leap
expr_stmt|;
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|->
name|refclktype
operator|==
name|REFCLK_ATOM_PPS
condition|)
name|typepps
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|==
name|sys_peer
condition|)
name|typesystem
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
block|{
name|typeprefer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|typeprefer
operator|->
name|offset
argument_list|)
operator|<
name|clock_max
condition|)
name|pps_update
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|==
name|sys_peer
condition|)
name|sys_peer
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Mitigation rules of the game. There are several types of 	 * peers that make a difference here: (1) prefer local peers 	 * (type REFCLK_LOCALCLOCK with FLAG_PREFER) or prefer modem 	 * peers (type REFCLK_NIST_ATOM etc with FLAG_PREFER), (2) pps 	 * peers (type REFCLK_ATOM_PPS), (3) remaining prefer peers 	 * (flag FLAG_PREFER), (4) the existing system peer, if any, (5) 	 * the head of the survivor list. Note that only one peer can be 	 * declared prefer. The order of preference is in the order 	 * stated. Note that all of these must be at the lowest stratum, 	 * i.e., the stratum of the head of the survivor list. 	 */
name|osys_peer
operator|=
name|sys_peer
expr_stmt|;
if|if
condition|(
name|typeprefer
operator|&&
operator|(
name|typeprefer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
operator|||
name|typeprefer
operator|->
name|sstclktype
operator|==
name|CTL_SST_TS_TELEPHONE
operator|||
operator|!
name|typepps
operator|)
condition|)
block|{
name|sys_peer
operator|=
name|typeprefer
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
name|sys_epsil
operator|=
name|sys_peer
operator|->
name|variance
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: prefer offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|typepps
operator|&&
name|pps_update
condition|)
block|{
name|sys_peer
operator|=
name|typepps
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_PPS
expr_stmt|;
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
name|sys_epsil
operator|=
name|sys_peer
operator|->
name|variance
expr_stmt|;
if|if
condition|(
operator|!
name|pps_control
condition|)
name|NLOG
argument_list|(
argument|NLOG_SYSEVENT
argument_list|)
comment|/* conditional syslog */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"pps sync enabled"
argument_list|)
expr_stmt|;
name|pps_control
operator|=
name|current_time
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: pps offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
name|typesystem
condition|)
name|sys_peer
operator|=
name|peer_list
index|[
literal|0
index|]
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
name|sys_offset
operator|=
name|clock_combine
argument_list|(
name|peer_list
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
name|sys_epsil
operator|=
name|sys_peer
operator|->
name|variance
operator|+
name|sys_maxd
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: combine offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|osys_peer
operator|!=
name|sys_peer
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|clock_update
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_combine - combine offsets from selected peers  */
end_comment

begin_function
specifier|static
name|double
name|clock_combine
parameter_list|(
name|struct
name|peer
modifier|*
modifier|*
name|peers
parameter_list|,
name|int
name|npeers
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|y
operator|=
name|z
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npeers
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|root_distance
argument_list|(
name|peers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|y
operator|+=
literal|1.
operator|/
name|x
expr_stmt|;
name|z
operator|+=
name|peers
index|[
name|i
index|]
operator|->
name|offset
operator|/
name|x
expr_stmt|;
block|}
return|return
operator|(
name|z
operator|/
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * root_distance - compute synchronization distance from peer to root  */
end_comment

begin_function
specifier|static
name|double
name|root_distance
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
return|return
operator|(
operator|(
name|fabs
argument_list|(
name|peer
operator|->
name|delay
argument_list|)
operator|+
name|peer
operator|->
name|rootdelay
operator|)
operator|/
literal|2
operator|+
name|peer
operator|->
name|rootdispersion
operator|+
name|peer
operator|->
name|disp
operator|+
name|SQRT
argument_list|(
name|peer
operator|->
name|variance
argument_list|)
operator|+
name|CLOCK_PHI
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * peer_xmit - send packet for persistent association.  */
end_comment

begin_function
specifier|static
name|void
name|peer_xmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
name|int
name|find_rtt
init|=
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_MCAST
operator|)
operator|&&
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BROADCAST
decl_stmt|;
name|int
name|sendlen
decl_stmt|;
comment|/* 	 * Initialize protocol fields. 	 */
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|peer
operator|->
name|version
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
operator|+
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|rec
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * Authenticate the packet if enabled and either configured or 	 * the previous packet was authenticated. If for some reason the 	 * key associated with the key identifier is not in the key 	 * cache, then honk key zero. 	 */
name|sendlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
block|{
name|u_long
name|xkeyid
decl_stmt|;
name|l_fp
name|xmt_tx
decl_stmt|;
comment|/* 		 * Transmit encrypted packet compensated for the 		 * encryption delay. 		 */
ifdef|#
directive|ifdef
name|MD5
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
condition|)
block|{
comment|/* 			 * In autokey mode, allocate and initialize a 			 * key list if not already done. Then, use the 			 * list in inverse order, discarding keys once 			 * used. Keep the latest key around until the 			 * next one, so clients can use client/server 			 * packets to compute propagation delay. Note we 			 * have to wait until the receive side of the 			 * socket is bound and the server address 			 * confirmed. 			 */
if|if
condition|(
name|ntohl
argument_list|(
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|==
literal|0
operator|&&
name|ntohl
argument_list|(
name|peer
operator|->
name|dstadr
operator|->
name|bcast
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|==
literal|0
condition|)
name|peer
operator|->
name|keyid
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|keylist
operator|==
literal|0
condition|)
block|{
name|make_keylist
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authtrust
argument_list|(
name|peer
operator|->
name|keylist
index|[
name|peer
operator|->
name|keynumber
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|keynumber
operator|==
literal|0
condition|)
name|make_keylist
argument_list|(
name|peer
argument_list|)
expr_stmt|;
else|else
block|{
name|peer
operator|->
name|keynumber
operator|--
expr_stmt|;
name|xkeyid
operator|=
name|peer
operator|->
name|keylist
index|[
name|peer
operator|->
name|keynumber
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|xkeyid
argument_list|)
condition|)
name|make_keylist
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
name|peer
operator|->
name|keyid
operator|=
name|peer
operator|->
name|keylist
index|[
name|peer
operator|->
name|keynumber
index|]
expr_stmt|;
name|xpkt
operator|.
name|keyid1
operator|=
name|htonl
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|keyid2
operator|=
name|htonl
argument_list|(
name|sys_private
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MD5 */
name|xkeyid
operator|=
name|peer
operator|->
name|keyid
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|authencrypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|find_rtt
condition|?
name|any_interface
else|:
name|peer
operator|->
name|dstadr
argument_list|,
operator|(
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_MCAST
operator|)
operator|&&
operator|!
name|find_rtt
operator|)
condition|?
operator|(
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_ACAST
operator|)
condition|?
operator|-
literal|7
else|:
name|peer
operator|->
name|ttl
operator|)
else|:
operator|-
literal|7
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
comment|/* 		 * Calculate the encryption delay. Keep the minimum over 		 * the latest two samples. 		 */
name|L_SUB
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|1
index|]
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|xmt_tx
operator|.
name|l_uf
expr_stmt|;
if|if
condition|(
name|sys_authdly
index|[
literal|0
index|]
operator|<
name|sys_authdly
index|[
literal|1
index|]
condition|)
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|1
index|]
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld to %s mode %d keyid %08lx index %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|xkeyid
argument_list|,
name|peer
operator|->
name|keynumber
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * Transmit non-authenticated packet. 		 */
name|get_systime
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|xmt
operator|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|find_rtt
condition|?
name|any_interface
else|:
name|peer
operator|->
name|dstadr
argument_list|,
operator|(
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_MCAST
operator|)
operator|&&
operator|!
name|find_rtt
operator|)
condition|?
operator|(
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_ACAST
operator|)
condition|?
operator|-
literal|7
else|:
name|peer
operator|->
name|ttl
operator|)
else|:
operator|-
literal|8
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld to %s mode %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * fast_xmit - Send packet for nonpersistent association.  */
end_comment

begin_function
specifier|static
name|void
name|fast_xmit
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
comment|/* receive packet pointer */
name|int
name|xmode
parameter_list|,
comment|/* transmit mode */
name|u_long
name|xkeyid
comment|/* transmit key ID */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
name|struct
name|pkt
modifier|*
name|rpkt
decl_stmt|;
name|int
name|sendlen
decl_stmt|;
name|l_fp
name|xmt_ts
decl_stmt|;
comment|/* 	 * Initialize transmit packet header fields in the receive 	 * buffer provided. We leave some fields intact as received. 	 */
name|rpkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|rpkt
operator|->
name|ppoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
operator|+
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|org
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
name|sendlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>
name|sendlen
condition|)
block|{
name|l_fp
name|xmt_tx
decl_stmt|;
comment|/* 		 * Transmit encrypted packet compensated for the 		 * encryption delay. 		 */
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|xpkt
operator|.
name|keyid1
operator|=
name|htonl
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|keyid2
operator|=
name|htonl
argument_list|(
name|sys_private
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
expr_stmt|;
block|}
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|authencrypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
operator|-
literal|9
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
comment|/* 		 * Calculate the encryption delay. Keep the minimum over 		 * the latest two samples. 		 */
name|L_SUB
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|1
index|]
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|xmt_tx
operator|.
name|l_uf
expr_stmt|;
if|if
condition|(
name|sys_authdly
index|[
literal|0
index|]
operator|<
name|sys_authdly
index|[
literal|1
index|]
condition|)
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld to %s mode %d keyid %08lx\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|xmode
argument_list|,
name|xkeyid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * Transmit non-authenticated packet. 		 */
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
operator|-
literal|10
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld to %s mode %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MD5
end_ifdef

begin_comment
comment|/*  * Compute key list  */
end_comment

begin_function
specifier|static
name|void
name|make_keylist
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|keyid
decl_stmt|;
name|u_long
name|ltemp
decl_stmt|;
comment|/* 	 * Allocate the key list if necessary. 	 */
if|if
condition|(
name|peer
operator|->
name|keylist
operator|==
literal|0
condition|)
name|peer
operator|->
name|keylist
operator|=
operator|(
name|u_long
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|NTP_MAXSESSION
argument_list|)
expr_stmt|;
comment|/* 	 * Generate an initial key ID which is unique and greater than 	 * NTP_MAXKEY. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|keyid
operator|=
operator|(
name|u_long
operator|)
name|RANDOM
operator|&
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|keyid
operator|<=
name|NTP_MAXKEY
condition|)
continue|continue;
if|if
condition|(
name|authhavekey
argument_list|(
name|keyid
argument_list|)
condition|)
continue|continue;
break|break;
block|}
comment|/* 	 * Generate up to NTP_MAXSESSION session keys. Stop if the 	 * next one would not be unique or not a session key ID or if 	 * it would expire before the next poll. 	 */
name|ltemp
operator|=
name|sys_automax
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_MAXSESSION
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|keylist
index|[
name|i
index|]
operator|=
name|keyid
expr_stmt|;
name|peer
operator|->
name|keynumber
operator|=
name|i
expr_stmt|;
name|keyid
operator|=
name|session_key
argument_list|(
name|ntohl
argument_list|(
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
operator|||
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST2
operator|)
operator|)
condition|?
name|ntohl
argument_list|(
name|peer
operator|->
name|dstadr
operator|->
name|bcast
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
else|:
name|ntohl
argument_list|(
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|keyid
argument_list|,
name|ltemp
argument_list|)
expr_stmt|;
name|ltemp
operator|-=
literal|1
operator|<<
name|peer
operator|->
name|hpoll
expr_stmt|;
if|if
condition|(
name|auth_havekey
argument_list|(
name|keyid
argument_list|)
operator|||
name|keyid
operator|<=
name|NTP_MAXKEY
operator|||
name|ltemp
operator|<=
operator|(
literal|1
operator|<<
operator|(
name|peer
operator|->
name|hpoll
operator|+
literal|1
operator|)
operator|)
condition|)
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MD5 */
end_comment

begin_comment
comment|/*  * Find the precision of this particular machine  */
end_comment

begin_define
define|#
directive|define
name|DUSECS
value|1000000
end_define

begin_comment
comment|/* us in a s */
end_comment

begin_define
define|#
directive|define
name|HUSECS
value|(1<< 20)
end_define

begin_comment
comment|/* approx DUSECS for shifting etc */
end_comment

begin_define
define|#
directive|define
name|MINSTEP
value|5
end_define

begin_comment
comment|/* minimum clock increment (us) */
end_comment

begin_define
define|#
directive|define
name|MAXSTEP
value|20000
end_define

begin_comment
comment|/* maximum clock increment (us) */
end_comment

begin_define
define|#
directive|define
name|MINLOOPS
value|5
end_define

begin_comment
comment|/* minimum number of step samples */
end_comment

begin_comment
comment|/*  * This routine calculates the differences between successive calls to  * gettimeofday(). If a difference is less than zero, the us field  * has rolled over to the next second, so we add a second in us. If  * the difference is greater than zero and less than MINSTEP, the  * clock has been advanced by a small amount to avoid standing still.  * If the clock has advanced by a greater amount, then a timer interrupt  * has occurred and this amount represents the precision of the clock.  * In order to guard against spurious values, which could occur if we  * happen to hit a fat interrupt, we do this for MINLOOPS times and  * keep the minimum value obtained.  */
end_comment

begin_function
name|int
name|default_get_precision
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
name|struct
name|timezone
name|tzp
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
struct|struct
name|timezone
block|{
name|int
name|tz_minuteswest
decl_stmt|;
name|int
name|tz_dsttime
decl_stmt|;
block|}
name|tzp
struct|;
endif|#
directive|endif
comment|/* defined(VMS) || defined(_SEQUENT_) */
name|long
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|diff
decl_stmt|;
name|long
name|val
decl_stmt|;
name|long
name|usec
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
name|struct
name|timespec
name|ts
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
name|u_long
name|freq
decl_stmt|;
name|size_t
name|j
decl_stmt|;
comment|/* Try to see if we can find the frequency of of the counter 	 * which drives our timekeeping 	 */
name|j
operator|=
sizeof|sizeof
name|freq
expr_stmt|;
name|i
operator|=
name|sysctlbyname
argument_list|(
literal|"kern.timecounter.frequency"
argument_list|,
operator|&
name|freq
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|i
operator|=
name|sysctlbyname
argument_list|(
literal|"machdep.tsc_freq"
argument_list|,
operator|&
name|freq
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|i
operator|=
name|sysctlbyname
argument_list|(
literal|"machdep.i586_freq"
argument_list|,
operator|&
name|freq
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|i
operator|=
name|sysctlbyname
argument_list|(
literal|"machdep.i8254_freq"
argument_list|,
operator|&
name|freq
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|freq
condition|;
name|i
operator|--
control|)
name|freq
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
endif|#
directive|endif
name|usec
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|MAXSTEP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
operator|(
name|void
operator|)
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|tp
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tp
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
comment|/*  not HAVE_GETCLOCK */
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_GETCLOCK */
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MINLOOPS
operator|&&
name|usec
operator|<
name|HUSECS
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
operator|(
name|void
operator|)
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|tp
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tp
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
comment|/*  not HAVE_GETCLOCK */
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_GETCLOCK */
name|diff
operator|=
name|tp
operator|.
name|tv_usec
operator|-
name|last
expr_stmt|;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|+=
name|DUSECS
expr_stmt|;
name|usec
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|MINSTEP
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|val
condition|)
name|val
operator|=
name|diff
expr_stmt|;
block|}
block|}
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"precision = %ld usec"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|usec
operator|>=
name|HUSECS
condition|)
name|val
operator|=
name|MINSTEP
expr_stmt|;
comment|/* val<= MINSTEP; fast machine */
name|diff
operator|=
name|HUSECS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|diff
operator|>
name|val
condition|;
name|i
operator|--
control|)
name|diff
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * init_proto - initialize the protocol module's data  */
end_comment

begin_function
name|void
name|init_proto
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|dummy
decl_stmt|;
comment|/* 	 * Fill in the sys_* stuff.  Default is don't listen to 	 * broadcasting, authenticate. 	 */
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|sys_precision
operator|=
operator|(
name|s_char
operator|)
name|default_get_precision
argument_list|()
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdispersion
operator|=
literal|0
expr_stmt|;
name|sys_refid
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_reftime
argument_list|)
expr_stmt|;
name|sys_peer
operator|=
literal|0
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|sys_bclient
operator|=
literal|0
expr_stmt|;
name|sys_bdelay
operator|=
name|DEFBROADDELAY
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DES
argument_list|)
operator|||
name|defined
argument_list|(
name|MD5
argument_list|)
name|sys_authenticate
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|sys_authenticate
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|L_CLR
argument_list|(
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|sys_authdly
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sys_stattime
operator|=
literal|0
expr_stmt|;
name|sys_badstratum
operator|=
literal|0
expr_stmt|;
name|sys_oldversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_newversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_unknownversion
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
name|sys_manycastserver
operator|=
literal|0
expr_stmt|;
name|sys_automax
operator|=
literal|1
operator|<<
name|NTP_AUTOMAX
expr_stmt|;
comment|/* 	 * Default these to enable 	 */
name|ntp_enable
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|KERNEL_FLL_BUG
name|kern_enable
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"kern_enable is %d"
argument_list|,
name|kern_enable
argument_list|)
expr_stmt|;
name|stats_control
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Some system clocks should only be adjusted in 10ms increments. 	 */
if|#
directive|if
name|defined
name|RELIANTUNIX_CLOCK
name|systime_10ms_ticks
operator|=
literal|1
expr_stmt|;
comment|/* Reliant UNIX */
elif|#
directive|elif
name|defined
name|SCO5_CLOCK
if|if
condition|(
name|sys_precision
operator|>=
operator|(
name|s_char
operator|)
operator|-
literal|10
condition|)
comment|/* pre-SCO OpenServer 5.0.6 */
name|systime_10ms_ticks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|systime_10ms_ticks
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"using 10ms tick adjustments"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * proto_config - configure the protocol module  */
end_comment

begin_function
name|void
name|proto_config
parameter_list|(
name|int
name|item
parameter_list|,
name|u_long
name|value
parameter_list|,
name|double
name|dvalue
parameter_list|)
block|{
comment|/* 	 * Figure out what he wants to change, then do it 	 */
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|PROTO_KERNEL
case|:
comment|/* 		 * Turn on/off kernel discipline 		 */
name|kern_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_NTP
case|:
comment|/* 		 * Turn on/off clock discipline 		 */
name|ntp_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_MONITOR
case|:
comment|/* 		 * Turn on/off monitoring 		 */
if|if
condition|(
name|value
condition|)
name|mon_start
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
else|else
name|mon_stop
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_FILEGEN
case|:
comment|/* 		 * Turn on/off statistics 		 */
name|stats_control
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_BROADCLIENT
case|:
comment|/* 		 * Turn on/off facility to listen to broadcasts 		 */
name|sys_bclient
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|io_setbclient
argument_list|()
expr_stmt|;
else|else
name|io_unsetbclient
argument_list|()
expr_stmt|;
break|break;
case|case
name|PROTO_MULTICAST_ADD
case|:
comment|/* 		 * Add muliticast group address 		 */
name|io_multicast_add
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_MULTICAST_DEL
case|:
comment|/* 		 * Delete multicast group address 		 */
name|io_multicast_del
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_BROADDELAY
case|:
comment|/* 		 * Set default broadcast delay 		 */
name|sys_bdelay
operator|=
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_AUTHENTICATE
case|:
comment|/* 		 * Specify the use of authenticated data 		 */
name|sys_authenticate
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Log this error 		 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"proto_config: illegal item %d, value %ld"
argument_list|,
name|item
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * proto_clr_stats - clear protocol stat counters  */
end_comment

begin_function
name|void
name|proto_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|sys_badstratum
operator|=
literal|0
expr_stmt|;
name|sys_oldversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_newversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_unknownversion
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
name|sys_stattime
operator|=
name|current_time
expr_stmt|;
name|sys_limitrejected
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

