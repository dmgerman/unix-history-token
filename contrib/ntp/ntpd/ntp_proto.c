begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_proto.c - NTP version 4 protocol machinery  *  * ATTENTION: Get approval from Dave Mills on all changes to this file!  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|VMS_LOCALUNIT
argument_list|)
end_if

begin_comment
comment|/*wjm*/
end_comment

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This macro defines the authentication state. If x is 1 authentication  * is required; othewise it is optional.  */
end_comment

begin_define
define|#
directive|define
name|AUTH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) ? (y) == AUTH_OK : (y) == AUTH_OK || \ 			    (y) == AUTH_NONE)
end_define

begin_comment
comment|/*  * System variables are declared here. See Section 3.2 of the  * specification.  */
end_comment

begin_decl_stmt
name|u_char
name|sys_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system leap indicator */
end_comment

begin_decl_stmt
name|u_char
name|sys_stratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stratum of system */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision (log2 s) */
end_comment

begin_decl_stmt
name|double
name|sys_rootdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* roundtrip delay to primary source */
end_comment

begin_decl_stmt
name|double
name|sys_rootdispersion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dispersion to primary source */
end_comment

begin_decl_stmt
name|u_int32
name|sys_refid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* source/loop in network byte order */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current local clock offset */
end_comment

begin_decl_stmt
name|l_fp
name|sys_reftime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time we were last updated */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our current peer */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_pps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our PPS peer */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_prefer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our cherished peer */
end_comment

begin_decl_stmt
name|int
name|sys_kod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kod credit */
end_comment

begin_decl_stmt
name|int
name|sys_kod_rate
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max kod packets per second */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_decl_stmt
name|u_long
name|sys_automax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum session key lifetime */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * Nonspecified system state variables.  */
end_comment

begin_decl_stmt
name|int
name|sys_bclient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* broadcast client enable */
end_comment

begin_decl_stmt
name|double
name|sys_bdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* broadcast client default delay */
end_comment

begin_decl_stmt
name|int
name|sys_calldelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modem callup delay (s) */
end_comment

begin_decl_stmt
name|int
name|sys_authenticate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* requre authentication for config */
end_comment

begin_decl_stmt
name|l_fp
name|sys_authdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|sys_authdly
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay shift reg */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_mindisp
init|=
name|MINDISPERSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min disp increment (s) */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_maxdist
init|=
name|MAXDISTANCE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* selection threshold (s) */
end_comment

begin_decl_stmt
name|double
name|sys_jitter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system jitter (s) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sys_hopper
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* anticlockhop counter */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sys_maxhop
init|=
name|MAXHOP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* anticlockhop counter threshold */
end_comment

begin_decl_stmt
name|int
name|leap_next
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* leap consensus */
end_comment

begin_decl_stmt
name|keyid_t
name|sys_private
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private value for session seed */
end_comment

begin_decl_stmt
name|int
name|sys_manycastserver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* respond to manycast client pkts */
end_comment

begin_decl_stmt
name|int
name|peer_ntpdate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* active peers in ntpdate mode */
end_comment

begin_decl_stmt
name|int
name|sys_survivors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* truest of the truechimers */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|sys_hostname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gethostname() name */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * TOS and multicast mapping stuff  */
end_comment

begin_decl_stmt
name|int
name|sys_floor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cluster stratum floor */
end_comment

begin_decl_stmt
name|int
name|sys_ceiling
init|=
name|STRATUM_UNSPEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cluster stratum ceiling */
end_comment

begin_decl_stmt
name|int
name|sys_minsane
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum candidates */
end_comment

begin_decl_stmt
name|int
name|sys_minclock
init|=
name|NTP_MINCLOCK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum survivors */
end_comment

begin_decl_stmt
name|int
name|sys_maxclock
init|=
name|NTP_MAXCLOCK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum candidates */
end_comment

begin_decl_stmt
name|int
name|sys_cohort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cohort switch */
end_comment

begin_decl_stmt
name|int
name|sys_orphan
init|=
name|STRATUM_UNSPEC
operator|+
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* orphan stratum */
end_comment

begin_decl_stmt
name|double
name|sys_orphandelay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* orphan root delay */
end_comment

begin_decl_stmt
name|int
name|sys_beacon
init|=
name|BEACON
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* manycast beacon interval */
end_comment

begin_decl_stmt
name|int
name|sys_ttlmax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max ttl mapping vector index */
end_comment

begin_decl_stmt
name|u_char
name|sys_ttl
index|[
name|MAX_TTL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ttl mapping vector */
end_comment

begin_comment
comment|/*  * Statistics counters  */
end_comment

begin_decl_stmt
name|u_long
name|sys_stattime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time since reset */
end_comment

begin_decl_stmt
name|u_long
name|sys_received
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets received */
end_comment

begin_decl_stmt
name|u_long
name|sys_processed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets processed */
end_comment

begin_decl_stmt
name|u_long
name|sys_newversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current version */
end_comment

begin_decl_stmt
name|u_long
name|sys_oldversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recent version */
end_comment

begin_decl_stmt
name|u_long
name|sys_unknownversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* invalid version */
end_comment

begin_decl_stmt
name|u_long
name|sys_restricted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* access denied */
end_comment

begin_decl_stmt
name|u_long
name|sys_badlength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bad length or format */
end_comment

begin_decl_stmt
name|u_long
name|sys_badauth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bad authentication */
end_comment

begin_decl_stmt
name|u_long
name|sys_limitrejected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rate exceeded */
end_comment

begin_decl_stmt
specifier|static
name|double
name|root_distance
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clock_combine
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|peer_xmit
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fast_xmit
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|,
name|keyid_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clock_update
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_get_precision
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|peer_unfit
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * transmit - Transmit Procedure. See Section 3.4.2 of the  *	specification.  */
end_comment

begin_function
name|void
name|transmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|int
name|hpoll
decl_stmt|;
comment|/* 	 * The polling state machine. There are two kinds of machines, 	 * those that never expect a reply (broadcast and manycast 	 * server modes) and those that do (all other modes). The dance 	 * is intricate... 	 */
comment|/* 	 * Orphan mode is active when enabled and when no servers less 	 * than the orphan statum are available. In this mode packets 	 * are sent at the orphan stratum. An orphan with no other 	 * synchronization source is an orphan parent. It assumes root 	 * delay zero and reference ID the loopback address. All others 	 * are orphan children with root delay randomized over a 1-s 	 * range. The root delay is used by the election algorithm to 	 * select the order of synchronization. 	 */
name|hpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
if|if
condition|(
name|sys_orphan
operator|<
name|STRATUM_UNSPEC
operator|&&
name|sys_peer
operator|==
name|NULL
condition|)
block|{
name|sys_leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|sys_stratum
operator|=
name|sys_orphan
expr_stmt|;
name|sys_refid
operator|=
name|htonl
argument_list|(
name|LOOPBACKADR
argument_list|)
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdispersion
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * In broadcast mode the poll interval is never changed from 	 * minpoll. 	 */
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
operator|(
name|MDF_BCAST
operator||
name|MDF_MCAST
operator|)
condition|)
block|{
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * In manycast mode we start with unity ttl. The ttl is 	 * increased by one for each poll until either sys_maxclock 	 * servers have been found or the maximum ttl is reached. When 	 * sys_maxclock servers are found we stop polling until one or 	 * more servers have timed out or until less than minpoll 	 * associations turn up. In this case additional better servers 	 * are dragged in and preempt the existing ones. 	 */
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_ACAST
condition|)
block|{
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|unreach
operator|>
name|sys_beacon
condition|)
block|{
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sys_survivors
operator|<
name|sys_minclock
operator|||
name|peer_preempt
operator|<
name|sys_maxclock
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|ttl
operator|<
name|sys_ttlmax
condition|)
name|peer
operator|->
name|ttl
operator|++
expr_stmt|;
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|unreach
operator|++
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * In unicast modes the dance is much more intricate. It is 	 * desigmed to back off whenever possible to minimize network 	 * traffic. 	 */
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
name|u_char
name|oreach
decl_stmt|;
comment|/* 		 * Update the reachability status. If not heard for 		 * three consecutive polls, stuff infinity in the clock 		 * filter.  		 */
name|oreach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|sys_peer
condition|)
name|sys_hopper
operator|++
expr_stmt|;
name|peer
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|reach
operator|&
literal|0x07
operator|)
condition|)
name|clock_filter
argument_list|(
name|peer
argument_list|,
literal|0.
argument_list|,
literal|0.
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|reach
condition|)
block|{
comment|/* 			 * Here the peer is unreachable. If it was 			 * previously reachable, raise a trap. 			 */
if|if
condition|(
name|oreach
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_UNREACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
block|}
comment|/* 			 * Send a burst if enabled, but only once after 			 * a peer becomes unreachable. If the prempt 			 * flag is dim, bump the unreach counter by one; 			 * otherwise, bump it by three. 			 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_IBURST
operator|&&
name|peer
operator|->
name|unreach
operator|==
literal|0
condition|)
block|{
name|peer
operator|->
name|burst
operator|=
name|NTP_BURST
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREEMPT
operator|)
condition|)
name|peer
operator|->
name|unreach
operator|++
expr_stmt|;
else|else
name|peer
operator|->
name|unreach
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Here the peer is reachable. Set the poll 			 * interval to the system poll interval. Send a 			 * burst only if enabled and the peer is fit. 			 * 			 * Respond to the peer evaluation produced by 			 * the selection algorithm. If less than the 			 * outlyer level, up the unreach by three. If 			 * there are excess associations, up the unreach 			 * by two if not a candidate and by one if so. 			 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREEMPT
operator|)
condition|)
block|{
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|status
operator|<
name|CTL_PST_SEL_SELCAND
condition|)
block|{
name|peer
operator|->
name|unreach
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer_preempt
operator|>
name|sys_maxclock
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|status
operator|<
name|CTL_PST_SEL_SYNCCAND
condition|)
name|peer
operator|->
name|unreach
operator|+=
literal|2
expr_stmt|;
else|else
name|peer
operator|->
name|unreach
operator|++
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
block|}
name|hpoll
operator|=
name|sys_poll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_BURST
operator|&&
operator|!
name|peer_unfit
argument_list|(
name|peer
argument_list|)
condition|)
name|peer
operator|->
name|burst
operator|=
name|NTP_BURST
expr_stmt|;
block|}
comment|/* 		 * Watch for timeout. If ephemeral or preemptable, toss 		 * the rascal; otherwise, bump the poll interval. 		 */
if|if
condition|(
name|peer
operator|->
name|unreach
operator|>=
name|NTP_UNREACH
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREEMPT
operator|||
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"TIME"
argument_list|)
expr_stmt|;
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|hpoll
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|peer
operator|->
name|burst
operator|--
expr_stmt|;
comment|/* 		 * If a broadcast client at this point, the burst has 		 * concluded, so we switch to client mode and purge the 		 * keylist, since no further transmissions will be made. 		 */
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
condition|)
block|{
name|peer
operator|->
name|hmode
operator|=
name|MODE_BCLIENT
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
block|}
comment|/* 			 * If ntpdate mode and the clock has not been 			 * set and all peers have completed the burst, 			 * we declare a successful failure. 			 */
if|if
condition|(
name|mode_ntpdate
condition|)
block|{
name|peer_ntpdate
operator|--
expr_stmt|;
if|if
condition|(
name|peer_ntpdate
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"no reply; clock not set"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Do not transmit if in broadcast client mode.  	 */
if|if
condition|(
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BCLIENT
condition|)
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * receive - Receive Procedure.  See section 3.4.3 in the specification.  */
end_comment

begin_function
name|void
name|receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* peer structure pointer */
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
comment|/* receive packet pointer */
name|int
name|hisversion
decl_stmt|;
comment|/* packet version */
name|int
name|hisleap
decl_stmt|;
comment|/* packet leap indicator */
name|int
name|hismode
decl_stmt|;
comment|/* packet mode */
name|int
name|hisstratum
decl_stmt|;
comment|/* packet stratum */
name|int
name|restrict_mask
decl_stmt|;
comment|/* restrict bits */
name|int
name|has_mac
decl_stmt|;
comment|/* length of MAC field */
name|int
name|authlen
decl_stmt|;
comment|/* offset of MAC field */
name|int
name|is_authentic
init|=
literal|0
decl_stmt|;
comment|/* cryptosum ok */
name|keyid_t
name|skeyid
init|=
literal|0
decl_stmt|;
comment|/* key ID */
name|struct
name|sockaddr_storage
modifier|*
name|dstadr_sin
decl_stmt|;
comment|/* active runway */
name|struct
name|peer
modifier|*
name|peer2
decl_stmt|;
comment|/* aux peer structure pointer */
name|l_fp
name|p_org
decl_stmt|;
comment|/* origin timestamp */
name|l_fp
name|p_rec
decl_stmt|;
comment|/* receive timestamp */
name|l_fp
name|p_xmt
decl_stmt|;
comment|/* transmit timestamp */
ifdef|#
directive|ifdef
name|OPENSSL
name|keyid_t
name|tkeyid
init|=
literal|0
decl_stmt|;
comment|/* temporary key ID */
name|keyid_t
name|pkeyid
init|=
literal|0
decl_stmt|;
comment|/* previous key ID */
name|struct
name|autokey
modifier|*
name|ap
decl_stmt|;
comment|/* autokey structure pointer */
name|int
name|rval
decl_stmt|;
comment|/* cookie snatcher */
endif|#
directive|endif
comment|/* OPENSSL */
name|int
name|retcode
init|=
name|AM_NOMATCH
decl_stmt|;
name|int
name|at_listhead
decl_stmt|;
comment|/* 	 * Monitor the packet and get restrictions. Note that the packet 	 * length for control and private mode packets must be checked 	 * by the service routines. Note that no statistics counters are 	 * recorded for restrict violations, since these counters are in 	 * the restriction routine. Note the careful distinctions here 	 * between a packet with a format error and a packet that is 	 * simply discarded without prejudice. Some restrictions have to 	 * be handled later in order to generate a kiss-of-death packet. 	 */
comment|/* 	 * Bogus port check is before anything, since it probably 	 * reveals a clogging attack. 	 */
name|sys_received
operator|++
expr_stmt|;
if|if
condition|(
name|SRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bogus port */
block|}
name|at_listhead
operator|=
name|ntp_monitor
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
name|restrict_mask
operator|=
name|restrictions
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|at_listhead
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s flags %x restrict %03x\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|restrict_mask
operator|&
name|RES_IGNORE
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* ignore everything */
block|}
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
name|hisversion
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|hisleap
operator|=
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|hismode
operator|=
operator|(
name|int
operator|)
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|hisstratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
if|if
condition|(
name|hismode
operator|==
name|MODE_PRIVATE
condition|)
block|{
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOQUERY
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no query private */
block|}
name|process_private
argument_list|(
name|rbufp
argument_list|,
operator|(
operator|(
name|restrict_mask
operator|&
name|RES_NOMODIFY
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hismode
operator|==
name|MODE_CONTROL
condition|)
block|{
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOQUERY
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no query control */
block|}
name|process_control
argument_list|(
name|rbufp
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|restrict_mask
operator|&
name|RES_DONTSERVE
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no time */
block|}
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|<
name|LEN_PKT_NOMAC
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* runt packet */
block|}
comment|/* 	 * Version check must be after the query packets, since they 	 * intentionally use early version. 	 */
if|if
condition|(
name|hisversion
operator|==
name|NTP_VERSION
condition|)
block|{
name|sys_newversionpkt
operator|++
expr_stmt|;
comment|/* new version */
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|restrict_mask
operator|&
name|RES_VERSION
operator|)
operator|&&
name|hisversion
operator|>=
name|NTP_OLDVERSION
condition|)
block|{
name|sys_oldversionpkt
operator|++
expr_stmt|;
comment|/* previous version */
block|}
else|else
block|{
name|sys_unknownversion
operator|++
expr_stmt|;
return|return;
comment|/* old version */
block|}
comment|/* 	 * Figure out his mode and validate the packet. This has some 	 * legacy raunch that probably should be removed. In very early 	 * NTP versions mode 0 was equivalent to what later versions 	 * would interpret as client mode. 	 */
if|if
condition|(
name|hismode
operator|==
name|MODE_UNSPEC
condition|)
block|{
if|if
condition|(
name|hisversion
operator|==
name|NTP_OLDVERSION
condition|)
block|{
name|hismode
operator|=
name|MODE_CLIENT
expr_stmt|;
block|}
else|else
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* invalid mode */
block|}
block|}
comment|/* 	 * Parse the extension field if present. We figure out whether 	 * an extension field is present by measuring the MAC size. If 	 * the number of words following the packet header is 0, no MAC 	 * is present and the packet is not authenticated. If 1, the 	 * packet is a crypto-NAK; if 3, the packet is authenticated 	 * with DES; if 5, the packet is authenticated with MD5. If 2 or 	 * 4, the packet is a runt and discarded forthwith. If greater 	 * than 5, an extension field is present, so we subtract the 	 * length of the field and go around again. 	 */
name|authlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
name|has_mac
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|authlen
expr_stmt|;
while|while
condition|(
name|has_mac
operator|>
literal|0
condition|)
block|{
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|has_mac
operator|%
literal|4
operator|!=
literal|0
operator|||
name|has_mac
operator|<
literal|0
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bad MAC length */
block|}
if|if
condition|(
name|has_mac
operator|==
literal|1
operator|*
literal|4
operator|||
name|has_mac
operator|==
literal|3
operator|*
literal|4
operator|||
name|has_mac
operator|==
name|MAX_MAC_LEN
condition|)
block|{
name|skeyid
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
name|u_int32
operator|*
operator|)
name|pkt
operator|)
index|[
name|authlen
operator|/
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|has_mac
operator|>
name|MAX_MAC_LEN
condition|)
block|{
name|temp
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
name|u_int32
operator|*
operator|)
name|pkt
operator|)
index|[
name|authlen
operator|/
literal|4
index|]
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|4
operator|||
name|temp
operator|>
name|NTP_MAXEXTEN
operator|||
name|temp
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bad MAC length */
block|}
name|authlen
operator|+=
name|temp
expr_stmt|;
name|has_mac
operator|-=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bad MAC length */
block|}
block|}
ifdef|#
directive|ifdef
name|OPENSSL
name|pkeyid
operator|=
name|tkeyid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * We have tossed out as many buggy packets as possible early in 	 * the game to reduce the exposure to a clogging attack. Now we 	 * have to burn some cycles to find the association and 	 * authenticate the packet if required. Note that we burn only 	 * MD5 cycles, again to reduce exposure. There may be no 	 * matching association and that's okay. 	 * 	 * More on the autokey mambo. Normally the local interface is 	 * found when the association was mobilized with respect to a 	 * designated remote address. We assume packets arriving from 	 * the remote address arrive via this interface and the local 	 * address used to construct the autokey is the unicast address 	 * of the interface. However, if the sender is a broadcaster, 	 * the interface broadcast address is used instead.& Notwithstanding this technobabble, if the sender is a 	 * multicaster, the broadcast address is null, so we use the 	 * unicast address anyway. Don't ask. 	 */
name|peer
operator|=
name|findpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|hismode
argument_list|,
operator|&
name|retcode
argument_list|)
expr_stmt|;
name|dstadr_sin
operator|=
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|,
operator|&
name|p_rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
comment|/* 	 * Authentication is conditioned by three switches: 	 * 	 * NOPEER  (RES_NOPEER) do not mobilize an association unless 	 *         authenticated 	 * NOTRUST (RES_DONTTRUST) do not allow access unless 	 *         authenticated (implies NOPEER) 	 * enable  (sys_authenticate) master NOPEER switch, by default 	 *         on 	 * 	 * The NOPEER and NOTRUST can be specified on a per-client basis 	 * using the restrict command. The enable switch if on implies 	 * NOPEER for all clients. There are four outcomes: 	 * 	 * NONE    The packet has no MAC. 	 * OK      the packet has a MAC and authentication succeeds 	 * ERROR   the packet has a MAC and authentication fails 	 * CRYPTO  crypto-NAK. The MAC has four octets only. 	 * 	 * Note: The AUTH(x, y) macro is used to filter outcomes. If x 	 * is zero, acceptable outcomes of y are NONE and OK. If x is 	 * one, the only acceptable outcome of y is OK. 	 */
if|if
condition|(
name|has_mac
operator|==
literal|0
condition|)
block|{
name|is_authentic
operator|=
name|AUTH_NONE
expr_stmt|;
comment|/* not required */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s mode %d code %d auth %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
name|dstadr_sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|retcode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|has_mac
operator|==
literal|4
condition|)
block|{
name|is_authentic
operator|=
name|AUTH_CRYPTO
expr_stmt|;
comment|/* crypto-NAK */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s mode %d code %d keyid %08x len %d mac %d auth %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
name|dstadr_sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|retcode
argument_list|,
name|skeyid
argument_list|,
name|authlen
argument_list|,
name|has_mac
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* 		 * For autokey modes, generate the session key 		 * and install in the key cache. Use the socket 		 * broadcast or unicast address as appropriate. 		 */
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
comment|/* 			 * More on the autokey dance (AKD). A cookie is 			 * constructed from public and private values. 			 * For broadcast packets, the cookie is public 			 * (zero). For packets that match no 			 * association, the cookie is hashed from the 			 * addresses and private value. For server 			 * packets, the cookie was previously obtained 			 * from the server. For symmetric modes, the 			 * cookie was previously constructed using an 			 * agreement protocol; however, should PKI be 			 * unavailable, we construct a fake agreement as 			 * the EXOR of the peer and host cookies. 			 * 			 * hismode	ephemeral	persistent 			 * ======================================= 			 * active	0		cookie# 			 * passive	0%		cookie# 			 * client	sys cookie	0% 			 * server	0%		sys cookie 			 * broadcast	0		0 			 * 			 * # if unsync, 0 			 * % can't happen 			 */
if|if
condition|(
name|hismode
operator|==
name|MODE_BROADCAST
condition|)
block|{
comment|/* 				 * For broadcaster, use the interface 				 * broadcast address when available; 				 * otherwise, use the unicast address 				 * found when the association was 				 * mobilized. However, if this is from 				 * the wildcard interface, game over. 				 */
if|if
condition|(
name|crypto_flags
operator|&&
name|rbufp
operator|->
name|dstadr
operator|==
name|any_interface
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no wildcard */
block|}
name|pkeyid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SOCKNUL
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|bcast
argument_list|)
condition|)
name|dstadr_sin
operator|=
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|bcast
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
block|{
name|pkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
literal|0
argument_list|,
name|sys_private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkeyid
operator|=
name|peer
operator|->
name|pcookie
expr_stmt|;
block|}
comment|/* 			 * The session key includes both the public 			 * values and cookie. In case of an extension 			 * field, the cookie used for authentication 			 * purposes is zero. Note the hash is saved for 			 * use later in the autokey mambo. 			 */
if|if
condition|(
name|authlen
operator|>
name|LEN_PKT_NOMAC
operator|&&
name|pkeyid
operator|!=
literal|0
condition|)
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
name|pkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
name|pkeyid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 		 * Compute the cryptosum. Note a clogging attack may 		 * succeed in bloating the key cache. If an autokey, 		 * purge it immediately, since we won't be needing it 		 * again. If the packet is authentic, it can mobilize an 		 * association. Note that there is no key zero. 		 */
if|if
condition|(
operator|!
name|authdecrypt
argument_list|(
name|skeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|pkt
argument_list|,
name|authlen
argument_list|,
name|has_mac
argument_list|)
condition|)
block|{
name|is_authentic
operator|=
name|AUTH_ERROR
expr_stmt|;
name|sys_badauth
operator|++
expr_stmt|;
return|return;
block|}
else|else
block|{
name|is_authentic
operator|=
name|AUTH_OK
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|skeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s mode %d code %d keyid %08x len %d mac %d auth %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
name|dstadr_sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|retcode
argument_list|,
name|skeyid
argument_list|,
name|authlen
argument_list|,
name|has_mac
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * The association matching rules are implemented by a set of 	 * routines and an association table. A packet matching an 	 * association is processed by the peer process for that 	 * association. If there are no errors, an ephemeral association 	 * is mobilized: a broadcast packet mobilizes a broadcast client 	 * aassociation; a manycast server packet mobilizes a manycast 	 * client association; a symmetric active packet mobilizes a 	 * symmetric passive association. 	 */
switch|switch
condition|(
name|retcode
condition|)
block|{
comment|/* 	 * This is a client mode packet not matching any association. If 	 * an ordinary client, simply toss a server mode packet back 	 * over the fence. If a manycast client, we have to work a 	 * little harder. 	 */
case|case
name|AM_FXMIT
case|:
comment|/* 		 * The vanilla case is when this is not a multicast 		 * interface. If authentication succeeds, return a 		 * server mode packet; if not and the key ID is nonzero, 		 * return a crypto-NAK. 		 */
if|if
condition|(
operator|!
operator|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MCASTOPEN
operator|)
condition|)
block|{
if|if
condition|(
name|AUTH
argument_list|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
argument_list|,
name|is_authentic
argument_list|)
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
name|skeyid
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_authentic
operator|==
name|AUTH_ERROR
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
comment|/* hooray */
block|}
comment|/* 		 * This must be manycast. Do not respond if not 		 * configured as a manycast server. 		 */
if|if
condition|(
operator|!
name|sys_manycastserver
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* not enabled */
block|}
comment|/* 		 * Do not respond if unsynchronized or stratum is below 		 * the floor or at or above the ceiling. 		 */
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
operator|||
name|sys_stratum
operator|<
name|sys_floor
operator|||
name|sys_stratum
operator|>=
name|sys_ceiling
condition|)
return|return;
comment|/* bad stratum */
comment|/* 		 * Do not respond if our stratum is greater than the 		 * manycaster or it has already synchronized to us. 		 */
if|if
condition|(
name|sys_peer
operator|==
name|NULL
operator|||
name|hisstratum
operator|<
name|sys_stratum
operator|||
operator|(
name|sys_cohort
operator|&&
name|hisstratum
operator|==
name|sys_stratum
operator|)
operator|||
name|rbufp
operator|->
name|dstadr
operator|->
name|addr_refid
operator|==
name|pkt
operator|->
name|refid
condition|)
return|return;
comment|/* no help */
comment|/* 		 * Respond only if authentication succeeds. Don't do a 		 * crypto-NAK, as that would not be useful. 		 */
if|if
condition|(
name|AUTH
argument_list|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
argument_list|,
name|is_authentic
argument_list|)
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
name|skeyid
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
comment|/* hooray */
comment|/* 	 * This is a server mode packet returned in response to a client 	 * mode packet sent to a multicast group address. The origin 	 * timestamp is a good nonce to reliably associate the reply 	 * with what was sent. If there is no match, that's curious and 	 * could be an intruder attempting to clog, so we just ignore 	 * it. 	 * 	 * If the packet is authentic and the manycast association is 	 * found, we mobilize a client association and copy pertinent 	 * variables from the manycast association to the new client 	 * association. If not, just ignore the packet. 	 * 	 * There is an implosion hazard at the manycast client, since 	 * the manycast servers send the server packet immediately. If 	 * the guy is already here, don't fire up a duplicate. 	 */
case|case
name|AM_MANYCAST
case|:
if|if
condition|(
operator|!
name|AUTH
argument_list|(
name|sys_authenticate
operator||
operator|(
name|restrict_mask
operator|&
operator|(
name|RES_NOPEER
operator||
name|RES_DONTTRUST
operator|)
operator|)
argument_list|,
name|is_authentic
argument_list|)
condition|)
return|return;
comment|/* bad auth */
if|if
condition|(
operator|(
name|peer2
operator|=
name|findmanycastpeer
argument_list|(
name|rbufp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* not enabled */
block|}
if|if
condition|(
operator|(
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_CLIENT
argument_list|,
name|hisversion
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
name|FLAG_IBURST
operator||
name|FLAG_PREEMPT
argument_list|,
name|MDF_UCAST
operator||
name|MDF_ACLNT
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* system error */
comment|/* 		 * We don't need these, but it warms the billboards. 		 */
name|peer
operator|->
name|ttl
operator|=
name|peer2
operator|->
name|ttl
expr_stmt|;
break|break;
comment|/* 	 * This is the first packet received from a broadcast server. If 	 * the packet is authentic and we are enabled as broadcast 	 * client, mobilize a broadcast client association. We don't 	 * kiss any frogs here. 	 */
case|case
name|AM_NEWBCL
case|:
if|if
condition|(
operator|!
name|AUTH
argument_list|(
name|sys_authenticate
operator||
operator|(
name|restrict_mask
operator|&
operator|(
name|RES_NOPEER
operator||
name|RES_DONTTRUST
operator|)
operator|)
argument_list|,
name|is_authentic
argument_list|)
condition|)
return|return;
comment|/* bad auth */
comment|/* 		 * Do not respond if unsynchronized or stratum is below 		 * the floor or at or above the ceiling. 		 */
if|if
condition|(
name|hisleap
operator|==
name|LEAP_NOTINSYNC
operator|||
name|hisstratum
operator|<
name|sys_floor
operator|||
name|hisstratum
operator|>=
name|sys_ceiling
condition|)
return|return;
comment|/* bad stratum */
switch|switch
condition|(
name|sys_bclient
condition|)
block|{
comment|/* 		 * If not enabled, just skedaddle. 		 */
case|case
literal|0
case|:
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* not enabled */
comment|/* 		 * Execute the initial volley in order to calibrate the 		 * propagation delay and run the Autokey protocol, if 		 * enabled. 		 */
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_CLIENT
argument_list|,
name|hisversion
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
name|FLAG_MCAST
operator||
name|FLAG_IBURST
argument_list|,
name|MDF_BCLNT
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* system error */
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
name|crypto_recv
argument_list|(
name|peer
argument_list|,
name|rbufp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
return|return;
comment|/* hooray */
comment|/* 		 * Do not execute the initial volley. 		 */
case|case
literal|2
case|:
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* 			 * If a two-way exchange is not possible, 			 * neither is Autokey. 			 */
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"receive: autokey requires two-way communication"
argument_list|)
expr_stmt|;
return|return;
comment|/* no autokey */
block|}
endif|#
directive|endif
comment|/* OPENSSL */
if|if
condition|(
operator|(
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_BCLIENT
argument_list|,
name|hisversion
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
literal|0
argument_list|,
name|MDF_BCLNT
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* system error */
block|}
break|break;
comment|/* 	 * This is the first packet received from a symmetric active 	 * peer. If the packet is authentic and the first he sent, 	 * mobilize a passive association. If not, kiss the frog. 	 */
case|case
name|AM_NEWPASS
case|:
comment|/* 		 * If the inbound packet is correctly authenticated and 		 * enabled, a symmetric passive association is 		 * mobilized. If not but correctly authenticated, a 		 * symmetric active response is sent. If authentication 		 * fails, send a crypto-NAK packet.  		 */
if|if
condition|(
operator|!
name|AUTH
argument_list|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
argument_list|,
name|is_authentic
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_authentic
operator|==
name|AUTH_ERROR
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_ACTIVE
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
comment|/* bad auth */
block|}
if|if
condition|(
operator|!
name|AUTH
argument_list|(
name|sys_authenticate
operator||
operator|(
name|restrict_mask
operator|&
name|RES_NOPEER
operator|)
argument_list|,
name|is_authentic
argument_list|)
condition|)
block|{
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_ACTIVE
argument_list|,
name|skeyid
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
comment|/* hooray */
block|}
comment|/* 		 * Do not respond if stratum is below the floor. 		 */
if|if
condition|(
name|hisstratum
operator|<
name|sys_floor
condition|)
return|return;
comment|/* bad stratum */
if|if
condition|(
operator|(
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_PASSIVE
argument_list|,
name|hisversion
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
literal|0
argument_list|,
name|MDF_UCAST
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* system error */
break|break;
comment|/* 	 * Process regular packet. Nothing special. 	 */
case|case
name|AM_PROCPKT
case|:
break|break;
comment|/* 	 * A passive packet matches a passive association. This is 	 * usually the result of reconfiguring a client on the fly. As 	 * this association might be legitamate and this packet an 	 * attempt to deny service, just ignore it. 	 */
case|case
name|AM_ERR
case|:
return|return;
comment|/* 	 * For everything else there is the bit bucket. 	 */
default|default:
return|return;
block|}
name|peer
operator|->
name|flash
operator|&=
operator|~
name|PKT_TEST_MASK
expr_stmt|;
comment|/* 	 * Next comes a rigorous schedule of timestamp checking. If the 	 * transmit timestamp is zero, the server is horribly broken. 	 */
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_xmt
argument_list|)
condition|)
block|{
return|return;
comment|/* read rfc1305 */
comment|/* 	 * If the transmit timestamp duplicates a previous one, the 	 * packet is a replay. This prevents the bad guys from replaying 	 * the most recent packet, authenticated or not. 	 */
block|}
elseif|else
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST1
expr_stmt|;
name|peer
operator|->
name|oldpkt
operator|++
expr_stmt|;
return|return;
comment|/* duplicate packet */
comment|/* 	 * If this is a broadcast mode packet, skip further checking. 	 */
block|}
elseif|else
if|if
condition|(
name|hismode
operator|!=
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_org
argument_list|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* protocol unsynch */
elseif|else
if|if
condition|(
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|p_org
argument_list|,
operator|&
name|peer
operator|->
name|xmt
argument_list|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST2
expr_stmt|;
comment|/* bogus packet */
block|}
comment|/* 	 * Update the origin and destination timestamps. If 	 * unsynchronized or bogus abandon ship. If the crypto machine 	 * breaks, light the crypto bit and plaint the log. 	 */
name|peer
operator|->
name|org
operator|=
name|p_xmt
expr_stmt|;
name|peer
operator|->
name|rec
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|PKT_TEST_MASK
condition|)
block|{
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|crypto_flags
operator|&&
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
operator|)
condition|)
block|{
name|rval
operator|=
name|crypto_recv
argument_list|(
name|peer
argument_list|,
name|rbufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|XEVNT_OK
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"CRYP"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST9
expr_stmt|;
comment|/* crypto error */
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL */
return|return;
comment|/* unsynch */
block|}
comment|/* 	 * The timestamps are valid and the receive packet matches the 	 * last one sent. If the packet is a crypto-NAK, the server 	 * might have just changed keys. We reset the association 	 * and restart the protocol. 	 */
if|if
condition|(
name|is_authentic
operator|==
name|AUTH_CRYPTO
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"AUTH"
argument_list|)
expr_stmt|;
return|return;
comment|/* crypto-NAK */
comment|/*  	 * If the association is authenticated, the key ID is nonzero 	 * and received packets must be authenticated. This is designed 	 * to avoid a bait-and-switch attack, which was possible in past 	 * versions. If symmetric modes, return a crypto-NAK. The peer 	 * should restart the protocol. 	 */
block|}
elseif|else
if|if
condition|(
operator|!
name|AUTH
argument_list|(
name|peer
operator|->
name|keyid
operator|||
operator|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
operator|)
argument_list|,
name|is_authentic
argument_list|)
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST5
expr_stmt|;
if|if
condition|(
name|hismode
operator|==
name|MODE_ACTIVE
operator|||
name|hismode
operator|==
name|MODE_PASSIVE
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_ACTIVE
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
comment|/* bad auth */
block|}
comment|/* 	 * That was hard and I am sweaty, but the packet is squeaky 	 * clean. Get on with real work. 	 */
name|peer
operator|->
name|received
operator|++
expr_stmt|;
name|peer
operator|->
name|timereceived
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|is_authentic
operator|==
name|AUTH_OK
condition|)
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENTIC
expr_stmt|;
else|else
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_AUTHENTIC
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* 	 * More autokey dance. The rules of the cha-cha are as follows: 	 * 	 * 1. If there is no key or the key is not auto, do nothing. 	 * 	 * 2. If this packet is in response to the one just previously 	 *    sent or from a broadcast server, do the extension fields. 	 *    Otherwise, assume bogosity and bail out. 	 * 	 * 3. If an extension field contains a verified signature, it is 	 *    self-authenticated and we sit the dance. 	 * 	 * 4. If this is a server reply, check only to see that the 	 *    transmitted key ID matches the received key ID. 	 * 	 * 5. Check to see that one or more hashes of the current key ID 	 *    matches the previous key ID or ultimate original key ID 	 *    obtained from the broadcaster or symmetric peer. If no 	 *    match, sit the dance and wait for timeout. 	 * 	 * In case of crypto error, fire the orchestra and stop dancing. 	 * This is considered a permanant error, so light the crypto bit 	 * to suppress further requests. If preemptable or ephemeral, 	 * scuttle the ship. 	 */
if|if
condition|(
name|crypto_flags
operator|&&
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
operator|)
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST8
expr_stmt|;
name|rval
operator|=
name|crypto_recv
argument_list|(
name|peer
argument_list|,
name|rbufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|XEVNT_OK
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"CRYP"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST9
expr_stmt|;
comment|/* crypto error */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREEMPT
operator|||
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|hismode
operator|==
name|MODE_SERVER
condition|)
block|{
if|if
condition|(
name|skeyid
operator|==
name|peer
operator|->
name|keyid
condition|)
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flash
operator|&
name|TEST8
operator|)
condition|)
block|{
name|peer
operator|->
name|pkeyid
operator|=
name|skeyid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ap
operator|=
operator|(
expr|struct
name|autokey
operator|*
operator|)
name|peer
operator|->
name|recval
operator|.
name|ptr
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tkeyid
operator|==
name|peer
operator|->
name|pkeyid
operator|||
name|tkeyid
operator|==
name|ap
operator|->
name|key
condition|)
block|{
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
name|peer
operator|->
name|pkeyid
operator|=
name|skeyid
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|ap
operator|->
name|seq
condition|)
break|break;
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|tkeyid
argument_list|,
name|pkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_PROV
operator|)
condition|)
comment|/* test 9 */
name|peer
operator|->
name|flash
operator||=
name|TEST8
expr_stmt|;
comment|/* not proventic */
comment|/* 		 * If the transmit queue is nonempty, clamp the host 		 * poll interval to the packet poll interval. 		 */
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
literal|0
condition|)
block|{
name|peer
operator|->
name|ppoll
operator|=
name|pkt
operator|->
name|ppoll
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * The dance is complete and the flash bits have been lit. Toss 	 * the packet over the fence for processing, which may light up 	 * more flashers. 	 */
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
comment|/* 	 * Well, that was nice. If TEST4 is lit, either the crypto 	 * machine jammed or a kiss-o'-death packet flew in, either of 	 * which is fatal. 	 */
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|TEST4
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"receive: fatal error %04x for %s"
argument_list|,
name|peer
operator|->
name|flash
argument_list|,
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * process_packet - Packet Procedure, a la Section 3.4.4 of the  *	specification. Or almost, at least. If we're in here we have a  *	reasonable expectation that we will be having a long term  *	relationship with this host.  */
end_comment

begin_function
name|void
name|process_packet
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|)
block|{
name|double
name|t34
decl_stmt|,
name|t21
decl_stmt|;
name|double
name|p_offset
decl_stmt|,
name|p_del
decl_stmt|,
name|p_disp
decl_stmt|;
name|l_fp
name|p_rec
decl_stmt|,
name|p_xmt
decl_stmt|,
name|p_org
decl_stmt|,
name|p_reftime
decl_stmt|;
name|l_fp
name|ci
decl_stmt|;
name|u_char
name|pmode
decl_stmt|,
name|pleap
decl_stmt|,
name|pstratum
decl_stmt|;
name|sys_processed
operator|++
expr_stmt|;
name|peer
operator|->
name|processed
operator|++
expr_stmt|;
name|p_del
operator|=
name|FPTOD
argument_list|(
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|p_disp
operator|=
name|FPTOD
argument_list|(
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|reftime
argument_list|,
operator|&
name|p_reftime
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|,
operator|&
name|p_rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
name|pmode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|pleap
operator|=
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmode
operator|!=
name|MODE_BROADCAST
condition|)
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
else|else
name|p_org
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
name|pstratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
comment|/* 	 * Test for kiss-o'death packet) 	 */
if|if
condition|(
name|pleap
operator|==
name|LEAP_NOTINSYNC
operator|&&
name|pstratum
operator|==
name|STRATUM_UNSPEC
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|pkt
operator|->
name|refid
argument_list|,
literal|"DENY"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"DENY"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST4
expr_stmt|;
comment|/* access denied */
block|}
block|}
comment|/* 	 * Capture the header values. 	 */
name|record_raw_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|peer
operator|->
name|dstadr
condition|?
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
else|:
name|NULL
argument_list|,
operator|&
name|p_org
argument_list|,
operator|&
name|p_rec
argument_list|,
operator|&
name|p_xmt
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
name|peer
operator|->
name|leap
operator|=
name|pleap
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|min
argument_list|(
name|pstratum
argument_list|,
name|STRATUM_UNSPEC
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pmode
operator|=
name|pmode
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|pkt
operator|->
name|ppoll
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|pkt
operator|->
name|precision
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
name|p_del
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
name|p_disp
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pkt
operator|->
name|refid
expr_stmt|;
comment|/* network byte order */
name|peer
operator|->
name|reftime
operator|=
name|p_reftime
expr_stmt|;
comment|/* 	 * Verify the server is synchronized; that is, the leap bits and 	 * stratum are valid, the root delay and root dispersion are 	 * valid and the reference timestamp is not later than the 	 * transmit timestamp. 	 */
if|if
condition|(
name|pleap
operator|==
name|LEAP_NOTINSYNC
operator|||
comment|/* test 6 */
name|pstratum
operator|<
name|sys_floor
operator|||
name|pstratum
operator|>=
name|sys_ceiling
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST6
expr_stmt|;
comment|/* peer not synch */
if|if
condition|(
name|p_del
operator|<
literal|0
operator|||
name|p_disp
operator|<
literal|0
operator|||
name|p_del
operator|/
comment|/* test 7 */
literal|2
operator|+
name|p_disp
operator|>=
name|MAXDISPERSE
operator|||
operator|!
name|L_ISHIS
argument_list|(
operator|&
name|p_xmt
argument_list|,
operator|&
name|p_reftime
argument_list|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST7
expr_stmt|;
comment|/* bad header */
comment|/* 	 * If any tests fail at this point, the packet is discarded. 	 * Note that some flashers may have already been set in the 	 * receive() routine. 	 */
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|PKT_TEST_MASK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: flash header %04x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|reach
operator|)
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_REACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
block|}
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
comment|/* 	 * For a client/server association, calculate the clock offset, 	 * roundtrip delay and dispersion. The equations are reordered 	 * from the spec for more efficient use of temporaries. For a 	 * broadcast association, offset the last measurement by the 	 * computed delay during the client/server volley. Note that 	 * org has been set to the time of last reception. Note the 	 * computation of dispersion includes the system precision plus 	 * that due to the frequency error since the origin time. 	 * 	 * It is very important to respect the hazards of overflow. The 	 * only permitted operation on raw timestamps is subtraction, 	 * where the result is a signed quantity spanning from 68 years 	 * in the past to 68 years in the future. To avoid loss of 	 * precision, these calculations are done using 64-bit integer 	 * arithmetic. However, the offset and delay calculations are 	 * sums and differences of these first-order differences, which 	 * if done using 64-bit integer arithmetic, would be valid over 	 * only half that span. Since the typical first-order 	 * differences are usually very small, they are converted to 64- 	 * bit doubles and all remaining calculations done in floating- 	 * point arithmetic. This preserves the accuracy while retaining 	 * the 68-year span. 	 * 	 * Let t1 = p_org, t2 = p_rec, t3 = p_xmt, t4 = peer->rec: 	 */
name|ci
operator|=
name|p_xmt
expr_stmt|;
comment|/* t3 - t4 */
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|t34
argument_list|)
expr_stmt|;
name|ci
operator|=
name|p_rec
expr_stmt|;
comment|/* t2 - t1 */
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|t21
argument_list|)
expr_stmt|;
name|ci
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
comment|/* t4 - t1 */
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
comment|/* 	 * If running in a broadcast association, the clock offset is 	 * (t1 - t0) corrected by the one-way delay, but we can't 	 * measure that directly. Therefore, we start up in MODE_CLIENT 	 * mode, set FLAG_MCAST and exchange eight messages to determine 	 * the clock offset. When the last message is sent, we switch to 	 * MODE_BCLIENT mode. The next broadcast message after that 	 * computes the broadcast offset and clears FLAG_MCAST. 	 */
if|if
condition|(
name|pmode
operator|==
name|MODE_BROADCAST
condition|)
block|{
name|p_offset
operator|=
name|t34
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST
condition|)
block|{
name|peer
operator|->
name|estbdelay
operator|=
name|peer
operator|->
name|offset
operator|-
name|p_offset
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_CLIENT
condition|)
return|return;
name|peer
operator|->
name|flags
operator|&=
operator|~
operator|(
name|FLAG_MCAST
operator||
name|FLAG_BURST
operator|)
expr_stmt|;
block|}
name|p_offset
operator|+=
name|peer
operator|->
name|estbdelay
expr_stmt|;
name|p_del
operator|=
name|peer
operator|->
name|delay
expr_stmt|;
name|p_disp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p_offset
operator|=
operator|(
name|t21
operator|+
name|t34
operator|)
operator|/
literal|2.
expr_stmt|;
name|p_del
operator|=
name|t21
operator|-
name|t34
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|p_disp
argument_list|)
expr_stmt|;
name|p_disp
operator|=
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
operator|+
name|LOGTOD
argument_list|(
name|peer
operator|->
name|precision
argument_list|)
operator|+
name|clock_phi
operator|*
name|p_disp
expr_stmt|;
block|}
name|p_del
operator|=
name|max
argument_list|(
name|p_del
argument_list|,
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
expr_stmt|;
name|clock_filter
argument_list|(
name|peer
argument_list|,
name|p_offset
argument_list|,
name|p_del
argument_list|,
name|p_disp
argument_list|)
expr_stmt|;
name|record_peer_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|disp
argument_list|,
name|peer
operator|->
name|jitter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_update - Called at system process update intervals.  */
end_comment

begin_function
specifier|static
name|void
name|clock_update
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|oleap
decl_stmt|;
name|u_char
name|ostratum
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
comment|/* 	 * There must be a system peer at this point. If we just changed 	 * the system peer, but have a newer sample from the old one, 	 * wait until newer data are available. 	 */
if|if
condition|(
name|sys_poll
operator|<
name|sys_peer
operator|->
name|minpoll
condition|)
name|sys_poll
operator|=
name|sys_peer
operator|->
name|minpoll
expr_stmt|;
if|if
condition|(
name|sys_poll
operator|>
name|sys_peer
operator|->
name|maxpoll
condition|)
name|sys_poll
operator|=
name|sys_peer
operator|->
name|maxpoll
expr_stmt|;
name|poll_update
argument_list|(
name|sys_peer
argument_list|,
name|sys_poll
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_peer
operator|->
name|epoch
operator|<=
name|sys_clocktime
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_update: at %ld assoc %d \n"
argument_list|,
name|current_time
argument_list|,
name|peer_associations
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oleap
operator|=
name|sys_leap
expr_stmt|;
name|ostratum
operator|=
name|sys_stratum
expr_stmt|;
switch|switch
condition|(
name|local_clock
argument_list|(
name|sys_peer
argument_list|,
name|sys_offset
argument_list|)
condition|)
block|{
comment|/* 	 * Clock exceeds panic threshold. Life as we know it ends. 	 */
case|case
operator|-
literal|1
case|:
name|report_event
argument_list|(
name|EVNT_SYSFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* not reached */
comment|/* 	 * Clock was stepped. Flush all time values of all peers. 	 */
case|case
literal|2
case|:
name|clear_all
argument_list|()
expr_stmt|;
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdispersion
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"STEP"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_CLOCKRESET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Clock was slewed. Update the system stratum, leap bits, root 	 * delay, root dispersion, reference ID and reference time. If 	 * the leap changes, we gotta reroll the keys. Except for 	 * reference clocks, the minimum dispersion increment is not 	 * less than sys_mindisp. 	 */
case|case
literal|1
case|:
name|sys_leap
operator|=
name|leap_next
expr_stmt|;
name|sys_stratum
operator|=
name|min
argument_list|(
name|sys_peer
operator|->
name|stratum
operator|+
literal|1
argument_list|,
name|STRATUM_UNSPEC
argument_list|)
expr_stmt|;
name|sys_reftime
operator|=
name|sys_peer
operator|->
name|rec
expr_stmt|;
comment|/* 		 * In orphan mode the stratum defaults to the orphan 		 * stratum. The root delay is set to a random value 		 * generated at startup. The root dispersion is set from 		 * the peer dispersion; the peer root dispersion is 		 * ignored. 		 */
name|dtemp
operator|=
name|sys_peer
operator|->
name|disp
operator|+
name|clock_phi
operator|*
operator|(
name|current_time
operator|-
name|sys_peer
operator|->
name|update
operator|)
operator|+
name|sys_jitter
operator|+
name|fabs
argument_list|(
name|sys_peer
operator|->
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
operator|!
operator|(
name|sys_peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|)
operator|&&
name|dtemp
operator|<
name|sys_mindisp
condition|)
name|dtemp
operator|=
name|sys_mindisp
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|dtemp
operator|<
name|sys_mindisp
condition|)
name|dtemp
operator|=
name|sys_mindisp
expr_stmt|;
endif|#
directive|endif
comment|/* REFCLOCK */
if|if
condition|(
name|sys_stratum
operator|>=
name|sys_orphan
condition|)
block|{
name|sys_stratum
operator|=
name|sys_orphan
expr_stmt|;
name|sys_rootdelay
operator|=
name|sys_peer
operator|->
name|delay
expr_stmt|;
name|sys_rootdispersion
operator|=
name|dtemp
expr_stmt|;
block|}
else|else
block|{
name|sys_rootdelay
operator|=
name|sys_peer
operator|->
name|delay
operator|+
name|sys_peer
operator|->
name|rootdelay
expr_stmt|;
name|sys_rootdispersion
operator|=
name|dtemp
operator|+
name|sys_peer
operator|->
name|rootdispersion
expr_stmt|;
block|}
if|if
condition|(
name|oleap
operator|==
name|LEAP_NOTINSYNC
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_SYNCCHG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|expire_all
argument_list|()
expr_stmt|;
name|crypto_update
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
block|}
break|break;
comment|/* 	 * Popcorn spike or step threshold exceeded. Pretend it never 	 * happened. 	 */
default|default:
break|break;
block|}
if|if
condition|(
name|ostratum
operator|!=
name|sys_stratum
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * poll_update - update peer poll interval  */
end_comment

begin_function
name|void
name|poll_update
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|mpoll
parameter_list|)
block|{
name|int
name|hpoll
decl_stmt|;
comment|/* 	 * This routine figures out when the next poll should be sent. 	 * That turns out to be wickedly complicated. The big problem is 	 * that sometimes the time for the next poll is in the past. 	 * Watch out for races here between the receive process and the 	 * poll process. The key assertion is that, if nextdate equals 	 * current_time, the call is from the poll process; otherwise, 	 * it is from the receive process. 	 * 	 * First, bracket the poll interval according to the type of 	 * association and options. If a fixed interval is configured, 	 * use minpoll. This primarily is for reference clocks, but 	 * works for any association. 	 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_FIXPOLL
condition|)
block|{
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
comment|/* 	 * The ordinary case; clamp the poll interval between minpoll 	 * and maxpoll. 	 */
block|}
else|else
block|{
name|hpoll
operator|=
name|max
argument_list|(
name|min
argument_list|(
name|peer
operator|->
name|maxpoll
argument_list|,
name|mpoll
argument_list|)
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* 	 * Bit of crass arrogance at this point. If the poll interval 	 * has changed and we have a keylist, the lifetimes in the 	 * keylist are probably bogus. In this case purge the keylist 	 * and regenerate it later. 	 */
if|if
condition|(
name|hpoll
operator|!=
name|peer
operator|->
name|hpoll
condition|)
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
name|peer
operator|->
name|hpoll
operator|=
name|hpoll
expr_stmt|;
comment|/* 	 * Now we figure out if there is an override. If during the 	 * crypto protocol and a message is pending, make it wait not 	 * more than two seconds. 	 */
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
operator|&&
operator|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|||
name|peer
operator|->
name|crypto
operator|)
condition|)
block|{
name|peer
operator|->
name|nextdate
operator|=
name|current_time
operator|+
name|RESP_DELAY
expr_stmt|;
comment|/* 	 * If we get called from the receive routine while a burst is 	 * pending, just slink away. If from the poll routine and a 	 * reference clock or a pending crypto response, delay for one 	 * second. If this is the first sent in a burst, wait for the 	 * modem to come up. For others in the burst, delay two seconds. 	 */
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
block|{
else|#
directive|else
comment|/* OPENSSL */
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* OPENSSL */
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|!=
name|current_time
condition|)
return|return;
ifdef|#
directive|ifdef
name|REFCLOCK
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|peer
operator|->
name|nextdate
operator|+=
name|RESP_DELAY
expr_stmt|;
endif|#
directive|endif
comment|/* REFCLOCK */
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
operator|(
name|FLAG_IBURST
operator||
name|FLAG_BURST
operator|)
operator|&&
name|peer
operator|->
name|burst
operator|==
name|NTP_BURST
condition|)
name|peer
operator|->
name|nextdate
operator|+=
name|sys_calldelay
expr_stmt|;
else|else
name|peer
operator|->
name|nextdate
operator|+=
name|BURST_DELAY
expr_stmt|;
comment|/* 	 * The ordinary case; use the minimum of the host and peer 	 * intervals, but not less than minpoll. In other words, 	 * oversampling is okay but understampling is evil. 	 */
block|}
else|else
block|{
name|peer
operator|->
name|nextdate
operator|=
name|peer
operator|->
name|outdate
operator|+
name|RANDPOLL
argument_list|(
name|max
argument_list|(
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|hpoll
argument_list|)
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the time for the next poll has already happened, bring it 	 * up to the next second after this one. This way the only way 	 * to get nexdate == current time is from the poll routine. 	 */
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|<=
name|current_time
condition|)
name|peer
operator|->
name|nextdate
operator|=
name|current_time
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"poll_update: at %lu %s flags %04x poll %d burst %d last %lu next %lu\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|flags
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|,
name|peer
operator|->
name|burst
argument_list|,
name|peer
operator|->
name|outdate
argument_list|,
name|peer
operator|->
name|nextdate
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * peer_crypto_clear - discard crypto information  */
name|void
name|peer_crypto_clear
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
comment|/* 	 * If cryptographic credentials have been acquired, toss them to 	 * Valhalla. Note that autokeys are ephemeral, in that they are 	 * tossed immediately upon use. Therefore, the keylist can be 	 * purged anytime without needing to preserve random keys. Note 	 * that, if the peer is purged, the cryptographic variables are 	 * purged, too. This makes it much harder to sneak in some 	 * unauthenticated data in the clock filter. 	 */
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"peer_crypto_clear: at %ld next %ld assoc ID %d\n"
operator|,
name|current_time
operator|,
name|peer
operator|->
name|nextdate
operator|,
name|peer
operator|->
name|associd
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|peer
operator|->
name|assoc
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|crypto
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|pkey
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|peer
operator|->
name|pkey
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pkey
operator|=
name|NULL
expr_stmt|;
name|peer
operator|->
name|digest
operator|=
name|NULL
expr_stmt|;
comment|/* XXX MEMLEAK? check whether this needs to be freed in any way - never was freed */
if|if
condition|(
name|peer
operator|->
name|subject
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|subject
argument_list|)
expr_stmt|;
name|peer
operator|->
name|subject
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|issuer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|issuer
operator|=
name|NULL
expr_stmt|;
name|peer
operator|->
name|pkeyid
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|pcookie
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|peer
operator|->
name|ident_pkey
argument_list|)
expr_stmt|;
name|peer
operator|->
name|ident_pkey
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|peer
operator|->
name|fstamp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|peer
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|iffval
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|grpkey
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|grpkey
argument_list|)
expr_stmt|;
name|peer
operator|->
name|grpkey
operator|=
name|NULL
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|cookval
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|recval
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|peer
operator|->
name|cmmd
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|NULL
expr_stmt|;
block|}
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|encrypt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
block|}
comment|/*  * peer_clear - clear peer filter registers.  See Section 3.4.8 of the spec.  */
name|void
name|peer_clear
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure */
name|char
modifier|*
name|ident
comment|/* tally lights */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|peer_crypto_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|sys_peer
condition|)
name|sys_peer
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Wipe the association clean and initialize the nonzero values. 	 */
name|memset
argument_list|(
name|CLEAR_TO_ZERO
argument_list|(
name|peer
argument_list|)
argument_list|,
literal|0
argument_list|,
name|LEN_CLEAR_TO_ZERO
argument_list|)
expr_stmt|;
name|peer
operator|->
name|estbdelay
operator|=
name|sys_bdelay
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|disp
operator|=
name|MAXDISPERSE
expr_stmt|;
name|peer
operator|->
name|jitter
operator|=
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|peer
operator|->
name|filter_disp
index|[
name|i
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|)
condition|)
block|{
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|ident
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|ident
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* REFCLOCK */
comment|/* 	 * During initialization use the association count to spread out 	 * the polls at one-second intervals. Othersie, randomize over 	 * the minimum poll interval in order to avoid broadcast 	 * implosion. 	 */
name|peer
operator|->
name|nextdate
operator|=
name|peer
operator|->
name|update
operator|=
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|initializing
condition|)
name|peer
operator|->
name|nextdate
operator|+=
name|peer_associations
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_PASSIVE
condition|)
name|peer
operator|->
name|nextdate
operator|+=
name|RESP_DELAY
expr_stmt|;
else|else
name|peer
operator|->
name|nextdate
operator|+=
operator|(
name|ntp_random
argument_list|()
operator|&
operator|(
operator|(
literal|1
operator|<<
name|NTP_MINDPOLL
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"peer_clear: at %ld next %ld assoc ID %d refid %s\n"
operator|,
name|current_time
operator|,
name|peer
operator|->
name|nextdate
operator|,
name|peer
operator|->
name|associd
operator|,
name|ident
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*  * clock_filter - add incoming clock sample to filter register and run  *		  the filter procedure to find the best sample.  */
name|void
name|clock_filter
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample_offset
parameter_list|,
comment|/* clock offset */
name|double
name|sample_delay
parameter_list|,
comment|/* roundtrip delay */
name|double
name|sample_disp
comment|/* dispersion */
parameter_list|)
block|{
name|double
name|dst
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* distance vector */
name|int
name|ord
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* index vector */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|;
name|double
name|dtemp
decl_stmt|,
name|etemp
decl_stmt|;
comment|/* 	 * Shift the new sample into the register and discard the oldest 	 * one. The new offset and delay come directly from the 	 * timestamp calculations. The dispersion grows from the last 	 * outbound packet or reference clock update to the present time 	 * and increased by the sum of the peer precision and the system 	 * precision. The delay can sometimes swing negative due to 	 * frequency skew, so it is clamped non-negative. 	 */
name|j
operator|=
name|peer
operator|->
name|filter_nextpt
expr_stmt|;
name|peer
operator|->
name|filter_offset
index|[
name|j
index|]
operator|=
name|sample_offset
expr_stmt|;
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|sample_delay
argument_list|)
expr_stmt|;
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|=
name|sample_disp
expr_stmt|;
name|peer
operator|->
name|filter_epoch
index|[
name|j
index|]
operator|=
name|current_time
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
literal|1
operator|)
operator|%
name|NTP_SHIFT
expr_stmt|;
name|peer
operator|->
name|filter_nextpt
operator|=
name|j
expr_stmt|;
comment|/* 	 * Update dispersions since the last update and at the same 	 * time initialize the distance and index lists. The distance 	 * list uses a compound metric. If the sample is valid and 	 * younger than the minimum Allan intercept, use delay; 	 * otherwise, use biased dispersion. 	 */
name|dtemp
operator|=
name|clock_phi
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
expr_stmt|;
name|peer
operator|->
name|update
operator|=
name|current_time
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|+=
name|dtemp
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|>=
name|MAXDISPERSE
condition|)
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|>=
name|MAXDISPERSE
condition|)
name|dst
index|[
name|i
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|update
operator|-
name|peer
operator|->
name|filter_epoch
index|[
name|j
index|]
operator|>
name|allan_xpt
condition|)
name|dst
index|[
name|i
index|]
operator|=
name|sys_maxdist
operator|+
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
expr_stmt|;
else|else
name|dst
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|j
operator|%=
name|NTP_SHIFT
expr_stmt|;
block|}
comment|/* 	 * If the clock discipline has stabilized, sort the samples in 	 * both lists by distance. Note, we do not displace a higher 	 * distance sample by a lower distance one unless lower by at 	 * least the precision.   	 */
if|if
condition|(
name|state
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|dst
index|[
name|j
index|]
operator|>
name|dst
index|[
name|i
index|]
operator|+
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
condition|)
block|{
name|k
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|j
index|]
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
name|etemp
operator|=
name|dst
index|[
name|j
index|]
expr_stmt|;
name|dst
index|[
name|j
index|]
operator|=
name|dst
index|[
name|i
index|]
expr_stmt|;
name|dst
index|[
name|i
index|]
operator|=
name|etemp
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Copy the index list to the association structure so ntpq 	 * can see it later. Prune the distance list to samples less 	 * than max distance, but keep at least two valid samples for 	 * jitter calculation. 	 */
name|m
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter_order
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|ord
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dst
index|[
name|i
index|]
operator|>=
name|MAXDISPERSE
operator|||
operator|(
name|m
operator|>=
literal|2
operator|&&
name|dst
index|[
name|i
index|]
operator|>=
name|sys_maxdist
operator|)
condition|)
continue|continue;
name|m
operator|++
expr_stmt|;
block|}
comment|/* 	 * Compute the dispersion and jitter. The dispersion is weighted 	 * exponentially by NTP_FWEIGHT (0.5) so it is normalized close 	 * to 1.0. The jitter is the RMS differences relative to the 	 * lowest delay sample. If no acceptable samples remain in the 	 * shift register, quietly tiptoe home leaving only the 	 * dispersion. 	 */
name|peer
operator|->
name|disp
operator|=
name|peer
operator|->
name|jitter
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|ord
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|j
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|peer
operator|->
name|disp
operator|=
name|NTP_FWEIGHT
operator|*
operator|(
name|peer
operator|->
name|disp
operator|+
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|m
condition|)
name|peer
operator|->
name|jitter
operator|+=
name|DIFF
argument_list|(
name|peer
operator|->
name|filter_offset
index|[
name|j
index|]
argument_list|,
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If no acceptable samples remain in the shift register, 	 * quietly tiptoe home leaving only the dispersion. Otherwise, 	 * save the offset, delay and jitter. Note the jitter must not 	 * be less than the precision. 	 */
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|etemp
operator|=
name|fabs
argument_list|(
name|peer
operator|->
name|offset
operator|-
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|peer
operator|->
name|offset
operator|=
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
expr_stmt|;
name|peer
operator|->
name|delay
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|1
condition|)
name|peer
operator|->
name|jitter
operator|/=
name|m
operator|-
literal|1
expr_stmt|;
name|peer
operator|->
name|jitter
operator|=
name|max
argument_list|(
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
argument_list|,
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * A new sample is useful only if it is younger than the last 	 * one used. Note the order is FIFO if the clock discipline has 	 * not stabilized. 	 */
if|if
condition|(
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
operator|<=
name|peer
operator|->
name|epoch
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: discard %lu\n"
argument_list|,
name|peer
operator|->
name|epoch
operator|-
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * If the difference between the last offset and the current one 	 * exceeds the jitter by CLOCK_SGATE and the interval since the 	 * last update is less than twice the system poll interval, 	 * consider the update a popcorn spike and ignore it. 	 */
if|if
condition|(
name|etemp
operator|>
name|CLOCK_SGATE
operator|*
name|peer
operator|->
name|jitter
operator|&&
name|m
operator|>
literal|1
operator|&&
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
operator|-
name|peer
operator|->
name|epoch
operator|<
literal|2.
operator|*
name|ULOGTOD
argument_list|(
name|sys_poll
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: popcorn %.6f %.6f\n"
argument_list|,
name|etemp
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The mitigated sample statistics are saved for later 	 * processing. If not in a burst, tickle the select. 	 */
name|peer
operator|->
name|epoch
operator|=
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: n %d off %.6f del %.6f dsp %.6f jit %.6f, age %lu\n"
argument_list|,
name|m
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|disp
argument_list|,
name|peer
operator|->
name|jitter
argument_list|,
name|current_time
operator|-
name|peer
operator|->
name|epoch
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
operator|||
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
condition|)
name|clock_select
argument_list|()
expr_stmt|;
block|}
comment|/*  * clock_select - find the pick-of-the-litter clock  *  * LOCKCLOCK: If the local clock is the prefer peer, it will always be  * enabled, even if declared falseticker, (2) only the prefer peer can  * be selected as the system peer, (3) if the external source is down,  * the system leap bits are set to 11 and the stratum set to infinity.  */
name|void
name|clock_select
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|int
name|nlist
decl_stmt|,
name|nl3
decl_stmt|;
name|int
name|allow
decl_stmt|,
name|osurv
decl_stmt|;
name|double
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|;
name|double
name|high
decl_stmt|,
name|low
decl_stmt|;
name|double
name|synch
index|[
name|NTP_MAXASSOC
index|]
decl_stmt|,
name|error
index|[
name|NTP_MAXASSOC
index|]
decl_stmt|;
name|struct
name|peer
modifier|*
name|osys_peer
decl_stmt|;
name|struct
name|peer
modifier|*
name|typeacts
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typelocal
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typesystem
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|list_alloc
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|endpoint
modifier|*
name|endpoint
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
modifier|*
name|indx
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|peer
modifier|*
modifier|*
name|peer_list
init|=
name|NULL
decl_stmt|;
specifier|static
name|u_int
name|endpoint_size
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|indx_size
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|peer_list_size
init|=
literal|0
decl_stmt|;
comment|/* 	 * Initialize and create endpoint, index and peer lists big 	 * enough to handle all associations. 	 */
name|osys_peer
operator|=
name|sys_peer
expr_stmt|;
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|sys_pps
operator|=
name|NULL
expr_stmt|;
name|sys_prefer
operator|=
name|NULL
expr_stmt|;
name|osurv
operator|=
name|sys_survivors
expr_stmt|;
name|sys_survivors
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKCLOCK
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"DOWN"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKCLOCK */
name|nlist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NTP_HASH_SIZE
condition|;
name|n
operator|++
control|)
name|nlist
operator|+=
name|peer_hash_count
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
name|list_alloc
condition|)
block|{
if|if
condition|(
name|list_alloc
operator|>
literal|0
condition|)
block|{
name|free
argument_list|(
name|endpoint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|indx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer_list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|list_alloc
operator|<
name|nlist
condition|)
block|{
name|list_alloc
operator|+=
literal|5
expr_stmt|;
name|endpoint_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|endpoint
argument_list|)
expr_stmt|;
name|indx_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|indx
argument_list|)
expr_stmt|;
name|peer_list_size
operator|+=
literal|5
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|peer_list
argument_list|)
expr_stmt|;
block|}
name|endpoint
operator|=
operator|(
expr|struct
name|endpoint
operator|*
operator|)
name|emalloc
argument_list|(
name|endpoint_size
argument_list|)
expr_stmt|;
name|indx
operator|=
operator|(
name|int
operator|*
operator|)
name|emalloc
argument_list|(
name|indx_size
argument_list|)
expr_stmt|;
name|peer_list
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
name|peer_list_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initially, we populate the island with all the rifraff peers 	 * that happen to be lying around. Those with seriously 	 * defective clocks are immediately booted off the island. Then, 	 * the falsetickers are culled and put to sea. The truechimers 	 * remaining are subject to repeated rounds where the most 	 * unpopular at each round is kicked off. When the population 	 * has dwindled to sys_minclock, the survivors split a million 	 * bucks and collectively crank the chimes. 	 */
name|nlist
operator|=
name|nl3
operator|=
literal|0
expr_stmt|;
comment|/* none yet */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NTP_HASH_SIZE
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|n
index|]
init|;
name|peer
operator|!=
name|NULL
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_SYSPEER
expr_stmt|;
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_REJECT
expr_stmt|;
comment|/* 			 * Leave the island immediately if the peer is 			 * unfit to synchronize. 			 */
if|if
condition|(
name|peer_unfit
argument_list|(
name|peer
argument_list|)
condition|)
continue|continue;
comment|/* 			 * Don't allow the local clock or modem drivers 			 * in the kitchen at this point, unless the 			 * prefer peer. Do that later, but only if 			 * nobody else is around. These guys are all 			 * configured, so we never throw them away. 			 */
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|peer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|VMS_LOCALUNIT
argument_list|)
comment|/* wjm: VMS_LOCALUNIT taken seriously */
operator|&&
name|REFCLOCKUNIT
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|!=
name|VMS_LOCALUNIT
endif|#
directive|endif
comment|/* VMS&& VMS_LOCALUNIT */
condition|)
block|{
name|typelocal
operator|=
name|peer
expr_stmt|;
ifndef|#
directive|ifndef
name|LOCKCLOCK
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
continue|continue;
comment|/* no local clock */
endif|#
directive|endif
comment|/* LOCKCLOCK */
block|}
if|if
condition|(
name|peer
operator|->
name|sstclktype
operator|==
name|CTL_SST_TS_TELEPHONE
condition|)
block|{
name|typeacts
operator|=
name|peer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
continue|continue;
comment|/* no acts */
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
comment|/* 			 * If we get this far, the peer can stay on the 			 * island, but does not yet have the immunity 			 * idol. 			 */
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|peer_list
index|[
name|nlist
operator|++
index|]
operator|=
name|peer
expr_stmt|;
comment|/* 			 * Insert each interval endpoint on the sorted 			 * list. 			 */
name|e
operator|=
name|peer
operator|->
name|offset
expr_stmt|;
comment|/* Upper end */
name|f
operator|=
name|root_distance
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|+
name|f
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nl3
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|indx
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|indx
index|[
name|i
index|]
expr_stmt|;
block|}
name|indx
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|-
name|f
expr_stmt|;
comment|/* Center point */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|indx
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|indx
index|[
name|i
index|]
expr_stmt|;
block|}
name|indx
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|-
name|f
expr_stmt|;
comment|/* Lower end */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|indx
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|indx
index|[
name|i
index|]
expr_stmt|;
block|}
name|indx
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl3
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: endpoint %2d %.6f\n"
argument_list|,
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
argument_list|,
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This is the actual algorithm that cleaves the truechimers 	 * from the falsetickers. The original algorithm was described 	 * in Keith Marzullo's dissertation, but has been modified for 	 * better accuracy. 	 * 	 * Briefly put, we first assume there are no falsetickers, then 	 * scan the candidate list first from the low end upwards and 	 * then from the high end downwards. The scans stop when the 	 * number of intersections equals the number of candidates less 	 * the number of falsetickers. If this doesn't happen for a 	 * given number of falsetickers, we bump the number of 	 * falsetickers and try again. If the number of falsetickers 	 * becomes equal to or greater than half the number of 	 * candidates, the Albanians have won the Byzantine wars and 	 * correct synchronization is not possible. 	 * 	 * Here, nlist is the number of candidates and allow is the 	 * number of falsetickers. Upon exit, the truechimers are the 	 * susvivors with offsets not less than low and not greater than 	 * high. There may be none of them. 	 */
name|low
operator|=
literal|1e9
expr_stmt|;
name|high
operator|=
operator|-
literal|1e9
expr_stmt|;
for|for
control|(
name|allow
operator|=
literal|0
init|;
literal|2
operator|*
name|allow
operator|<
name|nlist
condition|;
name|allow
operator|++
control|)
block|{
name|int
name|found
decl_stmt|;
comment|/* 		 * Bound the interval (low, high) as the largest 		 * interval containing points from presumed truechimers. 		 */
name|found
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl3
condition|;
name|i
operator|++
control|)
block|{
name|low
operator|=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
expr_stmt|;
name|n
operator|-=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|nlist
operator|-
name|allow
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nl3
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|high
operator|=
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
operator|.
name|val
expr_stmt|;
name|n
operator|+=
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|nlist
operator|-
name|allow
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
comment|/* 		 * If the number of candidates found outside the 		 * interval is greater than the number of falsetickers, 		 * then at least one truechimer is outside the interval, 		 * so go around again. This is what makes this algorithm 		 * different than Marzullo's. 		 */
if|if
condition|(
name|found
operator|>
name|allow
condition|)
continue|continue;
comment|/* 		 * If an interval containing truechimers is found, stop. 		 * If not, increase the number of falsetickers and go 		 * around again. 		 */
if|if
condition|(
name|high
operator|>
name|low
condition|)
break|break;
block|}
comment|/* 	 * Clustering algorithm. Construct candidate list in order first 	 * by stratum then by root distance, but keep only the best 	 * NTP_MAXASSOC of them. Scan the list to find falsetickers, who 	 * leave the island immediately. The TRUE peer is always a 	 * truechimer. We must leave at least one peer to collect the 	 * million bucks. If in orphan mode, rascals found with lower 	 * stratum are guaranteed a seat on the bus. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
literal|1
operator|&&
operator|(
name|peer
operator|->
name|offset
operator|<=
name|low
operator|||
name|peer
operator|->
name|offset
operator|>=
name|high
operator|)
operator|&&
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_TRUE
operator|)
operator|&&
operator|!
operator|(
name|sys_stratum
operator|>=
name|sys_orphan
operator|&&
name|peer
operator|->
name|stratum
operator|<
name|sys_orphan
operator|)
condition|)
continue|continue;
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_DISTSYSPEER
expr_stmt|;
comment|/* 		 * The order metric is formed from the stratum times 		 * max distance (1.) plus the root distance. It strongly 		 * favors the lowest stratum, but a higher stratum peer 		 * can capture the clock if the low stratum dominant 		 * hasn't been heard for awhile. 		 */
name|d
operator|=
name|root_distance
argument_list|(
name|peer
argument_list|)
operator|+
name|peer
operator|->
name|stratum
operator|*
name|sys_maxdist
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|NTP_MAXASSOC
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|j
operator|-
literal|1
index|]
condition|)
continue|continue;
else|else
name|j
operator|--
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|k
operator|-
literal|1
index|]
condition|)
break|break;
name|peer_list
index|[
name|k
index|]
operator|=
name|peer_list
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|error
index|[
name|k
index|]
operator|=
name|error
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|synch
index|[
name|k
index|]
operator|=
name|synch
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|peer_list
index|[
name|k
index|]
operator|=
name|peer
expr_stmt|;
name|error
index|[
name|k
index|]
operator|=
name|peer
operator|->
name|jitter
expr_stmt|;
name|synch
index|[
name|k
index|]
operator|=
name|d
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|nlist
operator|=
name|j
expr_stmt|;
comment|/* 	 * If no survivors remain at this point, check if the local 	 * clock or modem drivers have been found. If so, nominate one 	 * of them as the only survivor. Otherwise, give up and leave 	 * the island to the rats. 	 */
if|if
condition|(
name|nlist
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|typeacts
operator|!=
literal|0
condition|)
block|{
name|typeacts
operator|->
name|status
operator|=
name|CTL_PST_SEL_DISTSYSPEER
expr_stmt|;
name|peer_list
index|[
literal|0
index|]
operator|=
name|typeacts
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typelocal
operator|!=
literal|0
condition|)
block|{
name|typelocal
operator|->
name|status
operator|=
name|CTL_PST_SEL_DISTSYSPEER
expr_stmt|;
name|peer_list
index|[
literal|0
index|]
operator|=
name|typelocal
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|osys_peer
operator|!=
name|NULL
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_SYNCSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"no servers reachable"
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * We can only trust the survivors if the number of candidates 	 * sys_minsane is at least the number required to detect and 	 * cast out one falsticker. For the Byzantine agreement 	 * algorithm used here, that number is 4; however, the default 	 * sys_minsane is 1 to speed initial synchronization. Careful 	 * operators will tinker a higher value and use at least that 	 * number of synchronization sources. 	 */
if|if
condition|(
name|nlist
operator|<
name|sys_minsane
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
name|peer_list
index|[
name|i
index|]
operator|->
name|status
operator|=
name|CTL_PST_SEL_SELCAND
expr_stmt|;
comment|/* 	 * Now, vote outlyers off the island by select jitter weighted 	 * by root distance. Continue voting as long as there are more 	 * than sys_minclock survivors and the minimum select jitter is 	 * greater than the maximum peer jitter. Stop if we are about to 	 * discard a TRUE or PREFER  peer, who of course has the 	 * immunity idol. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|d
operator|=
literal|1e9
expr_stmt|;
name|e
operator|=
operator|-
literal|1e9
expr_stmt|;
name|f
operator|=
name|g
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|error
index|[
name|i
index|]
operator|<
name|d
condition|)
name|d
operator|=
name|error
index|[
name|i
index|]
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
name|f
operator|+=
name|DIFF
argument_list|(
name|peer_list
index|[
name|j
index|]
operator|->
name|offset
argument_list|,
name|peer_list
index|[
name|i
index|]
operator|->
name|offset
argument_list|)
expr_stmt|;
name|f
operator|=
name|SQRT
argument_list|(
name|f
operator|/
operator|(
name|nlist
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|*
name|synch
index|[
name|i
index|]
operator|>
name|e
condition|)
block|{
name|g
operator|=
name|f
expr_stmt|;
name|e
operator|=
name|f
operator|*
name|synch
index|[
name|i
index|]
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
block|}
name|f
operator|=
name|max
argument_list|(
name|f
argument_list|,
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlist
operator|<=
name|sys_minclock
operator|||
name|f
operator|<=
name|d
operator|||
name|peer_list
index|[
name|k
index|]
operator|->
name|flags
operator|&
operator|(
name|FLAG_TRUE
operator||
name|FLAG_PREFER
operator|)
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"select: drop %s select %.6f jitter %.6f\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|k
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|g
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
name|k
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
name|peer_list
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|peer_list
index|[
name|j
index|]
expr_stmt|;
name|error
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|error
index|[
name|j
index|]
expr_stmt|;
block|}
name|nlist
operator|--
expr_stmt|;
block|}
comment|/* 	 * What remains is a list usually not greater than sys_minclock 	 * peers. We want only a peer at the lowest stratum to become 	 * the system peer, although all survivors are eligible for the 	 * combining algorithm. Consider each peer in turn and OR the 	 * leap bits on the assumption that, if some of them honk 	 * nonzero bits, they must know what they are doing. Check for 	 * prefer and pps peers at any stratum. Note that the head of 	 * the list is at the lowest stratum and that unsynchronized 	 * peers cannot survive this far. 	 */
name|leap_next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
name|sys_survivors
operator|++
expr_stmt|;
name|leap_next
operator||=
name|peer
operator|->
name|leap
expr_stmt|;
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYNCCAND
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
name|sys_prefer
operator|=
name|peer
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|osys_peer
condition|)
name|typesystem
operator|=
name|peer
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|peer
operator|->
name|refclktype
operator|==
name|REFCLK_ATOM_PPS
condition|)
name|sys_pps
operator|=
name|peer
expr_stmt|;
endif|#
directive|endif
comment|/* REFCLOCK */
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"cluster: survivor %s metric %.6f\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|synch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Anticlockhop provision. Keep the current system peer if it is 	 * a survivor but not first in the list. But do that only HOPPER 	 * times. 	 */
if|if
condition|(
name|osys_peer
operator|==
name|NULL
operator|||
name|typesystem
operator|==
name|NULL
operator|||
name|typesystem
operator|==
name|peer_list
index|[
literal|0
index|]
operator|||
name|sys_hopper
operator|>
name|sys_maxhop
condition|)
block|{
name|typesystem
operator|=
name|peer_list
index|[
literal|0
index|]
expr_stmt|;
name|sys_hopper
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|selbroken
operator|++
expr_stmt|;
block|}
comment|/* 	 * Mitigation rules of the game. There are several types of 	 * peers that can be selected here: (1) orphan, (2) prefer peer 	 * (flag FLAG_PREFER) (3) pps peers (type REFCLK_ATOM_PPS), (4) 	 * the existing system peer, if any, and (5) the head of the 	 * survivor list. 	 */
if|if
condition|(
name|typesystem
operator|->
name|stratum
operator|>=
name|sys_orphan
condition|)
block|{
comment|/* 		 * If in orphan mode, choose the system peer. If the 		 * lowest distance, we are the orphan parent and the 		 * offset is zero. 		 */
name|sys_peer
operator|=
name|typesystem
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
if|if
condition|(
name|sys_orphandelay
operator|<
name|sys_peer
operator|->
name|rootdelay
condition|)
block|{
name|sys_offset
operator|=
literal|0
expr_stmt|;
name|sys_refid
operator|=
name|htonl
argument_list|(
name|LOOPBACKADR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
name|sys_refid
operator|=
name|addr2refid
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
block|}
name|sys_jitter
operator|=
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: orphan offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|sys_prefer
condition|)
block|{
comment|/* 		 * If a pps peer is present, choose it; otherwise, 		 * choose the prefer peer. 		 */
if|if
condition|(
name|sys_pps
condition|)
block|{
name|sys_peer
operator|=
name|sys_pps
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_PPS
expr_stmt|;
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|pps_control
condition|)
name|NLOG
argument_list|(
argument|NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"pps sync enabled"
argument_list|)
expr_stmt|;
name|pps_control
operator|=
name|current_time
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: pps offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|sys_peer
operator|=
name|sys_prefer
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: prefer offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sys_peer
operator|->
name|stratum
operator|==
name|STRATUM_REFCLOCK
operator|||
name|sys_peer
operator|->
name|stratum
operator|==
name|STRATUM_UNSPEC
condition|)
name|sys_refid
operator|=
name|sys_peer
operator|->
name|refid
expr_stmt|;
else|else
name|sys_refid
operator|=
name|addr2refid
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|sys_jitter
operator|=
name|sys_peer
operator|->
name|jitter
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, choose the anticlockhopper. 		 */
name|sys_peer
operator|=
name|typesystem
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
name|clock_combine
argument_list|(
name|peer_list
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_peer
operator|->
name|stratum
operator|==
name|STRATUM_REFCLOCK
operator|||
name|sys_peer
operator|->
name|stratum
operator|==
name|STRATUM_UNSPEC
condition|)
name|sys_refid
operator|=
name|sys_peer
operator|->
name|refid
expr_stmt|;
else|else
name|sys_refid
operator|=
name|addr2refid
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|sys_jitter
operator|=
name|SQRT
argument_list|(
name|SQUARE
argument_list|(
name|sys_peer
operator|->
name|jitter
argument_list|)
operator|+
name|SQUARE
argument_list|(
name|sys_jitter
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: combine offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * We have found the alpha male. 	 */
name|sys_peer
operator|->
name|flags
operator||=
name|FLAG_SYSPEER
expr_stmt|;
if|if
condition|(
name|osys_peer
operator|!=
name|sys_peer
condition|)
block|{
name|char
modifier|*
name|src
decl_stmt|;
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|sys_peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|src
operator|=
name|refnumtoa
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* REFCLOCK */
name|src
operator|=
name|ntoa
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYNCSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"synchronized to %s, stratum %d"
argument_list|,
name|src
argument_list|,
name|sys_peer
operator|->
name|stratum
argument_list|)
expr_stmt|;
block|}
name|clock_update
argument_list|()
expr_stmt|;
block|}
comment|/*  * clock_combine - compute system offset and jitter from selected peers  */
specifier|static
name|void
name|clock_combine
parameter_list|(
name|struct
name|peer
modifier|*
modifier|*
name|peers
parameter_list|,
comment|/* survivor list */
name|int
name|npeers
comment|/* number of survivors */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
name|w
decl_stmt|;
name|y
operator|=
name|z
operator|=
name|w
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npeers
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|root_distance
argument_list|(
name|peers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|y
operator|+=
literal|1.
operator|/
name|x
expr_stmt|;
name|z
operator|+=
name|peers
index|[
name|i
index|]
operator|->
name|offset
operator|/
name|x
expr_stmt|;
name|w
operator|+=
name|SQUARE
argument_list|(
name|peers
index|[
name|i
index|]
operator|->
name|offset
operator|-
name|peers
index|[
literal|0
index|]
operator|->
name|offset
argument_list|)
operator|/
name|x
expr_stmt|;
block|}
name|sys_offset
operator|=
name|z
operator|/
name|y
expr_stmt|;
name|sys_jitter
operator|=
name|SQRT
argument_list|(
name|w
operator|/
name|y
argument_list|)
expr_stmt|;
block|}
comment|/*  * root_distance - compute synchronization distance from peer to root  */
specifier|static
name|double
name|root_distance
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|double
name|dist
decl_stmt|;
comment|/* 	 * Careful squeak here. The value returned must be greater than 	 * the minimum root dispersion in order to avoid clockhop with 	 * highly precise reference clocks. In orphan mode lose the peer 	 * root delay, as that is used by the election algorithm. 	 */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>=
name|sys_orphan
condition|)
name|dist
operator|=
literal|0
expr_stmt|;
else|else
name|dist
operator|=
name|peer
operator|->
name|rootdelay
expr_stmt|;
name|dist
operator|+=
name|max
argument_list|(
name|sys_mindisp
argument_list|,
name|dist
operator|+
name|peer
operator|->
name|delay
argument_list|)
operator|/
literal|2
operator|+
name|peer
operator|->
name|rootdispersion
operator|+
name|peer
operator|->
name|disp
operator|+
name|clock_phi
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
operator|+
name|peer
operator|->
name|jitter
expr_stmt|;
return|return
operator|(
name|dist
operator|)
return|;
block|}
comment|/*  * peer_xmit - send packet for persistent association.  */
specifier|static
name|void
name|peer_xmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* transmit packet */
name|int
name|sendlen
decl_stmt|,
name|authlen
decl_stmt|;
name|keyid_t
name|xkeyid
init|=
literal|0
decl_stmt|;
comment|/* transmit key ID */
name|l_fp
name|xmt_tx
decl_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|dstadr
condition|)
comment|/* don't bother with peers without interface */
return|return;
comment|/* 	 * This is deliciously complicated. There are three cases. 	 * 	 * case		leap	stratum	refid	delay	dispersion 	 * 	 * normal	system	system	system	system	system 	 * orphan child	00	orphan	system	orphan	system 	 * orphan parent 00	orphan	loopbk	0	0 	 */
comment|/* 	 * This is a normal packet. Use the system variables. 	 */
if|if
condition|(
name|sys_stratum
operator|<
name|sys_orphan
condition|)
block|{
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|peer
operator|->
name|version
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This is a orphan child packet. The host is synchronized to an 	 * orphan parent. Show leap synchronized, orphan stratum, system 	 * reference ID, orphan root delay and system root dispersion. 	 */
block|}
elseif|else
if|if
condition|(
name|sys_peer
operator|!=
name|NULL
condition|)
block|{
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOWARNING
argument_list|,
name|peer
operator|->
name|version
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_orphan
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|htonl
argument_list|(
name|LOOPBACKADR
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_orphandelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This is an orphan parent. Show leap synchronized, orphan 	 * stratum, loopack reference ID and zero root delay and root 	 * dispersion. 	 */
block|}
else|else
block|{
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOWARNING
argument_list|,
name|peer
operator|->
name|version
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_orphan
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
literal|0
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
literal|0
expr_stmt|;
block|}
name|xpkt
operator|.
name|ppoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|rec
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * If the received packet contains a MAC, the transmitted packet 	 * is authenticated and contains a MAC. If not, the transmitted 	 * packet is not authenticated. 	 * 	 * It is most important when autokey is in use that the local 	 * interface IP address be known before the first packet is 	 * sent. Otherwise, it is not possible to compute a correct MAC 	 * the recipient will accept. Thus, the I/O semantics have to do 	 * a little more work. In particular, the wildcard interface 	 * might not be usable. 	 */
name|sendlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|)
condition|)
block|{
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|,
name|sys_ttl
index|[
name|peer
operator|->
name|ttl
index|]
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d\n"
argument_list|,
name|current_time
argument_list|,
name|peer
operator|->
name|dstadr
condition|?
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
else|:
literal|"-"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The received packet contains a MAC, so the transmitted packet 	 * must be authenticated. If autokey is enabled, fuss with the 	 * various modes; otherwise, symmetric key cryptography is used. 	 */
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|crypto_flags
operator|&&
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
operator|)
condition|)
block|{
name|struct
name|exten
modifier|*
name|exten
decl_stmt|;
comment|/* extension field */
comment|/* 		 * The Public Key Dance (PKD): Cryptographic credentials 		 * are contained in extension fields, each including a 		 * 4-octet length/code word followed by a 4-octet 		 * association ID and optional additional data. Optional 		 * data includes a 4-octet data length field followed by 		 * the data itself. Request messages are sent from a 		 * configured association; response messages can be sent 		 * from a configured association or can take the fast 		 * path without ever matching an association. Response 		 * messages have the same code as the request, but have 		 * a response bit and possibly an error bit set. In this 		 * implementation, a message may contain no more than 		 * one command and no more than one response. 		 * 		 * Cryptographic session keys include both a public and 		 * a private componet. Request and response messages 		 * using extension fields are always sent with the 		 * private component set to zero. Packets without 		 * extension fields indlude the private component when 		 * the session key is generated. 		 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 			 * Allocate and initialize a keylist if not 			 * already done. Then, use the list in inverse 			 * order, discarding keys once used. Keep the 			 * latest key around until the next one, so 			 * clients can use client/server packets to 			 * compute propagation delay. 			 * 			 * Note that once a key is used from the list, 			 * it is retained in the key cache until the 			 * next key is used. This is to allow a client 			 * to retrieve the encrypted session key 			 * identifier to verify authenticity. 			 * 			 * If for some reason a key is no longer in the 			 * key cache, a birthday has happened and the 			 * pseudo-random sequence is probably broken. In 			 * that case, purge the keylist and regenerate 			 * it. 			 */
if|if
condition|(
name|peer
operator|->
name|keynumber
operator|==
literal|0
condition|)
name|make_keylist
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|keynumber
operator|--
expr_stmt|;
name|xkeyid
operator|=
name|peer
operator|->
name|keylist
index|[
name|peer
operator|->
name|keynumber
index|]
expr_stmt|;
if|if
condition|(
name|authistrusted
argument_list|(
name|xkeyid
argument_list|)
condition|)
break|break;
else|else
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|keyid
operator|=
name|xkeyid
expr_stmt|;
name|exten
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|peer
operator|->
name|hmode
condition|)
block|{
comment|/* 			 * In broadcast server mode the autokey values are 			 * required by the broadcast clients. Push them when a 			 * new keylist is generated; otherwise, push the 			 * association message so the client can request them at 			 * other times. 			 */
case|case
name|MODE_BROADCAST
case|:
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_ASSOC
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_ASSOC
operator||
name|CRYPTO_RESP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * In symmetric modes the digest, certificate, agreement 		 * parameters, cookie and autokey values are required. 		 * The leapsecond table is optional. But, a passive peer 		 * will not believe the active peer until the latter has 		 * synchronized, so the agreement must be postponed 		 * until then. In any case, if a new keylist is 		 * generated, the autokey values are pushed. 		 * 		 * If the crypto bit is lit, don't send requests. 		 */
case|case
name|MODE_ACTIVE
case|:
case|case
name|MODE_PASSIVE
case|:
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|TEST9
condition|)
break|break;
comment|/* 			 * Parameter and certificate. 			 */
if|if
condition|(
operator|!
name|peer
operator|->
name|crypto
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_ASSOC
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VALID
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_CERT
argument_list|,
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
comment|/* 			 * Identity. Note we have to sign the 			 * certificate before the cookie to avoid a 			 * deadlock when the passive peer is walking the 			 * certificate trail. Awesome. 			 */
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|crypto_ident
argument_list|(
name|peer
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_SIGN
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_SIGN
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
comment|/* 			 * Autokey. We request the cookie only when the 			 * server and client are synchronized and 			 * signatures work both ways. On the other hand, 			 * the active peer needs the autokey values 			 * before then and when the passive peer is 			 * waiting for the active peer to synchronize. 			 * Any time we regenerate the key list, we offer 			 * the autokey values without being asked. 			 */
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
name|peer
operator|->
name|leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AGREE
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_COOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_ASSOC
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AUTO
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Postamble. We trade leapseconds only when the 			 * server and client are synchronized. 			 */
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
name|peer
operator|->
name|leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_TAI
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_LEAP
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_TAI
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * In client mode the digest, certificate, agreement 		 * parameters and cookie are required. The leapsecond 		 * table is optional. If broadcast client mode, the 		 * autokey values are required as well. In broadcast 		 * client mode, these values must be acquired during the 		 * client/server exchange to avoid having to wait until 		 * the next key list regeneration. Otherwise, the poor 		 * dude may die a lingering death until becoming 		 * unreachable and attempting rebirth. 		 * 		 * If neither the server or client have the agreement 		 * parameters, the protocol transmits the cookie in the 		 * clear. If the server has the parameters, the client 		 * requests them and the protocol blinds it using the 		 * agreed key. It is a protocol error if the client has 		 * the parameters but the server does not. 		 * 		 * If the crypto bit is lit, don't send requests. 		 */
case|case
name|MODE_CLIENT
case|:
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|TEST9
condition|)
break|break;
comment|/* 			 * Parameter and certificate. 			 */
if|if
condition|(
operator|!
name|peer
operator|->
name|crypto
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_ASSOC
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VALID
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_CERT
argument_list|,
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
comment|/* 			 * Identity 			 */
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|crypto_ident
argument_list|(
name|peer
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Autokey 			 */
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AGREE
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_COOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AUTO
operator|)
operator|&&
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Postamble. We can sign the certificate here, 			 * since there is no chance of deadlock. 			 */
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_SIGN
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_SIGN
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_TAI
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_LEAP
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_TAI
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Build the extension fields as directed. A response to 		 * a request is always sent, even if an error. If an 		 * error occurs when sending a request, the crypto 		 * machinery broke or was misconfigured. In that case 		 * light the crypto bit to suppress further requests. 		 */
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
condition|)
block|{
name|peer
operator|->
name|cmmd
operator|->
name|associd
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|&
name|xpkt
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|sendlen
argument_list|,
name|peer
operator|->
name|cmmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|cmmd
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|exten
operator|!=
name|NULL
condition|)
block|{
name|int
name|ltemp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exten
operator|->
name|opcode
operator|!=
literal|0
condition|)
block|{
name|ltemp
operator|=
name|crypto_xmit
argument_list|(
operator|&
name|xpkt
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|sendlen
argument_list|,
name|exten
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltemp
operator|==
literal|0
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST9
expr_stmt|;
comment|/* crypto error */
name|free
argument_list|(
name|exten
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|sendlen
operator|+=
name|ltemp
expr_stmt|;
name|free
argument_list|(
name|exten
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If extension fields are present, we must use a 		 * private cookie value of zero. Don't send if the 		 * crypto bit is set and no extension field is present, 		 * but in that case give back the key. Most intricate. 		 */
if|if
condition|(
name|sendlen
operator|>
name|LEN_PKT_NOMAC
condition|)
block|{
name|session_key
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|xkeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|TEST9
condition|)
block|{
name|authtrust
argument_list|(
name|xkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * Stash the transmit timestamp corrected for the encryption 	 * delay. If autokey, give back the key, as we use keys only 	 * once. Check for errors such as missing keys, buffer overflow, 	 * etc. 	 */
name|xkeyid
operator|=
name|peer
operator|->
name|keyid
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|authlen
operator|=
name|authencrypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|authlen
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"transmit: %s key %u not found"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|xkeyid
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST9
expr_stmt|;
comment|/* no key found */
return|return;
block|}
name|sendlen
operator|+=
name|authlen
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|xkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendlen
operator|>
sizeof|sizeof
argument_list|(
name|xpkt
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"buffer overflow %u"
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sendpkt
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|,
name|sys_ttl
index|[
name|peer
operator|->
name|ttl
index|]
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the encryption delay. Keep the minimum over 	 * the latest two samples. 	 */
name|L_SUB
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|1
index|]
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|xmt_tx
operator|.
name|l_uf
expr_stmt|;
if|if
condition|(
name|sys_authdly
index|[
literal|0
index|]
operator|<
name|sys_authdly
index|[
literal|1
index|]
condition|)
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|1
index|]
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d mac %d index %d\n"
argument_list|,
name|current_time
argument_list|,
name|peer
operator|->
name|dstadr
condition|?
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
else|:
literal|"-"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
operator|-
name|authlen
argument_list|,
name|authlen
argument_list|,
name|peer
operator|->
name|keynumber
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d mac %d\n"
argument_list|,
name|current_time
argument_list|,
name|peer
operator|->
name|dstadr
condition|?
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
else|:
literal|"-"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
operator|-
name|authlen
argument_list|,
name|authlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* OPENSSL */
block|}
comment|/*  * fast_xmit - Send packet for nonpersistent association. Note that  * neither the source or destination can be a broadcast address.  */
specifier|static
name|void
name|fast_xmit
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
comment|/* receive packet pointer */
name|int
name|xmode
parameter_list|,
comment|/* transmit mode */
name|keyid_t
name|xkeyid
parameter_list|,
comment|/* transmit key ID */
name|int
name|mask
comment|/* restrict mask */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* transmit packet structure */
name|struct
name|pkt
modifier|*
name|rpkt
decl_stmt|;
comment|/* receive packet structure */
name|l_fp
name|xmt_ts
decl_stmt|;
comment|/* timestamp */
name|l_fp
name|xmt_tx
decl_stmt|;
comment|/* timestamp after authent */
name|int
name|sendlen
decl_stmt|,
name|authlen
decl_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|u_int32
name|temp32
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize transmit packet header fields from the receive 	 * buffer provided. We leave some fields intact as received. If 	 * the gazinta was from a multicast address, the gazoutta must 	 * go out another way. 	 * 	 * The root delay field is special. If the system stratum is 	 * less than the orphan stratum, send the real root delay. 	 * Otherwise, if there is no system peer, send the orphan delay. 	 * Otherwise, we must be an orphan parent, so send zero. 	 */
name|rpkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MCASTOPEN
condition|)
name|rbufp
operator|->
name|dstadr
operator|=
name|findinterface
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
comment|/* 	 * This is deliciously complicated. There are four cases. 	 * 	 * case		leap	stratum	refid	delay	dispersion 	 * 	 * KoD		11	16	KISS	system	system 	 * normal	system	system	system	system	system 	 * orphan child	00	orphan	system	orphan	system 	 * orphan parent 00	orphan	loopbk	0	0 	 */
comment|/* 	 * This is a kiss-of-death (KoD) packet. Show leap 	 * unsynchronized, stratum zero, reference ID the four-character 	 * kiss code and system root delay. Note the rate limit on these 	 * packets. Once a second initialize a bucket counter. Every 	 * packet sent decrements the counter until reaching zero. If 	 * the counter is zero, drop the kiss. 	 */
if|if
condition|(
name|mask
operator|&
name|RES_LIMITED
condition|)
block|{
name|sys_limitrejected
operator|++
expr_stmt|;
if|if
condition|(
name|sys_kod
operator|==
literal|0
operator|||
operator|!
operator|(
name|mask
operator|&
name|RES_DEMOBILIZE
operator|)
condition|)
return|return;
name|sys_kod
operator|--
expr_stmt|;
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOTINSYNC
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|xpkt
operator|.
name|refid
argument_list|,
literal|"RATE"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This is a normal packet. Use the system variables. 	 */
block|}
elseif|else
if|if
condition|(
name|sys_stratum
operator|<
name|sys_orphan
condition|)
block|{
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This is a orphan child packet. The host is synchronized to an 	 * orphan parent. Show leap synchronized, orphan stratum, system 	 * reference ID and orphan root delay. 	 */
block|}
elseif|else
if|if
condition|(
name|sys_peer
operator|!=
name|NULL
condition|)
block|{
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOWARNING
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_orphan
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_orphandelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This is an orphan parent. Show leap synchronized, orphan 	 * stratum, loopack reference ID and zero root delay. 	 */
block|}
else|else
block|{
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOWARNING
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_orphan
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|htonl
argument_list|(
name|LOOPBACKADR
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xpkt
operator|.
name|ppoll
operator|=
name|rpkt
operator|->
name|ppoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|org
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * If the received packet contains a MAC, the transmitted packet 	 * is authenticated and contains a MAC. If not, the transmitted 	 * packet is not authenticated. 	 */
name|sendlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|==
name|sendlen
condition|)
block|{
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
literal|0
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The received packet contains a MAC, so the transmitted packet 	 * must be authenticated. For symmetric key cryptography, use 	 * the predefined and trusted symmetric keys to generate the 	 * cryptosum. For autokey cryptography, use the server private 	 * value to generate the cookie, which is unique for every 	 * source-destination-key ID combination. 	 */
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|keyid_t
name|cookie
decl_stmt|;
comment|/* 		 * The only way to get here is a reply to a legitimate 		 * client request message, so the mode must be 		 * MODE_SERVER. If an extension field is present, there 		 * can be only one and that must be a command. Do what 		 * needs, but with private value of zero so the poor 		 * jerk can decode it. If no extension field is present, 		 * use the cookie to generate the session key. 		 */
name|cookie
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
literal|0
argument_list|,
name|sys_private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>=
call|(
name|int
call|)
argument_list|(
name|sendlen
operator|+
name|MAX_MAC_LEN
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
argument_list|)
condition|)
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|xkeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|temp32
operator|=
name|CRYPTO_RESP
expr_stmt|;
name|rpkt
operator|->
name|exten
index|[
literal|0
index|]
operator||=
name|htonl
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|&
name|xpkt
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|sendlen
argument_list|,
operator|(
expr|struct
name|exten
operator|*
operator|)
name|rpkt
operator|->
name|exten
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|xkeyid
argument_list|,
name|cookie
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL */
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|authlen
operator|=
name|authencrypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|authlen
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|xkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendlen
operator|>
sizeof|sizeof
argument_list|(
name|xpkt
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"buffer overflow %u"
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
literal|0
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the encryption delay. Keep the minimum over the 	 * latest two samples. 	 */
name|L_SUB
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|1
index|]
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|xmt_tx
operator|.
name|l_uf
expr_stmt|;
if|if
condition|(
name|sys_authdly
index|[
literal|0
index|]
operator|<
name|sys_authdly
index|[
literal|1
index|]
condition|)
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d mac %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|xmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
operator|-
name|authlen
argument_list|,
name|authlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OPENSSL
comment|/*  * key_expire - purge the key list  */
name|void
name|key_expire
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|keylist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|peer
operator|->
name|keynumber
condition|;
name|i
operator|++
control|)
name|authtrust
argument_list|(
name|peer
operator|->
name|keylist
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|keylist
argument_list|)
expr_stmt|;
name|peer
operator|->
name|keylist
operator|=
name|NULL
expr_stmt|;
block|}
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|sndval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|keynumber
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"key_expire: at %lu\n"
argument_list|,
name|current_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/*  * Determine if the peer is unfit for synchronization  *  * A peer is unfit for synchronization if  *> TEST10 bad leap or stratum below floor or at or above ceiling  *> TEST11 root distance exceeded  *> TEST12 a direct or indirect synchronization loop would form  *> TEST13 unreachable or noselect  */
name|int
comment|/* FALSE if fit, TRUE if unfit */
name|peer_unfit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
comment|/* 	 * A stratum error occurs if (1) the server has never been 	 * synchronized, (2) the server stratum is below the floor or 	 * greater than or equal to the ceiling, (3) the system stratum 	 * is below the orphan stratum and the server stratum is greater 	 * than or equal to the orphan stratum. 	 */
if|if
condition|(
name|peer
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
operator|||
name|peer
operator|->
name|stratum
operator|<
name|sys_floor
operator|||
name|peer
operator|->
name|stratum
operator|>=
name|sys_ceiling
operator|||
operator|(
name|sys_stratum
operator|<
name|sys_orphan
operator|&&
name|peer
operator|->
name|stratum
operator|>=
name|sys_orphan
operator|)
condition|)
name|rval
operator||=
name|TEST10
expr_stmt|;
comment|/* stratum out of bounds */
comment|/* 	 * A distance error occurs if the root distance is greater than 	 * or equal to the distance threshold plus the increment due to 	 * one poll interval. 	 */
if|if
condition|(
name|root_distance
argument_list|(
name|peer
argument_list|)
operator|>=
name|sys_maxdist
operator|+
name|clock_phi
operator|*
name|ULOGTOD
argument_list|(
name|sys_poll
argument_list|)
condition|)
name|rval
operator||=
name|TEST11
expr_stmt|;
comment|/* distance exceeded */
comment|/* 	 * A loop error occurs if the remote peer is synchronized to the 	 * local peer of if the remote peer is synchronized to the same 	 * server as the local peer, but only if the remote peer is not 	 * the orphan parent. 	 */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>
literal|1
operator|&&
name|peer
operator|->
name|refid
operator|!=
name|htonl
argument_list|(
name|LOOPBACKADR
argument_list|)
operator|&&
operator|(
operator|(
operator|!
name|peer
operator|->
name|dstadr
operator|||
name|peer
operator|->
name|refid
operator|==
name|peer
operator|->
name|dstadr
operator|->
name|addr_refid
operator|)
operator|||
name|peer
operator|->
name|refid
operator|==
name|sys_refid
operator|)
condition|)
name|rval
operator||=
name|TEST12
expr_stmt|;
comment|/* synch loop */
comment|/* 	 * An unreachable error occurs if the server is unreachable or 	 * the noselect bit is set. 	 */
if|if
condition|(
operator|!
name|peer
operator|->
name|reach
operator|||
name|peer
operator|->
name|flags
operator|&
name|FLAG_NOSELECT
condition|)
name|rval
operator||=
name|TEST13
expr_stmt|;
comment|/* unreachable */
name|peer
operator|->
name|flash
operator|&=
operator|~
name|PEER_TEST_MASK
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|rval
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
comment|/*  * Find the precision of this particular machine  */
define|#
directive|define
name|MINSTEP
value|100e-9
comment|/* minimum clock increment (s) */
define|#
directive|define
name|MAXSTEP
value|20e-3
comment|/* maximum clock increment (s) */
define|#
directive|define
name|MINLOOPS
value|5
comment|/* minimum number of step samples */
comment|/*  * This routine calculates the system precision, defined as the minimum  * of a sequence of differences between successive readings of the  * system clock. However, if the system clock can be read more than once  * during a tick interval, the difference can be zero or one LSB unit,  * where the LSB corresponds to one nanosecond or one microsecond.  * Conceivably, if some other process preempts this one and reads the  * clock, the difference can be more than one LSB unit.  *  * For hardware clock frequencies of 10 MHz or less, we assume the  * logical clock advances only at the hardware clock tick. For higher  * frequencies, we assume the logical clock can advance no more than 100  * nanoseconds between ticks.  */
name|int
name|default_get_precision
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|val
decl_stmt|;
comment|/* current seconds fraction */
name|l_fp
name|last
decl_stmt|;
comment|/* last seconds fraction */
name|l_fp
name|diff
decl_stmt|;
comment|/* difference */
name|double
name|tick
decl_stmt|;
comment|/* computed tick value */
name|double
name|dtemp
decl_stmt|;
comment|/* scratch */
name|int
name|i
decl_stmt|;
comment|/* log2 precision */
comment|/* 	 * Loop to find tick value in nanoseconds. Toss out outlyer 	 * values less than the minimun tick value. In wacky cases, use 	 * the default maximum value. 	 */
name|get_systime
argument_list|(
operator|&
name|last
argument_list|)
expr_stmt|;
name|tick
operator|=
name|MAXSTEP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MINLOOPS
condition|;
control|)
block|{
name|get_systime
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
name|diff
operator|=
name|val
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
name|val
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|diff
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
name|MINSTEP
condition|)
continue|continue;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
name|tick
condition|)
name|tick
operator|=
name|dtemp
expr_stmt|;
block|}
comment|/* 	 * Find the nearest power of two. 	 */
name|NLOG
argument_list|(
argument|NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"precision = %.3f usec"
argument_list|,
name|tick
operator|*
literal|1e6
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tick
operator|<=
literal|1
condition|;
name|i
operator|++
control|)
name|tick
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|tick
operator|-
literal|1.
operator|>
literal|1.
operator|-
name|tick
operator|/
literal|2
condition|)
name|i
operator|--
expr_stmt|;
return|return
operator|(
operator|-
name|i
operator|)
return|;
block|}
comment|/*  * kod_proto - called once per second to limit kiss-of-death packets  */
name|void
name|kod_proto
parameter_list|(
name|void
parameter_list|)
block|{
name|sys_kod
operator|=
name|sys_kod_rate
expr_stmt|;
block|}
comment|/*  * init_proto - initialize the protocol module's data  */
name|void
name|init_proto
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|dummy
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Fill in the sys_* stuff.  Default is don't listen to 	 * broadcasting, authenticate. 	 */
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"INIT"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sys_precision
operator|=
operator|(
name|s_char
operator|)
name|default_get_precision
argument_list|()
expr_stmt|;
name|sys_jitter
operator|=
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_orphandelay
operator|=
call|(
name|double
call|)
argument_list|(
name|ntp_random
argument_list|()
operator|&
literal|0xffff
argument_list|)
operator|/
literal|65536.
operator|*
name|sys_maxdist
expr_stmt|;
name|sys_rootdispersion
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_reftime
argument_list|)
expr_stmt|;
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|sys_survivors
operator|=
literal|0
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|sys_manycastserver
operator|=
literal|0
expr_stmt|;
name|sys_bclient
operator|=
literal|0
expr_stmt|;
name|sys_bdelay
operator|=
name|DEFBROADDELAY
expr_stmt|;
name|sys_calldelay
operator|=
name|BURST_DELAY
expr_stmt|;
name|sys_authenticate
operator|=
literal|1
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|sys_authdly
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sys_stattime
operator|=
literal|0
expr_stmt|;
name|proto_clr_stats
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TTL
condition|;
name|i
operator|++
control|)
block|{
name|sys_ttl
index|[
name|i
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|i
operator|*
literal|256
operator|)
operator|/
name|MAX_TTL
argument_list|)
expr_stmt|;
name|sys_ttlmax
operator|=
name|i
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL
name|sys_automax
operator|=
literal|1
operator|<<
name|NTP_AUTOMAX
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * Default these to enable 	 */
name|ntp_enable
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|KERNEL_FLL_BUG
name|kern_enable
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|pps_enable
operator|=
literal|0
expr_stmt|;
name|stats_control
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  * proto_config - configure the protocol module  */
name|void
name|proto_config
parameter_list|(
name|int
name|item
parameter_list|,
name|u_long
name|value
parameter_list|,
name|double
name|dvalue
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|svalue
parameter_list|)
block|{
comment|/* 	 * Figure out what he wants to change, then do it 	 */
switch|switch
condition|(
name|item
condition|)
block|{
comment|/* 	 * Turn on/off kernel discipline. 	 */
case|case
name|PROTO_KERNEL
case|:
name|kern_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off clock discipline. 	 */
case|case
name|PROTO_NTP
case|:
name|ntp_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off monitoring. 	 */
case|case
name|PROTO_MONITOR
case|:
if|if
condition|(
name|value
condition|)
name|mon_start
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
else|else
name|mon_stop
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off statistics. 	 */
case|case
name|PROTO_FILEGEN
case|:
name|stats_control
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off enable broadcasts. 	 */
case|case
name|PROTO_BROADCLIENT
case|:
name|sys_bclient
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|sys_bclient
operator|==
literal|0
condition|)
name|io_unsetbclient
argument_list|()
expr_stmt|;
else|else
name|io_setbclient
argument_list|()
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off PPS discipline. 	 */
case|case
name|PROTO_PPS
case|:
name|pps_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Add muliticast group address. 	 */
case|case
name|PROTO_MULTICAST_ADD
case|:
if|if
condition|(
name|svalue
condition|)
name|io_multicast_add
argument_list|(
operator|*
name|svalue
argument_list|)
expr_stmt|;
name|sys_bclient
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 	 * Delete multicast group address. 	 */
case|case
name|PROTO_MULTICAST_DEL
case|:
if|if
condition|(
name|svalue
condition|)
name|io_multicast_del
argument_list|(
operator|*
name|svalue
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set default broadcast delay. 	 */
case|case
name|PROTO_BROADDELAY
case|:
name|sys_bdelay
operator|=
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set modem call delay. 	 */
case|case
name|PROTO_CALLDELAY
case|:
name|sys_calldelay
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off authentication to mobilize ephemeral 	 * associations. 	 */
case|case
name|PROTO_AUTHENTICATE
case|:
name|sys_authenticate
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Set minimum number of survivors. 	 */
case|case
name|PROTO_MINCLOCK
case|:
name|sys_minclock
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set maximum number of preemptable associations. 	 */
case|case
name|PROTO_MAXCLOCK
case|:
name|sys_maxclock
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set minimum number of survivors. 	 */
case|case
name|PROTO_MINSANE
case|:
name|sys_minsane
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set stratum floor. 	 */
case|case
name|PROTO_FLOOR
case|:
name|sys_floor
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set stratum ceiling. 	 */
case|case
name|PROTO_CEILING
case|:
name|sys_ceiling
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set orphan stratum. 	 */
case|case
name|PROTO_ORPHAN
case|:
name|sys_orphan
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set cohort switch. 	 */
case|case
name|PROTO_COHORT
case|:
name|sys_cohort
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set minimum dispersion increment. 	 */
case|case
name|PROTO_MINDISP
case|:
name|sys_mindisp
operator|=
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set maximum distance (select threshold). 	 */
case|case
name|PROTO_MAXDIST
case|:
name|sys_maxdist
operator|=
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set anticlockhop threshold. 	 */
case|case
name|PROTO_MAXHOP
case|:
name|sys_maxhop
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set adjtime() resolution (s). 	 */
case|case
name|PROTO_ADJ
case|:
name|sys_tick
operator|=
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set manycast beacon interval. 	 */
case|case
name|PROTO_BEACON
case|:
name|sys_beacon
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 	 * Turn on/off refclock calibrate 	 */
case|case
name|PROTO_CAL
case|:
name|cal_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* REFCLOCK */
default|default:
comment|/* 		 * Log this error. 		 */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"proto_config: illegal item %d, value %ld"
argument_list|,
name|item
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * proto_clr_stats - clear protocol stat counters  */
name|void
name|proto_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|sys_stattime
operator|=
name|current_time
expr_stmt|;
name|sys_received
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_newversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_oldversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_unknownversion
operator|=
literal|0
expr_stmt|;
name|sys_restricted
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
name|sys_limitrejected
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

