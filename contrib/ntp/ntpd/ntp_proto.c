begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_proto.c - NTP version 4 protocol machinery  *  * ATTENTION: Get approval from Dave Mills on all changes to this file!  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_leapsec.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBSCF_H
end_ifdef

begin_include
include|#
directive|include
file|<libscf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This macro defines the authentication state. If x is 1 authentication  * is required; othewise it is optional.  */
end_comment

begin_define
define|#
directive|define
name|AUTH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) ? (y) == AUTH_OK : (y) == AUTH_OK || \ 			    (y) == AUTH_NONE)
end_define

begin_define
define|#
directive|define
name|AUTH_NONE
value|0
end_define

begin_comment
comment|/* authentication not required */
end_comment

begin_define
define|#
directive|define
name|AUTH_OK
value|1
end_define

begin_comment
comment|/* authentication OK */
end_comment

begin_define
define|#
directive|define
name|AUTH_ERROR
value|2
end_define

begin_comment
comment|/* authentication error */
end_comment

begin_define
define|#
directive|define
name|AUTH_CRYPTO
value|3
end_define

begin_comment
comment|/* crypto_NAK */
end_comment

begin_comment
comment|/*  * traffic shaping parameters  */
end_comment

begin_define
define|#
directive|define
name|NTP_IBURST
value|6
end_define

begin_comment
comment|/* packets in iburst */
end_comment

begin_define
define|#
directive|define
name|RESP_DELAY
value|1
end_define

begin_comment
comment|/* refclock burst delay (s) */
end_comment

begin_comment
comment|/*  * pool soliciting restriction duration (s)  */
end_comment

begin_define
define|#
directive|define
name|POOL_SOLICIT_WINDOW
value|8
end_define

begin_comment
comment|/*  * peer_select groups statistics for a peer used by clock_select() and  * clock_cluster().  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|peer_select_tag
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|double
name|synch
decl_stmt|;
comment|/* sync distance */
name|double
name|error
decl_stmt|;
comment|/* jitter */
name|double
name|seljit
decl_stmt|;
comment|/* selection jitter */
block|}
name|peer_select
typedef|;
end_typedef

begin_comment
comment|/*  * System variables are declared here. Unless specified otherwise, all  * times are in seconds.  */
end_comment

begin_decl_stmt
name|u_char
name|sys_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system leap indicator */
end_comment

begin_decl_stmt
name|u_char
name|sys_stratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system stratum */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision (log2 s) */
end_comment

begin_decl_stmt
name|double
name|sys_rootdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* roundtrip delay to primary source */
end_comment

begin_decl_stmt
name|double
name|sys_rootdisp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dispersion to primary source */
end_comment

begin_decl_stmt
name|u_int32
name|sys_refid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference id (network byte order) */
end_comment

begin_decl_stmt
name|l_fp
name|sys_reftime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last update time */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current peer */
end_comment

begin_comment
comment|/*  * Rate controls. Leaky buckets are used to throttle the packet  * transmission rates in order to protect busy servers such as at NIST  * and USNO. There is a counter for each association and another for KoD  * packets. The association counter decrements each second, but not  * below zero. Each time a packet is sent the counter is incremented by  * a configurable value representing the average interval between  * packets. A packet is delayed as long as the counter is greater than  * zero. Note this does not affect the time value computations.  */
end_comment

begin_comment
comment|/*  * Nonspecified system state variables  */
end_comment

begin_decl_stmt
name|int
name|sys_bclient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* broadcast client enable */
end_comment

begin_decl_stmt
name|double
name|sys_bdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* broadcast client default delay */
end_comment

begin_decl_stmt
name|int
name|sys_authenticate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* requre authentication for config */
end_comment

begin_decl_stmt
name|l_fp
name|sys_authdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay */
end_comment

begin_decl_stmt
name|double
name|sys_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current local clock offset */
end_comment

begin_decl_stmt
name|double
name|sys_mindisp
init|=
name|MINDISPERSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum distance (s) */
end_comment

begin_decl_stmt
name|double
name|sys_maxdist
init|=
name|MAXDISTANCE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* selection threshold */
end_comment

begin_decl_stmt
name|double
name|sys_jitter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system jitter */
end_comment

begin_decl_stmt
name|u_long
name|sys_epoch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last clock update time */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_clockhop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clockhop threshold */
end_comment

begin_decl_stmt
specifier|static
name|int
name|leap_vote_ins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* leap consensus for insert */
end_comment

begin_decl_stmt
specifier|static
name|int
name|leap_vote_del
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* leap consensus for delete */
end_comment

begin_decl_stmt
name|keyid_t
name|sys_private
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private value for session seed */
end_comment

begin_decl_stmt
name|int
name|sys_manycastserver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* respond to manycast client pkts */
end_comment

begin_decl_stmt
name|int
name|ntp_mode7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* respond to ntpdc (mode7) */
end_comment

begin_decl_stmt
name|int
name|peer_ntpdate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* active peers in ntpdate mode */
end_comment

begin_decl_stmt
name|int
name|sys_survivors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* truest of the truechimers */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sys_ident
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* identity scheme */
end_comment

begin_comment
comment|/*  * TOS and multicast mapping stuff  */
end_comment

begin_decl_stmt
name|int
name|sys_floor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cluster stratum floor */
end_comment

begin_decl_stmt
name|int
name|sys_ceiling
init|=
name|STRATUM_UNSPEC
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cluster stratum ceiling */
end_comment

begin_decl_stmt
name|int
name|sys_minsane
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum candidates */
end_comment

begin_decl_stmt
name|int
name|sys_minclock
init|=
name|NTP_MINCLOCK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum candidates */
end_comment

begin_decl_stmt
name|int
name|sys_maxclock
init|=
name|NTP_MAXCLOCK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum candidates */
end_comment

begin_decl_stmt
name|int
name|sys_cohort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cohort switch */
end_comment

begin_decl_stmt
name|int
name|sys_orphan
init|=
name|STRATUM_UNSPEC
operator|+
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* orphan stratum */
end_comment

begin_decl_stmt
name|int
name|sys_orphwait
init|=
name|NTP_ORPHWAIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* orphan wait */
end_comment

begin_decl_stmt
name|int
name|sys_beacon
init|=
name|BEACON
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* manycast beacon interval */
end_comment

begin_decl_stmt
name|int
name|sys_ttlmax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max ttl mapping vector index */
end_comment

begin_decl_stmt
name|u_char
name|sys_ttl
index|[
name|MAX_TTL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ttl mapping vector */
end_comment

begin_comment
comment|/*  * Statistics counters - first the good, then the bad  */
end_comment

begin_decl_stmt
name|u_long
name|sys_stattime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* elapsed time */
end_comment

begin_decl_stmt
name|u_long
name|sys_received
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets received */
end_comment

begin_decl_stmt
name|u_long
name|sys_processed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets for this host */
end_comment

begin_decl_stmt
name|u_long
name|sys_newversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current version */
end_comment

begin_decl_stmt
name|u_long
name|sys_oldversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* old version */
end_comment

begin_decl_stmt
name|u_long
name|sys_restricted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* access denied */
end_comment

begin_decl_stmt
name|u_long
name|sys_badlength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bad length or format */
end_comment

begin_decl_stmt
name|u_long
name|sys_badauth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bad authentication */
end_comment

begin_decl_stmt
name|u_long
name|sys_declined
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* declined */
end_comment

begin_decl_stmt
name|u_long
name|sys_limitrejected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rate exceeded */
end_comment

begin_decl_stmt
name|u_long
name|sys_kodsent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* KoD sent */
end_comment

begin_function_decl
specifier|static
name|double
name|root_distance
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clock_combine
parameter_list|(
name|peer_select
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peer_xmit
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fast_xmit
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|keyid_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pool_xmit
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clock_update
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|measure_precision
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|measure_tick_fuzz
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|local_refid
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|peer_unfit
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_function_decl
specifier|static
name|int
name|group_test
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOKEY */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WORKER
end_ifdef

begin_function_decl
name|void
name|pool_name_resolved
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WORKER */
end_comment

begin_comment
comment|/*  * transmit - transmit procedure called by poll timeout  */
end_comment

begin_function
name|void
name|transmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|u_char
name|hpoll
decl_stmt|;
comment|/* 	 * The polling state machine. There are two kinds of machines, 	 * those that never expect a reply (broadcast and manycast 	 * server modes) and those that do (all other modes). The dance 	 * is intricate... 	 */
name|hpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
comment|/* 	 * In broadcast mode the poll interval is never changed from 	 * minpoll. 	 */
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
operator|(
name|MDF_BCAST
operator||
name|MDF_MCAST
operator|)
condition|)
block|{
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * In manycast mode we start with unity ttl. The ttl is 	 * increased by one for each poll until either sys_maxclock 	 * servers have been found or the maximum ttl is reached. When 	 * sys_maxclock servers are found we stop polling until one or 	 * more servers have timed out or until less than sys_minclock 	 * associations turn up. In this case additional better servers 	 * are dragged in and preempt the existing ones.  Once every 	 * sys_beacon seconds we are to transmit unconditionally, but 	 * this code is not quite right -- peer->unreach counts polls 	 * and is being compared with sys_beacon, so the beacons happen 	 * every sys_beacon polls. 	 */
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_ACAST
condition|)
block|{
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|unreach
operator|>
name|sys_beacon
condition|)
block|{
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sys_survivors
operator|<
name|sys_minclock
operator|||
name|peer_associations
operator|<
name|sys_maxclock
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|ttl
operator|<
operator|(
name|u_int32
operator|)
name|sys_ttlmax
condition|)
name|peer
operator|->
name|ttl
operator|++
expr_stmt|;
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|unreach
operator|++
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Pool associations transmit unicast solicitations when there 	 * are less than a hard limit of 2 * sys_maxclock associations, 	 * and either less than sys_minclock survivors or less than 	 * sys_maxclock associations.  The hard limit prevents unbounded 	 * growth in associations if the system clock or network quality 	 * result in survivor count dipping below sys_minclock often. 	 * This was observed testing with pool, where sys_maxclock == 12 	 * resulted in 60 associations without the hard limit.  A 	 * similar hard limit on manycastclient ephemeral associations 	 * may be appropriate. 	 */
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_POOL
condition|)
block|{
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
operator|(
name|peer_associations
operator|<=
literal|2
operator|*
name|sys_maxclock
operator|)
operator|&&
operator|(
name|peer_associations
operator|<
name|sys_maxclock
operator|||
name|sys_survivors
operator|<
name|sys_minclock
operator|)
condition|)
name|pool_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * In unicast modes the dance is much more intricate. It is 	 * designed to back off whenever possible to minimize network 	 * traffic. 	 */
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
name|u_char
name|oreach
decl_stmt|;
comment|/* 		 * Update the reachability status. If not heard for 		 * three consecutive polls, stuff infinity in the clock 		 * filter.  		 */
name|oreach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
name|peer
operator|->
name|unreach
operator|++
expr_stmt|;
name|peer
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|reach
condition|)
block|{
comment|/* 			 * Here the peer is unreachable. If it was 			 * previously reachable raise a trap. Send a 			 * burst if enabled. 			 */
name|clock_filter
argument_list|(
name|peer
argument_list|,
literal|0.
argument_list|,
literal|0.
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oreach
condition|)
block|{
name|peer_unfit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|PEVNT_UNREACH
argument_list|,
name|peer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_IBURST
operator|)
operator|&&
name|peer
operator|->
name|retry
operator|==
literal|0
condition|)
name|peer
operator|->
name|retry
operator|=
name|NTP_RETRY
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Here the peer is reachable. Send a burst if 			 * enabled and the peer is fit.  Reset unreach 			 * for persistent and ephemeral associations. 			 * Unreach is also reset for survivors in 			 * clock_select(). 			 */
name|hpoll
operator|=
name|sys_poll
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREEMPT
operator|)
condition|)
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_BURST
operator|)
operator|&&
name|peer
operator|->
name|retry
operator|==
literal|0
operator|&&
operator|!
name|peer_unfit
argument_list|(
name|peer
argument_list|)
condition|)
name|peer
operator|->
name|retry
operator|=
name|NTP_RETRY
expr_stmt|;
block|}
comment|/* 		 * Watch for timeout.  If ephemeral, toss the rascal; 		 * otherwise, bump the poll interval. Note the 		 * poll_update() routine will clamp it to maxpoll. 		 * If preemptible and we have more peers than maxclock, 		 * and this peer has the minimum score of preemptibles, 		 * demobilize. 		 */
if|if
condition|(
name|peer
operator|->
name|unreach
operator|>=
name|NTP_UNREACH
condition|)
block|{
name|hpoll
operator|++
expr_stmt|;
comment|/* ephemeral: no FLAG_CONFIG nor FLAG_PREEMPT */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
operator|(
name|FLAG_CONFIG
operator||
name|FLAG_PREEMPT
operator|)
operator|)
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_RESTART
argument_list|,
name|peer
argument_list|,
literal|"timeout"
argument_list|)
expr_stmt|;
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"TIME"
argument_list|)
expr_stmt|;
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREEMPT
operator|)
operator|&&
operator|(
name|peer_associations
operator|>
name|sys_maxclock
operator|)
operator|&&
name|score_all
argument_list|(
name|peer
argument_list|)
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_RESTART
argument_list|,
name|peer
argument_list|,
literal|"timeout"
argument_list|)
expr_stmt|;
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"TIME"
argument_list|)
expr_stmt|;
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
name|peer
operator|->
name|burst
operator|--
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If ntpdate mode and the clock has not been 			 * set and all peers have completed the burst, 			 * we declare a successful failure. 			 */
if|if
condition|(
name|mode_ntpdate
condition|)
block|{
name|peer_ntpdate
operator|--
expr_stmt|;
if|if
condition|(
name|peer_ntpdate
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ntpd: no servers found"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msyslog_term
condition|)
name|printf
argument_list|(
literal|"ntpd: no servers found\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|peer
operator|->
name|retry
operator|>
literal|0
condition|)
name|peer
operator|->
name|retry
operator|--
expr_stmt|;
comment|/* 	 * Do not transmit if in broadcast client mode.  	 */
if|if
condition|(
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BCLIENT
condition|)
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * receive - receive procedure called for each packet received  */
end_comment

begin_function
name|void
name|receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* peer structure pointer */
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
comment|/* receive packet pointer */
name|u_char
name|hisversion
decl_stmt|;
comment|/* packet version */
name|u_char
name|hisleap
decl_stmt|;
comment|/* packet leap indicator */
name|u_char
name|hismode
decl_stmt|;
comment|/* packet mode */
name|u_char
name|hisstratum
decl_stmt|;
comment|/* packet stratum */
name|u_short
name|restrict_mask
decl_stmt|;
comment|/* restrict bits */
name|int
name|has_mac
decl_stmt|;
comment|/* length of MAC field */
name|int
name|authlen
decl_stmt|;
comment|/* offset of MAC field */
name|int
name|is_authentic
init|=
literal|0
decl_stmt|;
comment|/* cryptosum ok */
name|int
name|retcode
init|=
name|AM_NOMATCH
decl_stmt|;
comment|/* match code */
name|keyid_t
name|skeyid
init|=
literal|0
decl_stmt|;
comment|/* key IDs */
name|u_int32
name|opcode
init|=
literal|0
decl_stmt|;
comment|/* extension field opcode */
name|sockaddr_u
modifier|*
name|dstadr_sin
decl_stmt|;
comment|/* active runway */
name|struct
name|peer
modifier|*
name|peer2
decl_stmt|;
comment|/* aux peer structure pointer */
name|endpt
modifier|*
name|match_ep
decl_stmt|;
comment|/* newpeer() local address */
name|l_fp
name|p_org
decl_stmt|;
comment|/* origin timestamp */
name|l_fp
name|p_rec
decl_stmt|;
comment|/* receive timestamp */
name|l_fp
name|p_xmt
decl_stmt|;
comment|/* transmit timestamp */
ifdef|#
directive|ifdef
name|AUTOKEY
name|char
name|hostname
index|[
name|NTP_MAXSTRLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|groupname
init|=
name|NULL
decl_stmt|;
name|struct
name|autokey
modifier|*
name|ap
decl_stmt|;
comment|/* autokey structure pointer */
name|int
name|rval
decl_stmt|;
comment|/* cookie snatcher */
name|keyid_t
name|pkeyid
init|=
literal|0
decl_stmt|,
name|tkeyid
init|=
literal|0
decl_stmt|;
comment|/* key IDs */
endif|#
directive|endif
comment|/* AUTOKEY */
ifdef|#
directive|ifdef
name|HAVE_NTP_SIGND
specifier|static
name|unsigned
name|char
name|zero_key
index|[
literal|16
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_NTP_SIGND */
comment|/* 	 * Monitor the packet and get restrictions. Note that the packet 	 * length for control and private mode packets must be checked 	 * by the service routines. Some restrictions have to be handled 	 * later in order to generate a kiss-o'-death packet. 	 */
comment|/* 	 * Bogus port check is before anything, since it probably 	 * reveals a clogging attack. 	 */
name|sys_received
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|SRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bogus port */
block|}
name|restrict_mask
operator|=
name|restrictions
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"receive: at %ld %s<-%s flags %x restrict %03x\n"
operator|,
name|current_time
operator|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
operator|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
operator|,
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|,
name|restrict_mask
operator|)
argument_list|)
expr_stmt|;
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
name|hisversion
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|hisleap
operator|=
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|hismode
operator|=
operator|(
name|int
operator|)
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|hisstratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
if|if
condition|(
name|restrict_mask
operator|&
name|RES_IGNORE
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* ignore everything */
block|}
if|if
condition|(
name|hismode
operator|==
name|MODE_PRIVATE
condition|)
block|{
if|if
condition|(
operator|!
name|ntp_mode7
operator|||
operator|(
name|restrict_mask
operator|&
name|RES_NOQUERY
operator|)
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no query private */
block|}
name|process_private
argument_list|(
name|rbufp
argument_list|,
operator|(
operator|(
name|restrict_mask
operator|&
name|RES_NOMODIFY
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hismode
operator|==
name|MODE_CONTROL
condition|)
block|{
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOQUERY
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no query control */
block|}
name|process_control
argument_list|(
name|rbufp
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|restrict_mask
operator|&
name|RES_DONTSERVE
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no time serve */
block|}
comment|/* 	 * This is for testing. If restricted drop ten percent of 	 * surviving packets. 	 */
if|if
condition|(
name|restrict_mask
operator|&
name|RES_FLAKE
condition|)
block|{
if|if
condition|(
operator|(
name|double
operator|)
name|ntp_random
argument_list|()
operator|/
literal|0x7fffffff
operator|<
literal|.1
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no flakeway */
block|}
block|}
comment|/* 	 * Version check must be after the query packets, since they 	 * intentionally use an early version. 	 */
if|if
condition|(
name|hisversion
operator|==
name|NTP_VERSION
condition|)
block|{
name|sys_newversion
operator|++
expr_stmt|;
comment|/* new version */
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|restrict_mask
operator|&
name|RES_VERSION
operator|)
operator|&&
name|hisversion
operator|>=
name|NTP_OLDVERSION
condition|)
block|{
name|sys_oldversion
operator|++
expr_stmt|;
comment|/* previous version */
block|}
else|else
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* old version */
block|}
comment|/* 	 * Figure out his mode and validate the packet. This has some 	 * legacy raunch that probably should be removed. In very early 	 * NTP versions mode 0 was equivalent to what later versions 	 * would interpret as client mode. 	 */
if|if
condition|(
name|hismode
operator|==
name|MODE_UNSPEC
condition|)
block|{
if|if
condition|(
name|hisversion
operator|==
name|NTP_OLDVERSION
condition|)
block|{
name|hismode
operator|=
name|MODE_CLIENT
expr_stmt|;
block|}
else|else
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* invalid mode */
block|}
block|}
comment|/* 	 * Parse the extension field if present. We figure out whether 	 * an extension field is present by measuring the MAC size. If 	 * the number of words following the packet header is 0, no MAC 	 * is present and the packet is not authenticated. If 1, the 	 * packet is a crypto-NAK; if 3, the packet is authenticated 	 * with DES; if 5, the packet is authenticated with MD5; if 6, 	 * the packet is authenticated with SHA. If 2 or * 4, the packet 	 * is a runt and discarded forthwith. If greater than 6, an 	 * extension field is present, so we subtract the length of the 	 * field and go around again. 	 */
name|authlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
name|has_mac
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|authlen
expr_stmt|;
while|while
condition|(
name|has_mac
operator|>
literal|0
condition|)
block|{
name|u_int32
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|u_int32
name|hostlen
decl_stmt|;
name|struct
name|exten
modifier|*
name|ep
decl_stmt|;
endif|#
directive|endif
comment|/*AUTOKEY */
if|if
condition|(
name|has_mac
operator|%
literal|4
operator|!=
literal|0
operator|||
name|has_mac
operator|<
operator|(
name|int
operator|)
name|MIN_MAC_LEN
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bad length */
block|}
if|if
condition|(
name|has_mac
operator|<=
operator|(
name|int
operator|)
name|MAX_MAC_LEN
condition|)
block|{
name|skeyid
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
name|u_int32
operator|*
operator|)
name|pkt
operator|)
index|[
name|authlen
operator|/
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|opcode
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
name|u_int32
operator|*
operator|)
name|pkt
operator|)
index|[
name|authlen
operator|/
literal|4
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|opcode
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|len
operator|%
literal|4
operator|!=
literal|0
operator|||
name|len
operator|<
literal|4
operator|||
operator|(
name|int
operator|)
name|len
operator|+
name|authlen
operator|>
name|rbufp
operator|->
name|recv_length
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bad length */
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 			 * Extract calling group name for later.  If 			 * sys_groupname is non-NULL, there must be 			 * a group name provided to elicit a response. 			 */
if|if
condition|(
operator|(
name|opcode
operator|&
literal|0x3fff0000
operator|)
operator|==
name|CRYPTO_ASSOC
operator|&&
name|sys_groupname
operator|!=
name|NULL
condition|)
block|{
name|ep
operator|=
operator|(
expr|struct
name|exten
operator|*
operator|)
operator|&
operator|(
operator|(
name|u_int32
operator|*
operator|)
name|pkt
operator|)
index|[
name|authlen
operator|/
literal|4
index|]
expr_stmt|;
name|hostlen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostlen
operator|>=
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
operator|||
name|hostlen
operator|>
name|len
operator|-
name|offsetof
argument_list|(
expr|struct
name|exten
argument_list|,
name|pkt
argument_list|)
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bad length */
block|}
name|memcpy
argument_list|(
name|hostname
argument_list|,
operator|&
name|ep
operator|->
name|pkt
argument_list|,
name|hostlen
argument_list|)
expr_stmt|;
name|hostname
index|[
name|hostlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|groupname
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupname
operator|==
name|NULL
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
block|}
name|groupname
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
name|authlen
operator|+=
name|len
expr_stmt|;
name|has_mac
operator|-=
name|len
expr_stmt|;
block|}
block|}
comment|/* 	 * If has_mac is< 0 we had a malformed packet. 	 */
if|if
condition|(
name|has_mac
operator|<
literal|0
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bad length */
block|}
comment|/* 	 * If authentication required, a MAC must be present. 	 */
if|if
condition|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
operator|&&
name|has_mac
operator|==
literal|0
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* access denied */
block|}
comment|/* 	 * Update the MRU list and finger the cloggers. It can be a 	 * little expensive, so turn it off for production use. 	 * RES_LIMITED and RES_KOD will be cleared in the returned 	 * restrict_mask unless one or both actions are warranted. 	 */
name|restrict_mask
operator|=
name|ntp_monitor
argument_list|(
name|rbufp
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|restrict_mask
operator|&
name|RES_LIMITED
condition|)
block|{
name|sys_limitrejected
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|restrict_mask
operator|&
name|RES_KOD
operator|)
operator|||
name|MODE_BROADCAST
operator|==
name|hismode
operator|||
name|MODE_SERVER
operator|==
name|hismode
condition|)
block|{
if|if
condition|(
name|MODE_SERVER
operator|==
name|hismode
condition|)
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Possibly self-induced rate limiting of MODE_SERVER from %s\n"
operator|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
comment|/* rate exceeded */
block|}
if|if
condition|(
name|hismode
operator|==
name|MODE_CLIENT
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
name|skeyid
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
else|else
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_ACTIVE
argument_list|,
name|skeyid
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
comment|/* rate exceeded */
block|}
name|restrict_mask
operator|&=
operator|~
name|RES_KOD
expr_stmt|;
comment|/* 	 * We have tossed out as many buggy packets as possible early in 	 * the game to reduce the exposure to a clogging attack. Now we 	 * have to burn some cycles to find the association and 	 * authenticate the packet if required. Note that we burn only 	 * digest cycles, again to reduce exposure. There may be no 	 * matching association and that's okay. 	 * 	 * More on the autokey mambo. Normally the local interface is 	 * found when the association was mobilized with respect to a 	 * designated remote address. We assume packets arriving from 	 * the remote address arrive via this interface and the local 	 * address used to construct the autokey is the unicast address 	 * of the interface. However, if the sender is a broadcaster, 	 * the interface broadcast address is used instead. 	 * Notwithstanding this technobabble, if the sender is a 	 * multicaster, the broadcast address is null, so we use the 	 * unicast address anyway. Don't ask. 	 */
name|peer
operator|=
name|findpeer
argument_list|(
name|rbufp
argument_list|,
name|hismode
argument_list|,
operator|&
name|retcode
argument_list|)
expr_stmt|;
name|dstadr_sin
operator|=
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|,
operator|&
name|p_rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
comment|/* 	 * Authentication is conditioned by three switches: 	 * 	 * NOPEER  (RES_NOPEER) do not mobilize an association unless 	 *         authenticated 	 * NOTRUST (RES_DONTTRUST) do not allow access unless 	 *         authenticated (implies NOPEER) 	 * enable  (sys_authenticate) master NOPEER switch, by default 	 *         on 	 * 	 * The NOPEER and NOTRUST can be specified on a per-client basis 	 * using the restrict command. The enable switch if on implies 	 * NOPEER for all clients. There are four outcomes: 	 * 	 * NONE    The packet has no MAC. 	 * OK      the packet has a MAC and authentication succeeds 	 * ERROR   the packet has a MAC and authentication fails 	 * CRYPTO  crypto-NAK. The MAC has four octets only. 	 * 	 * Note: The AUTH(x, y) macro is used to filter outcomes. If x 	 * is zero, acceptable outcomes of y are NONE and OK. If x is 	 * one, the only acceptable outcome of y is OK. 	 */
if|if
condition|(
name|has_mac
operator|==
literal|0
condition|)
block|{
name|restrict_mask
operator|&=
operator|~
name|RES_MSSNTP
expr_stmt|;
name|is_authentic
operator|=
name|AUTH_NONE
expr_stmt|;
comment|/* not required */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s mode %d len %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
name|dstadr_sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|authlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|has_mac
operator|==
literal|4
condition|)
block|{
name|restrict_mask
operator|&=
operator|~
name|RES_MSSNTP
expr_stmt|;
name|is_authentic
operator|=
name|AUTH_CRYPTO
expr_stmt|;
comment|/* crypto-NAK */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s mode %d keyid %08x len %d auth %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
name|dstadr_sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|skeyid
argument_list|,
name|authlen
operator|+
name|has_mac
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_NTP_SIGND
comment|/* 		 * If the signature is 20 bytes long, the last 16 of 		 * which are zero, then this is a Microsoft client 		 * wanting AD-style authentication of the server's 		 * reply.   		 * 		 * This is described in Microsoft's WSPP docs, in MS-SNTP: 		 * http://msdn.microsoft.com/en-us/library/cc212930.aspx 		 */
block|}
elseif|else
if|if
condition|(
name|has_mac
operator|==
name|MAX_MD5_LEN
operator|&&
operator|(
name|restrict_mask
operator|&
name|RES_MSSNTP
operator|)
operator|&&
operator|(
name|retcode
operator|==
name|AM_FXMIT
operator|||
name|retcode
operator|==
name|AM_NEWPASS
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|zero_key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
operator|+
name|authlen
operator|+
literal|4
argument_list|,
name|MAX_MD5_LEN
operator|-
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|is_authentic
operator|=
name|AUTH_NONE
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NTP_SIGND */
block|}
else|else
block|{
name|restrict_mask
operator|&=
operator|~
name|RES_MSSNTP
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 		 * For autokey modes, generate the session key 		 * and install in the key cache. Use the socket 		 * broadcast or unicast address as appropriate. 		 */
if|if
condition|(
name|crypto_flags
operator|&&
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
comment|/* 			 * More on the autokey dance (AKD). A cookie is 			 * constructed from public and private values. 			 * For broadcast packets, the cookie is public 			 * (zero). For packets that match no 			 * association, the cookie is hashed from the 			 * addresses and private value. For server 			 * packets, the cookie was previously obtained 			 * from the server. For symmetric modes, the 			 * cookie was previously constructed using an 			 * agreement protocol; however, should PKI be 			 * unavailable, we construct a fake agreement as 			 * the EXOR of the peer and host cookies. 			 * 			 * hismode	ephemeral	persistent 			 * ======================================= 			 * active	0		cookie# 			 * passive	0%		cookie# 			 * client	sys cookie	0% 			 * server	0%		sys cookie 			 * broadcast	0		0 			 * 			 * # if unsync, 0 			 * % can't happen 			 */
if|if
condition|(
name|has_mac
operator|<
operator|(
name|int
operator|)
name|MAX_MD5_LEN
condition|)
block|{
name|sys_badauth
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hismode
operator|==
name|MODE_BROADCAST
condition|)
block|{
comment|/* 				 * For broadcaster, use the interface 				 * broadcast address when available; 				 * otherwise, use the unicast address 				 * found when the association was 				 * mobilized. However, if this is from 				 * the wildcard interface, game over. 				 */
if|if
condition|(
name|crypto_flags
operator|&&
name|rbufp
operator|->
name|dstadr
operator|==
name|ANY_INTERFACE_CHOOSE
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no wildcard */
block|}
name|pkeyid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SOCK_UNSPEC
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|bcast
argument_list|)
condition|)
name|dstadr_sin
operator|=
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|bcast
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
block|{
name|pkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
literal|0
argument_list|,
name|sys_private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkeyid
operator|=
name|peer
operator|->
name|pcookie
expr_stmt|;
block|}
comment|/* 			 * The session key includes both the public 			 * values and cookie. In case of an extension 			 * field, the cookie used for authentication 			 * purposes is zero. Note the hash is saved for 			 * use later in the autokey mambo. 			 */
if|if
condition|(
name|authlen
operator|>
operator|(
name|int
operator|)
name|LEN_PKT_NOMAC
operator|&&
name|pkeyid
operator|!=
literal|0
condition|)
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
name|pkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
name|pkeyid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 		 * Compute the cryptosum. Note a clogging attack may 		 * succeed in bloating the key cache. If an autokey, 		 * purge it immediately, since we won't be needing it 		 * again. If the packet is authentic, it can mobilize an 		 * association. Note that there is no key zero. 		 */
if|if
condition|(
operator|!
name|authdecrypt
argument_list|(
name|skeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|pkt
argument_list|,
name|authlen
argument_list|,
name|has_mac
argument_list|)
condition|)
name|is_authentic
operator|=
name|AUTH_ERROR
expr_stmt|;
else|else
name|is_authentic
operator|=
name|AUTH_OK
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|crypto_flags
operator|&&
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|skeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s mode %d keyid %08x len %d auth %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
name|dstadr_sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|skeyid
argument_list|,
name|authlen
operator|+
name|has_mac
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * The association matching rules are implemented by a set of 	 * routines and an association table. A packet matching an 	 * association is processed by the peer process for that 	 * association. If there are no errors, an ephemeral association 	 * is mobilized: a broadcast packet mobilizes a broadcast client 	 * aassociation; a manycast server packet mobilizes a manycast 	 * client association; a symmetric active packet mobilizes a 	 * symmetric passive association. 	 */
switch|switch
condition|(
name|retcode
condition|)
block|{
comment|/* 	 * This is a client mode packet not matching any association. If 	 * an ordinary client, simply toss a server mode packet back 	 * over the fence. If a manycast client, we have to work a 	 * little harder. 	 */
case|case
name|AM_FXMIT
case|:
comment|/* 		 * If authentication OK, send a server reply; otherwise, 		 * send a crypto-NAK. 		 */
if|if
condition|(
operator|!
operator|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MCASTOPEN
operator|)
condition|)
block|{
if|if
condition|(
name|AUTH
argument_list|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
argument_list|,
name|is_authentic
argument_list|)
condition|)
block|{
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
name|skeyid
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_authentic
operator|==
name|AUTH_ERROR
condition|)
block|{
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
name|sys_badauth
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sys_restricted
operator|++
expr_stmt|;
block|}
return|return;
comment|/* hooray */
block|}
comment|/* 		 * This must be manycast. Do not respond if not 		 * configured as a manycast server. 		 */
if|if
condition|(
operator|!
name|sys_manycastserver
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* not enabled */
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 		 * Do not respond if not the same group. 		 */
if|if
condition|(
name|group_test
argument_list|(
name|groupname
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 		 * Do not respond if we are not synchronized or our 		 * stratum is greater than the manycaster or the 		 * manycaster has already synchronized to us. 		 */
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
operator|||
name|sys_stratum
operator|>=
name|hisstratum
operator|||
operator|(
operator|!
name|sys_cohort
operator|&&
name|sys_stratum
operator|==
name|hisstratum
operator|+
literal|1
operator|)
operator|||
name|rbufp
operator|->
name|dstadr
operator|->
name|addr_refid
operator|==
name|pkt
operator|->
name|refid
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
comment|/* no help */
block|}
comment|/* 		 * Respond only if authentication succeeds. Don't do a 		 * crypto-NAK, as that would not be useful. 		 */
if|if
condition|(
name|AUTH
argument_list|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
argument_list|,
name|is_authentic
argument_list|)
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
name|skeyid
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
comment|/* hooray */
comment|/* 	 * This is a server mode packet returned in response to a client 	 * mode packet sent to a multicast group address (for 	 * manycastclient) or to a unicast address (for pool). The 	 * origin timestamp is a good nonce to reliably associate the 	 * reply with what was sent. If there is no match, that's 	 * curious and could be an intruder attempting to clog, so we 	 * just ignore it. 	 * 	 * If the packet is authentic and the manycastclient or pool  	 * association is found, we mobilize a client association and 	 * copy pertinent variables from the manycastclient or pool 	 * association to the new client association. If not, just 	 * ignore the packet. 	 * 	 * There is an implosion hazard at the manycast client, since 	 * the manycast servers send the server packet immediately. If 	 * the guy is already here, don't fire up a duplicate. 	 */
case|case
name|AM_MANYCAST
case|:
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 		 * Do not respond if not the same group. 		 */
if|if
condition|(
name|group_test
argument_list|(
name|groupname
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
if|if
condition|(
operator|(
name|peer2
operator|=
name|findmanycastpeer
argument_list|(
name|rbufp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* not enabled */
block|}
if|if
condition|(
operator|!
name|AUTH
argument_list|(
operator|(
operator|!
operator|(
name|peer2
operator|->
name|cast_flags
operator|&
name|MDF_POOL
operator|)
operator|&&
name|sys_authenticate
operator|)
operator||
operator|(
name|restrict_mask
operator|&
operator|(
name|RES_NOPEER
operator||
name|RES_DONTTRUST
operator|)
operator|)
argument_list|,
name|is_authentic
argument_list|)
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* access denied */
block|}
comment|/* 		 * Do not respond if unsynchronized or stratum is below 		 * the floor or at or above the ceiling. 		 */
if|if
condition|(
name|hisleap
operator|==
name|LEAP_NOTINSYNC
operator|||
name|hisstratum
operator|<
name|sys_floor
operator|||
name|hisstratum
operator|>=
name|sys_ceiling
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
comment|/* no help */
block|}
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|NULL
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_CLIENT
argument_list|,
name|hisversion
argument_list|,
name|peer2
operator|->
name|minpoll
argument_list|,
name|peer2
operator|->
name|maxpoll
argument_list|,
name|FLAG_PREEMPT
operator||
operator|(
name|FLAG_IBURST
operator|&
name|peer2
operator|->
name|flags
operator|)
argument_list|,
name|MDF_UCAST
operator||
name|MDF_UCLNT
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|,
name|sys_ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|peer
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
comment|/* ignore duplicate  */
block|}
comment|/* 		 * After each ephemeral pool association is spun, 		 * accelerate the next poll for the pool solicitor so 		 * the pool will fill promptly. 		 */
if|if
condition|(
name|peer2
operator|->
name|cast_flags
operator|&
name|MDF_POOL
condition|)
name|peer2
operator|->
name|nextdate
operator|=
name|current_time
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Further processing of the solicitation response would 		 * simply detect its origin timestamp as bogus for the 		 * brand-new association (it matches the prototype 		 * association) and tinker with peer->nextdate delaying 		 * first sync. 		 */
return|return;
comment|/* solicitation response handled */
comment|/* 	 * This is the first packet received from a broadcast server. If 	 * the packet is authentic and we are enabled as broadcast 	 * client, mobilize a broadcast client association. We don't 	 * kiss any frogs here. 	 */
case|case
name|AM_NEWBCL
case|:
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 		 * Do not respond if not the same group. 		 */
if|if
condition|(
name|group_test
argument_list|(
name|groupname
argument_list|,
name|sys_ident
argument_list|)
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
if|if
condition|(
name|sys_bclient
operator|==
literal|0
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* not enabled */
block|}
if|if
condition|(
operator|!
name|AUTH
argument_list|(
name|sys_authenticate
operator||
operator|(
name|restrict_mask
operator|&
operator|(
name|RES_NOPEER
operator||
name|RES_DONTTRUST
operator|)
operator|)
argument_list|,
name|is_authentic
argument_list|)
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* access denied */
block|}
comment|/* 		 * Do not respond if unsynchronized or stratum is below 		 * the floor or at or above the ceiling. 		 */
if|if
condition|(
name|hisleap
operator|==
name|LEAP_NOTINSYNC
operator|||
name|hisstratum
operator|<
name|sys_floor
operator|||
name|hisstratum
operator|>=
name|sys_ceiling
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
comment|/* no help */
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 		 * Do not respond if Autokey and the opcode is not a 		 * CRYPTO_ASSOC response with association ID. 		 */
if|if
condition|(
name|crypto_flags
operator|&&
name|skeyid
operator|>
name|NTP_MAXKEY
operator|&&
operator|(
name|opcode
operator|&
literal|0xffff0000
operator|)
operator|!=
operator|(
name|CRYPTO_ASSOC
operator||
name|CRYPTO_RESP
operator|)
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
comment|/* protocol error */
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 		 * Broadcasts received via a multicast address may 		 * arrive after a unicast volley has begun 		 * with the same remote address.  newpeer() will not 		 * find duplicate associations on other local endpoints 		 * if a non-NULL endpoint is supplied.  multicastclient 		 * ephemeral associations are unique across all local 		 * endpoints. 		 */
if|if
condition|(
operator|!
operator|(
name|INT_MCASTOPEN
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|)
condition|)
name|match_ep
operator|=
name|rbufp
operator|->
name|dstadr
expr_stmt|;
else|else
name|match_ep
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Determine whether to execute the initial volley. 		 */
if|if
condition|(
name|sys_bdelay
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 			 * If a two-way exchange is not possible, 			 * neither is Autokey. 			 */
if|if
condition|(
name|crypto_flags
operator|&&
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no autokey */
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 			 * Do not execute the volley. Start out in 			 * broadcast client mode. 			 */
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|NULL
argument_list|,
name|match_ep
argument_list|,
name|MODE_BCLIENT
argument_list|,
name|hisversion
argument_list|,
name|pkt
operator|->
name|ppoll
argument_list|,
name|pkt
operator|->
name|ppoll
argument_list|,
name|FLAG_PREEMPT
argument_list|,
name|MDF_BCLNT
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|,
name|sys_ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|peer
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* ignore duplicate */
block|}
else|else
block|{
name|peer
operator|->
name|delay
operator|=
name|sys_bdelay
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Execute the initial volley in order to calibrate the 		 * propagation delay and run the Autokey protocol. 		 * 		 * Note that the minpoll is taken from the broadcast 		 * packet, normally 6 (64 s) and that the poll interval 		 * is fixed at this value. 		 */
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|NULL
argument_list|,
name|match_ep
argument_list|,
name|MODE_CLIENT
argument_list|,
name|hisversion
argument_list|,
name|pkt
operator|->
name|ppoll
argument_list|,
name|pkt
operator|->
name|ppoll
argument_list|,
name|FLAG_BC_VOL
operator||
name|FLAG_IBURST
operator||
name|FLAG_PREEMPT
argument_list|,
name|MDF_BCLNT
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|,
name|sys_ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|peer
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* ignore duplicate */
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
name|crypto_recv
argument_list|(
name|peer
argument_list|,
name|rbufp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
return|return;
comment|/* hooray */
comment|/* 	 * This is the first packet received from a symmetric active 	 * peer. If the packet is authentic and the first he sent, 	 * mobilize a passive association. If not, kiss the frog. 	 */
case|case
name|AM_NEWPASS
case|:
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 		 * Do not respond if not the same group. 		 */
if|if
condition|(
name|group_test
argument_list|(
name|groupname
argument_list|,
name|sys_ident
argument_list|)
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
if|if
condition|(
operator|!
name|AUTH
argument_list|(
name|sys_authenticate
operator||
operator|(
name|restrict_mask
operator|&
operator|(
name|RES_NOPEER
operator||
name|RES_DONTTRUST
operator|)
operator|)
argument_list|,
name|is_authentic
argument_list|)
condition|)
block|{
comment|/* 			 * If authenticated but cannot mobilize an 			 * association, send a symmetric passive 			 * response without mobilizing an association. 			 * This is for drat broken Windows clients. See 			 * Microsoft KB 875424 for preferred workaround. 			 */
if|if
condition|(
name|AUTH
argument_list|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
argument_list|,
name|is_authentic
argument_list|)
condition|)
block|{
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_PASSIVE
argument_list|,
name|skeyid
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
comment|/* hooray */
block|}
if|if
condition|(
name|is_authentic
operator|==
name|AUTH_ERROR
condition|)
block|{
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_ACTIVE
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
name|sys_restricted
operator|++
expr_stmt|;
return|return;
block|}
block|}
comment|/* 		 * Do not respond if synchronized and if stratum is 		 * below the floor or at or above the ceiling. Note, 		 * this allows an unsynchronized peer to synchronize to 		 * us. It would be very strange if he did and then was 		 * nipped, but that could only happen if we were 		 * operating at the top end of the range.  It also means 		 * we will spin an ephemeral association in response to 		 * MODE_ACTIVE KoDs, which will time out eventually. 		 */
if|if
condition|(
name|hisleap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
operator|(
name|hisstratum
operator|<
name|sys_floor
operator|||
name|hisstratum
operator|>=
name|sys_ceiling
operator|)
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
comment|/* no help */
block|}
comment|/* 		 * The message is correctly authenticated and allowed. 		 * Mobilize a symmetric passive association. 		 */
if|if
condition|(
operator|(
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|NULL
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_PASSIVE
argument_list|,
name|hisversion
argument_list|,
name|pkt
operator|->
name|ppoll
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
literal|0
argument_list|,
name|MDF_UCAST
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|,
name|sys_ident
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
comment|/* ignore duplicate */
block|}
break|break;
comment|/* 	 * Process regular packet. Nothing special. 	 */
case|case
name|AM_PROCPKT
case|:
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 		 * Do not respond if not the same group. 		 */
if|if
condition|(
name|group_test
argument_list|(
name|groupname
argument_list|,
name|peer
operator|->
name|ident
argument_list|)
condition|)
block|{
name|sys_declined
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
break|break;
comment|/* 	 * A passive packet matches a passive association. This is 	 * usually the result of reconfiguring a client on the fly. As 	 * this association might be legitimate and this packet an 	 * attempt to deny service, just ignore it. 	 */
case|case
name|AM_ERR
case|:
name|sys_declined
operator|++
expr_stmt|;
return|return;
comment|/* 	 * For everything else there is the bit bucket. 	 */
default|default:
name|sys_declined
operator|++
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * If the association is configured for Autokey, the packet must 	 * have a public key ID; if not, the packet must have a 	 * symmetric key ID. 	 */
if|if
condition|(
name|is_authentic
operator|!=
name|AUTH_CRYPTO
operator|&&
operator|(
operator|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
operator|)
operator|&&
name|skeyid
operator|<=
name|NTP_MAXKEY
operator|)
operator|||
operator|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
operator|)
operator|&&
name|skeyid
operator|>
name|NTP_MAXKEY
operator|)
operator|)
condition|)
block|{
name|sys_badauth
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
name|peer
operator|->
name|received
operator|++
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|PKT_TEST_MASK
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_XBOGUS
condition|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_XBOGUS
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
block|}
comment|/* 	 * Next comes a rigorous schedule of timestamp checking. If the 	 * transmit timestamp is zero, the server has not initialized in 	 * interleaved modes or is horribly broken. 	 */
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_xmt
argument_list|)
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynch */
comment|/* 	 * If the transmit timestamp duplicates a previous one, the 	 * packet is a replay. This prevents the bad guys from replaying 	 * the most recent packet, authenticated or not. 	 */
block|}
elseif|else
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST1
expr_stmt|;
comment|/* duplicate */
name|peer
operator|->
name|oldpkt
operator|++
expr_stmt|;
return|return;
comment|/* 	 * If this is a broadcast mode packet, skip further checking. If 	 * an initial volley, bail out now and let the client do its 	 * stuff. If the origin timestamp is nonzero, this is an 	 * interleaved broadcast. so restart the protocol. 	 */
block|}
elseif|else
if|if
condition|(
name|hismode
operator|==
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
operator|!
name|L_ISZERO
argument_list|(
operator|&
name|p_org
argument_list|)
operator|&&
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_XB
operator|)
condition|)
block|{
name|peer
operator|->
name|flags
operator||=
name|FLAG_XB
expr_stmt|;
name|peer
operator|->
name|aorg
operator|=
name|p_xmt
expr_stmt|;
name|peer
operator|->
name|borg
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|report_event
argument_list|(
name|PEVNT_XLEAVE
argument_list|,
name|peer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check for bogus packet in basic mode. If found, switch to 	 * interleaved mode and resynchronize, but only after confirming 	 * the packet is not bogus in symmetric interleaved mode. 	 */
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|flip
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|p_org
argument_list|,
operator|&
name|peer
operator|->
name|aorg
argument_list|)
condition|)
block|{
name|peer
operator|->
name|bogusorg
operator|++
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST2
expr_stmt|;
comment|/* bogus */
if|if
condition|(
operator|!
name|L_ISZERO
argument_list|(
operator|&
name|peer
operator|->
name|dst
argument_list|)
operator|&&
name|L_ISEQU
argument_list|(
operator|&
name|p_org
argument_list|,
operator|&
name|peer
operator|->
name|dst
argument_list|)
condition|)
block|{
name|peer
operator|->
name|flip
operator|=
literal|1
expr_stmt|;
name|report_event
argument_list|(
name|PEVNT_XLEAVE
argument_list|,
name|peer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|L_CLR
argument_list|(
operator|&
name|peer
operator|->
name|aorg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for valid nonzero timestamp fields. 	 */
block|}
elseif|else
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_org
argument_list|)
operator|||
name|L_ISZERO
argument_list|(
operator|&
name|p_rec
argument_list|)
operator|||
name|L_ISZERO
argument_list|(
operator|&
name|peer
operator|->
name|dst
argument_list|)
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynch */
comment|/* 	 * Check for bogus packet in interleaved symmetric mode. This 	 * can happen if a packet is lost, duplicated or crossed. If 	 * found, flip and resynchronize. 	 */
block|}
elseif|else
if|if
condition|(
operator|!
name|L_ISZERO
argument_list|(
operator|&
name|peer
operator|->
name|dst
argument_list|)
operator|&&
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|p_org
argument_list|,
operator|&
name|peer
operator|->
name|dst
argument_list|)
condition|)
block|{
name|peer
operator|->
name|bogusorg
operator|++
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_XBOGUS
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST2
expr_stmt|;
comment|/* bogus */
block|}
comment|/* 	 * Update the state variables. 	 */
if|if
condition|(
name|peer
operator|->
name|flip
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hismode
operator|!=
name|MODE_BROADCAST
condition|)
name|peer
operator|->
name|rec
operator|=
name|p_xmt
expr_stmt|;
name|peer
operator|->
name|dst
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
block|}
name|peer
operator|->
name|xmt
operator|=
name|p_xmt
expr_stmt|;
comment|/* 	 * If this is a crypto_NAK, the server cannot authenticate a 	 * client packet. The server might have just changed keys. Clear 	 * the association and restart the protocol. 	 */
if|if
condition|(
name|is_authentic
operator|==
name|AUTH_CRYPTO
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_AUTH
argument_list|,
name|peer
argument_list|,
literal|"crypto_NAK"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST5
expr_stmt|;
comment|/* bad auth */
name|peer
operator|->
name|badauth
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREEMPT
condition|)
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|peer
operator|->
name|crypto
condition|)
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"AUTH"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
return|return;
comment|/*  	 * If the digest fails, the client cannot authenticate a server 	 * reply to a client packet previously sent. The loopback check 	 * is designed to avoid a bait-and-switch attack, which was 	 * possible in past versions. If symmetric modes, return a 	 * crypto-NAK. The peer should restart the protocol. 	 */
block|}
elseif|else
if|if
condition|(
operator|!
name|AUTH
argument_list|(
name|has_mac
operator|||
operator|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
operator|)
argument_list|,
name|is_authentic
argument_list|)
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_AUTH
argument_list|,
name|peer
argument_list|,
literal|"digest"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST5
expr_stmt|;
comment|/* bad auth */
name|peer
operator|->
name|badauth
operator|++
expr_stmt|;
if|if
condition|(
name|hismode
operator|==
name|MODE_ACTIVE
operator|||
name|hismode
operator|==
name|MODE_PASSIVE
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_ACTIVE
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREEMPT
condition|)
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|peer
operator|->
name|crypto
condition|)
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"AUTH"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
return|return;
block|}
comment|/* 	 * Set the peer ppoll to the maximum of the packet ppoll and the 	 * peer minpoll. If a kiss-o'-death, set the peer minpoll to 	 * this maximum and advance the headway to give the sender some 	 * headroom. Very intricate. 	 */
name|peer
operator|->
name|ppoll
operator|=
name|max
argument_list|(
name|peer
operator|->
name|minpoll
argument_list|,
name|pkt
operator|->
name|ppoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|hismode
operator|==
name|MODE_SERVER
operator|&&
name|hisleap
operator|==
name|LEAP_NOTINSYNC
operator|&&
name|hisstratum
operator|==
name|STRATUM_UNSPEC
operator|&&
name|memcmp
argument_list|(
operator|&
name|pkt
operator|->
name|refid
argument_list|,
literal|"RATE"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|peer
operator|->
name|selbroken
operator|++
expr_stmt|;
name|report_event
argument_list|(
name|PEVNT_RATE
argument_list|,
name|peer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|ppoll
operator|>
name|peer
operator|->
name|minpoll
condition|)
name|peer
operator|->
name|minpoll
operator|=
name|peer
operator|->
name|ppoll
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|peer
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|throttle
operator|=
operator|(
name|NTP_SHIFT
operator|+
literal|1
operator|)
operator|*
operator|(
literal|1
operator|<<
name|peer
operator|->
name|minpoll
operator|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|pkt
operator|->
name|ppoll
argument_list|)
expr_stmt|;
return|return;
comment|/* kiss-o'-death */
block|}
comment|/* 	 * That was hard and I am sweaty, but the packet is squeaky 	 * clean. Get on with real work. 	 */
name|peer
operator|->
name|timereceived
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|is_authentic
operator|==
name|AUTH_OK
condition|)
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENTIC
expr_stmt|;
else|else
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_AUTHENTIC
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * More autokey dance. The rules of the cha-cha are as follows: 	 * 	 * 1. If there is no key or the key is not auto, do nothing. 	 * 	 * 2. If this packet is in response to the one just previously 	 *    sent or from a broadcast server, do the extension fields. 	 *    Otherwise, assume bogosity and bail out. 	 * 	 * 3. If an extension field contains a verified signature, it is 	 *    self-authenticated and we sit the dance. 	 * 	 * 4. If this is a server reply, check only to see that the 	 *    transmitted key ID matches the received key ID. 	 * 	 * 5. Check to see that one or more hashes of the current key ID 	 *    matches the previous key ID or ultimate original key ID 	 *    obtained from the broadcaster or symmetric peer. If no 	 *    match, sit the dance and call for new autokey values. 	 * 	 * In case of crypto error, fire the orchestra, stop dancing and 	 * restart the protocol. 	 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
condition|)
block|{
comment|/* 		 * Decrement remaining autokey hashes. This isn't 		 * perfect if a packet is lost, but results in no harm. 		 */
name|ap
operator|=
operator|(
expr|struct
name|autokey
operator|*
operator|)
name|peer
operator|->
name|recval
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
name|ap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|seq
operator|>
literal|0
condition|)
name|ap
operator|->
name|seq
operator|--
expr_stmt|;
block|}
name|peer
operator|->
name|flash
operator||=
name|TEST8
expr_stmt|;
name|rval
operator|=
name|crypto_recv
argument_list|(
name|peer
argument_list|,
name|rbufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|XEVNT_OK
condition|)
block|{
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rval
operator|==
name|XEVNT_ERR
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_RESTART
argument_list|,
name|peer
argument_list|,
literal|"crypto error"
argument_list|)
expr_stmt|;
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"CRYP"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST9
expr_stmt|;
comment|/* bad crypt */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREEMPT
condition|)
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 		 * If server mode, verify the receive key ID matches 		 * the transmit key ID. 		 */
if|if
condition|(
name|hismode
operator|==
name|MODE_SERVER
condition|)
block|{
if|if
condition|(
name|skeyid
operator|==
name|peer
operator|->
name|keyid
condition|)
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
comment|/* 		 * If an extension field is present, verify only that it 		 * has been correctly signed. We don't need a sequence 		 * check here, but the sequence continues. 		 */
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flash
operator|&
name|TEST8
operator|)
condition|)
block|{
name|peer
operator|->
name|pkeyid
operator|=
name|skeyid
expr_stmt|;
comment|/* 		 * Now the fun part. Here, skeyid is the current ID in 		 * the packet, pkeyid is the ID in the last packet and 		 * tkeyid is the hash of skeyid. If the autokey values 		 * have not been received, this is an automatic error. 		 * If so, check that the tkeyid matches pkeyid. If not, 		 * hash tkeyid and try again. If the number of hashes 		 * exceeds the number remaining in the sequence, declare 		 * a successful failure and refresh the autokey values. 		 */
block|}
elseif|else
if|if
condition|(
name|ap
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tkeyid
operator|==
name|peer
operator|->
name|pkeyid
operator|||
name|tkeyid
operator|==
name|ap
operator|->
name|key
condition|)
block|{
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
name|peer
operator|->
name|pkeyid
operator|=
name|skeyid
expr_stmt|;
name|ap
operator|->
name|seq
operator|-=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|ap
operator|->
name|seq
condition|)
block|{
name|peer
operator|->
name|crypto
operator|&=
operator|~
name|CRYPTO_FLAG_AUTO
expr_stmt|;
break|break;
block|}
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|tkeyid
argument_list|,
name|pkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|TEST8
condition|)
name|report_event
argument_list|(
name|PEVNT_AUTH
argument_list|,
name|peer
argument_list|,
literal|"keylist"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_PROV
operator|)
condition|)
comment|/* test 9 */
name|peer
operator|->
name|flash
operator||=
name|TEST8
expr_stmt|;
comment|/* bad autokey */
comment|/* 		 * The maximum lifetime of the protocol is about one 		 * week before restarting the Autokey protocol to 		 * refresh certificates and leapseconds values. 		 */
if|if
condition|(
name|current_time
operator|>
name|peer
operator|->
name|refresh
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_RESTART
argument_list|,
name|peer
argument_list|,
literal|"crypto refresh"
argument_list|)
expr_stmt|;
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"TIME"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 	 * The dance is complete and the flash bits have been lit. Toss 	 * the packet over the fence for processing, which may light up 	 * more flashers. 	 */
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|)
expr_stmt|;
comment|/* 	 * In interleaved mode update the state variables. Also adjust the 	 * transmit phase to avoid crossover. 	 */
if|if
condition|(
name|peer
operator|->
name|flip
operator|!=
literal|0
condition|)
block|{
name|peer
operator|->
name|rec
operator|=
name|p_rec
expr_stmt|;
name|peer
operator|->
name|dst
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|-
name|current_time
operator|<
operator|(
literal|1U
operator|<<
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
operator|)
operator|/
literal|2
condition|)
name|peer
operator|->
name|nextdate
operator|++
expr_stmt|;
else|else
name|peer
operator|->
name|nextdate
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process_packet - Packet Procedure, a la Section 3.4.4 of the  *	specification. Or almost, at least. If we're in here we have a  *	reasonable expectation that we will be having a long term  *	relationship with this host.  */
end_comment

begin_function
name|void
name|process_packet
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|double
name|t34
decl_stmt|,
name|t21
decl_stmt|;
name|double
name|p_offset
decl_stmt|,
name|p_del
decl_stmt|,
name|p_disp
decl_stmt|;
name|l_fp
name|p_rec
decl_stmt|,
name|p_xmt
decl_stmt|,
name|p_org
decl_stmt|,
name|p_reftime
decl_stmt|,
name|ci
decl_stmt|;
name|u_char
name|pmode
decl_stmt|,
name|pleap
decl_stmt|,
name|pversion
decl_stmt|,
name|pstratum
decl_stmt|;
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ASSYM
name|int
name|itemp
decl_stmt|;
name|double
name|etemp
decl_stmt|,
name|ftemp
decl_stmt|,
name|td
decl_stmt|;
endif|#
directive|endif
comment|/* ASSYM */
name|sys_processed
operator|++
expr_stmt|;
name|peer
operator|->
name|processed
operator|++
expr_stmt|;
name|p_del
operator|=
name|FPTOD
argument_list|(
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|p_offset
operator|=
literal|0
expr_stmt|;
name|p_disp
operator|=
name|FPTOD
argument_list|(
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdisp
argument_list|)
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|reftime
argument_list|,
operator|&
name|p_reftime
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|,
operator|&
name|p_rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
name|pmode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|pleap
operator|=
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|pversion
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|pstratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
comment|/* 	 * Capture the header values in the client/peer association.. 	 */
name|record_raw_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|peer
operator|->
name|dstadr
condition|?
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
else|:
name|NULL
argument_list|,
operator|&
name|p_org
argument_list|,
operator|&
name|p_rec
argument_list|,
operator|&
name|p_xmt
argument_list|,
operator|&
name|peer
operator|->
name|dst
argument_list|,
name|pleap
argument_list|,
name|pversion
argument_list|,
name|pmode
argument_list|,
name|pstratum
argument_list|,
name|pkt
operator|->
name|ppoll
argument_list|,
name|pkt
operator|->
name|precision
argument_list|,
name|p_del
argument_list|,
name|p_disp
argument_list|,
name|pkt
operator|->
name|refid
argument_list|)
expr_stmt|;
name|peer
operator|->
name|leap
operator|=
name|pleap
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|min
argument_list|(
name|pstratum
argument_list|,
name|STRATUM_UNSPEC
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pmode
operator|=
name|pmode
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|pkt
operator|->
name|precision
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
name|p_del
expr_stmt|;
name|peer
operator|->
name|rootdisp
operator|=
name|p_disp
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pkt
operator|->
name|refid
expr_stmt|;
comment|/* network byte order */
name|peer
operator|->
name|reftime
operator|=
name|p_reftime
expr_stmt|;
comment|/* 	 * First, if either burst mode is armed, enable the burst. 	 * Compute the headway for the next packet and delay if 	 * necessary to avoid exceeding the threshold. 	 */
if|if
condition|(
name|peer
operator|->
name|retry
operator|>
literal|0
condition|)
block|{
name|peer
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
condition|)
name|peer
operator|->
name|burst
operator|=
name|min
argument_list|(
literal|1
operator|<<
operator|(
name|peer
operator|->
name|hpoll
operator|-
name|peer
operator|->
name|minpoll
operator|)
argument_list|,
name|NTP_SHIFT
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|peer
operator|->
name|burst
operator|=
name|NTP_IBURST
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
name|peer
operator|->
name|nextdate
operator|=
name|current_time
expr_stmt|;
block|}
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
comment|/* 	 * Verify the server is synchronized; that is, the leap bits, 	 * stratum and root distance are valid. 	 */
if|if
condition|(
name|pleap
operator|==
name|LEAP_NOTINSYNC
operator|||
comment|/* test 6 */
name|pstratum
operator|<
name|sys_floor
operator|||
name|pstratum
operator|>=
name|sys_ceiling
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST6
expr_stmt|;
comment|/* bad synch or strat */
if|if
condition|(
name|p_del
operator|/
literal|2
operator|+
name|p_disp
operator|>=
name|MAXDISPERSE
condition|)
comment|/* test 7 */
name|peer
operator|->
name|flash
operator||=
name|TEST7
expr_stmt|;
comment|/* bad header */
comment|/* 	 * If any tests fail at this point, the packet is discarded. 	 * Note that some flashers may have already been set in the 	 * receive() routine. 	 */
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|PKT_TEST_MASK
condition|)
block|{
name|peer
operator|->
name|seldisptoolarge
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: flash header %04x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * If the peer was previously unreachable, raise a trap. In any 	 * case, mark it reachable. 	 */
if|if
condition|(
operator|!
name|peer
operator|->
name|reach
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_REACH
argument_list|,
name|peer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
block|}
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
comment|/* 	 * For a client/server association, calculate the clock offset, 	 * roundtrip delay and dispersion. The equations are reordered 	 * from the spec for more efficient use of temporaries. For a 	 * broadcast association, offset the last measurement by the 	 * computed delay during the client/server volley. Note the 	 * computation of dispersion includes the system precision plus 	 * that due to the frequency error since the origin time. 	 * 	 * It is very important to respect the hazards of overflow. The 	 * only permitted operation on raw timestamps is subtraction, 	 * where the result is a signed quantity spanning from 68 years 	 * in the past to 68 years in the future. To avoid loss of 	 * precision, these calculations are done using 64-bit integer 	 * arithmetic. However, the offset and delay calculations are 	 * sums and differences of these first-order differences, which 	 * if done using 64-bit integer arithmetic, would be valid over 	 * only half that span. Since the typical first-order 	 * differences are usually very small, they are converted to 64- 	 * bit doubles and all remaining calculations done in floating- 	 * double arithmetic. This preserves the accuracy while 	 * retaining the 68-year span. 	 * 	 * There are three interleaving schemes, basic, interleaved 	 * symmetric and interleaved broadcast. The timestamps are 	 * idioscyncratically different. See the onwire briefing/white 	 * paper at www.eecis.udel.edu/~mills for details. 	 * 	 * Interleaved symmetric mode 	 * t1 = peer->aorg/borg, t2 = peer->rec, t3 = p_xmt, 	 * t4 = peer->dst 	 */
if|if
condition|(
name|peer
operator|->
name|flip
operator|!=
literal|0
condition|)
block|{
name|ci
operator|=
name|p_xmt
expr_stmt|;
comment|/* t3 - t4 */
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|peer
operator|->
name|dst
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|t34
argument_list|)
expr_stmt|;
name|ci
operator|=
name|p_rec
expr_stmt|;
comment|/* t2 - t1 */
if|if
condition|(
name|peer
operator|->
name|flip
operator|>
literal|0
condition|)
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|peer
operator|->
name|borg
argument_list|)
expr_stmt|;
else|else
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|peer
operator|->
name|aorg
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|t21
argument_list|)
expr_stmt|;
name|p_del
operator|=
name|t21
operator|-
name|t34
expr_stmt|;
name|p_offset
operator|=
operator|(
name|t21
operator|+
name|t34
operator|)
operator|/
literal|2.
expr_stmt|;
if|if
condition|(
name|p_del
operator|<
literal|0
operator|||
name|p_del
operator|>
literal|1.
condition|)
block|{
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"t21 %.6f t34 %.6f"
argument_list|,
name|t21
argument_list|,
name|t34
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|PEVNT_XERR
argument_list|,
name|peer
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Broadcast modes 	 */
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|pmode
operator|==
name|MODE_BROADCAST
condition|)
block|{
comment|/* 		 * Interleaved broadcast mode. Use interleaved timestamps. 		 * t1 = peer->borg, t2 = p_org, t3 = p_org, t4 = aorg 		 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_XB
condition|)
block|{
name|ci
operator|=
name|p_org
expr_stmt|;
comment|/* delay */
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|peer
operator|->
name|aorg
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|t34
argument_list|)
expr_stmt|;
name|ci
operator|=
name|p_org
expr_stmt|;
comment|/* t2 - t1 */
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|peer
operator|->
name|borg
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|t21
argument_list|)
expr_stmt|;
name|peer
operator|->
name|aorg
operator|=
name|p_xmt
expr_stmt|;
name|peer
operator|->
name|borg
operator|=
name|peer
operator|->
name|dst
expr_stmt|;
if|if
condition|(
name|t34
operator|<
literal|0
operator|||
name|t34
operator|>
literal|1.
condition|)
block|{
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"offset %.6f delay %.6f"
argument_list|,
name|t21
argument_list|,
name|t34
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|PEVNT_XERR
argument_list|,
name|peer
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_offset
operator|=
name|t21
expr_stmt|;
name|peer
operator|->
name|xleave
operator|=
name|t34
expr_stmt|;
comment|/* 		 * Basic broadcast - use direct timestamps. 		 * t3 = p_xmt, t4 = peer->dst 		 */
block|}
else|else
block|{
name|ci
operator|=
name|p_xmt
expr_stmt|;
comment|/* t3 - t4 */
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|peer
operator|->
name|dst
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|t34
argument_list|)
expr_stmt|;
name|p_offset
operator|=
name|t34
expr_stmt|;
block|}
comment|/* 		 * When calibration is complete and the clock is 		 * synchronized, the bias is calculated as the difference 		 * between the unicast timestamp and the broadcast 		 * timestamp. This works for both basic and interleaved 		 * modes. 		 */
if|if
condition|(
name|FLAG_BC_VOL
operator|&
name|peer
operator|->
name|flags
condition|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_BC_VOL
expr_stmt|;
name|peer
operator|->
name|delay
operator|=
name|fabs
argument_list|(
name|peer
operator|->
name|offset
operator|-
name|p_offset
argument_list|)
operator|*
literal|2
expr_stmt|;
block|}
name|p_del
operator|=
name|peer
operator|->
name|delay
expr_stmt|;
name|p_offset
operator|+=
name|p_del
operator|/
literal|2
expr_stmt|;
comment|/* 	 * Basic mode, otherwise known as the old fashioned way. 	 * 	 * t1 = p_org, t2 = p_rec, t3 = p_xmt, t4 = peer->dst 	 */
block|}
else|else
block|{
name|ci
operator|=
name|p_xmt
expr_stmt|;
comment|/* t3 - t4 */
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|peer
operator|->
name|dst
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|t34
argument_list|)
expr_stmt|;
name|ci
operator|=
name|p_rec
expr_stmt|;
comment|/* t2 - t1 */
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|t21
argument_list|)
expr_stmt|;
name|p_del
operator|=
name|fabs
argument_list|(
name|t21
operator|-
name|t34
argument_list|)
expr_stmt|;
name|p_offset
operator|=
operator|(
name|t21
operator|+
name|t34
operator|)
operator|/
literal|2.
expr_stmt|;
block|}
name|p_del
operator|=
name|max
argument_list|(
name|p_del
argument_list|,
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
expr_stmt|;
name|p_disp
operator|=
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
operator|+
name|LOGTOD
argument_list|(
name|peer
operator|->
name|precision
argument_list|)
operator|+
name|clock_phi
operator|*
name|p_del
expr_stmt|;
if|#
directive|if
name|ASSYM
comment|/* 	 * This code calculates the outbound and inbound data rates by 	 * measuring the differences between timestamps at different 	 * packet lengths. This is helpful in cases of large asymmetric 	 * delays commonly experienced on deep space communication 	 * links. 	 */
if|if
condition|(
name|peer
operator|->
name|t21_last
operator|>
literal|0
operator|&&
name|peer
operator|->
name|t34_bytes
operator|>
literal|0
condition|)
block|{
name|itemp
operator|=
name|peer
operator|->
name|t21_bytes
operator|-
name|peer
operator|->
name|t21_last
expr_stmt|;
if|if
condition|(
name|itemp
operator|>
literal|25
condition|)
block|{
name|etemp
operator|=
name|t21
operator|-
name|peer
operator|->
name|t21
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|etemp
argument_list|)
operator|>
literal|1e-6
condition|)
block|{
name|ftemp
operator|=
name|itemp
operator|/
name|etemp
expr_stmt|;
if|if
condition|(
name|ftemp
operator|>
literal|1000.
condition|)
name|peer
operator|->
name|r21
operator|=
name|ftemp
expr_stmt|;
block|}
block|}
name|itemp
operator|=
name|len
operator|-
name|peer
operator|->
name|t34_bytes
expr_stmt|;
if|if
condition|(
name|itemp
operator|>
literal|25
condition|)
block|{
name|etemp
operator|=
operator|-
name|t34
operator|-
name|peer
operator|->
name|t34
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|etemp
argument_list|)
operator|>
literal|1e-6
condition|)
block|{
name|ftemp
operator|=
name|itemp
operator|/
name|etemp
expr_stmt|;
if|if
condition|(
name|ftemp
operator|>
literal|1000.
condition|)
name|peer
operator|->
name|r34
operator|=
name|ftemp
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * The following section compensates for different data rates on 	 * the outbound (d21) and inbound (t34) directions. To do this, 	 * it finds t such that r21 * t - r34 * (d - t) = 0, where d is 	 * the roundtrip delay. Then it calculates the correction as a 	 * fraction of d. 	 */
name|peer
operator|->
name|t21
operator|=
name|t21
expr_stmt|;
name|peer
operator|->
name|t21_last
operator|=
name|peer
operator|->
name|t21_bytes
expr_stmt|;
name|peer
operator|->
name|t34
operator|=
operator|-
name|t34
expr_stmt|;
name|peer
operator|->
name|t34_bytes
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"packet: t21 %.9lf %d t34 %.9lf %d\n"
argument_list|,
name|peer
operator|->
name|t21
argument_list|,
name|peer
operator|->
name|t21_bytes
argument_list|,
name|peer
operator|->
name|t34
argument_list|,
name|peer
operator|->
name|t34_bytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|r21
operator|>
literal|0
operator|&&
name|peer
operator|->
name|r34
operator|>
literal|0
operator|&&
name|p_del
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|pmode
operator|!=
name|MODE_BROADCAST
condition|)
name|td
operator|=
operator|(
name|peer
operator|->
name|r34
operator|/
operator|(
name|peer
operator|->
name|r21
operator|+
name|peer
operator|->
name|r34
operator|)
operator|-
literal|.5
operator|)
operator|*
name|p_del
expr_stmt|;
else|else
name|td
operator|=
literal|0
expr_stmt|;
comment|/*  		 * Unfortunately, in many cases the errors are 		 * unacceptable, so for the present the rates are not 		 * used. In future, we might find conditions where the 		 * calculations are useful, so this should be considered 		 * a work in progress. 		 */
name|t21
operator|-=
name|td
expr_stmt|;
name|t34
operator|-=
name|td
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"packet: del %.6lf r21 %.1lf r34 %.1lf %.6lf\n"
argument_list|,
name|p_del
argument_list|,
name|peer
operator|->
name|r21
operator|/
literal|1e3
argument_list|,
name|peer
operator|->
name|r34
operator|/
literal|1e3
argument_list|,
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* ASSYM */
comment|/* 	 * That was awesome. Now hand off to the clock filter. 	 */
name|clock_filter
argument_list|(
name|peer
argument_list|,
name|p_offset
operator|+
name|peer
operator|->
name|bias
argument_list|,
name|p_del
argument_list|,
name|p_disp
argument_list|)
expr_stmt|;
comment|/* 	 * If we are in broadcast calibrate mode, return to broadcast 	 * client mode when the client is fit and the autokey dance is 	 * complete. 	 */
if|if
condition|(
operator|(
name|FLAG_BC_VOL
operator|&
name|peer
operator|->
name|flags
operator|)
operator|&&
name|MODE_CLIENT
operator|==
name|peer
operator|->
name|hmode
operator|&&
operator|!
operator|(
name|TEST11
operator|&
name|peer_unfit
argument_list|(
name|peer
argument_list|)
operator|)
condition|)
block|{
comment|/* distance exceeded */
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|~
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_ALL
operator|)
condition|)
name|peer
operator|->
name|hmode
operator|=
name|MODE_BCLIENT
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|hmode
operator|=
name|MODE_BCLIENT
expr_stmt|;
block|}
else|#
directive|else
comment|/* !AUTOKEY follows */
name|peer
operator|->
name|hmode
operator|=
name|MODE_BCLIENT
expr_stmt|;
endif|#
directive|endif
comment|/* !AUTOKEY */
block|}
block|}
end_function

begin_comment
comment|/*  * clock_update - Called at system process update intervals.  */
end_comment

begin_function
specifier|static
name|void
name|clock_update
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|double
name|dtemp
decl_stmt|;
name|l_fp
name|now
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBSCF_H
name|char
modifier|*
name|fmri
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_LIBSCF_H */
comment|/* 	 * Update the system state variables. We do this very carefully, 	 * as the poll interval might need to be clamped differently. 	 */
name|sys_peer
operator|=
name|peer
expr_stmt|;
name|sys_epoch
operator|=
name|peer
operator|->
name|epoch
expr_stmt|;
if|if
condition|(
name|sys_poll
operator|<
name|peer
operator|->
name|minpoll
condition|)
name|sys_poll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
if|if
condition|(
name|sys_poll
operator|>
name|peer
operator|->
name|maxpoll
condition|)
name|sys_poll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|sys_poll
argument_list|)
expr_stmt|;
name|sys_stratum
operator|=
name|min
argument_list|(
name|peer
operator|->
name|stratum
operator|+
literal|1
argument_list|,
name|STRATUM_UNSPEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|==
name|STRATUM_REFCLOCK
operator|||
name|peer
operator|->
name|stratum
operator|==
name|STRATUM_UNSPEC
condition|)
name|sys_refid
operator|=
name|peer
operator|->
name|refid
expr_stmt|;
else|else
name|sys_refid
operator|=
name|addr2refid
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
comment|/* 	 * Root Dispersion (E) is defined (in RFC 5905) as: 	 * 	 * E = p.epsilon_r + p.epsilon + p.psi + PHI*(s.t - p.t) + |THETA| 	 * 	 * where: 	 *  p.epsilon_r is the PollProc's root dispersion 	 *  p.epsilon   is the PollProc's dispersion 	 *  p.psi       is the PollProc's jitter 	 *  THETA       is the combined offset 	 * 	 * NB: Think Hard about where these numbers come from and 	 * what they mean.  When did peer->update happen?  Has anything 	 * interesting happened since then?  What values are the most 	 * defensible?  Why? 	 * 	 * DLM thinks this equation is probably the best of all worse choices. 	 */
name|dtemp
operator|=
name|peer
operator|->
name|rootdisp
operator|+
name|peer
operator|->
name|disp
operator|+
name|sys_jitter
operator|+
name|clock_phi
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
operator|+
name|fabs
argument_list|(
name|sys_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
name|sys_mindisp
condition|)
name|sys_rootdisp
operator|=
name|dtemp
expr_stmt|;
else|else
name|sys_rootdisp
operator|=
name|sys_mindisp
expr_stmt|;
name|sys_rootdelay
operator|=
name|peer
operator|->
name|delay
operator|+
name|peer
operator|->
name|rootdelay
expr_stmt|;
name|sys_reftime
operator|=
name|peer
operator|->
name|dst
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_update: at %lu sample %lu associd %d\n"
argument_list|,
name|current_time
argument_list|,
name|peer
operator|->
name|epoch
argument_list|,
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Comes now the moment of truth. Crank the clock discipline and 	 * see what comes out. 	 */
switch|switch
condition|(
name|local_clock
argument_list|(
name|peer
argument_list|,
name|sys_offset
argument_list|)
condition|)
block|{
comment|/* 	 * Clock exceeds panic threshold. Life as we know it ends. 	 */
case|case
operator|-
literal|1
case|:
ifdef|#
directive|ifdef
name|HAVE_LIBSCF_H
comment|/* 		 * For Solaris enter the maintenance mode. 		 */
if|if
condition|(
operator|(
name|fmri
operator|=
name|getenv
argument_list|(
literal|"SMF_FMRI"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|smf_maintain_instance
argument_list|(
name|fmri
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"smf_maintain_instance: %s\n"
argument_list|,
name|scf_strerror
argument_list|(
name|scf_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Sleep until SMF kills us. 			 */
for|for
control|(
init|;
condition|;
control|)
name|pause
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_LIBSCF_H */
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* not reached */
comment|/* 	 * Clock was stepped. Flush all time values of all peers. 	 */
case|case
literal|2
case|:
name|clear_all
argument_list|()
expr_stmt|;
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"STEP"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdisp
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_reftime
argument_list|)
expr_stmt|;
name|sys_jitter
operator|=
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
expr_stmt|;
name|leapsec_reset_frame
argument_list|()
expr_stmt|;
break|break;
comment|/* 	 * Clock was slewed. Handle the leapsecond stuff. 	 */
case|case
literal|1
case|:
comment|/* 		 * If this is the first time the clock is set, reset the 		 * leap bits. If crypto, the timer will goose the setup 		 * process. 		 */
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
condition|)
block|{
name|sys_leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|crypto_flags
condition|)
name|crypto_update
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 			 * If our parent process is waiting for the 			 * first clock sync, send them home satisfied. 			 */
ifdef|#
directive|ifdef
name|HAVE_WORKING_FORK
if|if
condition|(
name|waitsync_fd_to_close
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|waitsync_fd_to_close
argument_list|)
expr_stmt|;
name|waitsync_fd_to_close
operator|=
operator|-
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"notified parent --wait-sync is done\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_WORKING_FORK */
block|}
comment|/* 		 * If there is no leap second pending and the number of 		 * survivor leap bits is greater than half the number of 		 * survivors, try to schedule a leap for the end of the 		 * current month. (This only works if no leap second for 		 * that range is in the table, so doing this more than 		 * once is mostly harmless.) 		 */
if|if
condition|(
name|leapsec
operator|==
name|LSPROX_NOWARN
condition|)
block|{
if|if
condition|(
name|leap_vote_ins
operator|>
name|leap_vote_del
operator|&&
name|leap_vote_ins
operator|>
name|sys_survivors
operator|/
literal|2
condition|)
block|{
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|leapsec_add_dyn
argument_list|(
name|TRUE
argument_list|,
name|now
operator|.
name|l_ui
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leap_vote_del
operator|>
name|leap_vote_ins
operator|&&
name|leap_vote_del
operator|>
name|sys_survivors
operator|/
literal|2
condition|)
block|{
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|leapsec_add_dyn
argument_list|(
name|FALSE
argument_list|,
name|now
operator|.
name|l_ui
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* 	 * Popcorn spike or step threshold exceeded. Pretend it never 	 * happened. 	 */
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * poll_update - update peer poll interval  */
end_comment

begin_function
name|void
name|poll_update
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|u_char
name|mpoll
parameter_list|)
block|{
name|u_long
name|next
decl_stmt|,
name|utemp
decl_stmt|;
name|u_char
name|hpoll
decl_stmt|;
comment|/* 	 * This routine figures out when the next poll should be sent. 	 * That turns out to be wickedly complicated. One problem is 	 * that sometimes the time for the next poll is in the past when 	 * the poll interval is reduced. We watch out for races here 	 * between the receive process and the poll process. 	 * 	 * Clamp the poll interval between minpoll and maxpoll. 	 */
name|hpoll
operator|=
name|max
argument_list|(
name|min
argument_list|(
name|peer
operator|->
name|maxpoll
argument_list|,
name|mpoll
argument_list|)
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * If during the crypto protocol the poll interval has changed, 	 * the lifetimes in the key list are probably bogus. Purge the 	 * the key list and regenerate it later. 	 */
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
operator|)
operator|&&
name|hpoll
operator|!=
name|peer
operator|->
name|hpoll
condition|)
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
name|peer
operator|->
name|hpoll
operator|=
name|hpoll
expr_stmt|;
comment|/* 	 * There are three variables important for poll scheduling, the 	 * current time (current_time), next scheduled time (nextdate) 	 * and the earliest time (utemp). The earliest time is 2 s 	 * seconds, but could be more due to rate management. When 	 * sending in a burst, use the earliest time. When not in a 	 * burst but with a reply pending, send at the earliest time 	 * unless the next scheduled time has not advanced. This can 	 * only happen if multiple replies are pending in the same 	 * response interval. Otherwise, send at the later of the next 	 * scheduled time and the earliest time. 	 * 	 * Now we figure out if there is an override. If a burst is in 	 * progress and we get called from the receive process, just 	 * slink away. If called from the poll process, delay 1 s for a 	 * reference clock, otherwise 2 s. 	 */
name|utemp
operator|=
name|current_time
operator|+
name|max
argument_list|(
name|peer
operator|->
name|throttle
operator|-
operator|(
name|NTP_SHIFT
operator|-
literal|1
operator|)
operator|*
operator|(
literal|1
operator|<<
name|peer
operator|->
name|minpoll
operator|)
argument_list|,
name|ntp_minpkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|>
name|current_time
condition|)
return|return;
ifdef|#
directive|ifdef
name|REFCLOCK
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|peer
operator|->
name|nextdate
operator|=
name|current_time
operator|+
name|RESP_DELAY
expr_stmt|;
endif|#
directive|endif
comment|/* REFCLOCK */
else|else
name|peer
operator|->
name|nextdate
operator|=
name|utemp
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * If a burst is not in progress and a crypto response message 	 * is pending, delay 2 s, but only if this is a new interval. 	 */
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|>
name|current_time
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|+
name|ntp_minpkt
operator|!=
name|utemp
condition|)
name|peer
operator|->
name|nextdate
operator|=
name|utemp
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|nextdate
operator|=
name|utemp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 	 * The ordinary case. If a retry, use minpoll; if unreachable, 	 * use host poll; otherwise, use the minimum of host and peer 	 * polls; In other words, oversampling is okay but 	 * understampling is evil. Use the maximum of this value and the 	 * headway. If the average headway is greater than the headway 	 * threshold, increase the headway by the minimum interval. 	 */
block|}
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|retry
operator|>
literal|0
condition|)
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|reach
operator|)
condition|)
name|hpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
else|else
name|hpoll
operator|=
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|next
operator|=
literal|1
operator|<<
name|hpoll
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* REFCLOCK */
name|next
operator|=
operator|(
operator|(
literal|0x1000UL
operator||
operator|(
name|ntp_random
argument_list|()
operator|&
literal|0x0ff
operator|)
operator|)
operator|<<
name|hpoll
operator|)
operator|>>
literal|12
expr_stmt|;
name|next
operator|+=
name|peer
operator|->
name|outdate
expr_stmt|;
if|if
condition|(
name|next
operator|>
name|utemp
condition|)
name|peer
operator|->
name|nextdate
operator|=
name|next
expr_stmt|;
else|else
name|peer
operator|->
name|nextdate
operator|=
name|utemp
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|throttle
operator|>
operator|(
literal|1
operator|<<
name|peer
operator|->
name|minpoll
operator|)
condition|)
name|peer
operator|->
name|nextdate
operator|+=
name|ntp_minpkt
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"poll_update: at %lu %s poll %d burst %d retry %d head %d early %lu next %lu\n"
operator|,
name|current_time
operator|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|peer
operator|->
name|hpoll
operator|,
name|peer
operator|->
name|burst
operator|,
name|peer
operator|->
name|retry
operator|,
name|peer
operator|->
name|throttle
operator|,
name|utemp
operator|-
name|current_time
operator|,
name|peer
operator|->
name|nextdate
operator|-
name|current_time
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * peer_clear - clear peer filter registers.  See Section 3.4.8 of the  * spec.  */
end_comment

begin_function
name|void
name|peer_clear
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure */
specifier|const
name|char
modifier|*
name|ident
comment|/* tally lights */
parameter_list|)
block|{
name|u_char
name|u
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * If cryptographic credentials have been acquired, toss them to 	 * Valhalla. Note that autokeys are ephemeral, in that they are 	 * tossed immediately upon use. Therefore, the keylist can be 	 * purged anytime without needing to preserve random keys. Note 	 * that, if the peer is purged, the cryptographic variables are 	 * purged, too. This makes it much harder to sneak in some 	 * unauthenticated data in the clock filter. 	 */
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|iffval
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|cookval
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|recval
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|encrypt
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|sndval
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|cmmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|subject
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|issuer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 	 * Clear all values, including the optional crypto values above. 	 */
name|memset
argument_list|(
name|CLEAR_TO_ZERO
argument_list|(
name|peer
argument_list|)
argument_list|,
literal|0
argument_list|,
name|LEN_CLEAR_TO_ZERO
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|disp
operator|=
name|MAXDISPERSE
expr_stmt|;
name|peer
operator|->
name|flash
operator|=
name|peer_unfit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|jitter
operator|=
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
expr_stmt|;
comment|/* 	 * If interleave mode, initialize the alternate origin switch. 	 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_XLEAVE
condition|)
name|peer
operator|->
name|flip
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|NTP_SHIFT
condition|;
name|u
operator|++
control|)
block|{
name|peer
operator|->
name|filter_order
index|[
name|u
index|]
operator|=
name|u
expr_stmt|;
name|peer
operator|->
name|filter_disp
index|[
name|u
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|)
condition|)
block|{
endif|#
directive|endif
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|ident
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
block|}
endif|#
directive|endif
comment|/* 	 * During initialization use the association count to spread out 	 * the polls at one-second intervals. Passive associations' 	 * first poll is delayed by the "discard minimum" to avoid rate 	 * limiting. Other post-startup new or cleared associations 	 * randomize the first poll over the minimum poll interval to 	 * avoid implosion. 	 */
name|peer
operator|->
name|nextdate
operator|=
name|peer
operator|->
name|update
operator|=
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|initializing
condition|)
block|{
name|peer
operator|->
name|nextdate
operator|+=
name|peer_associations
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MODE_PASSIVE
operator|==
name|peer
operator|->
name|hmode
condition|)
block|{
name|peer
operator|->
name|nextdate
operator|+=
name|ntp_minpkt
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|nextdate
operator|+=
name|ntp_random
argument_list|()
operator|%
name|peer
operator|->
name|minpoll
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
name|peer
operator|->
name|refresh
operator|=
name|current_time
operator|+
operator|(
literal|1
operator|<<
name|NTP_REFRESH
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"peer_clear: at %ld next %ld associd %d refid %s\n"
argument_list|,
name|current_time
argument_list|,
name|peer
operator|->
name|nextdate
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * clock_filter - add incoming clock sample to filter register and run  *		  the filter procedure to find the best sample.  */
end_comment

begin_function
name|void
name|clock_filter
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample_offset
parameter_list|,
comment|/* clock offset */
name|double
name|sample_delay
parameter_list|,
comment|/* roundtrip delay */
name|double
name|sample_disp
comment|/* dispersion */
parameter_list|)
block|{
name|double
name|dst
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* distance vector */
name|int
name|ord
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* index vector */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|;
name|double
name|dtemp
decl_stmt|,
name|etemp
decl_stmt|;
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* 	 * A sample consists of the offset, delay, dispersion and epoch 	 * of arrival. The offset and delay are determined by the on- 	 * wire protocol. The dispersion grows from the last outbound 	 * packet to the arrival of this one increased by the sum of the 	 * peer precision and the system precision as required by the 	 * error budget. First, shift the new arrival into the shift 	 * register discarding the oldest one. 	 */
name|j
operator|=
name|peer
operator|->
name|filter_nextpt
expr_stmt|;
name|peer
operator|->
name|filter_offset
index|[
name|j
index|]
operator|=
name|sample_offset
expr_stmt|;
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
operator|=
name|sample_delay
expr_stmt|;
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|=
name|sample_disp
expr_stmt|;
name|peer
operator|->
name|filter_epoch
index|[
name|j
index|]
operator|=
name|current_time
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
literal|1
operator|)
operator|%
name|NTP_SHIFT
expr_stmt|;
name|peer
operator|->
name|filter_nextpt
operator|=
name|j
expr_stmt|;
comment|/* 	 * Update dispersions since the last update and at the same 	 * time initialize the distance and index lists. Since samples 	 * become increasingly uncorrelated beyond the Allan intercept, 	 * only under exceptional cases will an older sample be used. 	 * Therefore, the distance list uses a compound metric. If the 	 * dispersion is greater than the maximum dispersion, clamp the 	 * distance at that value. If the time since the last update is 	 * less than the Allan intercept use the delay; otherwise, use 	 * the sum of the delay and dispersion. 	 */
name|dtemp
operator|=
name|clock_phi
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
expr_stmt|;
name|peer
operator|->
name|update
operator|=
name|current_time
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|+=
name|dtemp
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|>=
name|MAXDISPERSE
condition|)
block|{
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
name|dst
index|[
name|i
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|update
operator|-
name|peer
operator|->
name|filter_epoch
index|[
name|j
index|]
operator|>
operator|(
name|u_long
operator|)
name|ULOGTOD
argument_list|(
name|allan_xpt
argument_list|)
condition|)
block|{
name|dst
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
operator|+
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
expr_stmt|;
block|}
else|else
block|{
name|dst
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
expr_stmt|;
block|}
name|ord
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
literal|1
operator|)
operator|%
name|NTP_SHIFT
expr_stmt|;
block|}
comment|/* 	 * If the clock has stabilized, sort the samples by distance.   	 */
if|if
condition|(
name|freq_cnt
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|dst
index|[
name|j
index|]
operator|>
name|dst
index|[
name|i
index|]
condition|)
block|{
name|k
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|j
index|]
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
name|etemp
operator|=
name|dst
index|[
name|j
index|]
expr_stmt|;
name|dst
index|[
name|j
index|]
operator|=
name|dst
index|[
name|i
index|]
expr_stmt|;
name|dst
index|[
name|i
index|]
operator|=
name|etemp
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Copy the index list to the association structure so ntpq 	 * can see it later. Prune the distance list to leave only 	 * samples less than the maximum dispersion, which disfavors 	 * uncorrelated samples older than the Allan intercept. To 	 * further improve the jitter estimate, of the remainder leave 	 * only samples less than the maximum distance, but keep at 	 * least two samples for jitter calculation. 	 */
name|m
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter_order
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|ord
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dst
index|[
name|i
index|]
operator|>=
name|MAXDISPERSE
operator|||
operator|(
name|m
operator|>=
literal|2
operator|&&
name|dst
index|[
name|i
index|]
operator|>=
name|sys_maxdist
operator|)
condition|)
continue|continue;
name|m
operator|++
expr_stmt|;
block|}
comment|/* 	 * Compute the dispersion and jitter. The dispersion is weighted 	 * exponentially by NTP_FWEIGHT (0.5) so it is normalized close 	 * to 1.0. The jitter is the RMS differences relative to the 	 * lowest delay sample. 	 */
name|peer
operator|->
name|disp
operator|=
name|peer
operator|->
name|jitter
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|ord
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|j
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|peer
operator|->
name|disp
operator|=
name|NTP_FWEIGHT
operator|*
operator|(
name|peer
operator|->
name|disp
operator|+
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|m
condition|)
name|peer
operator|->
name|jitter
operator|+=
name|DIFF
argument_list|(
name|peer
operator|->
name|filter_offset
index|[
name|j
index|]
argument_list|,
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If no acceptable samples remain in the shift register, 	 * quietly tiptoe home leaving only the dispersion. Otherwise, 	 * save the offset, delay and jitter. Note the jitter must not 	 * be less than the precision. 	 */
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|clock_select
argument_list|()
expr_stmt|;
return|return;
block|}
name|etemp
operator|=
name|fabs
argument_list|(
name|peer
operator|->
name|offset
operator|-
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|peer
operator|->
name|offset
operator|=
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
expr_stmt|;
name|peer
operator|->
name|delay
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|1
condition|)
name|peer
operator|->
name|jitter
operator|/=
name|m
operator|-
literal|1
expr_stmt|;
name|peer
operator|->
name|jitter
operator|=
name|max
argument_list|(
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
argument_list|,
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the the new sample and the current sample are both valid 	 * and the difference between their offsets exceeds CLOCK_SGATE 	 * (3) times the jitter and the interval between them is less 	 * than twice the host poll interval, consider the new sample 	 * a popcorn spike and ignore it. 	 */
if|if
condition|(
name|peer
operator|->
name|disp
operator|<
name|sys_maxdist
operator|&&
name|peer
operator|->
name|filter_disp
index|[
name|k
index|]
operator|<
name|sys_maxdist
operator|&&
name|etemp
operator|>
name|CLOCK_SGATE
operator|*
name|peer
operator|->
name|jitter
operator|&&
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
operator|-
name|peer
operator|->
name|epoch
operator|<
literal|2.
operator|*
name|ULOGTOD
argument_list|(
name|peer
operator|->
name|hpoll
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"%.6f s"
argument_list|,
name|etemp
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|PEVNT_POPCORN
argument_list|,
name|peer
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * A new minimum sample is useful only if it is later than the 	 * last one used. In this design the maximum lifetime of any 	 * sample is not greater than eight times the poll interval, so 	 * the maximum interval between minimum samples is eight 	 * packets. 	 */
if|if
condition|(
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
operator|<=
name|peer
operator|->
name|epoch
condition|)
block|{
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"clock_filter: old sample %lu\n"
argument_list|,
name|current_time
operator|-
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|peer
operator|->
name|epoch
operator|=
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
expr_stmt|;
comment|/* 	 * The mitigated sample statistics are saved for later 	 * processing. If not synchronized or not in a burst, tickle the 	 * clock select algorithm. 	 */
name|record_peer_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|disp
argument_list|,
name|peer
operator|->
name|jitter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: n %d off %.6f del %.6f dsp %.6f jit %.6f\n"
argument_list|,
name|m
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|disp
argument_list|,
name|peer
operator|->
name|jitter
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
operator|||
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
condition|)
name|clock_select
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_select - find the pick-of-the-litter clock  *  * LOCKCLOCK: (1) If the local clock is the prefer peer, it will always  * be enabled, even if declared falseticker, (2) only the prefer peer  * can be selected as the system peer, (3) if the external source is  * down, the system leap bits are set to 11 and the stratum set to  * infinity.  */
end_comment

begin_function
name|void
name|clock_select
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|int
name|nlist
decl_stmt|,
name|nl2
decl_stmt|;
name|int
name|allow
decl_stmt|;
name|int
name|speer
decl_stmt|;
name|double
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|;
name|double
name|high
decl_stmt|,
name|low
decl_stmt|;
name|double
name|speermet
decl_stmt|;
name|double
name|orphmet
init|=
literal|2.0
operator|*
name|U_INT32_MAX
decl_stmt|;
comment|/* 2x is greater than */
name|struct
name|endpoint
name|endp
decl_stmt|;
name|struct
name|peer
modifier|*
name|osys_peer
decl_stmt|;
name|struct
name|peer
modifier|*
name|sys_prefer
init|=
name|NULL
decl_stmt|;
comment|/* prefer peer */
name|struct
name|peer
modifier|*
name|typesystem
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typeorphan
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
name|struct
name|peer
modifier|*
name|typeacts
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typelocal
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typepps
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* REFCLOCK */
specifier|static
name|struct
name|endpoint
modifier|*
name|endpoint
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
modifier|*
name|indx
init|=
name|NULL
decl_stmt|;
specifier|static
name|peer_select
modifier|*
name|peers
init|=
name|NULL
decl_stmt|;
specifier|static
name|u_int
name|endpoint_size
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|peers_size
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|indx_size
init|=
literal|0
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
comment|/* 	 * Initialize and create endpoint, index and peer lists big 	 * enough to handle all associations. 	 */
name|osys_peer
operator|=
name|sys_peer
expr_stmt|;
name|sys_survivors
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKCLOCK
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"DOWN"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKCLOCK */
comment|/* 	 * Allocate dynamic space depending on the number of 	 * associations. 	 */
name|nlist
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|peer
operator|=
name|peer_list
init|;
name|peer
operator|!=
name|NULL
condition|;
name|peer
operator|=
name|peer
operator|->
name|p_link
control|)
name|nlist
operator|++
expr_stmt|;
name|endpoint_size
operator|=
name|ALIGNED_SIZE
argument_list|(
name|nlist
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|endpoint
argument_list|)
argument_list|)
expr_stmt|;
name|peers_size
operator|=
name|ALIGNED_SIZE
argument_list|(
name|nlist
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|peers
argument_list|)
argument_list|)
expr_stmt|;
name|indx_size
operator|=
name|ALIGNED_SIZE
argument_list|(
name|nlist
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|indx
argument_list|)
argument_list|)
expr_stmt|;
name|octets
operator|=
name|endpoint_size
operator|+
name|peers_size
operator|+
name|indx_size
expr_stmt|;
name|endpoint
operator|=
name|erealloc
argument_list|(
name|endpoint
argument_list|,
name|octets
argument_list|)
expr_stmt|;
name|peers
operator|=
name|INC_ALIGNED_PTR
argument_list|(
name|endpoint
argument_list|,
name|endpoint_size
argument_list|)
expr_stmt|;
name|indx
operator|=
name|INC_ALIGNED_PTR
argument_list|(
name|peers
argument_list|,
name|peers_size
argument_list|)
expr_stmt|;
comment|/* 	 * Initially, we populate the island with all the rifraff peers 	 * that happen to be lying around. Those with seriously 	 * defective clocks are immediately booted off the island. Then, 	 * the falsetickers are culled and put to sea. The truechimers 	 * remaining are subject to repeated rounds where the most 	 * unpopular at each round is kicked off. When the population 	 * has dwindled to sys_minclock, the survivors split a million 	 * bucks and collectively crank the chimes. 	 */
name|nlist
operator|=
name|nl2
operator|=
literal|0
expr_stmt|;
comment|/* none yet */
for|for
control|(
name|peer
operator|=
name|peer_list
init|;
name|peer
operator|!=
name|NULL
condition|;
name|peer
operator|=
name|peer
operator|->
name|p_link
control|)
block|{
name|peer
operator|->
name|new_status
operator|=
name|CTL_PST_SEL_REJECT
expr_stmt|;
comment|/* 		 * Leave the island immediately if the peer is 		 * unfit to synchronize. 		 */
if|if
condition|(
name|peer_unfit
argument_list|(
name|peer
argument_list|)
condition|)
continue|continue;
comment|/* 		 * If this peer is an orphan parent, elect the 		 * one with the lowest metric defined as the 		 * IPv4 address or the first 64 bits of the 		 * hashed IPv6 address.  To ensure convergence 		 * on the same selected orphan, consider as 		 * well that this system may have the lowest 		 * metric and be the orphan parent.  If this 		 * system wins, sys_peer will be NULL to trigger 		 * orphan mode in timer(). 		 */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|==
name|sys_orphan
condition|)
block|{
name|u_int32
name|localmet
decl_stmt|;
name|u_int32
name|peermet
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|dstadr
operator|!=
name|NULL
condition|)
name|localmet
operator|=
name|ntohl
argument_list|(
name|peer
operator|->
name|dstadr
operator|->
name|addr_refid
argument_list|)
expr_stmt|;
else|else
name|localmet
operator|=
name|U_INT32_MAX
expr_stmt|;
name|peermet
operator|=
name|ntohl
argument_list|(
name|addr2refid
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peermet
operator|<
name|localmet
operator|&&
name|peermet
operator|<
name|orphmet
condition|)
block|{
name|typeorphan
operator|=
name|peer
expr_stmt|;
name|orphmet
operator|=
name|peermet
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * If this peer could have the orphan parent 		 * as a synchronization ancestor, exclude it 		 * from selection to avoid forming a  		 * synchronization loop within the orphan mesh, 		 * triggering stratum climb to infinity  		 * instability.  Peers at stratum higher than 		 * the orphan stratum could have the orphan 		 * parent in ancestry so are excluded. 		 * See http://bugs.ntp.org/2050 		 */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>
name|sys_orphan
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 		 * The following are special cases. We deal 		 * with them later. 		 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
block|{
switch|switch
condition|(
name|peer
operator|->
name|refclktype
condition|)
block|{
case|case
name|REFCLK_LOCALCLOCK
case|:
if|if
condition|(
name|current_time
operator|>
name|orphwait
operator|&&
name|typelocal
operator|==
name|NULL
condition|)
name|typelocal
operator|=
name|peer
expr_stmt|;
continue|continue;
case|case
name|REFCLK_ACTS
case|:
if|if
condition|(
name|current_time
operator|>
name|orphwait
operator|&&
name|typeacts
operator|==
name|NULL
condition|)
name|typeacts
operator|=
name|peer
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
comment|/* 		 * If we get this far, the peer can stay on the 		 * island, but does not yet have the immunity 		 * idol. 		 */
name|peer
operator|->
name|new_status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|f
operator|=
name|root_distance
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peers
index|[
name|nlist
index|]
operator|.
name|peer
operator|=
name|peer
expr_stmt|;
name|peers
index|[
name|nlist
index|]
operator|.
name|error
operator|=
name|peer
operator|->
name|jitter
expr_stmt|;
name|peers
index|[
name|nlist
index|]
operator|.
name|synch
operator|=
name|f
expr_stmt|;
name|nlist
operator|++
expr_stmt|;
comment|/* 		 * Insert each interval endpoint on the unsorted 		 * endpoint[] list. 		 */
name|e
operator|=
name|peer
operator|->
name|offset
expr_stmt|;
name|endpoint
index|[
name|nl2
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* lower end */
name|endpoint
index|[
name|nl2
index|]
operator|.
name|val
operator|=
name|e
operator|-
name|f
expr_stmt|;
name|nl2
operator|++
expr_stmt|;
name|endpoint
index|[
name|nl2
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
comment|/* upper end */
name|endpoint
index|[
name|nl2
index|]
operator|.
name|val
operator|=
name|e
operator|+
name|f
expr_stmt|;
name|nl2
operator|++
expr_stmt|;
block|}
comment|/* 	 * Construct sorted indx[] of endpoint[] indexes ordered by 	 * offset. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl2
condition|;
name|i
operator|++
control|)
name|indx
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl2
condition|;
name|i
operator|++
control|)
block|{
name|endp
operator|=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
expr_stmt|;
name|e
operator|=
name|endp
operator|.
name|val
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nl2
condition|;
name|j
operator|++
control|)
block|{
name|endp
operator|=
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|endp
operator|.
name|val
operator|<
name|e
condition|)
block|{
name|e
operator|=
name|endp
operator|.
name|val
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|!=
name|i
condition|)
block|{
name|j
operator|=
name|indx
index|[
name|k
index|]
expr_stmt|;
name|indx
index|[
name|k
index|]
operator|=
name|indx
index|[
name|i
index|]
expr_stmt|;
name|indx
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl2
condition|;
name|i
operator|++
control|)
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"select: endpoint %2d %.6f\n"
operator|,
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
operator|,
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * This is the actual algorithm that cleaves the truechimers 	 * from the falsetickers. The original algorithm was described 	 * in Keith Marzullo's dissertation, but has been modified for 	 * better accuracy. 	 * 	 * Briefly put, we first assume there are no falsetickers, then 	 * scan the candidate list first from the low end upwards and 	 * then from the high end downwards. The scans stop when the 	 * number of intersections equals the number of candidates less 	 * the number of falsetickers. If this doesn't happen for a 	 * given number of falsetickers, we bump the number of 	 * falsetickers and try again. If the number of falsetickers 	 * becomes equal to or greater than half the number of 	 * candidates, the Albanians have won the Byzantine wars and 	 * correct synchronization is not possible. 	 * 	 * Here, nlist is the number of candidates and allow is the 	 * number of falsetickers. Upon exit, the truechimers are the 	 * survivors with offsets not less than low and not greater than 	 * high. There may be none of them. 	 */
name|low
operator|=
literal|1e9
expr_stmt|;
name|high
operator|=
operator|-
literal|1e9
expr_stmt|;
for|for
control|(
name|allow
operator|=
literal|0
init|;
literal|2
operator|*
name|allow
operator|<
name|nlist
condition|;
name|allow
operator|++
control|)
block|{
comment|/* 		 * Bound the interval (low, high) as the smallest  		 * interval containing points from the most sources. 		 */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl2
condition|;
name|i
operator|++
control|)
block|{
name|low
operator|=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
expr_stmt|;
name|n
operator|-=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|nlist
operator|-
name|allow
condition|)
break|break;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nl2
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|high
operator|=
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
operator|.
name|val
expr_stmt|;
name|n
operator|+=
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|nlist
operator|-
name|allow
condition|)
break|break;
block|}
comment|/* 		 * If an interval containing truechimers is found, stop. 		 * If not, increase the number of falsetickers and go 		 * around again. 		 */
if|if
condition|(
name|high
operator|>
name|low
condition|)
break|break;
block|}
comment|/* 	 * Clustering algorithm. Whittle candidate list of falsetickers, 	 * who leave the island immediately. The TRUE peer is always a 	 * truechimer. We must leave at least one peer to collect the 	 * million bucks. 	 * 	 * We assert the correct time is contained in the interval, but 	 * the best offset estimate for the interval might not be 	 * contained in the interval. For this purpose, a truechimer is 	 * defined as the midpoint of an interval that overlaps the  	 * intersection interval. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|double
name|h
decl_stmt|;
name|peer
operator|=
name|peers
index|[
name|i
index|]
operator|.
name|peer
expr_stmt|;
name|h
operator|=
name|peers
index|[
name|i
index|]
operator|.
name|synch
expr_stmt|;
if|if
condition|(
operator|(
name|high
operator|<=
name|low
operator|||
name|peer
operator|->
name|offset
operator|+
name|h
operator|<
name|low
operator|||
name|peer
operator|->
name|offset
operator|-
name|h
operator|>
name|high
operator|)
operator|&&
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_TRUE
operator|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 		 * Eligible PPS peers must survive the intersection 		 * algorithm. Use the first one found, but don't 		 * include any of them in the cluster population. 		 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PPS
condition|)
block|{
if|if
condition|(
name|typepps
operator|==
name|NULL
condition|)
name|typepps
operator|=
name|peer
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
if|if
condition|(
name|j
operator|!=
name|i
condition|)
name|peers
index|[
name|j
index|]
operator|=
name|peers
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|nlist
operator|=
name|j
expr_stmt|;
comment|/* 	 * If no survivors remain at this point, check if the modem  	 * driver, local driver or orphan parent in that order. If so, 	 * nominate the first one found as the only survivor. 	 * Otherwise, give up and leave the island to the rats. 	 */
if|if
condition|(
name|nlist
operator|==
literal|0
condition|)
block|{
name|peers
index|[
literal|0
index|]
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|peers
index|[
literal|0
index|]
operator|.
name|synch
operator|=
name|sys_mindisp
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|typeacts
operator|!=
name|NULL
condition|)
block|{
name|peers
index|[
literal|0
index|]
operator|.
name|peer
operator|=
name|typeacts
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typelocal
operator|!=
name|NULL
condition|)
block|{
name|peers
index|[
literal|0
index|]
operator|.
name|peer
operator|=
name|typelocal
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* REFCLOCK */
if|if
condition|(
name|typeorphan
operator|!=
name|NULL
condition|)
block|{
name|peers
index|[
literal|0
index|]
operator|.
name|peer
operator|=
name|typeorphan
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Mark the candidates at this point as truechimers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peers
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|new_status
operator|=
name|CTL_PST_SEL_SELCAND
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"select: survivor %s %f\n"
operator|,
name|stoa
argument_list|(
operator|&
name|peers
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|peers
index|[
name|i
index|]
operator|.
name|synch
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now, vote outlyers off the island by select jitter weighted 	 * by root distance. Continue voting as long as there are more 	 * than sys_minclock survivors and the select jitter of the peer 	 * with the worst metric is greater than the minimum peer 	 * jitter. Stop if we are about to discard a TRUE or PREFER  	 * peer, who of course have the immunity idol. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|d
operator|=
literal|1e9
expr_stmt|;
name|e
operator|=
operator|-
literal|1e9
expr_stmt|;
name|g
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|peers
index|[
name|i
index|]
operator|.
name|error
operator|<
name|d
condition|)
name|d
operator|=
name|peers
index|[
name|i
index|]
operator|.
name|error
expr_stmt|;
name|peers
index|[
name|i
index|]
operator|.
name|seljit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
literal|1
condition|)
block|{
name|f
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
name|f
operator|+=
name|DIFF
argument_list|(
name|peers
index|[
name|j
index|]
operator|.
name|peer
operator|->
name|offset
argument_list|,
name|peers
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|offset
argument_list|)
expr_stmt|;
name|peers
index|[
name|i
index|]
operator|.
name|seljit
operator|=
name|SQRT
argument_list|(
name|f
operator|/
operator|(
name|nlist
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peers
index|[
name|i
index|]
operator|.
name|seljit
operator|*
name|peers
index|[
name|i
index|]
operator|.
name|synch
operator|>
name|e
condition|)
block|{
name|g
operator|=
name|peers
index|[
name|i
index|]
operator|.
name|seljit
expr_stmt|;
name|e
operator|=
name|peers
index|[
name|i
index|]
operator|.
name|seljit
operator|*
name|peers
index|[
name|i
index|]
operator|.
name|synch
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
block|}
name|g
operator|=
name|max
argument_list|(
name|g
argument_list|,
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlist
operator|<=
name|max
argument_list|(
literal|1
argument_list|,
name|sys_minclock
argument_list|)
operator|||
name|g
operator|<=
name|d
operator|||
operator|(
operator|(
name|FLAG_TRUE
operator||
name|FLAG_PREFER
operator|)
operator|&
name|peers
index|[
name|k
index|]
operator|.
name|peer
operator|->
name|flags
operator|)
condition|)
break|break;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"select: drop %s seljit %.6f jit %.6f\n"
operator|,
name|ntoa
argument_list|(
operator|&
name|peers
index|[
name|k
index|]
operator|.
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|g
operator|,
name|d
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
name|sys_maxclock
condition|)
name|peers
index|[
name|k
index|]
operator|.
name|peer
operator|->
name|new_status
operator|=
name|CTL_PST_SEL_EXCESS
expr_stmt|;
for|for
control|(
name|j
operator|=
name|k
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
name|peers
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|peers
index|[
name|j
index|]
expr_stmt|;
name|nlist
operator|--
expr_stmt|;
block|}
comment|/* 	 * What remains is a list usually not greater than sys_minclock 	 * peers. Note that unsynchronized peers cannot survive this 	 * far.  Count and mark these survivors. 	 * 	 * While at it, count the number of leap warning bits found. 	 * This will be used later to vote the system leap warning bit. 	 * If a leap warning bit is found on a reference clock, the vote 	 * is always won. 	 * 	 * Choose the system peer using a hybrid metric composed of the 	 * selection jitter scaled by the root distance augmented by 	 * stratum scaled by sys_mindisp (.001 by default). The goal of 	 * the small stratum factor is to avoid clockhop between a 	 * reference clock and a network peer which has a refclock and 	 * is using an older ntpd, which does not floor sys_rootdisp at 	 * sys_mindisp. 	 * 	 * In contrast, ntpd 4.2.6 and earlier used stratum primarily 	 * in selecting the system peer, using a weight of 1 second of 	 * additional root distance per stratum.  This heavy bias is no 	 * longer appropriate, as the scaled root distance provides a 	 * more rational metric carrying the cumulative error budget. 	 */
name|e
operator|=
literal|1e9
expr_stmt|;
name|speer
operator|=
literal|0
expr_stmt|;
name|leap_vote_ins
operator|=
literal|0
expr_stmt|;
name|leap_vote_del
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peers
index|[
name|i
index|]
operator|.
name|peer
expr_stmt|;
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|new_status
operator|=
name|CTL_PST_SEL_SYNCCAND
expr_stmt|;
name|sys_survivors
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|leap
operator|==
name|LEAP_ADDSECOND
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|leap_vote_ins
operator|=
name|nlist
expr_stmt|;
elseif|else
if|if
condition|(
name|leap_vote_ins
operator|<
name|nlist
condition|)
name|leap_vote_ins
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|leap
operator|==
name|LEAP_DELSECOND
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|leap_vote_del
operator|=
name|nlist
expr_stmt|;
elseif|else
if|if
condition|(
name|leap_vote_del
operator|<
name|nlist
condition|)
name|leap_vote_del
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
name|sys_prefer
operator|=
name|peer
expr_stmt|;
name|speermet
operator|=
name|peers
index|[
name|i
index|]
operator|.
name|seljit
operator|*
name|peers
index|[
name|i
index|]
operator|.
name|synch
operator|+
name|peer
operator|->
name|stratum
operator|*
name|sys_mindisp
expr_stmt|;
if|if
condition|(
name|speermet
operator|<
name|e
condition|)
block|{
name|e
operator|=
name|speermet
expr_stmt|;
name|speer
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * Unless there are at least sys_misane survivors, leave the 	 * building dark. Otherwise, do a clockhop dance. Ordinarily, 	 * use the selected survivor speer. However, if the current 	 * system peer is not speer, stay with the current system peer 	 * as long as it doesn't get too old or too ugly. 	 */
if|if
condition|(
name|nlist
operator|>
literal|0
operator|&&
name|nlist
operator|>=
name|sys_minsane
condition|)
block|{
name|double
name|x
decl_stmt|;
name|typesystem
operator|=
name|peers
index|[
name|speer
index|]
operator|.
name|peer
expr_stmt|;
if|if
condition|(
name|osys_peer
operator|==
name|NULL
operator|||
name|osys_peer
operator|==
name|typesystem
condition|)
block|{
name|sys_clockhop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|=
name|fabs
argument_list|(
name|typesystem
operator|->
name|offset
operator|-
name|osys_peer
operator|->
name|offset
argument_list|)
operator|)
operator|<
name|sys_mindisp
condition|)
block|{
if|if
condition|(
name|sys_clockhop
operator|==
literal|0
condition|)
name|sys_clockhop
operator|=
name|sys_mindisp
expr_stmt|;
else|else
name|sys_clockhop
operator|*=
literal|.5
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"select: clockhop %d %.6f %.6f\n"
operator|,
name|j
operator|,
name|x
operator|,
name|sys_clockhop
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|x
argument_list|)
operator|<
name|sys_clockhop
condition|)
name|typesystem
operator|=
name|osys_peer
expr_stmt|;
else|else
name|sys_clockhop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sys_clockhop
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Mitigation rules of the game. We have the pick of the 	 * litter in typesystem if any survivors are left. If 	 * there is a prefer peer, use its offset and jitter. 	 * Otherwise, use the combined offset and jitter of all kitters. 	 */
if|if
condition|(
name|typesystem
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sys_prefer
operator|==
name|NULL
condition|)
block|{
name|typesystem
operator|->
name|new_status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
name|clock_combine
argument_list|(
name|peers
argument_list|,
name|sys_survivors
argument_list|,
name|speer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|typesystem
operator|=
name|sys_prefer
expr_stmt|;
name|sys_clockhop
operator|=
literal|0
expr_stmt|;
name|typesystem
operator|->
name|new_status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
name|sys_offset
operator|=
name|typesystem
operator|->
name|offset
expr_stmt|;
name|sys_jitter
operator|=
name|typesystem
operator|->
name|jitter
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"select: combine offset %.9f jitter %.9f\n"
operator|,
name|sys_offset
operator|,
name|sys_jitter
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 	 * If a PPS driver is lit and the combined offset is less than 	 * 0.4 s, select the driver as the PPS peer and use its offset 	 * and jitter. However, if this is the atom driver, use it only 	 * if there is a prefer peer or there are no survivors and none 	 * are required. 	 */
if|if
condition|(
name|typepps
operator|!=
name|NULL
operator|&&
name|fabs
argument_list|(
name|sys_offset
argument_list|)
operator|<
literal|0.4
operator|&&
operator|(
name|typepps
operator|->
name|refclktype
operator|!=
name|REFCLK_ATOM_PPS
operator|||
operator|(
name|typepps
operator|->
name|refclktype
operator|==
name|REFCLK_ATOM_PPS
operator|&&
operator|(
name|sys_prefer
operator|!=
name|NULL
operator|||
operator|(
name|typesystem
operator|==
name|NULL
operator|&&
name|sys_minsane
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|typesystem
operator|=
name|typepps
expr_stmt|;
name|sys_clockhop
operator|=
literal|0
expr_stmt|;
name|typesystem
operator|->
name|new_status
operator|=
name|CTL_PST_SEL_PPS
expr_stmt|;
name|sys_offset
operator|=
name|typesystem
operator|->
name|offset
expr_stmt|;
name|sys_jitter
operator|=
name|typesystem
operator|->
name|jitter
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"select: pps offset %.9f jitter %.9f\n"
operator|,
name|sys_offset
operator|,
name|sys_jitter
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
comment|/* 	 * If there are no survivors at this point, there is no 	 * system peer. If so and this is an old update, keep the 	 * current statistics, but do not update the clock. 	 */
if|if
condition|(
name|typesystem
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|osys_peer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sys_orphwait
operator|>
literal|0
condition|)
name|orphwait
operator|=
name|current_time
operator|+
name|sys_orphwait
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_NOPEER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|sys_peer
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|peer
operator|=
name|peer_list
init|;
name|peer
operator|!=
name|NULL
condition|;
name|peer
operator|=
name|peer
operator|->
name|p_link
control|)
name|peer
operator|->
name|status
operator|=
name|peer
operator|->
name|new_status
expr_stmt|;
return|return;
block|}
comment|/* 	 * Do not use old data, as this may mess up the clock discipline 	 * stability. 	 */
if|if
condition|(
name|typesystem
operator|->
name|epoch
operator|<=
name|sys_epoch
condition|)
return|return;
comment|/* 	 * We have found the alpha male. Wind the clock. 	 */
if|if
condition|(
name|osys_peer
operator|!=
name|typesystem
condition|)
name|report_event
argument_list|(
name|PEVNT_NEWPEER
argument_list|,
name|typesystem
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|peer
operator|=
name|peer_list
init|;
name|peer
operator|!=
name|NULL
condition|;
name|peer
operator|=
name|peer
operator|->
name|p_link
control|)
name|peer
operator|->
name|status
operator|=
name|peer
operator|->
name|new_status
expr_stmt|;
name|clock_update
argument_list|(
name|typesystem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clock_combine
parameter_list|(
name|peer_select
modifier|*
name|peers
parameter_list|,
comment|/* survivor list */
name|int
name|npeers
parameter_list|,
comment|/* number of survivors */
name|int
name|syspeer
comment|/* index of sys.peer */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
name|w
decl_stmt|;
name|y
operator|=
name|z
operator|=
name|w
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npeers
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
literal|1.
operator|/
name|peers
index|[
name|i
index|]
operator|.
name|synch
expr_stmt|;
name|y
operator|+=
name|x
expr_stmt|;
name|z
operator|+=
name|x
operator|*
name|peers
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|offset
expr_stmt|;
name|w
operator|+=
name|x
operator|*
name|DIFF
argument_list|(
name|peers
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|offset
argument_list|,
name|peers
index|[
name|syspeer
index|]
operator|.
name|peer
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
name|sys_offset
operator|=
name|z
operator|/
name|y
expr_stmt|;
name|sys_jitter
operator|=
name|SQRT
argument_list|(
name|w
operator|/
name|y
operator|+
name|SQUARE
argument_list|(
name|peers
index|[
name|syspeer
index|]
operator|.
name|seljit
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * root_distance - compute synchronization distance from peer to root  */
end_comment

begin_function
specifier|static
name|double
name|root_distance
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|double
name|dtemp
decl_stmt|;
comment|/* 	 * Root Distance (LAMBDA) is defined as: 	 * (delta + DELTA)/2 + epsilon + EPSILON + phi 	 * 	 * where: 	 *  delta   is the round-trip delay 	 *  DELTA   is the root delay 	 *  epsilon is the remote server precision + local precision 	 *	    + (15 usec each second) 	 *  EPSILON is the root dispersion 	 *  phi     is the peer jitter statistic 	 * 	 * NB: Think hard about why we are using these values, and what 	 * the alternatives are, and the various pros/cons. 	 * 	 * DLM thinks these are probably the best choices from any of the 	 * other worse choices. 	 */
name|dtemp
operator|=
operator|(
name|peer
operator|->
name|delay
operator|+
name|peer
operator|->
name|rootdelay
operator|)
operator|/
literal|2
operator|+
name|LOGTOD
argument_list|(
name|peer
operator|->
name|precision
argument_list|)
operator|+
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
operator|+
name|clock_phi
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
operator|+
name|peer
operator|->
name|rootdisp
operator|+
name|peer
operator|->
name|jitter
expr_stmt|;
comment|/* 	 * Careful squeak here. The value returned must be greater than 	 * the minimum root dispersion in order to avoid clockhop with 	 * highly precise reference clocks. Note that the root distance 	 * cannot exceed the sys_maxdist, as this is the cutoff by the 	 * selection algorithm. 	 */
if|if
condition|(
name|dtemp
operator|<
name|sys_mindisp
condition|)
name|dtemp
operator|=
name|sys_mindisp
expr_stmt|;
return|return
operator|(
name|dtemp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * peer_xmit - send packet for persistent association.  */
end_comment

begin_function
specifier|static
name|void
name|peer_xmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* transmit packet */
name|size_t
name|sendlen
decl_stmt|,
name|authlen
decl_stmt|;
name|keyid_t
name|xkeyid
init|=
literal|0
decl_stmt|;
comment|/* transmit key ID */
name|l_fp
name|xmt_tx
decl_stmt|,
name|xmt_ty
decl_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|dstadr
condition|)
comment|/* drop peers without interface */
return|return;
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|peer
operator|->
name|version
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdisp
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdisp
argument_list|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|rec
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|dst
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * If the received packet contains a MAC, the transmitted packet 	 * is authenticated and contains a MAC. If not, the transmitted 	 * packet is not authenticated. 	 * 	 * It is most important when autokey is in use that the local 	 * interface IP address be known before the first packet is 	 * sent. Otherwise, it is not possible to compute a correct MAC 	 * the recipient will accept. Thus, the I/O semantics have to do 	 * a little more work. In particular, the wildcard interface 	 * might not be usable. 	 */
name|sendlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
operator|)
operator|&&
name|peer
operator|->
name|keyid
operator|==
literal|0
condition|)
block|{
else|#
directive|else
comment|/* !AUTOKEY follows */
if|if
condition|(
name|peer
operator|->
name|keyid
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* !AUTOKEY */
comment|/* 		 * Transmit a-priori timestamps 		 */
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flip
operator|==
literal|0
condition|)
block|{
comment|/* basic mode */
name|peer
operator|->
name|aorg
operator|=
name|xmt_tx
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* interleaved modes */
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
condition|)
block|{
comment|/* bcst */
name|HTONL_FP
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flip
operator|>
literal|0
condition|)
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|borg
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
else|else
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|aorg
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* symmetric */
if|if
condition|(
name|peer
operator|->
name|flip
operator|>
literal|0
condition|)
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|borg
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
else|else
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|aorg
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
block|}
block|}
name|peer
operator|->
name|t21_bytes
operator|=
name|sendlen
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|,
name|sys_ttl
index|[
name|peer
operator|->
name|ttl
index|]
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
name|peer
operator|->
name|throttle
operator|+=
operator|(
literal|1
operator|<<
name|peer
operator|->
name|minpoll
operator|)
operator|-
literal|2
expr_stmt|;
comment|/* 		 * Capture a-posteriori timestamps 		 */
name|get_systime
argument_list|(
operator|&
name|xmt_ty
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flip
operator|!=
literal|0
condition|)
block|{
comment|/* interleaved modes */
if|if
condition|(
name|peer
operator|->
name|flip
operator|>
literal|0
condition|)
name|peer
operator|->
name|aorg
operator|=
name|xmt_ty
expr_stmt|;
else|else
name|peer
operator|->
name|borg
operator|=
name|xmt_ty
expr_stmt|;
name|peer
operator|->
name|flip
operator|=
operator|-
name|peer
operator|->
name|flip
expr_stmt|;
block|}
name|L_SUB
argument_list|(
operator|&
name|xmt_ty
argument_list|,
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|xmt_ty
argument_list|,
name|peer
operator|->
name|xleave
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d len %zu\n"
argument_list|,
name|current_time
argument_list|,
name|peer
operator|->
name|dstadr
condition|?
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
else|:
literal|"-"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * Authentication is enabled, so the transmitted packet must be 	 * authenticated. If autokey is enabled, fuss with the various 	 * modes; otherwise, symmetric key cryptography is used. 	 */
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
condition|)
block|{
name|struct
name|exten
modifier|*
name|exten
decl_stmt|;
comment|/* extension field */
comment|/* 		 * The Public Key Dance (PKD): Cryptographic credentials 		 * are contained in extension fields, each including a 		 * 4-octet length/code word followed by a 4-octet 		 * association ID and optional additional data. Optional 		 * data includes a 4-octet data length field followed by 		 * the data itself. Request messages are sent from a 		 * configured association; response messages can be sent 		 * from a configured association or can take the fast 		 * path without ever matching an association. Response 		 * messages have the same code as the request, but have 		 * a response bit and possibly an error bit set. In this 		 * implementation, a message may contain no more than 		 * one command and one or more responses. 		 * 		 * Cryptographic session keys include both a public and 		 * a private componet. Request and response messages 		 * using extension fields are always sent with the 		 * private component set to zero. Packets without 		 * extension fields indlude the private component when 		 * the session key is generated. 		 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 			 * Allocate and initialize a keylist if not 			 * already done. Then, use the list in inverse 			 * order, discarding keys once used. Keep the 			 * latest key around until the next one, so 			 * clients can use client/server packets to 			 * compute propagation delay. 			 * 			 * Note that once a key is used from the list, 			 * it is retained in the key cache until the 			 * next key is used. This is to allow a client 			 * to retrieve the encrypted session key 			 * identifier to verify authenticity. 			 * 			 * If for some reason a key is no longer in the 			 * key cache, a birthday has happened or the key 			 * has expired, so the pseudo-random sequence is 			 * broken. In that case, purge the keylist and 			 * regenerate it. 			 */
if|if
condition|(
name|peer
operator|->
name|keynumber
operator|==
literal|0
condition|)
name|make_keylist
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|keynumber
operator|--
expr_stmt|;
name|xkeyid
operator|=
name|peer
operator|->
name|keylist
index|[
name|peer
operator|->
name|keynumber
index|]
expr_stmt|;
if|if
condition|(
name|authistrusted
argument_list|(
name|xkeyid
argument_list|)
condition|)
break|break;
else|else
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|keyid
operator|=
name|xkeyid
expr_stmt|;
name|exten
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|peer
operator|->
name|hmode
condition|)
block|{
comment|/* 		 * In broadcast server mode the autokey values are 		 * required by the broadcast clients. Push them when a 		 * new keylist is generated; otherwise, push the 		 * association message so the client can request them at 		 * other times. 		 */
case|case
name|MODE_BROADCAST
case|:
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_ASSOC
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_ASSOC
operator||
name|CRYPTO_RESP
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * In symmetric modes the parameter, certificate,  		 * identity, cookie and autokey exchanges are 		 * required. The leapsecond exchange is optional. But, a 		 * peer will not believe the other peer until the other 		 * peer has synchronized, so the certificate exchange 		 * might loop until then. If a peer finds a broken 		 * autokey sequence, it uses the autokey exchange to 		 * retrieve the autokey values. In any case, if a new 		 * keylist is generated, the autokey values are pushed. 		 */
case|case
name|MODE_ACTIVE
case|:
case|case
name|MODE_PASSIVE
case|:
comment|/* 			 * Parameter, certificate and identity. 			 */
if|if
condition|(
operator|!
name|peer
operator|->
name|crypto
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_ASSOC
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|hostval
operator|.
name|ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_CERT
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_CERT
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|crypto_ident
argument_list|(
name|peer
argument_list|)
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Cookie and autokey. We request the cookie 			 * only when the this peer and the other peer 			 * are synchronized. But, this peer needs the 			 * autokey values when the cookie is zero. Any 			 * time we regenerate the key list, we offer the 			 * autokey values without being asked. If for 			 * some reason either peer finds a broken 			 * autokey sequence, the autokey exchange is 			 * used to retrieve the autokey values. 			 */
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
name|peer
operator|->
name|leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_COOK
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_COOK
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AUTO
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_ASSOC
operator|&&
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_SIGN
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
argument_list|,
name|peer
operator|->
name|assoc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Wait for clock sync, then sign the 			 * certificate and retrieve the leapsecond 			 * values. 			 */
elseif|else
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_SIGN
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_SIGN
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|hostval
operator|.
name|ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_LEAP
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_LEAP
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * In client mode the parameter, certificate, identity, 		 * cookie and sign exchanges are required. The 		 * leapsecond exchange is optional. If broadcast client 		 * mode the same exchanges are required, except that the 		 * autokey exchange is substitutes for the cookie 		 * exchange, since the cookie is always zero. If the 		 * broadcast client finds a broken autokey sequence, it 		 * uses the autokey exchange to retrieve the autokey 		 * values. 		 */
case|case
name|MODE_CLIENT
case|:
comment|/* 			 * Parameter, certificate and identity. 			 */
if|if
condition|(
operator|!
name|peer
operator|->
name|crypto
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_ASSOC
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|hostval
operator|.
name|ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_CERT
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_CERT
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|crypto_ident
argument_list|(
name|peer
argument_list|)
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Cookie and autokey. These are requests, but 			 * we use the peer association ID with autokey 			 * rather than our own. 			 */
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_COOK
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_COOK
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AUTO
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
argument_list|,
name|peer
operator|->
name|assoc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Wait for clock sync, then sign the 			 * certificate and retrieve the leapsecond 			 * values. 			 */
elseif|else
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_SIGN
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_SIGN
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|hostval
operator|.
name|ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_LEAP
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_LEAP
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Add a queued extension field if present. This is 		 * always a request message, so the reply ID is already 		 * in the message. If an error occurs, the error bit is 		 * lit in the response. 		 */
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
condition|)
block|{
name|u_int32
name|temp32
decl_stmt|;
name|temp32
operator|=
name|CRYPTO_RESP
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|->
name|opcode
operator||=
name|htonl
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
name|peer
argument_list|,
operator|&
name|xpkt
argument_list|,
name|NULL
argument_list|,
name|sendlen
argument_list|,
name|peer
operator|->
name|cmmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|cmmd
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Add an extension field created above. All but the 		 * autokey response message are request messages. 		 */
if|if
condition|(
name|exten
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|exten
operator|->
name|opcode
operator|!=
literal|0
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
name|peer
argument_list|,
operator|&
name|xpkt
argument_list|,
name|NULL
argument_list|,
name|sendlen
argument_list|,
name|exten
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exten
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Calculate the next session key. Since extension 		 * fields are present, the cookie value is zero. 		 */
if|if
condition|(
name|sendlen
operator|>
operator|(
name|int
operator|)
name|LEN_PKT_NOMAC
condition|)
block|{
name|session_key
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|xkeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 	 * Transmit a-priori timestamps 	 */
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flip
operator|==
literal|0
condition|)
block|{
comment|/* basic mode */
name|peer
operator|->
name|aorg
operator|=
name|xmt_tx
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* interleaved modes */
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
condition|)
block|{
comment|/* bcst */
name|HTONL_FP
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flip
operator|>
literal|0
condition|)
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|borg
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
else|else
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|aorg
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* symmetric */
if|if
condition|(
name|peer
operator|->
name|flip
operator|>
literal|0
condition|)
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|borg
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
else|else
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|aorg
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
block|}
block|}
name|xkeyid
operator|=
name|peer
operator|->
name|keyid
expr_stmt|;
name|authlen
operator|=
name|authencrypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|authlen
operator|==
literal|0
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_AUTH
argument_list|,
name|peer
argument_list|,
literal|"no key"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST5
expr_stmt|;
comment|/* auth error */
name|peer
operator|->
name|badauth
operator|++
expr_stmt|;
return|return;
block|}
name|sendlen
operator|+=
name|authlen
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|xkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
if|if
condition|(
name|sendlen
operator|>
sizeof|sizeof
argument_list|(
name|xpkt
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"proto: buffer overflow %zu"
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|t21_bytes
operator|=
name|sendlen
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|,
name|sys_ttl
index|[
name|peer
operator|->
name|ttl
index|]
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
name|peer
operator|->
name|throttle
operator|+=
operator|(
literal|1
operator|<<
name|peer
operator|->
name|minpoll
operator|)
operator|-
literal|2
expr_stmt|;
comment|/* 	 * Capture a-posteriori timestamps 	 */
name|get_systime
argument_list|(
operator|&
name|xmt_ty
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flip
operator|!=
literal|0
condition|)
block|{
comment|/* interleaved modes */
if|if
condition|(
name|peer
operator|->
name|flip
operator|>
literal|0
condition|)
name|peer
operator|->
name|aorg
operator|=
name|xmt_ty
expr_stmt|;
else|else
name|peer
operator|->
name|borg
operator|=
name|xmt_ty
expr_stmt|;
name|peer
operator|->
name|flip
operator|=
operator|-
name|peer
operator|->
name|flip
expr_stmt|;
block|}
name|L_SUB
argument_list|(
operator|&
name|xmt_ty
argument_list|,
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|xmt_ty
argument_list|,
name|peer
operator|->
name|xleave
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %zu index %d\n"
argument_list|,
name|current_time
argument_list|,
name|latoa
argument_list|(
name|peer
operator|->
name|dstadr
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
argument_list|,
name|peer
operator|->
name|keynumber
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* !AUTOKEY follows */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d\n"
argument_list|,
name|current_time
argument_list|,
name|peer
operator|->
name|dstadr
condition|?
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
else|:
literal|"-"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !AUTOKEY */
block|}
comment|/*  * fast_xmit - Send packet for nonpersistent association. Note that  * neither the source or destination can be a broadcast address.  */
specifier|static
name|void
name|fast_xmit
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
comment|/* receive packet pointer */
name|int
name|xmode
parameter_list|,
comment|/* receive mode */
name|keyid_t
name|xkeyid
parameter_list|,
comment|/* transmit key ID */
name|int
name|flags
comment|/* restrict mask */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* transmit packet structure */
name|struct
name|pkt
modifier|*
name|rpkt
decl_stmt|;
comment|/* receive packet structure */
name|l_fp
name|xmt_tx
decl_stmt|,
name|xmt_ty
decl_stmt|;
name|int
name|sendlen
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|u_int32
name|temp32
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize transmit packet header fields from the receive 	 * buffer provided. We leave the fields intact as received, but 	 * set the peer poll at the maximum of the receive peer poll and 	 * the system minimum poll (ntp_minpoll). This is for KoD rate 	 * control and not strictly specification compliant, but doesn't 	 * break anything. 	 * 	 * If the gazinta was from a multicast address, the gazoutta 	 * must go out another way. 	 */
name|rpkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MCASTOPEN
condition|)
name|rbufp
operator|->
name|dstadr
operator|=
name|findinterface
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a kiss-o'-death (KoD) packet, show leap 	 * unsynchronized, stratum zero, reference ID the four-character 	 * kiss code and system root delay. Note we don't reveal the 	 * local time, so these packets can't be used for 	 * synchronization. 	 */
if|if
condition|(
name|flags
operator|&
name|RES_KOD
condition|)
block|{
name|sys_kodsent
operator|++
expr_stmt|;
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOTINSYNC
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_PKT_UNSPEC
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|max
argument_list|(
name|rpkt
operator|->
name|ppoll
argument_list|,
name|ntp_minpoll
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|rpkt
operator|->
name|precision
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|xpkt
operator|.
name|refid
argument_list|,
literal|"RATE"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|rpkt
operator|->
name|rootdelay
expr_stmt|;
name|xpkt
operator|.
name|rootdisp
operator|=
name|rpkt
operator|->
name|rootdisp
expr_stmt|;
name|xpkt
operator|.
name|reftime
operator|=
name|rpkt
operator|->
name|reftime
expr_stmt|;
name|xpkt
operator|.
name|org
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
name|xpkt
operator|.
name|rec
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
name|xpkt
operator|.
name|xmt
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
comment|/* 	 * This is a normal packet. Use the system variables. 	 */
block|}
else|else
block|{
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|max
argument_list|(
name|rpkt
operator|->
name|ppoll
argument_list|,
name|ntp_minpoll
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdisp
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdisp
argument_list|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|org
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_NTP_SIGND
if|if
condition|(
name|flags
operator|&
name|RES_MSSNTP
condition|)
block|{
name|send_via_ntp_signd
argument_list|(
name|rbufp
argument_list|,
name|xmode
argument_list|,
name|xkeyid
argument_list|,
name|flags
argument_list|,
operator|&
name|xpkt
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_NTP_SIGND */
comment|/* 	 * If the received packet contains a MAC, the transmitted packet 	 * is authenticated and contains a MAC. If not, the transmitted 	 * packet is not authenticated. 	 */
name|sendlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|==
name|sendlen
condition|)
block|{
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
literal|0
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d len %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|xmode
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The received packet contains a MAC, so the transmitted packet 	 * must be authenticated. For symmetric key cryptography, use 	 * the predefined and trusted symmetric keys to generate the 	 * cryptosum. For autokey cryptography, use the server private 	 * value to generate the cookie, which is unique for every 	 * source-destination-key ID combination. 	 */
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|keyid_t
name|cookie
decl_stmt|;
comment|/* 		 * The only way to get here is a reply to a legitimate 		 * client request message, so the mode must be 		 * MODE_SERVER. If an extension field is present, there 		 * can be only one and that must be a command. Do what 		 * needs, but with private value of zero so the poor 		 * jerk can decode it. If no extension field is present, 		 * use the cookie to generate the session key. 		 */
name|cookie
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
literal|0
argument_list|,
name|sys_private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>
name|sendlen
operator|+
operator|(
name|int
operator|)
name|MAX_MAC_LEN
condition|)
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|xkeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|temp32
operator|=
name|CRYPTO_RESP
expr_stmt|;
name|rpkt
operator|->
name|exten
index|[
literal|0
index|]
operator||=
name|htonl
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
name|NULL
argument_list|,
operator|&
name|xpkt
argument_list|,
name|rbufp
argument_list|,
name|sendlen
argument_list|,
operator|(
expr|struct
name|exten
operator|*
operator|)
name|rpkt
operator|->
name|exten
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|xkeyid
argument_list|,
name|cookie
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|authencrypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|xkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
literal|0
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|xmt_ty
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|xmt_ty
argument_list|,
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
name|sys_authdelay
operator|=
name|xmt_ty
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|xmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * pool_xmit - resolve hostname or send unicast solicitation for pool.  */
specifier|static
name|void
name|pool_xmit
parameter_list|(
name|struct
name|peer
modifier|*
name|pool
comment|/* pool solicitor association */
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WORKER
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* transmit packet structure */
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|interface
modifier|*
name|lcladr
decl_stmt|;
name|sockaddr_u
modifier|*
name|rmtadr
decl_stmt|;
name|int
name|restrict_mask
decl_stmt|;
name|struct
name|peer
modifier|*
name|p
decl_stmt|;
name|l_fp
name|xmt_tx
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pool
operator|->
name|ai
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|addrs
operator|!=
name|NULL
condition|)
block|{
comment|/* free() is used with copy_addrinfo_list() */
name|free
argument_list|(
name|pool
operator|->
name|addrs
argument_list|)
expr_stmt|;
name|pool
operator|->
name|addrs
operator|=
name|NULL
expr_stmt|;
block|}
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF
argument_list|(
operator|&
name|pool
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
comment|/* ignore getaddrinfo_sometime() errors, we will retry */
name|rc
operator|=
name|getaddrinfo_sometime
argument_list|(
name|pool
operator|->
name|hostname
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
comment|/* no retry */
operator|&
name|pool_name_resolved
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|pool
operator|->
name|associd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"pool DNS lookup %s started\n"
operator|,
name|pool
operator|->
name|hostname
operator|)
argument_list|)
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to start pool DNS %s %m"
argument_list|,
name|pool
operator|->
name|hostname
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
comment|/* copy_addrinfo_list ai_addr points to a sockaddr_u */
name|rmtadr
operator|=
operator|(
name|sockaddr_u
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|pool
operator|->
name|ai
operator|->
name|ai_addr
expr_stmt|;
name|pool
operator|->
name|ai
operator|=
name|pool
operator|->
name|ai
operator|->
name|ai_next
expr_stmt|;
name|p
operator|=
name|findexistingpeer
argument_list|(
name|rmtadr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MODE_CLIENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|pool
operator|->
name|ai
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
return|return;
comment|/* out of addresses, re-query DNS next poll */
name|restrict_mask
operator|=
name|restrictions
argument_list|(
name|rmtadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|RES_FLAGS
operator|&
name|restrict_mask
condition|)
name|restrict_source
argument_list|(
name|rmtadr
argument_list|,
literal|0
argument_list|,
name|current_time
operator|+
name|POOL_SOLICIT_WINDOW
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lcladr
operator|=
name|findinterface
argument_list|(
name|rmtadr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|xpkt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xpkt
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|pool
operator|->
name|version
argument_list|,
name|MODE_CLIENT
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|pool
operator|->
name|hpoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdisp
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdisp
argument_list|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
name|pool
operator|->
name|aorg
operator|=
name|xmt_tx
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
name|rmtadr
argument_list|,
name|lcladr
argument_list|,
name|sys_ttl
index|[
name|pool
operator|->
name|ttl
index|]
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|pool
operator|->
name|sent
operator|++
expr_stmt|;
name|pool
operator|->
name|throttle
operator|+=
operator|(
literal|1
operator|<<
name|pool
operator|->
name|minpoll
operator|)
operator|-
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s pool\n"
argument_list|,
name|current_time
argument_list|,
name|latoa
argument_list|(
name|lcladr
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|rmtadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Soliciting pool server %s"
argument_list|,
name|stoa
argument_list|(
name|rmtadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WORKER */
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * group_test - test if this is the same group 	 * 	 * host		assoc		return		action 	 * none		none		0		mobilize * 	 * none		group		0		mobilize * 	 * group	none		0		mobilize * 	 * group	group		1		mobilize 	 * group	different	1		ignore 	 * * ignore if notrust 	 */
name|int
name|group_test
parameter_list|(
name|char
modifier|*
name|grp
parameter_list|,
name|char
modifier|*
name|ident
parameter_list|)
block|{
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|grp
argument_list|,
name|sys_groupname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ident
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|grp
argument_list|,
name|ident
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
ifdef|#
directive|ifdef
name|WORKER
name|void
name|pool_name_resolved
parameter_list|(
name|int
name|rescode
parameter_list|,
name|int
name|gai_errno
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|pool
decl_stmt|;
comment|/* pool solicitor association */
name|associd_t
name|assoc
decl_stmt|;
if|if
condition|(
name|rescode
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error resolving pool %s: %s (%d)"
argument_list|,
name|name
argument_list|,
name|gai_strerror
argument_list|(
name|rescode
argument_list|)
argument_list|,
name|rescode
argument_list|)
expr_stmt|;
return|return;
block|}
name|assoc
operator|=
operator|(
name|associd_t
operator|)
operator|(
name|intptr_t
operator|)
name|context
expr_stmt|;
name|pool
operator|=
name|findpeerbyassoc
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pool
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not find assoc %u for pool DNS %s"
argument_list|,
name|assoc
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"pool DNS %s completed\n"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|addrs
operator|=
name|copy_addrinfo_list
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|pool
operator|->
name|ai
operator|=
name|pool
operator|->
name|addrs
expr_stmt|;
name|pool_xmit
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WORKER */
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/*  * key_expire - purge the key list  */
name|void
name|key_expire
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|keylist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|peer
operator|->
name|keynumber
condition|;
name|i
operator|++
control|)
name|authtrust
argument_list|(
name|peer
operator|->
name|keylist
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|keylist
argument_list|)
expr_stmt|;
name|peer
operator|->
name|keylist
operator|=
name|NULL
expr_stmt|;
block|}
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|sndval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|keynumber
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_ASSOC
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"key_expire: at %lu associd %d\n"
argument_list|,
name|current_time
argument_list|,
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/*  * local_refid(peer) - check peer refid to avoid selecting peers  *		       currently synced to this ntpd.  */
specifier|static
name|int
name|local_refid
parameter_list|(
name|struct
name|peer
modifier|*
name|p
parameter_list|)
block|{
name|endpt
modifier|*
name|unicast_ep
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|dstadr
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|INT_MCASTIF
operator|&
name|p
operator|->
name|dstadr
operator|->
name|flags
operator|)
condition|)
name|unicast_ep
operator|=
name|p
operator|->
name|dstadr
expr_stmt|;
else|else
name|unicast_ep
operator|=
name|findinterface
argument_list|(
operator|&
name|p
operator|->
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unicast_ep
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|refid
operator|==
name|unicast_ep
operator|->
name|addr_refid
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
comment|/*  * Determine if the peer is unfit for synchronization  *  * A peer is unfit for synchronization if  *> TEST10 bad leap or stratum below floor or at or above ceiling  *> TEST11 root distance exceeded for remote peer  *> TEST12 a direct or indirect synchronization loop would form  *> TEST13 unreachable or noselect  */
name|int
comment|/* FALSE if fit, TRUE if unfit */
name|peer_unfit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
comment|/* 	 * A stratum error occurs if (1) the server has never been 	 * synchronized, (2) the server stratum is below the floor or 	 * greater than or equal to the ceiling. 	 */
if|if
condition|(
name|peer
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
operator|||
name|peer
operator|->
name|stratum
operator|<
name|sys_floor
operator|||
name|peer
operator|->
name|stratum
operator|>=
name|sys_ceiling
condition|)
name|rval
operator||=
name|TEST10
expr_stmt|;
comment|/* bad synch or stratum */
comment|/* 	 * A distance error for a remote peer occurs if the root 	 * distance is greater than or equal to the distance threshold 	 * plus the increment due to one host poll interval. 	 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|)
operator|&&
name|root_distance
argument_list|(
name|peer
argument_list|)
operator|>=
name|sys_maxdist
operator|+
name|clock_phi
operator|*
name|ULOGTOD
argument_list|(
name|peer
operator|->
name|hpoll
argument_list|)
condition|)
name|rval
operator||=
name|TEST11
expr_stmt|;
comment|/* distance exceeded */
comment|/* 	 * A loop error occurs if the remote peer is synchronized to the 	 * local peer or if the remote peer is synchronized to the same 	 * server as the local peer but only if the remote peer is 	 * neither a reference clock nor an orphan. 	 */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>
literal|1
operator|&&
name|local_refid
argument_list|(
name|peer
argument_list|)
condition|)
name|rval
operator||=
name|TEST12
expr_stmt|;
comment|/* synchronization loop */
comment|/* 	 * An unreachable error occurs if the server is unreachable or 	 * the noselect bit is set. 	 */
if|if
condition|(
operator|!
name|peer
operator|->
name|reach
operator|||
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_NOSELECT
operator|)
condition|)
name|rval
operator||=
name|TEST13
expr_stmt|;
comment|/* unreachable */
name|peer
operator|->
name|flash
operator|&=
operator|~
name|PEER_TEST_MASK
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|rval
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
comment|/*  * Find the precision of this particular machine  */
define|#
directive|define
name|MINSTEP
value|20e-9
comment|/* minimum clock increment (s) */
define|#
directive|define
name|MAXSTEP
value|1
comment|/* maximum clock increment (s) */
define|#
directive|define
name|MINCHANGES
value|12
comment|/* minimum number of step samples */
define|#
directive|define
name|MAXLOOPS
value|((int)(1. / MINSTEP))
comment|/* avoid infinite loop */
comment|/*  * This routine measures the system precision defined as the minimum of  * a sequence of differences between successive readings of the system  * clock. However, if a difference is less than MINSTEP, the clock has  * been read more than once during a clock tick and the difference is  * ignored. We set MINSTEP greater than zero in case something happens  * like a cache miss, and to tolerate underlying system clocks which  * ensure each reading is strictly greater than prior readings while  * using an underlying stepping (not interpolated) clock.  *  * sys_tick and sys_precision represent the time to read the clock for  * systems with high-precision clocks, and the tick interval or step  * size for lower-precision stepping clocks.  *  * This routine also measures the time to read the clock on stepping  * system clocks by counting the number of readings between changes of  * the underlying clock.  With either type of clock, the minimum time  * to read the clock is saved as sys_fuzz, and used to ensure the  * get_systime() readings always increase and are fuzzed below sys_fuzz.  */
name|void
name|measure_precision
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * With sys_fuzz set to zero, get_systime() fuzzing of low bits 	 * is effectively disabled.  trunc_os_clock is FALSE to disable 	 * get_ostime() simulation of a low-precision system clock. 	 */
name|set_sys_fuzz
argument_list|(
literal|0.
argument_list|)
expr_stmt|;
name|trunc_os_clock
operator|=
name|FALSE
expr_stmt|;
name|measured_tick
operator|=
name|measure_tick_fuzz
argument_list|()
expr_stmt|;
name|set_sys_tick_precision
argument_list|(
name|measured_tick
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"proto: precision = %.3f usec (%d)"
argument_list|,
name|sys_tick
operator|*
literal|1e6
argument_list|,
name|sys_precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_fuzz
operator|<
name|sys_tick
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"proto: fuzz beneath %.3f usec"
argument_list|,
name|sys_fuzz
operator|*
literal|1e6
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * measure_tick_fuzz()  *  * measures the minimum time to read the clock (stored in sys_fuzz)  * and returns the tick, the larger of the minimum increment observed  * between successive clock readings and the time to read the clock.  */
name|double
name|measure_tick_fuzz
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|minstep
decl_stmt|;
comment|/* MINSTEP as l_fp */
name|l_fp
name|val
decl_stmt|;
comment|/* current seconds fraction */
name|l_fp
name|last
decl_stmt|;
comment|/* last seconds fraction */
name|l_fp
name|ldiff
decl_stmt|;
comment|/* val - last */
name|double
name|tick
decl_stmt|;
comment|/* computed tick value */
name|double
name|diff
decl_stmt|;
name|long
name|repeats
decl_stmt|;
name|long
name|max_repeats
decl_stmt|;
name|int
name|changes
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* log2 precision */
name|tick
operator|=
name|MAXSTEP
expr_stmt|;
name|max_repeats
operator|=
literal|0
expr_stmt|;
name|repeats
operator|=
literal|0
expr_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
name|DTOLFP
argument_list|(
name|MINSTEP
argument_list|,
operator|&
name|minstep
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|last
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXLOOPS
operator|&&
name|changes
operator|<
name|MINCHANGES
condition|;
name|i
operator|++
control|)
block|{
name|get_systime
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
name|ldiff
operator|=
name|val
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|ldiff
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|L_ISGT
argument_list|(
operator|&
name|ldiff
argument_list|,
operator|&
name|minstep
argument_list|)
condition|)
block|{
name|max_repeats
operator|=
name|max
argument_list|(
name|repeats
argument_list|,
name|max_repeats
argument_list|)
expr_stmt|;
name|repeats
operator|=
literal|0
expr_stmt|;
name|changes
operator|++
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ldiff
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|tick
operator|=
name|min
argument_list|(
name|diff
argument_list|,
name|tick
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|repeats
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changes
operator|<
name|MINCHANGES
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Fatal error: precision could not be measured (MINSTEP too large?)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|max_repeats
condition|)
block|{
name|set_sys_fuzz
argument_list|(
name|tick
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_sys_fuzz
argument_list|(
name|tick
operator|/
name|max_repeats
argument_list|)
expr_stmt|;
block|}
return|return
name|tick
return|;
block|}
name|void
name|set_sys_tick_precision
parameter_list|(
name|double
name|tick
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tick
operator|>
literal|1.
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unsupported tick %.3f> 1s ignored"
argument_list|,
name|tick
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tick
operator|<
name|measured_tick
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"proto: tick %.3f less than measured tick %.3f, ignored"
argument_list|,
name|tick
argument_list|,
name|measured_tick
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|tick
operator|>
name|measured_tick
condition|)
block|{
name|trunc_os_clock
operator|=
name|TRUE
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"proto: truncating system clock to multiples of %.9f"
argument_list|,
name|tick
argument_list|)
expr_stmt|;
block|}
name|sys_tick
operator|=
name|tick
expr_stmt|;
comment|/* 	 * Find the nearest power of two. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tick
operator|<=
literal|1
condition|;
name|i
operator|--
control|)
name|tick
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|tick
operator|-
literal|1
operator|>
literal|1
operator|-
name|tick
operator|/
literal|2
condition|)
name|i
operator|++
expr_stmt|;
name|sys_precision
operator|=
operator|(
name|s_char
operator|)
name|i
expr_stmt|;
block|}
comment|/*  * init_proto - initialize the protocol module's data  */
name|void
name|init_proto
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|dummy
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Fill in the sys_* stuff.  Default is don't listen to 	 * broadcasting, require authentication. 	 */
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"INIT"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdisp
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_reftime
argument_list|)
expr_stmt|;
name|sys_jitter
operator|=
literal|0
expr_stmt|;
name|measure_precision
argument_list|()
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|sys_survivors
operator|=
literal|0
expr_stmt|;
name|sys_manycastserver
operator|=
literal|0
expr_stmt|;
name|sys_bclient
operator|=
literal|0
expr_stmt|;
name|sys_bdelay
operator|=
literal|0
expr_stmt|;
name|sys_authenticate
operator|=
literal|1
expr_stmt|;
name|sys_stattime
operator|=
name|current_time
expr_stmt|;
name|orphwait
operator|=
name|current_time
operator|+
name|sys_orphwait
expr_stmt|;
name|proto_clr_stats
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TTL
condition|;
name|i
operator|++
control|)
block|{
name|sys_ttl
index|[
name|i
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|i
operator|*
literal|256
operator|)
operator|/
name|MAX_TTL
argument_list|)
expr_stmt|;
name|sys_ttlmax
operator|=
name|i
expr_stmt|;
block|}
name|hardpps_enable
operator|=
literal|0
expr_stmt|;
name|stats_control
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  * proto_config - configure the protocol module  */
name|void
name|proto_config
parameter_list|(
name|int
name|item
parameter_list|,
name|u_long
name|value
parameter_list|,
name|double
name|dvalue
parameter_list|,
name|sockaddr_u
modifier|*
name|svalue
parameter_list|)
block|{
comment|/* 	 * Figure out what he wants to change, then do it 	 */
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"proto_config: code %d value %lu dvalue %lf\n"
operator|,
name|item
operator|,
name|value
operator|,
name|dvalue
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|item
condition|)
block|{
comment|/* 	 * enable and disable commands - arguments are Boolean. 	 */
case|case
name|PROTO_AUTHENTICATE
case|:
comment|/* authentication (auth) */
name|sys_authenticate
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_BROADCLIENT
case|:
comment|/* broadcast client (bclient) */
name|sys_bclient
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|sys_bclient
operator|==
literal|0
condition|)
name|io_unsetbclient
argument_list|()
expr_stmt|;
else|else
name|io_setbclient
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|REFCLOCK
case|case
name|PROTO_CAL
case|:
comment|/* refclock calibrate (calibrate) */
name|cal_enable
operator|=
name|value
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* REFCLOCK */
case|case
name|PROTO_KERNEL
case|:
comment|/* kernel discipline (kernel) */
name|select_loop
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_MONITOR
case|:
comment|/* monitoring (monitor) */
if|if
condition|(
name|value
condition|)
name|mon_start
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
else|else
name|mon_stop
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_NTP
case|:
comment|/* NTP discipline (ntp) */
name|ntp_enable
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_MODE7
case|:
comment|/* mode7 management (ntpdc) */
name|ntp_mode7
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_PPS
case|:
comment|/* PPS discipline (pps) */
name|hardpps_enable
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_FILEGEN
case|:
comment|/* statistics (stats) */
name|stats_control
operator|=
name|value
expr_stmt|;
break|break;
comment|/* 	 * tos command - arguments are double, sometimes cast to int 	 */
case|case
name|PROTO_BEACON
case|:
comment|/* manycast beacon (beacon) */
name|sys_beacon
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_BROADDELAY
case|:
comment|/* default broadcast delay (bdelay) */
name|sys_bdelay
operator|=
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_CEILING
case|:
comment|/* stratum ceiling (ceiling) */
name|sys_ceiling
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_COHORT
case|:
comment|/* cohort switch (cohort) */
name|sys_cohort
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_FLOOR
case|:
comment|/* stratum floor (floor) */
name|sys_floor
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_MAXCLOCK
case|:
comment|/* maximum candidates (maxclock) */
name|sys_maxclock
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_MAXDIST
case|:
comment|/* select threshold (maxdist) */
name|sys_maxdist
operator|=
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_CALLDELAY
case|:
comment|/* modem call delay (mdelay) */
break|break;
comment|/* NOT USED */
case|case
name|PROTO_MINCLOCK
case|:
comment|/* minimum candidates (minclock) */
name|sys_minclock
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_MINDISP
case|:
comment|/* minimum distance (mindist) */
name|sys_mindisp
operator|=
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_MINSANE
case|:
comment|/* minimum survivors (minsane) */
name|sys_minsane
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_ORPHAN
case|:
comment|/* orphan stratum (orphan) */
name|sys_orphan
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_ORPHWAIT
case|:
comment|/* orphan wait (orphwait) */
name|orphwait
operator|-=
name|sys_orphwait
expr_stmt|;
name|sys_orphwait
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
name|orphwait
operator|+=
name|sys_orphwait
expr_stmt|;
break|break;
comment|/* 	 * Miscellaneous commands 	 */
case|case
name|PROTO_MULTICAST_ADD
case|:
comment|/* add group address */
if|if
condition|(
name|svalue
operator|!=
name|NULL
condition|)
name|io_multicast_add
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
name|sys_bclient
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PROTO_MULTICAST_DEL
case|:
comment|/* delete group address */
if|if
condition|(
name|svalue
operator|!=
name|NULL
condition|)
name|io_multicast_del
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"proto: unsupported option %d"
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * proto_clr_stats - clear protocol stat counters  */
name|void
name|proto_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|sys_stattime
operator|=
name|current_time
expr_stmt|;
name|sys_received
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_newversion
operator|=
literal|0
expr_stmt|;
name|sys_oldversion
operator|=
literal|0
expr_stmt|;
name|sys_declined
operator|=
literal|0
expr_stmt|;
name|sys_restricted
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
name|sys_limitrejected
operator|=
literal|0
expr_stmt|;
name|sys_kodsent
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

