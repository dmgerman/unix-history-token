begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_proto.c - NTP version 4 protocol machinery  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_crypto.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|VMS_LOCALUNIT
argument_list|)
end_if

begin_comment
comment|/*wjm*/
end_comment

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * System variables are declared here. See Section 3.2 of the  * specification.  */
end_comment

begin_decl_stmt
name|u_char
name|sys_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system leap indicator */
end_comment

begin_decl_stmt
name|u_char
name|sys_stratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stratum of system */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision */
end_comment

begin_decl_stmt
name|double
name|sys_rootdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* roundtrip delay to primary source */
end_comment

begin_decl_stmt
name|double
name|sys_rootdispersion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dispersion to primary source */
end_comment

begin_decl_stmt
name|u_int32
name|sys_refid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference source for local clock */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current local clock offset */
end_comment

begin_decl_stmt
name|l_fp
name|sys_reftime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time we were last updated */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our current peer */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_prefer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our cherished peer */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_decl_stmt
name|u_long
name|sys_automax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum session key lifetime */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOKEY */
end_comment

begin_comment
comment|/*  * Nonspecified system state variables.  */
end_comment

begin_decl_stmt
name|int
name|sys_bclient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we set our time to broadcasts */
end_comment

begin_decl_stmt
name|double
name|sys_bdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* broadcast client default delay */
end_comment

begin_decl_stmt
name|int
name|sys_authenticate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* requre authentication for config */
end_comment

begin_decl_stmt
name|l_fp
name|sys_authdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|sys_authdly
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay shift reg */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|leap_consensus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* consensus of survivor leap bits */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_selerr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* select error (squares) */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_syserr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system error (squares) */
end_comment

begin_decl_stmt
name|keyid_t
name|sys_private
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private value for session seed */
end_comment

begin_decl_stmt
name|int
name|sys_manycastserver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* respond to manycast client pkts */
end_comment

begin_decl_stmt
name|u_int
name|sys_survivors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* truest of the truechimers */
end_comment

begin_decl_stmt
name|int
name|peer_ntpdate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* active peers in ntpdate mode */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|sys_hostname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gethostname() name */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOKEY */
end_comment

begin_comment
comment|/*  * Statistics counters  */
end_comment

begin_decl_stmt
name|u_long
name|sys_stattime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time when we started recording */
end_comment

begin_decl_stmt
name|u_long
name|sys_badstratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets with invalid stratum */
end_comment

begin_decl_stmt
name|u_long
name|sys_oldversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* old version packets received */
end_comment

begin_decl_stmt
name|u_long
name|sys_newversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new version packets received */
end_comment

begin_decl_stmt
name|u_long
name|sys_unknownversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't know version packets */
end_comment

begin_decl_stmt
name|u_long
name|sys_badlength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets with bad length */
end_comment

begin_decl_stmt
name|u_long
name|sys_processed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets processed */
end_comment

begin_decl_stmt
name|u_long
name|sys_badauth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets dropped because of auth */
end_comment

begin_decl_stmt
name|u_long
name|sys_limitrejected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pkts rejected due to client count per net */
end_comment

begin_decl_stmt
specifier|static
name|double
name|root_distance
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|clock_combine
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|peer_xmit
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fast_xmit
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|,
name|keyid_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clock_update
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_get_precision
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * transmit - Transmit Procedure. See Section 3.4.2 of the  *	specification.  */
end_comment

begin_function
name|void
name|transmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|int
name|hpoll
decl_stmt|;
name|hpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
name|u_char
name|oreach
decl_stmt|;
comment|/* 		 * The polling state machine. There are two kinds of 		 * machines, those that never expect a reply (broadcast 		 * and manycast server modes) and those that do (all 		 * other modes). The dance is intricate... 		 */
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
operator|(
name|MDF_BCAST
operator||
name|MDF_MCAST
operator|)
condition|)
block|{
comment|/* 			 * In broadcast mode the poll interval is fixed 			 * at minpoll and the ttl at ttlmax. 			 */
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|ttl
operator|=
name|peer
operator|->
name|ttlmax
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_ACAST
condition|)
block|{
comment|/* 			 * In manycast mode we start with the minpoll 			 * interval and ttl. However, the actual poll 			 * interval is eight times the nominal poll 			 * interval shown here. If fewer than three 			 * servers are found, the ttl is increased by 			 * one and we try again. If this continues to 			 * the max ttl, the poll interval is bumped by 			 * one and we try again. If at least three 			 * servers are found, the poll interval 			 * increases with the system poll interval to 			 * the max and we continue indefinately. 			 * However, about once per day when the 			 * agreement parameters are refreshed, the 			 * manycast clients are reset and we start from 			 * the beginning. This is to catch and clamp the 			 * ttl to the lowest practical value and avoid 			 * knocking on spurious doors. 			 */
if|if
condition|(
name|sys_survivors
operator|<
name|NTP_MINCLOCK
operator|&&
name|peer
operator|->
name|ttl
operator|<
name|peer
operator|->
name|ttlmax
condition|)
name|peer
operator|->
name|ttl
operator|++
expr_stmt|;
name|hpoll
operator|=
name|sys_poll
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
block|}
else|else
block|{
comment|/* 			 * For associations expecting a reply, the 			 * watchdog counter is bumped by one if the peer 			 * has not been heard since the previous poll. 			 * If the counter reaches the max, the peer is 			 * demobilized if not configured and just 			 * cleared if it is, but in this case the poll 			 * interval is bumped by one. 			 */
if|if
condition|(
name|peer
operator|->
name|unreach
operator|<
name|NTP_UNREACH
condition|)
block|{
name|peer
operator|->
name|unreach
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|hpoll
operator|++
expr_stmt|;
block|}
block|}
name|oreach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
name|peer
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If this association has become unreachable, 			 * clear it and raise a trap. 			 */
if|if
condition|(
name|oreach
operator|!=
literal|0
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_UNREACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
block|}
block|}
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_IBURST
condition|)
name|peer
operator|->
name|burst
operator|=
name|NTP_SHIFT
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Here the peer is reachable. If it has not 			 * been heard for three consecutive polls, stuff 			 * the clock filter. Next, determine the poll 			 * interval. If the peer is a synchronization 			 * candidate, use the system poll interval. If 			 * the peer is not sane, increase it by one. If 			 * the number of valid updates is not greater 			 * than half the register size, clamp it to the 			 * minimum. This is to quickly recover the time 			 * variables when a noisy peer shows life. 			 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|reach
operator|&
literal|0x07
operator|)
condition|)
block|{
name|clock_filter
argument_list|(
name|peer
argument_list|,
literal|0.
argument_list|,
literal|0.
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|peer
operator|->
name|stratum
operator|>
literal|1
operator|&&
name|peer
operator|->
name|refid
operator|==
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
operator|||
name|peer
operator|->
name|stratum
operator|>=
name|STRATUM_UNSPEC
condition|)
name|hpoll
operator|++
expr_stmt|;
else|else
name|hpoll
operator|=
name|sys_poll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_BURST
condition|)
name|peer
operator|->
name|burst
operator|=
name|NTP_SHIFT
expr_stmt|;
block|}
block|}
else|else
block|{
name|peer
operator|->
name|burst
operator|--
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If a broadcast client at this point, the 			 * burst has concluded, so we switch to client 			 * mode and purge the keylist, since no further 			 * transmissions will be made. 			 */
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
condition|)
block|{
name|peer
operator|->
name|hmode
operator|=
name|MODE_BCLIENT
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
block|}
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
comment|/* 			 * If ntpdate mode and the clock has not been 			 * set and all peers have completed the burst, 			 * we declare a successful failure. 			 */
if|if
condition|(
name|mode_ntpdate
condition|)
block|{
name|peer_ntpdate
operator|--
expr_stmt|;
if|if
condition|(
name|peer_ntpdate
operator|>
literal|0
condition|)
return|return;
name|NLOG
argument_list|(
argument|NLOG_SYNCEVENT | NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"no reply; clock not set"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ntpd: no reply; clock not set\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
comment|/* 	 * We need to be very careful about honking uncivilized time. 	 * Never transmit if in broadcast client mode or access denied. 	 * If in broadcast mode, transmit only if synchronized to a 	 * valid source.  	 */
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BCLIENT
operator|||
name|peer
operator|->
name|flash
operator|&
name|TEST4
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
name|sys_peer
operator|==
name|NULL
condition|)
return|return;
block|}
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * receive - Receive Procedure.  See section 3.4.3 in the specification.  */
end_comment

begin_function
name|void
name|receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
name|int
name|hismode
decl_stmt|;
name|int
name|oflags
decl_stmt|;
name|int
name|restrict_mask
decl_stmt|;
name|int
name|has_mac
decl_stmt|;
comment|/* length of MAC field */
name|int
name|authlen
decl_stmt|;
comment|/* offset of MAC field */
name|int
name|is_authentic
decl_stmt|;
comment|/* cryptosum ok */
name|keyid_t
name|skeyid
decl_stmt|;
comment|/* cryptographic keys */
name|struct
name|sockaddr_in
modifier|*
name|dstadr_sin
decl_stmt|;
comment|/* active runway */
ifdef|#
directive|ifdef
name|AUTOKEY
name|keyid_t
name|pkeyid
decl_stmt|,
name|tkeyid
decl_stmt|;
comment|/* cryptographic keys */
endif|#
directive|endif
comment|/* AUTOKEY */
name|struct
name|peer
modifier|*
name|peer2
decl_stmt|;
name|int
name|retcode
init|=
name|AM_NOMATCH
decl_stmt|;
comment|/* 	 * Monitor the packet and get restrictions. Note that the packet 	 * length for control and private mode packets must be checked 	 * by the service routines. Note that no statistics counters are 	 * recorded for restrict violations, since these counters are in 	 * the restriction routine. Note the careful distinctions here 	 * between a packet with a format error and a packet that is 	 * simply discarded without prejudice. Some restrictions have to 	 * be handled later in order to generate a kiss-of-death packet. 	 */
name|ntp_monitor
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
name|restrict_mask
operator|=
name|restrictions
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s restrict %02x\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|restrict_mask
operator|&
name|RES_IGNORE
condition|)
return|return;
comment|/* no anything */
if|if
condition|(
operator|!
operator|(
name|SRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
operator|==
name|NTP_PORT
operator|||
name|SRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
operator|>=
name|IPPORT_RESERVED
operator|)
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* invalid port */
block|}
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|NTP_VERSION
condition|)
block|{
name|sys_newversionpkt
operator|++
expr_stmt|;
comment|/* new version */
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|restrict_mask
operator|&
name|RES_VERSION
operator|)
operator|&&
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|>=
name|NTP_OLDVERSION
condition|)
block|{
name|sys_oldversionpkt
operator|++
expr_stmt|;
comment|/* old version */
block|}
else|else
block|{
name|sys_unknownversion
operator|++
expr_stmt|;
return|return;
comment|/* invalid version */
block|}
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_PRIVATE
condition|)
block|{
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOQUERY
condition|)
return|return;
comment|/* no query private */
name|process_private
argument_list|(
name|rbufp
argument_list|,
operator|(
operator|(
name|restrict_mask
operator|&
name|RES_NOMODIFY
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_CONTROL
condition|)
block|{
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOQUERY
condition|)
return|return;
comment|/* no query control */
name|process_control
argument_list|(
name|rbufp
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|<
name|LEN_PKT_NOMAC
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* runt packet */
block|}
comment|/* 	 * Validate mode. Note that NTPv1 is no longer supported. 	 */
name|hismode
operator|=
operator|(
name|int
operator|)
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hismode
operator|==
name|MODE_UNSPEC
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* invalid mode */
block|}
comment|/* 	 * Discard broadcast packets received on the wildcard interface 	 * or if not enabled as broadcast client. 	 */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_BROADCAST
operator|&&
operator|(
name|rbufp
operator|->
name|dstadr
operator|==
name|any_interface
operator|||
operator|!
name|sys_bclient
operator|)
condition|)
return|return;
comment|/* 	 * Parse the extension field if present. We figure out whether 	 * an extension field is present by measuring the MAC size. If 	 * the number of words following the packet header is 0 or 1, no 	 * MAC is present and the packet is not authenticated. If 1, the 	 * packet is a reply to a previous request that failed to 	 * authenticate. If 3, the packet is authenticated with DES; if 	 * 5, the packet is authenticated with MD5. If greater than 5, 	 * an extension field is present. If 2 or 4, the packet is a 	 * runt and goes poof! with a brilliant flash. 	 */
name|skeyid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|pkeyid
operator|=
name|tkeyid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
name|authlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
while|while
condition|(
operator|(
name|has_mac
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|authlen
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|has_mac
operator|%
literal|4
operator|!=
literal|0
operator|||
name|has_mac
operator|<
literal|0
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|has_mac
operator|==
literal|1
operator|*
literal|4
operator|||
name|has_mac
operator|==
literal|3
operator|*
literal|4
operator|||
name|has_mac
operator|==
name|MAX_MAC_LEN
condition|)
block|{
name|skeyid
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
name|u_int32
operator|*
operator|)
name|pkt
operator|)
index|[
name|authlen
operator|/
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|has_mac
operator|>
name|MAX_MAC_LEN
condition|)
block|{
name|temp
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
name|u_int32
operator|*
operator|)
name|pkt
operator|)
index|[
name|authlen
operator|/
literal|4
index|]
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|4
operator|||
name|temp
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
block|}
name|authlen
operator|+=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * We have tossed out as many buggy packets as possible early in 	 * the game to reduce the exposure to a clogging attack. Now we 	 * have to burn some cycles to find the association and 	 * authenticate the packet if required. Note that we burn only 	 * MD5 or DES cycles, again to reduce exposure. There may be no 	 * matching association and that's okay. 	 * 	 * More on the autokey mambo. Normally the local interface is 	 * found when the association was mobilized with respect to a 	 * designated remote address. We assume packets arriving from 	 * the remote address arrive via this interface and the local 	 * address used to construct the autokey is the unicast address 	 * of the interface. However, if the sender is a broadcaster, 	 * the interface broadcast address is used instead. 	 * Notwithstanding this technobabble, if the sender is a 	 * multicaster, the broadcast address is null, so we use the 	 * unicast address anyway. Don't ask. 	 */
name|peer
operator|=
name|findpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|rbufp
operator|->
name|fd
argument_list|,
name|hismode
argument_list|,
operator|&
name|retcode
argument_list|)
expr_stmt|;
name|is_authentic
operator|=
literal|0
expr_stmt|;
name|dstadr_sin
operator|=
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
expr_stmt|;
if|if
condition|(
name|has_mac
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s mode %d code %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 		 * For autokey modes, generate the session key 		 * and install in the key cache. Use the socket 		 * broadcast or unicast address as appropriate. 		 */
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
comment|/* 			 * More on the autokey dance (AKD). A cookie is 			 * constructed from public and private values. 			 * For broadcast packets, the cookie is public 			 * (zero). For packets that match no 			 * association, the cookie is hashed from the 			 * addresses and private value. For server 			 * packets, the cookie was previously obtained 			 * from the server. For symmetric modes, the 			 * cookie was previously constructed using an 			 * agreement protocol; however, should PKI be 			 * unavailable, we construct a fake agreement as 			 * the EXOR of the peer and host cookies. 			 * 			 * hismode	ephemeral	persistent 			 * ======================================= 			 * active	0		cookie# 			 * passive	0%		cookie# 			 * client	sys cookie	0% 			 * server	0%		sys cookie 			 * broadcast	0		0 			 * 			 * # if unsync, 0 			 * % can't happen 			 */
if|if
condition|(
name|hismode
operator|==
name|MODE_BROADCAST
condition|)
block|{
comment|/* 				 * For broadcaster, use the interface 				 * broadcast address when available; 				 * otherwise, use the unicast address 				 * found when the association was 				 * mobilized. 				 */
name|pkeyid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|dstadr
operator|->
name|bcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
name|dstadr_sin
operator|=
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|bcast
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
block|{
name|pkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
literal|0
argument_list|,
name|sys_private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkeyid
operator|=
name|peer
operator|->
name|pcookie
operator|.
name|key
expr_stmt|;
block|}
comment|/* 			 * The session key includes both the public 			 * values and cookie. In case of an extension 			 * field, the cookie used for authentication 			 * purposes is zero. Note the hash is saved for 			 * use later in the autokey mambo. 			 */
if|if
condition|(
name|authlen
operator|>
name|LEN_PKT_NOMAC
operator|&&
name|pkeyid
operator|!=
literal|0
condition|)
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
name|pkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
name|pkeyid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 		 * Compute the cryptosum. Note a clogging attack may 		 * succeed in bloating the key cache. If an autokey, 		 * purge it immediately, since we won't be needing it 		 * again. 		 */
if|if
condition|(
name|authdecrypt
argument_list|(
name|skeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|pkt
argument_list|,
name|authlen
argument_list|,
name|has_mac
argument_list|)
condition|)
name|is_authentic
operator|=
literal|1
expr_stmt|;
else|else
name|sys_badauth
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|skeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s mode %d code %d keyid %08x len %d mac %d auth %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
name|dstadr_sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|retcode
argument_list|,
name|skeyid
argument_list|,
name|authlen
argument_list|,
name|has_mac
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * The association matching rules are implemented by a set of 	 * routines and a table in ntp_peer.c. A packet matching an 	 * association is processed by that association. If not and 	 * certain conditions prevail, then an ephemeral association is 	 * mobilized: a broadcast packet mobilizes a broadcast client 	 * aassociation; a server packet mobilizes a client association; 	 * a symmetric active packet mobilizes a symmetric passive 	 * association. And, the adventure continues... 	 */
switch|switch
condition|(
name|retcode
condition|)
block|{
case|case
name|AM_FXMIT
case|:
comment|/* 		 * This is a client mode packet not matching a known 		 * association. If from a manycast client we run a few 		 * sanity checks before deciding to send a unicast 		 * server response. Otherwise, it must be a client 		 * request, so send a server response and go home. 		 */
if|if
condition|(
name|sys_manycastserver
operator|&&
operator|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MULTICAST
operator|)
condition|)
block|{
comment|/* 			 * We are picky about responding to a 			 * manycaster. There is no reason to respond to 			 * a request if our time is worse than the 			 * manycaster. We certainly don't reply if not 			 * synchronized to proventic time. 			 */
if|if
condition|(
name|sys_peer
operator|==
name|NULL
condition|)
return|return;
comment|/* 			 * We don't reply if the our stratum is greater 			 * than the manycaster. 			 */
if|if
condition|(
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
operator|<
name|sys_stratum
condition|)
return|return;
block|}
comment|/* 		 * Note that we don't require an authentication check 		 * here, since we can't set the system clock; but, we do 		 * set the key ID to zero to tell the caller about this. 		 */
if|if
condition|(
name|is_authentic
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
name|skeyid
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
else|else
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
case|case
name|AM_MANYCAST
case|:
comment|/* 		 * This is a server mode packet returned in response to 		 * a client mode packet sent to a multicast group 		 * address. The originate timestamp is a good nonce to 		 * reliably associate the reply with what was sent. If 		 * there is no match, that's curious and could be an 		 * intruder attempting to clog, so we just ignore it. 		 * 		 * First, make sure the packet is authentic. If so and 		 * the manycast association is found, we mobilize a 		 * client mode association, copy pertinent variables 		 * from the manycast to the client mode association and 		 * wind up the spring. 		 * 		 * There is an implosion hazard at the manycast client, 		 * since the manycast servers send the server packet 		 * immediately. 		 */
if|if
condition|(
operator|(
name|restrict_mask
operator|&
operator|(
name|RES_DONTSERVE
operator||
name|RES_LIMITED
operator||
name|RES_NOPEER
operator|)
operator|)
operator|||
operator|(
name|sys_authenticate
operator|&&
operator|!
name|is_authentic
operator|)
condition|)
return|return;
name|peer2
operator|=
name|findmanycastpeer
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer2
operator|==
literal|0
condition|)
return|return;
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_CLIENT
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|sys_minpoll
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
name|FLAG_IBURST
operator||
operator|(
name|peer2
operator|->
name|flags
operator|&
operator|(
name|FLAG_AUTHENABLE
operator||
name|FLAG_SKEY
operator|)
operator|)
argument_list|,
name|MDF_UCAST
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
return|return;
break|break;
case|case
name|AM_NEWPASS
case|:
comment|/* 		 * This is the first packet received from a symmetric 		 * active peer. First, make sure the packet is 		 * authentic. If so, mobilize a symmetric passive 		 * association. 		 */
if|if
condition|(
operator|(
name|restrict_mask
operator|&
operator|(
name|RES_DONTSERVE
operator||
name|RES_LIMITED
operator||
name|RES_NOPEER
operator|)
operator|)
operator|||
operator|(
name|sys_authenticate
operator|&&
operator|!
name|is_authentic
operator|)
condition|)
block|{
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_PASSIVE
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_PASSIVE
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|sys_minpoll
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
name|sys_authenticate
condition|?
name|FLAG_AUTHENABLE
else|:
literal|0
argument_list|,
name|MDF_UCAST
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
return|return;
break|break;
case|case
name|AM_NEWBCL
case|:
comment|/* 		 * This is the first packet received from a broadcast 		 * server. First, make sure the packet is authentic, not 		 * restricted and that we are a broadcast or multicast 		 * client. If so, mobilize a broadcast client 		 * association. 		 */
if|if
condition|(
operator|(
name|restrict_mask
operator|&
operator|(
name|RES_DONTSERVE
operator||
name|RES_LIMITED
operator||
name|RES_NOPEER
operator|)
operator|)
operator|||
operator|(
name|sys_authenticate
operator|&&
operator|!
name|is_authentic
operator|)
operator|||
operator|!
name|sys_bclient
condition|)
return|return;
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_CLIENT
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|sys_minpoll
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
name|FLAG_MCAST
operator||
name|FLAG_IBURST
operator||
operator|(
name|sys_authenticate
condition|?
name|FLAG_AUTHENABLE
else|:
literal|0
operator|)
argument_list|,
name|MDF_BCLNT
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
ifdef|#
directive|ifdef
name|PUBKEY
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
condition|)
name|crypto_recv
argument_list|(
name|peer
argument_list|,
name|rbufp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PUBKEY */
endif|#
directive|endif
comment|/* AUTOKEY */
return|return;
case|case
name|AM_POSSBCL
case|:
case|case
name|AM_PROCPKT
case|:
comment|/* 		 * Happiness and nothing broke. Earn some revenue. 		 */
break|break;
default|default:
comment|/* 		 * Invalid mode combination. Leave the island 		 * immediately. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: bad protocol %d\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * If the peer isn't configured, set his authenable and autokey 	 * status based on the packet. Once the status is set, it can't 	 * be unset. It seems like a silly idea to do this here, rather 	 * in the configuration routine, but in some goofy cases the 	 * first packet sent cannot be authenticated and we need a way 	 * for the dude to change his mind. 	 */
name|oflags
operator|=
name|peer
operator|->
name|flags
expr_stmt|;
name|peer
operator|->
name|timereceived
operator|=
name|current_time
expr_stmt|;
name|peer
operator|->
name|received
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
name|has_mac
condition|)
block|{
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENABLE
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
name|peer
operator|->
name|flags
operator||=
name|FLAG_SKEY
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
block|}
comment|/* 	 * A valid packet must be from an authentic and allowed source. 	 * All packets must pass the authentication allowed tests. 	 * Autokey authenticated packets must pass additional tests and 	 * public-key authenticated packets must have the credentials 	 * verified. If all tests are passed, the packet is forwarded 	 * for processing. If not, the packet is discarded and the 	 * association demobilized if appropriate. 	 */
name|peer
operator|->
name|flash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_authentic
condition|)
block|{
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENTIC
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_AUTHENTIC
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
operator|&&
operator|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
operator|)
condition|)
comment|/* test 4 */
name|peer
operator|->
name|flash
operator||=
name|TEST4
expr_stmt|;
comment|/* access denied */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENTIC
operator|)
condition|)
comment|/* test 5 */
name|peer
operator|->
name|flash
operator||=
name|TEST5
expr_stmt|;
comment|/* auth failed */
elseif|else
if|if
condition|(
operator|!
operator|(
name|oflags
operator|&
name|FLAG_AUTHENABLE
operator|)
condition|)
name|report_event
argument_list|(
name|EVNT_PEERAUTH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|flash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: bad auth %03x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * More autokey dance. The rules of the cha-cha are as follows: 	 * 	 * 1. If there is no key or the key is not auto, do nothing. 	 * 	 * 2. If an extension field contains a verified signature, it is 	 *    self-authenticated and we sit the dance. 	 * 	 * 3. If this is a server reply, check only to see that the 	 *    transmitted key ID matches the received key ID. 	 * 	 * 4. Check to see that one or more hashes of the current key ID 	 *    matches the previous key ID or ultimate original key ID 	 *    obtained from the broadcaster or symmetric peer. If no 	 *    match, sit the dance and wait for timeout. 	 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST10
expr_stmt|;
name|crypto_recv
argument_list|(
name|peer
argument_list|,
name|rbufp
argument_list|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|hismode
operator|==
name|MODE_SERVER
condition|)
block|{
if|if
condition|(
name|skeyid
operator|==
name|peer
operator|->
name|keyid
condition|)
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|peer
operator|->
name|flash
operator|&
name|TEST10
condition|)
block|{
name|peer
operator|->
name|pkeyid
operator|=
name|skeyid
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tkeyid
operator|==
name|peer
operator|->
name|pkeyid
operator|||
name|tkeyid
operator|==
name|peer
operator|->
name|recauto
operator|.
name|key
condition|)
block|{
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
name|peer
operator|->
name|pkeyid
operator|=
name|skeyid
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|peer
operator|->
name|recauto
operator|.
name|seq
condition|)
break|break;
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|tkeyid
argument_list|,
name|pkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PUBKEY
comment|/* 		 * This is delicious. Ordinarily, we kick out all errors 		 * at this point; however, in symmetric mode and just 		 * warming up, an unsynchronized peer must inject the 		 * timestamps, even if it fails further up the road. So, 		 * let the dude by here, but only if the jerk is not yet 		 * reachable. After that, he's on his own. 		 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PROVEN
operator|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST11
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flash
operator|&&
name|peer
operator|->
name|reach
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: bad autokey %03x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
endif|#
directive|endif
comment|/* PUBKEY */
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 	 * We have survived the gaunt. Forward to the packet routine. If 	 * a symmetric passive association has been mobilized and the 	 * association doesn't deserve to live, it will die in the 	 * transmit routine if not reachable after timeout. 	 */
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process_packet - Packet Procedure, a la Section 3.4.4 of the  *	specification. Or almost, at least. If we're in here we have a  *	reasonable expectation that we will be having a long term  *	relationship with this host.  */
end_comment

begin_function
name|void
name|process_packet
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|l_fp
modifier|*
name|recv_ts
parameter_list|)
block|{
name|l_fp
name|t10
decl_stmt|,
name|t23
decl_stmt|;
name|double
name|p_offset
decl_stmt|,
name|p_del
decl_stmt|,
name|p_disp
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
name|l_fp
name|p_rec
decl_stmt|,
name|p_xmt
decl_stmt|,
name|p_org
decl_stmt|,
name|p_reftime
decl_stmt|;
name|l_fp
name|ci
decl_stmt|;
name|int
name|pmode
decl_stmt|,
name|pleap
decl_stmt|,
name|pstratum
decl_stmt|;
comment|/* 	 * Swap header fields and keep the books. The books amount to 	 * the receive timestamp and poll interval in the header. We 	 * need these even if there are other problems in order to crank 	 * up the state machine. 	 */
name|sys_processed
operator|++
expr_stmt|;
name|peer
operator|->
name|processed
operator|++
expr_stmt|;
name|p_del
operator|=
name|FPTOD
argument_list|(
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|p_disp
operator|=
name|FPTOD
argument_list|(
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|reftime
argument_list|,
operator|&
name|p_reftime
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|,
operator|&
name|p_rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_BROADCAST
condition|)
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
else|else
name|p_org
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
comment|/* 	 * Test for old, duplicate or unsynch packets (tests 1-3). 	 */
name|peer
operator|->
name|rec
operator|=
operator|*
name|recv_ts
expr_stmt|;
name|pmode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|pleap
operator|=
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|pstratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISHIS
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* count old packets */
name|peer
operator|->
name|oldpkt
operator|++
expr_stmt|;
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* 1 */
name|peer
operator|->
name|flash
operator||=
name|TEST1
expr_stmt|;
comment|/* dupe */
if|if
condition|(
name|pmode
operator|!=
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|p_org
argument_list|)
condition|)
comment|/* 2 */
name|peer
operator|->
name|flash
operator||=
name|TEST2
expr_stmt|;
comment|/* bogus */
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_rec
argument_list|)
operator|||
name|L_ISZERO
argument_list|(
operator|&
name|p_org
argument_list|)
condition|)
comment|/* test 3 */
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynch */
block|}
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* 3 */
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynch */
name|peer
operator|->
name|org
operator|=
name|p_xmt
expr_stmt|;
comment|/* 	 * If tests 1-3 fail, the packet is discarded leaving only the 	 * receive and origin timestamps and poll interval, which is 	 * enough to get the protocol started. 	 */
if|if
condition|(
name|peer
operator|->
name|flash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: bad data %03x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * A kiss-of-death (kod) packet is returned by a server in case 	 * the client is denied access. It consists of the client 	 * request packet with the leap bits indicating never 	 * synchronized, stratum zero and reference ID field the ASCII 	 * string "DENY". If the packet originate timestamp matches the 	 * association transmit timestamp the kod is legitimate. If the 	 * peer leap bits indicate never synchronized, this must be 	 * access deny and the association is disabled; otherwise this 	 * must be a limit reject. In either case a naughty message is 	 * forced to the system log. 	 */
if|if
condition|(
name|pleap
operator|==
name|LEAP_NOTINSYNC
operator|&&
name|pstratum
operator|>=
name|STRATUM_UNSPEC
operator|&&
name|memcmp
argument_list|(
operator|&
name|pkt
operator|->
name|refid
argument_list|,
literal|"DENY"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
block|{
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST4
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|peer
operator|->
name|refid
argument_list|,
operator|&
name|pkt
operator|->
name|refid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"access denied"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"limit reject"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Test for valid peer data (tests 6-8) 	 */
name|ci
operator|=
name|p_xmt
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|p_reftime
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pleap
operator|==
name|LEAP_NOTINSYNC
operator|||
comment|/* 6 */
name|pstratum
operator|>=
name|STRATUM_UNSPEC
operator|||
name|dtemp
operator|<
literal|0
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST6
expr_stmt|;
comment|/* bad synch */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
name|sys_peer
operator|!=
name|NULL
condition|)
block|{
comment|/* 7 */
if|if
condition|(
name|pstratum
operator|>
name|sys_stratum
operator|&&
name|pmode
operator|!=
name|MODE_ACTIVE
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST7
expr_stmt|;
comment|/* bad stratum */
name|sys_badstratum
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_del
operator|<
literal|0
operator|||
name|p_disp
operator|<
literal|0
operator|||
name|p_del
operator|/
comment|/* 8 */
literal|2
operator|+
name|p_disp
operator|>=
name|MAXDISPERSE
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST8
expr_stmt|;
comment|/* bad peer distance */
if|if
condition|(
name|peer
operator|->
name|flash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: bad header %03x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The header is valid. Capture the remaining header values and 	 * mark as reachable. 	 */
name|record_raw_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|p_org
argument_list|,
operator|&
name|p_rec
argument_list|,
operator|&
name|p_xmt
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
name|peer
operator|->
name|leap
operator|=
name|pleap
expr_stmt|;
name|peer
operator|->
name|pmode
operator|=
name|pmode
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|pstratum
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|pkt
operator|->
name|ppoll
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|pkt
operator|->
name|precision
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
name|p_del
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
name|p_disp
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pkt
operator|->
name|refid
expr_stmt|;
name|peer
operator|->
name|reftime
operator|=
name|p_reftime
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|reach
operator|)
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_REACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
block|}
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
comment|/* 	 * If running in a client/server association, calculate the 	 * clock offset c, roundtrip delay d and dispersion e. We use 	 * the equations (reordered from those in the spec). Note that, 	 * in a broadcast association, org has been set to the time of 	 * last reception. Note the computation of dispersion includes 	 * the system precision plus that due to the frequency error 	 * since the originate time. 	 * 	 * c = ((t2 - t3) + (t1 - t0)) / 2 	 * d = (t2 - t3) - (t1 - t0) 	 * e = (org - rec) (seconds only) 	 */
name|t10
operator|=
name|p_xmt
expr_stmt|;
comment|/* compute t1 - t0 */
name|L_SUB
argument_list|(
operator|&
name|t10
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
name|t23
operator|=
name|p_rec
expr_stmt|;
comment|/* compute t2 - t3 */
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|ci
operator|=
name|t10
expr_stmt|;
name|p_disp
operator|=
name|clock_phi
operator|*
operator|(
name|peer
operator|->
name|rec
operator|.
name|l_ui
operator|-
name|p_org
operator|.
name|l_ui
operator|)
expr_stmt|;
comment|/* 	 * If running in a broadcast association, the clock offset is 	 * (t1 - t0) corrected by the one-way delay, but we can't 	 * measure that directly. Therefore, we start up in MODE_CLIENT 	 * mode, set FLAG_MCAST and exchange eight messages to determine 	 * the clock offset. When the last message is sent, we switch to 	 * MODE_BCLIENT mode. The next broadcast message after that 	 * computes the broadcast offset and clears FLAG_MCAST. 	 */
if|if
condition|(
name|pmode
operator|==
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST
condition|)
block|{
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|p_offset
argument_list|)
expr_stmt|;
name|peer
operator|->
name|estbdelay
operator|=
name|peer
operator|->
name|offset
operator|-
name|p_offset
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_CLIENT
condition|)
return|return;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_MCAST
expr_stmt|;
block|}
name|DTOLFP
argument_list|(
name|peer
operator|->
name|estbdelay
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|p_del
operator|=
name|peer
operator|->
name|delay
expr_stmt|;
block|}
else|else
block|{
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|t23
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|t23
argument_list|,
name|p_del
argument_list|)
expr_stmt|;
block|}
name|p_del
operator|=
name|max
argument_list|(
name|p_del
argument_list|,
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|p_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|peer
operator|->
name|rootdelay
operator|+
name|p_del
operator|)
operator|/
literal|2.
operator|+
name|peer
operator|->
name|rootdispersion
operator|+
name|p_disp
operator|>=
name|MAXDISPERSE
condition|)
comment|/* 9 */
name|peer
operator|->
name|flash
operator||=
name|TEST9
expr_stmt|;
comment|/* bad peer distance */
comment|/* 	 * If any flasher bits remain set at this point, abandon ship. 	 * Otherwise, forward to the clock filter. 	 */
if|if
condition|(
name|peer
operator|->
name|flash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: bad packet data %03x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|clock_filter
argument_list|(
name|peer
argument_list|,
name|p_offset
argument_list|,
name|p_del
argument_list|,
name|p_disp
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
name|record_peer_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|disp
argument_list|,
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_update - Called at system process update intervals.  */
end_comment

begin_function
specifier|static
name|void
name|clock_update
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|oleap
decl_stmt|;
name|u_char
name|ostratum
decl_stmt|;
comment|/* 	 * Reset/adjust the system clock. Do this only if there is a 	 * system peer and we haven't seen that peer lately. Watch for 	 * timewarps here. 	 */
if|if
condition|(
name|sys_peer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sys_peer
operator|->
name|pollsw
operator|==
name|FALSE
operator|||
name|sys_peer
operator|->
name|burst
operator|>
literal|0
condition|)
return|return;
name|sys_peer
operator|->
name|pollsw
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_update: at %ld assoc %d \n"
argument_list|,
name|current_time
argument_list|,
name|peer_associations
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oleap
operator|=
name|sys_leap
expr_stmt|;
name|ostratum
operator|=
name|sys_stratum
expr_stmt|;
switch|switch
condition|(
name|local_clock
argument_list|(
name|sys_peer
argument_list|,
name|sys_offset
argument_list|,
name|sys_syserr
argument_list|)
condition|)
block|{
comment|/* 	 * Clock is too screwed up. Just exit for now. 	 */
case|case
operator|-
literal|1
case|:
name|report_event
argument_list|(
name|EVNT_SYSFAULT
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
comment|/* 	 * Clock was stepped. Flush all time values of all peers. 	 */
case|case
literal|1
case|:
name|clear_all
argument_list|()
expr_stmt|;
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|sys_poll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYNCSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"synchronisation lost"
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_CLOCKRESET
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Update the system stratum, leap bits, root delay, root 	 * dispersion, reference ID and reference time. We also update 	 * select dispersion and max frequency error. If the leap 	 * changes, we gotta reroll the keys. 	 */
default|default:
name|sys_stratum
operator|=
name|sys_peer
operator|->
name|stratum
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sys_stratum
operator|==
literal|1
condition|)
name|sys_refid
operator|=
name|sys_peer
operator|->
name|refid
expr_stmt|;
else|else
name|sys_refid
operator|=
name|sys_peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|sys_reftime
operator|=
name|sys_peer
operator|->
name|rec
expr_stmt|;
name|sys_rootdelay
operator|=
name|sys_peer
operator|->
name|rootdelay
operator|+
name|sys_peer
operator|->
name|delay
expr_stmt|;
name|sys_leap
operator|=
name|leap_consensus
expr_stmt|;
block|}
if|if
condition|(
name|oleap
operator|==
name|LEAP_NOTINSYNC
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_SYNCCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|expire_all
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
block|}
if|if
condition|(
name|ostratum
operator|!=
name|sys_stratum
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * poll_update - update peer poll interval  */
end_comment

begin_function
name|void
name|poll_update
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|hpoll
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AUTOKEY
name|int
name|oldpoll
decl_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 	 * A little foxtrot to determine what controls the poll 	 * interval. If the peer is reachable, but the last four polls 	 * have not been answered, use the minimum. If declared 	 * truechimer, use the system poll interval. This allows each 	 * association to ramp up the poll interval for useless sources 	 * and to clamp it to the minimum when first starting up. 	 */
ifdef|#
directive|ifdef
name|AUTOKEY
name|oldpoll
operator|=
name|peer
operator|->
name|kpoll
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
if|if
condition|(
name|hpoll
operator|>
name|peer
operator|->
name|maxpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
elseif|else
if|if
condition|(
name|hpoll
operator|<
name|peer
operator|->
name|minpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
else|else
name|peer
operator|->
name|hpoll
operator|=
name|hpoll
expr_stmt|;
comment|/* 	 * Bit of adventure here. If during a burst and not timeout, 	 * just slink away. If timeout, figure what the next timeout 	 * should be. If IBURST or a reference clock, use one second. If 	 * not and the dude was reachable during the previous poll 	 * interval, randomize over 1-4 seconds; otherwise, randomize 	 * over 15-18 seconds. This is to give time for a modem to 	 * complete the call, for example. If not during a burst, 	 * randomize over the poll interval -1 to +2 seconds. 	 * 	 * In case of manycast server, make the poll interval, which is 	 * axtually the manycast beacon interval, eight times the system 	 * poll interval. Normally when the host poll interval settles 	 * up to 17.1 s, the beacon interval settles up to 2.3 hours. 	 */
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|!=
name|current_time
condition|)
return|return;
ifdef|#
directive|ifdef
name|REFCLOCK
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|peer
operator|->
name|nextdate
operator|++
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|peer
operator|->
name|reach
operator|&
literal|0x1
condition|)
name|peer
operator|->
name|nextdate
operator|+=
name|RANDPOLL
argument_list|(
name|BURST_INTERVAL2
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|nextdate
operator|+=
name|RANDPOLL
argument_list|(
name|BURST_INTERVAL1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_ACAST
condition|)
block|{
if|if
condition|(
name|sys_survivors
operator|<
name|NTP_MINCLOCK
condition|)
name|peer
operator|->
name|kpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
else|else
name|peer
operator|->
name|kpoll
operator|=
name|peer
operator|->
name|hpoll
operator|+
literal|3
expr_stmt|;
name|peer
operator|->
name|nextdate
operator|=
name|peer
operator|->
name|outdate
operator|+
name|RANDPOLL
argument_list|(
name|peer
operator|->
name|kpoll
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|kpoll
operator|=
name|max
argument_list|(
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
name|peer
operator|->
name|nextdate
operator|=
name|peer
operator|->
name|outdate
operator|+
name|RANDPOLL
argument_list|(
name|peer
operator|->
name|kpoll
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|<
name|current_time
condition|)
name|peer
operator|->
name|nextdate
operator|=
name|current_time
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * Bit of crass arrogance at this point. If the poll interval 	 * has changed and we have a keylist, the lifetimes in the 	 * keylist are probably bogus. In this case purge the keylist 	 * and regenerate it later. 	 */
if|if
condition|(
name|peer
operator|->
name|kpoll
operator|!=
name|oldpoll
condition|)
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"poll_update: at %lu %s flags %04x poll %d burst %d last %lu next %lu\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|flags
argument_list|,
name|peer
operator|->
name|kpoll
argument_list|,
name|peer
operator|->
name|burst
argument_list|,
name|peer
operator|->
name|outdate
argument_list|,
name|peer
operator|->
name|nextdate
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * clear - clear peer filter registers.  See Section 3.4.8 of the spec.  */
end_comment

begin_function
name|void
name|peer_clear
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|u_long
name|u_rand
decl_stmt|;
comment|/* 	 * If cryptographic credentials have been acquired, toss them to 	 * Valhalla. Note that autokeys are ephemeral, in that they are 	 * tossed immediately upon use. Therefore, the keylist can be 	 * purged anytime without needing to preserve random keys. Note 	 * that, if the peer is purged, the cryptographic variables are 	 * purged, too. This makes it much harder to sneak in some 	 * unauthenticated data in the clock filter. 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"peer_clear: at %ld assoc ID %d\n"
argument_list|,
name|current_time
argument_list|,
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AUTOKEY
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUBKEY
if|if
condition|(
name|peer
operator|->
name|keystr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|keystr
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|pubkey
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|pubkey
operator|.
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|certif
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|certif
operator|.
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PUBKEY */
endif|#
directive|endif
comment|/* AUTOKEY */
name|memset
argument_list|(
name|CLEAR_TO_ZERO
argument_list|(
name|peer
argument_list|)
argument_list|,
literal|0
argument_list|,
name|LEN_CLEAR_TO_ZERO
argument_list|)
expr_stmt|;
comment|/* 	 * If he dies as a broadcast client, he comes back to life as 	 * a broadcast client in client mode in order to recover the 	 * initial autokey values. Note that there is no need to call 	 * clock_select(), since the perp has already been voted off 	 * the island at this point. 	 */
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
condition|)
block|{
name|peer
operator|->
name|flags
operator||=
name|FLAG_MCAST
expr_stmt|;
name|peer
operator|->
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
block|}
name|peer
operator|->
name|flags
operator|&=
operator|~
operator|(
name|FLAG_AUTOKEY
operator||
name|FLAG_ASSOC
operator|)
expr_stmt|;
name|peer
operator|->
name|estbdelay
operator|=
name|sys_bdelay
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|kpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
name|peer
operator|->
name|pollsw
operator|=
name|FALSE
expr_stmt|;
name|peer
operator|->
name|jitter
operator|=
name|MAXDISPERSE
expr_stmt|;
name|peer
operator|->
name|epoch
operator|=
name|current_time
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|)
condition|)
block|{
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|peer
operator|->
name|filter_disp
index|[
name|i
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
name|peer
operator|->
name|filter_epoch
index|[
name|i
index|]
operator|=
name|current_time
expr_stmt|;
block|}
comment|/* 	 * Randomize the first poll over 1-16s to avoid bunching. 	 */
name|peer
operator|->
name|update
operator|=
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
name|u_rand
operator|=
name|RANDOM
expr_stmt|;
name|peer
operator|->
name|nextdate
operator|=
name|current_time
operator|+
operator|(
name|u_rand
operator|&
operator|(
operator|(
literal|1
operator|<<
name|BURST_INTERVAL1
operator|)
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_filter - add incoming clock sample to filter register and run  *		  the filter procedure to find the best sample.  */
end_comment

begin_function
name|void
name|clock_filter
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample_offset
parameter_list|,
comment|/* clock offset */
name|double
name|sample_delay
parameter_list|,
comment|/* roundtrip delay */
name|double
name|sample_disp
comment|/* dispersion */
parameter_list|)
block|{
name|double
name|dst
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* distance vector */
name|int
name|ord
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* index vector */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|;
name|double
name|dsp
decl_stmt|,
name|jit
decl_stmt|,
name|dtemp
decl_stmt|,
name|etemp
decl_stmt|;
comment|/* 	 * Shift the new sample into the register and discard the oldest 	 * one. The new offset and delay come directly from the 	 * timestamp calculations. The dispersion grows from the last 	 * outbound packet or reference clock update to the present time 	 * and increased by the sum of the peer precision and the system 	 * precision. The delay can sometimes swing negative due to 	 * frequency skew, so it is clamped non-negative. 	 */
name|dsp
operator|=
name|min
argument_list|(
name|LOGTOD
argument_list|(
name|peer
operator|->
name|precision
argument_list|)
operator|+
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
operator|+
name|sample_disp
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
name|j
operator|=
name|peer
operator|->
name|filter_nextpt
expr_stmt|;
name|peer
operator|->
name|filter_offset
index|[
name|j
index|]
operator|=
name|sample_offset
expr_stmt|;
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|sample_delay
argument_list|)
expr_stmt|;
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|=
name|dsp
expr_stmt|;
name|peer
operator|->
name|filter_epoch
index|[
name|j
index|]
operator|=
name|current_time
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|j
operator|%=
name|NTP_SHIFT
expr_stmt|;
name|peer
operator|->
name|filter_nextpt
operator|=
name|j
expr_stmt|;
comment|/* 	 * Update dispersions since the last update and at the same 	 * time initialize the distance and index lists. The distance 	 * list uses a compound metric. If the sample is valid and 	 * younger than the minimum Allan intercept, use delay; 	 * otherwise, use biased dispersion. 	 */
name|dtemp
operator|=
name|clock_phi
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
expr_stmt|;
name|peer
operator|->
name|update
operator|=
name|current_time
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|+=
name|dtemp
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|>
name|MAXDISPERSE
condition|)
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|>=
name|MAXDISPERSE
condition|)
name|dst
index|[
name|i
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|update
operator|-
name|peer
operator|->
name|filter_epoch
index|[
name|j
index|]
operator|>
name|allan_xpt
condition|)
name|dst
index|[
name|i
index|]
operator|=
name|MAXDISTANCE
operator|+
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
expr_stmt|;
else|else
name|dst
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|j
operator|%=
name|NTP_SHIFT
expr_stmt|;
block|}
comment|/* 	 * Sort the samples in both lists by distance. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|dst
index|[
name|j
index|]
operator|>
name|dst
index|[
name|i
index|]
condition|)
block|{
name|k
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|j
index|]
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
name|etemp
operator|=
name|dst
index|[
name|j
index|]
expr_stmt|;
name|dst
index|[
name|j
index|]
operator|=
name|dst
index|[
name|i
index|]
expr_stmt|;
name|dst
index|[
name|i
index|]
operator|=
name|etemp
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Copy the index list to the association structure so ntpq 	 * can see it later. Prune the distance list to samples less 	 * than MAXDISTANCE, but keep at least two valid samples for 	 * jitter calculation. 	 */
name|m
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter_order
index|[
name|i
index|]
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dst
index|[
name|i
index|]
operator|>=
name|MAXDISPERSE
operator|||
operator|(
name|m
operator|>=
literal|2
operator|&&
name|dst
index|[
name|i
index|]
operator|>=
name|MAXDISTANCE
operator|)
condition|)
continue|continue;
name|m
operator|++
expr_stmt|;
block|}
comment|/* 	 * Compute the dispersion and jitter squares. The dispersion 	 * is weighted exponentially by NTP_FWEIGHT (0.5) so it is 	 * normalized close to 1.0. The jitter is the mean of the square 	 * differences relative to the lowest delay sample. If no 	 * acceptable samples remain in the shift register, quietly 	 * tiptoe home leaving only the 	 * dispersion. 	 */
name|jit
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|disp
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|ord
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|j
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|peer
operator|->
name|disp
operator|=
name|NTP_FWEIGHT
operator|*
operator|(
name|peer
operator|->
name|disp
operator|+
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|m
condition|)
name|jit
operator|+=
name|DIFF
argument_list|(
name|peer
operator|->
name|filter_offset
index|[
name|j
index|]
argument_list|,
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If no acceptable samples remain in the shift register, 	 * quietly tiptoe home leaving only the dispersion. Otherwise, 	 * save the offset, delay and jitter average. Note the jitter 	 * must not be less than the system precision. 	 */
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|etemp
operator|=
name|peer
operator|->
name|offset
expr_stmt|;
name|peer
operator|->
name|offset
operator|=
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
expr_stmt|;
name|peer
operator|->
name|delay
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|1
condition|)
name|jit
operator|/=
name|m
operator|-
literal|1
expr_stmt|;
name|peer
operator|->
name|jitter
operator|=
name|max
argument_list|(
name|jit
argument_list|,
name|SQUARE
argument_list|(
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * A new sample is useful only if it is younger than the last 	 * one used. 	 */
if|if
condition|(
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
operator|<=
name|peer
operator|->
name|epoch
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: discard %lu\n"
argument_list|,
name|peer
operator|->
name|epoch
operator|-
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * If the difference between the last offset and the current one 	 * exceeds the jitter by CLOCK_SGATE (4) and the interval since 	 * the last update is less than twice the system poll interval, 	 * consider the update a popcorn spike and ignore it. 	 */
if|if
condition|(
name|m
operator|>
literal|1
operator|&&
name|fabs
argument_list|(
name|peer
operator|->
name|offset
operator|-
name|etemp
argument_list|)
operator|>
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
operator|*
name|CLOCK_SGATE
operator|&&
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
operator|-
name|peer
operator|->
name|epoch
operator|<
operator|(
literal|1
operator|<<
operator|(
name|sys_poll
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: n %d popcorn spike %.6f jitter %.6f\n"
argument_list|,
name|m
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The mitigated sample statistics are saved for later 	 * processing, but can be processed only once. 	 */
name|peer
operator|->
name|epoch
operator|=
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
expr_stmt|;
name|peer
operator|->
name|pollsw
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: n %d off %.6f del %.6f dsp %.6f jit %.6f, age %lu\n"
argument_list|,
name|m
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|disp
argument_list|,
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
argument_list|,
name|peer
operator|->
name|update
operator|-
name|peer
operator|->
name|epoch
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * clock_select - find the pick-of-the-litter clock  */
end_comment

begin_function
name|void
name|clock_select
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|int
name|nreach
decl_stmt|,
name|nlist
decl_stmt|,
name|nl3
decl_stmt|;
name|double
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|;
name|int
name|allow
decl_stmt|,
name|found
decl_stmt|,
name|sw
decl_stmt|;
name|double
name|high
decl_stmt|,
name|low
decl_stmt|;
name|double
name|synch
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|,
name|error
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|struct
name|peer
modifier|*
name|osys_peer
decl_stmt|;
name|struct
name|peer
modifier|*
name|typeacts
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typelocal
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typepps
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typesystem
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|list_alloc
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|endpoint
modifier|*
name|endpoint
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
modifier|*
name|indx
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|peer
modifier|*
modifier|*
name|peer_list
init|=
name|NULL
decl_stmt|;
specifier|static
name|u_int
name|endpoint_size
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|indx_size
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|peer_list_size
init|=
literal|0
decl_stmt|;
comment|/* 	 * Initialize and create endpoint, index and peer lists big 	 * enough to handle all associations. 	 */
name|osys_peer
operator|=
name|sys_peer
expr_stmt|;
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|sys_prefer
operator|=
name|NULL
expr_stmt|;
name|nreach
operator|=
name|nlist
operator|=
literal|0
expr_stmt|;
name|low
operator|=
literal|1e9
expr_stmt|;
name|high
operator|=
operator|-
literal|1e9
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_SIZE
condition|;
name|n
operator|++
control|)
name|nlist
operator|+=
name|peer_hash_count
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
name|list_alloc
condition|)
block|{
if|if
condition|(
name|list_alloc
operator|>
literal|0
condition|)
block|{
name|free
argument_list|(
name|endpoint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|indx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer_list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|list_alloc
operator|<
name|nlist
condition|)
block|{
name|list_alloc
operator|+=
literal|5
expr_stmt|;
name|endpoint_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|endpoint
argument_list|)
expr_stmt|;
name|indx_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|indx
argument_list|)
expr_stmt|;
name|peer_list_size
operator|+=
literal|5
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|peer_list
argument_list|)
expr_stmt|;
block|}
name|endpoint
operator|=
operator|(
expr|struct
name|endpoint
operator|*
operator|)
name|emalloc
argument_list|(
name|endpoint_size
argument_list|)
expr_stmt|;
name|indx
operator|=
operator|(
name|int
operator|*
operator|)
name|emalloc
argument_list|(
name|indx_size
argument_list|)
expr_stmt|;
name|peer_list
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
name|peer_list_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initially, we populate the island with all the rifraff peers 	 * that happen to be lying around. Those with seriously 	 * defective clocks are immediately booted off the island. Then, 	 * the falsetickers are culled and put to sea. The truechimers 	 * remaining are subject to repeated rounds where the most 	 * unpopular at each round is kicked off. When the population 	 * has dwindled to NTP_MINCLOCK (3), the survivors split a 	 * million bucks and collectively crank the chimes. 	 */
name|nlist
operator|=
name|nl3
operator|=
literal|0
expr_stmt|;
comment|/* none yet */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_SIZE
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|n
index|]
init|;
name|peer
operator|!=
name|NULL
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_SYSPEER
expr_stmt|;
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_REJECT
expr_stmt|;
comment|/* 			 * A peer leaves the island immediately if 			 * unreachable, synchronized to us or suffers 			 * excessive root distance. Careful with the 			 * root distance, since the poll interval can 			 * increase to a day and a half. 			 */
if|if
condition|(
operator|!
name|peer
operator|->
name|reach
operator|||
operator|(
name|peer
operator|->
name|stratum
operator|>
literal|1
operator|&&
name|peer
operator|->
name|refid
operator|==
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
operator|||
name|peer
operator|->
name|stratum
operator|>=
name|STRATUM_UNSPEC
operator|||
operator|(
name|root_distance
argument_list|(
name|peer
argument_list|)
operator|>=
name|MAXDISTANCE
operator|+
literal|2
operator|*
name|clock_phi
operator|*
name|ULOGTOD
argument_list|(
name|sys_poll
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* 			 * Don't allow the local clock or modem drivers 			 * in the kitchen at this point, unless the 			 * prefer peer. Do that later, but only if 			 * nobody else is around. These guys are all 			 * configured, so we never throw them away. 			 */
if|if
condition|(
name|peer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|VMS_LOCALUNIT
argument_list|)
comment|/* wjm: local unit VMS_LOCALUNIT taken seriously */
operator|&&
name|REFCLOCKUNIT
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|!=
name|VMS_LOCALUNIT
endif|#
directive|endif
comment|/* VMS&& VMS_LOCALUNIT */
condition|)
block|{
name|typelocal
operator|=
name|peer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
continue|continue;
comment|/* no local clock */
block|}
if|if
condition|(
name|peer
operator|->
name|sstclktype
operator|==
name|CTL_SST_TS_TELEPHONE
condition|)
block|{
name|typeacts
operator|=
name|peer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
continue|continue;
comment|/* no acts */
block|}
comment|/* 			 * If we get this far, the peer can stay on the 			 * island, but does not yet have the immunity 			 * idol. 			 */
name|nreach
operator|++
expr_stmt|;
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|peer_list
index|[
name|nlist
operator|++
index|]
operator|=
name|peer
expr_stmt|;
comment|/* 			 * Insert each interval endpoint on the sorted 			 * list. 			 */
name|e
operator|=
name|peer
operator|->
name|offset
expr_stmt|;
comment|/* Upper end */
name|f
operator|=
name|root_distance
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|+
name|f
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nl3
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|indx
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|indx
index|[
name|i
index|]
expr_stmt|;
block|}
name|indx
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|-
name|f
expr_stmt|;
comment|/* Center point */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|indx
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|indx
index|[
name|i
index|]
expr_stmt|;
block|}
name|indx
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|-
name|f
expr_stmt|;
comment|/* Lower end */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|indx
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|indx
index|[
name|i
index|]
expr_stmt|;
block|}
name|indx
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl3
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: endpoint %2d %.6f\n"
argument_list|,
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
argument_list|,
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|nl3
operator|-
literal|1
expr_stmt|;
name|allow
operator|=
name|nlist
expr_stmt|;
comment|/* falsetickers assumed */
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|allow
operator|>
literal|0
condition|)
block|{
name|allow
operator|--
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|+=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|j
operator|--
control|)
block|{
name|n
operator|+=
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|>
name|allow
condition|)
break|break;
name|low
operator|=
name|endpoint
index|[
name|indx
index|[
name|i
operator|++
index|]
index|]
operator|.
name|val
expr_stmt|;
name|high
operator|=
name|endpoint
index|[
name|indx
index|[
name|j
operator|--
index|]
index|]
operator|.
name|val
expr_stmt|;
block|}
comment|/* 	 * If no survivors remain at this point, check if the local 	 * clock or modem drivers have been found. If so, nominate one 	 * of them as the only survivor. Otherwise, give up and declare 	 * us unsynchronized. 	 */
if|if
condition|(
operator|(
name|allow
operator|<<
literal|1
operator|)
operator|>=
name|nlist
condition|)
block|{
if|if
condition|(
name|typeacts
operator|!=
literal|0
condition|)
block|{
name|typeacts
operator|->
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|peer_list
index|[
literal|0
index|]
operator|=
name|typeacts
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typelocal
operator|!=
literal|0
condition|)
block|{
name|typelocal
operator|->
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|peer_list
index|[
literal|0
index|]
operator|=
name|typelocal
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|osys_peer
operator|!=
name|NULL
condition|)
block|{
name|sys_poll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYNCSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"synchronisation lost"
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|sys_survivors
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|resetmanycast
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"select: low %.6f high %.6f\n"
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Clustering algorithm. Construct candidate list in order first 	 * by stratum then by root distance. If we have more than 	 * MAXCLOCK peers, keep only the best MAXCLOCK of them. Scan the 	 * list to find falsetickers, who leave the island immediately. 	 * If a falseticker is not configured, his association raft is 	 * drowned as well. We must leave at least one peer to collect 	 * the million bucks. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
literal|1
operator|&&
operator|(
name|low
operator|>=
name|peer
operator|->
name|offset
operator|||
name|peer
operator|->
name|offset
operator|>=
name|high
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_DISTSYSPEER
expr_stmt|;
name|d
operator|=
name|root_distance
argument_list|(
name|peer
argument_list|)
operator|+
name|peer
operator|->
name|stratum
operator|*
name|MAXDISPERSE
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|NTP_MAXCLOCK
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|j
operator|-
literal|1
index|]
condition|)
continue|continue;
else|else
name|j
operator|--
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|k
operator|-
literal|1
index|]
condition|)
break|break;
name|peer_list
index|[
name|k
index|]
operator|=
name|peer_list
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|error
index|[
name|k
index|]
operator|=
name|error
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|synch
index|[
name|k
index|]
operator|=
name|synch
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|peer_list
index|[
name|k
index|]
operator|=
name|peer
expr_stmt|;
name|error
index|[
name|k
index|]
operator|=
name|peer
operator|->
name|jitter
expr_stmt|;
name|synch
index|[
name|k
index|]
operator|=
name|d
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|nlist
operator|=
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer_list
index|[
name|i
index|]
operator|->
name|status
operator|=
name|CTL_PST_SEL_SELCAND
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"select: %s distance %.6f\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|synch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Now, vote outlyers off the island by select jitter weighted 	 * by root dispersion. Continue voting as long as there are more 	 * than NTP_MINCLOCK survivors and the minimum select jitter 	 * squared is greater than the maximum peer jitter squared. Stop 	 * if we are about to discard a prefer peer, who of course has 	 * the immunity idol. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|d
operator|=
literal|1e9
expr_stmt|;
name|e
operator|=
operator|-
literal|1e9
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|error
index|[
name|i
index|]
operator|<
name|d
condition|)
name|d
operator|=
name|error
index|[
name|i
index|]
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
name|f
operator|+=
name|DIFF
argument_list|(
name|peer_list
index|[
name|j
index|]
operator|->
name|offset
argument_list|,
name|peer_list
index|[
name|i
index|]
operator|->
name|offset
argument_list|)
expr_stmt|;
name|f
operator|/=
name|nlist
operator|-
literal|1
expr_stmt|;
block|}
name|f
operator|=
name|max
argument_list|(
name|f
argument_list|,
name|SQUARE
argument_list|(
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|*
name|synch
index|[
name|i
index|]
operator|>
name|e
condition|)
block|{
name|sys_selerr
operator|=
name|f
expr_stmt|;
name|e
operator|=
name|f
operator|*
name|synch
index|[
name|i
index|]
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"select: survivors %d select %.6f peer %.6f\n"
argument_list|,
name|k
argument_list|,
name|SQRT
argument_list|(
name|sys_selerr
argument_list|)
argument_list|,
name|SQRT
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nlist
operator|<=
name|NTP_MINCLOCK
operator|||
name|sys_selerr
operator|<=
name|d
operator|||
name|peer_list
index|[
name|k
index|]
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|peer_list
index|[
name|k
index|]
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
name|unpeer
argument_list|(
name|peer_list
index|[
name|k
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|k
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
name|peer_list
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|peer_list
index|[
name|j
index|]
expr_stmt|;
name|error
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|error
index|[
name|j
index|]
expr_stmt|;
block|}
name|nlist
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * In manycast client mode we may have spooked a sizeable number 	 * of servers that we don't need. If there are at least 	 * NTP_MINCLOCK of them, the manycast message will be turned 	 * off. By the time we get here we nay be ready to prune some of 	 * them back, but we want to make sure all the candicates have 	 * had a chance. If they didn't pass the sanity and intersection 	 * tests, they have already been voted off the island. 	 */
if|if
condition|(
name|sys_survivors
operator|>=
name|NTP_MINCLOCK
operator|&&
name|nlist
operator|<
name|NTP_MINCLOCK
condition|)
name|resetmanycast
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
name|sys_survivors
operator|=
name|nlist
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: %s offset %.6f, distance %.6f poll %d\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer_list
index|[
name|i
index|]
operator|->
name|offset
argument_list|,
name|synch
index|[
name|i
index|]
argument_list|,
name|peer_list
index|[
name|i
index|]
operator|->
name|pollsw
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * What remains is a list of not greater than NTP_MINCLOCK 	 * peers. We want only a peer at the lowest stratum to become 	 * the system peer, although all survivors are eligible for the 	 * combining algorithm. First record their order, diddle the 	 * flags and clamp the poll intervals. Then, consider the peers 	 * at the lowest stratum. Of these, OR the leap bits on the 	 * assumption that, if some of them honk nonzero bits, they must 	 * know what they are doing. Also, check for prefer and pps 	 * peers. If a prefer peer is found within clock_max, update the 	 * pps switch. Of the other peers not at the lowest stratum, 	 * check if the system peer is among them and, if found, zap 	 * him. We note that the head of the list is at the lowest 	 * stratum and that unsynchronized peers cannot survive this 	 * far. 	 * 	 * Note that we go no further, unless the number of survivors is 	 * a majority of the suckers that have been found reachable and 	 * no prior source is available. This avoids the transient when 	 * one of a flock of sources is out to lunch and just happens 	 * to be the first survivor. 	 */
if|if
condition|(
name|osys_peer
operator|==
name|NULL
operator|&&
literal|2
operator|*
name|nlist
operator|<
name|min
argument_list|(
name|nreach
argument_list|,
name|NTP_MINCLOCK
argument_list|)
condition|)
return|return;
name|leap_consensus
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nlist
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYNCCAND
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_SYSPEER
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|==
name|peer_list
index|[
literal|0
index|]
operator|->
name|stratum
condition|)
block|{
name|leap_consensus
operator||=
name|peer
operator|->
name|leap
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|refclktype
operator|==
name|REFCLK_ATOM_PPS
operator|&&
name|peer
operator|->
name|stratum
operator|<
name|STRATUM_UNSPEC
condition|)
name|typepps
operator|=
name|peer
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|osys_peer
condition|)
name|typesystem
operator|=
name|peer
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
name|sys_prefer
operator|=
name|peer
expr_stmt|;
block|}
block|}
comment|/* 	 * Mitigation rules of the game. There are several types of 	 * peers that make a difference here: (1) prefer local peers 	 * (type REFCLK_LOCALCLOCK with FLAG_PREFER) or prefer modem 	 * peers (type REFCLK_NIST_ATOM etc with FLAG_PREFER), (2) pps 	 * peers (type REFCLK_ATOM_PPS), (3) remaining prefer peers 	 * (flag FLAG_PREFER), (4) the existing system peer, if any, (5) 	 * the head of the survivor list. Note that only one peer can be 	 * declared prefer. The order of preference is in the order 	 * stated. Note that all of these must be at the lowest stratum, 	 * i.e., the stratum of the head of the survivor list. 	 */
if|if
condition|(
name|sys_prefer
condition|)
name|sw
operator|=
name|sys_prefer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
operator|||
name|sys_prefer
operator|->
name|sstclktype
operator|==
name|CTL_SST_TS_TELEPHONE
operator|||
operator|!
name|typepps
expr_stmt|;
else|else
name|sw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sw
condition|)
block|{
name|sys_peer
operator|=
name|sys_prefer
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
name|sys_syserr
operator|=
name|sys_peer
operator|->
name|jitter
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: prefer offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|typepps
condition|)
block|{
name|sys_peer
operator|=
name|typepps
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_PPS
expr_stmt|;
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
name|sys_syserr
operator|=
name|sys_peer
operator|->
name|jitter
expr_stmt|;
if|if
condition|(
operator|!
name|pps_control
condition|)
name|NLOG
argument_list|(
argument|NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"pps sync enabled"
argument_list|)
expr_stmt|;
name|pps_control
operator|=
name|current_time
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: pps offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|typesystem
condition|)
name|sys_peer
operator|=
name|osys_peer
expr_stmt|;
else|else
name|sys_peer
operator|=
name|peer_list
index|[
literal|0
index|]
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
name|sys_offset
operator|=
name|clock_combine
argument_list|(
name|peer_list
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
name|sys_syserr
operator|=
name|sys_peer
operator|->
name|jitter
operator|+
name|sys_selerr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: combine offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|osys_peer
operator|!=
name|sys_peer
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|clock_update
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_combine - combine offsets from selected peers  */
end_comment

begin_function
specifier|static
name|double
name|clock_combine
parameter_list|(
name|struct
name|peer
modifier|*
modifier|*
name|peers
parameter_list|,
name|int
name|npeers
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|y
operator|=
name|z
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npeers
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|root_distance
argument_list|(
name|peers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|y
operator|+=
literal|1.
operator|/
name|x
expr_stmt|;
name|z
operator|+=
name|peers
index|[
name|i
index|]
operator|->
name|offset
operator|/
name|x
expr_stmt|;
block|}
return|return
operator|(
name|z
operator|/
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * root_distance - compute synchronization distance from peer to root  */
end_comment

begin_function
specifier|static
name|double
name|root_distance
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
comment|/* 	 * Careful squeak here. The value returned must be greater than 	 * zero blamed on the peer jitter, which must be at least the 	 * square of sys_precision. 	 */
return|return
operator|(
operator|(
name|peer
operator|->
name|rootdelay
operator|+
name|peer
operator|->
name|delay
operator|)
operator|/
literal|2
operator|+
name|peer
operator|->
name|rootdispersion
operator|+
name|peer
operator|->
name|disp
operator|+
name|clock_phi
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
operator|+
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * peer_xmit - send packet for persistent association.  */
end_comment

begin_function
specifier|static
name|void
name|peer_xmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* transmit packet */
name|int
name|sendlen
decl_stmt|,
name|authlen
decl_stmt|;
name|keyid_t
name|xkeyid
decl_stmt|;
comment|/* transmit key ID */
name|l_fp
name|xmt_tx
decl_stmt|;
comment|/* 	 * Initialize transmit packet header fields. 	 */
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|peer
operator|->
name|version
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|rec
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * If the received packet contains a MAC, the transmitted packet 	 * is authenticated and contains a MAC. If not, the transmitted 	 * packet is not authenticated. 	 * 	 * In the current I/O semantics the default interface is set 	 * until after receiving a packet and setting the right 	 * interface. So, the first packet goes out unauthenticated. 	 * That's why the really icky test next is here. 	 */
name|sendlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|)
condition|)
block|{
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|,
name|peer
operator|->
name|ttl
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The received packet contains a MAC, so the transmitted packet 	 * must be authenticated. If autokey is enabled, fuss with the 	 * various modes; otherwise, private key cryptography is used. 	 */
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
operator|)
condition|)
block|{
name|u_int
name|cmmd
decl_stmt|;
comment|/* 		 * The Public Key Dance (PKD): Cryptographic credentials 		 * are contained in extension fields, each including a 		 * 4-octet length/code word followed by a 4-octet 		 * association ID and optional additional data. Optional 		 * data includes a 4-octet data length field followed by 		 * the data itself. Request messages are sent from a 		 * configured association; response messages can be sent 		 * from a configured association or can take the fast 		 * path without ever matching an association. Response 		 * messages have the same code as the request, but have 		 * a response bit and possibly an error bit set. In this 		 * implementation, a message may contain no more than 		 * one command and no more than one response. 		 * 		 * Cryptographic session keys include both a public and 		 * a private componet. Request and response messages 		 * using extension fields are always sent with the 		 * private component set to zero. Packets without 		 * extension fields indlude the private component when 		 * the session key is generated. 		 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 			 * Allocate and initialize a keylist if not 			 * already done. Then, use the list in inverse 			 * order, discarding keys once used. Keep the 			 * latest key around until the next one, so 			 * clients can use client/server packets to 			 * compute propagation delay. 			 * 			 * Note that once a key is used from the list, 			 * it is retained in the key cache until the 			 * next key is used. This is to allow a client 			 * to retrieve the encrypted session key 			 * identifier to verify authenticity. 			 * 			 * If for some reason a key is no longer in the 			 * key cache, a birthday has happened and the 			 * pseudo-random sequence is probably broken. In 			 * that case, purge the keylist and regenerate 			 * it. 			 */
if|if
condition|(
name|peer
operator|->
name|keynumber
operator|==
literal|0
condition|)
name|make_keylist
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|keynumber
operator|--
expr_stmt|;
name|xkeyid
operator|=
name|peer
operator|->
name|keylist
index|[
name|peer
operator|->
name|keynumber
index|]
expr_stmt|;
if|if
condition|(
name|authistrusted
argument_list|(
name|xkeyid
argument_list|)
condition|)
break|break;
else|else
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|keyid
operator|=
name|xkeyid
expr_stmt|;
switch|switch
condition|(
name|peer
operator|->
name|hmode
condition|)
block|{
comment|/* 		 * In broadcast mode the autokey values are required. 		 * Send them when a new keylist is generated; otherwise, 		 * send the association ID so the client can request 		 * them at other times. 		 */
case|case
name|MODE_BROADCAST
case|:
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_ASSOC
condition|)
name|cmmd
operator|=
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
expr_stmt|;
else|else
name|cmmd
operator|=
name|CRYPTO_ASSOC
operator||
name|CRYPTO_RESP
expr_stmt|;
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|cmmd
argument_list|,
literal|0
argument_list|,
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * In symmetric modes the public key, leapsecond table, 		 * agreement parameters and autokey values are required.  		 * 		 * 1. If a response is pending, always send it first. 		 * 		 * 2. Don't send anything except a public-key request 		 *    until the public key has been stored.  		 * 		 * 3. Once the public key has been stored, don't send 		 *    anything except an agreement parameter request 		 *    until the agreement parameters have been stored. 		 * 		 * 4. Once the argeement parameters have been stored, 		 *    don't send anything except a public value request 		 *    until the agreed key has been stored. 		 * 		 * 5. When the agreed key has been stored and the key 		 *    list is regenerated, send the autokey values 		 *    gratis unless they have already been sent. 		 */
case|case
name|MODE_ACTIVE
case|:
case|case
name|MODE_PASSIVE
case|:
ifdef|#
directive|ifdef
name|PUBKEY
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
literal|0
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
operator|(
name|peer
operator|->
name|cmmd
operator|>>
literal|16
operator|)
operator||
name|CRYPTO_RESP
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|crypto
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_ASSOC
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|crypto_flags
operator|&&
name|peer
operator|->
name|pcookie
operator|.
name|tstamp
operator|==
literal|0
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_PRIV
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|crypto_flags
operator|&&
name|peer
operator|->
name|pubkey
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_NAME
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_CERT
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_CERT
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|crypto_flags
operator|&&
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_DH
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_DHPAR
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|crypto_flags
operator|&&
name|peer
operator|->
name|pcookie
operator|.
name|tstamp
operator|==
literal|0
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_DH
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
literal|0
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
operator|(
name|peer
operator|->
name|cmmd
operator|>>
literal|16
operator|)
operator||
name|CRYPTO_RESP
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|pcookie
operator|.
name|tstamp
operator|==
literal|0
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_PRIV
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PUBKEY */
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTOKEY
operator|)
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_AUTO
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_ASSOC
operator|)
operator|&&
operator|(
name|peer
operator|->
name|cmmd
operator|>>
literal|16
operator|)
operator|!=
name|CRYPTO_AUTO
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUBKEY
elseif|else
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_TAI
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_TAI
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PUBKEY */
name|peer
operator|->
name|cmmd
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 		 * In client mode, the public key, host cookie and 		 * autokey values are required. In broadcast client 		 * mode, these values must be acquired during the 		 * client/server exchange to avoid having to wait until 		 * the next key list regeneration. Otherwise, the poor 		 * dude may die a lingering death until becoming 		 * unreachable and attempting rebirth. Note that we ask 		 * for the cookie at each key list regeneration anyway. 		 */
case|case
name|MODE_CLIENT
case|:
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
literal|0
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
operator|(
name|peer
operator|->
name|cmmd
operator|>>
literal|16
operator|)
operator||
name|CRYPTO_RESP
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|crypto
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_ASSOC
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUBKEY
elseif|else
if|if
condition|(
name|crypto_flags
operator|&&
name|peer
operator|->
name|pubkey
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_NAME
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_CERT
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_CERT
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PUBKEY */
elseif|else
if|if
condition|(
name|peer
operator|->
name|pcookie
operator|.
name|tstamp
operator|==
literal|0
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_PRIV
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTOKEY
operator|)
operator|&&
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
operator|)
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_AUTO
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUBKEY
elseif|else
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_TAI
condition|)
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|CRYPTO_TAI
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PUBKEY */
name|peer
operator|->
name|cmmd
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * If extension fields are present, we must use a 		 * private value of zero and force min poll interval.   		 * Most intricate. 		 */
if|if
condition|(
name|sendlen
operator|>
name|LEN_PKT_NOMAC
condition|)
name|session_key
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|xkeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
name|xkeyid
operator|=
name|peer
operator|->
name|keyid
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|authlen
operator|=
name|authencrypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|authlen
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"transmit: no encryption key found"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST4
operator||
name|TEST5
expr_stmt|;
return|return;
block|}
name|sendlen
operator|+=
name|authlen
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|xkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendlen
operator|>
sizeof|sizeof
argument_list|(
name|xpkt
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"buffer overflow %u"
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sendpkt
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|,
name|peer
operator|->
name|ttl
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the encryption delay. Keep the minimum over 	 * the latest two samples. 	 */
name|L_SUB
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|1
index|]
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|xmt_tx
operator|.
name|l_uf
expr_stmt|;
if|if
condition|(
name|sys_authdly
index|[
literal|0
index|]
operator|<
name|sys_authdly
index|[
literal|1
index|]
condition|)
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|1
index|]
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d mac %d index %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
argument_list|,
name|authlen
argument_list|,
name|peer
operator|->
name|keynumber
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d mac %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
argument_list|,
name|authlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* AUTOKEY */
block|}
end_function

begin_comment
comment|/*  * fast_xmit - Send packet for nonpersistent association. Note that  * neither the source or destination can be a broadcast address.  */
end_comment

begin_function
specifier|static
name|void
name|fast_xmit
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
comment|/* receive packet pointer */
name|int
name|xmode
parameter_list|,
comment|/* transmit mode */
name|keyid_t
name|xkeyid
parameter_list|,
comment|/* transmit key ID */
name|int
name|mask
comment|/* restrict mask */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* transmit packet structure */
name|struct
name|pkt
modifier|*
name|rpkt
decl_stmt|;
comment|/* receive packet structure */
name|l_fp
name|xmt_ts
decl_stmt|;
comment|/* transmit timestamp */
name|l_fp
name|xmt_tx
decl_stmt|;
comment|/* transmit timestamp after authent */
name|int
name|sendlen
decl_stmt|,
name|authlen
decl_stmt|;
comment|/* 	 * Initialize transmit packet header fields from the receive 	 * buffer provided. We leave some fields intact as received. If 	 * the gazinta was from a multicast address, the gazouta must go 	 * out another way. 	 */
name|rpkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MULTICAST
condition|)
name|rbufp
operator|->
name|dstadr
operator|=
name|findinterface
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
comment|/* 	 * If the caller is restricted, return a kiss-of-death packet; 	 * otherwise, smooch politely. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|RES_DONTSERVE
operator||
name|RES_LIMITED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|RES_DEMOBILIZE
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOTINSYNC
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|xpkt
operator|.
name|refid
argument_list|,
literal|"DENY"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
block|}
name|xpkt
operator|.
name|ppoll
operator|=
name|rpkt
operator|->
name|ppoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|org
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * If the received packet contains a MAC, the transmitted packet 	 * is authenticated and contains a MAC. If not, the transmitted 	 * packet is not authenticated. 	 */
name|sendlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|==
name|sendlen
condition|)
block|{
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
literal|0
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The received packet contains a MAC, so the transmitted packet 	 * must be authenticated. For private-key cryptography, use the 	 * predefined private keys to generate the cryptosum. For 	 * autokey cryptography, use the server private value to 	 * generate the cookie, which is unique for every source- 	 * destination-key ID combination. 	 */
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|keyid_t
name|cookie
decl_stmt|;
name|u_int
name|code
decl_stmt|,
name|associd
decl_stmt|;
comment|/* 		 * The only way to get here is a reply to a legitimate 		 * client request message, so the mode must be 		 * MODE_SERVER. If an extension field is present, there 		 * can be only one and that must be a command. Do what 		 * needs, but with private value of zero so the poor 		 * jerk can decode it. If no extension field is present, 		 * use the cookie to generate the session key. 		 */
name|code
operator|=
operator|(
name|htonl
argument_list|(
name|rpkt
operator|->
name|exten
index|[
literal|0
index|]
argument_list|)
operator|>>
literal|16
operator|)
operator||
name|CRYPTO_RESP
expr_stmt|;
name|cookie
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
literal|0
argument_list|,
name|sys_private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|associd
operator|=
name|htonl
argument_list|(
name|rpkt
operator|->
name|exten
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>=
name|sendlen
operator|+
name|MAX_MAC_LEN
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
condition|)
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|xkeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|,
name|code
argument_list|,
name|cookie
argument_list|,
name|associd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|xkeyid
argument_list|,
name|cookie
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|authlen
operator|=
name|authencrypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|authlen
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|xkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendlen
operator|>
sizeof|sizeof
argument_list|(
name|xpkt
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"buffer overflow %u"
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
literal|0
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the encryption delay. Keep the minimum over the 	 * latest two samples. 	 */
name|L_SUB
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|1
index|]
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|xmt_tx
operator|.
name|l_uf
expr_stmt|;
if|if
condition|(
name|sys_authdly
index|[
literal|0
index|]
operator|<
name|sys_authdly
index|[
literal|1
index|]
condition|)
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d mac %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|xmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
argument_list|,
name|authlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_comment
comment|/*  * key_expire - purge the key list  */
end_comment

begin_function
name|void
name|key_expire
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|keylist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|peer
operator|->
name|keynumber
condition|;
name|i
operator|++
control|)
name|authtrust
argument_list|(
name|peer
operator|->
name|keylist
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|keylist
argument_list|)
expr_stmt|;
name|peer
operator|->
name|keylist
operator|=
name|NULL
expr_stmt|;
block|}
name|peer
operator|->
name|keynumber
operator|=
name|peer
operator|->
name|sndauto
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"key_expire: at %lu\n"
argument_list|,
name|current_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOKEY */
end_comment

begin_comment
comment|/*  * Find the precision of this particular machine  */
end_comment

begin_define
define|#
directive|define
name|DUSECS
value|1000000
end_define

begin_comment
comment|/* us in a s */
end_comment

begin_define
define|#
directive|define
name|HUSECS
value|(1<< 20)
end_define

begin_comment
comment|/* approx DUSECS for shifting etc */
end_comment

begin_define
define|#
directive|define
name|MINSTEP
value|5
end_define

begin_comment
comment|/* minimum clock increment (us) */
end_comment

begin_define
define|#
directive|define
name|MAXSTEP
value|20000
end_define

begin_comment
comment|/* maximum clock increment (us) */
end_comment

begin_define
define|#
directive|define
name|MINLOOPS
value|5
end_define

begin_comment
comment|/* minimum number of step samples */
end_comment

begin_comment
comment|/*  * This routine calculates the differences between successive calls to  * gettimeofday(). If a difference is less than zero, the us field  * has rolled over to the next second, so we add a second in us. If  * the difference is greater than zero and less than MINSTEP, the  * clock has been advanced by a small amount to avoid standing still.  * If the clock has advanced by a greater amount, then a timer interrupt  * has occurred and this amount represents the precision of the clock.  * In order to guard against spurious values, which could occur if we  * happen to hit a fat interrupt, we do this for MINLOOPS times and  * keep the minimum value obtained.  */
end_comment

begin_function
name|int
name|default_get_precision
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
name|struct
name|timezone
name|tzp
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
struct|struct
name|timezone
block|{
name|int
name|tz_minuteswest
decl_stmt|;
name|int
name|tz_dsttime
decl_stmt|;
block|}
name|tzp
struct|;
endif|#
directive|endif
comment|/* defined(VMS) || defined(_SEQUENT_) */
name|long
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|diff
decl_stmt|;
name|long
name|val
decl_stmt|;
name|long
name|usec
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
name|struct
name|timespec
name|ts
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
name|u_long
name|freq
decl_stmt|;
name|size_t
name|j
decl_stmt|;
comment|/* Try to see if we can find the frequency of of the counter 	 * which drives our timekeeping 	 */
name|j
operator|=
sizeof|sizeof
name|freq
expr_stmt|;
name|i
operator|=
name|sysctlbyname
argument_list|(
literal|"kern.timecounter.frequency"
argument_list|,
operator|&
name|freq
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|i
operator|=
name|sysctlbyname
argument_list|(
literal|"machdep.tsc_freq"
argument_list|,
operator|&
name|freq
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|i
operator|=
name|sysctlbyname
argument_list|(
literal|"machdep.i586_freq"
argument_list|,
operator|&
name|freq
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|i
operator|=
name|sysctlbyname
argument_list|(
literal|"machdep.i8254_freq"
argument_list|,
operator|&
name|freq
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|freq
condition|;
name|i
operator|--
control|)
name|freq
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
endif|#
directive|endif
name|usec
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|MAXSTEP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
operator|(
name|void
operator|)
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|tp
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tp
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
comment|/*  not HAVE_GETCLOCK */
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_GETCLOCK */
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MINLOOPS
operator|&&
name|usec
operator|<
name|HUSECS
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
operator|(
name|void
operator|)
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|tp
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tp
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
comment|/*  not HAVE_GETCLOCK */
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_GETCLOCK */
name|diff
operator|=
name|tp
operator|.
name|tv_usec
operator|-
name|last
expr_stmt|;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|+=
name|DUSECS
expr_stmt|;
name|usec
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|MINSTEP
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|val
condition|)
name|val
operator|=
name|diff
expr_stmt|;
block|}
block|}
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"precision = %ld usec"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|usec
operator|>=
name|HUSECS
condition|)
name|val
operator|=
name|MINSTEP
expr_stmt|;
comment|/* val<= MINSTEP; fast machine */
name|diff
operator|=
name|HUSECS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|diff
operator|>
name|val
condition|;
name|i
operator|--
control|)
name|diff
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * init_proto - initialize the protocol module's data  */
end_comment

begin_function
name|void
name|init_proto
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|dummy
decl_stmt|;
comment|/* 	 * Fill in the sys_* stuff.  Default is don't listen to 	 * broadcasting, authenticate. 	 */
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|sys_precision
operator|=
operator|(
name|s_char
operator|)
name|default_get_precision
argument_list|()
expr_stmt|;
name|sys_jitter
operator|=
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdispersion
operator|=
literal|0
expr_stmt|;
name|sys_refid
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_reftime
argument_list|)
expr_stmt|;
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|sys_survivors
operator|=
literal|0
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|sys_bclient
operator|=
literal|0
expr_stmt|;
name|sys_bdelay
operator|=
name|DEFBROADDELAY
expr_stmt|;
name|sys_authenticate
operator|=
literal|1
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|sys_authdly
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sys_stattime
operator|=
literal|0
expr_stmt|;
name|sys_badstratum
operator|=
literal|0
expr_stmt|;
name|sys_oldversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_newversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_unknownversion
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
name|sys_manycastserver
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|sys_automax
operator|=
literal|1
operator|<<
name|NTP_AUTOMAX
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 	 * Default these to enable 	 */
name|ntp_enable
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|KERNEL_FLL_BUG
name|kern_enable
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|pps_enable
operator|=
literal|0
expr_stmt|;
name|stats_control
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Some system clocks should only be adjusted in 10ms 	 * increments. 	 */
if|#
directive|if
name|defined
name|RELIANTUNIX_CLOCK
name|systime_10ms_ticks
operator|=
literal|1
expr_stmt|;
comment|/* Reliant UNIX */
elif|#
directive|elif
name|defined
name|SCO5_CLOCK
if|if
condition|(
name|sys_precision
operator|>=
operator|(
name|s_char
operator|)
operator|-
literal|10
condition|)
comment|/* pre-SCO OpenServer 5.0.6 */
name|systime_10ms_ticks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|systime_10ms_ticks
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"using 10ms tick adjustments"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * proto_config - configure the protocol module  */
end_comment

begin_function
name|void
name|proto_config
parameter_list|(
name|int
name|item
parameter_list|,
name|u_long
name|value
parameter_list|,
name|double
name|dvalue
parameter_list|)
block|{
comment|/* 	 * Figure out what he wants to change, then do it 	 */
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|PROTO_KERNEL
case|:
comment|/* 		 * Turn on/off kernel discipline 		 */
name|kern_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_NTP
case|:
comment|/* 		 * Turn on/off clock discipline 		 */
name|ntp_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_MONITOR
case|:
comment|/* 		 * Turn on/off monitoring 		 */
if|if
condition|(
name|value
condition|)
name|mon_start
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
else|else
name|mon_stop
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_FILEGEN
case|:
comment|/* 		 * Turn on/off statistics 		 */
name|stats_control
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_BROADCLIENT
case|:
comment|/* 		 * Turn on/off facility to listen to broadcasts 		 */
name|sys_bclient
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|io_setbclient
argument_list|()
expr_stmt|;
else|else
name|io_unsetbclient
argument_list|()
expr_stmt|;
break|break;
case|case
name|PROTO_MULTICAST_ADD
case|:
comment|/* 		 * Add muliticast group address 		 */
name|io_multicast_add
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_MULTICAST_DEL
case|:
comment|/* 		 * Delete multicast group address 		 */
name|io_multicast_del
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_BROADDELAY
case|:
comment|/* 		 * Set default broadcast delay 		 */
name|sys_bdelay
operator|=
name|dvalue
expr_stmt|;
break|break;
case|case
name|PROTO_AUTHENTICATE
case|:
comment|/* 		 * Specify the use of authenticated data 		 */
name|sys_authenticate
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_PPS
case|:
comment|/* 		 * Turn on/off PPS discipline 		 */
name|pps_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|REFCLOCK
case|case
name|PROTO_CAL
case|:
comment|/* 		 * Turn on/off refclock calibrate 		 */
name|cal_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* 		 * Log this error 		 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"proto_config: illegal item %d, value %ld"
argument_list|,
name|item
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * proto_clr_stats - clear protocol stat counters  */
end_comment

begin_function
name|void
name|proto_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|sys_badstratum
operator|=
literal|0
expr_stmt|;
name|sys_oldversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_newversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_unknownversion
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
name|sys_stattime
operator|=
name|current_time
expr_stmt|;
name|sys_limitrejected
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

