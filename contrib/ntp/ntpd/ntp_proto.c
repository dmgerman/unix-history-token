begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_proto.c - NTP version 4 protocol machinery  *  * ATTENTION: Get approval from Dave Mills on all changes to this file!  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|VMS_LOCALUNIT
argument_list|)
end_if

begin_comment
comment|/*wjm*/
end_comment

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * System variables are declared here. See Section 3.2 of the  * specification.  */
end_comment

begin_decl_stmt
name|u_char
name|sys_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system leap indicator */
end_comment

begin_decl_stmt
name|u_char
name|sys_stratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stratum of system */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision */
end_comment

begin_decl_stmt
name|double
name|sys_rootdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* roundtrip delay to primary source */
end_comment

begin_decl_stmt
name|double
name|sys_rootdispersion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dispersion to primary source */
end_comment

begin_decl_stmt
name|u_int32
name|sys_refid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference source for local clock */
end_comment

begin_decl_stmt
name|u_int32
name|sys_peer_refid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hashed refid of our current peer */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current local clock offset */
end_comment

begin_decl_stmt
name|l_fp
name|sys_reftime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time we were last updated */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our current peer */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_prefer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our cherished peer */
end_comment

begin_decl_stmt
name|int
name|sys_kod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kod credit */
end_comment

begin_decl_stmt
name|int
name|sys_kod_rate
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max kod packets per second */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_decl_stmt
name|u_long
name|sys_automax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum session key lifetime */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * Nonspecified system state variables.  */
end_comment

begin_decl_stmt
name|int
name|sys_bclient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* broadcast client enable */
end_comment

begin_decl_stmt
name|double
name|sys_bdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* broadcast client default delay */
end_comment

begin_decl_stmt
name|int
name|sys_calldelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modem callup delay (s) */
end_comment

begin_decl_stmt
name|int
name|sys_authenticate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* requre authentication for config */
end_comment

begin_decl_stmt
name|l_fp
name|sys_authdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|sys_authdly
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay shift reg */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|leap_consensus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* consensus of survivor leap bits */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_selerr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* select error (squares) */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_syserr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system error (squares) */
end_comment

begin_decl_stmt
name|keyid_t
name|sys_private
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private value for session seed */
end_comment

begin_decl_stmt
name|int
name|sys_manycastserver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* respond to manycast client pkts */
end_comment

begin_decl_stmt
name|int
name|peer_ntpdate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* active peers in ntpdate mode */
end_comment

begin_decl_stmt
name|int
name|sys_survivors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* truest of the truechimers */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|sys_hostname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gethostname() name */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * TOS and multicast mapping stuff  */
end_comment

begin_decl_stmt
name|int
name|sys_floor
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cluster stratum floor */
end_comment

begin_decl_stmt
name|int
name|sys_ceiling
init|=
name|STRATUM_UNSPEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cluster stratum ceiling*/
end_comment

begin_decl_stmt
name|int
name|sys_minsane
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum candidates */
end_comment

begin_decl_stmt
name|int
name|sys_minclock
init|=
name|NTP_MINCLOCK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum survivors */
end_comment

begin_decl_stmt
name|int
name|sys_cohort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cohort switch */
end_comment

begin_decl_stmt
name|int
name|sys_ttlmax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max ttl mapping vector index */
end_comment

begin_decl_stmt
name|u_char
name|sys_ttl
index|[
name|MAX_TTL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ttl mapping vector */
end_comment

begin_comment
comment|/*  * Statistics counters  */
end_comment

begin_decl_stmt
name|u_long
name|sys_stattime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time since reset */
end_comment

begin_decl_stmt
name|u_long
name|sys_received
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets received */
end_comment

begin_decl_stmt
name|u_long
name|sys_processed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets processed */
end_comment

begin_decl_stmt
name|u_long
name|sys_newversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current version */
end_comment

begin_decl_stmt
name|u_long
name|sys_oldversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recent version */
end_comment

begin_decl_stmt
name|u_long
name|sys_unknownversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* invalid version */
end_comment

begin_decl_stmt
name|u_long
name|sys_restricted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* access denied */
end_comment

begin_decl_stmt
name|u_long
name|sys_badlength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bad length or format */
end_comment

begin_decl_stmt
name|u_long
name|sys_badauth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bad authentication */
end_comment

begin_decl_stmt
name|u_long
name|sys_limitrejected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rate exceeded */
end_comment

begin_decl_stmt
specifier|static
name|double
name|root_distance
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|clock_combine
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|peer_xmit
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fast_xmit
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|,
name|keyid_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clock_update
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_get_precision
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|peer_unfit
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * transmit - Transmit Procedure. See Section 3.4.2 of the  *	specification.  */
end_comment

begin_function
name|void
name|transmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|int
name|hpoll
decl_stmt|;
comment|/* 	 * The polling state machine. There are two kinds of machines, 	 * those that never expect a reply (broadcast and manycast 	 * server modes) and those that do (all other modes). The dance 	 * is intricate... 	 */
name|hpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
operator|(
name|MDF_BCAST
operator||
name|MDF_MCAST
operator|)
condition|)
block|{
comment|/* 		 * In broadcast mode the poll interval is fixed 		 * at minpoll. 		 */
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_ACAST
condition|)
block|{
comment|/* 		 * In manycast mode we start with the minpoll interval 		 * and ttl. However, the actual poll interval is eight 		 * times the nominal poll interval shown here. If fewer 		 * than sys_minclock servers are found, the ttl is 		 * increased by one and we try again. If this continues 		 * to the max ttl, the poll interval is bumped by one 		 * and we try again. If at least sys_minclock servers 		 * are found, the poll interval increases with the 		 * system poll interval to the max and we continue 		 * indefinately. However, about once per day when the 		 * agreement parameters are refreshed, the manycast 		 * clients are reset and we start from the beginning. 		 * This is to catch and clamp the ttl to the lowest 		 * practical value and avoid knocking on spurious doors. 		 */
if|if
condition|(
name|sys_survivors
operator|<
name|sys_minclock
operator|&&
name|peer
operator|->
name|ttl
operator|<
name|sys_ttlmax
condition|)
name|peer
operator|->
name|ttl
operator|++
expr_stmt|;
name|hpoll
operator|=
name|sys_poll
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * For associations expecting a reply, the watchdog 		 * counter is bumped by one if the peer has not been 		 * heard since the previous poll. If the counter reaches 		 * the max, the poll interval is doubled and the peer is 		 * demobilized if not configured. 		 */
name|peer
operator|->
name|unreach
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|unreach
operator|>=
name|NTP_UNREACH
condition|)
block|{
name|hpoll
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
block|{
comment|/* 				 * If nothing is likely to change in 				 * future, flash the access denied bit 				 * so we won't bother the dude again. 				 */
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|,
literal|"DENY"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|,
literal|"CRYP"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST4
expr_stmt|;
block|}
else|else
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
name|u_char
name|oreach
decl_stmt|;
name|oreach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
name|peer
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
name|peer
operator|->
name|hyst
operator|*=
name|HYST_TC
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If this association has become 				 * unreachable, clear it and raise a 				 * trap. 				 */
if|if
condition|(
name|oreach
operator|!=
literal|0
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_UNREACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"INIT"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_IBURST
condition|)
name|peer
operator|->
name|burst
operator|=
name|NTP_BURST
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Here the peer is reachable. If it has 				 * not been heard for three consecutive 				 * polls, stuff the clock filter. Next, 				 * determine the poll interval. If the 				 * peer is unfit for synchronization, 				 * increase it by one; otherwise, use 				 * the system poll interval.  				 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|reach
operator|&
literal|0x07
operator|)
condition|)
block|{
name|clock_filter
argument_list|(
name|peer
argument_list|,
literal|0.
argument_list|,
literal|0.
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|peer_unfit
argument_list|(
name|peer
argument_list|)
condition|)
name|hpoll
operator|++
expr_stmt|;
else|else
name|hpoll
operator|=
name|sys_poll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_BURST
condition|)
name|peer
operator|->
name|burst
operator|=
name|NTP_BURST
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Source rate control. If we are restrained, 			 * each burst consists of only one packet. 			 */
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|,
literal|"RSTR"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|peer
operator|->
name|burst
operator|=
literal|0
expr_stmt|;
else|else
name|peer
operator|->
name|burst
operator|--
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If a broadcast client at this point, 				 * the burst has concluded, so we switch 				 * to client mode and purge the keylist, 				 * since no further transmissions will 				 * be made. 				 */
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
condition|)
block|{
name|peer
operator|->
name|hmode
operator|=
name|MODE_BCLIENT
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
block|}
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
comment|/* 				 * If ntpdate mode and the clock has not 				 * been set and all peers have completed 				 * the burst, we declare a successful 				 * failure. 				 */
if|if
condition|(
name|mode_ntpdate
condition|)
block|{
name|peer_ntpdate
operator|--
expr_stmt|;
if|if
condition|(
name|peer_ntpdate
operator|>
literal|0
condition|)
block|{
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
return|return;
block|}
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"no reply; clock not set"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * Do not transmit if in broadcast cclient mode or access has 	 * been denied.  	 */
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BCLIENT
operator|||
name|peer
operator|->
name|flash
operator|&
name|TEST4
condition|)
block|{
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 * Do not transmit in broadcast mode unless we are synchronized. 	 */
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
operator|&&
name|sys_peer
operator|==
name|NULL
condition|)
block|{
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
return|return;
block|}
name|peer_xmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * receive - Receive Procedure.  See section 3.4.3 in the specification.  */
end_comment

begin_function
name|void
name|receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* peer structure pointer */
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
comment|/* receive packet pointer */
name|int
name|hismode
decl_stmt|;
comment|/* packet mode */
name|int
name|restrict_mask
decl_stmt|;
comment|/* restrict bits */
name|int
name|has_mac
decl_stmt|;
comment|/* length of MAC field */
name|int
name|authlen
decl_stmt|;
comment|/* offset of MAC field */
name|int
name|is_authentic
decl_stmt|;
comment|/* cryptosum ok */
name|keyid_t
name|skeyid
init|=
literal|0
decl_stmt|;
comment|/* key ID */
name|struct
name|sockaddr_storage
modifier|*
name|dstadr_sin
decl_stmt|;
comment|/* active runway */
name|struct
name|peer
modifier|*
name|peer2
decl_stmt|;
comment|/* aux peer structure pointer */
name|l_fp
name|p_org
decl_stmt|;
comment|/* originate timestamp */
name|l_fp
name|p_xmt
decl_stmt|;
comment|/* transmit timestamp */
ifdef|#
directive|ifdef
name|OPENSSL
name|keyid_t
name|tkeyid
init|=
literal|0
decl_stmt|;
comment|/* temporary key ID */
name|keyid_t
name|pkeyid
init|=
literal|0
decl_stmt|;
comment|/* previous key ID */
name|struct
name|autokey
modifier|*
name|ap
decl_stmt|;
comment|/* autokey structure pointer */
name|int
name|rval
decl_stmt|;
comment|/* cookie snatcher */
endif|#
directive|endif
comment|/* OPENSSL */
name|int
name|retcode
init|=
name|AM_NOMATCH
decl_stmt|;
comment|/* 	 * Monitor the packet and get restrictions. Note that the packet 	 * length for control and private mode packets must be checked 	 * by the service routines. Note that no statistics counters are 	 * recorded for restrict violations, since these counters are in 	 * the restriction routine. Note the careful distinctions here 	 * between a packet with a format error and a packet that is 	 * simply discarded without prejudice. Some restrictions have to 	 * be handled later in order to generate a kiss-of-death packet. 	 */
comment|/* 	 * Bogus port check is before anything, since it probably 	 * reveals a clogging attack. 	 */
name|sys_received
operator|++
expr_stmt|;
if|if
condition|(
name|SRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bogus port */
block|}
name|ntp_monitor
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
name|restrict_mask
operator|=
name|restrictions
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s restrict %03x\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|restrict_mask
operator|&
name|RES_IGNORE
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no anything */
block|}
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
name|hismode
operator|=
operator|(
name|int
operator|)
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hismode
operator|==
name|MODE_PRIVATE
condition|)
block|{
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOQUERY
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no query private */
block|}
name|process_private
argument_list|(
name|rbufp
argument_list|,
operator|(
operator|(
name|restrict_mask
operator|&
name|RES_NOMODIFY
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hismode
operator|==
name|MODE_CONTROL
condition|)
block|{
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOQUERY
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no query control */
block|}
name|process_control
argument_list|(
name|rbufp
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|restrict_mask
operator|&
name|RES_DONTSERVE
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no time */
block|}
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|<
name|LEN_PKT_NOMAC
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* runt packet */
block|}
comment|/* 	 * Version check must be after the query packets, since they 	 * intentionally use early version. 	 */
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|NTP_VERSION
condition|)
block|{
name|sys_newversionpkt
operator|++
expr_stmt|;
comment|/* new version */
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|restrict_mask
operator|&
name|RES_VERSION
operator|)
operator|&&
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|>=
name|NTP_OLDVERSION
condition|)
block|{
name|sys_oldversionpkt
operator|++
expr_stmt|;
comment|/* previous version */
block|}
else|else
block|{
name|sys_unknownversion
operator|++
expr_stmt|;
return|return;
comment|/* old version */
block|}
comment|/* 	 * Figure out his mode and validate the packet. This has some 	 * legacy raunch that probably should be removed. In very early 	 * NTP versions mode 0 was equivalent to what later versions 	 * would interpret as client mode. 	 */
if|if
condition|(
name|hismode
operator|==
name|MODE_UNSPEC
condition|)
block|{
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|NTP_OLDVERSION
condition|)
block|{
name|hismode
operator|=
name|MODE_CLIENT
expr_stmt|;
block|}
else|else
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* invalid mode */
block|}
block|}
comment|/* 	 * Discard broadcast if not enabled as broadcast client. If 	 * Autokey, the wildcard interface cannot be used, so dump 	 * packets gettiing off the bus at that stop as well. This means 	 * that some systems with broken interface code, specifically 	 * Linux, will not work with Autokey. 	 */
if|if
condition|(
name|hismode
operator|==
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
operator|!
name|sys_bclient
operator|||
name|restrict_mask
operator|&
name|RES_NOPEER
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no client */
block|}
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|crypto_flags
operator|&&
name|rbufp
operator|->
name|dstadr
operator|==
name|any_interface
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no client */
block|}
endif|#
directive|endif
comment|/* OPENSSL */
block|}
comment|/* 	 * Parse the extension field if present. We figure out whether 	 * an extension field is present by measuring the MAC size. If 	 * the number of words following the packet header is 0 or 1, no 	 * MAC is present and the packet is not authenticated. If 1, the 	 * packet is a reply to a previous request that failed to 	 * authenticate. If 3, the packet is authenticated with DES; if 	 * 5, the packet is authenticated with MD5. If greater than 5, 	 * an extension field is present. If 2 or 4, the packet is a 	 * runt and goes poof! with a brilliant flash. 	 */
name|authlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
name|has_mac
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|authlen
expr_stmt|;
while|while
condition|(
name|has_mac
operator|>
literal|0
condition|)
block|{
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|has_mac
operator|%
literal|4
operator|!=
literal|0
operator|||
name|has_mac
operator|<
literal|0
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bad MAC length */
block|}
if|if
condition|(
name|has_mac
operator|==
literal|1
operator|*
literal|4
operator|||
name|has_mac
operator|==
literal|3
operator|*
literal|4
operator|||
name|has_mac
operator|==
name|MAX_MAC_LEN
condition|)
block|{
name|skeyid
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
name|u_int32
operator|*
operator|)
name|pkt
operator|)
index|[
name|authlen
operator|/
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|has_mac
operator|>
name|MAX_MAC_LEN
condition|)
block|{
name|temp
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
name|u_int32
operator|*
operator|)
name|pkt
operator|)
index|[
name|authlen
operator|/
literal|4
index|]
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|4
operator|||
name|temp
operator|>
name|NTP_MAXEXTEN
operator|||
name|temp
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bad MAC length */
block|}
name|authlen
operator|+=
name|temp
expr_stmt|;
name|has_mac
operator|-=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|sys_badlength
operator|++
expr_stmt|;
return|return;
comment|/* bad MAC length */
block|}
block|}
ifdef|#
directive|ifdef
name|OPENSSL
name|pkeyid
operator|=
name|tkeyid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * We have tossed out as many buggy packets as possible early in 	 * the game to reduce the exposure to a clogging attack. Now we 	 * have to burn some cycles to find the association and 	 * authenticate the packet if required. Note that we burn only 	 * MD5 cycles, again to reduce exposure. There may be no 	 * matching association and that's okay. 	 * 	 * More on the autokey mambo. Normally the local interface is 	 * found when the association was mobilized with respect to a 	 * designated remote address. We assume packets arriving from 	 * the remote address arrive via this interface and the local 	 * address used to construct the autokey is the unicast address 	 * of the interface. However, if the sender is a broadcaster, 	 * the interface broadcast address is used instead. 	 * Notwithstanding this technobabble, if the sender is a 	 * multicaster, the broadcast address is null, so we use the 	 * unicast address anyway. Don't ask. 	 */
name|peer
operator|=
name|findpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|rbufp
operator|->
name|fd
argument_list|,
name|hismode
argument_list|,
operator|&
name|retcode
argument_list|)
expr_stmt|;
name|is_authentic
operator|=
literal|0
expr_stmt|;
name|dstadr_sin
operator|=
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
expr_stmt|;
if|if
condition|(
name|has_mac
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s mode %d code %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* 		 * For autokey modes, generate the session key 		 * and install in the key cache. Use the socket 		 * broadcast or unicast address as appropriate. 		 */
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
comment|/* 			 * More on the autokey dance (AKD). A cookie is 			 * constructed from public and private values. 			 * For broadcast packets, the cookie is public 			 * (zero). For packets that match no 			 * association, the cookie is hashed from the 			 * addresses and private value. For server 			 * packets, the cookie was previously obtained 			 * from the server. For symmetric modes, the 			 * cookie was previously constructed using an 			 * agreement protocol; however, should PKI be 			 * unavailable, we construct a fake agreement as 			 * the EXOR of the peer and host cookies. 			 * 			 * hismode	ephemeral	persistent 			 * ======================================= 			 * active	0		cookie# 			 * passive	0%		cookie# 			 * client	sys cookie	0% 			 * server	0%		sys cookie 			 * broadcast	0		0 			 * 			 * # if unsync, 0 			 * % can't happen 			 */
if|if
condition|(
name|hismode
operator|==
name|MODE_BROADCAST
condition|)
block|{
comment|/* 				 * For broadcaster, use the interface 				 * broadcast address when available; 				 * otherwise, use the unicast address 				 * found when the association was 				 * mobilized. 				 */
name|pkeyid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SOCKNUL
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|bcast
argument_list|)
condition|)
name|dstadr_sin
operator|=
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|bcast
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
block|{
name|pkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
literal|0
argument_list|,
name|sys_private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkeyid
operator|=
name|peer
operator|->
name|pcookie
expr_stmt|;
block|}
comment|/* 			 * The session key includes both the public 			 * values and cookie. In case of an extension 			 * field, the cookie used for authentication 			 * purposes is zero. Note the hash is saved for 			 * use later in the autokey mambo. 			 */
if|if
condition|(
name|authlen
operator|>
name|LEN_PKT_NOMAC
operator|&&
name|pkeyid
operator|!=
literal|0
condition|)
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
name|pkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|skeyid
argument_list|,
name|pkeyid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 		 * Compute the cryptosum. Note a clogging attack may 		 * succeed in bloating the key cache. If an autokey, 		 * purge it immediately, since we won't be needing it 		 * again. If the packet is authentic, it may mobilize an 		 * association. 		 */
if|if
condition|(
name|authdecrypt
argument_list|(
name|skeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|pkt
argument_list|,
name|authlen
argument_list|,
name|has_mac
argument_list|)
condition|)
block|{
name|is_authentic
operator|=
literal|1
expr_stmt|;
name|restrict_mask
operator|&=
operator|~
name|RES_DONTTRUST
expr_stmt|;
block|}
else|else
block|{
name|sys_badauth
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|skeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|skeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: at %ld %s<-%s mode %d code %d keyid %08x len %d mac %d auth %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
name|dstadr_sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|hismode
argument_list|,
name|retcode
argument_list|,
name|skeyid
argument_list|,
name|authlen
argument_list|,
name|has_mac
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * The association matching rules are implemented by a set of 	 * routines and a table in ntp_peer.c. A packet matching an 	 * association is processed by that association. If not and 	 * certain conditions prevail, then an ephemeral association is 	 * mobilized: a broadcast packet mobilizes a broadcast client 	 * aassociation; a manycast server packet mobilizes a manycast 	 * client association; a symmetric active packet mobilizes a 	 * symmetric passive association. And, the adventure 	 * continues... 	 */
switch|switch
condition|(
name|retcode
condition|)
block|{
case|case
name|AM_FXMIT
case|:
comment|/* 		 * This is a client mode packet not matching a known 		 * association. If from a manycast client we run a few 		 * sanity checks before deciding to send a unicast 		 * server response. Otherwise, it must be a client 		 * request, so send a server response and go home. 		 */
if|if
condition|(
name|sys_manycastserver
operator|&&
operator|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MULTICAST
operator|)
condition|)
block|{
comment|/* 			 * There is no reason to respond to a request if 			 * our time is worse than the manycaster or it 			 * has already synchronized to us. 			 */
if|if
condition|(
name|sys_peer
operator|==
name|NULL
operator|||
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
operator|<
name|sys_stratum
operator|||
operator|(
name|sys_cohort
operator|&&
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
operator|==
name|sys_stratum
operator|)
operator|||
name|rbufp
operator|->
name|dstadr
operator|->
name|addr_refid
operator|==
name|pkt
operator|->
name|refid
condition|)
return|return;
comment|/* manycast dropped */
block|}
comment|/* 		 * Note that we don't require an authentication check 		 * here, since we can't set the system clock; but, we do 		 * send a crypto-NAK to tell the caller about this. 		 */
if|if
condition|(
name|has_mac
operator|&&
operator|!
name|is_authentic
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
else|else
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_SERVER
argument_list|,
name|skeyid
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
case|case
name|AM_MANYCAST
case|:
comment|/* 		 * This is a server mode packet returned in response to 		 * a client mode packet sent to a multicast group 		 * address. The originate timestamp is a good nonce to 		 * reliably associate the reply with what was sent. If 		 * there is no match, that's curious and could be an 		 * intruder attempting to clog, so we just ignore it. 		 * 		 * First, make sure the packet is authentic and not 		 * restricted. If so and the manycast association is 		 * found, we mobilize a client association and copy 		 * pertinent variables from the manycast association to 		 * the new client association. 		 * 		 * There is an implosion hazard at the manycast client, 		 * since the manycast servers send the server packet 		 * immediately. If the guy is already here, don't fire 		 * up a duplicate. 		 */
if|if
condition|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no trust */
block|}
if|if
condition|(
name|sys_authenticate
operator|&&
operator|!
name|is_authentic
condition|)
return|return;
comment|/* bad auth */
if|if
condition|(
operator|(
name|peer2
operator|=
name|findmanycastpeer
argument_list|(
name|rbufp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* no assoc match */
if|if
condition|(
operator|(
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_CLIENT
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
name|FLAG_IBURST
argument_list|,
name|MDF_UCAST
operator||
name|MDF_ACLNT
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* system error */
comment|/* 		 * We don't need these, but it warms the billboards. 		 */
name|peer
operator|->
name|ttl
operator|=
name|peer2
operator|->
name|ttl
expr_stmt|;
break|break;
case|case
name|AM_NEWPASS
case|:
comment|/* 		 * This is the first packet received from a symmetric 		 * active peer. First, make sure it is authentic and not 		 * restricted. If so, mobilize a passive association. 		 * If authentication fails send a crypto-NAK; otherwise, 		 * kiss the frog. 		 */
if|if
condition|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no trust */
block|}
if|if
condition|(
name|sys_authenticate
operator|&&
operator|!
name|is_authentic
condition|)
block|{
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_PASSIVE
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
comment|/* bad auth */
block|}
if|if
condition|(
operator|(
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_PASSIVE
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
literal|0
argument_list|,
name|MDF_UCAST
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* system error */
break|break;
case|case
name|AM_NEWBCL
case|:
comment|/* 		 * This is the first packet received from a broadcast 		 * server. First, make sure it is authentic and not 		 * restricted and that we are a broadcast client. If so, 		 * mobilize a broadcast client association. We don't 		 * kiss any frogs here. 		 */
if|if
condition|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
return|return;
comment|/* no trust */
block|}
if|if
condition|(
name|sys_authenticate
operator|&&
operator|!
name|is_authentic
condition|)
return|return;
comment|/* bad auth */
if|if
condition|(
operator|!
name|sys_bclient
condition|)
return|return;
comment|/* not a client */
if|if
condition|(
operator|(
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_CLIENT
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
name|FLAG_MCAST
operator||
name|FLAG_IBURST
argument_list|,
name|MDF_BCLNT
argument_list|,
literal|0
argument_list|,
name|skeyid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* system error */
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* 		 * Danger looms. If this is autokey, go process the 		 * extension fields. If something goes wrong, abandon 		 * ship and don't trust subsequent packets. 		 */
if|if
condition|(
name|crypto_flags
condition|)
block|{
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_recv
argument_list|(
name|peer
argument_list|,
name|rbufp
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
block|{
name|struct
name|sockaddr_storage
name|mskadr_sin
decl_stmt|;
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|sys_restricted
operator|++
expr_stmt|;
name|SET_HOSTMASK
argument_list|(
operator|&
name|mskadr_sin
argument_list|,
name|rbufp
operator|->
name|recv_srcadr
operator|.
name|ss_family
argument_list|)
expr_stmt|;
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
operator|&
name|mskadr_sin
argument_list|,
literal|0
argument_list|,
name|RES_DONTTRUST
operator||
name|RES_TIMEOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: bad exten %x\n"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL */
return|return;
case|case
name|AM_POSSBCL
case|:
comment|/* 		 * This is a broadcast packet received in client mode. 		 * It could happen if the initial client/server volley 		 * is not complete before the next broadcast packet is 		 * received. Be liberal in what we accept. 		 */
case|case
name|AM_PROCPKT
case|:
comment|/* 		 * This is a symmetric mode packet received in symmetric 		 * mode, a server packet received in client mode or a 		 * broadcast packet received in broadcast client mode. 		 * If it is restricted, this is very strange because it 		 * is rude to send a packet to a restricted address. If 		 * anyway, flash a restrain kiss and skedaddle to 		 * Seattle. If not authentic, leave a light on and 		 * continue. 		 */
name|peer
operator|->
name|flash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|restrict_mask
operator|&
name|RES_DONTTRUST
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"RSTR"
argument_list|)
expr_stmt|;
else|else
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
comment|/* no trust */
block|}
if|if
condition|(
name|has_mac
operator|&&
operator|!
name|is_authentic
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST5
expr_stmt|;
comment|/* bad auth */
break|break;
default|default:
comment|/* 		 * Invalid mode combination. This happens when a passive 		 * mode packet arrives and matches another passive 		 * association or no association at all, or when a 		 * server mode packet arrives and matches a broadcast 		 * client association. This is usually the result of 		 * reconfiguring a client on-fly. If authenticated 		 * passive mode packet, send a crypto-NAK; otherwise, 		 * ignore it. 		 */
if|if
condition|(
name|has_mac
operator|&&
name|hismode
operator|==
name|MODE_PASSIVE
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_ACTIVE
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: bad protocol %d\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * We do a little homework. Note we can get here with an 	 * authentication error. We Need to do this in order to validate 	 * a crypto-NAK later. Note the order of processing; it is very 	 * important to avoid livelocks, deadlocks and lockpicks. 	 */
name|peer
operator|->
name|timereceived
operator|=
name|current_time
expr_stmt|;
name|peer
operator|->
name|received
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|TEST5
condition|)
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_AUTHENTIC
expr_stmt|;
else|else
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENTIC
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
comment|/* 	 * If the packet is an old duplicate, we let it through so the 	 * extension fields will be processed. 	 */
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
block|{
comment|/* test 1 */
name|peer
operator|->
name|flash
operator||=
name|TEST1
expr_stmt|;
comment|/* dupe */
comment|/* fall through */
comment|/* 	 * For broadcast server mode, loopback checking is disabled. An 	 * authentication error probably means the server restarted or 	 * rolled a new private value. If so, dump the association 	 * and wait for the next message. 	 */
block|}
elseif|else
if|if
condition|(
name|hismode
operator|==
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|TEST5
condition|)
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fall through */
comment|/* 	 * For server and symmetric modes, if the association transmit 	 * timestamp matches the packet originate timestamp, loopback is 	 * confirmed. Note in symmetric modes this also happens when the 	 * first packet from the active peer arrives at the newly 	 * mobilized passive peer.  An authentication error probably 	 * means the server or peer restarted or rolled a new private 	 * value, but could be an intruder trying to stir up trouble. 	 * However, if this is a crypto-NAK, we know it is authentic, so 	 * dump the association and wait for the next message. 	 */
block|}
elseif|else
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|p_org
argument_list|)
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|TEST5
condition|)
block|{
if|if
condition|(
name|has_mac
operator|==
literal|4
operator|&&
name|pkt
operator|->
name|exten
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"AUTH"
argument_list|)
expr_stmt|;
else|else
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* fall through */
comment|/* 	 * If the client or passive peer has never transmitted anything, 	 * this is either the first message from a symmetric peer or 	 * possibly a duplicate received before the transmit timeout. 	 * Pass it on. 	 */
block|}
elseif|else
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
condition|)
block|{
comment|/* fall through */
comment|/* 	 * Now it gets interesting. We have transmitted at least one 	 * packet. If the packet originate timestamp is nonzero, it 	 * does not match the association transmit timestamp, which is a 	 * loopback error. This error might mean a manycast server has 	 * answered a manycast honk from us and we already have an 	 * association for him, in which case quietly drop the packet 	 * here. It might mean an old duplicate, dropped packet or 	 * intruder replay, in which case we drop it later after 	 * extension field processing, but never let it touch the time 	 * values. 	 */
block|}
elseif|else
if|if
condition|(
operator|!
name|L_ISZERO
argument_list|(
operator|&
name|p_org
argument_list|)
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_ACLNT
condition|)
return|return;
comment|/* not a client */
name|peer
operator|->
name|flash
operator||=
name|TEST2
expr_stmt|;
comment|/* fall through */
comment|/* 	 * The packet originate timestamp is zero, meaning the other guy 	 * either didn't receive the first packet or died and restarted. 	 * If the association originate timestamp is zero, this is the 	 * first packet received, so we pass it on. 	 */
block|}
elseif|else
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|)
condition|)
block|{
comment|/* fall through */
comment|/* 	 * The other guy has restarted and we are still on the wire. We 	 * should demobilize/clear and get out of Dodge. If this is 	 * symmetric mode, we should also send a crypto-NAK. 	 */
block|}
else|else
block|{
if|if
condition|(
name|hismode
operator|==
name|MODE_ACTIVE
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_PASSIVE
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hismode
operator|==
name|MODE_PASSIVE
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|MODE_ACTIVE
argument_list|,
literal|0
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: dropped %03x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"DROP"
argument_list|)
expr_stmt|;
else|else
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
operator|~
name|TEST2
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* 	 * More autokey dance. The rules of the cha-cha are as follows: 	 * 	 * 1. If there is no key or the key is not auto, do nothing. 	 * 	 * 2. If this packet is in response to the one just previously 	 *    sent or from a broadcast server, do the extension fields. 	 *    Otherwise, assume bogosity and bail out. 	 * 	 * 3. If an extension field contains a verified signature, it is 	 *    self-authenticated and we sit the dance. 	 * 	 * 4. If this is a server reply, check only to see that the 	 *    transmitted key ID matches the received key ID. 	 * 	 * 5. Check to see that one or more hashes of the current key ID 	 *    matches the previous key ID or ultimate original key ID 	 *    obtained from the broadcaster or symmetric peer. If no 	 *    match, sit the dance and wait for timeout. 	 */
if|if
condition|(
name|crypto_flags
operator|&&
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
operator|)
condition|)
block|{
name|peer
operator|->
name|flash
operator||=
name|TEST10
expr_stmt|;
name|rval
operator|=
name|crypto_recv
argument_list|(
name|peer
argument_list|,
name|rbufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|XEVNT_OK
condition|)
block|{
comment|/* fall through */
block|}
elseif|else
if|if
condition|(
name|hismode
operator|==
name|MODE_SERVER
condition|)
block|{
if|if
condition|(
name|skeyid
operator|==
name|peer
operator|->
name|keyid
condition|)
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|peer
operator|->
name|flash
operator|&
name|TEST10
condition|)
block|{
name|peer
operator|->
name|pkeyid
operator|=
name|skeyid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ap
operator|=
operator|(
expr|struct
name|autokey
operator|*
operator|)
name|peer
operator|->
name|recval
operator|.
name|ptr
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tkeyid
operator|==
name|peer
operator|->
name|pkeyid
operator|||
name|tkeyid
operator|==
name|ap
operator|->
name|key
condition|)
block|{
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
name|peer
operator|->
name|pkeyid
operator|=
name|skeyid
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|ap
operator|->
name|seq
condition|)
break|break;
name|tkeyid
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|dstadr_sin
argument_list|,
name|tkeyid
argument_list|,
name|pkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_PROV
operator|)
condition|)
comment|/* test 11 */
name|peer
operator|->
name|flash
operator||=
name|TEST11
expr_stmt|;
comment|/* not proventic */
comment|/* 		 * If the transmit queue is nonempty, clamp the host 		 * poll interval to the packet poll interval. 		 */
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
literal|0
condition|)
block|{
name|peer
operator|->
name|ppoll
operator|=
name|pkt
operator|->
name|ppoll
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the return code from extension field processing is 		 * not okay, we scrub the association and start over. 		 */
if|if
condition|(
name|rval
operator|!=
name|XEVNT_OK
condition|)
block|{
comment|/* 			 * If the return code is bad, the crypto machine 			 * may be jammed or an intruder may lurk. First, 			 * we demobilize the association, then see if 			 * the error is recoverable. 			 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"CRYP"
argument_list|)
expr_stmt|;
else|else
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: bad exten %x\n"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 		 * If TEST10 is lit, the autokey sequence has broken, 		 * which probably means the server has refreshed its 		 * private value. We reset the poll interval to the& minimum and scrub the association clean. 		 */
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
name|TEST10
operator|&&
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AUTO
condition|)
block|{
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: bad auto %03x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"AUTO"
argument_list|)
expr_stmt|;
else|else
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * We have survived the gaunt. Forward to the packet routine. If 	 * a symmetric passive association has been mobilized and the 	 * association doesn't deserve to live, it will die in the 	 * transmit routine if not reachable after timeout. However, if 	 * either symmetric mode and the crypto code has something 	 * urgent to say, we expedite the response. 	 */
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process_packet - Packet Procedure, a la Section 3.4.4 of the  *	specification. Or almost, at least. If we're in here we have a  *	reasonable expectation that we will be having a long term  *	relationship with this host.  */
end_comment

begin_function
name|void
name|process_packet
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|l_fp
modifier|*
name|recv_ts
parameter_list|)
block|{
name|l_fp
name|t34
decl_stmt|,
name|t21
decl_stmt|;
name|double
name|p_offset
decl_stmt|,
name|p_del
decl_stmt|,
name|p_disp
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
name|l_fp
name|p_rec
decl_stmt|,
name|p_xmt
decl_stmt|,
name|p_org
decl_stmt|,
name|p_reftime
decl_stmt|;
name|l_fp
name|ci
decl_stmt|;
name|u_char
name|pmode
decl_stmt|,
name|pleap
decl_stmt|,
name|pstratum
decl_stmt|;
comment|/* 	 * Swap header fields and keep the books. The books amount to 	 * the receive timestamp and poll interval in the header. We 	 * need these even if there are other problems in order to crank 	 * up the state machine. 	 */
name|sys_processed
operator|++
expr_stmt|;
name|peer
operator|->
name|processed
operator|++
expr_stmt|;
name|p_del
operator|=
name|FPTOD
argument_list|(
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|p_disp
operator|=
name|FPTOD
argument_list|(
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|reftime
argument_list|,
operator|&
name|p_reftime
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|,
operator|&
name|p_rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
name|pmode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|pleap
operator|=
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmode
operator|!=
name|MODE_BROADCAST
condition|)
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
else|else
name|p_org
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
name|pstratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
comment|/* 	 * Test for unsynchronized server. 	 */
if|if
condition|(
name|L_ISHIS
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* count old packets */
name|peer
operator|->
name|oldpkt
operator|++
expr_stmt|;
if|if
condition|(
name|pmode
operator|!=
name|MODE_BROADCAST
operator|&&
operator|(
name|L_ISZERO
argument_list|(
operator|&
name|p_rec
argument_list|)
operator|||
name|L_ISZERO
argument_list|(
operator|&
name|p_org
argument_list|)
operator|)
condition|)
comment|/* test 3 */
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynch */
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* test 3 */
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynch */
comment|/* 	 * If any tests fail, the packet is discarded leaving only the 	 * timestamps, which are enough to get the protocol started. The 	 * originate timestamp is copied from the packet transmit 	 * timestamp and the receive timestamp is copied from the 	 * packet receive timestamp. If okay so far, we save the leap, 	 * stratum and refid for billboards. 	 */
name|peer
operator|->
name|org
operator|=
name|p_xmt
expr_stmt|;
name|peer
operator|->
name|rec
operator|=
operator|*
name|recv_ts
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: bad data %03x from address: %s\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|,
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|peer
operator|->
name|leap
operator|=
name|pleap
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|pstratum
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pkt
operator|->
name|refid
expr_stmt|;
comment|/* 	 * Test for valid peer data (tests 6-8) 	 */
name|ci
operator|=
name|p_xmt
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|p_reftime
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pleap
operator|==
name|LEAP_NOTINSYNC
operator|||
comment|/* test 6 */
name|pstratum
operator|>=
name|STRATUM_UNSPEC
operator|||
name|dtemp
operator|<
literal|0
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST6
expr_stmt|;
comment|/* bad synch */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
name|sys_peer
operator|!=
name|NULL
condition|)
block|{
comment|/* test 7 */
if|if
condition|(
name|pstratum
operator|>
name|sys_stratum
operator|&&
name|pmode
operator|!=
name|MODE_ACTIVE
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST7
expr_stmt|;
comment|/* bad stratum */
block|}
if|if
condition|(
name|p_del
operator|<
literal|0
operator|||
name|p_disp
operator|<
literal|0
operator|||
name|p_del
operator|/
comment|/* test 8 */
literal|2
operator|+
name|p_disp
operator|>=
name|MAXDISPERSE
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST8
expr_stmt|;
comment|/* bad peer values */
comment|/* 	 * If any tests fail at this point, the packet is discarded. 	 */
if|if
condition|(
name|peer
operator|->
name|flash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: bad header %03x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The header is valid. Capture the remaining header values and 	 * mark as reachable. 	 */
name|record_raw_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|p_org
argument_list|,
operator|&
name|p_rec
argument_list|,
operator|&
name|p_xmt
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pmode
operator|=
name|pmode
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|pkt
operator|->
name|ppoll
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|pkt
operator|->
name|precision
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
name|p_del
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
name|p_disp
expr_stmt|;
name|peer
operator|->
name|reftime
operator|=
name|p_reftime
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|reach
operator|)
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_REACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
block|}
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If running in a client/server association, calculate the 	 * clock offset c, roundtrip delay d and dispersion e. We use 	 * the equations (reordered from those in the spec). Note that, 	 * in a broadcast association, org has been set to the time of 	 * last reception. Note the computation of dispersion includes 	 * the system precision plus that due to the frequency error 	 * since the originate time. 	 * 	 * Let t1 = p_org, t2 = p_rec, t3 = p_xmt, t4 = peer->rec: 	 */
name|t34
operator|=
name|p_xmt
expr_stmt|;
comment|/* t3 - t4 */
name|L_SUB
argument_list|(
operator|&
name|t34
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
name|t21
operator|=
name|p_rec
expr_stmt|;
comment|/* t2 - t1 */
name|L_SUB
argument_list|(
operator|&
name|t21
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|ci
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
comment|/* t4 - t1 */
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|p_disp
argument_list|)
expr_stmt|;
name|p_disp
operator|=
name|clock_phi
operator|*
name|max
argument_list|(
name|p_disp
argument_list|,
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If running in a broadcast association, the clock offset is 	 * (t1 - t0) corrected by the one-way delay, but we can't 	 * measure that directly. Therefore, we start up in MODE_CLIENT 	 * mode, set FLAG_MCAST and exchange eight messages to determine 	 * the clock offset. When the last message is sent, we switch to 	 * MODE_BCLIENT mode. The next broadcast message after that 	 * computes the broadcast offset and clears FLAG_MCAST. 	 */
name|ci
operator|=
name|t34
expr_stmt|;
if|if
condition|(
name|pmode
operator|==
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST
condition|)
block|{
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|p_offset
argument_list|)
expr_stmt|;
name|peer
operator|->
name|estbdelay
operator|=
name|peer
operator|->
name|offset
operator|-
name|p_offset
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_CLIENT
condition|)
return|return;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_MCAST
expr_stmt|;
block|}
name|DTOLFP
argument_list|(
name|peer
operator|->
name|estbdelay
argument_list|,
operator|&
name|t34
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|t34
argument_list|)
expr_stmt|;
name|p_del
operator|=
name|peer
operator|->
name|delay
expr_stmt|;
block|}
else|else
block|{
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|t21
argument_list|)
expr_stmt|;
comment|/* (t2 - t1) + (t3 - t4) */
name|L_RSHIFT
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|t21
argument_list|,
operator|&
name|t34
argument_list|)
expr_stmt|;
comment|/* (t2 - t1) - (t3 - t4) */
name|LFPTOD
argument_list|(
operator|&
name|t21
argument_list|,
name|p_del
argument_list|)
expr_stmt|;
block|}
name|p_del
operator|=
name|max
argument_list|(
name|p_del
argument_list|,
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|ci
argument_list|,
name|p_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|peer
operator|->
name|rootdelay
operator|+
name|p_del
operator|)
operator|/
literal|2.
operator|+
name|peer
operator|->
name|rootdispersion
operator|+
name|p_disp
operator|>=
name|MAXDISPERSE
condition|)
comment|/* test 9 */
name|peer
operator|->
name|flash
operator||=
name|TEST9
expr_stmt|;
comment|/* bad root distance */
comment|/* 	 * If any flasher bits remain set at this point, abandon ship. 	 * Otherwise, forward to the clock filter. 	 */
if|if
condition|(
name|peer
operator|->
name|flash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packet: bad packet data %03x\n"
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|clock_filter
argument_list|(
name|peer
argument_list|,
name|p_offset
argument_list|,
name|p_del
argument_list|,
name|p_disp
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
name|record_peer_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|disp
argument_list|,
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_update - Called at system process update intervals.  */
end_comment

begin_function
specifier|static
name|void
name|clock_update
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|oleap
decl_stmt|;
name|u_char
name|ostratum
decl_stmt|;
comment|/* 	 * Reset/adjust the system clock. Do this only if there is a 	 * system peer and the peer epoch is not older than the last 	 * update. 	 */
if|if
condition|(
name|sys_peer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sys_peer
operator|->
name|epoch
operator|<=
name|last_time
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_update: at %ld assoc %d \n"
argument_list|,
name|current_time
argument_list|,
name|peer_associations
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oleap
operator|=
name|sys_leap
expr_stmt|;
name|ostratum
operator|=
name|sys_stratum
expr_stmt|;
switch|switch
condition|(
name|local_clock
argument_list|(
name|sys_peer
argument_list|,
name|sys_offset
argument_list|,
name|sys_syserr
argument_list|)
condition|)
block|{
comment|/* 	 * Clock is too screwed up. Just exit for now. 	 */
case|case
operator|-
literal|1
case|:
name|report_event
argument_list|(
name|EVNT_SYSFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
comment|/* 	 * Clock was stepped. Flush all time values of all peers. 	 */
case|case
literal|1
case|:
name|clear_all
argument_list|()
expr_stmt|;
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"STEP"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sys_poll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_CLOCKRESET
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|oleap
operator|!=
name|LEAP_NOTINSYNC
condition|)
name|expire_all
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
break|break;
comment|/* 	 * Update the system stratum, leap bits, root delay, root 	 * dispersion, reference ID and reference time. We also update 	 * select dispersion and max frequency error. If the leap 	 * changes, we gotta reroll the keys. 	 */
default|default:
name|sys_stratum
operator|=
call|(
name|u_char
call|)
argument_list|(
name|sys_peer
operator|->
name|stratum
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_stratum
operator|==
literal|1
operator|||
name|sys_stratum
operator|==
name|STRATUM_UNSPEC
condition|)
name|sys_refid
operator|=
name|sys_peer
operator|->
name|refid
expr_stmt|;
else|else
name|sys_refid
operator|=
name|sys_peer_refid
expr_stmt|;
name|sys_reftime
operator|=
name|sys_peer
operator|->
name|rec
expr_stmt|;
name|sys_rootdelay
operator|=
name|sys_peer
operator|->
name|rootdelay
operator|+
name|sys_peer
operator|->
name|delay
expr_stmt|;
name|sys_leap
operator|=
name|leap_consensus
expr_stmt|;
if|if
condition|(
name|oleap
operator|==
name|LEAP_NOTINSYNC
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_SYNCCHG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|expire_all
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
block|}
block|}
if|if
condition|(
name|ostratum
operator|!=
name|sys_stratum
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * poll_update - update peer poll interval  */
end_comment

begin_function
name|void
name|poll_update
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|hpoll
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OPENSSL
name|int
name|oldpoll
decl_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * A little foxtrot to determine what controls the poll 	 * interval. If the peer is reachable, but the last four polls 	 * have not been answered, use the minimum. If declared 	 * truechimer, use the system poll interval. This allows each 	 * association to ramp up the poll interval for useless sources 	 * and to clamp it to the minimum when first starting up. 	 */
ifdef|#
directive|ifdef
name|OPENSSL
name|oldpoll
operator|=
name|peer
operator|->
name|kpoll
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
if|if
condition|(
name|hpoll
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|hpoll
operator|>
name|peer
operator|->
name|maxpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
elseif|else
if|if
condition|(
name|hpoll
operator|<
name|peer
operator|->
name|minpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
else|else
name|peer
operator|->
name|hpoll
operator|=
operator|(
name|u_char
operator|)
name|hpoll
expr_stmt|;
block|}
comment|/* 	 * Bit of adventure here. If during a burst and not a poll, just 	 * slink away. If a poll, figure what the next poll should be. 	 * If a burst is pending and a reference clock or a pending 	 * crypto response, delay for one second. If the first sent in a 	 * burst, delay ten seconds for the modem to come up. For others 	 * in the burst, delay two seconds. 	 * 	 * In case of manycast server, make the poll interval, which is 	 * axtually the manycast beacon interval, eight times the system 	 * poll interval. Normally when the host poll interval settles 	 * up to 1024 s, the beacon interval settles up to 2.3 hours. 	 */
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
operator|&&
operator|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|||
name|peer
operator|->
name|crypto
operator|)
condition|)
block|{
name|peer
operator|->
name|nextdate
operator|=
name|current_time
operator|+
name|RESP_DELAY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
block|{
else|#
directive|else
comment|/* OPENSSL */
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* OPENSSL */
if|if
condition|(
name|hpoll
operator|==
literal|0
operator|&&
name|peer
operator|->
name|nextdate
operator|!=
name|current_time
condition|)
return|return;
ifdef|#
directive|ifdef
name|REFCLOCK
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|peer
operator|->
name|nextdate
operator|+=
name|RESP_DELAY
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
operator|(
name|FLAG_IBURST
operator||
name|FLAG_BURST
operator|)
operator|&&
name|peer
operator|->
name|burst
operator|==
name|NTP_BURST
condition|)
name|peer
operator|->
name|nextdate
operator|+=
name|sys_calldelay
expr_stmt|;
else|else
name|peer
operator|->
name|nextdate
operator|+=
name|BURST_DELAY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_ACAST
condition|)
block|{
if|if
condition|(
name|sys_survivors
operator|>=
name|sys_minclock
operator|||
name|peer
operator|->
name|ttl
operator|>=
name|sys_ttlmax
condition|)
name|peer
operator|->
name|kpoll
operator|=
call|(
name|u_char
call|)
argument_list|(
name|peer
operator|->
name|hpoll
operator|+
literal|3
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|kpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
name|peer
operator|->
name|nextdate
operator|=
name|peer
operator|->
name|outdate
operator|+
name|RANDPOLL
argument_list|(
name|peer
operator|->
name|kpoll
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|kpoll
operator|=
operator|(
name|u_char
operator|)
name|max
argument_list|(
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
name|peer
operator|->
name|nextdate
operator|=
name|peer
operator|->
name|outdate
operator|+
name|RANDPOLL
argument_list|(
name|peer
operator|->
name|kpoll
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|<
name|current_time
condition|)
name|peer
operator|->
name|nextdate
operator|=
name|current_time
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* 	 * Bit of crass arrogance at this point. If the poll interval 	 * has changed and we have a keylist, the lifetimes in the 	 * keylist are probably bogus. In this case purge the keylist 	 * and regenerate it later. 	 */
if|if
condition|(
name|peer
operator|->
name|kpoll
operator|!=
name|oldpoll
condition|)
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"poll_update: at %lu %s flags %04x poll %d burst %d last %lu next %lu\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|flags
argument_list|,
name|peer
operator|->
name|kpoll
argument_list|,
name|peer
operator|->
name|burst
argument_list|,
name|peer
operator|->
name|outdate
argument_list|,
name|peer
operator|->
name|nextdate
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * clear - clear peer filter registers.  See Section 3.4.8 of the spec.  */
name|void
name|peer_clear
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure */
name|char
modifier|*
name|ident
comment|/* tally lights */
parameter_list|)
block|{
name|u_char
name|oreach
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * If cryptographic credentials have been acquired, toss them to 	 * Valhalla. Note that autokeys are ephemeral, in that they are 	 * tossed immediately upon use. Therefore, the keylist can be 	 * purged anytime without needing to preserve random keys. Note 	 * that, if the peer is purged, the cryptographic variables are 	 * purged, too. This makes it much harder to sneak in some 	 * unauthenticated data in the clock filter. 	 */
name|oreach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|pkey
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|peer
operator|->
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|peer
operator|->
name|ident_pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|subject
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|issuer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|iffval
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|grpkey
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|grpkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|cmmd
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|cookval
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|recval
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|tai_leap
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|encrypt
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|sndval
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * Wipe the association clean and initialize the nonzero values. 	 */
name|memset
argument_list|(
name|CLEAR_TO_ZERO
argument_list|(
name|peer
argument_list|)
argument_list|,
literal|0
argument_list|,
name|LEN_CLEAR_TO_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|sys_peer
condition|)
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|peer
operator|->
name|estbdelay
operator|=
name|sys_bdelay
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|kpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
name|peer
operator|->
name|jitter
operator|=
name|MAXDISPERSE
expr_stmt|;
name|peer
operator|->
name|epoch
operator|=
name|current_time
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|)
condition|)
block|{
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|ident
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|ident
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|peer
operator|->
name|filter_disp
index|[
name|i
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
name|peer
operator|->
name|filter_epoch
index|[
name|i
index|]
operator|=
name|current_time
expr_stmt|;
block|}
comment|/* 	 * If he dies as a broadcast client, he comes back to life as 	 * a broadcast client in client mode in order to recover the 	 * initial autokey values. 	 */
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
condition|)
block|{
name|peer
operator|->
name|flags
operator||=
name|FLAG_MCAST
expr_stmt|;
name|peer
operator|->
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
block|}
comment|/* 	 * Randomize the first poll to avoid bunching, but only if the 	 * rascal has never been heard. During initialization use the 	 * association count to spread out the polls at one-second 	 * intervals. 	 */
name|peer
operator|->
name|nextdate
operator|=
name|peer
operator|->
name|update
operator|=
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oreach
condition|)
name|poll_update
argument_list|(
name|peer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|initializing
condition|)
name|peer
operator|->
name|nextdate
operator|=
name|current_time
operator|+
name|peer_associations
expr_stmt|;
else|else
name|peer
operator|->
name|nextdate
operator|=
name|current_time
operator|+
operator|(
name|u_int
operator|)
name|RANDOM
operator|%
name|peer_associations
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"peer_clear: at %ld assoc ID %d refid %s\n"
argument_list|,
name|current_time
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * clock_filter - add incoming clock sample to filter register and run  *		  the filter procedure to find the best sample.  */
name|void
name|clock_filter
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample_offset
parameter_list|,
comment|/* clock offset */
name|double
name|sample_delay
parameter_list|,
comment|/* roundtrip delay */
name|double
name|sample_disp
comment|/* dispersion */
parameter_list|)
block|{
name|double
name|dst
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* distance vector */
name|int
name|ord
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* index vector */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|;
name|double
name|dsp
decl_stmt|,
name|jit
decl_stmt|,
name|dtemp
decl_stmt|,
name|etemp
decl_stmt|;
comment|/* 	 * Shift the new sample into the register and discard the oldest 	 * one. The new offset and delay come directly from the 	 * timestamp calculations. The dispersion grows from the last 	 * outbound packet or reference clock update to the present time 	 * and increased by the sum of the peer precision and the system 	 * precision. The delay can sometimes swing negative due to 	 * frequency skew, so it is clamped non-negative. 	 */
name|dsp
operator|=
name|min
argument_list|(
name|LOGTOD
argument_list|(
name|peer
operator|->
name|precision
argument_list|)
operator|+
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
operator|+
name|sample_disp
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
name|j
operator|=
name|peer
operator|->
name|filter_nextpt
expr_stmt|;
name|peer
operator|->
name|filter_offset
index|[
name|j
index|]
operator|=
name|sample_offset
expr_stmt|;
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|sample_delay
argument_list|)
expr_stmt|;
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|=
name|dsp
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|j
operator|%=
name|NTP_SHIFT
expr_stmt|;
name|peer
operator|->
name|filter_nextpt
operator|=
operator|(
name|u_short
operator|)
name|j
expr_stmt|;
comment|/* 	 * Update dispersions since the last update and at the same 	 * time initialize the distance and index lists. The distance 	 * list uses a compound metric. If the sample is valid and 	 * younger than the minimum Allan intercept, use delay; 	 * otherwise, use biased dispersion. 	 */
name|dtemp
operator|=
name|clock_phi
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
expr_stmt|;
name|peer
operator|->
name|update
operator|=
name|current_time
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|+=
name|dtemp
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|>=
name|MAXDISPERSE
condition|)
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|>=
name|MAXDISPERSE
condition|)
name|dst
index|[
name|i
index|]
operator|=
name|MAXDISPERSE
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|update
operator|-
name|peer
operator|->
name|filter_epoch
index|[
name|j
index|]
operator|>
name|allan_xpt
condition|)
name|dst
index|[
name|i
index|]
operator|=
name|MAXDISTANCE
operator|+
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
expr_stmt|;
else|else
name|dst
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|j
operator|%=
name|NTP_SHIFT
expr_stmt|;
block|}
name|peer
operator|->
name|filter_epoch
index|[
name|j
index|]
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * Sort the samples in both lists by distance. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|dst
index|[
name|j
index|]
operator|>
name|dst
index|[
name|i
index|]
condition|)
block|{
name|k
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|j
index|]
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
name|etemp
operator|=
name|dst
index|[
name|j
index|]
expr_stmt|;
name|dst
index|[
name|j
index|]
operator|=
name|dst
index|[
name|i
index|]
expr_stmt|;
name|dst
index|[
name|i
index|]
operator|=
name|etemp
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Copy the index list to the association structure so ntpq 	 * can see it later. Prune the distance list to samples less 	 * than MAXDISTANCE, but keep at least two valid samples for 	 * jitter calculation. 	 */
name|m
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter_order
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|ord
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dst
index|[
name|i
index|]
operator|>=
name|MAXDISPERSE
operator|||
operator|(
name|m
operator|>=
literal|2
operator|&&
name|dst
index|[
name|i
index|]
operator|>=
name|MAXDISTANCE
operator|)
condition|)
continue|continue;
name|m
operator|++
expr_stmt|;
block|}
comment|/* 	 * Compute the dispersion and jitter squares. The dispersion 	 * is weighted exponentially by NTP_FWEIGHT (0.5) so it is 	 * normalized close to 1.0. The jitter is the mean of the square 	 * differences relative to the lowest delay sample. If no 	 * acceptable samples remain in the shift register, quietly 	 * tiptoe home leaving only the dispersion. 	 */
name|jit
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|disp
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|ord
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|j
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|peer
operator|->
name|disp
operator|=
name|NTP_FWEIGHT
operator|*
operator|(
name|peer
operator|->
name|disp
operator|+
name|peer
operator|->
name|filter_disp
index|[
name|j
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|m
condition|)
name|jit
operator|+=
name|DIFF
argument_list|(
name|peer
operator|->
name|filter_offset
index|[
name|j
index|]
argument_list|,
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If no acceptable samples remain in the shift register, 	 * quietly tiptoe home leaving only the dispersion. Otherwise, 	 * save the offset, delay and jitter average. Note the jitter 	 * must not be less than the system precision. 	 */
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|etemp
operator|=
name|fabs
argument_list|(
name|peer
operator|->
name|offset
operator|-
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|dtemp
operator|=
name|sqrt
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
expr_stmt|;
name|peer
operator|->
name|offset
operator|=
name|peer
operator|->
name|filter_offset
index|[
name|k
index|]
expr_stmt|;
name|peer
operator|->
name|delay
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|1
condition|)
name|jit
operator|/=
name|m
operator|-
literal|1
expr_stmt|;
name|peer
operator|->
name|jitter
operator|=
name|max
argument_list|(
name|jit
argument_list|,
name|SQUARE
argument_list|(
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * A new sample is useful only if it is younger than the last 	 * one used, but only if the sucker has been synchronized. 	 */
if|if
condition|(
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
operator|<=
name|peer
operator|->
name|epoch
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: discard %lu\n"
argument_list|,
name|peer
operator|->
name|epoch
operator|-
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * If the difference between the last offset and the current one 	 * exceeds the jitter by CLOCK_SGATE and the interval since the 	 * last update is less than twice the system poll interval, 	 * consider the update a popcorn spike and ignore it. 	 */
if|if
condition|(
name|m
operator|>
literal|1
operator|&&
name|etemp
operator|>
name|CLOCK_SGATE
operator|*
name|dtemp
operator|&&
call|(
name|long
call|)
argument_list|(
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
operator|-
name|peer
operator|->
name|epoch
argument_list|)
operator|<
operator|(
literal|1
operator|<<
operator|(
name|sys_poll
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: popcorn %.6f %.6f\n"
argument_list|,
name|etemp
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The mitigated sample statistics are saved for later 	 * processing. 	 */
name|peer
operator|->
name|epoch
operator|=
name|peer
operator|->
name|filter_epoch
index|[
name|k
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter: n %d off %.6f del %.6f dsp %.6f jit %.6f, age %lu\n"
argument_list|,
name|m
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|disp
argument_list|,
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
argument_list|,
name|peer
operator|->
name|update
operator|-
name|peer
operator|->
name|epoch
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * clock_select - find the pick-of-the-litter clock  *  * LOCKCLOCK: If the local clock is the prefer peer, it will always be  * enabled, even if declared falseticker, (2) only the prefer peer can  * be selected as the system peer, (3) if the external source is down,  * the system leap bits are set to 11 and the stratum set to infinity.  */
name|void
name|clock_select
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|int
name|nlist
decl_stmt|,
name|nl3
decl_stmt|;
name|double
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|;
name|int
name|allow
decl_stmt|,
name|sw
decl_stmt|,
name|osurv
decl_stmt|;
name|double
name|high
decl_stmt|,
name|low
decl_stmt|;
name|double
name|synch
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|,
name|error
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|struct
name|peer
modifier|*
name|osys_peer
decl_stmt|;
name|struct
name|peer
modifier|*
name|typeacts
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typelocal
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typepps
init|=
name|NULL
decl_stmt|;
name|struct
name|peer
modifier|*
name|typesystem
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|list_alloc
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|endpoint
modifier|*
name|endpoint
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
modifier|*
name|indx
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|peer
modifier|*
modifier|*
name|peer_list
init|=
name|NULL
decl_stmt|;
specifier|static
name|u_int
name|endpoint_size
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|indx_size
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|peer_list_size
init|=
literal|0
decl_stmt|;
comment|/* 	 * Initialize and create endpoint, index and peer lists big 	 * enough to handle all associations. 	 */
name|osys_peer
operator|=
name|sys_peer
expr_stmt|;
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|osurv
operator|=
name|sys_survivors
expr_stmt|;
name|sys_survivors
operator|=
literal|0
expr_stmt|;
name|sys_prefer
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKCLOCK
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"DOWN"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKCLOCK */
name|nlist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_SIZE
condition|;
name|n
operator|++
control|)
name|nlist
operator|+=
name|peer_hash_count
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
name|list_alloc
condition|)
block|{
if|if
condition|(
name|list_alloc
operator|>
literal|0
condition|)
block|{
name|free
argument_list|(
name|endpoint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|indx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer_list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|list_alloc
operator|<
name|nlist
condition|)
block|{
name|list_alloc
operator|+=
literal|5
expr_stmt|;
name|endpoint_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|endpoint
argument_list|)
expr_stmt|;
name|indx_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|indx
argument_list|)
expr_stmt|;
name|peer_list_size
operator|+=
literal|5
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|peer_list
argument_list|)
expr_stmt|;
block|}
name|endpoint
operator|=
name|emalloc
argument_list|(
name|endpoint_size
argument_list|)
expr_stmt|;
name|indx
operator|=
name|emalloc
argument_list|(
name|indx_size
argument_list|)
expr_stmt|;
name|peer_list
operator|=
name|emalloc
argument_list|(
name|peer_list_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initially, we populate the island with all the rifraff peers 	 * that happen to be lying around. Those with seriously 	 * defective clocks are immediately booted off the island. Then, 	 * the falsetickers are culled and put to sea. The truechimers 	 * remaining are subject to repeated rounds where the most 	 * unpopular at each round is kicked off. When the population 	 * has dwindled to sys_minclock, the survivors split a million 	 * bucks and collectively crank the chimes. 	 */
name|nlist
operator|=
name|nl3
operator|=
literal|0
expr_stmt|;
comment|/* none yet */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_SIZE
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|n
index|]
init|;
name|peer
operator|!=
name|NULL
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_SYSPEER
expr_stmt|;
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_REJECT
expr_stmt|;
comment|/* 			 * Leave the island immediately if the peer is 			 * unfit to synchronize. 			 */
if|if
condition|(
name|peer_unfit
argument_list|(
name|peer
argument_list|)
condition|)
continue|continue;
comment|/* 			 * Don't allow the local clock or modem drivers 			 * in the kitchen at this point, unless the 			 * prefer peer. Do that later, but only if 			 * nobody else is around. These guys are all 			 * configured, so we never throw them away. 			 */
if|if
condition|(
name|peer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|VMS_LOCALUNIT
argument_list|)
comment|/* wjm: VMS_LOCALUNIT taken seriously */
operator|&&
name|REFCLOCKUNIT
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|!=
name|VMS_LOCALUNIT
endif|#
directive|endif
comment|/* VMS&& VMS_LOCALUNIT */
condition|)
block|{
name|typelocal
operator|=
name|peer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
continue|continue;
comment|/* no local clock */
ifdef|#
directive|ifdef
name|LOCKCLOCK
else|else
name|sys_prefer
operator|=
name|peer
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKCLOCK */
block|}
if|if
condition|(
name|peer
operator|->
name|sstclktype
operator|==
name|CTL_SST_TS_TELEPHONE
condition|)
block|{
name|typeacts
operator|=
name|peer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
continue|continue;
comment|/* no acts */
block|}
comment|/* 			 * If we get this far, the peer can stay on the 			 * island, but does not yet have the immunity 			 * idol. 			 */
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|peer_list
index|[
name|nlist
operator|++
index|]
operator|=
name|peer
expr_stmt|;
comment|/* 			 * Insert each interval endpoint on the sorted 			 * list. 			 */
name|e
operator|=
name|peer
operator|->
name|offset
expr_stmt|;
comment|/* Upper end */
name|f
operator|=
name|root_distance
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|+
name|f
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nl3
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|indx
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|indx
index|[
name|i
index|]
expr_stmt|;
block|}
name|indx
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|-
name|f
expr_stmt|;
comment|/* Center point */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|indx
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|indx
index|[
name|i
index|]
expr_stmt|;
block|}
name|indx
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|-
name|f
expr_stmt|;
comment|/* Lower end */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|indx
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|indx
index|[
name|i
index|]
expr_stmt|;
block|}
name|indx
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl3
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: endpoint %2d %.6f\n"
argument_list|,
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
argument_list|,
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This is the actual algorithm that cleaves the truechimers 	 * from the falsetickers. The original algorithm was described 	 * in Keith Marzullo's dissertation, but has been modified for 	 * better accuracy. 	 * 	 * Briefly put, we first assume there are no falsetickers, then 	 * scan the candidate list first from the low end upwards and 	 * then from the high end downwards. The scans stop when the 	 * number of intersections equals the number of candidates less 	 * the number of falsetickers. If this doesn't happen for a 	 * given number of falsetickers, we bump the number of 	 * falsetickers and try again. If the number of falsetickers 	 * becomes equal to or greater than half the number of 	 * candidates, the Albanians have won the Byzantine wars and 	 * correct synchronization is not possible. 	 * 	 * Here, nlist is the number of candidates and allow is the 	 * number of falsetickers. 	 */
name|low
operator|=
literal|1e9
expr_stmt|;
name|high
operator|=
operator|-
literal|1e9
expr_stmt|;
for|for
control|(
name|allow
operator|=
literal|0
init|;
literal|2
operator|*
name|allow
operator|<
name|nlist
condition|;
name|allow
operator|++
control|)
block|{
name|int
name|found
decl_stmt|;
comment|/* 		 * Bound the interval (low, high) as the largest 		 * interval containing points from presumed truechimers. 		 */
name|found
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl3
condition|;
name|i
operator|++
control|)
block|{
name|low
operator|=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|val
expr_stmt|;
name|n
operator|-=
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|nlist
operator|-
name|allow
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|indx
index|[
name|i
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nl3
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|high
operator|=
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
operator|.
name|val
expr_stmt|;
name|n
operator|+=
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|nlist
operator|-
name|allow
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|indx
index|[
name|j
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
comment|/* 		 * If the number of candidates found outside the 		 * interval is greater than the number of falsetickers, 		 * then at least one truechimer is outside the interval, 		 * so go around again. This is what makes this algorithm 		 * different than Marzullo's. 		 */
if|if
condition|(
name|found
operator|>
name|allow
condition|)
continue|continue;
comment|/* 		 * If an interval containing truechimers is found, stop. 		 * If not, increase the number of falsetickers and go 		 * around again. 		 */
if|if
condition|(
name|high
operator|>
name|low
condition|)
break|break;
block|}
comment|/* 	 * If no survivors remain at this point, check if the local 	 * clock or modem drivers have been found. If so, nominate one 	 * of them as the only survivor. Otherwise, give up and leave 	 * the island to the rats. 	 */
if|if
condition|(
name|high
operator|<=
name|low
condition|)
block|{
if|if
condition|(
name|typeacts
operator|!=
literal|0
condition|)
block|{
name|typeacts
operator|->
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|peer_list
index|[
literal|0
index|]
operator|=
name|typeacts
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typelocal
operator|!=
literal|0
condition|)
block|{
name|typelocal
operator|->
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
name|peer_list
index|[
literal|0
index|]
operator|=
name|typelocal
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|osys_peer
operator|!=
name|NULL
condition|)
block|{
name|sys_poll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYNCSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"no servers reachable"
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|osurv
operator|>
literal|0
condition|)
name|resetmanycast
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * We can only trust the survivors if the number of candidates 	 * sys_minsane is at least the number required to detect and 	 * cast out one falsticker. For the Byzantine agreement 	 * algorithm used here, that number is 4; however, the default 	 * sys_minsane is 1 to speed initial synchronization. Careful 	 * operators will tinker the value to 4 and use at least that 	 * number of synchronization sources. 	 */
if|if
condition|(
name|nlist
operator|<
name|sys_minsane
condition|)
return|return;
comment|/* 	 * Clustering algorithm. Construct candidate list in order first 	 * by stratum then by root distance, but keep only the best 	 * NTP_MAXCLOCK of them. Scan the list to find falsetickers, who 	 * leave the island immediately. If a falseticker is not 	 * configured, his association raft is drowned as well, but only 	 * if at at least eight poll intervals have gone. We must leave 	 * at least one peer to collect the million bucks. 	 * 	 * Note the hysteresis gimmick that increases the effective 	 * distance for those rascals that have not made the final cut. 	 * This is to discourage clockhopping. Note also the prejudice 	 * against lower stratum peers if the floor is elevated. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
literal|1
operator|&&
operator|(
name|peer
operator|->
name|offset
operator|<=
name|low
operator|||
name|peer
operator|->
name|offset
operator|>=
name|high
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_DISTSYSPEER
expr_stmt|;
name|d
operator|=
name|peer
operator|->
name|stratum
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|sys_floor
condition|)
name|d
operator|+=
name|sys_floor
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|sys_ceiling
condition|)
name|d
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|d
operator|=
name|root_distance
argument_list|(
name|peer
argument_list|)
operator|+
name|d
operator|*
name|MAXDISTANCE
expr_stmt|;
name|d
operator|*=
literal|1.
operator|-
name|peer
operator|->
name|hyst
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|NTP_MAXCLOCK
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|j
operator|-
literal|1
index|]
condition|)
continue|continue;
else|else
name|j
operator|--
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|k
operator|-
literal|1
index|]
condition|)
break|break;
name|peer_list
index|[
name|k
index|]
operator|=
name|peer_list
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|error
index|[
name|k
index|]
operator|=
name|error
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|synch
index|[
name|k
index|]
operator|=
name|synch
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|peer_list
index|[
name|k
index|]
operator|=
name|peer
expr_stmt|;
name|error
index|[
name|k
index|]
operator|=
name|peer
operator|->
name|jitter
expr_stmt|;
name|synch
index|[
name|k
index|]
operator|=
name|d
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|nlist
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|nlist
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_select: empty intersection interval\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer_list
index|[
name|i
index|]
operator|->
name|status
operator|=
name|CTL_PST_SEL_SELCAND
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"select: %s distance %.6f jitter %.6f\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|synch
index|[
name|i
index|]
argument_list|,
name|SQRT
argument_list|(
name|error
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Now, vote outlyers off the island by select jitter weighted 	 * by root dispersion. Continue voting as long as there are more 	 * than sys_minclock survivors and the minimum select jitter 	 * squared is greater than the maximum peer jitter squared. Stop 	 * if we are about to discard a prefer peer, who of course has 	 * the immunity idol. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|d
operator|=
literal|1e9
expr_stmt|;
name|e
operator|=
operator|-
literal|1e9
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|error
index|[
name|i
index|]
operator|<
name|d
condition|)
name|d
operator|=
name|error
index|[
name|i
index|]
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
name|f
operator|+=
name|DIFF
argument_list|(
name|peer_list
index|[
name|j
index|]
operator|->
name|offset
argument_list|,
name|peer_list
index|[
name|i
index|]
operator|->
name|offset
argument_list|)
expr_stmt|;
name|f
operator|/=
name|nlist
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|*
name|synch
index|[
name|i
index|]
operator|>
name|e
condition|)
block|{
name|sys_selerr
operator|=
name|f
expr_stmt|;
name|e
operator|=
name|f
operator|*
name|synch
index|[
name|i
index|]
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
block|}
name|f
operator|=
name|max
argument_list|(
name|sys_selerr
argument_list|,
name|SQUARE
argument_list|(
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlist
operator|<=
name|sys_minclock
operator|||
name|f
operator|<=
name|d
operator|||
name|peer_list
index|[
name|k
index|]
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"select: drop %s select %.6f jitter %.6f\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|k
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|SQRT
argument_list|(
name|sys_selerr
argument_list|)
argument_list|,
name|SQRT
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|peer_list
index|[
name|k
index|]
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
name|peer_list
index|[
name|k
index|]
operator|->
name|hmode
operator|==
name|MODE_CLIENT
condition|)
name|unpeer
argument_list|(
name|peer_list
index|[
name|k
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|k
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
name|peer_list
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|peer_list
index|[
name|j
index|]
expr_stmt|;
name|error
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|error
index|[
name|j
index|]
expr_stmt|;
block|}
name|nlist
operator|--
expr_stmt|;
block|}
comment|/* 	 * What remains is a list usually not greater than sys_minclock 	 * peers. We want only a peer at the lowest stratum to become 	 * the system peer, although all survivors are eligible for the 	 * combining algorithm. First record their order, diddle the 	 * flags and clamp the poll intervals. Then, consider each peer 	 * in turn and OR the leap bits on the assumption that, if some 	 * of them honk nonzero bits, they must know what they are 	 * doing. Check for prefer and pps peers at any stratum. Check 	 * if the old system peer is among the peers at the lowest 	 * stratum. Note that the head of the list is at the lowest 	 * stratum and that unsynchronized peers cannot survive this 	 * far. 	 * 	 * Fiddle for hysteresis. Pump it up for a peer only if the peer 	 * stratum is at least the floor and there are enough survivors. 	 * This minimizes the pain when tossing out rascals beneath the 	 * floorboard. Don't count peers with stratum above the ceiling. 	 * Manycast is sooo complicated. 	 */
name|leap_consensus
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nlist
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
name|leap_consensus
operator||=
name|peer
operator|->
name|leap
expr_stmt|;
name|peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYNCCAND
expr_stmt|;
name|peer
operator|->
name|rank
operator|++
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_SYSPEER
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>=
name|sys_floor
operator|&&
name|osurv
operator|>=
name|sys_minclock
condition|)
name|peer
operator|->
name|hyst
operator|=
name|HYST
expr_stmt|;
else|else
name|peer
operator|->
name|hyst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
name|sys_ceiling
condition|)
name|sys_survivors
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
name|sys_prefer
operator|=
name|peer
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|refclktype
operator|==
name|REFCLK_ATOM_PPS
operator|&&
name|peer
operator|->
name|stratum
operator|<
name|STRATUM_UNSPEC
condition|)
name|typepps
operator|=
name|peer
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|==
name|peer_list
index|[
literal|0
index|]
operator|->
name|stratum
operator|&&
name|peer
operator|==
name|osys_peer
condition|)
name|typesystem
operator|=
name|peer
expr_stmt|;
block|}
comment|/* 	 * In manycast client mode we may have spooked a sizeable number 	 * of peers that we don't need. If there are at least 	 * sys_minclock of them, the manycast message will be turned 	 * off. By the time we get here we nay be ready to prune some of 	 * them back, but we want to make sure all the candicates have 	 * had a chance. If they didn't pass the sanity and intersection 	 * tests, they have already been voted off the island. 	 */
if|if
condition|(
name|sys_survivors
operator|<
name|sys_minclock
operator|&&
name|osurv
operator|>=
name|sys_minclock
condition|)
name|resetmanycast
argument_list|()
expr_stmt|;
comment|/* 	 * Mitigation rules of the game. There are several types of 	 * peers that make a difference here: (1) prefer local peers 	 * (type REFCLK_LOCALCLOCK with FLAG_PREFER) or prefer modem 	 * peers (type REFCLK_NIST_ATOM etc with FLAG_PREFER), (2) pps 	 * peers (type REFCLK_ATOM_PPS), (3) remaining prefer peers 	 * (flag FLAG_PREFER), (4) the existing system peer, if any, (5) 	 * the head of the survivor list. Note that only one peer can be 	 * declared prefer. The order of preference is in the order 	 * stated. Note that all of these must be at the lowest stratum, 	 * i.e., the stratum of the head of the survivor list. 	 */
if|if
condition|(
name|sys_prefer
condition|)
name|sw
operator|=
name|sys_prefer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
operator|||
name|sys_prefer
operator|->
name|sstclktype
operator|==
name|CTL_SST_TS_TELEPHONE
operator|||
operator|!
name|typepps
expr_stmt|;
else|else
name|sw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sw
condition|)
block|{
name|sys_peer
operator|=
name|sys_prefer
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
name|sys_syserr
operator|=
name|sys_peer
operator|->
name|jitter
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: prefer offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|LOCKCLOCK
elseif|else
if|if
condition|(
name|typepps
condition|)
block|{
name|sys_peer
operator|=
name|typepps
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_PPS
expr_stmt|;
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
name|sys_syserr
operator|=
name|sys_peer
operator|->
name|jitter
expr_stmt|;
if|if
condition|(
operator|!
name|pps_control
condition|)
name|NLOG
argument_list|(
argument|NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"pps sync enabled"
argument_list|)
expr_stmt|;
name|pps_control
operator|=
name|current_time
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: pps offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|typesystem
condition|)
name|sys_peer
operator|=
name|osys_peer
expr_stmt|;
else|else
name|sys_peer
operator|=
name|peer_list
index|[
literal|0
index|]
expr_stmt|;
name|sys_peer
operator|->
name|status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
name|sys_peer
operator|->
name|rank
operator|++
expr_stmt|;
name|sys_offset
operator|=
name|clock_combine
argument_list|(
name|peer_list
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
name|sys_syserr
operator|=
name|sys_peer
operator|->
name|jitter
operator|+
name|sys_selerr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"select: combine offset %.6f\n"
argument_list|,
name|sys_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* LOCKCLOCK */
if|if
condition|(
name|osys_peer
operator|!=
name|sys_peer
condition|)
block|{
name|char
modifier|*
name|src
decl_stmt|;
if|if
condition|(
name|sys_peer
operator|==
name|NULL
condition|)
name|sys_peer_refid
operator|=
literal|0
expr_stmt|;
else|else
name|sys_peer_refid
operator|=
name|addr2refid
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
condition|)
name|src
operator|=
name|refnumtoa
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|src
operator|=
name|ntoa
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYNCSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"synchronized to %s, stratum=%d"
argument_list|,
name|src
argument_list|,
name|sys_peer
operator|->
name|stratum
argument_list|)
expr_stmt|;
block|}
name|clock_update
argument_list|()
expr_stmt|;
block|}
comment|/*  * clock_combine - combine offsets from selected peers  */
specifier|static
name|double
name|clock_combine
parameter_list|(
name|struct
name|peer
modifier|*
modifier|*
name|peers
parameter_list|,
name|int
name|npeers
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|y
operator|=
name|z
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npeers
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|root_distance
argument_list|(
name|peers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|y
operator|+=
literal|1.
operator|/
name|x
expr_stmt|;
name|z
operator|+=
name|peers
index|[
name|i
index|]
operator|->
name|offset
operator|/
name|x
expr_stmt|;
block|}
return|return
operator|(
name|z
operator|/
name|y
operator|)
return|;
block|}
comment|/*  * root_distance - compute synchronization distance from peer to root  */
specifier|static
name|double
name|root_distance
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
comment|/* 	 * Careful squeak here. The value returned must be greater than 	 * zero blamed on the peer jitter, which must be at least the 	 * square of sys_precision. 	 */
return|return
operator|(
operator|(
name|peer
operator|->
name|rootdelay
operator|+
name|peer
operator|->
name|delay
operator|)
operator|/
literal|2
operator|+
name|peer
operator|->
name|rootdispersion
operator|+
name|peer
operator|->
name|disp
operator|+
name|clock_phi
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
operator|+
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
operator|)
return|;
block|}
comment|/*  * peer_xmit - send packet for persistent association.  */
specifier|static
name|void
name|peer_xmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* transmit packet */
name|int
name|sendlen
decl_stmt|,
name|authlen
decl_stmt|;
name|keyid_t
name|xkeyid
init|=
literal|0
decl_stmt|;
comment|/* transmit key ID */
name|l_fp
name|xmt_tx
decl_stmt|;
comment|/* 	 * Initialize transmit packet header fields. 	 */
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|peer
operator|->
name|version
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|rec
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * If the received packet contains a MAC, the transmitted packet 	 * is authenticated and contains a MAC. If not, the transmitted 	 * packet is not authenticated. 	 * 	 * In the current I/O semantics the default interface is set 	 * until after receiving a packet and setting the right 	 * interface. So, the first packet goes out unauthenticated. 	 * That's why the really icky test next is here. 	 */
name|sendlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|)
condition|)
block|{
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|,
name|sys_ttl
index|[
name|peer
operator|->
name|ttl
index|]
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The received packet contains a MAC, so the transmitted packet 	 * must be authenticated. If autokey is enabled, fuss with the 	 * various modes; otherwise, private key cryptography is used. 	 */
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|crypto_flags
operator|&&
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SKEY
operator|)
condition|)
block|{
name|struct
name|exten
modifier|*
name|exten
decl_stmt|;
comment|/* extension field */
name|u_int
name|opcode
decl_stmt|;
comment|/* 		 * The Public Key Dance (PKD): Cryptographic credentials 		 * are contained in extension fields, each including a 		 * 4-octet length/code word followed by a 4-octet 		 * association ID and optional additional data. Optional 		 * data includes a 4-octet data length field followed by 		 * the data itself. Request messages are sent from a 		 * configured association; response messages can be sent 		 * from a configured association or can take the fast 		 * path without ever matching an association. Response 		 * messages have the same code as the request, but have 		 * a response bit and possibly an error bit set. In this 		 * implementation, a message may contain no more than 		 * one command and no more than one response. 		 * 		 * Cryptographic session keys include both a public and 		 * a private componet. Request and response messages 		 * using extension fields are always sent with the 		 * private component set to zero. Packets without 		 * extension fields indlude the private component when 		 * the session key is generated. 		 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 			 * Allocate and initialize a keylist if not 			 * already done. Then, use the list in inverse 			 * order, discarding keys once used. Keep the 			 * latest key around until the next one, so 			 * clients can use client/server packets to 			 * compute propagation delay. 			 * 			 * Note that once a key is used from the list, 			 * it is retained in the key cache until the 			 * next key is used. This is to allow a client 			 * to retrieve the encrypted session key 			 * identifier to verify authenticity. 			 * 			 * If for some reason a key is no longer in the 			 * key cache, a birthday has happened and the 			 * pseudo-random sequence is probably broken. In 			 * that case, purge the keylist and regenerate 			 * it. 			 */
if|if
condition|(
name|peer
operator|->
name|keynumber
operator|==
literal|0
condition|)
name|make_keylist
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|keynumber
operator|--
expr_stmt|;
name|xkeyid
operator|=
name|peer
operator|->
name|keylist
index|[
name|peer
operator|->
name|keynumber
index|]
expr_stmt|;
if|if
condition|(
name|authistrusted
argument_list|(
name|xkeyid
argument_list|)
condition|)
break|break;
else|else
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|keyid
operator|=
name|xkeyid
expr_stmt|;
switch|switch
condition|(
name|peer
operator|->
name|hmode
condition|)
block|{
comment|/* 		 * In broadcast server mode the autokey values are 		 * required by the broadcast clients. Push them when a 		 * new keylist is generated; otherwise, push the 		 * association message so the client can request them at 		 * other times. 		 */
case|case
name|MODE_BROADCAST
case|:
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_ASSOC
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_ASSOC
operator||
name|CRYPTO_RESP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|&
name|xpkt
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|sendlen
argument_list|,
name|exten
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exten
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * In symmetric modes the digest, certificate, agreement 		 * parameters, cookie and autokey values are required. 		 * The leapsecond table is optional. But, a passive peer 		 * will not believe the active peer until the latter has 		 * synchronized, so the agreement must be postponed 		 * until then. In any case, if a new keylist is 		 * generated, the autokey values are pushed. 		 */
case|case
name|MODE_ACTIVE
case|:
case|case
name|MODE_PASSIVE
case|:
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
condition|)
block|{
name|peer
operator|->
name|cmmd
operator|->
name|associd
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|&
name|xpkt
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|sendlen
argument_list|,
name|peer
operator|->
name|cmmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|cmmd
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|NULL
expr_stmt|;
block|}
name|exten
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|crypto
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_ASSOC
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VALID
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_CERT
argument_list|,
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
comment|/* 			 * Identity. Note we have to sign the 			 * certificate before the cookie to avoid a 			 * deadlock when the passive peer is walking the 			 * certificate trail. Awesome. 			 */
elseif|else
if|if
condition|(
operator|(
name|opcode
operator|=
name|crypto_ident
argument_list|(
name|peer
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|opcode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_SIGN
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_SIGN
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
comment|/* 			 * Autokey. We request the cookie only when the 			 * server and client are synchronized and 			 * signatures work both ways. On the other hand, 			 * the active peer needs the autokey values 			 * before then and when the passive peer is 			 * waiting for the active peer to synchronize. 			 * Any time we regenerate the key list, we offer 			 * the autokey values without being asked. 			 */
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
name|peer
operator|->
name|leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AGREE
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_COOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_ASSOC
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AUTO
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Postamble. We trade leapseconds only when the 			 * server and client are synchronized. 			 */
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
name|peer
operator|->
name|leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_TAI
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_LEAP
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_TAI
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|exten
operator|!=
name|NULL
condition|)
block|{
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|&
name|xpkt
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|sendlen
argument_list|,
name|exten
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exten
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 * In client mode the digest, certificate, agreement 		 * parameters and cookie are required. The leapsecond 		 * table is optional. If broadcast client mode, the 		 * autokey values are required as well. In broadcast 		 * client mode, these values must be acquired during the 		 * client/server exchange to avoid having to wait until 		 * the next key list regeneration. Otherwise, the poor 		 * dude may die a lingering death until becoming 		 * unreachable and attempting rebirth. 		 * 		 * If neither the server or client have the agreement 		 * parameters, the protocol transmits the cookie in the 		 * clear. If the server has the parameters, the client 		 * requests them and the protocol blinds it using the 		 * agreed key. It is a protocol error if the client has 		 * the parameters but the server does not. 		 */
case|case
name|MODE_CLIENT
case|:
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
condition|)
block|{
name|peer
operator|->
name|cmmd
operator|->
name|associd
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|&
name|xpkt
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|sendlen
argument_list|,
name|peer
operator|->
name|cmmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|cmmd
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|NULL
expr_stmt|;
block|}
name|exten
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|crypto
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_ASSOC
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VALID
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_CERT
argument_list|,
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
comment|/* 			 * Identity. 			 */
elseif|else
if|if
condition|(
operator|(
name|opcode
operator|=
name|crypto_ident
argument_list|(
name|peer
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|opcode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Autokey 			 */
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AGREE
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_COOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AUTO
operator|)
operator|&&
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_AUTO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Postamble. We can sign the certificate here, 			 * since there is no chance of deadlock. 			 */
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_SIGN
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_SIGN
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_TAI
operator|&&
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_LEAP
operator|)
condition|)
name|exten
operator|=
name|crypto_args
argument_list|(
name|peer
argument_list|,
name|CRYPTO_TAI
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|exten
operator|!=
name|NULL
condition|)
block|{
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|&
name|xpkt
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|sendlen
argument_list|,
name|exten
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|exten
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * If extension fields are present, we must use a 		 * private value of zero and force min poll interval. 		 * Most intricate. 		 */
if|if
condition|(
name|sendlen
operator|>
name|LEN_PKT_NOMAC
condition|)
name|session_key
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|xkeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL */
name|xkeyid
operator|=
name|peer
operator|->
name|keyid
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|authlen
operator|=
name|authencrypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|authlen
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"transmit: encryption key %d not found"
argument_list|,
name|xkeyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"NKEY"
argument_list|)
expr_stmt|;
else|else
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
name|sendlen
operator|+=
name|authlen
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|xkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendlen
operator|>
sizeof|sizeof
argument_list|(
name|xpkt
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"buffer overflow %u"
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sendpkt
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|peer
operator|->
name|dstadr
argument_list|,
name|sys_ttl
index|[
name|peer
operator|->
name|ttl
index|]
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the encryption delay. Keep the minimum over 	 * the latest two samples. 	 */
name|L_SUB
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|1
index|]
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|xmt_tx
operator|.
name|l_uf
expr_stmt|;
if|if
condition|(
name|sys_authdly
index|[
literal|0
index|]
operator|<
name|sys_authdly
index|[
literal|1
index|]
condition|)
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|1
index|]
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d mac %d index %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
operator|-
name|authlen
argument_list|,
name|authlen
argument_list|,
name|peer
operator|->
name|keynumber
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d mac %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
operator|-
name|authlen
argument_list|,
name|authlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* OPENSSL */
block|}
comment|/*  * fast_xmit - Send packet for nonpersistent association. Note that  * neither the source or destination can be a broadcast address.  */
specifier|static
name|void
name|fast_xmit
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
comment|/* receive packet pointer */
name|int
name|xmode
parameter_list|,
comment|/* transmit mode */
name|keyid_t
name|xkeyid
parameter_list|,
comment|/* transmit key ID */
name|int
name|mask
comment|/* restrict mask */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* transmit packet structure */
name|struct
name|pkt
modifier|*
name|rpkt
decl_stmt|;
comment|/* receive packet structure */
name|l_fp
name|xmt_ts
decl_stmt|;
comment|/* timestamp */
name|l_fp
name|xmt_tx
decl_stmt|;
comment|/* timestamp after authent */
name|int
name|sendlen
decl_stmt|,
name|authlen
decl_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|u_int32
name|temp32
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize transmit packet header fields from the receive 	 * buffer provided. We leave some fields intact as received. If 	 * the gazinta was from a multicast address, the gazouta must go 	 * out another way. 	 */
name|rpkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MULTICAST
condition|)
name|rbufp
operator|->
name|dstadr
operator|=
name|findinterface
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
comment|/* 	 * If the packet has picked up a restriction due to either 	 * access denied or rate exceeded, decide what to do with it. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|RES_DONTTRUST
operator||
name|RES_LIMITED
operator|)
condition|)
block|{
name|char
modifier|*
name|code
init|=
literal|"????"
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|RES_LIMITED
condition|)
block|{
name|sys_limitrejected
operator|++
expr_stmt|;
name|code
operator|=
literal|"RATE"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|RES_DONTTRUST
condition|)
block|{
name|sys_restricted
operator|++
expr_stmt|;
name|code
operator|=
literal|"DENY"
expr_stmt|;
block|}
comment|/* 		 * Here we light up a kiss-of-death packet. Note the 		 * rate limit on these packets. Once a second initialize 		 * a bucket counter. Every packet sent decrements the 		 * counter until reaching zero. If the counter is zero, 		 * drop the kod. 		 */
if|if
condition|(
name|sys_kod
operator|==
literal|0
operator|||
operator|!
operator|(
name|mask
operator|&
name|RES_DEMOBILIZE
operator|)
condition|)
return|return;
name|sys_kod
operator|--
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|xpkt
operator|.
name|refid
argument_list|,
name|code
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOTINSYNC
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
block|}
else|else
block|{
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
block|}
name|xpkt
operator|.
name|ppoll
operator|=
name|rpkt
operator|->
name|ppoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|DTOFP
argument_list|(
name|sys_rootdelay
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|DTOUFP
argument_list|(
name|sys_rootdispersion
argument_list|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|org
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * If the received packet contains a MAC, the transmitted packet 	 * is authenticated and contains a MAC. If not, the transmitted 	 * packet is not authenticated. 	 */
name|sendlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|==
name|sendlen
condition|)
block|{
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
literal|0
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * The received packet contains a MAC, so the transmitted packet 	 * must be authenticated. For private-key cryptography, use the 	 * predefined private keys to generate the cryptosum. For 	 * autokey cryptography, use the server private value to 	 * generate the cookie, which is unique for every source- 	 * destination-key ID combination. 	 */
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|keyid_t
name|cookie
decl_stmt|;
comment|/* 		 * The only way to get here is a reply to a legitimate 		 * client request message, so the mode must be 		 * MODE_SERVER. If an extension field is present, there 		 * can be only one and that must be a command. Do what 		 * needs, but with private value of zero so the poor 		 * jerk can decode it. If no extension field is present, 		 * use the cookie to generate the session key. 		 */
name|cookie
operator|=
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
literal|0
argument_list|,
name|sys_private
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>=
call|(
name|int
call|)
argument_list|(
name|sendlen
operator|+
name|MAX_MAC_LEN
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
argument_list|)
condition|)
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|xkeyid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|temp32
operator|=
name|CRYPTO_RESP
expr_stmt|;
name|rpkt
operator|->
name|exten
index|[
literal|0
index|]
operator||=
name|htonl
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|crypto_xmit
argument_list|(
operator|&
name|xpkt
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|sendlen
argument_list|,
operator|(
expr|struct
name|exten
operator|*
operator|)
name|rpkt
operator|->
name|exten
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|session_key
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|xkeyid
argument_list|,
name|cookie
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* OPENSSL */
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|authlen
operator|=
name|authencrypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|sendlen
operator|+=
name|authlen
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|xkeyid
operator|>
name|NTP_MAXKEY
condition|)
name|authtrust
argument_list|(
name|xkeyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
name|get_systime
argument_list|(
operator|&
name|xmt_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendlen
operator|>
sizeof|sizeof
argument_list|(
name|xpkt
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"buffer overflow %u"
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
literal|0
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the encryption delay. Keep the minimum over the 	 * latest two samples. 	 */
name|L_SUB
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|xmt_tx
argument_list|,
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|1
index|]
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|xmt_tx
operator|.
name|l_uf
expr_stmt|;
if|if
condition|(
name|sys_authdly
index|[
literal|0
index|]
operator|<
name|sys_authdly
index|[
literal|1
index|]
condition|)
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sys_authdelay
operator|.
name|l_uf
operator|=
name|sys_authdly
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit: at %ld %s->%s mode %d keyid %08x len %d mac %d\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|xmode
argument_list|,
name|xkeyid
argument_list|,
name|sendlen
operator|-
name|authlen
argument_list|,
name|authlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OPENSSL
comment|/*  * key_expire - purge the key list  */
name|void
name|key_expire
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|keylist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|peer
operator|->
name|keynumber
condition|;
name|i
operator|++
control|)
name|authtrust
argument_list|(
name|peer
operator|->
name|keylist
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|keylist
argument_list|)
expr_stmt|;
name|peer
operator|->
name|keylist
operator|=
name|NULL
expr_stmt|;
block|}
name|value_free
argument_list|(
operator|&
name|peer
operator|->
name|sndval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|keynumber
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"key_expire: at %lu\n"
argument_list|,
name|current_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/*  * Determine if the peer is unfit for synchronization  *  * A peer is unfit for synchronization if  *> not reachable  *> a synchronization loop would form  *> never been synchronized  *> stratum undefined or too high  *> too long without synchronization  *> designated noselect  */
specifier|static
name|int
comment|/* 0 if no, 1 if yes */
name|peer_unfit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
return|return
operator|(
operator|!
name|peer
operator|->
name|reach
operator|||
operator|(
name|peer
operator|->
name|stratum
operator|>
literal|1
operator|&&
name|peer
operator|->
name|refid
operator|==
name|peer
operator|->
name|dstadr
operator|->
name|addr_refid
operator|)
operator|||
name|peer
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
operator|||
name|peer
operator|->
name|stratum
operator|>=
name|STRATUM_UNSPEC
operator|||
name|root_distance
argument_list|(
name|peer
argument_list|)
operator|>=
name|MAXDISTANCE
operator|+
literal|2.
operator|*
name|clock_phi
operator|*
name|ULOGTOD
argument_list|(
name|sys_poll
argument_list|)
operator|||
name|peer
operator|->
name|flags
operator|&
name|FLAG_NOSELECT
operator|)
return|;
block|}
comment|/*  * Find the precision of this particular machine  */
define|#
directive|define
name|MINSTEP
value|100e-9
comment|/* minimum clock increment (s) */
define|#
directive|define
name|MAXSTEP
value|20e-3
comment|/* maximum clock increment (s) */
define|#
directive|define
name|MINLOOPS
value|5
comment|/* minimum number of step samples */
comment|/*  * This routine calculates the system precision, defined as the minimum  * of a sequency of differences between successive readings of the  * system clock. However, if the system clock can be read more than once  * during a tick interval, the difference can be zero or one LSB unit,  * where the LSB corresponds to one nanosecond or one microsecond.  * Conceivably, if some other process preempts this one and reads the  * clock, the difference can be more than one LSB unit.  *  * For hardware clock frequencies of 10 MHz or less, we assume the  * logical clock advances only at the hardware clock tick. For higher  * frequencies, we assume the logical clock can advance no more than 100  * nanoseconds between ticks.  */
name|int
name|default_get_precision
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|val
decl_stmt|;
comment|/* current seconds fraction */
name|l_fp
name|last
decl_stmt|;
comment|/* last seconds fraction */
name|l_fp
name|diff
decl_stmt|;
comment|/* difference */
name|double
name|tick
decl_stmt|;
comment|/* computed tick value */
name|double
name|dtemp
decl_stmt|;
comment|/* scratch */
name|int
name|i
decl_stmt|;
comment|/* log2 precision */
comment|/* 	 * Loop to find tick value in nanoseconds. Toss out outlyer 	 * values less than the minimun tick value. In wacky cases, use 	 * the default maximum value. 	 */
name|get_systime
argument_list|(
operator|&
name|last
argument_list|)
expr_stmt|;
name|tick
operator|=
name|MAXSTEP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MINLOOPS
condition|;
control|)
block|{
name|get_systime
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
name|diff
operator|=
name|val
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
name|val
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|diff
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
name|MINSTEP
condition|)
continue|continue;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
name|tick
condition|)
name|tick
operator|=
name|dtemp
expr_stmt|;
block|}
comment|/* 	 * Find the nearest power of two. 	 */
name|NLOG
argument_list|(
argument|NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"precision = %.3f usec"
argument_list|,
name|tick
operator|*
literal|1e6
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tick
operator|<=
literal|1
condition|;
name|i
operator|++
control|)
name|tick
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|tick
operator|-
literal|1.
operator|>
literal|1.
operator|-
name|tick
operator|/
literal|2
condition|)
name|i
operator|--
expr_stmt|;
return|return
operator|(
operator|-
name|i
operator|)
return|;
block|}
comment|/*  * kod_proto - called once per second to limit kiss-of-death packets  */
name|void
name|kod_proto
parameter_list|(
name|void
parameter_list|)
block|{
name|sys_kod
operator|=
name|sys_kod_rate
expr_stmt|;
block|}
comment|/*  * init_proto - initialize the protocol module's data  */
name|void
name|init_proto
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|dummy
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Fill in the sys_* stuff.  Default is don't listen to 	 * broadcasting, authenticate. 	 */
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"INIT"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sys_precision
operator|=
operator|(
name|s_char
operator|)
name|default_get_precision
argument_list|()
expr_stmt|;
name|sys_jitter
operator|=
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdispersion
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_reftime
argument_list|)
expr_stmt|;
name|sys_peer
operator|=
name|NULL
expr_stmt|;
name|sys_survivors
operator|=
literal|0
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|sys_manycastserver
operator|=
literal|0
expr_stmt|;
name|sys_bclient
operator|=
literal|0
expr_stmt|;
name|sys_bdelay
operator|=
name|DEFBROADDELAY
expr_stmt|;
name|sys_calldelay
operator|=
name|BURST_DELAY
expr_stmt|;
name|sys_authenticate
operator|=
literal|1
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_authdelay
argument_list|)
expr_stmt|;
name|sys_authdly
index|[
literal|0
index|]
operator|=
name|sys_authdly
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sys_stattime
operator|=
literal|0
expr_stmt|;
name|proto_clr_stats
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TTL
condition|;
name|i
operator|++
control|)
block|{
name|sys_ttl
index|[
name|i
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|i
operator|*
literal|256
operator|)
operator|/
name|MAX_TTL
argument_list|)
expr_stmt|;
name|sys_ttlmax
operator|=
name|i
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL
name|sys_automax
operator|=
literal|1
operator|<<
name|NTP_AUTOMAX
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * Default these to enable 	 */
name|ntp_enable
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|KERNEL_FLL_BUG
name|kern_enable
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|pps_enable
operator|=
literal|0
expr_stmt|;
name|stats_control
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  * proto_config - configure the protocol module  */
name|void
name|proto_config
parameter_list|(
name|int
name|item
parameter_list|,
name|u_long
name|value
parameter_list|,
name|double
name|dvalue
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|svalue
parameter_list|)
block|{
comment|/* 	 * Figure out what he wants to change, then do it 	 */
switch|switch
condition|(
name|item
condition|)
block|{
comment|/* 	 * Turn on/off kernel discipline. 	 */
case|case
name|PROTO_KERNEL
case|:
name|kern_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off clock discipline. 	 */
case|case
name|PROTO_NTP
case|:
name|ntp_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off monitoring. 	 */
case|case
name|PROTO_MONITOR
case|:
if|if
condition|(
name|value
condition|)
name|mon_start
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
else|else
name|mon_stop
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off statistics. 	 */
case|case
name|PROTO_FILEGEN
case|:
name|stats_control
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off facility to listen to broadcasts. 	 */
case|case
name|PROTO_BROADCLIENT
case|:
name|sys_bclient
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|io_setbclient
argument_list|()
expr_stmt|;
else|else
name|io_unsetbclient
argument_list|()
expr_stmt|;
break|break;
comment|/* 	 * Add muliticast group address. 	 */
case|case
name|PROTO_MULTICAST_ADD
case|:
if|if
condition|(
name|svalue
condition|)
name|io_multicast_add
argument_list|(
operator|*
name|svalue
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Delete multicast group address. 	 */
case|case
name|PROTO_MULTICAST_DEL
case|:
if|if
condition|(
name|svalue
condition|)
name|io_multicast_del
argument_list|(
operator|*
name|svalue
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set default broadcast delay. 	 */
case|case
name|PROTO_BROADDELAY
case|:
name|sys_bdelay
operator|=
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set modem call delay. 	 */
case|case
name|PROTO_CALLDELAY
case|:
name|sys_calldelay
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Require authentication to mobilize ephemeral associations. 	 */
case|case
name|PROTO_AUTHENTICATE
case|:
name|sys_authenticate
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Turn on/off PPS discipline. 	 */
case|case
name|PROTO_PPS
case|:
name|pps_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
comment|/* 	 * Set the minimum number of survivors. 	 */
case|case
name|PROTO_MINCLOCK
case|:
name|sys_minclock
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set the minimum number of candidates. 	 */
case|case
name|PROTO_MINSANE
case|:
name|sys_minsane
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set the stratum floor. 	 */
case|case
name|PROTO_FLOOR
case|:
name|sys_floor
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set the stratum ceiling. 	 */
case|case
name|PROTO_CEILING
case|:
name|sys_ceiling
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set the cohort switch. 	 */
case|case
name|PROTO_COHORT
case|:
name|sys_cohort
operator|=
operator|(
name|int
operator|)
name|dvalue
expr_stmt|;
break|break;
comment|/* 	 * Set the adjtime() resolution (s). 	 */
case|case
name|PROTO_ADJ
case|:
name|sys_tick
operator|=
name|dvalue
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 	 * Turn on/off refclock calibrate 	 */
case|case
name|PROTO_CAL
case|:
name|cal_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* 		 * Log this error. 		 */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"proto_config: illegal item %d, value %ld"
argument_list|,
name|item
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * proto_clr_stats - clear protocol stat counters  */
name|void
name|proto_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|sys_stattime
operator|=
name|current_time
expr_stmt|;
name|sys_received
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_newversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_oldversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_unknownversion
operator|=
literal|0
expr_stmt|;
name|sys_restricted
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
name|sys_limitrejected
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

