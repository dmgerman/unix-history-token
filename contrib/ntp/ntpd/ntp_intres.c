begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ripped off from ../ntpres/ntpres.c by Greg Troxel 4/2/92  * routine callable from ntpd, rather than separate program  * also, key info passed in via a global, so no key file needed.  */
end_comment

begin_comment
comment|/*  * ntpres - process configuration entries which require use of the resolver  *  * This is meant to be run by ntpd on the fly.  It is not guaranteed  * to work properly if run by hand.  This is actually a quick hack to  * stave off violence from people who hate using numbers in the  * configuration file (at least I hope the rest of the daemon is  * better than this).  Also might provide some ideas about how one  * might go about autoconfiguring an NTP distribution network.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_request.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/**/
end_comment

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/**/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* MAXHOSTNAMELEN (often) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * Each item we are to resolve and configure gets one of these  * structures defined for it.  */
end_comment

begin_struct
struct|struct
name|conf_entry
block|{
name|struct
name|conf_entry
modifier|*
name|ce_next
decl_stmt|;
name|char
modifier|*
name|ce_name
decl_stmt|;
comment|/* name we are trying to resolve */
name|struct
name|conf_peer
name|ce_config
decl_stmt|;
comment|/* configuration info for peer */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ce_peeraddr
value|ce_config.peeraddr
end_define

begin_define
define|#
directive|define
name|ce_hmode
value|ce_config.hmode
end_define

begin_define
define|#
directive|define
name|ce_version
value|ce_config.version
end_define

begin_define
define|#
directive|define
name|ce_minpoll
value|ce_config.minpoll
end_define

begin_define
define|#
directive|define
name|ce_maxpoll
value|ce_config.maxpoll
end_define

begin_define
define|#
directive|define
name|ce_flags
value|ce_config.flags
end_define

begin_define
define|#
directive|define
name|ce_ttl
value|ce_config.ttl
end_define

begin_define
define|#
directive|define
name|ce_keyid
value|ce_config.keyid
end_define

begin_define
define|#
directive|define
name|ce_keystr
value|ce_config.keystr
end_define

begin_comment
comment|/*  * confentries is a pointer to the list of configuration entries  * we have left to do.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|conf_entry
modifier|*
name|confentries
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We take an interrupt every thirty seconds, at which time we decrement  * config_timer and resolve_timer.  The former is set to 2, so we retry  * unsucessful reconfigurations every minute.  The latter is set to  * an exponentially increasing value which starts at 2 and increases to  * 32.  When this expires we retry failed name resolutions.  *  * We sleep SLEEPTIME seconds before doing anything, to give the server  * time to arrange itself.  */
end_comment

begin_define
define|#
directive|define
name|MINRESOLVE
value|2
end_define

begin_define
define|#
directive|define
name|MAXRESOLVE
value|32
end_define

begin_define
define|#
directive|define
name|CONFIG_TIME
value|2
end_define

begin_define
define|#
directive|define
name|ALARM_TIME
value|30
end_define

begin_define
define|#
directive|define
name|SLEEPTIME
value|2
end_define

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|config_timer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|resolve_timer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|resolve_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next value of resolve timer */
end_comment

begin_comment
comment|/*  * Big hack attack  */
end_comment

begin_define
define|#
directive|define
name|LOCALHOST
value|0x7f000001
end_define

begin_comment
comment|/* 127.0.0.1, in hex, of course */
end_comment

begin_define
define|#
directive|define
name|SKEWTIME
value|0x08000000
end_define

begin_comment
comment|/* 0.03125 seconds as a l_fp fraction */
end_comment

begin_comment
comment|/*  * Select time out.  Set to 2 seconds.  The server is on the local machine,  * after all.  */
end_comment

begin_define
define|#
directive|define
name|TIMEOUT_SEC
value|2
end_define

begin_define
define|#
directive|define
name|TIMEOUT_USEC
value|0
end_define

begin_comment
comment|/*  * Input processing.  The data on each line in the configuration file  * is supposed to consist of entries in the following order  */
end_comment

begin_define
define|#
directive|define
name|TOK_HOSTNAME
value|0
end_define

begin_define
define|#
directive|define
name|TOK_HMODE
value|1
end_define

begin_define
define|#
directive|define
name|TOK_VERSION
value|2
end_define

begin_define
define|#
directive|define
name|TOK_MINPOLL
value|3
end_define

begin_define
define|#
directive|define
name|TOK_MAXPOLL
value|4
end_define

begin_define
define|#
directive|define
name|TOK_FLAGS
value|5
end_define

begin_define
define|#
directive|define
name|TOK_TTL
value|6
end_define

begin_define
define|#
directive|define
name|TOK_KEYID
value|7
end_define

begin_define
define|#
directive|define
name|TOK_KEYSTR
value|8
end_define

begin_define
define|#
directive|define
name|NUMTOK
value|9
end_define

begin_define
define|#
directive|define
name|MAXLINESIZE
value|512
end_define

begin_comment
comment|/*  * File descriptor for ntp request code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stuff to be filled in by caller */
end_comment

begin_decl_stmt
name|keyid_t
name|req_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request keyid */
end_comment

begin_decl_stmt
name|char
modifier|*
name|req_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the file with configuration info */
end_comment

begin_comment
comment|/* end stuff to be filled in */
end_comment

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|bong
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|checkparent
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|removeentry
name|P
argument_list|(
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addentry
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|u_int
operator|,
name|int
operator|,
name|keyid_t
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findhostaddr
name|P
argument_list|(
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|openntp
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|request
name|P
argument_list|(
operator|(
expr|struct
name|conf_peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nexttoken
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|readconf
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doconfigure
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ntp_res_t_pkt
block|{
comment|/* Tagged packet: */
name|void
modifier|*
name|tag
decl_stmt|;
comment|/* For the caller */
name|u_int32
name|paddr
decl_stmt|;
comment|/* IP to look up, or 0 */
name|char
name|name
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
comment|/* Name to look up (if 1st byte is not 0) */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntp_res_c_pkt
block|{
comment|/* Control packet: */
name|char
name|name
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|u_int32
name|paddr
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|version
decl_stmt|;
name|int
name|minpoll
decl_stmt|;
name|int
name|maxpoll
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|int
name|ttl
decl_stmt|;
name|keyid_t
name|keyid
decl_stmt|;
name|u_char
name|keystr
index|[
name|MAXFILENAME
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * ntp_res_recv: Process an answer from the resolver  */
end_comment

begin_function
name|void
name|ntp_res_recv
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	  We have data ready on our descriptor. 	  It may be an EOF, meaning the resolver process went away. 	  Otherwise, it will be an "answer". 	*/
block|}
end_function

begin_comment
comment|/*  * ntp_intres needs;  *  *	req_key(???), req_keyid, req_file valid  *	syslog still open  */
end_comment

begin_function
name|void
name|ntp_intres
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|in
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGSUSPEND
name|sigset_t
name|set
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGSUSPEND */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NTP_INTRES running"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* check out auth stuff */
if|if
condition|(
name|sys_authenticate
condition|)
block|{
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|req_keyid
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid request keyid %08x"
argument_list|,
name|req_keyid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Read the configuration info 	 * {this is bogus, since we are forked, but it is easier 	 * to keep this code - gdt} 	 */
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|req_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't open configuration file %s: %m"
argument_list|,
name|req_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|readconf
argument_list|(
name|in
argument_list|,
name|req_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|req_file
argument_list|)
expr_stmt|;
comment|/* 	 * Sleep a little to make sure the server is completely up 	 */
name|sleep
argument_list|(
name|SLEEPTIME
argument_list|)
expr_stmt|;
comment|/* 	 * Make a first cut at resolving the bunch 	 */
name|doconfigure
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|confentries
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
name|SYS_WINNT
name|ExitThread
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't want to kill whole NT process */
else|#
directive|else
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* done that quick */
endif|#
directive|endif
block|}
comment|/* 	 * Here we've got some problem children.  Set up the timer 	 * and wait for it. 	 */
name|resolve_value
operator|=
name|resolve_timer
operator|=
name|MINRESOLVE
expr_stmt|;
name|config_timer
operator|=
name|CONFIG_TIME
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGALRM
argument_list|,
name|bong
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|ALARM_TIME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|confentries
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|checkparent
argument_list|()
expr_stmt|;
if|if
condition|(
name|resolve_timer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|resolve_value
operator|<
name|MAXRESOLVE
condition|)
name|resolve_value
operator|<<=
literal|1
expr_stmt|;
name|resolve_timer
operator|=
name|resolve_value
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"resolve_timer: 0->%d"
argument_list|,
name|resolve_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|config_timer
operator|=
name|CONFIG_TIME
expr_stmt|;
name|doconfigure
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|config_timer
operator|==
literal|0
condition|)
block|{
name|config_timer
operator|=
name|CONFIG_TIME
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"config_timer: 0->%d"
argument_list|,
name|config_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|doconfigure
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* 		 * There is a race in here.  Is okay, though, since 		 * all it does is delay things by 30 seconds. 		 */
ifdef|#
directive|ifdef
name|HAVE_SIGSUSPEND
name|sigsuspend
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
else|#
directive|else
name|sigpause
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGSUSPEND */
else|#
directive|else
if|if
condition|(
name|config_timer
operator|>
literal|0
condition|)
name|config_timer
operator|--
expr_stmt|;
if|if
condition|(
name|resolve_timer
operator|>
literal|0
condition|)
name|resolve_timer
operator|--
expr_stmt|;
name|sleep
argument_list|(
name|ALARM_TIME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_comment
comment|/*  * bong - service and reschedule an alarm() interrupt  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|bong
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|config_timer
operator|>
literal|0
condition|)
name|config_timer
operator|--
expr_stmt|;
if|if
condition|(
name|resolve_timer
operator|>
literal|0
condition|)
name|resolve_timer
operator|--
expr_stmt|;
name|alarm
argument_list|(
name|ALARM_TIME
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * checkparent - see if our parent process is still running  *  * No need to worry in the Windows NT environment whether the  * main thread is still running, because if it goes  * down it takes the whole process down with it (in  * which case we won't be running this thread either)  * Turn function into NOP;  */
end_comment

begin_function
specifier|static
name|void
name|checkparent
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
comment|/* 	 * If our parent (the server) has died we will have been 	 * inherited by init.  If so, exit. 	 */
if|if
condition|(
name|getppid
argument_list|()
operator|==
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"parent died before we finished, exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT&& SYS_VXWORKS*/
block|}
end_function

begin_comment
comment|/*  * removeentry - we are done with an entry, remove it from the list  */
end_comment

begin_function
specifier|static
name|void
name|removeentry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|register
name|struct
name|conf_entry
modifier|*
name|ce
decl_stmt|;
name|ce
operator|=
name|confentries
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|entry
condition|)
block|{
name|confentries
operator|=
name|ce
operator|->
name|ce_next
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|ce
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ce
operator|->
name|ce_next
operator|==
name|entry
condition|)
block|{
name|ce
operator|->
name|ce_next
operator|=
name|entry
operator|->
name|ce_next
expr_stmt|;
return|return;
block|}
name|ce
operator|=
name|ce
operator|->
name|ce_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * addentry - add an entry to the configuration list  */
end_comment

begin_function
specifier|static
name|void
name|addentry
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|minpoll
parameter_list|,
name|int
name|maxpoll
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int
name|ttl
parameter_list|,
name|keyid_t
name|keyid
parameter_list|,
name|char
modifier|*
name|keystr
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|conf_entry
modifier|*
name|ce
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"intres:<%s> %d %d %d %d %x %d %x %s\n"
argument_list|,
name|name
argument_list|,
name|mode
argument_list|,
name|version
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|flags
argument_list|,
name|ttl
argument_list|,
name|keyid
argument_list|,
name|keystr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ce
operator|=
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_entry
argument_list|)
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_name
operator|=
name|cp
expr_stmt|;
name|ce
operator|->
name|ce_peeraddr
operator|=
literal|0
expr_stmt|;
name|ce
operator|->
name|ce_hmode
operator|=
operator|(
name|u_char
operator|)
name|mode
expr_stmt|;
name|ce
operator|->
name|ce_version
operator|=
operator|(
name|u_char
operator|)
name|version
expr_stmt|;
name|ce
operator|->
name|ce_minpoll
operator|=
operator|(
name|u_char
operator|)
name|minpoll
expr_stmt|;
name|ce
operator|->
name|ce_maxpoll
operator|=
operator|(
name|u_char
operator|)
name|maxpoll
expr_stmt|;
name|ce
operator|->
name|ce_flags
operator|=
operator|(
name|u_char
operator|)
name|flags
expr_stmt|;
name|ce
operator|->
name|ce_ttl
operator|=
operator|(
name|u_char
operator|)
name|ttl
expr_stmt|;
name|ce
operator|->
name|ce_keyid
operator|=
name|keyid
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ce
operator|->
name|ce_keystr
argument_list|,
name|keystr
argument_list|,
name|MAXFILENAME
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|confentries
operator|==
name|NULL
condition|)
block|{
name|confentries
operator|=
name|ce
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|conf_entry
modifier|*
name|cep
decl_stmt|;
for|for
control|(
name|cep
operator|=
name|confentries
init|;
name|cep
operator|->
name|ce_next
operator|!=
name|NULL
condition|;
name|cep
operator|=
name|cep
operator|->
name|ce_next
control|)
comment|/* nothing */
empty_stmt|;
name|cep
operator|->
name|ce_next
operator|=
name|ce
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * findhostaddr - resolve a host name into an address (Or vice-versa)  *  * Given one of {ce_peeraddr,ce_name}, find the other one.  * It returns 1 for "success" and 0 for an uncorrectable failure.  * Note that "success" includes try again errors.  You can tell that you  *  got a "try again" since {ce_peeraddr,ce_name} will still be zero.  */
end_comment

begin_function
specifier|static
name|int
name|findhostaddr
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|in_addr
name|in
decl_stmt|;
name|checkparent
argument_list|()
expr_stmt|;
comment|/* make sure our guy is still running */
if|if
condition|(
name|entry
operator|->
name|ce_name
operator|&&
name|entry
operator|->
name|ce_peeraddr
condition|)
block|{
comment|/* HMS: Squawk? */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"findhostaddr: both ce_name and ce_peeraddr are defined..."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|entry
operator|->
name|ce_name
operator|&&
operator|!
name|entry
operator|->
name|ce_peeraddr
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"findhostaddr: both ce_name and ce_peeraddr are undefined!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|ce_name
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"findhostaddr: Resolving<%s>"
argument_list|,
name|entry
operator|->
name|ce_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|entry
operator|->
name|ce_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"findhostaddr: Resolving %x>"
argument_list|,
name|entry
operator|->
name|ce_peeraddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|in
operator|.
name|s_addr
operator|=
name|entry
operator|->
name|ce_peeraddr
expr_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|in
argument_list|,
sizeof|sizeof
name|entry
operator|->
name|ce_peeraddr
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If the resolver is in use, see if the failure is 		 * temporary.  If so, return success. 		 */
if|if
condition|(
name|h_errno
operator|==
name|TRY_AGAIN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|ce_name
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"findhostaddr: name resolved."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Use the first address.  We don't have any way to tell 		 * preferences and older gethostbyname() implementations 		 * only return one. 		 */
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|entry
operator|->
name|ce_peeraddr
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ce_keystr
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|entry
operator|->
name|ce_keystr
operator|)
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
name|MAXFILENAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"findhostaddr: address resolved."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|emalloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|entry
operator|->
name|ce_name
operator|=
name|cp
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * openntp - open a socket to the ntp server  */
end_comment

begin_function
specifier|static
name|void
name|openntp
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|saddr
decl_stmt|;
if|if
condition|(
name|sockfd
operator|>=
literal|0
condition|)
return|return;
name|sockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|saddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
name|saddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|saddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
comment|/* trash */
name|saddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|LOCALHOST
argument_list|)
expr_stmt|;
comment|/* garbage */
comment|/* 	 * Make the socket non-blocking.  We'll wait with select() 	 */
ifndef|#
directive|ifndef
name|SYS_WINNT
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|sockfd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NONBLOCK) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|sockfd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
include|#
directive|include
file|"Bletch: NEED NON BLOCKING IO"
endif|#
directive|endif
comment|/* FNDDELAY */
endif|#
directive|endif
comment|/* O_NONBLOCK */
else|#
directive|else
comment|/* SYS_WINNT */
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ioctlsocket
argument_list|(
name|sockfd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
name|SOCKET_ERROR
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctlsocket(FIONBIO) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Windows NT - set socket in non-blocking mode */
block|}
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"openntp: connect() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * request - send a configuration request to the server, wait for a response  */
end_comment

begin_function
specifier|static
name|int
name|request
parameter_list|(
name|struct
name|conf_peer
modifier|*
name|conf
parameter_list|)
block|{
name|fd_set
name|fdset
decl_stmt|;
name|struct
name|timeval
name|tvout
decl_stmt|;
name|struct
name|req_pkt
name|reqpkt
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|HANDLE
name|hReadWriteEvent
init|=
name|NULL
decl_stmt|;
name|BOOL
name|ret
decl_stmt|;
name|DWORD
name|NumberOfBytesWritten
decl_stmt|,
name|NumberOfBytesRead
decl_stmt|,
name|dwWait
decl_stmt|;
name|OVERLAPPED
name|overlap
decl_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
name|checkparent
argument_list|()
expr_stmt|;
comment|/* make sure our guy is still running */
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|openntp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|hReadWriteEvent
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Try to clear out any previously received traffic so it 	 * doesn't fool us.  Note the socket is nonblocking. 	 */
name|tvout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
while|while
condition|(
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fdset
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvout
argument_list|)
operator|>
literal|0
condition|)
block|{
name|recv
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_MAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make up a request packet with the configuration info 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reqpkt
argument_list|)
argument_list|)
expr_stmt|;
name|reqpkt
operator|.
name|rm_vn_mode
operator|=
name|RM_VN_MODE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reqpkt
operator|.
name|auth_seq
operator|=
name|AUTH_SEQ
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* authenticated, no seq */
name|reqpkt
operator|.
name|implementation
operator|=
name|IMPL_XNTPD
expr_stmt|;
comment|/* local implementation */
name|reqpkt
operator|.
name|request
operator|=
name|REQ_CONFIG
expr_stmt|;
comment|/* configure a new peer */
name|reqpkt
operator|.
name|err_nitems
operator|=
name|ERR_NITEMS
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* one item */
name|reqpkt
operator|.
name|mbz_itemsize
operator|=
name|MBZ_ITEMSIZE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_peer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure mbz_itemsize<= sizeof reqpkt.data */
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_peer
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|reqpkt
operator|.
name|data
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Bletch: conf_peer is too big for reqpkt.data!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
name|reqpkt
operator|.
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|conf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_peer
argument_list|)
argument_list|)
expr_stmt|;
name|reqpkt
operator|.
name|keyid
operator|=
name|htonl
argument_list|(
name|req_keyid
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|ts
argument_list|,
name|SKEWTIME
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|reqpkt
operator|.
name|tstamp
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sys_authenticate
condition|)
name|n
operator|=
name|authencrypt
argument_list|(
name|req_keyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_NOMAC
argument_list|)
expr_stmt|;
comment|/* 	 * Done.  Send it. 	 */
ifndef|#
directive|ifndef
name|SYS_WINNT
name|n
operator|=
name|send
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|REQ_LEN_NOMAC
operator|+
name|n
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"send to NTP server failed: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* maybe should exit */
block|}
else|#
directive|else
comment|/* In the NT world, documentation seems to indicate that there 	 * exist _write and _read routines that can be used to do blocking 	 * I/O on sockets. Problem is these routines require a socket 	 * handle obtained through the _open_osf_handle C run-time API 	 * of which there is no explanation in the documentation. We need 	 * nonblocking write's and read's anyway for our purpose here. 	 * We're therefore forced to deviate a little bit from the Unix 	 * model here and use the ReadFile and WriteFile Win32 I/O API's 	 * on the socket 	 */
name|overlap
operator|.
name|Offset
operator|=
name|overlap
operator|.
name|OffsetHigh
operator|=
operator|(
name|DWORD
operator|)
literal|0
expr_stmt|;
name|overlap
operator|.
name|hEvent
operator|=
name|hReadWriteEvent
expr_stmt|;
name|ret
operator|=
name|WriteFile
argument_list|(
operator|(
name|HANDLE
operator|)
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_NOMAC
operator|+
name|n
argument_list|,
operator|(
name|LPDWORD
operator|)
operator|&
name|NumberOfBytesWritten
argument_list|,
operator|(
name|LPOVERLAPPED
operator|)
operator|&
name|overlap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_IO_PENDING
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"send to NTP server failed: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dwWait
operator|=
name|WaitForSingleObject
argument_list|(
name|hReadWriteEvent
argument_list|,
operator|(
name|DWORD
operator|)
name|TIMEOUT_SEC
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dwWait
operator|==
name|WAIT_FAILED
operator|)
operator|||
operator|(
name|dwWait
operator|==
name|WAIT_TIMEOUT
operator|)
condition|)
block|{
if|if
condition|(
name|dwWait
operator|==
name|WAIT_FAILED
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForSingleObject failed: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Wait for a response.  A weakness of the mode 7 protocol used 	 * is that there is no way to associate a response with a 	 * particular request, i.e. the response to this configuration 	 * request is indistinguishable from that to any other.  I should 	 * fix this some day.  In any event, the time out is fairly 	 * pessimistic to make sure that if an answer is coming back 	 * at all, we get it. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|tvout
operator|.
name|tv_sec
operator|=
name|TIMEOUT_SEC
expr_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
name|TIMEOUT_USEC
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fdset
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvout
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select() fails: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"select() returned 0."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|SYS_WINNT
name|n
operator|=
name|recv
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_MAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"recv() fails: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
continue|continue;
block|}
else|#
directive|else
comment|/* Overlapped I/O used on non-blocking sockets on Windows NT */
name|ret
operator|=
name|ReadFile
argument_list|(
operator|(
name|HANDLE
operator|)
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
operator|(
name|DWORD
operator|)
name|REQ_LEN_MAC
argument_list|,
operator|(
name|LPDWORD
operator|)
operator|&
name|NumberOfBytesRead
argument_list|,
operator|(
name|LPOVERLAPPED
operator|)
operator|&
name|overlap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_IO_PENDING
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ReadFile() fails: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dwWait
operator|=
name|WaitForSingleObject
argument_list|(
name|hReadWriteEvent
argument_list|,
operator|(
name|DWORD
operator|)
name|TIMEOUT_SEC
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dwWait
operator|==
name|WAIT_FAILED
operator|)
operator|||
operator|(
name|dwWait
operator|==
name|WAIT_TIMEOUT
operator|)
condition|)
block|{
if|if
condition|(
name|dwWait
operator|==
name|WAIT_FAILED
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForSingleObject fails: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
continue|continue;
block|}
name|n
operator|=
name|NumberOfBytesRead
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 		 * Got one.  Check through to make sure it is what 		 * we expect. 		 */
if|if
condition|(
name|n
operator|<
name|RESP_HEADER_SIZE
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"received runt response (%d octets)"
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ISRESPONSE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"received non-response packet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|ISMORE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"received fragmented packet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|INFO_VERSION
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|<
literal|2
operator|)
operator|||
operator|(
name|INFO_VERSION
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
operator|)
operator|)
operator|||
name|INFO_MODE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|!=
name|MODE_PRIVATE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"version (%d/%d) or mode (%d/%d) incorrect"
argument_list|,
name|INFO_VERSION
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
argument_list|,
name|NTP_VERSION
argument_list|,
name|INFO_MODE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
argument_list|,
name|MODE_PRIVATE
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|INFO_SEQ
argument_list|(
name|reqpkt
operator|.
name|auth_seq
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nonzero sequence number (%d)"
argument_list|,
name|INFO_SEQ
argument_list|(
name|reqpkt
operator|.
name|auth_seq
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|reqpkt
operator|.
name|implementation
operator|!=
name|IMPL_XNTPD
operator|||
name|reqpkt
operator|.
name|request
operator|!=
name|REQ_CONFIG
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"implementation (%d) or request (%d) incorrect"
argument_list|,
name|reqpkt
operator|.
name|implementation
argument_list|,
name|reqpkt
operator|.
name|request
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|reqpkt
operator|.
name|err_nitems
argument_list|)
operator|!=
literal|0
operator|||
name|INFO_MBZ
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
operator|!=
literal|0
operator|||
name|INFO_ITEMSIZE
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nitems (%d) mbz (%d) or itemsize (%d) nonzero"
argument_list|,
name|INFO_NITEMS
argument_list|(
name|reqpkt
operator|.
name|err_nitems
argument_list|)
argument_list|,
name|INFO_MBZ
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
argument_list|,
name|INFO_ITEMSIZE
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|n
operator|=
name|INFO_ERR
argument_list|(
name|reqpkt
operator|.
name|err_nitems
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|INFO_OKAY
case|:
comment|/* success */
return|return
literal|1
return|;
case|case
name|INFO_ERR_IMPL
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server reports implementation mismatch!!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_REQ
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server claims configuration request is unknown"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_FMT
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server indicates a format error occurred(!!)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_NODATA
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server indicates no data available (shouldn't happen)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_AUTH
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server returns a permission denied error"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server returns unknown error code %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * nexttoken - return the next token from a line  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|nexttoken
parameter_list|(
name|char
modifier|*
modifier|*
name|lptr
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|tstart
decl_stmt|;
name|cp
operator|=
operator|*
name|lptr
expr_stmt|;
comment|/* 	 * Skip leading white space 	 */
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* 	 * If this is the end of the line, return nothing. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|lptr
operator|=
name|cp
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Must be the start of a token.  Record the pointer and look 	 * for the end. 	 */
name|tstart
operator|=
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* 	 * Terminate the token with a \0.  If this isn't the end of the 	 * line, space to the next character. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|'\0'
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|lptr
operator|=
name|cp
expr_stmt|;
return|return
name|tstart
return|;
block|}
end_function

begin_comment
comment|/*  * readconf - read the configuration information out of the file we  *	      were passed.  Note that since the file is supposed to be  *	      machine generated, we bail out at the first sign of trouble.  */
end_comment

begin_function
specifier|static
name|void
name|readconf
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|token
index|[
name|NUMTOK
index|]
decl_stmt|;
name|u_long
name|intval
index|[
name|NUMTOK
index|]
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|MAXLINESIZE
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMTOK
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|token
index|[
name|i
index|]
operator|=
name|nexttoken
argument_list|(
operator|&
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tokenizing error in file `%s', quitting"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUMTOK
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|token
index|[
name|i
index|]
argument_list|,
operator|&
name|intval
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"format error for integer token `%s', file `%s', quitting"
argument_list|,
name|token
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|intval
index|[
name|TOK_HMODE
index|]
operator|!=
name|MODE_ACTIVE
operator|&&
name|intval
index|[
name|TOK_HMODE
index|]
operator|!=
name|MODE_CLIENT
operator|&&
name|intval
index|[
name|TOK_HMODE
index|]
operator|!=
name|MODE_BROADCAST
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid mode (%ld) in file %s"
argument_list|,
name|intval
index|[
name|TOK_HMODE
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intval
index|[
name|TOK_VERSION
index|]
operator|>
name|NTP_VERSION
operator|||
name|intval
index|[
name|TOK_VERSION
index|]
operator|<
name|NTP_OLDVERSION
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid version (%ld) in file %s"
argument_list|,
name|intval
index|[
name|TOK_VERSION
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intval
index|[
name|TOK_MINPOLL
index|]
operator|<
name|NTP_MINPOLL
operator|||
name|intval
index|[
name|TOK_MINPOLL
index|]
operator|>
name|NTP_MAXPOLL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid MINPOLL value (%ld) in file %s"
argument_list|,
name|intval
index|[
name|TOK_MINPOLL
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intval
index|[
name|TOK_MAXPOLL
index|]
operator|<
name|NTP_MINPOLL
operator|||
name|intval
index|[
name|TOK_MAXPOLL
index|]
operator|>
name|NTP_MAXPOLL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid MAXPOLL value (%ld) in file %s"
argument_list|,
name|intval
index|[
name|TOK_MAXPOLL
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intval
index|[
name|TOK_FLAGS
index|]
operator|&
operator|~
operator|(
name|FLAG_AUTHENABLE
operator||
name|FLAG_PREFER
operator||
name|FLAG_NOSELECT
operator||
name|FLAG_BURST
operator||
name|FLAG_IBURST
operator||
name|FLAG_SKEY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid flags (%ld) in file %s"
argument_list|,
name|intval
index|[
name|TOK_FLAGS
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|intval
index|[
name|TOK_FLAGS
index|]
operator|&
name|FLAG_AUTHENABLE
condition|)
name|flags
operator||=
name|CONF_FLAG_AUTHENABLE
expr_stmt|;
if|if
condition|(
name|intval
index|[
name|TOK_FLAGS
index|]
operator|&
name|FLAG_PREFER
condition|)
name|flags
operator||=
name|CONF_FLAG_PREFER
expr_stmt|;
if|if
condition|(
name|intval
index|[
name|TOK_FLAGS
index|]
operator|&
name|FLAG_NOSELECT
condition|)
name|flags
operator||=
name|CONF_FLAG_NOSELECT
expr_stmt|;
if|if
condition|(
name|intval
index|[
name|TOK_FLAGS
index|]
operator|&
name|FLAG_BURST
condition|)
name|flags
operator||=
name|CONF_FLAG_BURST
expr_stmt|;
if|if
condition|(
name|intval
index|[
name|TOK_FLAGS
index|]
operator|&
name|FLAG_IBURST
condition|)
name|flags
operator||=
name|CONF_FLAG_IBURST
expr_stmt|;
if|if
condition|(
name|intval
index|[
name|TOK_FLAGS
index|]
operator|&
name|FLAG_SKEY
condition|)
name|flags
operator||=
name|CONF_FLAG_SKEY
expr_stmt|;
comment|/* 		 * This is as good as we can check it.  Add it in. 		 */
name|addentry
argument_list|(
name|token
index|[
name|TOK_HOSTNAME
index|]
argument_list|,
operator|(
name|int
operator|)
name|intval
index|[
name|TOK_HMODE
index|]
argument_list|,
operator|(
name|int
operator|)
name|intval
index|[
name|TOK_VERSION
index|]
argument_list|,
operator|(
name|int
operator|)
name|intval
index|[
name|TOK_MINPOLL
index|]
argument_list|,
operator|(
name|int
operator|)
name|intval
index|[
name|TOK_MAXPOLL
index|]
argument_list|,
name|flags
argument_list|,
operator|(
name|int
operator|)
name|intval
index|[
name|TOK_TTL
index|]
argument_list|,
name|intval
index|[
name|TOK_KEYID
index|]
argument_list|,
name|token
index|[
name|TOK_KEYSTR
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * doconfigure - attempt to resolve names and configure the server  */
end_comment

begin_function
specifier|static
name|void
name|doconfigure
parameter_list|(
name|int
name|dores
parameter_list|)
block|{
specifier|register
name|struct
name|conf_entry
modifier|*
name|ce
decl_stmt|;
specifier|register
name|struct
name|conf_entry
modifier|*
name|ceremove
decl_stmt|;
name|ce
operator|=
name|confentries
expr_stmt|;
while|while
condition|(
name|ce
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"doconfigure:<%s> has peeraddr %#x"
argument_list|,
name|ce
operator|->
name|ce_name
argument_list|,
name|ce
operator|->
name|ce_peeraddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dores
operator|&&
name|ce
operator|->
name|ce_peeraddr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|findhostaddr
argument_list|(
name|ce
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't resolve `%s', giving up on it"
argument_list|,
name|ce
operator|->
name|ce_name
argument_list|)
expr_stmt|;
name|ceremove
operator|=
name|ce
expr_stmt|;
name|ce
operator|=
name|ceremove
operator|->
name|ce_next
expr_stmt|;
name|removeentry
argument_list|(
name|ceremove
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|ce
operator|->
name|ce_peeraddr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|request
argument_list|(
operator|&
name|ce
operator|->
name|ce_config
argument_list|)
condition|)
block|{
name|ceremove
operator|=
name|ce
expr_stmt|;
name|ce
operator|=
name|ceremove
operator|->
name|ce_next
expr_stmt|;
name|removeentry
argument_list|(
name|ceremove
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"doconfigure: request() FAILED, maybe next time."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|ce
operator|=
name|ce
operator|->
name|ce_next
expr_stmt|;
block|}
block|}
end_function

end_unit

