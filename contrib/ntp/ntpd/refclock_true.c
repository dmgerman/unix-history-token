begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_true - clock driver for the Kinemetrics Truetime receivers  *	Receiver Version 3.0C - tested plain, with CLKLDISC  *	Developement work being done:  * 	- Properly handle varying satellite positions (more acurately)  *	- Integrate GPSTM and/or OMEGA and/or TRAK and/or ??? drivers  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_TRUETIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/* This should be an atom clock but those are very hard to build.  *  * The PCL720 from P C Labs has an Intel 8253 lookalike, as well as a bunch  * of TTL input and output pins, all brought out to the back panel.  If you  * wire a PPS signal (such as the TTL PPS coming out of a GOES or other  * Kinemetrics/Truetime clock) to the 8253's GATE0, and then also wire the  * 8253's OUT0 to the PCL720's INPUT3.BIT0, then we can read CTR0 to get the  * number of uSecs since the last PPS upward swing, mediated by reading OUT0  * to find out if the counter has wrapped around (this happens if more than  * 65535us (65ms) elapses between the PPS event and our being called.)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CLOCK_PPS720
end_ifdef

begin_undef
undef|#
directive|undef
name|min
end_undef

begin_comment
comment|/* XXX */
end_comment

begin_undef
undef|#
directive|undef
name|max
end_undef

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<machine/inline.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcl720.h>
end_include

begin_include
include|#
directive|include
file|<sys/i8253.h>
end_include

begin_define
define|#
directive|define
name|PCL720_IOB
value|0x2a0
end_define

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|PCL720_CTR
value|0
end_define

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Support for Kinemetrics Truetime Receivers  *	GOES  *	GPS/TM-TMD  *	XL-DC		(a 151-602-210, reported by the driver as a GPS/TM-TMD)  *	GPS-800 TCU	(an 805-957 with the RS232 Talker/Listener module)  *	OM-DC:		getting stale ("OMEGA")  *  * Most of this code is originally from refclock_wwvb.c with thanks.  * It has been so mangled that wwvb is not a recognizable ancestor.  *  * Timcode format: ADDD:HH:MM:SSQCL  *	A - control A		(this is stripped before we see it)  *	Q - Quality indication	(see below)  *	C - Carriage return  *	L - Line feed  *  * Quality codes indicate possible error of  *   468-DC GOES Receiver:  *   GPS-TM/TMD Receiver:  *       ?     +/- 500 milliseconds	#     +/- 50 milliseconds  *       *     +/- 5 milliseconds	.     +/- 1 millisecond  *     space   less than 1 millisecond  *   OM-DC OMEGA Receiver:  *>>+- 5 seconds  *       ?>+/- 500 milliseconds    #>+/- 50 milliseconds  *       *>+/- 5 milliseconds      .>+/- 1 millisecond  *      A-H    less than 1 millisecond.  Character indicates which station  *             is being received as follows:  *             A = Norway, B = Liberia, C = Hawaii, D = North Dakota,  *             E = La Reunion, F = Argentina, G = Australia, H = Japan.  *  * The carriage return start bit begins on 0 seconds and extends to 1 bit time.  *  * Notes on 468-DC and OMEGA receiver:  *  * Send the clock a 'R' or 'C' and once per second a timestamp will  * appear.  Send a 'P' to get the satellite position once (GOES only.)  *  * Notes on the 468-DC receiver:  *  * Since the old east/west satellite locations are only historical, you can't  * set your clock propagation delay settings correctly and still use  * automatic mode. The manual says to use a compromise when setting the  * switches. This results in significant errors. The solution; use fudge  * time1 and time2 to incorporate corrections. If your clock is set for  * 50 and it should be 58 for using the west and 46 for using the east,  * use the line  *  * fudge 127.127.5.0 time1 +0.008 time2 -0.004  *  * This corrects the 4 milliseconds advance and 8 milliseconds retard  * needed. The software will ask the clock which satellite it sees.  *  * Ntp.conf parameters:  * time1 - offset applied to samples when reading WEST satellite (default = 0)  * time2 - offset applied to samples when reading EAST satellite (default = 0)  * val1  - stratum to assign to this clock (default = 0)  * val2  - refid assigned to this clock (default = "TRUE", see below)  * flag1 - will silence the clock side of ntpd, just reading the clock  *         without trying to write to it.  (default = 0)  * flag2 - generate a debug file /tmp/true%d.  * flag3 - enable ppsclock streams module  * flag4 - use the PCL-720 (BSD/OS only)  */
end_comment

begin_comment
comment|/*  * Definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/true%d"
end_define

begin_define
define|#
directive|define
name|SPEED232
value|B9600
end_define

begin_comment
comment|/* 9600 baud */
end_comment

begin_comment
comment|/*  * Radio interface parameters  */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"TRUE"
end_define

begin_comment
comment|/* reference id */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"Kinemetrics/TrueTime Receiver"
end_define

begin_comment
comment|/*  * Tags which station (satellite) we see  */
end_comment

begin_define
define|#
directive|define
name|GOES_WEST
value|0
end_define

begin_comment
comment|/* Default to WEST satellite and apply time1 */
end_comment

begin_define
define|#
directive|define
name|GOES_EAST
value|1
end_define

begin_comment
comment|/* until you discover otherwise */
end_comment

begin_comment
comment|/*  * used by the state machine  */
end_comment

begin_enum
enum|enum
name|true_event
block|{
name|e_Init
block|,
name|e_Huh
block|,
name|e_F18
block|,
name|e_F50
block|,
name|e_F51
block|,
name|e_Satellite
block|,
name|e_Poll
block|,
name|e_Location
block|,
name|e_TS
block|,
name|e_Max
block|}
enum|;
end_enum

begin_decl_stmt
specifier|const
name|char
modifier|*
name|events
index|[]
init|=
block|{
literal|"Init"
block|,
literal|"Huh"
block|,
literal|"F18"
block|,
literal|"F50"
block|,
literal|"F51"
block|,
literal|"Satellite"
block|,
literal|"Poll"
block|,
literal|"Location"
block|,
literal|"TS"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|eventStr
parameter_list|(
name|x
parameter_list|)
value|(((int)x<(int)e_Max) ? events[(int)x] : "?")
end_define

begin_enum
enum|enum
name|true_state
block|{
name|s_Base
block|,
name|s_InqTM
block|,
name|s_InqTCU
block|,
name|s_InqOmega
block|,
name|s_InqGOES
block|,
name|s_Init
block|,
name|s_F18
block|,
name|s_F50
block|,
name|s_Start
block|,
name|s_Auto
block|,
name|s_Max
block|}
enum|;
end_enum

begin_decl_stmt
specifier|const
name|char
modifier|*
name|states
index|[]
init|=
block|{
literal|"Base"
block|,
literal|"InqTM"
block|,
literal|"InqTCU"
block|,
literal|"InqOmega"
block|,
literal|"InqGOES"
block|,
literal|"Init"
block|,
literal|"F18"
block|,
literal|"F50"
block|,
literal|"Start"
block|,
literal|"Auto"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|stateStr
parameter_list|(
name|x
parameter_list|)
value|(((int)x<(int)s_Max) ? states[(int)x] : "?")
end_define

begin_enum
enum|enum
name|true_type
block|{
name|t_unknown
block|,
name|t_goes
block|,
name|t_tm
block|,
name|t_tcu
block|,
name|t_omega
block|,
name|t_Max
block|}
enum|;
end_enum

begin_decl_stmt
specifier|const
name|char
modifier|*
name|types
index|[]
init|=
block|{
literal|"unknown"
block|,
literal|"goes"
block|,
literal|"tm"
block|,
literal|"tcu"
block|,
literal|"omega"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|typeStr
parameter_list|(
name|x
parameter_list|)
value|(((int)x<(int)t_Max) ? types[(int)x] : "?")
end_define

begin_comment
comment|/*  * unit control structure  */
end_comment

begin_struct
struct|struct
name|true_unit
block|{
name|unsigned
name|int
name|pollcnt
decl_stmt|;
comment|/* poll message counter */
name|unsigned
name|int
name|station
decl_stmt|;
comment|/* which station we are on */
name|unsigned
name|int
name|polled
decl_stmt|;
comment|/* Hand in a time sample? */
name|enum
name|true_state
name|state
decl_stmt|;
comment|/* state machine */
name|enum
name|true_type
name|type
decl_stmt|;
comment|/* what kind of clock is it? */
name|int
name|unit
decl_stmt|;
comment|/* save an extra copy of this */
name|FILE
modifier|*
name|debug
decl_stmt|;
comment|/* debug logging file */
ifdef|#
directive|ifdef
name|CLOCK_PPS720
name|int
name|pcl720init
decl_stmt|;
comment|/* init flag for PCL 720 */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|true_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|true_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|true_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|true_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|true_send
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|true_doevent
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
expr|enum
name|true_event
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CLOCK_PPS720
end_ifdef

begin_decl_stmt
specifier|static
name|u_long
name|true_sample720
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_true
init|=
block|{
name|true_start
block|,
comment|/* start up driver */
name|true_shutdown
block|,
comment|/* shut down driver */
name|true_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old true_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old true_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|true_debug
value|(void)
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|true_debug
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|want_debugging
decl_stmt|,
name|now_debugging
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|true_unit
modifier|*
name|up
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|true_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|want_debugging
operator|=
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
operator|)
operator|!=
literal|0
expr_stmt|;
name|now_debugging
operator|=
operator|(
name|up
operator|->
name|debug
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|want_debugging
operator|!=
name|now_debugging
condition|)
block|{
if|if
condition|(
name|want_debugging
condition|)
block|{
name|char
name|filename
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"/tmp/true%d.debug"
argument_list|,
name|up
operator|->
name|unit
argument_list|)
expr_stmt|;
name|up
operator|->
name|debug
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|debug
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SETVBUF
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|setvbuf
argument_list|(
name|up
operator|->
name|debug
argument_list|,
name|buf
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|up
operator|->
name|debug
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|fclose
argument_list|(
name|up
operator|->
name|debug
argument_list|)
expr_stmt|;
name|up
operator|->
name|debug
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|up
operator|->
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|up
operator|->
name|debug
argument_list|,
literal|"true%d: "
argument_list|,
name|up
operator|->
name|unit
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|up
operator|->
name|debug
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*STDC*/
end_comment

begin_comment
comment|/*  * true_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|true_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|true_unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* 	 * Open serial port 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_CLK
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|true_unit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|true_unit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|true_unit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|true_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
name|up
operator|->
name|type
operator|=
name|t_unknown
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|s_Base
expr_stmt|;
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_Init
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * true_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|true_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|true_unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|true_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * true_receive - receive data from the serial interface on a clock  */
end_comment

begin_function
specifier|static
name|void
name|true_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|true_unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|u_short
name|new_station
decl_stmt|;
name|char
name|synced
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|lat
decl_stmt|,
name|lon
decl_stmt|,
name|off
decl_stmt|;
comment|/* GOES Satellite position */
comment|/* 	 * Get the clock this applies to and pointers to the data. 	 */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|true_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Read clock output.  Automatically handles STREAMS, CLKLDISC. 	 */
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
comment|/* 	 * There is a case where<cr><lf> generates 2 timestamps. 	 */
if|if
condition|(
name|pp
operator|->
name|lencode
operator|==
literal|0
condition|)
return|return;
name|pp
operator|->
name|a_lastcode
index|[
name|pp
operator|->
name|lencode
index|]
operator|=
literal|'\0'
expr_stmt|;
name|true_debug
argument_list|(
name|peer
argument_list|,
literal|"receive(%s) [%d]\n"
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
name|pp
operator|->
name|lencode
argument_list|)
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
comment|/* 	 * We get down to business, check the timecode format and decode 	 * its contents. This code decodes a multitude of different 	 * clock messages. Timecodes are processed if needed. All replies 	 * will be run through the state machine to tweak driver options 	 * and program the clock. 	 */
comment|/* 	 * Clock misunderstood our last command? 	 */
if|if
condition|(
name|pp
operator|->
name|a_lastcode
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_Huh
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Timecode: "nnnnn+nnn-nnn" 	 * (from GOES clock when asked about satellite position) 	 */
if|if
condition|(
operator|(
name|pp
operator|->
name|a_lastcode
index|[
literal|5
index|]
operator|==
literal|'+'
operator|||
name|pp
operator|->
name|a_lastcode
index|[
literal|5
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|pp
operator|->
name|a_lastcode
index|[
literal|9
index|]
operator|==
literal|'+'
operator|||
name|pp
operator|->
name|a_lastcode
index|[
literal|9
index|]
operator|==
literal|'-'
operator|)
operator|&&
name|sscanf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%5d%*c%3d%*c%3d"
argument_list|,
operator|&
name|lon
argument_list|,
operator|&
name|lat
argument_list|,
operator|&
name|off
argument_list|)
operator|==
literal|3
condition|)
block|{
specifier|const
name|char
modifier|*
name|label
init|=
literal|"Botch!"
decl_stmt|;
comment|/* 		 * This is less than perfect.  Call the (satellite) 		 * either EAST or WEST and adjust slop accodingly 		 * Perfectionists would recalculate the exact delay 		 * and adjust accordingly... 		 */
if|if
condition|(
name|lon
operator|>
literal|7000
operator|&&
name|lon
operator|<
literal|14000
condition|)
block|{
if|if
condition|(
name|lon
operator|<
literal|10000
condition|)
block|{
name|new_station
operator|=
name|GOES_EAST
expr_stmt|;
name|label
operator|=
literal|"EAST"
expr_stmt|;
block|}
else|else
block|{
name|new_station
operator|=
name|GOES_WEST
expr_stmt|;
name|label
operator|=
literal|"WEST"
expr_stmt|;
block|}
if|if
condition|(
name|new_station
operator|!=
name|up
operator|->
name|station
condition|)
block|{
name|double
name|dtemp
decl_stmt|;
name|dtemp
operator|=
name|pp
operator|->
name|fudgetime1
expr_stmt|;
name|pp
operator|->
name|fudgetime1
operator|=
name|pp
operator|->
name|fudgetime2
expr_stmt|;
name|pp
operator|->
name|fudgetime2
operator|=
name|dtemp
expr_stmt|;
name|up
operator|->
name|station
operator|=
name|new_station
expr_stmt|;
block|}
block|}
else|else
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|label
operator|=
literal|"UNKNOWN"
expr_stmt|;
block|}
name|true_debug
argument_list|(
name|peer
argument_list|,
literal|"GOES: station %s\n"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_Satellite
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Timecode: "Fnn" 	 * (from TM/TMD clock when it wants to tell us what it's up to.) 	 */
if|if
condition|(
name|sscanf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"F%2d"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|1
operator|&&
name|i
operator|>
literal|0
operator|&&
name|i
operator|<
literal|80
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|50
case|:
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_F50
argument_list|)
expr_stmt|;
break|break;
case|case
literal|51
case|:
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_F51
argument_list|)
expr_stmt|;
break|break;
default|default:
name|true_debug
argument_list|(
name|peer
argument_list|,
literal|"got F%02d - ignoring\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
comment|/* 	 * Timecode: " TRUETIME Mk III" 	 * (from a TM/TMD clock during initialization.) 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|" TRUETIME Mk III"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_F18
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKSTATUS
argument_list|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"TM/TMD: %s"
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Timecode: "N03726428W12209421+000033" 	 *                      1         2 	 *            0123456789012345678901234 	 * (from a TCU during initialization) 	 */
if|if
condition|(
operator|(
name|pp
operator|->
name|a_lastcode
index|[
literal|0
index|]
operator|==
literal|'N'
operator|||
name|pp
operator|->
name|a_lastcode
index|[
literal|0
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|pp
operator|->
name|a_lastcode
index|[
literal|9
index|]
operator|==
literal|'W'
operator|||
name|pp
operator|->
name|a_lastcode
index|[
literal|9
index|]
operator|==
literal|'E'
operator|)
operator|&&
name|pp
operator|->
name|a_lastcode
index|[
literal|18
index|]
operator|==
literal|'+'
condition|)
block|{
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_Location
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKSTATUS
argument_list|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"TCU-800: %s"
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Timecode: "ddd:hh:mm:ssQ" 	 * (from all clocks supported by this driver.) 	 */
if|if
condition|(
name|pp
operator|->
name|a_lastcode
index|[
literal|3
index|]
operator|==
literal|':'
operator|&&
name|pp
operator|->
name|a_lastcode
index|[
literal|6
index|]
operator|==
literal|':'
operator|&&
name|pp
operator|->
name|a_lastcode
index|[
literal|9
index|]
operator|==
literal|':'
operator|&&
name|sscanf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%3d:%2d:%2d:%2d%c"
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|synced
argument_list|)
operator|==
literal|5
condition|)
block|{
comment|/* 		 * Adjust the synchronize indicator according to timecode 		 */
if|if
condition|(
name|synced
operator|!=
literal|' '
operator|&&
name|synced
operator|!=
literal|'.'
operator|&&
name|synced
operator|!=
literal|'*'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_TS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLOCK_PPS720
comment|/* If it's taken more than 65ms to get here, we'll lose. */
if|if
condition|(
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
operator|)
operator|&&
name|up
operator|->
name|pcl720init
condition|)
block|{
name|l_fp
name|off
decl_stmt|;
ifdef|#
directive|ifdef
name|CLOCK_ATOM
comment|/* 			 * find out what time it really is. Include 			 * the count from the PCL720 			 */
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|GMT
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|&
name|off
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|pp
operator|->
name|usec
operator|=
name|true_sample720
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLOCK_ATOM
name|TVUTOTSF
argument_list|(
name|pp
operator|->
name|usec
argument_list|,
name|off
operator|.
name|l_uf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Stomp all over the timestamp that was pulled out 			 * of the input stream. It's irrelevant since we've 			 * adjusted the input time to reflect now (via pp->usec) 			 * rather than when the data was collected. 			 */
name|get_systime
argument_list|(
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLOCK_ATOM
comment|/* 			 * Create a true offset for feeding to pps_sample() 			 */
name|L_SUB
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
name|pps_sample
argument_list|(
name|peer
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|true_debug
argument_list|(
name|peer
argument_list|,
literal|"true_sample720: %luus\n"
argument_list|,
name|pp
operator|->
name|usec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * The clock will blurt a timecode every second but we only 		 * want one when polled.  If we havn't been polled, bail out. 		 */
if|if
condition|(
operator|!
name|up
operator|->
name|polled
condition|)
return|return;
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_Poll
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* 		 * We have succedded in answering the poll. 		 * Turn off the flag and return 		 */
name|up
operator|->
name|polled
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * No match to known timecodes, report failure and return 	 */
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * true_send - time to send the clock a signal to cough up a time sample  */
end_comment

begin_function
specifier|static
name|void
name|true_send
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG1
operator|)
condition|)
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|true_debug
argument_list|(
name|peer
argument_list|,
literal|"Send '%s'\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|cmd
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
operator|!=
name|len
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
else|else
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * state machine for initializing and controlling a clock  */
end_comment

begin_function
specifier|static
name|void
name|true_doevent
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|enum
name|true_event
name|event
parameter_list|)
block|{
name|struct
name|true_unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|true_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|e_TS
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKSTATUS
argument_list|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"TRUE: clock %s, state %s, event %s"
argument_list|,
name|typeStr
argument_list|(
name|up
operator|->
name|type
argument_list|)
argument_list|,
name|stateStr
argument_list|(
name|up
operator|->
name|state
argument_list|)
argument_list|,
name|eventStr
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|true_debug
argument_list|(
name|peer
argument_list|,
literal|"clock %s, state %s, event %s\n"
argument_list|,
name|typeStr
argument_list|(
name|up
operator|->
name|type
argument_list|)
argument_list|,
name|stateStr
argument_list|(
name|up
operator|->
name|state
argument_list|)
argument_list|,
name|eventStr
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|up
operator|->
name|type
condition|)
block|{
case|case
name|t_goes
case|:
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|e_Init
case|:
comment|/* FALLTHROUGH */
case|case
name|e_Satellite
case|:
comment|/* 			 * Switch back to on-second time codes and return. 			 */
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|s_Start
expr_stmt|;
break|break;
case|case
name|e_Poll
case|:
comment|/* 			 * After each poll, check the station (satellite). 			 */
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"P"
argument_list|)
expr_stmt|;
comment|/* No state change needed. */
break|break;
default|default:
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|t_omega
case|:
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|e_Init
case|:
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|s_Start
expr_stmt|;
break|break;
case|case
name|e_TS
case|:
if|if
condition|(
name|up
operator|->
name|state
operator|!=
name|s_Start
operator|&&
name|up
operator|->
name|state
operator|!=
name|s_Auto
condition|)
block|{
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"\03\r"
argument_list|)
expr_stmt|;
break|break;
block|}
name|up
operator|->
name|state
operator|=
name|s_Auto
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|t_tm
case|:
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|e_Init
case|:
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"F18\r"
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|s_Init
expr_stmt|;
break|break;
case|case
name|e_F18
case|:
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"F50\r"
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|s_F18
expr_stmt|;
break|break;
case|case
name|e_F50
case|:
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"F51\r"
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|s_F50
expr_stmt|;
break|break;
case|case
name|e_F51
case|:
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"F08\r"
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|s_Start
expr_stmt|;
break|break;
case|case
name|e_TS
case|:
if|if
condition|(
name|up
operator|->
name|state
operator|!=
name|s_Start
operator|&&
name|up
operator|->
name|state
operator|!=
name|s_Auto
condition|)
block|{
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"\03\r"
argument_list|)
expr_stmt|;
break|break;
block|}
name|up
operator|->
name|state
operator|=
name|s_Auto
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|t_tcu
case|:
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|e_Init
case|:
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"MD3\r"
argument_list|)
expr_stmt|;
comment|/* GPS Synch'd Gen. */
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"TSU\r"
argument_list|)
expr_stmt|;
comment|/* UTC, not GPS. */
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"AU\r"
argument_list|)
expr_stmt|;
comment|/* Auto Timestamps. */
name|up
operator|->
name|state
operator|=
name|s_Start
expr_stmt|;
break|break;
case|case
name|e_TS
case|:
if|if
condition|(
name|up
operator|->
name|state
operator|!=
name|s_Start
operator|&&
name|up
operator|->
name|state
operator|!=
name|s_Auto
condition|)
block|{
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"\03\r"
argument_list|)
expr_stmt|;
break|break;
block|}
name|up
operator|->
name|state
operator|=
name|s_Auto
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|t_unknown
case|:
switch|switch
condition|(
name|up
operator|->
name|state
condition|)
block|{
case|case
name|s_Base
case|:
if|if
condition|(
name|event
operator|!=
name|e_Init
condition|)
name|abort
argument_list|()
expr_stmt|;
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"P\r"
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|s_InqGOES
expr_stmt|;
break|break;
case|case
name|s_InqGOES
case|:
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|e_Satellite
case|:
name|up
operator|->
name|type
operator|=
name|t_goes
expr_stmt|;
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_Init
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_Init
case|:
comment|/*FALLTHROUGH*/
case|case
name|e_Huh
case|:
comment|/*FALLTHROUGH*/
case|case
name|e_TS
case|:
name|up
operator|->
name|state
operator|=
name|s_InqOmega
expr_stmt|;
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"C\r"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|s_InqOmega
case|:
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|e_TS
case|:
name|up
operator|->
name|type
operator|=
name|t_omega
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|s_Auto
expr_stmt|;
comment|/* Inq side-effect. */
break|break;
case|case
name|e_Init
case|:
comment|/*FALLTHROUGH*/
case|case
name|e_Huh
case|:
name|up
operator|->
name|state
operator|=
name|s_InqTM
expr_stmt|;
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"F18\r"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|s_InqTM
case|:
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|e_F18
case|:
name|up
operator|->
name|type
operator|=
name|t_tm
expr_stmt|;
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_Init
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_Init
case|:
comment|/*FALLTHROUGH*/
case|case
name|e_Huh
case|:
name|true_send
argument_list|(
name|peer
argument_list|,
literal|"PO\r"
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|s_InqTCU
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|s_InqTCU
case|:
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|e_Location
case|:
name|up
operator|->
name|type
operator|=
name|t_tcu
expr_stmt|;
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_Init
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_Init
case|:
comment|/*FALLTHROUGH*/
case|case
name|e_Huh
case|:
name|up
operator|->
name|state
operator|=
name|s_Base
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
comment|/* 			 * An expedient hack to prevent lint complaints, 			 * these don't actually need to be used here... 			 */
case|case
name|s_Init
case|:
case|case
name|s_F18
case|:
case|case
name|s_F50
case|:
case|case
name|s_Start
case|:
case|case
name|s_Auto
case|:
case|case
name|s_Max
case|:
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"TRUE: state %s is unexpected!"
argument_list|,
name|stateStr
argument_list|(
name|up
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
ifdef|#
directive|ifdef
name|CLOCK_PPS720
if|if
condition|(
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
operator|)
operator|&&
operator|!
name|up
operator|->
name|pcl720init
condition|)
block|{
comment|/* Make counter trigger on gate0, count down from 65535. */
name|pcl720_load
argument_list|(
name|PCL720_IOB
argument_list|,
name|PCL720_CTR
argument_list|,
name|i8253_oneshot
argument_list|,
literal|65535
argument_list|)
expr_stmt|;
comment|/* 		 * (These constants are OK since 		 * they represent hardware maximums.) 		 */
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"PCL-720 initialized"
argument_list|)
expr_stmt|;
block|}
name|up
operator|->
name|pcl720init
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * true_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|true_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|true_unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * You don't need to poll this clock.  It puts out timecodes 	 * once per second.  If asked for a timestamp, take note. 	 * The next time a timecode comes in, it will be fed back. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|true_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|pollcnt
operator|>
literal|0
condition|)
name|up
operator|->
name|pollcnt
operator|--
expr_stmt|;
else|else
block|{
name|true_doevent
argument_list|(
name|peer
argument_list|,
name|e_Init
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * polled every 64 seconds. Ask true_receive to hand in a 	 * timestamp. 	 */
name|up
operator|->
name|polled
operator|=
literal|1
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CLOCK_PPS720
end_ifdef

begin_comment
comment|/*  * true_sample720 - sample the PCL-720  */
end_comment

begin_function
specifier|static
name|u_long
name|true_sample720
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|f
decl_stmt|;
comment|/* We wire the PCL-720's 8253.OUT0 to bit 0 of connector 3. 	 * If it is not being held low now, we did not get called 	 * within 65535us. 	 */
if|if
condition|(
name|inb
argument_list|(
name|pcl720_data_16_23
argument_list|(
name|PCL720_IOB
argument_list|)
argument_list|)
operator|&
literal|0x01
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"PCL-720 out of synch"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|f
operator|=
operator|(
literal|65536
operator|-
name|pcl720_read
argument_list|(
name|PCL720_IOB
argument_list|,
name|PCL720_CTR
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS720_DEBUG
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"PCL-720: %luus"
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_true_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

