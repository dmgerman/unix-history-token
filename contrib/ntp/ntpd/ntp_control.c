begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_control.c - respond to control messages and send async traps  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PUBKEY
end_ifdef

begin_include
include|#
directive|include
file|"ntp_crypto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PUBKEY */
end_comment

begin_comment
comment|/*  * Structure to hold request procedure information  */
end_comment

begin_define
define|#
directive|define
name|NOAUTH
value|0
end_define

begin_define
define|#
directive|define
name|AUTH
value|1
end_define

begin_define
define|#
directive|define
name|NO_REQUEST
value|(-1)
end_define

begin_struct
struct|struct
name|ctl_proc
block|{
name|short
name|control_code
decl_stmt|;
comment|/* defined request code */
name|u_short
name|flags
decl_stmt|;
comment|/* flags word */
name|void
argument_list|(
argument|*handler
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* handle request */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Only one flag.  Authentication required or not.  */
end_comment

begin_define
define|#
directive|define
name|NOAUTH
value|0
end_define

begin_define
define|#
directive|define
name|AUTH
value|1
end_define

begin_comment
comment|/*  * Request processing routines  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ctl_error
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|ctlclkstatus
name|P
argument_list|(
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_flushpkt
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putdata
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putstr
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putdbl
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putuint
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_puthex
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putint
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putts
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putadr
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|u_int32
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putid
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putarray
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|double
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putsys
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putpeer
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ctl_putclock
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
modifier|*
name|ctl_getitem
name|P
argument_list|(
operator|(
expr|struct
name|ctl_var
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|count_var
name|P
argument_list|(
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|control_unspec
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_status
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_variables
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_variables
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_clock_status
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_clock_status
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_trap
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unset_trap
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_trap
modifier|*
name|ctlfindtrap
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_proc
name|control_codes
index|[]
init|=
block|{
block|{
name|CTL_OP_UNSPEC
block|,
name|NOAUTH
block|,
name|control_unspec
block|}
block|,
block|{
name|CTL_OP_READSTAT
block|,
name|NOAUTH
block|,
name|read_status
block|}
block|,
block|{
name|CTL_OP_READVAR
block|,
name|NOAUTH
block|,
name|read_variables
block|}
block|,
block|{
name|CTL_OP_WRITEVAR
block|,
name|AUTH
block|,
name|write_variables
block|}
block|,
block|{
name|CTL_OP_READCLOCK
block|,
name|NOAUTH
block|,
name|read_clock_status
block|}
block|,
block|{
name|CTL_OP_WRITECLOCK
block|,
name|NOAUTH
block|,
name|write_clock_status
block|}
block|,
block|{
name|CTL_OP_SETTRAP
block|,
name|NOAUTH
block|,
name|set_trap
block|}
block|,
block|{
name|CTL_OP_UNSETTRAP
block|,
name|NOAUTH
block|,
name|unset_trap
block|}
block|,
block|{
name|NO_REQUEST
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System variable values. The array can be indexed by the variable  * index to find the textual name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
name|sys_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CS_LEAP
block|,
name|RW
block|,
literal|"leap"
block|}
block|,
comment|/* 1 */
block|{
name|CS_STRATUM
block|,
name|RO
block|,
literal|"stratum"
block|}
block|,
comment|/* 2 */
block|{
name|CS_PRECISION
block|,
name|RO
block|,
literal|"precision"
block|}
block|,
comment|/* 3 */
block|{
name|CS_ROOTDELAY
block|,
name|RO
block|,
literal|"rootdelay"
block|}
block|,
comment|/* 4 */
block|{
name|CS_ROOTDISPERSION
block|,
name|RO
block|,
literal|"rootdispersion"
block|}
block|,
comment|/* 5 */
block|{
name|CS_REFID
block|,
name|RO
block|,
literal|"refid"
block|}
block|,
comment|/* 6 */
block|{
name|CS_REFTIME
block|,
name|RO
block|,
literal|"reftime"
block|}
block|,
comment|/* 7 */
block|{
name|CS_POLL
block|,
name|RO
block|,
literal|"poll"
block|}
block|,
comment|/* 8 */
block|{
name|CS_PEERID
block|,
name|RO
block|,
literal|"peer"
block|}
block|,
comment|/* 9 */
block|{
name|CS_STATE
block|,
name|RO
block|,
literal|"state"
block|}
block|,
comment|/* 10 */
block|{
name|CS_OFFSET
block|,
name|RO
block|,
literal|"offset"
block|}
block|,
comment|/* 11 */
block|{
name|CS_DRIFT
block|,
name|RO
block|,
literal|"frequency"
block|}
block|,
comment|/* 12 */
block|{
name|CS_JITTER
block|,
name|RO
block|,
literal|"jitter"
block|}
block|,
comment|/* 13 */
block|{
name|CS_CLOCK
block|,
name|RO
block|,
literal|"clock"
block|}
block|,
comment|/* 14 */
block|{
name|CS_PROCESSOR
block|,
name|RO
block|,
literal|"processor"
block|}
block|,
comment|/* 15 */
block|{
name|CS_SYSTEM
block|,
name|RO
block|,
literal|"system"
block|}
block|,
comment|/* 16 */
block|{
name|CS_VERSION
block|,
name|RO
block|,
literal|"version"
block|}
block|,
comment|/* 17 */
block|{
name|CS_STABIL
block|,
name|RO
block|,
literal|"stability"
block|}
block|,
comment|/* 18 */
block|{
name|CS_VARLIST
block|,
name|RO
block|,
literal|"sys_var_list"
block|}
block|,
comment|/* 19 */
ifdef|#
directive|ifdef
name|PUBKEY
block|{
name|CS_FLAGS
block|,
name|RO
block|,
literal|"flags"
block|}
block|,
comment|/* 20 */
block|{
name|CS_HOST
block|,
name|RO
block|,
literal|"hostname"
block|}
block|,
comment|/* 21 */
block|{
name|CS_PUBLIC
block|,
name|RO
block|,
literal|"publickey"
block|}
block|,
comment|/* 22 */
block|{
name|CS_CERTIF
block|,
name|RO
block|,
literal|"certificate"
block|}
block|,
comment|/* 23 */
block|{
name|CS_DHPARAMS
block|,
name|RO
block|,
literal|"params"
block|}
block|,
comment|/* 24 */
block|{
name|CS_REVTIME
block|,
name|RO
block|,
literal|"refresh"
block|}
block|,
comment|/* 25 */
block|{
name|CS_LEAPTAB
block|,
name|RO
block|,
literal|"leapseconds"
block|}
block|,
comment|/* 26 */
block|{
name|CS_TAI
block|,
name|RO
block|,
literal|"tai"
block|}
block|,
comment|/* 27 */
endif|#
directive|endif
comment|/* PUBKEY */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
comment|/* 28 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
modifier|*
name|ext_sys_var
init|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System variables we print by default (in fuzzball order,  * more-or-less)  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|def_sys_var
index|[]
init|=
block|{
name|CS_VERSION
block|,
name|CS_PROCESSOR
block|,
name|CS_SYSTEM
block|,
name|CS_LEAP
block|,
name|CS_STRATUM
block|,
name|CS_PRECISION
block|,
name|CS_ROOTDELAY
block|,
name|CS_ROOTDISPERSION
block|,
name|CS_PEERID
block|,
name|CS_REFID
block|,
name|CS_REFTIME
block|,
name|CS_POLL
block|,
name|CS_CLOCK
block|,
name|CS_STATE
block|,
name|CS_OFFSET
block|,
name|CS_DRIFT
block|,
name|CS_JITTER
block|,
name|CS_STABIL
block|,
ifdef|#
directive|ifdef
name|PUBKEY
name|CS_FLAGS
block|,
name|CS_HOST
block|,
name|CS_CERTIF
block|,
name|CS_DHPARAMS
block|,
name|CS_REVTIME
block|,
name|CS_LEAPTAB
block|,
endif|#
directive|endif
comment|/* PUBKEY */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Peer variable list  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
name|peer_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CP_CONFIG
block|,
name|RO
block|,
literal|"config"
block|}
block|,
comment|/* 1 */
block|{
name|CP_AUTHENABLE
block|,
name|RO
block|,
literal|"authenable"
block|}
block|,
comment|/* 2 */
block|{
name|CP_AUTHENTIC
block|,
name|RO
block|,
literal|"authentic"
block|}
block|,
comment|/* 3 */
block|{
name|CP_SRCADR
block|,
name|RO
block|,
literal|"srcadr"
block|}
block|,
comment|/* 4 */
block|{
name|CP_SRCPORT
block|,
name|RO
block|,
literal|"srcport"
block|}
block|,
comment|/* 5 */
block|{
name|CP_DSTADR
block|,
name|RO
block|,
literal|"dstadr"
block|}
block|,
comment|/* 6 */
block|{
name|CP_DSTPORT
block|,
name|RO
block|,
literal|"dstport"
block|}
block|,
comment|/* 7 */
block|{
name|CP_LEAP
block|,
name|RO
block|,
literal|"leap"
block|}
block|,
comment|/* 8 */
block|{
name|CP_HMODE
block|,
name|RO
block|,
literal|"hmode"
block|}
block|,
comment|/* 9 */
block|{
name|CP_STRATUM
block|,
name|RO
block|,
literal|"stratum"
block|}
block|,
comment|/* 10 */
block|{
name|CP_PPOLL
block|,
name|RO
block|,
literal|"ppoll"
block|}
block|,
comment|/* 11 */
block|{
name|CP_HPOLL
block|,
name|RO
block|,
literal|"hpoll"
block|}
block|,
comment|/* 12 */
block|{
name|CP_PRECISION
block|,
name|RO
block|,
literal|"precision"
block|}
block|,
comment|/* 13 */
block|{
name|CP_ROOTDELAY
block|,
name|RO
block|,
literal|"rootdelay"
block|}
block|,
comment|/* 14 */
block|{
name|CP_ROOTDISPERSION
block|,
name|RO
block|,
literal|"rootdispersion"
block|}
block|,
comment|/* 15 */
block|{
name|CP_REFID
block|,
name|RO
block|,
literal|"refid"
block|}
block|,
comment|/* 16 */
block|{
name|CP_REFTIME
block|,
name|RO
block|,
literal|"reftime"
block|}
block|,
comment|/* 17 */
block|{
name|CP_ORG
block|,
name|RO
block|,
literal|"org"
block|}
block|,
comment|/* 18 */
block|{
name|CP_REC
block|,
name|RO
block|,
literal|"rec"
block|}
block|,
comment|/* 19 */
block|{
name|CP_XMT
block|,
name|RO
block|,
literal|"xmt"
block|}
block|,
comment|/* 20 */
block|{
name|CP_REACH
block|,
name|RO
block|,
literal|"reach"
block|}
block|,
comment|/* 21 */
block|{
name|CP_VALID
block|,
name|RO
block|,
literal|"unreach"
block|}
block|,
comment|/* 22 */
block|{
name|CP_TIMER
block|,
name|RO
block|,
literal|"timer"
block|}
block|,
comment|/* 23 */
block|{
name|CP_DELAY
block|,
name|RO
block|,
literal|"delay"
block|}
block|,
comment|/* 24 */
block|{
name|CP_OFFSET
block|,
name|RO
block|,
literal|"offset"
block|}
block|,
comment|/* 25 */
block|{
name|CP_JITTER
block|,
name|RO
block|,
literal|"jitter"
block|}
block|,
comment|/* 26 */
block|{
name|CP_DISPERSION
block|,
name|RO
block|,
literal|"dispersion"
block|}
block|,
comment|/* 27 */
block|{
name|CP_KEYID
block|,
name|RO
block|,
literal|"keyid"
block|}
block|,
comment|/* 28 */
block|{
name|CP_FILTDELAY
block|,
name|RO
block|,
literal|"filtdelay="
block|}
block|,
comment|/* 29 */
block|{
name|CP_FILTOFFSET
block|,
name|RO
block|,
literal|"filtoffset="
block|}
block|,
comment|/* 30 */
block|{
name|CP_PMODE
block|,
name|RO
block|,
literal|"pmode"
block|}
block|,
comment|/* 31 */
block|{
name|CP_RECEIVED
block|,
name|RO
block|,
literal|"received"
block|}
block|,
comment|/* 32 */
block|{
name|CP_SENT
block|,
name|RO
block|,
literal|"sent"
block|}
block|,
comment|/* 33 */
block|{
name|CP_FILTERROR
block|,
name|RO
block|,
literal|"filtdisp="
block|}
block|,
comment|/* 34 */
block|{
name|CP_FLASH
block|,
name|RO
block|,
literal|"flash"
block|}
block|,
comment|/* 35 */
block|{
name|CP_TTL
block|,
name|RO
block|,
literal|"ttl"
block|}
block|,
comment|/* 36 */
block|{
name|CP_TTLMAX
block|,
name|RO
block|,
literal|"ttlmax"
block|}
block|,
comment|/* 37 */
block|{
name|CP_VARLIST
block|,
name|RO
block|,
literal|"peer_var_list"
block|}
block|,
comment|/* 38 */
ifdef|#
directive|ifdef
name|PUBKEY
block|{
name|CP_FLAGS
block|,
name|RO
block|,
literal|"flags"
block|}
block|,
comment|/* 38 */
block|{
name|CP_HOST
block|,
name|RO
block|,
literal|"hostname"
block|}
block|,
comment|/* 39 */
block|{
name|CP_PUBLIC
block|,
name|RO
block|,
literal|"publickey"
block|}
block|,
comment|/* 40 */
block|{
name|CP_CERTIF
block|,
name|RO
block|,
literal|"certificate"
block|}
block|,
comment|/* 41 */
block|{
name|CP_SESKEY
block|,
name|RO
block|,
literal|"pcookie"
block|}
block|,
comment|/* 42 */
block|{
name|CP_SASKEY
block|,
name|RO
block|,
literal|"hcookie"
block|}
block|,
comment|/* 43 */
block|{
name|CP_INITSEQ
block|,
name|RO
block|,
literal|"initsequence"
block|}
block|,
comment|/* 44 */
block|{
name|CP_INITKEY
block|,
name|RO
block|,
literal|"initkey"
block|}
block|,
comment|/* 45 */
block|{
name|CP_INITTSP
block|,
name|RO
block|,
literal|"timestamp"
block|}
block|,
comment|/* 46 */
endif|#
directive|endif
comment|/* PUBKEY */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
comment|/* 47 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Peer variables we print by default  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|def_peer_var
index|[]
init|=
block|{
name|CP_SRCADR
block|,
name|CP_SRCPORT
block|,
name|CP_DSTADR
block|,
name|CP_DSTPORT
block|,
name|CP_LEAP
block|,
name|CP_STRATUM
block|,
name|CP_PRECISION
block|,
name|CP_ROOTDELAY
block|,
name|CP_ROOTDISPERSION
block|,
name|CP_REFID
block|,
name|CP_REACH
block|,
name|CP_VALID
block|,
name|CP_HMODE
block|,
name|CP_PMODE
block|,
name|CP_HPOLL
block|,
name|CP_PPOLL
block|,
name|CP_FLASH
block|,
name|CP_KEYID
block|,
name|CP_TTL
block|,
name|CP_TTLMAX
block|,
name|CP_OFFSET
block|,
name|CP_DELAY
block|,
name|CP_DISPERSION
block|,
name|CP_JITTER
block|,
name|CP_REFTIME
block|,
name|CP_ORG
block|,
name|CP_REC
block|,
name|CP_XMT
block|,
name|CP_FILTDELAY
block|,
name|CP_FILTOFFSET
block|,
name|CP_FILTERROR
block|,
ifdef|#
directive|ifdef
name|PUBKEY
name|CP_FLAGS
block|,
name|CP_HOST
block|,
name|CP_CERTIF
block|,
name|CP_SESKEY
block|,
name|CP_INITSEQ
block|,
endif|#
directive|endif
comment|/* PUBKEY */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * Clock variable list  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
name|clock_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CC_TYPE
block|,
name|RO
block|,
literal|"type"
block|}
block|,
comment|/* 1 */
block|{
name|CC_TIMECODE
block|,
name|RO
block|,
literal|"timecode"
block|}
block|,
comment|/* 2 */
block|{
name|CC_POLL
block|,
name|RO
block|,
literal|"poll"
block|}
block|,
comment|/* 3 */
block|{
name|CC_NOREPLY
block|,
name|RO
block|,
literal|"noreply"
block|}
block|,
comment|/* 4 */
block|{
name|CC_BADFORMAT
block|,
name|RO
block|,
literal|"badformat"
block|}
block|,
comment|/* 5 */
block|{
name|CC_BADDATA
block|,
name|RO
block|,
literal|"baddata"
block|}
block|,
comment|/* 6 */
block|{
name|CC_FUDGETIME1
block|,
name|RO
block|,
literal|"fudgetime1"
block|}
block|,
comment|/* 7 */
block|{
name|CC_FUDGETIME2
block|,
name|RO
block|,
literal|"fudgetime2"
block|}
block|,
comment|/* 8 */
block|{
name|CC_FUDGEVAL1
block|,
name|RO
block|,
literal|"stratum"
block|}
block|,
comment|/* 9 */
block|{
name|CC_FUDGEVAL2
block|,
name|RO
block|,
literal|"refid"
block|}
block|,
comment|/* 10 */
block|{
name|CC_FLAGS
block|,
name|RO
block|,
literal|"flags"
block|}
block|,
comment|/* 11 */
block|{
name|CC_DEVICE
block|,
name|RO
block|,
literal|"device"
block|}
block|,
comment|/* 12 */
block|{
name|CC_VARLIST
block|,
name|RO
block|,
literal|"clock_var_list"
block|}
block|,
comment|/* 13 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
comment|/* 14 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clock variables printed by default  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|def_clock_var
index|[]
init|=
block|{
name|CC_DEVICE
block|,
name|CC_TYPE
block|,
comment|/* won't be output if device = known */
name|CC_TIMECODE
block|,
name|CC_POLL
block|,
name|CC_NOREPLY
block|,
name|CC_BADFORMAT
block|,
name|CC_BADDATA
block|,
name|CC_FUDGETIME1
block|,
name|CC_FUDGETIME2
block|,
name|CC_FUDGEVAL1
block|,
name|CC_FUDGEVAL2
block|,
name|CC_FLAGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * System and processor definitions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_UNAME
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|STR_SYSTEM
end_ifndef

begin_define
define|#
directive|define
name|STR_SYSTEM
value|"UNIX"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STR_PROCESSOR
end_ifndef

begin_define
define|#
directive|define
name|STR_PROCESSOR
value|"unknown"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|str_system
index|[]
init|=
name|STR_SYSTEM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|str_processor
index|[]
init|=
name|STR_PROCESSOR
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|utsname
name|utsnamebuf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNAME */
end_comment

begin_comment
comment|/*  * Trap structures. We only allow a few of these, and send a copy of  * each async message to each live one. Traps time out after an hour, it  * is up to the trap receipient to keep resetting it to avoid being  * timed out.  */
end_comment

begin_comment
comment|/* ntp_request.c */
end_comment

begin_decl_stmt
name|struct
name|ctl_trap
name|ctl_trap
index|[
name|CTL_MAXTRAPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_ctl_traps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Type bits, for ctlsettrap() call.  */
end_comment

begin_define
define|#
directive|define
name|TRAP_TYPE_CONFIG
value|0
end_define

begin_comment
comment|/* used by configuration code */
end_comment

begin_define
define|#
directive|define
name|TRAP_TYPE_PRIO
value|1
end_define

begin_comment
comment|/* priority trap */
end_comment

begin_define
define|#
directive|define
name|TRAP_TYPE_NONPRIO
value|2
end_define

begin_comment
comment|/* nonpriority trap */
end_comment

begin_comment
comment|/*  * List relating reference clock types to control message time sources.  * Index by the reference clock type. This list will only be used iff  * the reference clock driver doesn't set peer->sstclktype to something  * different than CTL_SST_TS_UNSPEC.  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|clocktypes
index|[]
init|=
block|{
name|CTL_SST_TS_NTP
block|,
comment|/* REFCLK_NONE (0) */
name|CTL_SST_TS_LOCAL
block|,
comment|/* REFCLK_LOCALCLOCK (1) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_TRAK (2) */
name|CTL_SST_TS_HF
block|,
comment|/* REFCLK_WWV_PST (3) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_WWVB_SPECTRACOM (4) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_TRUETIME (5) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GOES_TRAK (6) */
name|CTL_SST_TS_HF
block|,
comment|/* REFCLK_CHU (7) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLOCK_PARSE (default) (8) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_GPS_MX4200 (9) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_AS2201 (10) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_ARBITER (11) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_IRIG_TPRO (12) */
name|CTL_SST_TS_ATOM
block|,
comment|/* REFCLK_ATOM_LEITCH (13) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_MSF_EES (14) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_TRUETIME (15) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_IRIG_BANCOMM (16) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_DATU (17) */
name|CTL_SST_TS_TELEPHONE
block|,
comment|/* REFCLK_NIST_ACTS (18) */
name|CTL_SST_TS_HF
block|,
comment|/* REFCLK_WWV_HEATH (19) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_NMEA (20) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_VME (21) */
name|CTL_SST_TS_ATOM
block|,
comment|/* REFCLK_ATOM_PPS (22) */
name|CTL_SST_TS_TELEPHONE
block|,
comment|/* REFCLK_PTB_ACTS (23) */
name|CTL_SST_TS_TELEPHONE
block|,
comment|/* REFCLK_USNO (24) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_TRUETIME (25) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_HP (26) */
name|CTL_SST_TS_TELEPHONE
block|,
comment|/* REFCLK_ARCRON_MSF (27) */
name|CTL_SST_TS_TELEPHONE
block|,
comment|/* REFCLK_SHM (28) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_PALISADE (29) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_ONCORE (30) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_JUPITER (31) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_CHRONOLOG (32) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_DUMBCLOCK (32) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_ULINK (33) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_PCF (35) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_WWV (36) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_FG (37) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_HOPF_SERIAL (38) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_HOPF_PCI (39) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keyid used for authenticating write requests.  */
end_comment

begin_decl_stmt
name|keyid_t
name|ctl_auth_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We keep track of the last error reported by the system internally  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|ctl_sys_last_event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|ctl_sys_num_events
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statistic counters to keep track of requests and responses.  */
end_comment

begin_decl_stmt
name|u_long
name|ctltimereset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time stats reset */
end_comment

begin_decl_stmt
name|u_long
name|numctlreq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of requests we've received */
end_comment

begin_decl_stmt
name|u_long
name|numctlbadpkts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bad control packets */
end_comment

begin_decl_stmt
name|u_long
name|numctlresponses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of resp packets sent with data */
end_comment

begin_decl_stmt
name|u_long
name|numctlfrags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fragments sent */
end_comment

begin_decl_stmt
name|u_long
name|numctlerrors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of error responses sent */
end_comment

begin_decl_stmt
name|u_long
name|numctltooshort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of too short input packets */
end_comment

begin_decl_stmt
name|u_long
name|numctlinputresp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of responses on input */
end_comment

begin_decl_stmt
name|u_long
name|numctlinputfrag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fragments on input */
end_comment

begin_decl_stmt
name|u_long
name|numctlinputerr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input pkts with err bit set */
end_comment

begin_decl_stmt
name|u_long
name|numctlbadoffset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input pkts with nonzero offset */
end_comment

begin_decl_stmt
name|u_long
name|numctlbadversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input pkts with unknown version */
end_comment

begin_decl_stmt
name|u_long
name|numctldatatooshort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data too short for count */
end_comment

begin_decl_stmt
name|u_long
name|numctlbadop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bad op code found in packet */
end_comment

begin_decl_stmt
name|u_long
name|numasyncmsgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of async messages we've sent */
end_comment

begin_comment
comment|/*  * Response packet used by these routines. Also some state information  * so that we can handle packet formatting within a common set of  * subroutines.  Note we try to enter data in place whenever possible,  * but the need to set the more bit correctly means we occasionally  * use the extra buffer and copy.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ntp_control
name|rpkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|associd_t
name|res_associd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|res_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|datapt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|dataend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|datalinelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|datanotbinflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
modifier|*
name|rmt_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|lcl_inter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_authenticate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_authokay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyid_t
name|res_keyid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXDATALINELEN
value|(72)
end_define

begin_decl_stmt
specifier|static
name|u_char
name|res_async
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 if this is async trap response */
end_comment

begin_comment
comment|/*  * Pointers for saving state when decoding request packets  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reqpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reqend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * init_control - initialize request data  */
end_comment

begin_function
name|void
name|init_control
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_UNAME
name|uname
argument_list|(
operator|&
name|utsnamebuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_UNAME */
name|ctl_clr_stats
argument_list|()
expr_stmt|;
name|ctl_auth_keyid
operator|=
literal|0
expr_stmt|;
name|ctl_sys_last_event
operator|=
name|EVNT_UNSPEC
expr_stmt|;
name|ctl_sys_num_events
operator|=
literal|0
expr_stmt|;
name|num_ctl_traps
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAXTRAPS
condition|;
name|i
operator|++
control|)
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_error - send an error response for the current request  */
end_comment

begin_function
specifier|static
name|void
name|ctl_error
parameter_list|(
name|int
name|errcode
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
name|printf
argument_list|(
literal|"sending control error %d\n"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Fill in the fields. We assume rpkt.sequence and rpkt.associd 	 * have already been filled in. 	 */
name|rpkt
operator|.
name|r_m_e_op
operator|=
call|(
name|u_char
call|)
argument_list|(
name|CTL_RESPONSE
operator||
name|CTL_ERROR
operator||
operator|(
name|res_opcode
operator|&
name|CTL_OP_MASK
operator|)
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
call|(
name|u_short
call|)
argument_list|(
operator|(
name|errcode
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
argument_list|)
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * send packet and bump counters 	 */
if|if
condition|(
name|res_authenticate
operator|&&
name|sys_authenticate
condition|)
block|{
name|int
name|maclen
decl_stmt|;
operator|*
operator|(
name|u_int32
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rpkt
operator|+
name|CTL_HEADER_LEN
operator|)
operator|=
name|htonl
argument_list|(
name|res_keyid
argument_list|)
expr_stmt|;
name|maclen
operator|=
name|authencrypt
argument_list|(
name|res_keyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|CTL_HEADER_LEN
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|-
literal|2
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|CTL_HEADER_LEN
operator|+
name|maclen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|-
literal|3
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|CTL_HEADER_LEN
argument_list|)
expr_stmt|;
block|}
name|numctlerrors
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process_control - process an incoming control message  */
end_comment

begin_function
name|void
name|process_control
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
specifier|register
name|struct
name|ntp_control
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|int
name|req_count
decl_stmt|;
specifier|register
name|int
name|req_data
decl_stmt|;
specifier|register
name|struct
name|ctl_proc
modifier|*
name|cc
decl_stmt|;
name|int
name|properlen
decl_stmt|;
name|int
name|maclen
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"in process_control()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Save the addresses for error responses 	 */
name|numctlreq
operator|++
expr_stmt|;
name|rmt_addr
operator|=
operator|&
name|rbufp
operator|->
name|recv_srcadr
expr_stmt|;
name|lcl_inter
operator|=
name|rbufp
operator|->
name|dstadr
expr_stmt|;
name|pkt
operator|=
operator|(
expr|struct
name|ntp_control
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
comment|/* 	 * If the length is less than required for the header, or 	 * it is a response or a fragment, ignore this. 	 */
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|<
name|CTL_HEADER_LEN
operator|||
name|pkt
operator|->
name|r_m_e_op
operator|&
operator|(
name|CTL_RESPONSE
operator||
name|CTL_MORE
operator||
name|CTL_ERROR
operator|)
operator|||
name|pkt
operator|->
name|offset
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"invalid format in control packet\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|<
name|CTL_HEADER_LEN
condition|)
name|numctltooshort
operator|++
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|r_m_e_op
operator|&
name|CTL_RESPONSE
condition|)
name|numctlinputresp
operator|++
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|r_m_e_op
operator|&
name|CTL_MORE
condition|)
name|numctlinputfrag
operator|++
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|r_m_e_op
operator|&
name|CTL_ERROR
condition|)
name|numctlinputerr
operator|++
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|offset
operator|!=
literal|0
condition|)
name|numctlbadoffset
operator|++
expr_stmt|;
return|return;
block|}
name|res_version
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_version
operator|>
name|NTP_VERSION
operator|||
name|res_version
operator|<
name|NTP_OLDVERSION
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"unknown version %d in control packet\n"
argument_list|,
name|res_version
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|numctlbadversion
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Pull enough data from the packet to make intelligent 	 * responses 	 */
name|rpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|res_version
argument_list|,
name|MODE_CONTROL
argument_list|)
expr_stmt|;
name|res_opcode
operator|=
name|pkt
operator|->
name|r_m_e_op
expr_stmt|;
name|rpkt
operator|.
name|sequence
operator|=
name|pkt
operator|->
name|sequence
expr_stmt|;
name|rpkt
operator|.
name|associd
operator|=
name|pkt
operator|->
name|associd
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|res_offset
operator|=
literal|0
expr_stmt|;
name|res_associd
operator|=
name|htons
argument_list|(
name|pkt
operator|->
name|associd
argument_list|)
expr_stmt|;
name|res_async
operator|=
literal|0
expr_stmt|;
name|res_authenticate
operator|=
literal|0
expr_stmt|;
name|res_keyid
operator|=
literal|0
expr_stmt|;
name|res_authokay
operator|=
literal|0
expr_stmt|;
name|req_count
operator|=
operator|(
name|int
operator|)
name|htons
argument_list|(
name|pkt
operator|->
name|count
argument_list|)
expr_stmt|;
name|datanotbinflag
operator|=
literal|0
expr_stmt|;
name|datalinelen
operator|=
literal|0
expr_stmt|;
name|datapt
operator|=
name|rpkt
operator|.
name|data
expr_stmt|;
name|dataend
operator|=
operator|&
operator|(
name|rpkt
operator|.
name|data
index|[
name|CTL_MAX_DATA_LEN
index|]
operator|)
expr_stmt|;
comment|/* 	 * We're set up now. Make sure we've got at least enough 	 * incoming data space to match the count. 	 */
name|req_data
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|CTL_HEADER_LEN
expr_stmt|;
if|if
condition|(
name|req_data
operator|<
name|req_count
operator|||
name|rbufp
operator|->
name|recv_length
operator|&
literal|0x3
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADFMT
argument_list|)
expr_stmt|;
name|numctldatatooshort
operator|++
expr_stmt|;
return|return;
block|}
name|properlen
operator|=
name|req_count
operator|+
name|CTL_HEADER_LEN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
operator|&&
operator|(
name|rbufp
operator|->
name|recv_length
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Packet length %d unrounded\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* round up proper len to a 8 octet boundary */
name|properlen
operator|=
operator|(
name|properlen
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|maclen
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|properlen
expr_stmt|;
if|if
condition|(
operator|(
name|rbufp
operator|->
name|recv_length
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|maclen
operator|>=
name|MIN_MAC_LEN
operator|&&
name|maclen
operator|<=
name|MAX_MAC_LEN
operator|&&
name|sys_authenticate
condition|)
block|{
name|res_authenticate
operator|=
literal|1
expr_stmt|;
name|res_keyid
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|u_int32
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|pkt
operator|+
name|properlen
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"recv_len %d, properlen %d, wants auth with keyid %08x, MAC length=%d\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
name|properlen
argument_list|,
name|res_keyid
argument_list|,
name|maclen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|res_keyid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"invalid keyid %08x\n"
argument_list|,
name|res_keyid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|authdecrypt
argument_list|(
name|res_keyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|pkt
argument_list|,
name|rbufp
operator|->
name|recv_length
operator|-
name|maclen
argument_list|,
name|maclen
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"authenticated okay\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|res_authokay
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"authentication failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|res_keyid
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Set up translate pointers 	 */
name|reqpt
operator|=
operator|(
name|char
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|reqend
operator|=
name|reqpt
operator|+
name|req_count
expr_stmt|;
comment|/* 	 * Look for the opcode processor 	 */
for|for
control|(
name|cc
operator|=
name|control_codes
init|;
name|cc
operator|->
name|control_code
operator|!=
name|NO_REQUEST
condition|;
name|cc
operator|++
control|)
block|{
if|if
condition|(
name|cc
operator|->
name|control_code
operator|==
name|res_opcode
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"opcode %d, found command handler\n"
argument_list|,
name|res_opcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cc
operator|->
name|flags
operator|==
name|AUTH
operator|&&
operator|(
operator|!
name|res_authokay
operator|||
name|res_keyid
operator|!=
name|ctl_auth_keyid
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
name|cc
operator|->
name|handler
call|)
argument_list|(
name|rbufp
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Can't find this one, return an error. 	 */
name|numctlbadop
operator|++
expr_stmt|;
name|ctl_error
argument_list|(
name|CERR_BADOP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ctlpeerstatus - return a status word for this peer  */
end_comment

begin_function
name|u_short
name|ctlpeerstatus
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|u_short
name|status
decl_stmt|;
name|status
operator|=
name|peer
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|status
operator||=
name|CTL_PST_CONFIG
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
name|status
operator||=
name|CTL_PST_AUTHENABLE
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENTIC
condition|)
name|status
operator||=
name|CTL_PST_AUTHENTIC
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|!=
literal|0
condition|)
name|status
operator||=
name|CTL_PST_REACH
expr_stmt|;
return|return
operator|(
name|u_short
operator|)
name|CTL_PEER_STATUS
argument_list|(
name|status
argument_list|,
name|peer
operator|->
name|num_events
argument_list|,
name|peer
operator|->
name|last_event
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctlclkstatus - return a status word for this clock  */
end_comment

begin_function
specifier|static
name|u_short
name|ctlclkstatus
parameter_list|(
name|struct
name|refclockstat
modifier|*
name|this_clock
parameter_list|)
block|{
return|return
operator|(
call|(
name|u_short
call|)
argument_list|(
name|this_clock
operator|->
name|currentstatus
argument_list|)
operator|<<
literal|8
operator|)
operator||
call|(
name|u_short
call|)
argument_list|(
name|this_clock
operator|->
name|lastevent
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctlsysstatus - return the system status word  */
end_comment

begin_function
name|u_short
name|ctlsysstatus
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|u_char
name|this_clock
decl_stmt|;
name|this_clock
operator|=
name|CTL_SST_TS_UNSPEC
expr_stmt|;
if|if
condition|(
name|sys_peer
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sys_peer
operator|->
name|sstclktype
operator|!=
name|CTL_SST_TS_UNSPEC
condition|)
block|{
name|this_clock
operator|=
name|sys_peer
operator|->
name|sstclktype
expr_stmt|;
if|if
condition|(
name|pps_control
condition|)
name|this_clock
operator||=
name|CTL_SST_TS_PPS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sys_peer
operator|->
name|refclktype
operator|<
sizeof|sizeof
argument_list|(
name|clocktypes
argument_list|)
condition|)
name|this_clock
operator|=
name|clocktypes
index|[
name|sys_peer
operator|->
name|refclktype
index|]
expr_stmt|;
if|if
condition|(
name|pps_control
condition|)
name|this_clock
operator||=
name|CTL_SST_TS_PPS
expr_stmt|;
block|}
block|}
return|return
operator|(
name|u_short
operator|)
name|CTL_SYS_STATUS
argument_list|(
name|sys_leap
argument_list|,
name|this_clock
argument_list|,
name|ctl_sys_num_events
argument_list|,
name|ctl_sys_last_event
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctl_flushpkt - write out the current packet and prepare  *		  another if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_flushpkt
parameter_list|(
name|int
name|more
parameter_list|)
block|{
name|int
name|dlen
decl_stmt|;
name|int
name|sendlen
decl_stmt|;
if|if
condition|(
operator|!
name|more
operator|&&
name|datanotbinflag
condition|)
block|{
comment|/* 		 * Big hack, output a trailing \r\n 		 */
operator|*
name|datapt
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|datapt
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
name|dlen
operator|=
name|datapt
operator|-
operator|(
name|u_char
operator|*
operator|)
name|rpkt
operator|.
name|data
expr_stmt|;
name|sendlen
operator|=
name|dlen
operator|+
name|CTL_HEADER_LEN
expr_stmt|;
comment|/* 	 * Pad to a multiple of 32 bits 	 */
while|while
condition|(
name|sendlen
operator|&
literal|0x3
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sendlen
operator|++
expr_stmt|;
block|}
comment|/* 	 * Fill in the packet with the current info 	 */
name|rpkt
operator|.
name|r_m_e_op
operator|=
call|(
name|u_char
call|)
argument_list|(
name|CTL_RESPONSE
operator||
name|more
operator||
operator|(
name|res_opcode
operator|&
name|CTL_OP_MASK
operator|)
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|count
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|dlen
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|offset
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|res_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_async
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAXTRAPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_flags
operator|&
name|TRAP_INUSE
condition|)
block|{
name|rpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_version
argument_list|,
name|MODE_CONTROL
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|sequence
operator|=
name|htons
argument_list|(
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_sequence
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_addr
argument_list|,
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_localaddr
argument_list|,
operator|-
literal|4
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|more
condition|)
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_sequence
operator|++
expr_stmt|;
name|numasyncmsgs
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|res_authenticate
operator|&&
name|sys_authenticate
condition|)
block|{
name|int
name|maclen
decl_stmt|;
name|int
name|totlen
init|=
name|sendlen
decl_stmt|;
name|keyid_t
name|keyid
init|=
name|htonl
argument_list|(
name|res_keyid
argument_list|)
decl_stmt|;
comment|/* 			 * If we are going to authenticate, then there 			 * is an additional requirement that the MAC 			 * begin on a 64 bit boundary. 			 */
while|while
condition|(
name|totlen
operator|&
literal|7
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|totlen
operator|++
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|datapt
argument_list|,
operator|&
name|keyid
argument_list|,
sizeof|sizeof
name|keyid
argument_list|)
expr_stmt|;
name|maclen
operator|=
name|authencrypt
argument_list|(
name|res_keyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|-
literal|5
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|totlen
operator|+
name|maclen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|-
literal|6
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|more
condition|)
name|numctlfrags
operator|++
expr_stmt|;
else|else
name|numctlresponses
operator|++
expr_stmt|;
block|}
comment|/* 	 * Set us up for another go around. 	 */
name|res_offset
operator|+=
name|dlen
expr_stmt|;
name|datapt
operator|=
operator|(
name|u_char
operator|*
operator|)
name|rpkt
operator|.
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putdata - write data into the packet, fragmenting and starting  * another if this one is full.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putdata
parameter_list|(
specifier|const
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|int
name|dlen
parameter_list|,
name|int
name|bin
comment|/* set to 1 when data is binary */
parameter_list|)
block|{
name|int
name|overhead
decl_stmt|;
name|overhead
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bin
condition|)
block|{
name|datanotbinflag
operator|=
literal|1
expr_stmt|;
name|overhead
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|datapt
operator|!=
name|rpkt
operator|.
name|data
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|','
expr_stmt|;
name|datalinelen
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dlen
operator|+
name|datalinelen
operator|+
literal|1
operator|)
operator|>=
name|MAXDATALINELEN
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|datapt
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|datalinelen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|datapt
operator|++
operator|=
literal|' '
expr_stmt|;
name|datalinelen
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Save room for trailing junk 	 */
if|if
condition|(
name|dlen
operator|+
name|overhead
operator|+
name|datapt
operator|>
name|dataend
condition|)
block|{
comment|/* 		 * Not enough room in this one, flush it out. 		 */
name|ctl_flushpkt
argument_list|(
name|CTL_MORE
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|datapt
argument_list|,
name|dp
argument_list|,
operator|(
name|unsigned
operator|)
name|dlen
argument_list|)
expr_stmt|;
name|datapt
operator|+=
name|dlen
expr_stmt|;
name|datalinelen
operator|+=
name|dlen
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putstr - write a tagged string into the response packet  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putstr
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|400
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'"'
expr_stmt|;
if|if
condition|(
name|len
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|-
literal|1
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'"'
expr_stmt|;
block|}
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putdbl - write a tagged, signed double into the response packet  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putdbl
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|double
name|ts
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%.3f"
argument_list|,
name|ts
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putuint - write a tagged unsigned integer into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putuint
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|u_long
name|uval
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%lu"
argument_list|,
name|uval
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_puthex - write a tagged unsigned integer, in hex, into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_puthex
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|u_long
name|uval
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"0x%lx"
argument_list|,
name|uval
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putint - write a tagged signed integer into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putint
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|long
name|ival
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%ld"
argument_list|,
name|ival
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putts - write a tagged timestamp, in hex, into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putts
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|l_fp
modifier|*
name|ts
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"0x%08lx.%08lx"
argument_list|,
name|ts
operator|->
name|l_ui
operator|&
literal|0xffffffffL
argument_list|,
name|ts
operator|->
name|l_uf
operator|&
literal|0xffffffffL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putadr - write a dotted quad IP address into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putadr
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|u_int32
name|addr
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|cq
operator|=
name|numtoa
argument_list|(
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putid - write a tagged clock ID into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putid
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|char
modifier|*
name|id
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|cq
operator|=
name|id
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
operator|&&
operator|(
name|cq
operator|-
name|id
operator|)
operator|<
literal|4
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putarray - write a tagged eight element double array into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putarray
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|double
modifier|*
name|arr
parameter_list|,
name|int
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
do|do
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|NTP_SHIFT
expr_stmt|;
name|i
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" %.2f"
argument_list|,
name|arr
index|[
name|i
index|]
operator|*
literal|1e3
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|start
condition|)
do|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putsys - output a system variable  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putsys
parameter_list|(
name|int
name|varid
parameter_list|)
block|{
name|l_fp
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_UNAME
name|char
name|str
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|varid
condition|)
block|{
case|case
name|CS_LEAP
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_LEAP
index|]
operator|.
name|text
argument_list|,
name|sys_leap
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_STRATUM
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_STRATUM
index|]
operator|.
name|text
argument_list|,
name|sys_stratum
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PRECISION
case|:
name|ctl_putint
argument_list|(
name|sys_var
index|[
name|CS_PRECISION
index|]
operator|.
name|text
argument_list|,
name|sys_precision
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_ROOTDELAY
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_ROOTDELAY
index|]
operator|.
name|text
argument_list|,
name|sys_rootdelay
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_ROOTDISPERSION
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_ROOTDISPERSION
index|]
operator|.
name|text
argument_list|,
name|sys_rootdispersion
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_REFID
case|:
if|if
condition|(
name|sys_stratum
operator|>
literal|1
condition|)
name|ctl_putadr
argument_list|(
name|sys_var
index|[
name|CS_REFID
index|]
operator|.
name|text
argument_list|,
name|sys_refid
argument_list|)
expr_stmt|;
else|else
name|ctl_putid
argument_list|(
name|sys_var
index|[
name|CS_REFID
index|]
operator|.
name|text
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sys_refid
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_REFTIME
case|:
name|ctl_putts
argument_list|(
name|sys_var
index|[
name|CS_REFTIME
index|]
operator|.
name|text
argument_list|,
operator|&
name|sys_reftime
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_POLL
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_POLL
index|]
operator|.
name|text
argument_list|,
name|sys_poll
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PEERID
case|:
if|if
condition|(
name|sys_peer
operator|==
name|NULL
condition|)
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_PEERID
index|]
operator|.
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_PEERID
index|]
operator|.
name|text
argument_list|,
name|sys_peer
operator|->
name|associd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_STATE
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_STATE
index|]
operator|.
name|text
argument_list|,
operator|(
name|unsigned
operator|)
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_OFFSET
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_OFFSET
index|]
operator|.
name|text
argument_list|,
name|last_offset
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_DRIFT
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_DRIFT
index|]
operator|.
name|text
argument_list|,
name|drift_comp
operator|*
literal|1e6
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_JITTER
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_JITTER
index|]
operator|.
name|text
argument_list|,
name|sys_jitter
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_CLOCK
case|:
name|get_systime
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|ctl_putts
argument_list|(
name|sys_var
index|[
name|CS_CLOCK
index|]
operator|.
name|text
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PROCESSOR
case|:
ifndef|#
directive|ifndef
name|HAVE_UNAME
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_PROCESSOR
index|]
operator|.
name|text
argument_list|,
name|str_processor
argument_list|,
sizeof|sizeof
argument_list|(
name|str_processor
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_PROCESSOR
index|]
operator|.
name|text
argument_list|,
name|utsnamebuf
operator|.
name|machine
argument_list|,
name|strlen
argument_list|(
name|utsnamebuf
operator|.
name|machine
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_UNAME */
break|break;
case|case
name|CS_SYSTEM
case|:
ifndef|#
directive|ifndef
name|HAVE_UNAME
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_SYSTEM
index|]
operator|.
name|text
argument_list|,
name|str_system
argument_list|,
sizeof|sizeof
argument_list|(
name|str_system
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
name|utsnamebuf
operator|.
name|sysname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str
argument_list|,
name|utsnamebuf
operator|.
name|release
argument_list|)
expr_stmt|;
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_SYSTEM
index|]
operator|.
name|text
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_UNAME */
break|break;
case|case
name|CS_VERSION
case|:
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_VERSION
index|]
operator|.
name|text
argument_list|,
name|Version
argument_list|,
name|strlen
argument_list|(
name|Version
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_STABIL
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_STABIL
index|]
operator|.
name|text
argument_list|,
name|clock_stability
operator|*
literal|1e6
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_VARLIST
case|:
block|{
name|char
name|buf
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|be
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|ss
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
name|be
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|strlen
argument_list|(
name|sys_var
index|[
name|CS_VARLIST
index|]
operator|.
name|text
argument_list|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|be
condition|)
break|break;
comment|/* really long var name */
name|strcpy
argument_list|(
name|s
argument_list|,
name|sys_var
index|[
name|CS_VARLIST
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
literal|"=\""
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
for|for
control|(
name|k
operator|=
name|sys_var
init|;
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|i
operator|=
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|ext_sys_var
init|;
name|k
operator|&&
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|ss
operator|=
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
continue|continue;
while|while
condition|(
operator|*
name|ss
operator|&&
operator|*
name|ss
operator|!=
literal|'='
condition|)
name|ss
operator|++
expr_stmt|;
name|i
operator|=
name|ss
operator|-
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|strncpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|+
literal|2
operator|>=
name|be
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buf
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|-
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|PUBKEY
case|case
name|CS_FLAGS
case|:
if|if
condition|(
name|crypto_flags
condition|)
name|ctl_puthex
argument_list|(
name|sys_var
index|[
name|CS_FLAGS
index|]
operator|.
name|text
argument_list|,
name|crypto_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_HOST
case|:
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_HOST
index|]
operator|.
name|text
argument_list|,
name|sys_hostname
argument_list|,
name|strlen
argument_list|(
name|sys_hostname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|.
name|fstamp
operator|!=
literal|0
condition|)
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_PUBLIC
index|]
operator|.
name|text
argument_list|,
name|ntohl
argument_list|(
name|host
operator|.
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_CERTIF
case|:
if|if
condition|(
name|certif
operator|.
name|fstamp
operator|!=
literal|0
condition|)
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_CERTIF
index|]
operator|.
name|text
argument_list|,
name|ntohl
argument_list|(
name|certif
operator|.
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_DHPARAMS
case|:
if|if
condition|(
name|dhparam
operator|.
name|fstamp
operator|!=
literal|0
condition|)
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_DHPARAMS
index|]
operator|.
name|text
argument_list|,
name|ntohl
argument_list|(
name|dhparam
operator|.
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_REVTIME
case|:
if|if
condition|(
name|host
operator|.
name|tstamp
operator|!=
literal|0
condition|)
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_REVTIME
index|]
operator|.
name|text
argument_list|,
name|ntohl
argument_list|(
name|host
operator|.
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_LEAPTAB
case|:
if|if
condition|(
name|tai_leap
operator|.
name|fstamp
operator|!=
literal|0
condition|)
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_LEAPTAB
index|]
operator|.
name|text
argument_list|,
name|ntohl
argument_list|(
name|tai_leap
operator|.
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_tai
operator|!=
literal|0
condition|)
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_TAI
index|]
operator|.
name|text
argument_list|,
name|sys_tai
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PUBKEY */
block|}
block|}
end_function

begin_comment
comment|/*  * ctl_putpeer - output a peer variable  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putpeer
parameter_list|(
name|int
name|varid
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
switch|switch
condition|(
name|varid
condition|)
block|{
case|case
name|CP_CONFIG
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_CONFIG
index|]
operator|.
name|text
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_AUTHENABLE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_AUTHENABLE
index|]
operator|.
name|text
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|)
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_AUTHENTIC
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_AUTHENTIC
index|]
operator|.
name|text
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENTIC
operator|)
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SRCADR
case|:
name|ctl_putadr
argument_list|(
name|peer_var
index|[
name|CP_SRCADR
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SRCPORT
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_SRCPORT
index|]
operator|.
name|text
argument_list|,
name|ntohs
argument_list|(
name|peer
operator|->
name|srcadr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DSTADR
case|:
name|ctl_putadr
argument_list|(
name|peer_var
index|[
name|CP_DSTADR
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DSTPORT
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_DSTPORT
index|]
operator|.
name|text
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|peer
operator|->
name|dstadr
condition|?
name|ntohs
argument_list|(
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_port
argument_list|)
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_LEAP
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_LEAP
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|leap
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_HMODE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_HMODE
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_STRATUM
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_STRATUM
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|stratum
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_PPOLL
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_PPOLL
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|ppoll
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_HPOLL
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_HPOLL
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_PRECISION
case|:
name|ctl_putint
argument_list|(
name|peer_var
index|[
name|CP_PRECISION
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|precision
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ROOTDELAY
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|CP_ROOTDELAY
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|rootdelay
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ROOTDISPERSION
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|CP_ROOTDISPERSION
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|rootdispersion
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REFID
case|:
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|ctl_putadr
argument_list|(
name|peer_var
index|[
name|CP_REFID
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
else|else
name|ctl_putadr
argument_list|(
name|peer_var
index|[
name|CP_REFID
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|refid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_putid
argument_list|(
name|peer_var
index|[
name|CP_REFID
index|]
operator|.
name|text
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CP_REFTIME
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|CP_REFTIME
index|]
operator|.
name|text
argument_list|,
operator|&
name|peer
operator|->
name|reftime
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ORG
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|CP_ORG
index|]
operator|.
name|text
argument_list|,
operator|&
name|peer
operator|->
name|org
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REC
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|CP_REC
index|]
operator|.
name|text
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_XMT
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|CP_XMT
index|]
operator|.
name|text
argument_list|,
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REACH
case|:
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|CP_REACH
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|reach
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FLASH
case|:
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|CP_FLASH
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_TTL
case|:
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_ACAST
operator|)
condition|)
break|break;
name|ctl_putint
argument_list|(
name|peer_var
index|[
name|CP_TTL
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|ttl
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_TTLMAX
case|:
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|cast_flags
operator|&
operator|(
name|MDF_MCAST
operator||
name|MDF_ACAST
operator|)
operator|)
condition|)
break|break;
name|ctl_putint
argument_list|(
name|peer_var
index|[
name|CP_TTLMAX
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|ttlmax
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_VALID
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_VALID
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|unreach
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_TIMER
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_TIMER
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|nextdate
operator|-
name|current_time
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DELAY
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|CP_DELAY
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|delay
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_OFFSET
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|CP_OFFSET
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|offset
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_JITTER
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|CP_JITTER
index|]
operator|.
name|text
argument_list|,
name|SQRT
argument_list|(
name|peer
operator|->
name|jitter
argument_list|)
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DISPERSION
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|CP_DISPERSION
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|disp
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_KEYID
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_KEYID
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|keyid
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FILTDELAY
case|:
name|ctl_putarray
argument_list|(
name|peer_var
index|[
name|CP_FILTDELAY
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|filter_delay
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FILTOFFSET
case|:
name|ctl_putarray
argument_list|(
name|peer_var
index|[
name|CP_FILTOFFSET
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|filter_offset
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FILTERROR
case|:
name|ctl_putarray
argument_list|(
name|peer_var
index|[
name|CP_FILTERROR
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|filter_disp
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_PMODE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_PMODE
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|pmode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_RECEIVED
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_RECEIVED
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|received
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SENT
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_SENT
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|sent
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_VARLIST
case|:
block|{
name|char
name|buf
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|be
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
name|be
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|strlen
argument_list|(
name|peer_var
index|[
name|CP_VARLIST
index|]
operator|.
name|text
argument_list|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|be
condition|)
break|break;
comment|/* really long var name */
name|strcpy
argument_list|(
name|s
argument_list|,
name|peer_var
index|[
name|CP_VARLIST
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
literal|"=\""
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
for|for
control|(
name|k
operator|=
name|peer_var
init|;
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|i
operator|=
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|+
literal|2
operator|>=
name|be
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buf
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|-
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|PUBKEY
case|case
name|CP_FLAGS
case|:
if|if
condition|(
name|peer
operator|->
name|crypto
condition|)
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|CP_FLAGS
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|crypto
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_HOST
case|:
if|if
condition|(
name|peer
operator|->
name|keystr
operator|!=
name|NULL
condition|)
name|ctl_putstr
argument_list|(
name|peer_var
index|[
name|CP_HOST
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|keystr
argument_list|,
name|strlen
argument_list|(
name|peer
operator|->
name|keystr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|pubkey
operator|.
name|fstamp
operator|!=
literal|0
condition|)
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_PUBLIC
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|pubkey
operator|.
name|fstamp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_CERTIF
case|:
if|if
condition|(
name|peer
operator|->
name|certif
operator|.
name|fstamp
operator|!=
literal|0
condition|)
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_CERTIF
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|certif
operator|.
name|fstamp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SESKEY
case|:
if|if
condition|(
name|peer
operator|->
name|pcookie
operator|.
name|key
operator|!=
literal|0
condition|)
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|CP_SESKEY
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|pcookie
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hcookie
operator|!=
literal|0
condition|)
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|CP_SASKEY
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|hcookie
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_INITSEQ
case|:
if|if
condition|(
name|peer
operator|->
name|recauto
operator|.
name|key
operator|==
literal|0
condition|)
break|break;
name|ctl_putint
argument_list|(
name|peer_var
index|[
name|CP_INITSEQ
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|recauto
operator|.
name|seq
argument_list|)
expr_stmt|;
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|CP_INITKEY
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|recauto
operator|.
name|key
argument_list|)
expr_stmt|;
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_INITTSP
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|recauto
operator|.
name|tstamp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PUBKEY */
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * ctl_putclock - output clock variables  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putclock
parameter_list|(
name|int
name|varid
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|clock_stat
parameter_list|,
name|int
name|mustput
parameter_list|)
block|{
switch|switch
condition|(
name|varid
condition|)
block|{
case|case
name|CC_TYPE
case|:
if|if
condition|(
name|mustput
operator|||
name|clock_stat
operator|->
name|clockdesc
operator|==
name|NULL
operator|||
operator|*
operator|(
name|clock_stat
operator|->
name|clockdesc
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_TYPE
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_TIMECODE
case|:
name|ctl_putstr
argument_list|(
name|clock_var
index|[
name|CC_TIMECODE
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|p_lastcode
argument_list|,
operator|(
name|unsigned
operator|)
name|clock_stat
operator|->
name|lencode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_POLL
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_POLL
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|polls
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_NOREPLY
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_NOREPLY
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|noresponse
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_BADFORMAT
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_BADFORMAT
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|badformat
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_BADDATA
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_BADDATA
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|baddata
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGETIME1
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|clock_stat
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
operator|)
condition|)
name|ctl_putdbl
argument_list|(
name|clock_var
index|[
name|CC_FUDGETIME1
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|fudgetime1
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGETIME2
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|clock_stat
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME2
operator|)
condition|)
name|ctl_putdbl
argument_list|(
name|clock_var
index|[
name|CC_FUDGETIME2
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|fudgetime2
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGEVAL1
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|clock_stat
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
operator|)
condition|)
name|ctl_putint
argument_list|(
name|clock_var
index|[
name|CC_FUDGEVAL1
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|fudgeval1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGEVAL2
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|clock_stat
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL2
operator|)
condition|)
block|{
if|if
condition|(
name|clock_stat
operator|->
name|fudgeval1
operator|>
literal|1
condition|)
name|ctl_putadr
argument_list|(
name|clock_var
index|[
name|CC_FUDGEVAL2
index|]
operator|.
name|text
argument_list|,
operator|(
name|u_int32
operator|)
name|clock_stat
operator|->
name|fudgeval2
argument_list|)
expr_stmt|;
else|else
name|ctl_putid
argument_list|(
name|clock_var
index|[
name|CC_FUDGEVAL2
index|]
operator|.
name|text
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|clock_stat
operator|->
name|fudgeval2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_FLAGS
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|clock_stat
operator|->
name|haveflags
operator|&
operator|(
name|CLK_HAVEFLAG1
operator||
name|CLK_HAVEFLAG2
operator||
name|CLK_HAVEFLAG3
operator||
name|CLK_HAVEFLAG4
operator|)
operator|)
condition|)
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_FLAGS
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_DEVICE
case|:
if|if
condition|(
name|clock_stat
operator|->
name|clockdesc
operator|==
name|NULL
operator|||
operator|*
operator|(
name|clock_stat
operator|->
name|clockdesc
operator|)
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mustput
condition|)
name|ctl_putstr
argument_list|(
name|clock_var
index|[
name|CC_DEVICE
index|]
operator|.
name|text
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_putstr
argument_list|(
name|clock_var
index|[
name|CC_DEVICE
index|]
operator|.
name|text
argument_list|,
name|clock_stat
operator|->
name|clockdesc
argument_list|,
name|strlen
argument_list|(
name|clock_stat
operator|->
name|clockdesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_VARLIST
case|:
block|{
name|char
name|buf
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|be
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|ss
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
name|be
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|strlen
argument_list|(
name|clock_var
index|[
name|CC_VARLIST
index|]
operator|.
name|text
argument_list|)
operator|+
literal|4
operator|>
name|be
condition|)
break|break;
comment|/* really long var name */
name|strcpy
argument_list|(
name|s
argument_list|,
name|clock_var
index|[
name|CC_VARLIST
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
literal|"=\""
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
for|for
control|(
name|k
operator|=
name|clock_var
init|;
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|i
operator|=
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|clock_stat
operator|->
name|kv_list
init|;
name|k
operator|&&
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|ss
operator|=
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
continue|continue;
while|while
condition|(
operator|*
name|ss
operator|&&
operator|*
name|ss
operator|!=
literal|'='
condition|)
name|ss
operator|++
expr_stmt|;
name|i
operator|=
name|ss
operator|-
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|strncpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|+
literal|2
operator|>=
name|be
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buf
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|-
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ctl_getitem - get the next data item from the incoming packet  */
end_comment

begin_function
specifier|static
name|struct
name|ctl_var
modifier|*
name|ctl_getitem
parameter_list|(
name|struct
name|ctl_var
modifier|*
name|var_list
parameter_list|,
name|char
modifier|*
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|static
name|struct
name|ctl_var
name|eol
init|=
block|{
literal|0
block|,
name|EOV
block|, }
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* 	 * Delete leading commas and white space 	 */
while|while
condition|(
name|reqpt
operator|<
name|reqend
operator|&&
operator|(
operator|*
name|reqpt
operator|==
literal|','
operator|||
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|reqpt
argument_list|)
operator|)
condition|)
name|reqpt
operator|++
expr_stmt|;
if|if
condition|(
name|reqpt
operator|>=
name|reqend
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|var_list
operator|==
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
operator|&
name|eol
operator|)
return|;
comment|/* 	 * Look for a first character match on the tag.  If we find 	 * one, see if it is a full match. 	 */
name|v
operator|=
name|var_list
expr_stmt|;
name|cp
operator|=
name|reqpt
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|PADDING
operator|)
operator|&&
operator|*
name|cp
operator|==
operator|*
operator|(
name|v
operator|->
name|text
operator|)
condition|)
block|{
name|tp
operator|=
name|v
operator|->
name|text
expr_stmt|;
while|while
condition|(
operator|*
name|tp
operator|!=
literal|'\0'
operator|&&
operator|*
name|tp
operator|!=
literal|'='
operator|&&
name|cp
operator|<
name|reqend
operator|&&
operator|*
name|cp
operator|==
operator|*
name|tp
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|tp
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|tp
operator|==
literal|'='
operator|)
condition|)
block|{
while|while
condition|(
name|cp
operator|<
name|reqend
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|reqend
operator|||
operator|*
name|cp
operator|==
literal|','
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|data
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|reqend
condition|)
name|cp
operator|++
expr_stmt|;
name|reqpt
operator|=
name|cp
expr_stmt|;
return|return
name|v
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|tp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|reqend
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|reqend
operator|&&
operator|*
name|cp
operator|!=
literal|','
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|>=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cp
operator|<
name|reqend
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|tp
operator|--
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|tp
operator|>
name|buf
condition|)
block|{
operator|*
name|tp
operator|--
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|reqpt
operator|=
name|cp
expr_stmt|;
operator|*
name|data
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
block|}
name|cp
operator|=
name|reqpt
expr_stmt|;
block|}
name|v
operator|++
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * control_unspec - response to an unspecified op-code  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|control_unspec
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* 	 * What is an appropriate response to an unspecified op-code? 	 * I return no errors and no data, unless a specified assocation 	 * doesn't exist. 	 */
if|if
condition|(
name|res_associd
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|res_associd
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read_status - return either a list of associd's, or a particular  * peer's status.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|read_status
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|u_short
name|ass_stat
index|[
name|CTL_MAX_DATA_LEN
operator|/
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"read_status: ID %d\n"
argument_list|,
name|res_associd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Two choices here. If the specified association ID is 	 * zero we return all known assocation ID's.  Otherwise 	 * we return a bunch of stuff about the particular peer. 	 */
if|if
condition|(
name|res_associd
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|assoc_hash
index|[
name|i
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|peer
operator|->
name|ass_next
control|)
block|{
name|ass_stat
index|[
name|n
operator|++
index|]
operator|=
name|htons
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
name|ass_stat
index|[
name|n
operator|++
index|]
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|CTL_MAX_DATA_LEN
operator|/
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
name|ctl_putdata
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ass_stat
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|ctl_putdata
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ass_stat
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|res_associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_authokay
condition|)
name|peer
operator|->
name|num_events
operator|=
literal|0
expr_stmt|;
comment|/* 			 * For now, output everything we know about the 			 * peer. May be more selective later. 			 */
for|for
control|(
name|cp
operator|=
name|def_peer_var
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
name|ctl_putpeer
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * read_variables - return the variables the caller asks for  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|read_variables
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
specifier|register
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|valuep
decl_stmt|;
name|u_char
modifier|*
name|wants
decl_stmt|;
name|unsigned
name|int
name|gotvar
init|=
operator|(
name|CS_MAXCODE
operator|>
name|CP_MAXCODE
operator|)
condition|?
operator|(
name|CS_MAXCODE
operator|+
literal|1
operator|)
else|:
operator|(
name|CP_MAXCODE
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|res_associd
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Wants system variables. Figure out which he wants 		 * and give them to him. 		 */
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_authokay
condition|)
name|ctl_sys_num_events
operator|=
literal|0
expr_stmt|;
name|gotvar
operator|+=
name|count_var
argument_list|(
name|ext_sys_var
argument_list|)
expr_stmt|;
name|wants
operator|=
operator|(
name|u_char
operator|*
operator|)
name|emalloc
argument_list|(
name|gotvar
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|,
literal|0
argument_list|,
name|gotvar
argument_list|)
expr_stmt|;
name|gotvar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|ext_sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
return|return;
block|}
name|wants
index|[
name|CS_MAXCODE
operator|+
literal|1
operator|+
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
block|{
break|break;
comment|/* shouldn't happen ! */
block|}
block|}
name|wants
index|[
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gotvar
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CS_MAXCODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
index|]
condition|)
name|ctl_putsys
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ext_sys_var
operator|&&
operator|!
operator|(
name|ext_sys_var
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|EOV
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
operator|+
name|CS_MAXCODE
operator|+
literal|1
index|]
condition|)
name|ctl_putdata
argument_list|(
name|ext_sys_var
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|strlen
argument_list|(
name|ext_sys_var
index|[
name|i
index|]
operator|.
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|u_char
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
for|for
control|(
name|cs
operator|=
name|def_sys_var
init|;
operator|*
name|cs
operator|!=
literal|0
condition|;
name|cs
operator|++
control|)
name|ctl_putsys
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cs
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|ext_sys_var
init|;
name|kv
operator|&&
operator|!
operator|(
name|kv
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|kv
operator|->
name|flags
operator|&
name|DEF
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* 		 * Wants info for a particular peer. See if we know 		 * the guy. 		 */
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|res_associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_authokay
condition|)
name|peer
operator|->
name|num_events
operator|=
literal|0
expr_stmt|;
name|wants
operator|=
operator|(
name|u_char
operator|*
operator|)
name|emalloc
argument_list|(
name|gotvar
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|,
literal|0
argument_list|,
name|gotvar
argument_list|)
expr_stmt|;
name|gotvar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|peer_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
return|return;
block|}
name|wants
index|[
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gotvar
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CP_MAXCODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
index|]
condition|)
name|ctl_putpeer
argument_list|(
name|i
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|def_peer_var
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
name|ctl_putpeer
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
block|}
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * write_variables - write into variables. We only allow leap bit  * writing this way.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|write_variables
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
specifier|register
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
specifier|register
name|int
name|ext_var
decl_stmt|;
name|char
modifier|*
name|valuep
decl_stmt|;
name|long
name|val
decl_stmt|;
comment|/* 	 * If he's trying to write into a peer tell him no way 	 */
if|if
condition|(
name|res_associd
operator|!=
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set status 	 */
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * Look through the variables. Dump out at the first sign of 	 * trouble. 	 */
while|while
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ext_var
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|ext_sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
return|return;
block|}
name|ext_var
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|CAN_WRITE
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ext_var
operator|&&
operator|(
operator|*
name|valuep
operator|==
literal|'\0'
operator|||
operator|!
name|atoint
argument_list|(
name|valuep
argument_list|,
operator|&
name|val
argument_list|)
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADFMT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ext_var
operator|&&
operator|(
name|val
operator|&
operator|~
name|LEAP_NOTINSYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADVALUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ext_var
condition|)
block|{
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|v
operator|->
name|text
argument_list|)
operator|+
name|strlen
argument_list|(
name|valuep
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|tt
init|=
name|s
decl_stmt|;
name|t
operator|=
name|v
operator|->
name|text
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|*
name|t
operator|!=
literal|'='
condition|)
operator|*
name|tt
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
operator|*
name|tt
operator|++
operator|=
literal|'='
expr_stmt|;
name|strcat
argument_list|(
name|tt
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
name|v
operator|->
name|flags
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This one seems sane. Save it. 			 */
switch|switch
condition|(
name|v
operator|->
name|code
condition|)
block|{
case|case
name|CS_LEAP
case|:
default|default:
name|ctl_error
argument_list|(
name|CERR_UNSPEC
argument_list|)
expr_stmt|;
comment|/* really */
return|return;
block|}
block|}
block|}
comment|/* 	 * If we got anything, do it. xxx nothing to do *** 	 */
comment|/* 	  if (leapind != ~0 || leapwarn != ~0) { 	  	if (!leap_setleap((int)leapind, (int)leapwarn)) { 	  		ctl_error(CERR_PERMISSION); 	  		return; 	  	} 	  } 	*/
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read_clock_status - return clock radio status  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|read_clock_status
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|REFCLOCK
comment|/* 	 * If no refclock support, no data to return 	 */
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|char
modifier|*
name|valuep
decl_stmt|;
name|u_char
modifier|*
name|wants
decl_stmt|;
name|unsigned
name|int
name|gotvar
decl_stmt|;
name|struct
name|refclockstat
name|clock_stat
decl_stmt|;
if|if
condition|(
name|res_associd
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Find a clock for this jerk.	If the system peer 		 * is a clock use it, else search the hash tables 		 * for one. 		 */
if|if
condition|(
name|sys_peer
operator|!=
literal|0
operator|&&
operator|(
name|sys_peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|)
condition|)
block|{
name|peer
operator|=
name|sys_peer
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|peer
operator|==
literal|0
operator|&&
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|assoc_hash
index|[
name|i
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|peer
operator|->
name|ass_next
control|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|res_associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
operator|||
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If we got here we have a peer which is a clock. Get his 	 * status. 	 */
name|clock_stat
operator|.
name|kv_list
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
name|refclock_control
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|clock_stat
argument_list|)
expr_stmt|;
comment|/* 	 * Look for variables in the packet. 	 */
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlclkstatus
argument_list|(
operator|&
name|clock_stat
argument_list|)
argument_list|)
expr_stmt|;
name|gotvar
operator|=
name|CC_MAXCODE
operator|+
literal|1
operator|+
name|count_var
argument_list|(
name|clock_stat
operator|.
name|kv_list
argument_list|)
expr_stmt|;
name|wants
operator|=
operator|(
name|u_char
operator|*
operator|)
name|emalloc
argument_list|(
name|gotvar
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|,
literal|0
argument_list|,
name|gotvar
argument_list|)
expr_stmt|;
name|gotvar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|clock_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|clock_stat
operator|.
name|kv_list
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|clock_stat
operator|.
name|kv_list
argument_list|)
expr_stmt|;
return|return;
block|}
name|wants
index|[
name|CC_MAXCODE
operator|+
literal|1
operator|+
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
block|{
break|break;
comment|/* shouldn't happen ! */
block|}
block|}
name|wants
index|[
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gotvar
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CC_MAXCODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
index|]
condition|)
name|ctl_putclock
argument_list|(
name|i
argument_list|,
operator|&
name|clock_stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|clock_stat
operator|.
name|kv_list
operator|&&
operator|!
operator|(
name|clock_stat
operator|.
name|kv_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|EOV
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
operator|+
name|CC_MAXCODE
operator|+
literal|1
index|]
condition|)
name|ctl_putdata
argument_list|(
name|clock_stat
operator|.
name|kv_list
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|strlen
argument_list|(
name|clock_stat
operator|.
name|kv_list
index|[
name|i
index|]
operator|.
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|u_char
modifier|*
name|cc
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
for|for
control|(
name|cc
operator|=
name|def_clock_var
init|;
operator|*
name|cc
operator|!=
literal|0
condition|;
name|cc
operator|++
control|)
name|ctl_putclock
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|,
operator|&
name|clock_stat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|clock_stat
operator|.
name|kv_list
init|;
name|kv
operator|&&
operator|!
operator|(
name|kv
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|kv
operator|->
name|flags
operator|&
name|DEF
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|clock_stat
operator|.
name|kv_list
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * write_clock_status - we don't do this  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|write_clock_status
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trap support from here on down. We send async trap messages when the  * upper levels report trouble. Traps can by set either by control  * messages or by configuration.  */
end_comment

begin_comment
comment|/*  * set_trap - set a trap in response to a control message  */
end_comment

begin_function
specifier|static
name|void
name|set_trap
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|int
name|traptype
decl_stmt|;
comment|/* 	 * See if this guy is allowed 	 */
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOTRAP
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Determine his allowed trap type. 	 */
name|traptype
operator|=
name|TRAP_TYPE_PRIO
expr_stmt|;
if|if
condition|(
name|restrict_mask
operator|&
name|RES_LPTRAP
condition|)
name|traptype
operator|=
name|TRAP_TYPE_NONPRIO
expr_stmt|;
comment|/* 	 * Call ctlsettrap() to do the work.  Return 	 * an error if it can't assign the trap. 	 */
if|if
condition|(
operator|!
name|ctlsettrap
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|traptype
argument_list|,
operator|(
name|int
operator|)
name|res_version
argument_list|)
condition|)
name|ctl_error
argument_list|(
name|CERR_NORESOURCE
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * unset_trap - unset a trap in response to a control message  */
end_comment

begin_function
specifier|static
name|void
name|unset_trap
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|int
name|traptype
decl_stmt|;
comment|/* 	 * We don't prevent anyone from removing his own trap unless the 	 * trap is configured. Note we also must be aware of the 	 * possibility that restriction flags were changed since this 	 * guy last set his trap. Set the trap type based on this. 	 */
name|traptype
operator|=
name|TRAP_TYPE_PRIO
expr_stmt|;
if|if
condition|(
name|restrict_mask
operator|&
name|RES_LPTRAP
condition|)
name|traptype
operator|=
name|TRAP_TYPE_NONPRIO
expr_stmt|;
comment|/* 	 * Call ctlclrtrap() to clear this out. 	 */
if|if
condition|(
operator|!
name|ctlclrtrap
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|traptype
argument_list|)
condition|)
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctlsettrap - called to set a trap  */
end_comment

begin_function
name|int
name|ctlsettrap
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|raddr
parameter_list|,
name|struct
name|interface
modifier|*
name|linter
parameter_list|,
name|int
name|traptype
parameter_list|,
name|int
name|version
parameter_list|)
block|{
specifier|register
name|struct
name|ctl_trap
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|ctl_trap
modifier|*
name|tptouse
decl_stmt|;
comment|/* 	 * See if we can find this trap.  If so, we only need update 	 * the flags and the time. 	 */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctlfindtrap
argument_list|(
name|raddr
argument_list|,
name|linter
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|traptype
condition|)
block|{
case|case
name|TRAP_TYPE_CONFIG
case|:
name|tp
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
operator||
name|TRAP_CONFIGURED
expr_stmt|;
break|break;
case|case
name|TRAP_TYPE_PRIO
case|:
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* don't change anything */
name|tp
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
expr_stmt|;
break|break;
case|case
name|TRAP_TYPE_NONPRIO
case|:
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* don't change anything */
name|tp
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
operator||
name|TRAP_NONPRIO
expr_stmt|;
break|break;
block|}
name|tp
operator|->
name|tr_settime
operator|=
name|current_time
expr_stmt|;
name|tp
operator|->
name|tr_resets
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * First we heard of this guy.	Try to find a trap structure 	 * for him to use, clearing out lesser priority guys if we 	 * have to. Clear out anyone who's expired while we're at it. 	 */
name|tptouse
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|ctl_trap
init|;
name|tp
operator|<
operator|&
name|ctl_trap
index|[
name|CTL_MAXTRAPS
index|]
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_INUSE
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|tr_settime
operator|+
name|CTL_TRAPTIME
operator|)
operator|>
name|current_time
operator|)
condition|)
block|{
name|tp
operator|->
name|tr_flags
operator|=
literal|0
expr_stmt|;
name|num_ctl_traps
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_INUSE
operator|)
condition|)
block|{
name|tptouse
operator|=
name|tp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
operator|)
condition|)
block|{
switch|switch
condition|(
name|traptype
condition|)
block|{
case|case
name|TRAP_TYPE_CONFIG
case|:
if|if
condition|(
name|tptouse
operator|==
name|NULL
condition|)
block|{
name|tptouse
operator|=
name|tp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tptouse
operator|->
name|tr_flags
operator|&
name|TRAP_NONPRIO
operator|&&
operator|!
operator|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_NONPRIO
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|tptouse
operator|->
name|tr_flags
operator|&
name|TRAP_NONPRIO
operator|)
operator|&&
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_NONPRIO
condition|)
block|{
name|tptouse
operator|=
name|tp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tptouse
operator|->
name|tr_origtime
operator|<
name|tp
operator|->
name|tr_origtime
condition|)
name|tptouse
operator|=
name|tp
expr_stmt|;
break|break;
case|case
name|TRAP_TYPE_PRIO
case|:
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_NONPRIO
condition|)
block|{
if|if
condition|(
name|tptouse
operator|==
name|NULL
operator|||
operator|(
name|tptouse
operator|->
name|tr_flags
operator|&
name|TRAP_INUSE
operator|&&
name|tptouse
operator|->
name|tr_origtime
operator|<
name|tp
operator|->
name|tr_origtime
operator|)
condition|)
name|tptouse
operator|=
name|tp
expr_stmt|;
block|}
break|break;
case|case
name|TRAP_TYPE_NONPRIO
case|:
break|break;
block|}
block|}
block|}
comment|/* 	 * If we don't have room for him return an error. 	 */
if|if
condition|(
name|tptouse
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Set up this structure for him. 	 */
name|tptouse
operator|->
name|tr_settime
operator|=
name|tptouse
operator|->
name|tr_origtime
operator|=
name|current_time
expr_stmt|;
name|tptouse
operator|->
name|tr_count
operator|=
name|tptouse
operator|->
name|tr_resets
operator|=
literal|0
expr_stmt|;
name|tptouse
operator|->
name|tr_sequence
operator|=
literal|1
expr_stmt|;
name|tptouse
operator|->
name|tr_addr
operator|=
operator|*
name|raddr
expr_stmt|;
name|tptouse
operator|->
name|tr_localaddr
operator|=
name|linter
expr_stmt|;
name|tptouse
operator|->
name|tr_version
operator|=
name|version
expr_stmt|;
name|tptouse
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
expr_stmt|;
if|if
condition|(
name|traptype
operator|==
name|TRAP_TYPE_CONFIG
condition|)
name|tptouse
operator|->
name|tr_flags
operator||=
name|TRAP_CONFIGURED
expr_stmt|;
elseif|else
if|if
condition|(
name|traptype
operator|==
name|TRAP_TYPE_NONPRIO
condition|)
name|tptouse
operator|->
name|tr_flags
operator||=
name|TRAP_NONPRIO
expr_stmt|;
name|num_ctl_traps
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctlclrtrap - called to clear a trap  */
end_comment

begin_function
name|int
name|ctlclrtrap
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|raddr
parameter_list|,
name|struct
name|interface
modifier|*
name|linter
parameter_list|,
name|int
name|traptype
parameter_list|)
block|{
specifier|register
name|struct
name|ctl_trap
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctlfindtrap
argument_list|(
name|raddr
argument_list|,
name|linter
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
operator|&&
name|traptype
operator|!=
name|TRAP_TYPE_CONFIG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tp
operator|->
name|tr_flags
operator|=
literal|0
expr_stmt|;
name|num_ctl_traps
operator|--
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctlfindtrap - find a trap given the remote and local addresses  */
end_comment

begin_function
specifier|static
name|struct
name|ctl_trap
modifier|*
name|ctlfindtrap
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|raddr
parameter_list|,
name|struct
name|interface
modifier|*
name|linter
parameter_list|)
block|{
specifier|register
name|struct
name|ctl_trap
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|ctl_trap
init|;
name|tp
operator|<
operator|&
name|ctl_trap
index|[
name|CTL_MAXTRAPS
index|]
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_INUSE
operator|&&
name|NSRCADR
argument_list|(
name|raddr
argument_list|)
operator|==
name|NSRCADR
argument_list|(
operator|&
name|tp
operator|->
name|tr_addr
argument_list|)
operator|&&
name|NSRCPORT
argument_list|(
name|raddr
argument_list|)
operator|==
name|NSRCPORT
argument_list|(
operator|&
name|tp
operator|->
name|tr_addr
argument_list|)
operator|&&
name|linter
operator|==
name|tp
operator|->
name|tr_localaddr
condition|)
return|return
operator|(
name|tp
operator|)
return|;
block|}
return|return
operator|(
expr|struct
name|ctl_trap
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * report_event - report an event to the trappers  */
end_comment

begin_function
name|void
name|report_event
parameter_list|(
name|int
name|err
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Record error code in proper spots, but have mercy on the 	 * log file. 	 */
if|if
condition|(
operator|!
operator|(
name|err
operator|&
name|PEER_EVENT
operator|)
condition|)
block|{
if|if
condition|(
name|ctl_sys_num_events
operator|<
name|CTL_SYS_MAXEVENTS
condition|)
name|ctl_sys_num_events
operator|++
expr_stmt|;
if|if
condition|(
name|ctl_sys_last_event
operator|!=
operator|(
name|u_char
operator|)
name|err
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"system event '%s' (0x%02x) status '%s' (0x%02x)"
argument_list|,
name|eventstr
argument_list|(
name|err
argument_list|)
argument_list|,
name|err
argument_list|,
name|sysstatstr
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
argument_list|,
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"report_event: system event '%s' (0x%02x) status '%s' (0x%02x)\n"
argument_list|,
name|eventstr
argument_list|(
name|err
argument_list|)
argument_list|,
name|err
argument_list|,
name|sysstatstr
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
argument_list|,
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_sys_last_event
operator|=
operator|(
name|u_char
operator|)
name|err
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|peer
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|src
decl_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
condition|)
name|src
operator|=
name|refnumtoa
argument_list|(
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|src
operator|=
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|peer
operator|->
name|last_event
operator|=
call|(
name|u_char
call|)
argument_list|(
name|err
operator|&
operator|~
name|PEER_EVENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|num_events
operator|<
name|CTL_PEER_MAXEVENTS
condition|)
name|peer
operator|->
name|num_events
operator|++
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_PEEREVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"peer %s event '%s' (0x%02x) status '%s' (0x%02x)"
argument_list|,
name|src
argument_list|,
name|eventstr
argument_list|(
name|err
argument_list|)
argument_list|,
name|err
argument_list|,
name|peerstatstr
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"peer %s event '%s' (0x%02x) status '%s' (0x%02x)\n"
argument_list|,
name|src
argument_list|,
name|eventstr
argument_list|(
name|err
argument_list|)
argument_list|,
name|err
argument_list|,
name|peerstatstr
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"report_event: err '%s' (0x%02x), no peer"
argument_list|,
name|eventstr
argument_list|(
name|err
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"report_event: peer event '%s' (0x%02x), no peer\n"
argument_list|,
name|eventstr
argument_list|(
name|err
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * If no trappers, return. 	 */
if|if
condition|(
name|num_ctl_traps
operator|<=
literal|0
condition|)
return|return;
comment|/* 	 * Set up the outgoing packet variables 	 */
name|res_opcode
operator|=
name|CTL_OP_ASYNCMSG
expr_stmt|;
name|res_offset
operator|=
literal|0
expr_stmt|;
name|res_async
operator|=
literal|1
expr_stmt|;
name|res_authenticate
operator|=
literal|0
expr_stmt|;
name|datapt
operator|=
name|rpkt
operator|.
name|data
expr_stmt|;
name|dataend
operator|=
operator|&
operator|(
name|rpkt
operator|.
name|data
index|[
name|CTL_MAX_DATA_LEN
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|err
operator|&
name|PEER_EVENT
operator|)
condition|)
block|{
name|rpkt
operator|.
name|associd
operator|=
literal|0
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 		 * For now, put everything we know about system 		 * variables. Don't send crypto strings. 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CS_MAXCODE
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|PUBKEY
if|if
condition|(
name|i
operator|>
name|CS_VARLIST
condition|)
continue|continue;
endif|#
directive|endif
comment|/* PUBKEY */
name|ctl_putsys
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 		 * for clock exception events: add clock variables to 		 * reflect info on exception 		 */
if|if
condition|(
name|err
operator|==
name|EVNT_CLOCKEXCPT
condition|)
block|{
name|struct
name|refclockstat
name|clock_stat
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
name|clock_stat
operator|.
name|kv_list
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
name|refclock_control
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|clock_stat
argument_list|)
expr_stmt|;
name|ctl_puthex
argument_list|(
literal|"refclockstatus"
argument_list|,
name|ctlclkstatus
argument_list|(
operator|&
name|clock_stat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CC_MAXCODE
condition|;
name|i
operator|++
control|)
name|ctl_putclock
argument_list|(
name|i
argument_list|,
operator|&
name|clock_stat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|clock_stat
operator|.
name|kv_list
init|;
name|kv
operator|&&
operator|!
operator|(
name|kv
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|kv
operator|->
name|flags
operator|&
name|DEF
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|clock_stat
operator|.
name|kv_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*REFCLOCK*/
block|}
else|else
block|{
name|rpkt
operator|.
name|associd
operator|=
name|htons
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Dump it all. Later, maybe less. 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CP_MAXCODE
condition|;
name|i
operator|++
control|)
ifdef|#
directive|ifdef
name|PUBKEY
if|if
condition|(
name|i
operator|>
name|CP_VARLIST
condition|)
continue|continue;
endif|#
directive|endif
comment|/* PUBKEY */
name|ctl_putpeer
argument_list|(
name|i
argument_list|,
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 		 * for clock exception events: add clock variables to 		 * reflect info on exception 		 */
if|if
condition|(
name|err
operator|==
name|EVNT_PEERCLOCK
condition|)
block|{
name|struct
name|refclockstat
name|clock_stat
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
name|clock_stat
operator|.
name|kv_list
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
name|refclock_control
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|clock_stat
argument_list|)
expr_stmt|;
name|ctl_puthex
argument_list|(
literal|"refclockstatus"
argument_list|,
name|ctlclkstatus
argument_list|(
operator|&
name|clock_stat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CC_MAXCODE
condition|;
name|i
operator|++
control|)
name|ctl_putclock
argument_list|(
name|i
argument_list|,
operator|&
name|clock_stat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|clock_stat
operator|.
name|kv_list
init|;
name|kv
operator|&&
operator|!
operator|(
name|kv
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|kv
operator|->
name|flags
operator|&
name|DEF
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|clock_stat
operator|.
name|kv_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*REFCLOCK*/
block|}
comment|/* 	 * We're done, return. 	 */
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_clr_stats - clear stat counters  */
end_comment

begin_function
name|void
name|ctl_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|ctltimereset
operator|=
name|current_time
expr_stmt|;
name|numctlreq
operator|=
literal|0
expr_stmt|;
name|numctlbadpkts
operator|=
literal|0
expr_stmt|;
name|numctlresponses
operator|=
literal|0
expr_stmt|;
name|numctlfrags
operator|=
literal|0
expr_stmt|;
name|numctlerrors
operator|=
literal|0
expr_stmt|;
name|numctlfrags
operator|=
literal|0
expr_stmt|;
name|numctltooshort
operator|=
literal|0
expr_stmt|;
name|numctlinputresp
operator|=
literal|0
expr_stmt|;
name|numctlinputfrag
operator|=
literal|0
expr_stmt|;
name|numctlinputerr
operator|=
literal|0
expr_stmt|;
name|numctlbadoffset
operator|=
literal|0
expr_stmt|;
name|numctlbadversion
operator|=
literal|0
expr_stmt|;
name|numctldatatooshort
operator|=
literal|0
expr_stmt|;
name|numctlbadop
operator|=
literal|0
expr_stmt|;
name|numasyncmsgs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|count_var
parameter_list|(
name|struct
name|ctl_var
modifier|*
name|k
parameter_list|)
block|{
specifier|register
name|u_long
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|k
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|k
operator|++
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|)
name|c
operator|++
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|add_var
parameter_list|(
name|struct
name|ctl_var
modifier|*
modifier|*
name|kv
parameter_list|,
name|u_long
name|size
parameter_list|,
name|int
name|def
parameter_list|)
block|{
specifier|register
name|u_long
name|c
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|c
operator|=
name|count_var
argument_list|(
operator|*
name|kv
argument_list|)
expr_stmt|;
name|k
operator|=
operator|*
name|kv
expr_stmt|;
operator|*
name|kv
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|c
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
condition|)
block|{
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|kv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|k
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_var
argument_list|)
operator|*
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|k
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|kv
operator|)
index|[
name|c
index|]
operator|.
name|code
operator|=
operator|(
name|u_short
operator|)
name|c
expr_stmt|;
operator|(
operator|*
name|kv
operator|)
index|[
name|c
index|]
operator|.
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
operator|(
operator|*
name|kv
operator|)
index|[
name|c
index|]
operator|.
name|flags
operator|=
name|def
expr_stmt|;
operator|(
operator|*
name|kv
operator|)
index|[
name|c
operator|+
literal|1
index|]
operator|.
name|code
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|kv
operator|)
index|[
name|c
operator|+
literal|1
index|]
operator|.
name|text
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
operator|*
name|kv
operator|)
index|[
name|c
operator|+
literal|1
index|]
operator|.
name|flags
operator|=
name|EOV
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|kv
operator|)
index|[
name|c
index|]
operator|.
name|text
return|;
block|}
end_function

begin_function
name|void
name|set_var
parameter_list|(
name|struct
name|ctl_var
modifier|*
modifier|*
name|kv
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|u_long
name|size
parameter_list|,
name|int
name|def
parameter_list|)
block|{
specifier|register
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|td
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|||
operator|!
name|size
condition|)
return|return;
if|if
condition|(
operator|(
name|k
operator|=
operator|*
name|kv
operator|)
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|)
block|{
name|s
operator|=
name|data
expr_stmt|;
name|t
operator|=
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
while|while
condition|(
operator|*
name|t
operator|!=
literal|'='
operator|&&
operator|*
name|s
operator|-
operator|*
name|t
operator|==
literal|0
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|t
operator|&&
operator|(
operator|(
operator|*
name|t
operator|==
literal|'='
operator|)
operator|||
operator|!
operator|*
name|t
operator|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|td
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|k
operator|->
name|text
operator|=
name|td
expr_stmt|;
name|k
operator|->
name|flags
operator|=
name|def
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|td
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|td
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|k
operator|->
name|text
operator|=
name|td
expr_stmt|;
name|k
operator|->
name|flags
operator|=
name|def
expr_stmt|;
return|return;
block|}
name|k
operator|++
expr_stmt|;
block|}
block|}
name|td
operator|=
name|add_var
argument_list|(
name|kv
argument_list|,
name|size
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|td
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_sys_var
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|u_long
name|size
parameter_list|,
name|int
name|def
parameter_list|)
block|{
name|set_var
argument_list|(
operator|&
name|ext_sys_var
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_varlist
parameter_list|(
name|struct
name|ctl_var
modifier|*
name|kv
parameter_list|)
block|{
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
if|if
condition|(
name|kv
condition|)
block|{
for|for
control|(
name|k
operator|=
name|kv
init|;
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

