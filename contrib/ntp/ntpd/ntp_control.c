begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_control.c - respond to mode 6 control messages and send async  *		   traps.  Provides service to ntpq and others.  */
end_comment

begin_comment
comment|/*  * $FreeBSD: projects/release-arm-redux/contrib/ntp/ntpd/ntp_control.c 276071 2014-12-22 18:54:55Z delphij $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_config.h"
end_include

begin_include
include|#
directive|include
file|"ntp_crypto.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_leapsec.h"
end_include

begin_include
include|#
directive|include
file|"ntp_md5.h"
end_include

begin_comment
comment|/* provides OpenSSL digest API */
end_comment

begin_include
include|#
directive|include
file|"lib_strbuf.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL_PLL
end_ifdef

begin_include
include|#
directive|include
file|"ntp_syscall.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<= (b)) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Structure to hold request procedure information  */
end_comment

begin_struct
struct|struct
name|ctl_proc
block|{
name|short
name|control_code
decl_stmt|;
comment|/* defined request code */
define|#
directive|define
name|NO_REQUEST
value|(-1)
name|u_short
name|flags
decl_stmt|;
comment|/* flags word */
comment|/* Only one flag.  Authentication required or not. */
define|#
directive|define
name|NOAUTH
value|0
define|#
directive|define
name|AUTH
value|1
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* handle request */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Request processing routines  */
end_comment

begin_function_decl
specifier|static
name|void
name|ctl_error
parameter_list|(
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_function_decl
specifier|static
name|u_short
name|ctlclkstatus
parameter_list|(
name|struct
name|refclockstat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ctl_flushpkt
parameter_list|(
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putdata
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putstr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putdblf
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ctl_putdbl
parameter_list|(
name|tag
parameter_list|,
name|d
parameter_list|)
value|ctl_putdblf(tag, 1, 3, d)
end_define

begin_define
define|#
directive|define
name|ctl_putdbl6
parameter_list|(
name|tag
parameter_list|,
name|d
parameter_list|)
value|ctl_putdblf(tag, 1, 6, d)
end_define

begin_define
define|#
directive|define
name|ctl_putsfp
parameter_list|(
name|tag
parameter_list|,
name|sfp
parameter_list|)
value|ctl_putdblf(tag, 0, -1, \ 					    FPTOD(sfp))
end_define

begin_function_decl
specifier|static
name|void
name|ctl_putuint
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_puthex
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putint
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putts
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putadr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int32
parameter_list|,
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putrefid
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putarray
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|double
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putsys
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putpeer
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_putfs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tstamp_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_function_decl
specifier|static
name|void
name|ctl_putclock
parameter_list|(
name|int
parameter_list|,
name|struct
name|refclockstat
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_function_decl
specifier|static
specifier|const
name|struct
name|ctl_var
modifier|*
name|ctl_getitem
parameter_list|(
specifier|const
name|struct
name|ctl_var
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|count_var
parameter_list|(
specifier|const
name|struct
name|ctl_var
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|control_unspec
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_status
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_sysvars
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_peervars
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_variables
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_variables
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_clockstatus
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_clockstatus
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_trap
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_config
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|configure
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_mru_entry
parameter_list|(
name|mon_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_random_tag_value
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_mru_list
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_ifstats_entry
parameter_list|(
name|endpt
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_ifstats
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sockaddrs_from_restrict_u
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
name|sockaddr_u
modifier|*
parameter_list|,
name|restrict_u
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_restrict_entry
parameter_list|(
name|restrict_u
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_restrict_list
parameter_list|(
name|restrict_u
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_addr_restrictions
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_ordlist
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|derive_nonce
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
name|u_int32
parameter_list|,
name|u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_nonce
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|validate_nonce
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|req_nonce
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unset_trap
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ctl_trap
modifier|*
name|ctlfindtrap
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
name|struct
name|interface
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ctl_proc
name|control_codes
index|[]
init|=
block|{
block|{
name|CTL_OP_UNSPEC
block|,
name|NOAUTH
block|,
name|control_unspec
block|}
block|,
block|{
name|CTL_OP_READSTAT
block|,
name|NOAUTH
block|,
name|read_status
block|}
block|,
block|{
name|CTL_OP_READVAR
block|,
name|NOAUTH
block|,
name|read_variables
block|}
block|,
block|{
name|CTL_OP_WRITEVAR
block|,
name|AUTH
block|,
name|write_variables
block|}
block|,
block|{
name|CTL_OP_READCLOCK
block|,
name|NOAUTH
block|,
name|read_clockstatus
block|}
block|,
block|{
name|CTL_OP_WRITECLOCK
block|,
name|NOAUTH
block|,
name|write_clockstatus
block|}
block|,
block|{
name|CTL_OP_SETTRAP
block|,
name|NOAUTH
block|,
name|set_trap
block|}
block|,
block|{
name|CTL_OP_CONFIGURE
block|,
name|AUTH
block|,
name|configure
block|}
block|,
block|{
name|CTL_OP_SAVECONFIG
block|,
name|AUTH
block|,
name|save_config
block|}
block|,
block|{
name|CTL_OP_READ_MRU
block|,
name|NOAUTH
block|,
name|read_mru_list
block|}
block|,
block|{
name|CTL_OP_READ_ORDLIST_A
block|,
name|AUTH
block|,
name|read_ordlist
block|}
block|,
block|{
name|CTL_OP_REQ_NONCE
block|,
name|NOAUTH
block|,
name|req_nonce
block|}
block|,
block|{
name|CTL_OP_UNSETTRAP
block|,
name|NOAUTH
block|,
name|unset_trap
block|}
block|,
block|{
name|NO_REQUEST
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System variables we understand  */
end_comment

begin_define
define|#
directive|define
name|CS_LEAP
value|1
end_define

begin_define
define|#
directive|define
name|CS_STRATUM
value|2
end_define

begin_define
define|#
directive|define
name|CS_PRECISION
value|3
end_define

begin_define
define|#
directive|define
name|CS_ROOTDELAY
value|4
end_define

begin_define
define|#
directive|define
name|CS_ROOTDISPERSION
value|5
end_define

begin_define
define|#
directive|define
name|CS_REFID
value|6
end_define

begin_define
define|#
directive|define
name|CS_REFTIME
value|7
end_define

begin_define
define|#
directive|define
name|CS_POLL
value|8
end_define

begin_define
define|#
directive|define
name|CS_PEERID
value|9
end_define

begin_define
define|#
directive|define
name|CS_OFFSET
value|10
end_define

begin_define
define|#
directive|define
name|CS_DRIFT
value|11
end_define

begin_define
define|#
directive|define
name|CS_JITTER
value|12
end_define

begin_define
define|#
directive|define
name|CS_ERROR
value|13
end_define

begin_define
define|#
directive|define
name|CS_CLOCK
value|14
end_define

begin_define
define|#
directive|define
name|CS_PROCESSOR
value|15
end_define

begin_define
define|#
directive|define
name|CS_SYSTEM
value|16
end_define

begin_define
define|#
directive|define
name|CS_VERSION
value|17
end_define

begin_define
define|#
directive|define
name|CS_STABIL
value|18
end_define

begin_define
define|#
directive|define
name|CS_VARLIST
value|19
end_define

begin_define
define|#
directive|define
name|CS_TAI
value|20
end_define

begin_define
define|#
directive|define
name|CS_LEAPTAB
value|21
end_define

begin_define
define|#
directive|define
name|CS_LEAPEND
value|22
end_define

begin_define
define|#
directive|define
name|CS_RATE
value|23
end_define

begin_define
define|#
directive|define
name|CS_MRU_ENABLED
value|24
end_define

begin_define
define|#
directive|define
name|CS_MRU_DEPTH
value|25
end_define

begin_define
define|#
directive|define
name|CS_MRU_DEEPEST
value|26
end_define

begin_define
define|#
directive|define
name|CS_MRU_MINDEPTH
value|27
end_define

begin_define
define|#
directive|define
name|CS_MRU_MAXAGE
value|28
end_define

begin_define
define|#
directive|define
name|CS_MRU_MAXDEPTH
value|29
end_define

begin_define
define|#
directive|define
name|CS_MRU_MEM
value|30
end_define

begin_define
define|#
directive|define
name|CS_MRU_MAXMEM
value|31
end_define

begin_define
define|#
directive|define
name|CS_SS_UPTIME
value|32
end_define

begin_define
define|#
directive|define
name|CS_SS_RESET
value|33
end_define

begin_define
define|#
directive|define
name|CS_SS_RECEIVED
value|34
end_define

begin_define
define|#
directive|define
name|CS_SS_THISVER
value|35
end_define

begin_define
define|#
directive|define
name|CS_SS_OLDVER
value|36
end_define

begin_define
define|#
directive|define
name|CS_SS_BADFORMAT
value|37
end_define

begin_define
define|#
directive|define
name|CS_SS_BADAUTH
value|38
end_define

begin_define
define|#
directive|define
name|CS_SS_DECLINED
value|39
end_define

begin_define
define|#
directive|define
name|CS_SS_RESTRICTED
value|40
end_define

begin_define
define|#
directive|define
name|CS_SS_LIMITED
value|41
end_define

begin_define
define|#
directive|define
name|CS_SS_KODSENT
value|42
end_define

begin_define
define|#
directive|define
name|CS_SS_PROCESSED
value|43
end_define

begin_define
define|#
directive|define
name|CS_PEERADR
value|44
end_define

begin_define
define|#
directive|define
name|CS_PEERMODE
value|45
end_define

begin_define
define|#
directive|define
name|CS_BCASTDELAY
value|46
end_define

begin_define
define|#
directive|define
name|CS_AUTHDELAY
value|47
end_define

begin_define
define|#
directive|define
name|CS_AUTHKEYS
value|48
end_define

begin_define
define|#
directive|define
name|CS_AUTHFREEK
value|49
end_define

begin_define
define|#
directive|define
name|CS_AUTHKLOOKUPS
value|50
end_define

begin_define
define|#
directive|define
name|CS_AUTHKNOTFOUND
value|51
end_define

begin_define
define|#
directive|define
name|CS_AUTHKUNCACHED
value|52
end_define

begin_define
define|#
directive|define
name|CS_AUTHKEXPIRED
value|53
end_define

begin_define
define|#
directive|define
name|CS_AUTHENCRYPTS
value|54
end_define

begin_define
define|#
directive|define
name|CS_AUTHDECRYPTS
value|55
end_define

begin_define
define|#
directive|define
name|CS_AUTHRESET
value|56
end_define

begin_define
define|#
directive|define
name|CS_K_OFFSET
value|57
end_define

begin_define
define|#
directive|define
name|CS_K_FREQ
value|58
end_define

begin_define
define|#
directive|define
name|CS_K_MAXERR
value|59
end_define

begin_define
define|#
directive|define
name|CS_K_ESTERR
value|60
end_define

begin_define
define|#
directive|define
name|CS_K_STFLAGS
value|61
end_define

begin_define
define|#
directive|define
name|CS_K_TIMECONST
value|62
end_define

begin_define
define|#
directive|define
name|CS_K_PRECISION
value|63
end_define

begin_define
define|#
directive|define
name|CS_K_FREQTOL
value|64
end_define

begin_define
define|#
directive|define
name|CS_K_PPS_FREQ
value|65
end_define

begin_define
define|#
directive|define
name|CS_K_PPS_STABIL
value|66
end_define

begin_define
define|#
directive|define
name|CS_K_PPS_JITTER
value|67
end_define

begin_define
define|#
directive|define
name|CS_K_PPS_CALIBDUR
value|68
end_define

begin_define
define|#
directive|define
name|CS_K_PPS_CALIBS
value|69
end_define

begin_define
define|#
directive|define
name|CS_K_PPS_CALIBERRS
value|70
end_define

begin_define
define|#
directive|define
name|CS_K_PPS_JITEXC
value|71
end_define

begin_define
define|#
directive|define
name|CS_K_PPS_STBEXC
value|72
end_define

begin_define
define|#
directive|define
name|CS_KERN_FIRST
value|CS_K_OFFSET
end_define

begin_define
define|#
directive|define
name|CS_KERN_LAST
value|CS_K_PPS_STBEXC
end_define

begin_define
define|#
directive|define
name|CS_IOSTATS_RESET
value|73
end_define

begin_define
define|#
directive|define
name|CS_TOTAL_RBUF
value|74
end_define

begin_define
define|#
directive|define
name|CS_FREE_RBUF
value|75
end_define

begin_define
define|#
directive|define
name|CS_USED_RBUF
value|76
end_define

begin_define
define|#
directive|define
name|CS_RBUF_LOWATER
value|77
end_define

begin_define
define|#
directive|define
name|CS_IO_DROPPED
value|78
end_define

begin_define
define|#
directive|define
name|CS_IO_IGNORED
value|79
end_define

begin_define
define|#
directive|define
name|CS_IO_RECEIVED
value|80
end_define

begin_define
define|#
directive|define
name|CS_IO_SENT
value|81
end_define

begin_define
define|#
directive|define
name|CS_IO_SENDFAILED
value|82
end_define

begin_define
define|#
directive|define
name|CS_IO_WAKEUPS
value|83
end_define

begin_define
define|#
directive|define
name|CS_IO_GOODWAKEUPS
value|84
end_define

begin_define
define|#
directive|define
name|CS_TIMERSTATS_RESET
value|85
end_define

begin_define
define|#
directive|define
name|CS_TIMER_OVERRUNS
value|86
end_define

begin_define
define|#
directive|define
name|CS_TIMER_XMTS
value|87
end_define

begin_define
define|#
directive|define
name|CS_FUZZ
value|88
end_define

begin_define
define|#
directive|define
name|CS_WANDER_THRESH
value|89
end_define

begin_define
define|#
directive|define
name|CS_MAX_NOAUTOKEY
value|CS_WANDER_THRESH
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_define
define|#
directive|define
name|CS_FLAGS
value|(1 + CS_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CS_HOST
value|(2 + CS_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CS_PUBLIC
value|(3 + CS_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CS_CERTIF
value|(4 + CS_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CS_SIGNATURE
value|(5 + CS_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CS_REVTIME
value|(6 + CS_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CS_IDENT
value|(7 + CS_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CS_DIGEST
value|(8 + CS_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CS_MAXCODE
value|CS_DIGEST
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !AUTOKEY follows */
end_comment

begin_define
define|#
directive|define
name|CS_MAXCODE
value|CS_MAX_NOAUTOKEY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !AUTOKEY */
end_comment

begin_comment
comment|/*  * Peer variables we understand  */
end_comment

begin_define
define|#
directive|define
name|CP_CONFIG
value|1
end_define

begin_define
define|#
directive|define
name|CP_AUTHENABLE
value|2
end_define

begin_define
define|#
directive|define
name|CP_AUTHENTIC
value|3
end_define

begin_define
define|#
directive|define
name|CP_SRCADR
value|4
end_define

begin_define
define|#
directive|define
name|CP_SRCPORT
value|5
end_define

begin_define
define|#
directive|define
name|CP_DSTADR
value|6
end_define

begin_define
define|#
directive|define
name|CP_DSTPORT
value|7
end_define

begin_define
define|#
directive|define
name|CP_LEAP
value|8
end_define

begin_define
define|#
directive|define
name|CP_HMODE
value|9
end_define

begin_define
define|#
directive|define
name|CP_STRATUM
value|10
end_define

begin_define
define|#
directive|define
name|CP_PPOLL
value|11
end_define

begin_define
define|#
directive|define
name|CP_HPOLL
value|12
end_define

begin_define
define|#
directive|define
name|CP_PRECISION
value|13
end_define

begin_define
define|#
directive|define
name|CP_ROOTDELAY
value|14
end_define

begin_define
define|#
directive|define
name|CP_ROOTDISPERSION
value|15
end_define

begin_define
define|#
directive|define
name|CP_REFID
value|16
end_define

begin_define
define|#
directive|define
name|CP_REFTIME
value|17
end_define

begin_define
define|#
directive|define
name|CP_ORG
value|18
end_define

begin_define
define|#
directive|define
name|CP_REC
value|19
end_define

begin_define
define|#
directive|define
name|CP_XMT
value|20
end_define

begin_define
define|#
directive|define
name|CP_REACH
value|21
end_define

begin_define
define|#
directive|define
name|CP_UNREACH
value|22
end_define

begin_define
define|#
directive|define
name|CP_TIMER
value|23
end_define

begin_define
define|#
directive|define
name|CP_DELAY
value|24
end_define

begin_define
define|#
directive|define
name|CP_OFFSET
value|25
end_define

begin_define
define|#
directive|define
name|CP_JITTER
value|26
end_define

begin_define
define|#
directive|define
name|CP_DISPERSION
value|27
end_define

begin_define
define|#
directive|define
name|CP_KEYID
value|28
end_define

begin_define
define|#
directive|define
name|CP_FILTDELAY
value|29
end_define

begin_define
define|#
directive|define
name|CP_FILTOFFSET
value|30
end_define

begin_define
define|#
directive|define
name|CP_PMODE
value|31
end_define

begin_define
define|#
directive|define
name|CP_RECEIVED
value|32
end_define

begin_define
define|#
directive|define
name|CP_SENT
value|33
end_define

begin_define
define|#
directive|define
name|CP_FILTERROR
value|34
end_define

begin_define
define|#
directive|define
name|CP_FLASH
value|35
end_define

begin_define
define|#
directive|define
name|CP_TTL
value|36
end_define

begin_define
define|#
directive|define
name|CP_VARLIST
value|37
end_define

begin_define
define|#
directive|define
name|CP_IN
value|38
end_define

begin_define
define|#
directive|define
name|CP_OUT
value|39
end_define

begin_define
define|#
directive|define
name|CP_RATE
value|40
end_define

begin_define
define|#
directive|define
name|CP_BIAS
value|41
end_define

begin_define
define|#
directive|define
name|CP_SRCHOST
value|42
end_define

begin_define
define|#
directive|define
name|CP_TIMEREC
value|43
end_define

begin_define
define|#
directive|define
name|CP_TIMEREACH
value|44
end_define

begin_define
define|#
directive|define
name|CP_BADAUTH
value|45
end_define

begin_define
define|#
directive|define
name|CP_BOGUSORG
value|46
end_define

begin_define
define|#
directive|define
name|CP_OLDPKT
value|47
end_define

begin_define
define|#
directive|define
name|CP_SELDISP
value|48
end_define

begin_define
define|#
directive|define
name|CP_SELBROKEN
value|49
end_define

begin_define
define|#
directive|define
name|CP_CANDIDATE
value|50
end_define

begin_define
define|#
directive|define
name|CP_MAX_NOAUTOKEY
value|CP_CANDIDATE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_define
define|#
directive|define
name|CP_FLAGS
value|(1 + CP_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CP_HOST
value|(2 + CP_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CP_VALID
value|(3 + CP_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CP_INITSEQ
value|(4 + CP_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CP_INITKEY
value|(5 + CP_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CP_INITTSP
value|(6 + CP_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CP_SIGNATURE
value|(7 + CP_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CP_IDENT
value|(8 + CP_MAX_NOAUTOKEY)
end_define

begin_define
define|#
directive|define
name|CP_MAXCODE
value|CP_IDENT
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !AUTOKEY follows */
end_comment

begin_define
define|#
directive|define
name|CP_MAXCODE
value|CP_MAX_NOAUTOKEY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !AUTOKEY */
end_comment

begin_comment
comment|/*  * Clock variables we understand  */
end_comment

begin_define
define|#
directive|define
name|CC_TYPE
value|1
end_define

begin_define
define|#
directive|define
name|CC_TIMECODE
value|2
end_define

begin_define
define|#
directive|define
name|CC_POLL
value|3
end_define

begin_define
define|#
directive|define
name|CC_NOREPLY
value|4
end_define

begin_define
define|#
directive|define
name|CC_BADFORMAT
value|5
end_define

begin_define
define|#
directive|define
name|CC_BADDATA
value|6
end_define

begin_define
define|#
directive|define
name|CC_FUDGETIME1
value|7
end_define

begin_define
define|#
directive|define
name|CC_FUDGETIME2
value|8
end_define

begin_define
define|#
directive|define
name|CC_FUDGEVAL1
value|9
end_define

begin_define
define|#
directive|define
name|CC_FUDGEVAL2
value|10
end_define

begin_define
define|#
directive|define
name|CC_FLAGS
value|11
end_define

begin_define
define|#
directive|define
name|CC_DEVICE
value|12
end_define

begin_define
define|#
directive|define
name|CC_VARLIST
value|13
end_define

begin_define
define|#
directive|define
name|CC_MAXCODE
value|CC_VARLIST
end_define

begin_comment
comment|/*  * System variable values. The array can be indexed by the variable  * index to find the textual name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ctl_var
name|sys_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CS_LEAP
block|,
name|RW
block|,
literal|"leap"
block|}
block|,
comment|/* 1 */
block|{
name|CS_STRATUM
block|,
name|RO
block|,
literal|"stratum"
block|}
block|,
comment|/* 2 */
block|{
name|CS_PRECISION
block|,
name|RO
block|,
literal|"precision"
block|}
block|,
comment|/* 3 */
block|{
name|CS_ROOTDELAY
block|,
name|RO
block|,
literal|"rootdelay"
block|}
block|,
comment|/* 4 */
block|{
name|CS_ROOTDISPERSION
block|,
name|RO
block|,
literal|"rootdisp"
block|}
block|,
comment|/* 5 */
block|{
name|CS_REFID
block|,
name|RO
block|,
literal|"refid"
block|}
block|,
comment|/* 6 */
block|{
name|CS_REFTIME
block|,
name|RO
block|,
literal|"reftime"
block|}
block|,
comment|/* 7 */
block|{
name|CS_POLL
block|,
name|RO
block|,
literal|"tc"
block|}
block|,
comment|/* 8 */
block|{
name|CS_PEERID
block|,
name|RO
block|,
literal|"peer"
block|}
block|,
comment|/* 9 */
block|{
name|CS_OFFSET
block|,
name|RO
block|,
literal|"offset"
block|}
block|,
comment|/* 10 */
block|{
name|CS_DRIFT
block|,
name|RO
block|,
literal|"frequency"
block|}
block|,
comment|/* 11 */
block|{
name|CS_JITTER
block|,
name|RO
block|,
literal|"sys_jitter"
block|}
block|,
comment|/* 12 */
block|{
name|CS_ERROR
block|,
name|RO
block|,
literal|"clk_jitter"
block|}
block|,
comment|/* 13 */
block|{
name|CS_CLOCK
block|,
name|RO
block|,
literal|"clock"
block|}
block|,
comment|/* 14 */
block|{
name|CS_PROCESSOR
block|,
name|RO
block|,
literal|"processor"
block|}
block|,
comment|/* 15 */
block|{
name|CS_SYSTEM
block|,
name|RO
block|,
literal|"system"
block|}
block|,
comment|/* 16 */
block|{
name|CS_VERSION
block|,
name|RO
block|,
literal|"version"
block|}
block|,
comment|/* 17 */
block|{
name|CS_STABIL
block|,
name|RO
block|,
literal|"clk_wander"
block|}
block|,
comment|/* 18 */
block|{
name|CS_VARLIST
block|,
name|RO
block|,
literal|"sys_var_list"
block|}
block|,
comment|/* 19 */
block|{
name|CS_TAI
block|,
name|RO
block|,
literal|"tai"
block|}
block|,
comment|/* 20 */
block|{
name|CS_LEAPTAB
block|,
name|RO
block|,
literal|"leapsec"
block|}
block|,
comment|/* 21 */
block|{
name|CS_LEAPEND
block|,
name|RO
block|,
literal|"expire"
block|}
block|,
comment|/* 22 */
block|{
name|CS_RATE
block|,
name|RO
block|,
literal|"mintc"
block|}
block|,
comment|/* 23 */
block|{
name|CS_MRU_ENABLED
block|,
name|RO
block|,
literal|"mru_enabled"
block|}
block|,
comment|/* 24 */
block|{
name|CS_MRU_DEPTH
block|,
name|RO
block|,
literal|"mru_depth"
block|}
block|,
comment|/* 25 */
block|{
name|CS_MRU_DEEPEST
block|,
name|RO
block|,
literal|"mru_deepest"
block|}
block|,
comment|/* 26 */
block|{
name|CS_MRU_MINDEPTH
block|,
name|RO
block|,
literal|"mru_mindepth"
block|}
block|,
comment|/* 27 */
block|{
name|CS_MRU_MAXAGE
block|,
name|RO
block|,
literal|"mru_maxage"
block|}
block|,
comment|/* 28 */
block|{
name|CS_MRU_MAXDEPTH
block|,
name|RO
block|,
literal|"mru_maxdepth"
block|}
block|,
comment|/* 29 */
block|{
name|CS_MRU_MEM
block|,
name|RO
block|,
literal|"mru_mem"
block|}
block|,
comment|/* 30 */
block|{
name|CS_MRU_MAXMEM
block|,
name|RO
block|,
literal|"mru_maxmem"
block|}
block|,
comment|/* 31 */
block|{
name|CS_SS_UPTIME
block|,
name|RO
block|,
literal|"ss_uptime"
block|}
block|,
comment|/* 32 */
block|{
name|CS_SS_RESET
block|,
name|RO
block|,
literal|"ss_reset"
block|}
block|,
comment|/* 33 */
block|{
name|CS_SS_RECEIVED
block|,
name|RO
block|,
literal|"ss_received"
block|}
block|,
comment|/* 34 */
block|{
name|CS_SS_THISVER
block|,
name|RO
block|,
literal|"ss_thisver"
block|}
block|,
comment|/* 35 */
block|{
name|CS_SS_OLDVER
block|,
name|RO
block|,
literal|"ss_oldver"
block|}
block|,
comment|/* 36 */
block|{
name|CS_SS_BADFORMAT
block|,
name|RO
block|,
literal|"ss_badformat"
block|}
block|,
comment|/* 37 */
block|{
name|CS_SS_BADAUTH
block|,
name|RO
block|,
literal|"ss_badauth"
block|}
block|,
comment|/* 38 */
block|{
name|CS_SS_DECLINED
block|,
name|RO
block|,
literal|"ss_declined"
block|}
block|,
comment|/* 39 */
block|{
name|CS_SS_RESTRICTED
block|,
name|RO
block|,
literal|"ss_restricted"
block|}
block|,
comment|/* 40 */
block|{
name|CS_SS_LIMITED
block|,
name|RO
block|,
literal|"ss_limited"
block|}
block|,
comment|/* 41 */
block|{
name|CS_SS_KODSENT
block|,
name|RO
block|,
literal|"ss_kodsent"
block|}
block|,
comment|/* 42 */
block|{
name|CS_SS_PROCESSED
block|,
name|RO
block|,
literal|"ss_processed"
block|}
block|,
comment|/* 43 */
block|{
name|CS_PEERADR
block|,
name|RO
block|,
literal|"peeradr"
block|}
block|,
comment|/* 44 */
block|{
name|CS_PEERMODE
block|,
name|RO
block|,
literal|"peermode"
block|}
block|,
comment|/* 45 */
block|{
name|CS_BCASTDELAY
block|,
name|RO
block|,
literal|"bcastdelay"
block|}
block|,
comment|/* 46 */
block|{
name|CS_AUTHDELAY
block|,
name|RO
block|,
literal|"authdelay"
block|}
block|,
comment|/* 47 */
block|{
name|CS_AUTHKEYS
block|,
name|RO
block|,
literal|"authkeys"
block|}
block|,
comment|/* 48 */
block|{
name|CS_AUTHFREEK
block|,
name|RO
block|,
literal|"authfreek"
block|}
block|,
comment|/* 49 */
block|{
name|CS_AUTHKLOOKUPS
block|,
name|RO
block|,
literal|"authklookups"
block|}
block|,
comment|/* 50 */
block|{
name|CS_AUTHKNOTFOUND
block|,
name|RO
block|,
literal|"authknotfound"
block|}
block|,
comment|/* 51 */
block|{
name|CS_AUTHKUNCACHED
block|,
name|RO
block|,
literal|"authkuncached"
block|}
block|,
comment|/* 52 */
block|{
name|CS_AUTHKEXPIRED
block|,
name|RO
block|,
literal|"authkexpired"
block|}
block|,
comment|/* 53 */
block|{
name|CS_AUTHENCRYPTS
block|,
name|RO
block|,
literal|"authencrypts"
block|}
block|,
comment|/* 54 */
block|{
name|CS_AUTHDECRYPTS
block|,
name|RO
block|,
literal|"authdecrypts"
block|}
block|,
comment|/* 55 */
block|{
name|CS_AUTHRESET
block|,
name|RO
block|,
literal|"authreset"
block|}
block|,
comment|/* 56 */
block|{
name|CS_K_OFFSET
block|,
name|RO
block|,
literal|"koffset"
block|}
block|,
comment|/* 57 */
block|{
name|CS_K_FREQ
block|,
name|RO
block|,
literal|"kfreq"
block|}
block|,
comment|/* 58 */
block|{
name|CS_K_MAXERR
block|,
name|RO
block|,
literal|"kmaxerr"
block|}
block|,
comment|/* 59 */
block|{
name|CS_K_ESTERR
block|,
name|RO
block|,
literal|"kesterr"
block|}
block|,
comment|/* 60 */
block|{
name|CS_K_STFLAGS
block|,
name|RO
block|,
literal|"kstflags"
block|}
block|,
comment|/* 61 */
block|{
name|CS_K_TIMECONST
block|,
name|RO
block|,
literal|"ktimeconst"
block|}
block|,
comment|/* 62 */
block|{
name|CS_K_PRECISION
block|,
name|RO
block|,
literal|"kprecis"
block|}
block|,
comment|/* 63 */
block|{
name|CS_K_FREQTOL
block|,
name|RO
block|,
literal|"kfreqtol"
block|}
block|,
comment|/* 64 */
block|{
name|CS_K_PPS_FREQ
block|,
name|RO
block|,
literal|"kppsfreq"
block|}
block|,
comment|/* 65 */
block|{
name|CS_K_PPS_STABIL
block|,
name|RO
block|,
literal|"kppsstab"
block|}
block|,
comment|/* 66 */
block|{
name|CS_K_PPS_JITTER
block|,
name|RO
block|,
literal|"kppsjitter"
block|}
block|,
comment|/* 67 */
block|{
name|CS_K_PPS_CALIBDUR
block|,
name|RO
block|,
literal|"kppscalibdur"
block|}
block|,
comment|/* 68 */
block|{
name|CS_K_PPS_CALIBS
block|,
name|RO
block|,
literal|"kppscalibs"
block|}
block|,
comment|/* 69 */
block|{
name|CS_K_PPS_CALIBERRS
block|,
name|RO
block|,
literal|"kppscaliberrs"
block|}
block|,
comment|/* 70 */
block|{
name|CS_K_PPS_JITEXC
block|,
name|RO
block|,
literal|"kppsjitexc"
block|}
block|,
comment|/* 71 */
block|{
name|CS_K_PPS_STBEXC
block|,
name|RO
block|,
literal|"kppsstbexc"
block|}
block|,
comment|/* 72 */
block|{
name|CS_IOSTATS_RESET
block|,
name|RO
block|,
literal|"iostats_reset"
block|}
block|,
comment|/* 73 */
block|{
name|CS_TOTAL_RBUF
block|,
name|RO
block|,
literal|"total_rbuf"
block|}
block|,
comment|/* 74 */
block|{
name|CS_FREE_RBUF
block|,
name|RO
block|,
literal|"free_rbuf"
block|}
block|,
comment|/* 75 */
block|{
name|CS_USED_RBUF
block|,
name|RO
block|,
literal|"used_rbuf"
block|}
block|,
comment|/* 76 */
block|{
name|CS_RBUF_LOWATER
block|,
name|RO
block|,
literal|"rbuf_lowater"
block|}
block|,
comment|/* 77 */
block|{
name|CS_IO_DROPPED
block|,
name|RO
block|,
literal|"io_dropped"
block|}
block|,
comment|/* 78 */
block|{
name|CS_IO_IGNORED
block|,
name|RO
block|,
literal|"io_ignored"
block|}
block|,
comment|/* 79 */
block|{
name|CS_IO_RECEIVED
block|,
name|RO
block|,
literal|"io_received"
block|}
block|,
comment|/* 80 */
block|{
name|CS_IO_SENT
block|,
name|RO
block|,
literal|"io_sent"
block|}
block|,
comment|/* 81 */
block|{
name|CS_IO_SENDFAILED
block|,
name|RO
block|,
literal|"io_sendfailed"
block|}
block|,
comment|/* 82 */
block|{
name|CS_IO_WAKEUPS
block|,
name|RO
block|,
literal|"io_wakeups"
block|}
block|,
comment|/* 83 */
block|{
name|CS_IO_GOODWAKEUPS
block|,
name|RO
block|,
literal|"io_goodwakeups"
block|}
block|,
comment|/* 84 */
block|{
name|CS_TIMERSTATS_RESET
block|,
name|RO
block|,
literal|"timerstats_reset"
block|}
block|,
comment|/* 85 */
block|{
name|CS_TIMER_OVERRUNS
block|,
name|RO
block|,
literal|"timer_overruns"
block|}
block|,
comment|/* 86 */
block|{
name|CS_TIMER_XMTS
block|,
name|RO
block|,
literal|"timer_xmts"
block|}
block|,
comment|/* 87 */
block|{
name|CS_FUZZ
block|,
name|RO
block|,
literal|"fuzz"
block|}
block|,
comment|/* 88 */
block|{
name|CS_WANDER_THRESH
block|,
name|RO
block|,
literal|"clk_wander_threshold"
block|}
block|,
comment|/* 89 */
ifdef|#
directive|ifdef
name|AUTOKEY
block|{
name|CS_FLAGS
block|,
name|RO
block|,
literal|"flags"
block|}
block|,
comment|/* 1 + CS_MAX_NOAUTOKEY */
block|{
name|CS_HOST
block|,
name|RO
block|,
literal|"host"
block|}
block|,
comment|/* 2 + CS_MAX_NOAUTOKEY */
block|{
name|CS_PUBLIC
block|,
name|RO
block|,
literal|"update"
block|}
block|,
comment|/* 3 + CS_MAX_NOAUTOKEY */
block|{
name|CS_CERTIF
block|,
name|RO
block|,
literal|"cert"
block|}
block|,
comment|/* 4 + CS_MAX_NOAUTOKEY */
block|{
name|CS_SIGNATURE
block|,
name|RO
block|,
literal|"signature"
block|}
block|,
comment|/* 5 + CS_MAX_NOAUTOKEY */
block|{
name|CS_REVTIME
block|,
name|RO
block|,
literal|"until"
block|}
block|,
comment|/* 6 + CS_MAX_NOAUTOKEY */
block|{
name|CS_IDENT
block|,
name|RO
block|,
literal|"ident"
block|}
block|,
comment|/* 7 + CS_MAX_NOAUTOKEY */
block|{
name|CS_DIGEST
block|,
name|RO
block|,
literal|"digest"
block|}
block|,
comment|/* 8 + CS_MAX_NOAUTOKEY */
endif|#
directive|endif
comment|/* AUTOKEY */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
comment|/* 87/95 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
modifier|*
name|ext_sys_var
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System variables we print by default (in fuzzball order,  * more-or-less)  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|def_sys_var
index|[]
init|=
block|{
name|CS_VERSION
block|,
name|CS_PROCESSOR
block|,
name|CS_SYSTEM
block|,
name|CS_LEAP
block|,
name|CS_STRATUM
block|,
name|CS_PRECISION
block|,
name|CS_ROOTDELAY
block|,
name|CS_ROOTDISPERSION
block|,
name|CS_REFID
block|,
name|CS_REFTIME
block|,
name|CS_CLOCK
block|,
name|CS_PEERID
block|,
name|CS_POLL
block|,
name|CS_RATE
block|,
name|CS_OFFSET
block|,
name|CS_DRIFT
block|,
name|CS_JITTER
block|,
name|CS_ERROR
block|,
name|CS_STABIL
block|,
name|CS_TAI
block|,
name|CS_LEAPTAB
block|,
name|CS_LEAPEND
block|,
ifdef|#
directive|ifdef
name|AUTOKEY
name|CS_HOST
block|,
name|CS_IDENT
block|,
name|CS_FLAGS
block|,
name|CS_DIGEST
block|,
name|CS_SIGNATURE
block|,
name|CS_PUBLIC
block|,
name|CS_CERTIF
block|,
endif|#
directive|endif
comment|/* AUTOKEY */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Peer variable list  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ctl_var
name|peer_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CP_CONFIG
block|,
name|RO
block|,
literal|"config"
block|}
block|,
comment|/* 1 */
block|{
name|CP_AUTHENABLE
block|,
name|RO
block|,
literal|"authenable"
block|}
block|,
comment|/* 2 */
block|{
name|CP_AUTHENTIC
block|,
name|RO
block|,
literal|"authentic"
block|}
block|,
comment|/* 3 */
block|{
name|CP_SRCADR
block|,
name|RO
block|,
literal|"srcadr"
block|}
block|,
comment|/* 4 */
block|{
name|CP_SRCPORT
block|,
name|RO
block|,
literal|"srcport"
block|}
block|,
comment|/* 5 */
block|{
name|CP_DSTADR
block|,
name|RO
block|,
literal|"dstadr"
block|}
block|,
comment|/* 6 */
block|{
name|CP_DSTPORT
block|,
name|RO
block|,
literal|"dstport"
block|}
block|,
comment|/* 7 */
block|{
name|CP_LEAP
block|,
name|RO
block|,
literal|"leap"
block|}
block|,
comment|/* 8 */
block|{
name|CP_HMODE
block|,
name|RO
block|,
literal|"hmode"
block|}
block|,
comment|/* 9 */
block|{
name|CP_STRATUM
block|,
name|RO
block|,
literal|"stratum"
block|}
block|,
comment|/* 10 */
block|{
name|CP_PPOLL
block|,
name|RO
block|,
literal|"ppoll"
block|}
block|,
comment|/* 11 */
block|{
name|CP_HPOLL
block|,
name|RO
block|,
literal|"hpoll"
block|}
block|,
comment|/* 12 */
block|{
name|CP_PRECISION
block|,
name|RO
block|,
literal|"precision"
block|}
block|,
comment|/* 13 */
block|{
name|CP_ROOTDELAY
block|,
name|RO
block|,
literal|"rootdelay"
block|}
block|,
comment|/* 14 */
block|{
name|CP_ROOTDISPERSION
block|,
name|RO
block|,
literal|"rootdisp"
block|}
block|,
comment|/* 15 */
block|{
name|CP_REFID
block|,
name|RO
block|,
literal|"refid"
block|}
block|,
comment|/* 16 */
block|{
name|CP_REFTIME
block|,
name|RO
block|,
literal|"reftime"
block|}
block|,
comment|/* 17 */
block|{
name|CP_ORG
block|,
name|RO
block|,
literal|"org"
block|}
block|,
comment|/* 18 */
block|{
name|CP_REC
block|,
name|RO
block|,
literal|"rec"
block|}
block|,
comment|/* 19 */
block|{
name|CP_XMT
block|,
name|RO
block|,
literal|"xleave"
block|}
block|,
comment|/* 20 */
block|{
name|CP_REACH
block|,
name|RO
block|,
literal|"reach"
block|}
block|,
comment|/* 21 */
block|{
name|CP_UNREACH
block|,
name|RO
block|,
literal|"unreach"
block|}
block|,
comment|/* 22 */
block|{
name|CP_TIMER
block|,
name|RO
block|,
literal|"timer"
block|}
block|,
comment|/* 23 */
block|{
name|CP_DELAY
block|,
name|RO
block|,
literal|"delay"
block|}
block|,
comment|/* 24 */
block|{
name|CP_OFFSET
block|,
name|RO
block|,
literal|"offset"
block|}
block|,
comment|/* 25 */
block|{
name|CP_JITTER
block|,
name|RO
block|,
literal|"jitter"
block|}
block|,
comment|/* 26 */
block|{
name|CP_DISPERSION
block|,
name|RO
block|,
literal|"dispersion"
block|}
block|,
comment|/* 27 */
block|{
name|CP_KEYID
block|,
name|RO
block|,
literal|"keyid"
block|}
block|,
comment|/* 28 */
block|{
name|CP_FILTDELAY
block|,
name|RO
block|,
literal|"filtdelay"
block|}
block|,
comment|/* 29 */
block|{
name|CP_FILTOFFSET
block|,
name|RO
block|,
literal|"filtoffset"
block|}
block|,
comment|/* 30 */
block|{
name|CP_PMODE
block|,
name|RO
block|,
literal|"pmode"
block|}
block|,
comment|/* 31 */
block|{
name|CP_RECEIVED
block|,
name|RO
block|,
literal|"received"
block|}
block|,
comment|/* 32 */
block|{
name|CP_SENT
block|,
name|RO
block|,
literal|"sent"
block|}
block|,
comment|/* 33 */
block|{
name|CP_FILTERROR
block|,
name|RO
block|,
literal|"filtdisp"
block|}
block|,
comment|/* 34 */
block|{
name|CP_FLASH
block|,
name|RO
block|,
literal|"flash"
block|}
block|,
comment|/* 35 */
block|{
name|CP_TTL
block|,
name|RO
block|,
literal|"ttl"
block|}
block|,
comment|/* 36 */
block|{
name|CP_VARLIST
block|,
name|RO
block|,
literal|"peer_var_list"
block|}
block|,
comment|/* 37 */
block|{
name|CP_IN
block|,
name|RO
block|,
literal|"in"
block|}
block|,
comment|/* 38 */
block|{
name|CP_OUT
block|,
name|RO
block|,
literal|"out"
block|}
block|,
comment|/* 39 */
block|{
name|CP_RATE
block|,
name|RO
block|,
literal|"headway"
block|}
block|,
comment|/* 40 */
block|{
name|CP_BIAS
block|,
name|RO
block|,
literal|"bias"
block|}
block|,
comment|/* 41 */
block|{
name|CP_SRCHOST
block|,
name|RO
block|,
literal|"srchost"
block|}
block|,
comment|/* 42 */
block|{
name|CP_TIMEREC
block|,
name|RO
block|,
literal|"timerec"
block|}
block|,
comment|/* 43 */
block|{
name|CP_TIMEREACH
block|,
name|RO
block|,
literal|"timereach"
block|}
block|,
comment|/* 44 */
block|{
name|CP_BADAUTH
block|,
name|RO
block|,
literal|"badauth"
block|}
block|,
comment|/* 45 */
block|{
name|CP_BOGUSORG
block|,
name|RO
block|,
literal|"bogusorg"
block|}
block|,
comment|/* 46 */
block|{
name|CP_OLDPKT
block|,
name|RO
block|,
literal|"oldpkt"
block|}
block|,
comment|/* 47 */
block|{
name|CP_SELDISP
block|,
name|RO
block|,
literal|"seldisp"
block|}
block|,
comment|/* 48 */
block|{
name|CP_SELBROKEN
block|,
name|RO
block|,
literal|"selbroken"
block|}
block|,
comment|/* 49 */
block|{
name|CP_CANDIDATE
block|,
name|RO
block|,
literal|"candidate"
block|}
block|,
comment|/* 50 */
ifdef|#
directive|ifdef
name|AUTOKEY
block|{
name|CP_FLAGS
block|,
name|RO
block|,
literal|"flags"
block|}
block|,
comment|/* 1 + CP_MAX_NOAUTOKEY */
block|{
name|CP_HOST
block|,
name|RO
block|,
literal|"host"
block|}
block|,
comment|/* 2 + CP_MAX_NOAUTOKEY */
block|{
name|CP_VALID
block|,
name|RO
block|,
literal|"valid"
block|}
block|,
comment|/* 3 + CP_MAX_NOAUTOKEY */
block|{
name|CP_INITSEQ
block|,
name|RO
block|,
literal|"initsequence"
block|}
block|,
comment|/* 4 + CP_MAX_NOAUTOKEY */
block|{
name|CP_INITKEY
block|,
name|RO
block|,
literal|"initkey"
block|}
block|,
comment|/* 5 + CP_MAX_NOAUTOKEY */
block|{
name|CP_INITTSP
block|,
name|RO
block|,
literal|"timestamp"
block|}
block|,
comment|/* 6 + CP_MAX_NOAUTOKEY */
block|{
name|CP_SIGNATURE
block|,
name|RO
block|,
literal|"signature"
block|}
block|,
comment|/* 7 + CP_MAX_NOAUTOKEY */
block|{
name|CP_IDENT
block|,
name|RO
block|,
literal|"ident"
block|}
block|,
comment|/* 8 + CP_MAX_NOAUTOKEY */
endif|#
directive|endif
comment|/* AUTOKEY */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
comment|/* 50/58 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Peer variables we print by default  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|def_peer_var
index|[]
init|=
block|{
name|CP_SRCADR
block|,
name|CP_SRCPORT
block|,
name|CP_SRCHOST
block|,
name|CP_DSTADR
block|,
name|CP_DSTPORT
block|,
name|CP_OUT
block|,
name|CP_IN
block|,
name|CP_LEAP
block|,
name|CP_STRATUM
block|,
name|CP_PRECISION
block|,
name|CP_ROOTDELAY
block|,
name|CP_ROOTDISPERSION
block|,
name|CP_REFID
block|,
name|CP_REFTIME
block|,
name|CP_REC
block|,
name|CP_REACH
block|,
name|CP_UNREACH
block|,
name|CP_HMODE
block|,
name|CP_PMODE
block|,
name|CP_HPOLL
block|,
name|CP_PPOLL
block|,
name|CP_RATE
block|,
name|CP_FLASH
block|,
name|CP_KEYID
block|,
name|CP_TTL
block|,
name|CP_OFFSET
block|,
name|CP_DELAY
block|,
name|CP_DISPERSION
block|,
name|CP_JITTER
block|,
name|CP_XMT
block|,
name|CP_BIAS
block|,
name|CP_FILTDELAY
block|,
name|CP_FILTOFFSET
block|,
name|CP_FILTERROR
block|,
ifdef|#
directive|ifdef
name|AUTOKEY
name|CP_HOST
block|,
name|CP_FLAGS
block|,
name|CP_SIGNATURE
block|,
name|CP_VALID
block|,
name|CP_INITSEQ
block|,
name|CP_IDENT
block|,
endif|#
directive|endif
comment|/* AUTOKEY */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * Clock variable list  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ctl_var
name|clock_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CC_TYPE
block|,
name|RO
block|,
literal|"type"
block|}
block|,
comment|/* 1 */
block|{
name|CC_TIMECODE
block|,
name|RO
block|,
literal|"timecode"
block|}
block|,
comment|/* 2 */
block|{
name|CC_POLL
block|,
name|RO
block|,
literal|"poll"
block|}
block|,
comment|/* 3 */
block|{
name|CC_NOREPLY
block|,
name|RO
block|,
literal|"noreply"
block|}
block|,
comment|/* 4 */
block|{
name|CC_BADFORMAT
block|,
name|RO
block|,
literal|"badformat"
block|}
block|,
comment|/* 5 */
block|{
name|CC_BADDATA
block|,
name|RO
block|,
literal|"baddata"
block|}
block|,
comment|/* 6 */
block|{
name|CC_FUDGETIME1
block|,
name|RO
block|,
literal|"fudgetime1"
block|}
block|,
comment|/* 7 */
block|{
name|CC_FUDGETIME2
block|,
name|RO
block|,
literal|"fudgetime2"
block|}
block|,
comment|/* 8 */
block|{
name|CC_FUDGEVAL1
block|,
name|RO
block|,
literal|"stratum"
block|}
block|,
comment|/* 9 */
block|{
name|CC_FUDGEVAL2
block|,
name|RO
block|,
literal|"refid"
block|}
block|,
comment|/* 10 */
block|{
name|CC_FLAGS
block|,
name|RO
block|,
literal|"flags"
block|}
block|,
comment|/* 11 */
block|{
name|CC_DEVICE
block|,
name|RO
block|,
literal|"device"
block|}
block|,
comment|/* 12 */
block|{
name|CC_VARLIST
block|,
name|RO
block|,
literal|"clock_var_list"
block|}
block|,
comment|/* 13 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
comment|/* 14 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clock variables printed by default  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|def_clock_var
index|[]
init|=
block|{
name|CC_DEVICE
block|,
name|CC_TYPE
block|,
comment|/* won't be output if device = known */
name|CC_TIMECODE
block|,
name|CC_POLL
block|,
name|CC_NOREPLY
block|,
name|CC_BADFORMAT
block|,
name|CC_BADDATA
block|,
name|CC_FUDGETIME1
block|,
name|CC_FUDGETIME2
block|,
name|CC_FUDGEVAL1
block|,
name|CC_FUDGEVAL2
block|,
name|CC_FLAGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MRU string constants shared by send_mru_entry() and read_mru_list().  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|addr_fmt
index|[]
init|=
literal|"addr.%d"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|last_fmt
index|[]
init|=
literal|"last.%d"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System and processor definitions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_UNAME
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|STR_SYSTEM
end_ifndef

begin_define
define|#
directive|define
name|STR_SYSTEM
value|"UNIX"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STR_PROCESSOR
end_ifndef

begin_define
define|#
directive|define
name|STR_PROCESSOR
value|"unknown"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|str_system
index|[]
init|=
name|STR_SYSTEM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|str_processor
index|[]
init|=
name|STR_PROCESSOR
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|utsname
name|utsnamebuf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNAME */
end_comment

begin_comment
comment|/*  * Trap structures. We only allow a few of these, and send a copy of  * each async message to each live one. Traps time out after an hour, it  * is up to the trap receipient to keep resetting it to avoid being  * timed out.  */
end_comment

begin_comment
comment|/* ntp_request.c */
end_comment

begin_decl_stmt
name|struct
name|ctl_trap
name|ctl_traps
index|[
name|CTL_MAXTRAPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_ctl_traps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Type bits, for ctlsettrap() call.  */
end_comment

begin_define
define|#
directive|define
name|TRAP_TYPE_CONFIG
value|0
end_define

begin_comment
comment|/* used by configuration code */
end_comment

begin_define
define|#
directive|define
name|TRAP_TYPE_PRIO
value|1
end_define

begin_comment
comment|/* priority trap */
end_comment

begin_define
define|#
directive|define
name|TRAP_TYPE_NONPRIO
value|2
end_define

begin_comment
comment|/* nonpriority trap */
end_comment

begin_comment
comment|/*  * List relating reference clock types to control message time sources.  * Index by the reference clock type. This list will only be used iff  * the reference clock driver doesn't set peer->sstclktype to something  * different than CTL_SST_TS_UNSPEC.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|clocktypes
index|[]
init|=
block|{
name|CTL_SST_TS_NTP
block|,
comment|/* REFCLK_NONE (0) */
name|CTL_SST_TS_LOCAL
block|,
comment|/* REFCLK_LOCALCLOCK (1) */
name|CTL_SST_TS_UHF
block|,
comment|/* deprecated REFCLK_GPS_TRAK (2) */
name|CTL_SST_TS_HF
block|,
comment|/* REFCLK_WWV_PST (3) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_WWVB_SPECTRACOM (4) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_TRUETIME (5) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_IRIG_AUDIO (6) */
name|CTL_SST_TS_HF
block|,
comment|/* REFCLK_CHU (7) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLOCK_PARSE (default) (8) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_GPS_MX4200 (9) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_AS2201 (10) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_ARBITER (11) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_IRIG_TPRO (12) */
name|CTL_SST_TS_ATOM
block|,
comment|/* REFCLK_ATOM_LEITCH (13) */
name|CTL_SST_TS_LF
block|,
comment|/* deprecated REFCLK_MSF_EES (14) */
name|CTL_SST_TS_NTP
block|,
comment|/* not used (15) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_IRIG_BANCOMM (16) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_DATU (17) */
name|CTL_SST_TS_TELEPHONE
block|,
comment|/* REFCLK_NIST_ACTS (18) */
name|CTL_SST_TS_HF
block|,
comment|/* REFCLK_WWV_HEATH (19) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_NMEA (20) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_VME (21) */
name|CTL_SST_TS_ATOM
block|,
comment|/* REFCLK_ATOM_PPS (22) */
name|CTL_SST_TS_NTP
block|,
comment|/* not used (23) */
name|CTL_SST_TS_NTP
block|,
comment|/* not used (24) */
name|CTL_SST_TS_NTP
block|,
comment|/* not used (25) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_HP (26) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_ARCRON_MSF (27) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_SHM (28) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_PALISADE (29) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_ONCORE (30) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_JUPITER (31) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_CHRONOLOG (32) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_DUMBCLOCK (33) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_ULINK (34) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_PCF (35) */
name|CTL_SST_TS_HF
block|,
comment|/* REFCLK_WWV (36) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_FG (37) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_HOPF_SERIAL (38) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_HOPF_PCI (39) */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_JJY (40) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_TT560 (41) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_ZYFER (42) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_RIPENCC (43) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_NEOCLOCK4X (44) */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_TSYNCPCI (45) */
name|CTL_SST_TS_UHF
comment|/* REFCLK_GPSDJSON (46) */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_comment
comment|/*  * Keyid used for authenticating write requests.  */
end_comment

begin_decl_stmt
name|keyid_t
name|ctl_auth_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We keep track of the last error reported by the system internally  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|ctl_sys_last_event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|ctl_sys_num_events
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statistic counters to keep track of requests and responses.  */
end_comment

begin_decl_stmt
name|u_long
name|ctltimereset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time stats reset */
end_comment

begin_decl_stmt
name|u_long
name|numctlreq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of requests we've received */
end_comment

begin_decl_stmt
name|u_long
name|numctlbadpkts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bad control packets */
end_comment

begin_decl_stmt
name|u_long
name|numctlresponses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of resp packets sent with data */
end_comment

begin_decl_stmt
name|u_long
name|numctlfrags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fragments sent */
end_comment

begin_decl_stmt
name|u_long
name|numctlerrors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of error responses sent */
end_comment

begin_decl_stmt
name|u_long
name|numctltooshort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of too short input packets */
end_comment

begin_decl_stmt
name|u_long
name|numctlinputresp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of responses on input */
end_comment

begin_decl_stmt
name|u_long
name|numctlinputfrag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fragments on input */
end_comment

begin_decl_stmt
name|u_long
name|numctlinputerr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input pkts with err bit set */
end_comment

begin_decl_stmt
name|u_long
name|numctlbadoffset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input pkts with nonzero offset */
end_comment

begin_decl_stmt
name|u_long
name|numctlbadversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input pkts with unknown version */
end_comment

begin_decl_stmt
name|u_long
name|numctldatatooshort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data too short for count */
end_comment

begin_decl_stmt
name|u_long
name|numctlbadop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bad op code found in packet */
end_comment

begin_decl_stmt
name|u_long
name|numasyncmsgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of async messages we've sent */
end_comment

begin_comment
comment|/*  * Response packet used by these routines. Also some state information  * so that we can handle packet formatting within a common set of  * subroutines.  Note we try to enter data in place whenever possible,  * but the need to set the more bit correctly means we occasionally  * use the extra buffer and copy.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ntp_control
name|rpkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|associd_t
name|res_associd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|res_frags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* datagrams in this response */
end_comment

begin_decl_stmt
specifier|static
name|int
name|res_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offset of payload in response */
end_comment

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|datapt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|dataend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|datalinelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|datasent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag to avoid initial ", " */
end_comment

begin_decl_stmt
specifier|static
name|int
name|datanotbinflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sockaddr_u
modifier|*
name|rmt_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|lcl_inter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_authenticate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_authokay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyid_t
name|res_keyid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXDATALINELEN
value|(72)
end_define

begin_decl_stmt
specifier|static
name|u_char
name|res_async
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sending async trap response? */
end_comment

begin_comment
comment|/*  * Pointers for saving state when decoding request packets  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reqpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reqend
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<= (b)) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * init_control - initialize request data  */
end_comment

begin_function
name|void
name|init_control
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_UNAME
name|uname
argument_list|(
operator|&
name|utsnamebuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_UNAME */
name|ctl_clr_stats
argument_list|()
expr_stmt|;
name|ctl_auth_keyid
operator|=
literal|0
expr_stmt|;
name|ctl_sys_last_event
operator|=
name|EVNT_UNSPEC
expr_stmt|;
name|ctl_sys_num_events
operator|=
literal|0
expr_stmt|;
name|num_ctl_traps
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|ctl_traps
argument_list|)
condition|;
name|i
operator|++
control|)
name|ctl_traps
index|[
name|i
index|]
operator|.
name|tr_flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_error - send an error response for the current request  */
end_comment

begin_function
specifier|static
name|void
name|ctl_error
parameter_list|(
name|u_char
name|errcode
parameter_list|)
block|{
name|int
name|maclen
decl_stmt|;
name|numctlerrors
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"sending control error %u\n"
operator|,
name|errcode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the fields. We assume rpkt.sequence and rpkt.associd 	 * have already been filled in. 	 */
name|rpkt
operator|.
name|r_m_e_op
operator|=
operator|(
name|u_char
operator|)
name|CTL_RESPONSE
operator||
name|CTL_ERROR
operator||
operator|(
name|res_opcode
operator|&
name|CTL_OP_MASK
operator|)
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
call|(
name|u_short
call|)
argument_list|(
name|errcode
operator|<<
literal|8
argument_list|)
operator|&
literal|0xff00
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * send packet and bump counters 	 */
if|if
condition|(
name|res_authenticate
operator|&&
name|sys_authenticate
condition|)
block|{
name|maclen
operator|=
name|authencrypt
argument_list|(
name|res_keyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|CTL_HEADER_LEN
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|-
literal|2
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|CTL_HEADER_LEN
operator|+
name|maclen
argument_list|)
expr_stmt|;
block|}
else|else
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|-
literal|3
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|CTL_HEADER_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * save_config - Implements ntpq -c "saveconfig<filename>"  *		 Writes current configuration including any runtime  *		 changes by ntpq's :config or config-from-file  */
end_comment

begin_function
name|void
name|save_config
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|char
name|reply
index|[
literal|128
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SAVECONFIG
name|char
name|filespec
index|[
literal|128
index|]
decl_stmt|;
name|char
name|filename
index|[
literal|128
index|]
decl_stmt|;
name|char
name|fullpath
index|[
literal|512
index|]
decl_stmt|;
specifier|const
name|char
name|savedconfig_eq
index|[]
init|=
literal|"savedconfig="
decl_stmt|;
name|char
name|savedconfig
index|[
sizeof|sizeof
argument_list|(
name|savedconfig_eq
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
index|]
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|fptr
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|RES_NOMODIFY
operator|&
name|restrict_mask
condition|)
block|{
name|snprintf
argument_list|(
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|,
literal|"saveconfig prohibited by restrict ... nomodify"
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|reply
argument_list|,
name|strlen
argument_list|(
name|reply
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"saveconfig from %s rejected due to nomodify restriction"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|sys_restricted
operator|++
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|SAVECONFIG
if|if
condition|(
name|NULL
operator|==
name|saveconfigdir
condition|)
block|{
name|snprintf
argument_list|(
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|,
literal|"saveconfig prohibited, no saveconfigdir configured"
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|reply
argument_list|,
name|strlen
argument_list|(
name|reply
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"saveconfig from %s rejected, no saveconfigdir"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
literal|0
operator|==
name|reqend
operator|-
name|reqpt
condition|)
return|return;
name|strlcpy
argument_list|(
name|filespec
argument_list|,
name|reqpt
argument_list|,
sizeof|sizeof
argument_list|(
name|filespec
argument_list|)
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * allow timestamping of the saved config filename with 	 * strftime() format such as: 	 *   ntpq -c "saveconfig ntp-%Y%m%d-%H%M%S.conf" 	 * XXX: Nice feature, but not too safe. 	 */
if|if
condition|(
literal|0
operator|==
name|strftime
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
name|filespec
argument_list|,
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
condition|)
name|strlcpy
argument_list|(
name|filename
argument_list|,
name|filespec
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Conceptually we should be searching for DIRSEP in filename, 	 * however Windows actually recognizes both forward and 	 * backslashes as equivalent directory separators at the API 	 * level.  On POSIX systems we could allow '\\' but such 	 * filenames are tricky to manipulate from a shell, so just 	 * reject both types of slashes on all platforms. 	 */
if|if
condition|(
name|strchr
argument_list|(
name|filename
argument_list|,
literal|'\\'
argument_list|)
operator|||
name|strchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|,
literal|"saveconfig does not allow directory in filename"
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|reply
argument_list|,
name|strlen
argument_list|(
name|reply
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"saveconfig with path from %s rejected"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|snprintf
argument_list|(
name|fullpath
argument_list|,
sizeof|sizeof
argument_list|(
name|fullpath
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|saveconfigdir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fullpath
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|fd
condition|)
name|fptr
operator|=
name|NULL
expr_stmt|;
else|else
name|fptr
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|fptr
operator|||
operator|-
literal|1
operator|==
name|dump_all_config_trees
argument_list|(
name|fptr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|,
literal|"Unable to save configuration to file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"saveconfig %s from %s failed"
argument_list|,
name|filename
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|,
literal|"Configuration saved to %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Configuration saved to %s (requested by %s)"
argument_list|,
name|fullpath
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * save the output filename in system variable 		 * savedconfig, retrieved with: 		 *   ntpq -c "rv 0 savedconfig" 		 */
name|snprintf
argument_list|(
name|savedconfig
argument_list|,
sizeof|sizeof
argument_list|(
name|savedconfig
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|savedconfig_eq
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|savedconfig
argument_list|,
name|strlen
argument_list|(
name|savedconfig
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|!=
name|fptr
condition|)
name|fclose
argument_list|(
name|fptr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SAVECONFIG follows */
name|snprintf
argument_list|(
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|,
literal|"saveconfig unavailable, configured with --disable-saveconfig"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_putdata
argument_list|(
name|reply
argument_list|,
name|strlen
argument_list|(
name|reply
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process_control - process an incoming control message  */
end_comment

begin_function
name|void
name|process_control
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|struct
name|ntp_control
modifier|*
name|pkt
decl_stmt|;
name|int
name|req_count
decl_stmt|;
name|int
name|req_data
decl_stmt|;
specifier|const
name|struct
name|ctl_proc
modifier|*
name|cc
decl_stmt|;
name|keyid_t
modifier|*
name|pkid
decl_stmt|;
name|int
name|properlen
decl_stmt|;
name|size_t
name|maclen
decl_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"in process_control()\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Save the addresses for error responses 	 */
name|numctlreq
operator|++
expr_stmt|;
name|rmt_addr
operator|=
operator|&
name|rbufp
operator|->
name|recv_srcadr
expr_stmt|;
name|lcl_inter
operator|=
name|rbufp
operator|->
name|dstadr
expr_stmt|;
name|pkt
operator|=
operator|(
expr|struct
name|ntp_control
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
comment|/* 	 * If the length is less than required for the header, or 	 * it is a response or a fragment, ignore this. 	 */
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|<
operator|(
name|int
operator|)
name|CTL_HEADER_LEN
operator|||
operator|(
name|CTL_RESPONSE
operator||
name|CTL_MORE
operator||
name|CTL_ERROR
operator|)
operator|&
name|pkt
operator|->
name|r_m_e_op
operator|||
name|pkt
operator|->
name|offset
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"invalid format in control packet\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|<
operator|(
name|int
operator|)
name|CTL_HEADER_LEN
condition|)
name|numctltooshort
operator|++
expr_stmt|;
if|if
condition|(
name|CTL_RESPONSE
operator|&
name|pkt
operator|->
name|r_m_e_op
condition|)
name|numctlinputresp
operator|++
expr_stmt|;
if|if
condition|(
name|CTL_MORE
operator|&
name|pkt
operator|->
name|r_m_e_op
condition|)
name|numctlinputfrag
operator|++
expr_stmt|;
if|if
condition|(
name|CTL_ERROR
operator|&
name|pkt
operator|->
name|r_m_e_op
condition|)
name|numctlinputerr
operator|++
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|offset
operator|!=
literal|0
condition|)
name|numctlbadoffset
operator|++
expr_stmt|;
return|return;
block|}
name|res_version
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_version
operator|>
name|NTP_VERSION
operator|||
name|res_version
operator|<
name|NTP_OLDVERSION
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"unknown version %d in control packet\n"
operator|,
name|res_version
operator|)
argument_list|)
expr_stmt|;
name|numctlbadversion
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Pull enough data from the packet to make intelligent 	 * responses 	 */
name|rpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|res_version
argument_list|,
name|MODE_CONTROL
argument_list|)
expr_stmt|;
name|res_opcode
operator|=
name|pkt
operator|->
name|r_m_e_op
expr_stmt|;
name|rpkt
operator|.
name|sequence
operator|=
name|pkt
operator|->
name|sequence
expr_stmt|;
name|rpkt
operator|.
name|associd
operator|=
name|pkt
operator|->
name|associd
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|res_frags
operator|=
literal|1
expr_stmt|;
name|res_offset
operator|=
literal|0
expr_stmt|;
name|res_associd
operator|=
name|htons
argument_list|(
name|pkt
operator|->
name|associd
argument_list|)
expr_stmt|;
name|res_async
operator|=
name|FALSE
expr_stmt|;
name|res_authenticate
operator|=
name|FALSE
expr_stmt|;
name|res_keyid
operator|=
literal|0
expr_stmt|;
name|res_authokay
operator|=
name|FALSE
expr_stmt|;
name|req_count
operator|=
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|pkt
operator|->
name|count
argument_list|)
expr_stmt|;
name|datanotbinflag
operator|=
name|FALSE
expr_stmt|;
name|datalinelen
operator|=
literal|0
expr_stmt|;
name|datasent
operator|=
literal|0
expr_stmt|;
name|datapt
operator|=
name|rpkt
operator|.
name|u
operator|.
name|data
expr_stmt|;
name|dataend
operator|=
operator|&
name|rpkt
operator|.
name|u
operator|.
name|data
index|[
name|CTL_MAX_DATA_LEN
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rbufp
operator|->
name|recv_length
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"Control packet length %d unrounded\n"
operator|,
name|rbufp
operator|->
name|recv_length
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We're set up now. Make sure we've got at least enough 	 * incoming data space to match the count. 	 */
name|req_data
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|CTL_HEADER_LEN
expr_stmt|;
if|if
condition|(
name|req_data
operator|<
name|req_count
operator|||
name|rbufp
operator|->
name|recv_length
operator|&
literal|0x3
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADFMT
argument_list|)
expr_stmt|;
name|numctldatatooshort
operator|++
expr_stmt|;
return|return;
block|}
name|properlen
operator|=
name|req_count
operator|+
name|CTL_HEADER_LEN
expr_stmt|;
comment|/* round up proper len to a 8 octet boundary */
name|properlen
operator|=
operator|(
name|properlen
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|maclen
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|properlen
expr_stmt|;
if|if
condition|(
operator|(
name|rbufp
operator|->
name|recv_length
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
name|maclen
operator|>=
name|MIN_MAC_LEN
operator|&&
name|maclen
operator|<=
name|MAX_MAC_LEN
operator|&&
name|sys_authenticate
condition|)
block|{
name|res_authenticate
operator|=
name|TRUE
expr_stmt|;
name|pkid
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pkt
operator|+
name|properlen
operator|)
expr_stmt|;
name|res_keyid
operator|=
name|ntohl
argument_list|(
operator|*
name|pkid
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"recv_len %d, properlen %d, wants auth with keyid %08x, MAC length=%zu\n"
operator|,
name|rbufp
operator|->
name|recv_length
operator|,
name|properlen
operator|,
name|res_keyid
operator|,
name|maclen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|res_keyid
argument_list|)
condition|)
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"invalid keyid %08x\n"
operator|,
name|res_keyid
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|authdecrypt
argument_list|(
name|res_keyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|pkt
argument_list|,
name|rbufp
operator|->
name|recv_length
operator|-
name|maclen
argument_list|,
name|maclen
argument_list|)
condition|)
block|{
name|res_authokay
operator|=
name|TRUE
expr_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"authenticated okay\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res_keyid
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"authentication failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set up translate pointers 	 */
name|reqpt
operator|=
operator|(
name|char
operator|*
operator|)
name|pkt
operator|->
name|u
operator|.
name|data
expr_stmt|;
name|reqend
operator|=
name|reqpt
operator|+
name|req_count
expr_stmt|;
comment|/* 	 * Look for the opcode processor 	 */
for|for
control|(
name|cc
operator|=
name|control_codes
init|;
name|cc
operator|->
name|control_code
operator|!=
name|NO_REQUEST
condition|;
name|cc
operator|++
control|)
block|{
if|if
condition|(
name|cc
operator|->
name|control_code
operator|==
name|res_opcode
condition|)
block|{
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"opcode %d, found command handler\n"
operator|,
name|res_opcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|->
name|flags
operator|==
name|AUTH
operator|&&
operator|(
operator|!
name|res_authokay
operator|||
name|res_keyid
operator|!=
name|ctl_auth_keyid
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
name|cc
operator|->
name|handler
call|)
argument_list|(
name|rbufp
argument_list|,
name|restrict_mask
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Can't find this one, return an error. 	 */
name|numctlbadop
operator|++
expr_stmt|;
name|ctl_error
argument_list|(
name|CERR_BADOP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ctlpeerstatus - return a status word for this peer  */
end_comment

begin_function
name|u_short
name|ctlpeerstatus
parameter_list|(
specifier|register
name|struct
name|peer
modifier|*
name|p
parameter_list|)
block|{
name|u_short
name|status
decl_stmt|;
name|status
operator|=
name|p
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|FLAG_CONFIG
operator|&
name|p
operator|->
name|flags
condition|)
name|status
operator||=
name|CTL_PST_CONFIG
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|keyid
condition|)
name|status
operator||=
name|CTL_PST_AUTHENABLE
expr_stmt|;
if|if
condition|(
name|FLAG_AUTHENTIC
operator|&
name|p
operator|->
name|flags
condition|)
name|status
operator||=
name|CTL_PST_AUTHENTIC
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|reach
condition|)
name|status
operator||=
name|CTL_PST_REACH
expr_stmt|;
if|if
condition|(
name|MDF_TXONLY_MASK
operator|&
name|p
operator|->
name|cast_flags
condition|)
name|status
operator||=
name|CTL_PST_BCAST
expr_stmt|;
return|return
name|CTL_PEER_STATUS
argument_list|(
name|status
argument_list|,
name|p
operator|->
name|num_events
argument_list|,
name|p
operator|->
name|last_event
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctlclkstatus - return a status word for this clock  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_function
specifier|static
name|u_short
name|ctlclkstatus
parameter_list|(
name|struct
name|refclockstat
modifier|*
name|pcs
parameter_list|)
block|{
return|return
name|CTL_PEER_STATUS
argument_list|(
literal|0
argument_list|,
name|pcs
operator|->
name|lastevent
argument_list|,
name|pcs
operator|->
name|currentstatus
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ctlsysstatus - return the system status word  */
end_comment

begin_function
name|u_short
name|ctlsysstatus
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|u_char
name|this_clock
decl_stmt|;
name|this_clock
operator|=
name|CTL_SST_TS_UNSPEC
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|sys_peer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CTL_SST_TS_UNSPEC
operator|!=
name|sys_peer
operator|->
name|sstclktype
condition|)
name|this_clock
operator|=
name|sys_peer
operator|->
name|sstclktype
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_peer
operator|->
name|refclktype
operator|<
name|COUNTOF
argument_list|(
name|clocktypes
argument_list|)
condition|)
name|this_clock
operator|=
name|clocktypes
index|[
name|sys_peer
operator|->
name|refclktype
index|]
expr_stmt|;
block|}
else|#
directive|else
comment|/* REFCLOCK */
if|if
condition|(
name|sys_peer
operator|!=
literal|0
condition|)
name|this_clock
operator|=
name|CTL_SST_TS_NTP
expr_stmt|;
endif|#
directive|endif
comment|/* REFCLOCK */
return|return
name|CTL_SYS_STATUS
argument_list|(
name|sys_leap
argument_list|,
name|this_clock
argument_list|,
name|ctl_sys_num_events
argument_list|,
name|ctl_sys_last_event
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctl_flushpkt - write out the current packet and prepare  *		  another if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_flushpkt
parameter_list|(
name|u_char
name|more
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|dlen
decl_stmt|;
name|int
name|sendlen
decl_stmt|;
name|int
name|maclen
decl_stmt|;
name|int
name|totlen
decl_stmt|;
name|keyid_t
name|keyid
decl_stmt|;
name|dlen
operator|=
name|datapt
operator|-
name|rpkt
operator|.
name|u
operator|.
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|more
operator|&&
name|datanotbinflag
operator|&&
name|dlen
operator|+
literal|2
operator|<
name|CTL_MAX_DATA_LEN
condition|)
block|{
comment|/* 		 * Big hack, output a trailing \r\n 		 */
operator|*
name|datapt
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|datapt
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|dlen
operator|+=
literal|2
expr_stmt|;
block|}
name|sendlen
operator|=
name|dlen
operator|+
name|CTL_HEADER_LEN
expr_stmt|;
comment|/* 	 * Pad to a multiple of 32 bits 	 */
while|while
condition|(
name|sendlen
operator|&
literal|0x3
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sendlen
operator|++
expr_stmt|;
block|}
comment|/* 	 * Fill in the packet with the current info 	 */
name|rpkt
operator|.
name|r_m_e_op
operator|=
name|CTL_RESPONSE
operator||
name|more
operator||
operator|(
name|res_opcode
operator|&
name|CTL_OP_MASK
operator|)
expr_stmt|;
name|rpkt
operator|.
name|count
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|dlen
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|offset
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|res_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_async
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|ctl_traps
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TRAP_INUSE
operator|&
name|ctl_traps
index|[
name|i
index|]
operator|.
name|tr_flags
condition|)
block|{
name|rpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|ctl_traps
index|[
name|i
index|]
operator|.
name|tr_version
argument_list|,
name|MODE_CONTROL
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|sequence
operator|=
name|htons
argument_list|(
name|ctl_traps
index|[
name|i
index|]
operator|.
name|tr_sequence
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|ctl_traps
index|[
name|i
index|]
operator|.
name|tr_addr
argument_list|,
name|ctl_traps
index|[
name|i
index|]
operator|.
name|tr_localaddr
argument_list|,
operator|-
literal|4
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|more
condition|)
name|ctl_traps
index|[
name|i
index|]
operator|.
name|tr_sequence
operator|++
expr_stmt|;
name|numasyncmsgs
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|res_authenticate
operator|&&
name|sys_authenticate
condition|)
block|{
name|totlen
operator|=
name|sendlen
expr_stmt|;
comment|/* 			 * If we are going to authenticate, then there 			 * is an additional requirement that the MAC 			 * begin on a 64 bit boundary. 			 */
while|while
condition|(
name|totlen
operator|&
literal|7
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|totlen
operator|++
expr_stmt|;
block|}
name|keyid
operator|=
name|htonl
argument_list|(
name|res_keyid
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|datapt
argument_list|,
operator|&
name|keyid
argument_list|,
sizeof|sizeof
argument_list|(
name|keyid
argument_list|)
argument_list|)
expr_stmt|;
name|maclen
operator|=
name|authencrypt
argument_list|(
name|res_keyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|-
literal|5
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|totlen
operator|+
name|maclen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|-
literal|6
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|more
condition|)
name|numctlfrags
operator|++
expr_stmt|;
else|else
name|numctlresponses
operator|++
expr_stmt|;
block|}
comment|/* 	 * Set us up for another go around. 	 */
name|res_frags
operator|++
expr_stmt|;
name|res_offset
operator|+=
name|dlen
expr_stmt|;
name|datapt
operator|=
name|rpkt
operator|.
name|u
operator|.
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putdata - write data into the packet, fragmenting and starting  * another if this one is full.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putdata
parameter_list|(
specifier|const
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|int
name|dlen
parameter_list|,
name|int
name|bin
comment|/* set to 1 when data is binary */
parameter_list|)
block|{
name|int
name|overhead
decl_stmt|;
name|unsigned
name|int
name|currentlen
decl_stmt|;
name|overhead
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bin
condition|)
block|{
name|datanotbinflag
operator|=
name|TRUE
expr_stmt|;
name|overhead
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|datasent
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|','
expr_stmt|;
name|datalinelen
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dlen
operator|+
name|datalinelen
operator|+
literal|1
operator|)
operator|>=
name|MAXDATALINELEN
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|datapt
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|datalinelen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|datapt
operator|++
operator|=
literal|' '
expr_stmt|;
name|datalinelen
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Save room for trailing junk 	 */
while|while
condition|(
name|dlen
operator|+
name|overhead
operator|+
name|datapt
operator|>
name|dataend
condition|)
block|{
comment|/* 		 * Not enough room in this one, flush it out. 		 */
name|currentlen
operator|=
name|MIN
argument_list|(
name|dlen
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|dataend
operator|-
name|datapt
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|datapt
argument_list|,
name|dp
argument_list|,
name|currentlen
argument_list|)
expr_stmt|;
name|datapt
operator|+=
name|currentlen
expr_stmt|;
name|dp
operator|+=
name|currentlen
expr_stmt|;
name|dlen
operator|-=
name|currentlen
expr_stmt|;
name|datalinelen
operator|+=
name|currentlen
expr_stmt|;
name|ctl_flushpkt
argument_list|(
name|CTL_MORE
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|datapt
argument_list|,
name|dp
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|datapt
operator|+=
name|dlen
expr_stmt|;
name|datalinelen
operator|+=
name|dlen
expr_stmt|;
name|datasent
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putstr - write a tagged string into the response packet  *		in the form:  *  *		tag="data"  *  *		len is the data length excluding the NUL terminator,  *		as in ctl_putstr("var", "value", strlen("value"));  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putstr
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|tl
decl_stmt|;
name|tl
operator|=
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|tag
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
operator|+
name|tl
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|NTP_INSIST
argument_list|(
name|tl
operator|+
literal|3
operator|+
name|len
operator|<=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'"'
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'"'
expr_stmt|;
block|}
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putunqstr - write a tagged string into the response packet  *		   in the form:  *  *		   tag=data  *  *	len is the data length excluding the NUL terminator.  *	data must not contain a comma or whitespace.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putunqstr
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|tl
decl_stmt|;
name|tl
operator|=
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|tag
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
operator|+
name|tl
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|NTP_INSIST
argument_list|(
name|tl
operator|+
literal|1
operator|+
name|len
operator|<=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
block|}
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putdblf - write a tagged, signed double into the response packet  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putdblf
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|int
name|use_f
parameter_list|,
name|int
name|precision
parameter_list|,
name|double
name|d
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|NTP_INSIST
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
argument_list|,
name|use_f
condition|?
literal|"%.*f"
else|:
literal|"%.*g"
argument_list|,
name|precision
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putuint - write a tagged unsigned integer into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putuint
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|u_long
name|uval
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|NTP_INSIST
argument_list|(
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
argument_list|,
literal|"%lu"
argument_list|,
name|uval
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putcal - write a decoded calendar data into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putcal
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|struct
name|calendar
modifier|*
name|pcal
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|unsigned
name|numch
decl_stmt|;
name|numch
operator|=
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s=%04d%02d%02d%02d%02d"
argument_list|,
name|tag
argument_list|,
name|pcal
operator|->
name|year
argument_list|,
name|pcal
operator|->
name|month
argument_list|,
name|pcal
operator|->
name|monthday
argument_list|,
name|pcal
operator|->
name|hour
argument_list|,
name|pcal
operator|->
name|minute
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|numch
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|numch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ctl_putfs - write a decoded filestamp into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putfs
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|tstamp_t
name|uval
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
init|=
name|NULL
decl_stmt|;
name|time_t
name|fstamp
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|fstamp
operator|=
name|uval
operator|-
name|JAN_1970
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|tm
condition|)
return|return;
name|NTP_INSIST
argument_list|(
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
argument_list|,
literal|"%04d%02d%02d%02d%02d"
argument_list|,
name|tm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_puthex - write a tagged unsigned integer, in hex, into the  * response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_puthex
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|u_long
name|uval
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|NTP_INSIST
argument_list|(
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
argument_list|,
literal|"0x%lx"
argument_list|,
name|uval
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putint - write a tagged signed integer into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putint
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|long
name|ival
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|NTP_INSIST
argument_list|(
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
argument_list|,
literal|"%ld"
argument_list|,
name|ival
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putts - write a tagged timestamp, in hex, into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putts
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|l_fp
modifier|*
name|ts
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|NTP_INSIST
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
argument_list|,
literal|"0x%08x.%08x"
argument_list|,
operator|(
name|u_int
operator|)
name|ts
operator|->
name|l_ui
argument_list|,
operator|(
name|u_int
operator|)
name|ts
operator|->
name|l_uf
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putadr - write an IP address into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putadr
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|u_int32
name|addr32
parameter_list|,
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|addr
condition|)
name|cq
operator|=
name|numtoa
argument_list|(
name|addr32
argument_list|)
expr_stmt|;
else|else
name|cq
operator|=
name|stoa
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
argument_list|,
literal|"%s"
argument_list|,
name|cq
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putrefid - send a u_int32 refid as printable text  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putrefid
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|u_int32
name|refid
parameter_list|)
block|{
name|char
name|output
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|optr
decl_stmt|;
name|char
modifier|*
name|oplim
decl_stmt|;
name|char
modifier|*
name|iptr
decl_stmt|;
name|char
modifier|*
name|iplim
decl_stmt|;
name|char
modifier|*
name|past_eq
decl_stmt|;
name|optr
operator|=
name|output
expr_stmt|;
name|oplim
operator|=
name|output
operator|+
sizeof|sizeof
argument_list|(
name|output
argument_list|)
expr_stmt|;
while|while
condition|(
name|optr
operator|<
name|oplim
operator|&&
literal|'\0'
operator|!=
operator|*
name|tag
condition|)
operator|*
name|optr
operator|++
operator|=
operator|*
name|tag
operator|++
expr_stmt|;
if|if
condition|(
name|optr
operator|<
name|oplim
condition|)
block|{
operator|*
name|optr
operator|++
operator|=
literal|'='
expr_stmt|;
name|past_eq
operator|=
name|optr
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|optr
operator|<
name|oplim
operator|)
condition|)
return|return;
name|iptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|refid
expr_stmt|;
name|iplim
operator|=
name|iptr
operator|+
sizeof|sizeof
argument_list|(
name|refid
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|optr
operator|<
name|oplim
operator|&&
name|iptr
operator|<
name|iplim
operator|&&
literal|'\0'
operator|!=
operator|*
name|iptr
condition|;
name|iptr
operator|++
operator|,
name|optr
operator|++
control|)
if|if
condition|(
name|isprint
argument_list|(
operator|(
name|int
operator|)
operator|*
name|iptr
argument_list|)
condition|)
operator|*
name|optr
operator|=
operator|*
name|iptr
expr_stmt|;
else|else
operator|*
name|optr
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|optr
operator|<=
name|oplim
operator|)
condition|)
name|optr
operator|=
name|past_eq
expr_stmt|;
name|ctl_putdata
argument_list|(
name|output
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|optr
operator|-
name|output
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putarray - write a tagged eight element double array into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putarray
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|double
modifier|*
name|arr
parameter_list|,
name|int
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
do|do
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|NTP_SHIFT
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|NTP_INSIST
argument_list|(
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
argument_list|,
literal|" %.2f"
argument_list|,
name|arr
index|[
name|i
index|]
operator|*
literal|1e3
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|start
condition|)
do|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putsys - output a system variable  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putsys
parameter_list|(
name|int
name|varid
parameter_list|)
block|{
name|l_fp
name|tmp
decl_stmt|;
name|char
name|str
index|[
literal|256
index|]
decl_stmt|;
name|u_int
name|u
decl_stmt|;
name|double
name|kb
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
specifier|const
name|char
modifier|*
name|ss
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|struct
name|cert_info
modifier|*
name|cp
decl_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
ifdef|#
directive|ifdef
name|KERNEL_PLL
specifier|static
name|struct
name|timex
name|ntx
decl_stmt|;
specifier|static
name|u_long
name|ntp_adjtime_time
decl_stmt|;
specifier|static
specifier|const
name|double
name|to_ms
init|=
ifdef|#
directive|ifdef
name|STA_NANO
literal|1.0e-6
decl_stmt|;
comment|/* nsec to msec */
else|#
directive|else
literal|1.0e-3
expr_stmt|;
comment|/* usec to msec */
endif|#
directive|endif
comment|/* 	 * CS_K_* variables depend on up-to-date output of ntp_adjtime() 	 */
if|if
condition|(
name|CS_KERN_FIRST
operator|<=
name|varid
operator|&&
name|varid
operator|<=
name|CS_KERN_LAST
operator|&&
name|current_time
operator|!=
name|ntp_adjtime_time
condition|)
block|{
name|ZERO
argument_list|(
name|ntx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntp_adjtime
argument_list|(
operator|&
name|ntx
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ntp_adjtime() for mode 6 query failed: %m"
argument_list|)
expr_stmt|;
else|else
name|ntp_adjtime_time
operator|=
name|current_time
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* KERNEL_PLL */
switch|switch
condition|(
name|varid
condition|)
block|{
case|case
name|CS_LEAP
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_LEAP
index|]
operator|.
name|text
argument_list|,
name|sys_leap
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_STRATUM
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_STRATUM
index|]
operator|.
name|text
argument_list|,
name|sys_stratum
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PRECISION
case|:
name|ctl_putint
argument_list|(
name|sys_var
index|[
name|CS_PRECISION
index|]
operator|.
name|text
argument_list|,
name|sys_precision
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_ROOTDELAY
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_ROOTDELAY
index|]
operator|.
name|text
argument_list|,
name|sys_rootdelay
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_ROOTDISPERSION
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_ROOTDISPERSION
index|]
operator|.
name|text
argument_list|,
name|sys_rootdisp
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_REFID
case|:
if|if
condition|(
name|sys_stratum
operator|>
literal|1
operator|&&
name|sys_stratum
operator|<
name|STRATUM_UNSPEC
condition|)
name|ctl_putadr
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_refid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ctl_putrefid
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_refid
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_REFTIME
case|:
name|ctl_putts
argument_list|(
name|sys_var
index|[
name|CS_REFTIME
index|]
operator|.
name|text
argument_list|,
operator|&
name|sys_reftime
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_POLL
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_POLL
index|]
operator|.
name|text
argument_list|,
name|sys_poll
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PEERID
case|:
if|if
condition|(
name|sys_peer
operator|==
name|NULL
condition|)
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_PEERID
index|]
operator|.
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_PEERID
index|]
operator|.
name|text
argument_list|,
name|sys_peer
operator|->
name|associd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PEERADR
case|:
if|if
condition|(
name|sys_peer
operator|!=
name|NULL
operator|&&
name|sys_peer
operator|->
name|dstadr
operator|!=
name|NULL
condition|)
name|ss
operator|=
name|sptoa
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
else|else
name|ss
operator|=
literal|"0.0.0.0:0"
expr_stmt|;
name|ctl_putunqstr
argument_list|(
name|sys_var
index|[
name|CS_PEERADR
index|]
operator|.
name|text
argument_list|,
name|ss
argument_list|,
name|strlen
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PEERMODE
case|:
name|u
operator|=
operator|(
name|sys_peer
operator|!=
name|NULL
operator|)
condition|?
name|sys_peer
operator|->
name|hmode
else|:
name|MODE_UNSPEC
expr_stmt|;
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_PEERMODE
index|]
operator|.
name|text
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_OFFSET
case|:
name|ctl_putdbl6
argument_list|(
name|sys_var
index|[
name|CS_OFFSET
index|]
operator|.
name|text
argument_list|,
name|last_offset
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_DRIFT
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_DRIFT
index|]
operator|.
name|text
argument_list|,
name|drift_comp
operator|*
literal|1e6
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_JITTER
case|:
name|ctl_putdbl6
argument_list|(
name|sys_var
index|[
name|CS_JITTER
index|]
operator|.
name|text
argument_list|,
name|sys_jitter
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_ERROR
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_ERROR
index|]
operator|.
name|text
argument_list|,
name|clock_jitter
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_CLOCK
case|:
name|get_systime
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|ctl_putts
argument_list|(
name|sys_var
index|[
name|CS_CLOCK
index|]
operator|.
name|text
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PROCESSOR
case|:
ifndef|#
directive|ifndef
name|HAVE_UNAME
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_PROCESSOR
index|]
operator|.
name|text
argument_list|,
name|str_processor
argument_list|,
sizeof|sizeof
argument_list|(
name|str_processor
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_PROCESSOR
index|]
operator|.
name|text
argument_list|,
name|utsnamebuf
operator|.
name|machine
argument_list|,
name|strlen
argument_list|(
name|utsnamebuf
operator|.
name|machine
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_UNAME */
break|break;
case|case
name|CS_SYSTEM
case|:
ifndef|#
directive|ifndef
name|HAVE_UNAME
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_SYSTEM
index|]
operator|.
name|text
argument_list|,
name|str_system
argument_list|,
sizeof|sizeof
argument_list|(
name|str_system
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|utsnamebuf
operator|.
name|sysname
argument_list|,
name|utsnamebuf
operator|.
name|release
argument_list|)
expr_stmt|;
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_SYSTEM
index|]
operator|.
name|text
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_UNAME */
break|break;
case|case
name|CS_VERSION
case|:
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_VERSION
index|]
operator|.
name|text
argument_list|,
name|Version
argument_list|,
name|strlen
argument_list|(
name|Version
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_STABIL
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|CS_STABIL
index|]
operator|.
name|text
argument_list|,
name|clock_stability
operator|*
literal|1e6
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_VARLIST
case|:
block|{
name|char
name|buf
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
comment|//buffPointer, firstElementPointer, buffEndPointer
name|char
modifier|*
name|buffp
decl_stmt|,
modifier|*
name|buffend
decl_stmt|;
name|int
name|firstVarName
decl_stmt|;
specifier|const
name|char
modifier|*
name|ss1
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|buffp
operator|=
name|buf
expr_stmt|;
name|buffend
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffp
operator|+
name|strlen
argument_list|(
name|sys_var
index|[
name|CS_VARLIST
index|]
operator|.
name|text
argument_list|)
operator|+
literal|4
operator|>
name|buffend
condition|)
break|break;
comment|/* really long var name */
name|snprintf
argument_list|(
name|buffp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s=\""
argument_list|,
name|sys_var
index|[
name|CS_VARLIST
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|buffp
operator|+=
name|strlen
argument_list|(
name|buffp
argument_list|)
expr_stmt|;
name|firstVarName
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|k
operator|=
name|sys_var
init|;
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|len
operator|=
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffp
operator|+
name|len
operator|+
literal|1
operator|>=
name|buffend
condition|)
break|break;
if|if
condition|(
operator|!
name|firstVarName
condition|)
operator|*
name|buffp
operator|++
operator|=
literal|','
expr_stmt|;
else|else
name|firstVarName
operator|=
name|FALSE
expr_stmt|;
name|memcpy
argument_list|(
name|buffp
argument_list|,
name|k
operator|->
name|text
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buffp
operator|+=
name|len
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|ext_sys_var
init|;
name|k
operator|&&
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
if|if
condition|(
name|NULL
operator|==
name|k
operator|->
name|text
condition|)
continue|continue;
name|ss1
operator|=
name|strchr
argument_list|(
name|k
operator|->
name|text
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ss1
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|ss1
operator|-
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|buffp
operator|+
name|len
operator|+
literal|1
operator|>=
name|buffend
condition|)
break|break;
if|if
condition|(
name|firstVarName
condition|)
block|{
operator|*
name|buffp
operator|++
operator|=
literal|','
expr_stmt|;
name|firstVarName
operator|=
name|FALSE
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buffp
argument_list|,
name|k
operator|->
name|text
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|buffp
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|buffp
operator|+
literal|2
operator|>=
name|buffend
condition|)
break|break;
operator|*
name|buffp
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|buffp
operator|=
literal|'\0'
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buf
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|buffp
operator|-
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CS_TAI
case|:
if|if
condition|(
name|sys_tai
operator|>
literal|0
condition|)
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_TAI
index|]
operator|.
name|text
argument_list|,
name|sys_tai
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_LEAPTAB
case|:
block|{
name|leap_signature_t
name|lsig
decl_stmt|;
name|leapsec_getsig
argument_list|(
operator|&
name|lsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsig
operator|.
name|ttime
operator|>
literal|0
condition|)
name|ctl_putfs
argument_list|(
name|sys_var
index|[
name|CS_LEAPTAB
index|]
operator|.
name|text
argument_list|,
name|lsig
operator|.
name|ttime
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CS_LEAPEND
case|:
block|{
name|leap_signature_t
name|lsig
decl_stmt|;
name|leapsec_getsig
argument_list|(
operator|&
name|lsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsig
operator|.
name|etime
operator|>
literal|0
condition|)
name|ctl_putfs
argument_list|(
name|sys_var
index|[
name|CS_LEAPEND
index|]
operator|.
name|text
argument_list|,
name|lsig
operator|.
name|etime
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CS_RATE
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_RATE
index|]
operator|.
name|text
argument_list|,
name|ntp_minpoll
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_MRU_ENABLED
case|:
name|ctl_puthex
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|mon_enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_MRU_DEPTH
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|mru_entries
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_MRU_MEM
case|:
name|kb
operator|=
name|mru_entries
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|mon_entry
argument_list|)
operator|/
literal|1024.
operator|)
expr_stmt|;
name|u
operator|=
operator|(
name|u_int
operator|)
name|kb
expr_stmt|;
if|if
condition|(
name|kb
operator|-
name|u
operator|>=
literal|0.5
condition|)
name|u
operator|++
expr_stmt|;
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_MRU_DEEPEST
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|mru_peakentries
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_MRU_MINDEPTH
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|mru_mindepth
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_MRU_MAXAGE
case|:
name|ctl_putint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|mru_maxage
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_MRU_MAXDEPTH
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|mru_maxdepth
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_MRU_MAXMEM
case|:
name|kb
operator|=
name|mru_maxdepth
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|mon_entry
argument_list|)
operator|/
literal|1024.
operator|)
expr_stmt|;
name|u
operator|=
operator|(
name|u_int
operator|)
name|kb
expr_stmt|;
if|if
condition|(
name|kb
operator|-
name|u
operator|>=
literal|0.5
condition|)
name|u
operator|++
expr_stmt|;
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_UPTIME
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|current_time
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_RESET
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|current_time
operator|-
name|sys_stattime
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_RECEIVED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_received
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_THISVER
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_newversion
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_OLDVER
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_oldversion
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_BADFORMAT
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_badlength
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_BADAUTH
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_badauth
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_DECLINED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_declined
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_RESTRICTED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_restricted
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_LIMITED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_limitrejected
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_KODSENT
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_kodsent
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SS_PROCESSED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_processed
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_BCASTDELAY
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_bdelay
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_AUTHDELAY
case|:
name|LFPTOD
argument_list|(
operator|&
name|sys_authdelay
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|dtemp
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_AUTHKEYS
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|authnumkeys
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_AUTHFREEK
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|authnumfreekeys
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_AUTHKLOOKUPS
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|authkeylookups
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_AUTHKNOTFOUND
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|authkeynotfound
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_AUTHKUNCACHED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|authkeyuncached
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_AUTHKEXPIRED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|authkeyexpired
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_AUTHENCRYPTS
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|authencryptions
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_AUTHDECRYPTS
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|authdecryptions
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_AUTHRESET
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|current_time
operator|-
name|auth_timereset
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * CTL_IF_KERNLOOP() puts a zero if the kernel loop is 		 * unavailable, otherwise calls putfunc with args. 		 */
ifndef|#
directive|ifndef
name|KERNEL_PLL
define|#
directive|define
name|CTL_IF_KERNLOOP
parameter_list|(
name|putfunc
parameter_list|,
name|args
parameter_list|)
define|\
value|ctl_putint(sys_var[varid].text, 0)
else|#
directive|else
define|#
directive|define
name|CTL_IF_KERNLOOP
parameter_list|(
name|putfunc
parameter_list|,
name|args
parameter_list|)
define|\
value|putfunc args
endif|#
directive|endif
comment|/* 		 * CTL_IF_KERNPPS() puts a zero if either the kernel 		 * loop is unavailable, or kernel hard PPS is not 		 * active, otherwise calls putfunc with args. 		 */
ifndef|#
directive|ifndef
name|KERNEL_PLL
define|#
directive|define
name|CTL_IF_KERNPPS
parameter_list|(
name|putfunc
parameter_list|,
name|args
parameter_list|)
define|\
value|ctl_putint(sys_var[varid].text, 0)
else|#
directive|else
define|#
directive|define
name|CTL_IF_KERNPPS
parameter_list|(
name|putfunc
parameter_list|,
name|args
parameter_list|)
define|\
value|if (0 == ntx.shift)				\ 			ctl_putint(sys_var[varid].text, 0);	\ 		else						\ 			putfunc args
comment|/* no trailing ; */
endif|#
directive|endif
case|case
name|CS_K_OFFSET
case|:
name|CTL_IF_KERNLOOP
argument_list|(
name|ctl_putdblf
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
literal|0
operator|,
operator|-
literal|1
operator|,
name|to_ms
operator|*
name|ntx
operator|.
name|offset
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_FREQ
case|:
name|CTL_IF_KERNLOOP
argument_list|(
name|ctl_putsfp
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
name|ntx
operator|.
name|freq
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_MAXERR
case|:
name|CTL_IF_KERNLOOP
argument_list|(
name|ctl_putdblf
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
literal|0
operator|,
literal|6
operator|,
name|to_ms
operator|*
name|ntx
operator|.
name|maxerror
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_ESTERR
case|:
name|CTL_IF_KERNLOOP
argument_list|(
name|ctl_putdblf
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
literal|0
operator|,
literal|6
operator|,
name|to_ms
operator|*
name|ntx
operator|.
name|esterror
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_STFLAGS
case|:
ifndef|#
directive|ifndef
name|KERNEL_PLL
name|ss
operator|=
literal|""
expr_stmt|;
else|#
directive|else
name|ss
operator|=
name|k_st_flags
argument_list|(
name|ntx
operator|.
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|ss
argument_list|,
name|strlen
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_TIMECONST
case|:
name|CTL_IF_KERNLOOP
argument_list|(
name|ctl_putint
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
name|ntx
operator|.
name|constant
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_PRECISION
case|:
name|CTL_IF_KERNLOOP
argument_list|(
name|ctl_putdblf
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
literal|0
operator|,
literal|6
operator|,
name|to_ms
operator|*
name|ntx
operator|.
name|precision
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_FREQTOL
case|:
name|CTL_IF_KERNLOOP
argument_list|(
name|ctl_putsfp
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
name|ntx
operator|.
name|tolerance
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_PPS_FREQ
case|:
name|CTL_IF_KERNPPS
argument_list|(
name|ctl_putsfp
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
name|ntx
operator|.
name|ppsfreq
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_PPS_STABIL
case|:
name|CTL_IF_KERNPPS
argument_list|(
name|ctl_putsfp
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
name|ntx
operator|.
name|stabil
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_PPS_JITTER
case|:
name|CTL_IF_KERNPPS
argument_list|(
name|ctl_putdbl
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
name|to_ms
operator|*
name|ntx
operator|.
name|jitter
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_PPS_CALIBDUR
case|:
name|CTL_IF_KERNPPS
argument_list|(
name|ctl_putint
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
literal|1
operator|<<
name|ntx
operator|.
name|shift
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_PPS_CALIBS
case|:
name|CTL_IF_KERNPPS
argument_list|(
name|ctl_putint
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
name|ntx
operator|.
name|calcnt
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_PPS_CALIBERRS
case|:
name|CTL_IF_KERNPPS
argument_list|(
name|ctl_putint
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
name|ntx
operator|.
name|errcnt
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_PPS_JITEXC
case|:
name|CTL_IF_KERNPPS
argument_list|(
name|ctl_putint
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
name|ntx
operator|.
name|jitcnt
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_K_PPS_STBEXC
case|:
name|CTL_IF_KERNPPS
argument_list|(
name|ctl_putint
argument_list|,
operator|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
operator|,
name|ntx
operator|.
name|stbcnt
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_IOSTATS_RESET
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|current_time
operator|-
name|io_timereset
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_TOTAL_RBUF
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|total_recvbuffs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_FREE_RBUF
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|free_recvbuffs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_USED_RBUF
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|full_recvbuffs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_RBUF_LOWATER
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|lowater_additions
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_IO_DROPPED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|packets_dropped
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_IO_IGNORED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|packets_ignored
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_IO_RECEIVED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|packets_received
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_IO_SENT
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|packets_sent
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_IO_SENDFAILED
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|packets_notsent
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_IO_WAKEUPS
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|handler_calls
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_IO_GOODWAKEUPS
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|handler_pkts
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_TIMERSTATS_RESET
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|current_time
operator|-
name|timer_timereset
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_TIMER_OVERRUNS
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|alarm_overflow
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_TIMER_XMTS
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|timer_xmtcalls
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_FUZZ
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|sys_fuzz
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_WANDER_THRESH
case|:
name|ctl_putdbl
argument_list|(
name|sys_var
index|[
name|varid
index|]
operator|.
name|text
argument_list|,
name|wander_threshold
operator|*
literal|1e6
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|AUTOKEY
case|case
name|CS_FLAGS
case|:
if|if
condition|(
name|crypto_flags
condition|)
name|ctl_puthex
argument_list|(
name|sys_var
index|[
name|CS_FLAGS
index|]
operator|.
name|text
argument_list|,
name|crypto_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_DIGEST
case|:
if|if
condition|(
name|crypto_flags
condition|)
block|{
name|strlcpy
argument_list|(
name|str
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|crypto_nid
argument_list|)
argument_list|,
name|COUNTOF
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_DIGEST
index|]
operator|.
name|text
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CS_SIGNATURE
case|:
if|if
condition|(
name|crypto_flags
condition|)
block|{
specifier|const
name|EVP_MD
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|EVP_get_digestbynid
argument_list|(
name|crypto_flags
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|str
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|EVP_MD_pkey_type
argument_list|(
name|dp
argument_list|)
argument_list|)
argument_list|,
name|COUNTOF
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_SIGNATURE
index|]
operator|.
name|text
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CS_HOST
case|:
if|if
condition|(
name|hostval
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_HOST
index|]
operator|.
name|text
argument_list|,
name|hostval
operator|.
name|ptr
argument_list|,
name|strlen
argument_list|(
name|hostval
operator|.
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_IDENT
case|:
if|if
condition|(
name|sys_ident
operator|!=
name|NULL
condition|)
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_IDENT
index|]
operator|.
name|text
argument_list|,
name|sys_ident
argument_list|,
name|strlen
argument_list|(
name|sys_ident
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_CERTIF
case|:
for|for
control|(
name|cp
operator|=
name|cinfo
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|cp
operator|->
name|link
control|)
block|{
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%s %s 0x%x"
argument_list|,
name|cp
operator|->
name|subject
argument_list|,
name|cp
operator|->
name|issuer
argument_list|,
name|cp
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_CERTIF
index|]
operator|.
name|text
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_putcal
argument_list|(
name|sys_var
index|[
name|CS_REVTIME
index|]
operator|.
name|text
argument_list|,
operator|&
operator|(
name|cp
operator|->
name|last
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CS_PUBLIC
case|:
if|if
condition|(
name|hostval
operator|.
name|tstamp
operator|!=
literal|0
condition|)
name|ctl_putfs
argument_list|(
name|sys_var
index|[
name|CS_PUBLIC
index|]
operator|.
name|text
argument_list|,
name|ntohl
argument_list|(
name|hostval
operator|.
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* AUTOKEY */
block|}
block|}
end_function

begin_comment
comment|/*  * ctl_putpeer - output a peer variable  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putpeer
parameter_list|(
name|int
name|id
parameter_list|,
name|struct
name|peer
modifier|*
name|p
parameter_list|)
block|{
name|char
name|buf
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|be
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|struct
name|autokey
modifier|*
name|ap
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|dp
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|CP_CONFIG
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
operator|!
operator|(
name|FLAG_PREEMPT
operator|&
name|p
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_AUTHENABLE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
operator|!
operator|(
name|p
operator|->
name|keyid
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_AUTHENTIC
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
operator|!
operator|!
operator|(
name|FLAG_AUTHENTIC
operator|&
name|p
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SRCADR
case|:
name|ctl_putadr
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
literal|0
argument_list|,
operator|&
name|p
operator|->
name|srcadr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SRCPORT
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|SRCPORT
argument_list|(
operator|&
name|p
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SRCHOST
case|:
if|if
condition|(
name|p
operator|->
name|hostname
operator|!=
name|NULL
condition|)
name|ctl_putstr
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|hostname
argument_list|,
name|strlen
argument_list|(
name|p
operator|->
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DSTADR
case|:
name|ctl_putadr
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
literal|0
argument_list|,
operator|(
name|p
operator|->
name|dstadr
operator|!=
name|NULL
operator|)
condition|?
operator|&
name|p
operator|->
name|dstadr
operator|->
name|sin
else|:
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DSTPORT
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
operator|(
name|p
operator|->
name|dstadr
operator|!=
name|NULL
operator|)
condition|?
name|SRCPORT
argument_list|(
operator|&
name|p
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_IN
case|:
if|if
condition|(
name|p
operator|->
name|r21
operator|>
literal|0.
condition|)
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|r21
operator|/
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_OUT
case|:
if|if
condition|(
name|p
operator|->
name|r34
operator|>
literal|0.
condition|)
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|r34
operator|/
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_RATE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|throttle
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_LEAP
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|leap
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_HMODE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|hmode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_STRATUM
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|stratum
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_PPOLL
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|ppoll
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_HPOLL
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|hpoll
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_PRECISION
case|:
name|ctl_putint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|precision
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ROOTDELAY
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|rootdelay
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ROOTDISPERSION
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|rootdisp
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REFID
case|:
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
block|{
name|ctl_putrefid
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|refid
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|stratum
operator|>
literal|1
operator|&&
name|p
operator|->
name|stratum
operator|<
name|STRATUM_UNSPEC
condition|)
name|ctl_putadr
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|refid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ctl_putrefid
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|refid
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REFTIME
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
operator|&
name|p
operator|->
name|reftime
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ORG
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
operator|&
name|p
operator|->
name|aorg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REC
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
operator|&
name|p
operator|->
name|dst
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_XMT
case|:
if|if
condition|(
name|p
operator|->
name|xleave
condition|)
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|xleave
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_BIAS
case|:
if|if
condition|(
name|p
operator|->
name|bias
operator|!=
literal|0.
condition|)
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|bias
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REACH
case|:
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|reach
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FLASH
case|:
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|flash
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_TTL
case|:
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
block|{
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|ttl
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|ttl
operator|>
literal|0
operator|&&
name|p
operator|->
name|ttl
operator|<
name|COUNTOF
argument_list|(
name|sys_ttl
argument_list|)
condition|)
name|ctl_putint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|sys_ttl
index|[
name|p
operator|->
name|ttl
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_UNREACH
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|unreach
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_TIMER
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|nextdate
operator|-
name|current_time
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DELAY
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|delay
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_OFFSET
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|offset
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_JITTER
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|jitter
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DISPERSION
case|:
name|ctl_putdbl
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|disp
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_KEYID
case|:
if|if
condition|(
name|p
operator|->
name|keyid
operator|>
name|NTP_MAXKEY
condition|)
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|keyid
argument_list|)
expr_stmt|;
else|else
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|keyid
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FILTDELAY
case|:
name|ctl_putarray
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|filter_delay
argument_list|,
name|p
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FILTOFFSET
case|:
name|ctl_putarray
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|filter_offset
argument_list|,
name|p
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FILTERROR
case|:
name|ctl_putarray
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|filter_disp
argument_list|,
name|p
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_PMODE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|pmode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_RECEIVED
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|received
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SENT
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|sent
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_VARLIST
case|:
name|s
operator|=
name|buf
expr_stmt|;
name|be
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|)
operator|+
literal|4
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
break|break;
comment|/* really long var name */
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s=\""
argument_list|,
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
for|for
control|(
name|k
operator|=
name|peer_var
init|;
operator|!
operator|(
name|EOV
operator|&
name|k
operator|->
name|flags
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|PADDING
operator|&
name|k
operator|->
name|flags
condition|)
continue|continue;
name|i
operator|=
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|+
literal|2
operator|<
name|be
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buf
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|s
operator|-
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CP_TIMEREC
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|current_time
operator|-
name|p
operator|->
name|timereceived
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_TIMEREACH
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|current_time
operator|-
name|p
operator|->
name|timereachable
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_BADAUTH
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|badauth
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_BOGUSORG
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|bogusorg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_OLDPKT
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|oldpkt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SELDISP
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|seldisptoolarge
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SELBROKEN
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|selbroken
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_CANDIDATE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|status
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|AUTOKEY
case|case
name|CP_FLAGS
case|:
if|if
condition|(
name|p
operator|->
name|crypto
condition|)
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|crypto
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SIGNATURE
case|:
if|if
condition|(
name|p
operator|->
name|crypto
condition|)
block|{
name|dp
operator|=
name|EVP_get_digestbynid
argument_list|(
name|p
operator|->
name|crypto
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|str
operator|=
name|OBJ_nid2ln
argument_list|(
name|EVP_MD_pkey_type
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_putstr
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CP_HOST
case|:
if|if
condition|(
name|p
operator|->
name|subject
operator|!=
name|NULL
condition|)
name|ctl_putstr
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|subject
argument_list|,
name|strlen
argument_list|(
name|p
operator|->
name|subject
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_VALID
case|:
comment|/* not used */
break|break;
case|case
name|CP_INITSEQ
case|:
if|if
condition|(
name|NULL
operator|==
operator|(
name|ap
operator|=
name|p
operator|->
name|recval
operator|.
name|ptr
operator|)
condition|)
break|break;
name|ctl_putint
argument_list|(
name|peer_var
index|[
name|CP_INITSEQ
index|]
operator|.
name|text
argument_list|,
name|ap
operator|->
name|seq
argument_list|)
expr_stmt|;
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|CP_INITKEY
index|]
operator|.
name|text
argument_list|,
name|ap
operator|->
name|key
argument_list|)
expr_stmt|;
name|ctl_putfs
argument_list|(
name|peer_var
index|[
name|CP_INITTSP
index|]
operator|.
name|text
argument_list|,
name|ntohl
argument_list|(
name|p
operator|->
name|recval
operator|.
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_IDENT
case|:
if|if
condition|(
name|p
operator|->
name|ident
operator|!=
name|NULL
condition|)
name|ctl_putstr
argument_list|(
name|peer_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|p
operator|->
name|ident
argument_list|,
name|strlen
argument_list|(
name|p
operator|->
name|ident
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* AUTOKEY */
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * ctl_putclock - output clock variables  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putclock
parameter_list|(
name|int
name|id
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|pcs
parameter_list|,
name|int
name|mustput
parameter_list|)
block|{
name|char
name|buf
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|be
decl_stmt|;
specifier|const
name|char
modifier|*
name|ss
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|CC_TYPE
case|:
if|if
condition|(
name|mustput
operator|||
name|pcs
operator|->
name|clockdesc
operator|==
name|NULL
operator|||
operator|*
operator|(
name|pcs
operator|->
name|clockdesc
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_TIMECODE
case|:
name|ctl_putstr
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|p_lastcode
argument_list|,
operator|(
name|unsigned
operator|)
name|pcs
operator|->
name|lencode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_POLL
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|polls
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_NOREPLY
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|noresponse
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_BADFORMAT
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|badformat
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_BADDATA
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|baddata
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGETIME1
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|pcs
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
operator|)
condition|)
name|ctl_putdbl
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|fudgetime1
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGETIME2
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|pcs
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME2
operator|)
condition|)
name|ctl_putdbl
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|fudgetime2
operator|*
literal|1e3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGEVAL1
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|pcs
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
operator|)
condition|)
name|ctl_putint
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|fudgeval1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGEVAL2
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|pcs
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL2
operator|)
condition|)
block|{
if|if
condition|(
name|pcs
operator|->
name|fudgeval1
operator|>
literal|1
condition|)
name|ctl_putadr
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|fudgeval2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ctl_putrefid
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|fudgeval2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_FLAGS
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_DEVICE
case|:
if|if
condition|(
name|pcs
operator|->
name|clockdesc
operator|==
name|NULL
operator|||
operator|*
operator|(
name|pcs
operator|->
name|clockdesc
operator|)
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mustput
condition|)
name|ctl_putstr
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_putstr
argument_list|(
name|clock_var
index|[
name|id
index|]
operator|.
name|text
argument_list|,
name|pcs
operator|->
name|clockdesc
argument_list|,
name|strlen
argument_list|(
name|pcs
operator|->
name|clockdesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_VARLIST
case|:
name|s
operator|=
name|buf
expr_stmt|;
name|be
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|clock_var
index|[
name|CC_VARLIST
index|]
operator|.
name|text
argument_list|)
operator|+
literal|4
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
break|break;
comment|/* really long var name */
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s=\""
argument_list|,
name|clock_var
index|[
name|CC_VARLIST
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
for|for
control|(
name|k
operator|=
name|clock_var
init|;
operator|!
operator|(
name|EOV
operator|&
name|k
operator|->
name|flags
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|PADDING
operator|&
name|k
operator|->
name|flags
condition|)
continue|continue;
name|i
operator|=
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|pcs
operator|->
name|kv_list
init|;
name|k
operator|&&
operator|!
operator|(
name|EOV
operator|&
name|k
operator|->
name|flags
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|PADDING
operator|&
name|k
operator|->
name|flags
condition|)
continue|continue;
name|ss
operator|=
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ss
condition|)
continue|continue;
while|while
condition|(
operator|*
name|ss
operator|&&
operator|*
name|ss
operator|!=
literal|'='
condition|)
name|ss
operator|++
expr_stmt|;
name|i
operator|=
name|ss
operator|-
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|+
literal|2
operator|>=
name|be
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buf
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|-
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ctl_getitem - get the next data item from the incoming packet  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|ctl_var
modifier|*
name|ctl_getitem
parameter_list|(
specifier|const
name|struct
name|ctl_var
modifier|*
name|var_list
parameter_list|,
name|char
modifier|*
modifier|*
name|data
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ctl_var
name|eol
init|=
block|{
literal|0
block|,
name|EOV
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
specifier|static
name|u_long
name|quiet_until
decl_stmt|;
specifier|const
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* 	 * Delete leading commas and white space 	 */
while|while
condition|(
name|reqpt
operator|<
name|reqend
operator|&&
operator|(
operator|*
name|reqpt
operator|==
literal|','
operator|||
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|reqpt
argument_list|)
operator|)
condition|)
name|reqpt
operator|++
expr_stmt|;
if|if
condition|(
name|reqpt
operator|>=
name|reqend
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|NULL
operator|==
name|var_list
condition|)
return|return
operator|&
name|eol
return|;
comment|/* 	 * Look for a first character match on the tag.  If we find 	 * one, see if it is a full match. 	 */
name|v
operator|=
name|var_list
expr_stmt|;
name|cp
operator|=
name|reqpt
expr_stmt|;
for|for
control|(
name|v
operator|=
name|var_list
init|;
operator|!
operator|(
name|EOV
operator|&
name|v
operator|->
name|flags
operator|)
condition|;
name|v
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|PADDING
operator|&
name|v
operator|->
name|flags
operator|)
operator|&&
operator|*
name|cp
operator|==
operator|*
operator|(
name|v
operator|->
name|text
operator|)
condition|)
block|{
name|pch
operator|=
name|v
operator|->
name|text
expr_stmt|;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|pch
operator|&&
literal|'='
operator|!=
operator|*
name|pch
operator|&&
name|cp
operator|<
name|reqend
operator|&&
operator|*
name|cp
operator|==
operator|*
name|pch
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|pch
operator|++
expr_stmt|;
block|}
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|pch
operator|||
literal|'='
operator|==
operator|*
name|pch
condition|)
block|{
while|while
condition|(
name|cp
operator|<
name|reqend
operator|&&
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|reqend
operator|||
literal|','
operator|==
operator|*
name|cp
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|data
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|reqend
condition|)
name|cp
operator|++
expr_stmt|;
name|reqpt
operator|=
name|cp
expr_stmt|;
return|return
name|v
return|;
block|}
if|if
condition|(
literal|'='
operator|==
operator|*
name|cp
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|tp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|reqend
operator|&&
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|reqend
operator|&&
operator|*
name|cp
operator|!=
literal|','
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|tp
operator|-
name|buf
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADFMT
argument_list|)
expr_stmt|;
name|numctlbadpkts
operator|++
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYSEVENT
argument_list|)
if|if
condition|(
name|quiet_until
operator|<=
name|current_time
condition|)
block|{
name|quiet_until
operator|=
name|current_time
operator|+
literal|300
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Possible 'ntpdx' exploit from %s#%u (possibly spoofed)"
argument_list|,
name|stoa
argument_list|(
name|rmt_addr
argument_list|)
argument_list|,
name|SRCPORT
argument_list|(
name|rmt_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|cp
operator|<
name|reqend
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|tp
operator|--
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|tp
operator|>=
name|buf
operator|&&
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|tp
operator|--
operator|=
literal|'\0'
expr_stmt|;
name|reqpt
operator|=
name|cp
expr_stmt|;
operator|*
name|data
operator|=
name|buf
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
name|cp
operator|=
name|reqpt
expr_stmt|;
block|}
block|}
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * control_unspec - response to an unspecified op-code  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|control_unspec
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* 	 * What is an appropriate response to an unspecified op-code? 	 * I return no errors and no data, unless a specified assocation 	 * doesn't exist. 	 */
if|if
condition|(
name|res_associd
condition|)
block|{
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|res_associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|peer
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read_status - return either a list of associd's, or a particular  * peer's status.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|read_status
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|n
decl_stmt|;
comment|/* a_st holds association ID, status pairs alternating */
name|u_short
name|a_st
index|[
name|CTL_MAX_DATA_LEN
operator|/
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"read_status: ID %d\n"
argument_list|,
name|res_associd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Two choices here. If the specified association ID is 	 * zero we return all known assocation ID's.  Otherwise 	 * we return a bunch of stuff about the particular peer. 	 */
if|if
condition|(
name|res_associd
condition|)
block|{
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|res_associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|peer
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_authokay
condition|)
name|peer
operator|->
name|num_events
operator|=
literal|0
expr_stmt|;
comment|/* 		 * For now, output everything we know about the 		 * peer. May be more selective later. 		 */
for|for
control|(
name|cp
operator|=
name|def_peer_var
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
name|ctl_putpeer
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
literal|0
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|peer
operator|=
name|peer_list
init|;
name|peer
operator|!=
name|NULL
condition|;
name|peer
operator|=
name|peer
operator|->
name|p_link
control|)
block|{
name|a_st
index|[
name|n
operator|++
index|]
operator|=
name|htons
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
name|a_st
index|[
name|n
operator|++
index|]
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* two entries each loop iteration, so n + 1 */
if|if
condition|(
name|n
operator|+
literal|1
operator|>=
name|COUNTOF
argument_list|(
name|a_st
argument_list|)
condition|)
block|{
name|ctl_putdata
argument_list|(
operator|(
name|void
operator|*
operator|)
name|a_st
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|a_st
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
condition|)
name|ctl_putdata
argument_list|(
operator|(
name|void
operator|*
operator|)
name|a_st
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|a_st
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read_peervars - half of read_variables() implementation  */
end_comment

begin_function
specifier|static
name|void
name|read_peervars
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|valuep
decl_stmt|;
name|u_char
name|wants
index|[
name|CP_MAXCODE
operator|+
literal|1
index|]
decl_stmt|;
name|u_int
name|gotvar
decl_stmt|;
comment|/* 	 * Wants info for a particular peer. See if we know 	 * the guy. 	 */
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|res_associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|peer
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_authokay
condition|)
name|peer
operator|->
name|num_events
operator|=
literal|0
expr_stmt|;
name|ZERO
argument_list|(
name|wants
argument_list|)
expr_stmt|;
name|gotvar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|peer_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
return|return;
block|}
name|NTP_INSIST
argument_list|(
name|v
operator|->
name|code
operator|<
name|COUNTOF
argument_list|(
name|wants
argument_list|)
argument_list|)
expr_stmt|;
name|wants
index|[
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gotvar
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|wants
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
index|]
condition|)
name|ctl_putpeer
argument_list|(
name|i
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|cp
operator|=
name|def_peer_var
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
name|ctl_putpeer
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read_sysvars - half of read_variables() implementation  */
end_comment

begin_function
specifier|static
name|void
name|read_sysvars
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|u_int
name|gotvar
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cs
decl_stmt|;
name|char
modifier|*
name|valuep
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch
decl_stmt|;
name|u_char
modifier|*
name|wants
decl_stmt|;
name|size_t
name|wants_count
decl_stmt|;
comment|/* 	 * Wants system variables. Figure out which he wants 	 * and give them to him. 	 */
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_authokay
condition|)
name|ctl_sys_num_events
operator|=
literal|0
expr_stmt|;
name|wants_count
operator|=
name|CS_MAXCODE
operator|+
literal|1
operator|+
name|count_var
argument_list|(
name|ext_sys_var
argument_list|)
expr_stmt|;
name|wants
operator|=
name|emalloc_zero
argument_list|(
name|wants_count
argument_list|)
expr_stmt|;
name|gotvar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|EOV
operator|&
name|v
operator|->
name|flags
operator|)
condition|)
block|{
name|NTP_INSIST
argument_list|(
name|v
operator|->
name|code
operator|<
name|wants_count
argument_list|)
expr_stmt|;
name|wants
index|[
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|ctl_getitem
argument_list|(
name|ext_sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|v
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|EOV
operator|&
name|v
operator|->
name|flags
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wants
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|v
operator|->
name|code
operator|+
name|CS_MAXCODE
operator|+
literal|1
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|n
operator|<
name|wants_count
argument_list|)
expr_stmt|;
name|wants
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gotvar
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
name|CS_MAXCODE
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|n
index|]
condition|)
name|ctl_putsys
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|+
name|CS_MAXCODE
operator|+
literal|1
operator|<
name|wants_count
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|n
operator|+
name|CS_MAXCODE
operator|+
literal|1
index|]
condition|)
block|{
name|pch
operator|=
name|ext_sys_var
index|[
name|n
index|]
operator|.
name|text
expr_stmt|;
name|ctl_putdata
argument_list|(
name|pch
argument_list|,
name|strlen
argument_list|(
name|pch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|cs
operator|=
name|def_sys_var
init|;
operator|*
name|cs
operator|!=
literal|0
condition|;
name|cs
operator|++
control|)
name|ctl_putsys
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cs
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|ext_sys_var
init|;
name|kv
operator|&&
operator|!
operator|(
name|EOV
operator|&
name|kv
operator|->
name|flags
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|DEF
operator|&
name|kv
operator|->
name|flags
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|wants
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read_variables - return the variables the caller asks for  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|read_variables
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
if|if
condition|(
name|res_associd
condition|)
name|read_peervars
argument_list|()
expr_stmt|;
else|else
name|read_sysvars
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * write_variables - write into variables. We only allow leap bit  * writing this way.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|write_variables
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
name|int
name|ext_var
decl_stmt|;
name|char
modifier|*
name|valuep
decl_stmt|;
name|long
name|val
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
name|char
modifier|*
name|vareqv
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|tt
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If he's trying to write into a peer tell him no way 	 */
if|if
condition|(
name|res_associd
operator|!=
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set status 	 */
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * Look through the variables. Dump out at the first sign of 	 * trouble. 	 */
while|while
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ext_var
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|ext_sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
return|return;
block|}
name|ext_var
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|CAN_WRITE
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ext_var
operator|&&
operator|(
operator|*
name|valuep
operator|==
literal|'\0'
operator|||
operator|!
name|atoint
argument_list|(
name|valuep
argument_list|,
operator|&
name|val
argument_list|)
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADFMT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ext_var
operator|&&
operator|(
name|val
operator|&
operator|~
name|LEAP_NOTINSYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADVALUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ext_var
condition|)
block|{
name|octets
operator|=
name|strlen
argument_list|(
name|v
operator|->
name|text
argument_list|)
operator|+
name|strlen
argument_list|(
name|valuep
argument_list|)
operator|+
literal|2
expr_stmt|;
name|vareqv
operator|=
name|emalloc
argument_list|(
name|octets
argument_list|)
expr_stmt|;
name|tt
operator|=
name|vareqv
expr_stmt|;
name|t
operator|=
name|v
operator|->
name|text
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|*
name|t
operator|!=
literal|'='
condition|)
operator|*
name|tt
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
operator|*
name|tt
operator|++
operator|=
literal|'='
expr_stmt|;
name|memcpy
argument_list|(
name|tt
argument_list|,
name|valuep
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|valuep
argument_list|)
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|vareqv
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|vareqv
argument_list|)
argument_list|,
name|v
operator|->
name|flags
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vareqv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_error
argument_list|(
name|CERR_UNSPEC
argument_list|)
expr_stmt|;
comment|/* really */
return|return;
block|}
block|}
comment|/* 	 * If we got anything, do it. xxx nothing to do *** 	 */
comment|/* 	  if (leapind != ~0 || leapwarn != ~0) { 	  if (!leap_setleap((int)leapind, (int)leapwarn)) { 	  ctl_error(CERR_PERMISSION); 	  return; 	  } 	  } 	*/
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * configure() processes ntpq :config/config-from-file, allowing  *		generic runtime reconfiguration.  */
end_comment

begin_function
specifier|static
name|void
name|configure
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|size_t
name|data_count
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|replace_nl
decl_stmt|;
comment|/* I haven't yet implemented changes to an existing association. 	 * Hence check if the association id is 0 	 */
if|if
condition|(
name|res_associd
operator|!=
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADVALUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|RES_NOMODIFY
operator|&
name|restrict_mask
condition|)
block|{
name|snprintf
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|)
argument_list|,
literal|"runtime configuration prohibited by restrict ... nomodify"
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|,
name|strlen
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"runtime config from %s rejected due to nomodify restriction"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|sys_restricted
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Initialize the remote config buffer */
name|data_count
operator|=
name|reqend
operator|-
name|reqpt
expr_stmt|;
if|if
condition|(
name|data_count
operator|>
sizeof|sizeof
argument_list|(
name|remote_config
operator|.
name|buffer
argument_list|)
operator|-
literal|2
condition|)
block|{
name|snprintf
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|)
argument_list|,
literal|"runtime configuration failed: request too long"
argument_list|)
expr_stmt|;
name|ctl_putdata
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|,
name|strlen
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"runtime config from %s rejected: request too long"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|remote_config
operator|.
name|buffer
argument_list|,
name|reqpt
argument_list|,
name|data_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_count
operator|>
literal|0
operator|&&
literal|'\n'
operator|!=
name|remote_config
operator|.
name|buffer
index|[
name|data_count
operator|-
literal|1
index|]
condition|)
name|remote_config
operator|.
name|buffer
index|[
name|data_count
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|remote_config
operator|.
name|buffer
index|[
name|data_count
index|]
operator|=
literal|'\0'
expr_stmt|;
name|remote_config
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|remote_config
operator|.
name|err_pos
operator|=
literal|0
expr_stmt|;
name|remote_config
operator|.
name|no_errors
operator|=
literal|0
expr_stmt|;
comment|/* do not include terminating newline in log */
if|if
condition|(
name|data_count
operator|>
literal|0
operator|&&
literal|'\n'
operator|==
name|remote_config
operator|.
name|buffer
index|[
name|data_count
operator|-
literal|1
index|]
condition|)
block|{
name|remote_config
operator|.
name|buffer
index|[
name|data_count
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|replace_nl
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|replace_nl
operator|=
name|FALSE
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Got Remote Configuration Command: %s\n"
operator|,
name|remote_config
operator|.
name|buffer
operator|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s config: %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|remote_config
operator|.
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|replace_nl
condition|)
name|remote_config
operator|.
name|buffer
index|[
name|data_count
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|config_remotely
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
comment|/* 	 * Check if errors were reported. If not, output 'Config 	 * Succeeded'.  Else output the error count.  It would be nice 	 * to output any parser error messages. 	 */
if|if
condition|(
literal|0
operator|==
name|remote_config
operator|.
name|no_errors
condition|)
block|{
name|retval
operator|=
name|snprintf
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|)
argument_list|,
literal|"Config Succeeded"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|>
literal|0
condition|)
name|remote_config
operator|.
name|err_pos
operator|+=
name|retval
expr_stmt|;
block|}
name|ctl_putdata
argument_list|(
name|remote_config
operator|.
name|err_msg
argument_list|,
name|remote_config
operator|.
name|err_pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Reply: %s\n"
operator|,
name|remote_config
operator|.
name|err_msg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_config
operator|.
name|no_errors
operator|>
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%d error in %s config"
argument_list|,
name|remote_config
operator|.
name|no_errors
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * derive_nonce - generate client-address-specific nonce value  *		  associated with a given timestamp.  */
end_comment

begin_function
specifier|static
name|u_int32
name|derive_nonce
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|u_int32
name|ts_i
parameter_list|,
name|u_int32
name|ts_f
parameter_list|)
block|{
specifier|static
name|u_int32
name|salt
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|u_long
name|last_salt_update
decl_stmt|;
union|union
name|d_tag
block|{
name|u_char
name|digest
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|u_int32
name|extract
decl_stmt|;
block|}
name|d
union|;
name|EVP_MD_CTX
name|ctx
decl_stmt|;
name|u_int
name|len
decl_stmt|;
while|while
condition|(
operator|!
name|salt
index|[
literal|0
index|]
operator|||
name|current_time
operator|-
name|last_salt_update
operator|>=
literal|3600
condition|)
block|{
name|salt
index|[
literal|0
index|]
operator|=
name|ntp_random
argument_list|()
expr_stmt|;
name|salt
index|[
literal|1
index|]
operator|=
name|ntp_random
argument_list|()
expr_stmt|;
name|salt
index|[
literal|2
index|]
operator|=
name|ntp_random
argument_list|()
expr_stmt|;
name|salt
index|[
literal|3
index|]
operator|=
name|ntp_random
argument_list|()
expr_stmt|;
name|last_salt_update
operator|=
name|current_time
expr_stmt|;
block|}
name|EVP_DigestInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|EVP_get_digestbynid
argument_list|(
name|NID_md5
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|salt
argument_list|,
sizeof|sizeof
argument_list|(
name|salt
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|ts_i
argument_list|,
sizeof|sizeof
argument_list|(
name|ts_i
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|ts_f
argument_list|,
sizeof|sizeof
argument_list|(
name|ts_f
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IPV4
argument_list|(
name|addr
argument_list|)
condition|)
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|SOCK_ADDR4
argument_list|(
name|addr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|SOCK_ADDR4
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|SOCK_ADDR6
argument_list|(
name|addr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|SOCK_ADDR6
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|NSRCPORT
argument_list|(
name|addr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|NSRCPORT
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|salt
argument_list|,
sizeof|sizeof
argument_list|(
name|salt
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|d
operator|.
name|digest
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
return|return
name|d
operator|.
name|extract
return|;
block|}
end_function

begin_comment
comment|/*  * generate_nonce - generate client-address-specific nonce string.  */
end_comment

begin_function
specifier|static
name|void
name|generate_nonce
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|char
modifier|*
name|nonce
parameter_list|,
name|size_t
name|nonce_octets
parameter_list|)
block|{
name|u_int32
name|derived
decl_stmt|;
name|derived
operator|=
name|derive_nonce
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_ui
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|nonce
argument_list|,
name|nonce_octets
argument_list|,
literal|"%08x%08x%08x"
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_ui
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_uf
argument_list|,
name|derived
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * validate_nonce - validate client-address-specific nonce string.  *  * Returns TRUE if the local calculation of the nonce matches the  * client-provided value and the timestamp is recent enough.  */
end_comment

begin_function
specifier|static
name|int
name|validate_nonce
parameter_list|(
specifier|const
name|char
modifier|*
name|pnonce
parameter_list|,
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|u_int
name|ts_i
decl_stmt|;
name|u_int
name|ts_f
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|l_fp
name|now_delta
decl_stmt|;
name|u_int
name|supposed
decl_stmt|;
name|u_int
name|derived
decl_stmt|;
if|if
condition|(
literal|3
operator|!=
name|sscanf
argument_list|(
name|pnonce
argument_list|,
literal|"%08x%08x%08x"
argument_list|,
operator|&
name|ts_i
argument_list|,
operator|&
name|ts_f
argument_list|,
operator|&
name|supposed
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ts
operator|.
name|l_ui
operator|=
operator|(
name|u_int32
operator|)
name|ts_i
expr_stmt|;
name|ts
operator|.
name|l_uf
operator|=
operator|(
name|u_int32
operator|)
name|ts_f
expr_stmt|;
name|derived
operator|=
name|derive_nonce
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|ts
operator|.
name|l_ui
argument_list|,
name|ts
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|now_delta
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|now_delta
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
return|return
operator|(
name|supposed
operator|==
name|derived
operator|&&
name|now_delta
operator|.
name|l_ui
operator|<
literal|16
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * send_random_tag_value - send a randomly-generated three character  *			   tag prefix, a '.', an index, a '=' and a  *			   random integer value.  *  * To try to force clients to ignore unrecognized tags in mrulist,  * reslist, and ifstats responses, the first and last rows are spiced  * with randomly-generated tag names with correct .# index.  Make it  * three characters knowing that none of the currently-used subscripted  * tags have that length, avoiding the need to test for  * tag collision.  */
end_comment

begin_function
specifier|static
name|void
name|send_random_tag_value
parameter_list|(
name|int
name|indx
parameter_list|)
block|{
name|int
name|noise
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|noise
operator|=
name|rand
argument_list|()
operator|^
operator|(
name|rand
argument_list|()
operator|<<
literal|16
operator|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'a'
operator|+
name|noise
operator|%
literal|26
expr_stmt|;
name|noise
operator|>>=
literal|5
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'a'
operator|+
name|noise
operator|%
literal|26
expr_stmt|;
name|noise
operator|>>=
literal|5
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'a'
operator|+
name|noise
operator|%
literal|26
expr_stmt|;
name|noise
operator|>>=
literal|5
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'.'
expr_stmt|;
name|snprintf
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|4
argument_list|,
literal|"%d"
argument_list|,
name|indx
argument_list|)
expr_stmt|;
name|ctl_putuint
argument_list|(
name|buf
argument_list|,
name|noise
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a MRU list entry in response to a "ntpq -c mrulist" operation.  *  * To keep clients honest about not depending on the order of values,  * and thereby avoid being locked into ugly workarounds to maintain  * backward compatibility later as new fields are added to the response,  * the order is random.  */
end_comment

begin_function
specifier|static
name|void
name|send_mru_entry
parameter_list|(
name|mon_entry
modifier|*
name|mon
parameter_list|,
name|int
name|count
parameter_list|)
block|{
specifier|const
name|char
name|first_fmt
index|[]
init|=
literal|"first.%d"
decl_stmt|;
specifier|const
name|char
name|ct_fmt
index|[]
init|=
literal|"ct.%d"
decl_stmt|;
specifier|const
name|char
name|mv_fmt
index|[]
init|=
literal|"mv.%d"
decl_stmt|;
specifier|const
name|char
name|rs_fmt
index|[]
init|=
literal|"rs.%d"
decl_stmt|;
name|char
name|tag
index|[
literal|32
index|]
decl_stmt|;
name|u_char
name|sent
index|[
literal|6
index|]
decl_stmt|;
comment|/* 6 tag=value pairs */
name|u_int32
name|noise
decl_stmt|;
name|u_int
name|which
decl_stmt|;
name|u_int
name|remaining
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch
decl_stmt|;
name|remaining
operator|=
name|COUNTOF
argument_list|(
name|sent
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|sent
argument_list|)
expr_stmt|;
name|noise
operator|=
call|(
name|u_int32
call|)
argument_list|(
name|rand
argument_list|()
operator|^
operator|(
name|rand
argument_list|()
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|which
operator|=
operator|(
name|noise
operator|&
literal|7
operator|)
operator|%
name|COUNTOF
argument_list|(
name|sent
argument_list|)
expr_stmt|;
name|noise
operator|>>=
literal|3
expr_stmt|;
while|while
condition|(
name|sent
index|[
name|which
index|]
condition|)
name|which
operator|=
operator|(
name|which
operator|+
literal|1
operator|)
operator|%
name|COUNTOF
argument_list|(
name|sent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|addr_fmt
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|pch
operator|=
name|sptoa
argument_list|(
operator|&
name|mon
operator|->
name|rmtadr
argument_list|)
expr_stmt|;
name|ctl_putunqstr
argument_list|(
name|tag
argument_list|,
name|pch
argument_list|,
name|strlen
argument_list|(
name|pch
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|last_fmt
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ctl_putts
argument_list|(
name|tag
argument_list|,
operator|&
name|mon
operator|->
name|last
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|first_fmt
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ctl_putts
argument_list|(
name|tag
argument_list|,
operator|&
name|mon
operator|->
name|first
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|ct_fmt
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ctl_putint
argument_list|(
name|tag
argument_list|,
name|mon
operator|->
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|mv_fmt
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ctl_putuint
argument_list|(
name|tag
argument_list|,
name|mon
operator|->
name|vn_mode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|rs_fmt
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ctl_puthex
argument_list|(
name|tag
argument_list|,
name|mon
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|sent
index|[
name|which
index|]
operator|=
name|TRUE
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * read_mru_list - supports ntpq's mrulist command.  *  * The challenge here is to match ntpdc's monlist functionality without  * being limited to hundreds of entries returned total, and without  * requiring state on the server.  If state were required, ntpq's  * mrulist command would require authentication.  *  * The approach was suggested by Ry Jones.  A finite and variable number  * of entries are retrieved per request, to avoid having responses with  * such large numbers of packets that socket buffers are overflowed and  * packets lost.  The entries are retrieved oldest-first, taking into  * account that the MRU list will be changing between each request.  We  * can expect to see duplicate entries for addresses updated in the MRU  * list during the fetch operation.  In the end, the client can assemble  * a close approximation of the MRU list at the point in time the last  * response was sent by ntpd.  The only difference is it may be longer,  * containing some number of oldest entries which have since been  * reclaimed.  If necessary, the protocol could be extended to zap those  * from the client snapshot at the end, but so far that doesn't seem  * useful.  *  * To accomodate the changing MRU list, the starting point for requests  * after the first request is supplied as a series of last seen  * timestamps and associated addresses, the newest ones the client has  * received.  As long as at least one of those entries hasn't been  * bumped to the head of the MRU list, ntpd can pick up at that point.  * Otherwise, the request is failed and it is up to ntpq to back up and  * provide the next newest entry's timestamps and addresses, conceivably  * backing up all the way to the starting point.  *  * input parameters:  *	nonce=		Regurgitated nonce retrieved by the client  *			previously using CTL_OP_REQ_NONCE, demonstrating  *			ability to receive traffic sent to its address.  *	frags=		Limit on datagrams (fragments) in response.  Used  *			by newer ntpq versions instead of limit= when  *			retrieving multiple entries.  *	limit=		Limit on MRU entries returned.  One of frags= or  *			limit= must be provided.  *			limit=1 is a special case:  Instead of fetching  *			beginning with the supplied starting point's  *			newer neighbor, fetch the supplied entry, and  *			in that case the #.last timestamp can be zero.  *			This enables fetching a single entry by IP  *			address.  When limit is not one and frags= is  *			provided, the fragment limit controls.  *	mincount=	(decimal) Return entries with count>= mincount.  *	laddr=		Return entries associated with the server's IP  *			address given.  No port specification is needed,  *			and any supplied is ignored.  *	resall=		0x-prefixed hex restrict bits which must all be  *			lit for an MRU entry to be included.  *			Has precedence over any resany=.  *	resany=		0x-prefixed hex restrict bits, at least one of  *			which must be list for an MRU entry to be  *			included.  *	last.0=		0x-prefixed hex l_fp timestamp of newest entry  *			which client previously received.  *	addr.0=		text of newest entry's IP address and port,  *			IPv6 addresses in bracketed form: [::]:123  *	last.1=		timestamp of 2nd newest entry client has.  *	addr.1=		address of 2nd newest entry.  *	[...]  *  * ntpq provides as many last/addr pairs as will fit in a single request  * packet, except for the first request in a MRU fetch operation.  *  * The response begins with a new nonce value to be used for any  * followup request.  Following the nonce is the next newer entry than  * referred to by last.0 and addr.0, if the "0" entry has not been  * bumped to the front.  If it has, the first entry returned will be the  * next entry newer than referred to by last.1 and addr.1, and so on.  * If none of the referenced entries remain unchanged, the request fails  * and ntpq backs up to the next earlier set of entries to resync.  *  * Except for the first response, the response begins with confirmation  * of the entry that precedes the first additional entry provided:  *  *	last.older=	hex l_fp timestamp matching one of the input  *			.last timestamps, which entry now precedes the  *			response 0. entry in the MRU list.  *	addr.older=	text of address corresponding to older.last.  *  * And in any case, a successful response contains sets of values  * comprising entries, with the oldest numbered 0 and incrementing from  * there:  *  *	addr.#		text of IPv4 or IPv6 address and port  *	last.#		hex l_fp timestamp of last receipt  *	first.#		hex l_fp timestamp of first receipt  *	ct.#		count of packets received  *	mv.#		mode and version  *	rs.#		restriction mask (RES_* bits)  *  * Note the code currently assumes there are no valid three letter  * tags sent with each row, and needs to be adjusted if that changes.  *  * The client should accept the values in any order, and ignore .#  * values which it does not understand, to allow a smooth path to  * future changes without requiring a new opcode.  Clients can rely  * on all *.0 values preceding any *.1 values, that is all values for  * a given index number are together in the response.  *  * The end of the response list is noted with one or two tag=value  * pairs.  Unconditionally:  *  *	now=		0x-prefixed l_fp timestamp at the server marking  *			the end of the operation.  *  * If any entries were returned, now= is followed by:  *  *	last.newest=	hex l_fp identical to last.# of the prior  *			entry.  */
end_comment

begin_function
specifier|static
name|void
name|read_mru_list
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
specifier|const
name|char
name|nonce_text
index|[]
init|=
literal|"nonce"
decl_stmt|;
specifier|const
name|char
name|frags_text
index|[]
init|=
literal|"frags"
decl_stmt|;
specifier|const
name|char
name|limit_text
index|[]
init|=
literal|"limit"
decl_stmt|;
specifier|const
name|char
name|mincount_text
index|[]
init|=
literal|"mincount"
decl_stmt|;
specifier|const
name|char
name|resall_text
index|[]
init|=
literal|"resall"
decl_stmt|;
specifier|const
name|char
name|resany_text
index|[]
init|=
literal|"resany"
decl_stmt|;
specifier|const
name|char
name|maxlstint_text
index|[]
init|=
literal|"maxlstint"
decl_stmt|;
specifier|const
name|char
name|laddr_text
index|[]
init|=
literal|"laddr"
decl_stmt|;
specifier|const
name|char
name|resaxx_fmt
index|[]
init|=
literal|"0x%hx"
decl_stmt|;
name|u_int
name|limit
decl_stmt|;
name|u_short
name|frags
decl_stmt|;
name|u_short
name|resall
decl_stmt|;
name|u_short
name|resany
decl_stmt|;
name|int
name|mincount
decl_stmt|;
name|u_int
name|maxlstint
decl_stmt|;
name|sockaddr_u
name|laddr
decl_stmt|;
name|struct
name|interface
modifier|*
name|lcladr
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|u_int
name|ui
decl_stmt|;
name|u_int
name|uf
decl_stmt|;
name|l_fp
name|last
index|[
literal|16
index|]
decl_stmt|;
name|sockaddr_u
name|addr
index|[
name|COUNTOF
argument_list|(
name|last
argument_list|)
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|in_parms
decl_stmt|;
specifier|const
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch
decl_stmt|;
name|char
modifier|*
name|pnonce
decl_stmt|;
name|int
name|nonce_valid
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|priors
decl_stmt|;
name|u_short
name|hash
decl_stmt|;
name|mon_entry
modifier|*
name|mon
decl_stmt|;
name|mon_entry
modifier|*
name|prior_mon
decl_stmt|;
name|l_fp
name|now
decl_stmt|;
if|if
condition|(
name|RES_NOMRULIST
operator|&
name|restrict_mask
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"mrulist from %s rejected due to nomrulist restriction"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|sys_restricted
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * fill in_parms var list with all possible input parameters. 	 */
name|in_parms
operator|=
name|NULL
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|in_parms
argument_list|,
name|nonce_text
argument_list|,
sizeof|sizeof
argument_list|(
name|nonce_text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|in_parms
argument_list|,
name|frags_text
argument_list|,
sizeof|sizeof
argument_list|(
name|frags_text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|in_parms
argument_list|,
name|limit_text
argument_list|,
sizeof|sizeof
argument_list|(
name|limit_text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|in_parms
argument_list|,
name|mincount_text
argument_list|,
sizeof|sizeof
argument_list|(
name|mincount_text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|in_parms
argument_list|,
name|resall_text
argument_list|,
sizeof|sizeof
argument_list|(
name|resall_text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|in_parms
argument_list|,
name|resany_text
argument_list|,
sizeof|sizeof
argument_list|(
name|resany_text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|in_parms
argument_list|,
name|maxlstint_text
argument_list|,
sizeof|sizeof
argument_list|(
name|maxlstint_text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|in_parms
argument_list|,
name|laddr_text
argument_list|,
sizeof|sizeof
argument_list|(
name|laddr_text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|last
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|last_fmt
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|in_parms
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|addr_fmt
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|in_parms
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* decode input parms */
name|pnonce
operator|=
name|NULL
expr_stmt|;
name|frags
operator|=
literal|0
expr_stmt|;
name|limit
operator|=
literal|0
expr_stmt|;
name|mincount
operator|=
literal|0
expr_stmt|;
name|resall
operator|=
literal|0
expr_stmt|;
name|resany
operator|=
literal|0
expr_stmt|;
name|maxlstint
operator|=
literal|0
expr_stmt|;
name|lcladr
operator|=
name|NULL
expr_stmt|;
name|priors
operator|=
literal|0
expr_stmt|;
name|ZERO
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|in_parms
argument_list|,
operator|&
name|val
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|EOV
operator|&
name|v
operator|->
name|flags
operator|)
condition|)
block|{
name|int
name|si
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nonce_text
argument_list|,
name|v
operator|->
name|text
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|pnonce
condition|)
name|free
argument_list|(
name|pnonce
argument_list|)
expr_stmt|;
name|pnonce
operator|=
name|estrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|frags_text
argument_list|,
name|v
operator|->
name|text
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%hu"
argument_list|,
operator|&
name|frags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|limit_text
argument_list|,
name|v
operator|->
name|text
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mincount_text
argument_list|,
name|v
operator|->
name|text
argument_list|)
condition|)
block|{
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mincount
argument_list|)
operator|||
name|mincount
operator|<
literal|0
condition|)
name|mincount
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resall_text
argument_list|,
name|v
operator|->
name|text
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|val
argument_list|,
name|resaxx_fmt
argument_list|,
operator|&
name|resall
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|resany_text
argument_list|,
name|v
operator|->
name|text
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|val
argument_list|,
name|resaxx_fmt
argument_list|,
operator|&
name|resany
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|maxlstint_text
argument_list|,
name|v
operator|->
name|text
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|maxlstint
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|laddr_text
argument_list|,
name|v
operator|->
name|text
argument_list|)
condition|)
block|{
if|if
condition|(
name|decodenetnum
argument_list|(
name|val
argument_list|,
operator|&
name|laddr
argument_list|)
condition|)
name|lcladr
operator|=
name|getinterface
argument_list|(
operator|&
name|laddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|v
operator|->
name|text
argument_list|,
name|last_fmt
argument_list|,
operator|&
name|si
argument_list|)
operator|&&
operator|(
name|size_t
operator|)
name|si
operator|<
name|COUNTOF
argument_list|(
name|last
argument_list|)
condition|)
block|{
if|if
condition|(
literal|2
operator|==
name|sscanf
argument_list|(
name|val
argument_list|,
literal|"0x%08x.%08x"
argument_list|,
operator|&
name|ui
argument_list|,
operator|&
name|uf
argument_list|)
condition|)
block|{
name|last
index|[
name|si
index|]
operator|.
name|l_ui
operator|=
name|ui
expr_stmt|;
name|last
index|[
name|si
index|]
operator|.
name|l_uf
operator|=
name|uf
expr_stmt|;
if|if
condition|(
operator|!
name|SOCK_UNSPEC
argument_list|(
operator|&
name|addr
index|[
name|si
index|]
argument_list|)
operator|&&
name|si
operator|==
name|priors
condition|)
name|priors
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|v
operator|->
name|text
argument_list|,
name|addr_fmt
argument_list|,
operator|&
name|si
argument_list|)
operator|&&
operator|(
name|size_t
operator|)
name|si
operator|<
name|COUNTOF
argument_list|(
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|decodenetnum
argument_list|(
name|val
argument_list|,
operator|&
name|addr
index|[
name|si
index|]
argument_list|)
operator|&&
name|last
index|[
name|si
index|]
operator|.
name|l_ui
operator|&&
name|last
index|[
name|si
index|]
operator|.
name|l_uf
operator|&&
name|si
operator|==
name|priors
condition|)
name|priors
operator|++
expr_stmt|;
block|}
block|}
name|free_varlist
argument_list|(
name|in_parms
argument_list|)
expr_stmt|;
name|in_parms
operator|=
name|NULL
expr_stmt|;
comment|/* return no responses until the nonce is validated */
if|if
condition|(
name|NULL
operator|==
name|pnonce
condition|)
return|return;
name|nonce_valid
operator|=
name|validate_nonce
argument_list|(
name|pnonce
argument_list|,
name|rbufp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pnonce
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nonce_valid
condition|)
return|return;
if|if
condition|(
operator|(
literal|0
operator|==
name|frags
operator|&&
operator|!
operator|(
literal|0
operator|<
name|limit
operator|&&
name|limit
operator|<=
name|MRU_ROW_LIMIT
operator|)
operator|)
operator|||
name|frags
operator|>
name|MRU_FRAGS_LIMIT
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADVALUE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If either frags or limit is not given, use the max. 	 */
if|if
condition|(
literal|0
operator|!=
name|frags
operator|&&
literal|0
operator|==
name|limit
condition|)
name|limit
operator|=
name|UINT_MAX
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|!=
name|limit
operator|&&
literal|0
operator|==
name|frags
condition|)
name|frags
operator|=
name|MRU_FRAGS_LIMIT
expr_stmt|;
comment|/* 	 * Find the starting point if one was provided. 	 */
name|mon
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|priors
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|MON_HASH
argument_list|(
operator|&
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|mon
operator|=
name|mon_hash
index|[
name|hash
index|]
init|;
name|mon
operator|!=
name|NULL
condition|;
name|mon
operator|=
name|mon
operator|->
name|hash_next
control|)
if|if
condition|(
name|ADDR_PORT_EQ
argument_list|(
operator|&
name|mon
operator|->
name|rmtadr
argument_list|,
operator|&
name|addr
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|mon
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|mon
operator|->
name|last
argument_list|,
operator|&
name|last
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
name|mon
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If a starting point was provided... */
if|if
condition|(
name|priors
condition|)
block|{
comment|/* and none could be found unmodified... */
if|if
condition|(
name|NULL
operator|==
name|mon
condition|)
block|{
comment|/* tell ntpq to try again with older entries */
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* confirm the prior entry used as starting point */
name|ctl_putts
argument_list|(
literal|"last.older"
argument_list|,
operator|&
name|mon
operator|->
name|last
argument_list|)
expr_stmt|;
name|pch
operator|=
name|sptoa
argument_list|(
operator|&
name|mon
operator|->
name|rmtadr
argument_list|)
expr_stmt|;
name|ctl_putunqstr
argument_list|(
literal|"addr.older"
argument_list|,
name|pch
argument_list|,
name|strlen
argument_list|(
name|pch
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Move on to the first entry the client doesn't have, 		 * except in the special case of a limit of one.  In 		 * that case return the starting point entry. 		 */
if|if
condition|(
name|limit
operator|>
literal|1
condition|)
name|mon
operator|=
name|PREV_DLIST
argument_list|(
name|mon_mru_list
argument_list|,
name|mon
argument_list|,
name|mru
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* start with the oldest */
name|mon
operator|=
name|TAIL_DLIST
argument_list|(
name|mon_mru_list
argument_list|,
name|mru
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * send up to limit= entries in up to frags= datagrams 	 */
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|generate_nonce
argument_list|(
name|rbufp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_putunqstr
argument_list|(
literal|"nonce"
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|prior_mon
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|mon
operator|!=
name|NULL
operator|&&
name|res_frags
operator|<
name|frags
operator|&&
name|count
operator|<
name|limit
condition|;
name|mon
operator|=
name|PREV_DLIST
argument_list|(
name|mon_mru_list
argument_list|,
name|mon
argument_list|,
name|mru
argument_list|)
control|)
block|{
if|if
condition|(
name|mon
operator|->
name|count
operator|<
name|mincount
condition|)
continue|continue;
if|if
condition|(
name|resall
operator|&&
name|resall
operator|!=
operator|(
name|resall
operator|&
name|mon
operator|->
name|flags
operator|)
condition|)
continue|continue;
if|if
condition|(
name|resany
operator|&&
operator|!
operator|(
name|resany
operator|&
name|mon
operator|->
name|flags
operator|)
condition|)
continue|continue;
if|if
condition|(
name|maxlstint
operator|>
literal|0
operator|&&
name|now
operator|.
name|l_ui
operator|-
name|mon
operator|->
name|last
operator|.
name|l_ui
operator|>
name|maxlstint
condition|)
continue|continue;
if|if
condition|(
name|lcladr
operator|!=
name|NULL
operator|&&
name|mon
operator|->
name|lcladr
operator|!=
name|lcladr
condition|)
continue|continue;
name|send_mru_entry
argument_list|(
name|mon
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
name|send_random_tag_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|prior_mon
operator|=
name|mon
expr_stmt|;
block|}
comment|/* 	 * If this batch completes the MRU list, say so explicitly with 	 * a now= l_fp timestamp. 	 */
if|if
condition|(
name|NULL
operator|==
name|mon
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|send_random_tag_value
argument_list|(
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ctl_putts
argument_list|(
literal|"now"
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* if any entries were returned confirm the last */
if|if
condition|(
name|prior_mon
operator|!=
name|NULL
condition|)
name|ctl_putts
argument_list|(
literal|"last.newest"
argument_list|,
operator|&
name|prior_mon
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a ifstats entry in response to a "ntpq -c ifstats" request.  *  * To keep clients honest about not depending on the order of values,  * and thereby avoid being locked into ugly workarounds to maintain  * backward compatibility later as new fields are added to the response,  * the order is random.  */
end_comment

begin_function
specifier|static
name|void
name|send_ifstats_entry
parameter_list|(
name|endpt
modifier|*
name|la
parameter_list|,
name|u_int
name|ifnum
parameter_list|)
block|{
specifier|const
name|char
name|addr_fmtu
index|[]
init|=
literal|"addr.%u"
decl_stmt|;
specifier|const
name|char
name|bcast_fmt
index|[]
init|=
literal|"bcast.%u"
decl_stmt|;
specifier|const
name|char
name|en_fmt
index|[]
init|=
literal|"en.%u"
decl_stmt|;
comment|/* enabled */
specifier|const
name|char
name|name_fmt
index|[]
init|=
literal|"name.%u"
decl_stmt|;
specifier|const
name|char
name|flags_fmt
index|[]
init|=
literal|"flags.%u"
decl_stmt|;
specifier|const
name|char
name|tl_fmt
index|[]
init|=
literal|"tl.%u"
decl_stmt|;
comment|/* ttl */
specifier|const
name|char
name|mc_fmt
index|[]
init|=
literal|"mc.%u"
decl_stmt|;
comment|/* mcast count */
specifier|const
name|char
name|rx_fmt
index|[]
init|=
literal|"rx.%u"
decl_stmt|;
specifier|const
name|char
name|tx_fmt
index|[]
init|=
literal|"tx.%u"
decl_stmt|;
specifier|const
name|char
name|txerr_fmt
index|[]
init|=
literal|"txerr.%u"
decl_stmt|;
specifier|const
name|char
name|pc_fmt
index|[]
init|=
literal|"pc.%u"
decl_stmt|;
comment|/* peer count */
specifier|const
name|char
name|up_fmt
index|[]
init|=
literal|"up.%u"
decl_stmt|;
comment|/* uptime */
name|char
name|tag
index|[
literal|32
index|]
decl_stmt|;
name|u_char
name|sent
index|[
name|IFSTATS_FIELDS
index|]
decl_stmt|;
comment|/* 12 tag=value pairs */
name|int
name|noisebits
decl_stmt|;
name|u_int32
name|noise
decl_stmt|;
name|u_int
name|which
decl_stmt|;
name|u_int
name|remaining
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch
decl_stmt|;
name|remaining
operator|=
name|COUNTOF
argument_list|(
name|sent
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|sent
argument_list|)
expr_stmt|;
name|noise
operator|=
literal|0
expr_stmt|;
name|noisebits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|noisebits
operator|<
literal|4
condition|)
block|{
name|noise
operator|=
name|rand
argument_list|()
operator|^
operator|(
name|rand
argument_list|()
operator|<<
literal|16
operator|)
expr_stmt|;
name|noisebits
operator|=
literal|31
expr_stmt|;
block|}
name|which
operator|=
operator|(
name|noise
operator|&
literal|0xf
operator|)
operator|%
name|COUNTOF
argument_list|(
name|sent
argument_list|)
expr_stmt|;
name|noise
operator|>>=
literal|4
expr_stmt|;
name|noisebits
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|sent
index|[
name|which
index|]
condition|)
name|which
operator|=
operator|(
name|which
operator|+
literal|1
operator|)
operator|%
name|COUNTOF
argument_list|(
name|sent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|addr_fmtu
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|pch
operator|=
name|sptoa
argument_list|(
operator|&
name|la
operator|->
name|sin
argument_list|)
expr_stmt|;
name|ctl_putunqstr
argument_list|(
name|tag
argument_list|,
name|pch
argument_list|,
name|strlen
argument_list|(
name|pch
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|bcast_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_BCASTOPEN
operator|&
name|la
operator|->
name|flags
condition|)
name|pch
operator|=
name|sptoa
argument_list|(
operator|&
name|la
operator|->
name|bcast
argument_list|)
expr_stmt|;
else|else
name|pch
operator|=
literal|""
expr_stmt|;
name|ctl_putunqstr
argument_list|(
name|tag
argument_list|,
name|pch
argument_list|,
name|strlen
argument_list|(
name|pch
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|en_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|ctl_putint
argument_list|(
name|tag
argument_list|,
operator|!
name|la
operator|->
name|ignore_packets
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|name_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|ctl_putstr
argument_list|(
name|tag
argument_list|,
name|la
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|la
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|flags_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|ctl_puthex
argument_list|(
name|tag
argument_list|,
operator|(
name|u_int
operator|)
name|la
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|tl_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|ctl_putint
argument_list|(
name|tag
argument_list|,
name|la
operator|->
name|last_ttl
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|mc_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|ctl_putint
argument_list|(
name|tag
argument_list|,
name|la
operator|->
name|num_mcast
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|rx_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|ctl_putint
argument_list|(
name|tag
argument_list|,
name|la
operator|->
name|received
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|tx_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|ctl_putint
argument_list|(
name|tag
argument_list|,
name|la
operator|->
name|sent
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|txerr_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|ctl_putint
argument_list|(
name|tag
argument_list|,
name|la
operator|->
name|notsent
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|pc_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|ctl_putuint
argument_list|(
name|tag
argument_list|,
name|la
operator|->
name|peercnt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|up_fmt
argument_list|,
name|ifnum
argument_list|)
expr_stmt|;
name|ctl_putuint
argument_list|(
name|tag
argument_list|,
name|current_time
operator|-
name|la
operator|->
name|starttime
argument_list|)
expr_stmt|;
break|break;
block|}
name|sent
index|[
name|which
index|]
operator|=
name|TRUE
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
block|}
name|send_random_tag_value
argument_list|(
operator|(
name|int
operator|)
name|ifnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read_ifstats - send statistics for each local address, exposed by  *		  ntpq -c ifstats  */
end_comment

begin_function
specifier|static
name|void
name|read_ifstats
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|u_int
name|ifidx
decl_stmt|;
name|endpt
modifier|*
name|la
decl_stmt|;
comment|/* 	 * loop over [0..sys_ifnum] searching ep_list for each 	 * ifnum in turn. 	 */
for|for
control|(
name|ifidx
operator|=
literal|0
init|;
name|ifidx
operator|<
name|sys_ifnum
condition|;
name|ifidx
operator|++
control|)
block|{
for|for
control|(
name|la
operator|=
name|ep_list
init|;
name|la
operator|!=
name|NULL
condition|;
name|la
operator|=
name|la
operator|->
name|elink
control|)
if|if
condition|(
name|ifidx
operator|==
name|la
operator|->
name|ifnum
condition|)
break|break;
if|if
condition|(
name|NULL
operator|==
name|la
condition|)
continue|continue;
comment|/* return stats for one local address */
name|send_ifstats_entry
argument_list|(
name|la
argument_list|,
name|ifidx
argument_list|)
expr_stmt|;
block|}
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sockaddrs_from_restrict_u
parameter_list|(
name|sockaddr_u
modifier|*
name|psaA
parameter_list|,
name|sockaddr_u
modifier|*
name|psaM
parameter_list|,
name|restrict_u
modifier|*
name|pres
parameter_list|,
name|int
name|ipv6
parameter_list|)
block|{
name|ZERO
argument_list|(
operator|*
name|psaA
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
operator|*
name|psaM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ipv6
condition|)
block|{
name|psaA
operator|->
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|psaA
operator|->
name|sa4
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|pres
operator|->
name|u
operator|.
name|v4
operator|.
name|addr
argument_list|)
expr_stmt|;
name|psaM
operator|->
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|psaM
operator|->
name|sa4
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|pres
operator|->
name|u
operator|.
name|v4
operator|.
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|psaA
operator|->
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|psaA
operator|->
name|sa6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|pres
operator|->
name|u
operator|.
name|v6
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|psaA
operator|->
name|sa6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|psaM
operator|->
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|psaM
operator|->
name|sa6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|pres
operator|->
name|u
operator|.
name|v6
operator|.
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|psaA
operator|->
name|sa6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a restrict entry in response to a "ntpq -c reslist" request.  *  * To keep clients honest about not depending on the order of values,  * and thereby avoid being locked into ugly workarounds to maintain  * backward compatibility later as new fields are added to the response,  * the order is random.  */
end_comment

begin_function
specifier|static
name|void
name|send_restrict_entry
parameter_list|(
name|restrict_u
modifier|*
name|pres
parameter_list|,
name|int
name|ipv6
parameter_list|,
name|u_int
name|idx
parameter_list|)
block|{
specifier|const
name|char
name|addr_fmtu
index|[]
init|=
literal|"addr.%u"
decl_stmt|;
specifier|const
name|char
name|mask_fmtu
index|[]
init|=
literal|"mask.%u"
decl_stmt|;
specifier|const
name|char
name|hits_fmt
index|[]
init|=
literal|"hits.%u"
decl_stmt|;
specifier|const
name|char
name|flags_fmt
index|[]
init|=
literal|"flags.%u"
decl_stmt|;
name|char
name|tag
index|[
literal|32
index|]
decl_stmt|;
name|u_char
name|sent
index|[
name|RESLIST_FIELDS
index|]
decl_stmt|;
comment|/* 4 tag=value pairs */
name|int
name|noisebits
decl_stmt|;
name|u_int32
name|noise
decl_stmt|;
name|u_int
name|which
decl_stmt|;
name|u_int
name|remaining
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|sockaddr_u
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|match_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|access_str
decl_stmt|;
name|sockaddrs_from_restrict_u
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|mask
argument_list|,
name|pres
argument_list|,
name|ipv6
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|COUNTOF
argument_list|(
name|sent
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|sent
argument_list|)
expr_stmt|;
name|noise
operator|=
literal|0
expr_stmt|;
name|noisebits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|noisebits
operator|<
literal|2
condition|)
block|{
name|noise
operator|=
name|rand
argument_list|()
operator|^
operator|(
name|rand
argument_list|()
operator|<<
literal|16
operator|)
expr_stmt|;
name|noisebits
operator|=
literal|31
expr_stmt|;
block|}
name|which
operator|=
operator|(
name|noise
operator|&
literal|0x3
operator|)
operator|%
name|COUNTOF
argument_list|(
name|sent
argument_list|)
expr_stmt|;
name|noise
operator|>>=
literal|2
expr_stmt|;
name|noisebits
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|sent
index|[
name|which
index|]
condition|)
name|which
operator|=
operator|(
name|which
operator|+
literal|1
operator|)
operator|%
name|COUNTOF
argument_list|(
name|sent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|addr_fmtu
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|pch
operator|=
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
name|ctl_putunqstr
argument_list|(
name|tag
argument_list|,
name|pch
argument_list|,
name|strlen
argument_list|(
name|pch
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|mask_fmtu
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|pch
operator|=
name|stoa
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|ctl_putunqstr
argument_list|(
name|tag
argument_list|,
name|pch
argument_list|,
name|strlen
argument_list|(
name|pch
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|hits_fmt
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|ctl_putuint
argument_list|(
name|tag
argument_list|,
name|pres
operator|->
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
name|flags_fmt
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|match_str
operator|=
name|res_match_flags
argument_list|(
name|pres
operator|->
name|mflags
argument_list|)
expr_stmt|;
name|access_str
operator|=
name|res_access_flags
argument_list|(
name|pres
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|match_str
index|[
literal|0
index|]
condition|)
block|{
name|pch
operator|=
name|access_str
expr_stmt|;
block|}
else|else
block|{
name|LIB_GETBUF
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|LIB_BUFLENGTH
argument_list|,
literal|"%s %s"
argument_list|,
name|match_str
argument_list|,
name|access_str
argument_list|)
expr_stmt|;
name|pch
operator|=
name|buf
expr_stmt|;
block|}
name|ctl_putunqstr
argument_list|(
name|tag
argument_list|,
name|pch
argument_list|,
name|strlen
argument_list|(
name|pch
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|sent
index|[
name|which
index|]
operator|=
name|TRUE
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
block|}
name|send_random_tag_value
argument_list|(
operator|(
name|int
operator|)
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_restrict_list
parameter_list|(
name|restrict_u
modifier|*
name|pres
parameter_list|,
name|int
name|ipv6
parameter_list|,
name|u_int
modifier|*
name|pidx
parameter_list|)
block|{
for|for
control|(
init|;
name|pres
operator|!=
name|NULL
condition|;
name|pres
operator|=
name|pres
operator|->
name|link
control|)
block|{
name|send_restrict_entry
argument_list|(
name|pres
argument_list|,
name|ipv6
argument_list|,
operator|*
name|pidx
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pidx
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * read_addr_restrictions - returns IPv4 and IPv6 access control lists  */
end_comment

begin_function
specifier|static
name|void
name|read_addr_restrictions
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
name|send_restrict_list
argument_list|(
name|restrictlist4
argument_list|,
name|FALSE
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
name|send_restrict_list
argument_list|(
name|restrictlist6
argument_list|,
name|TRUE
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read_ordlist - CTL_OP_READ_ORDLIST_A for ntpq -c ifstats& reslist  */
end_comment

begin_function
specifier|static
name|void
name|read_ordlist
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
specifier|const
name|char
name|ifstats_s
index|[]
init|=
literal|"ifstats"
decl_stmt|;
specifier|const
name|size_t
name|ifstats_chars
init|=
name|COUNTOF
argument_list|(
name|ifstats_s
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
name|addr_rst_s
index|[]
init|=
literal|"addr_restrictions"
decl_stmt|;
specifier|const
name|size_t
name|a_r_chars
init|=
name|COUNTOF
argument_list|(
name|addr_rst_s
argument_list|)
operator|-
literal|1
decl_stmt|;
name|struct
name|ntp_control
modifier|*
name|cpkt
decl_stmt|;
name|u_short
name|qdata_octets
decl_stmt|;
comment|/* 	 * CTL_OP_READ_ORDLIST_A was first named CTL_OP_READ_IFSTATS and 	 * used only for ntpq -c ifstats.  With the addition of reslist 	 * the same opcode was generalized to retrieve ordered lists 	 * which require authentication.  The request data is empty or 	 * contains "ifstats" (not null terminated) to retrieve local 	 * addresses and associated stats.  It is "addr_restrictions" 	 * to retrieve the IPv4 then IPv6 remote address restrictions, 	 * which are access control lists.  Other request data return 	 * CERR_UNKNOWNVAR. 	 */
name|cpkt
operator|=
operator|(
expr|struct
name|ntp_control
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
name|qdata_octets
operator|=
name|ntohs
argument_list|(
name|cpkt
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|qdata_octets
operator|||
operator|(
name|ifstats_chars
operator|==
name|qdata_octets
operator|&&
operator|!
name|memcmp
argument_list|(
name|ifstats_s
argument_list|,
name|cpkt
operator|->
name|u
operator|.
name|data
argument_list|,
name|ifstats_chars
argument_list|)
operator|)
condition|)
block|{
name|read_ifstats
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|a_r_chars
operator|==
name|qdata_octets
operator|&&
operator|!
name|memcmp
argument_list|(
name|addr_rst_s
argument_list|,
name|cpkt
operator|->
name|u
operator|.
name|data
argument_list|,
name|a_r_chars
argument_list|)
condition|)
block|{
name|read_addr_restrictions
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * req_nonce - CTL_OP_REQ_NONCE for ntpq -c mrulist prerequisite.  */
end_comment

begin_function
specifier|static
name|void
name|req_nonce
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|generate_nonce
argument_list|(
name|rbufp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_putunqstr
argument_list|(
literal|"nonce"
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read_clockstatus - return clock radio status  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|read_clockstatus
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|REFCLOCK
comment|/* 	 * If no refclock support, no data to return 	 */
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|char
modifier|*
name|valuep
decl_stmt|;
name|u_char
modifier|*
name|wants
decl_stmt|;
name|size_t
name|wants_alloc
decl_stmt|;
name|int
name|gotvar
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cc
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
name|struct
name|refclockstat
name|cs
decl_stmt|;
if|if
condition|(
name|res_associd
operator|!=
literal|0
condition|)
block|{
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|res_associd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Find a clock for this jerk.	If the system peer 		 * is a clock use it, else search peer_list for one. 		 */
if|if
condition|(
name|sys_peer
operator|!=
name|NULL
operator|&&
operator|(
name|FLAG_REFCLOCK
operator|&
name|sys_peer
operator|->
name|flags
operator|)
condition|)
name|peer
operator|=
name|sys_peer
expr_stmt|;
else|else
for|for
control|(
name|peer
operator|=
name|peer_list
init|;
name|peer
operator|!=
name|NULL
condition|;
name|peer
operator|=
name|peer
operator|->
name|p_link
control|)
if|if
condition|(
name|FLAG_REFCLOCK
operator|&
name|peer
operator|->
name|flags
condition|)
break|break;
block|}
if|if
condition|(
name|NULL
operator|==
name|peer
operator|||
operator|!
operator|(
name|FLAG_REFCLOCK
operator|&
name|peer
operator|->
name|flags
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we got here we have a peer which is a clock. Get his 	 * status. 	 */
name|cs
operator|.
name|kv_list
operator|=
name|NULL
expr_stmt|;
name|refclock_control
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|NULL
argument_list|,
operator|&
name|cs
argument_list|)
expr_stmt|;
name|kv
operator|=
name|cs
operator|.
name|kv_list
expr_stmt|;
comment|/* 	 * Look for variables in the packet. 	 */
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlclkstatus
argument_list|(
operator|&
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|wants_alloc
operator|=
name|CC_MAXCODE
operator|+
literal|1
operator|+
name|count_var
argument_list|(
name|kv
argument_list|)
expr_stmt|;
name|wants
operator|=
name|emalloc_zero
argument_list|(
name|wants_alloc
argument_list|)
expr_stmt|;
name|gotvar
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|clock_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|EOV
operator|&
name|v
operator|->
name|flags
operator|)
condition|)
block|{
name|wants
index|[
name|v
operator|->
name|code
index|]
operator|=
name|TRUE
expr_stmt|;
name|gotvar
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|ctl_getitem
argument_list|(
name|kv
argument_list|,
operator|&
name|valuep
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|NULL
operator|!=
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|EOV
operator|&
name|v
operator|->
name|flags
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wants
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|cs
operator|.
name|kv_list
argument_list|)
expr_stmt|;
return|return;
block|}
name|wants
index|[
name|CC_MAXCODE
operator|+
literal|1
operator|+
name|v
operator|->
name|code
index|]
operator|=
name|TRUE
expr_stmt|;
name|gotvar
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gotvar
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CC_MAXCODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
index|]
condition|)
name|ctl_putclock
argument_list|(
name|i
argument_list|,
operator|&
name|cs
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kv
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
operator|(
name|EOV
operator|&
name|kv
index|[
name|i
index|]
operator|.
name|flags
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
operator|+
name|CC_MAXCODE
operator|+
literal|1
index|]
condition|)
name|ctl_putdata
argument_list|(
name|kv
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
index|[
name|i
index|]
operator|.
name|text
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|cc
operator|=
name|def_clock_var
init|;
operator|*
name|cc
operator|!=
literal|0
condition|;
name|cc
operator|++
control|)
name|ctl_putclock
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|,
operator|&
name|cs
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|kv
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|EOV
operator|&
name|kv
operator|->
name|flags
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|DEF
operator|&
name|kv
operator|->
name|flags
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|wants
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|cs
operator|.
name|kv_list
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * write_clockstatus - we don't do this  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|write_clockstatus
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trap support from here on down. We send async trap messages when the  * upper levels report trouble. Traps can by set either by control  * messages or by configuration.  */
end_comment

begin_comment
comment|/*  * set_trap - set a trap in response to a control message  */
end_comment

begin_function
specifier|static
name|void
name|set_trap
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|int
name|traptype
decl_stmt|;
comment|/* 	 * See if this guy is allowed 	 */
if|if
condition|(
name|restrict_mask
operator|&
name|RES_NOTRAP
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Determine his allowed trap type. 	 */
name|traptype
operator|=
name|TRAP_TYPE_PRIO
expr_stmt|;
if|if
condition|(
name|restrict_mask
operator|&
name|RES_LPTRAP
condition|)
name|traptype
operator|=
name|TRAP_TYPE_NONPRIO
expr_stmt|;
comment|/* 	 * Call ctlsettrap() to do the work.  Return 	 * an error if it can't assign the trap. 	 */
if|if
condition|(
operator|!
name|ctlsettrap
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|traptype
argument_list|,
operator|(
name|int
operator|)
name|res_version
argument_list|)
condition|)
name|ctl_error
argument_list|(
name|CERR_NORESOURCE
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * unset_trap - unset a trap in response to a control message  */
end_comment

begin_function
specifier|static
name|void
name|unset_trap
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|restrict_mask
parameter_list|)
block|{
name|int
name|traptype
decl_stmt|;
comment|/* 	 * We don't prevent anyone from removing his own trap unless the 	 * trap is configured. Note we also must be aware of the 	 * possibility that restriction flags were changed since this 	 * guy last set his trap. Set the trap type based on this. 	 */
name|traptype
operator|=
name|TRAP_TYPE_PRIO
expr_stmt|;
if|if
condition|(
name|restrict_mask
operator|&
name|RES_LPTRAP
condition|)
name|traptype
operator|=
name|TRAP_TYPE_NONPRIO
expr_stmt|;
comment|/* 	 * Call ctlclrtrap() to clear this out. 	 */
if|if
condition|(
operator|!
name|ctlclrtrap
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|traptype
argument_list|)
condition|)
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctlsettrap - called to set a trap  */
end_comment

begin_function
name|int
name|ctlsettrap
parameter_list|(
name|sockaddr_u
modifier|*
name|raddr
parameter_list|,
name|struct
name|interface
modifier|*
name|linter
parameter_list|,
name|int
name|traptype
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|struct
name|ctl_trap
modifier|*
name|tp
decl_stmt|;
name|struct
name|ctl_trap
modifier|*
name|tptouse
decl_stmt|;
comment|/* 	 * See if we can find this trap.  If so, we only need update 	 * the flags and the time. 	 */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctlfindtrap
argument_list|(
name|raddr
argument_list|,
name|linter
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|traptype
condition|)
block|{
case|case
name|TRAP_TYPE_CONFIG
case|:
name|tp
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
operator||
name|TRAP_CONFIGURED
expr_stmt|;
break|break;
case|case
name|TRAP_TYPE_PRIO
case|:
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* don't change anything */
name|tp
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
expr_stmt|;
break|break;
case|case
name|TRAP_TYPE_NONPRIO
case|:
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* don't change anything */
name|tp
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
operator||
name|TRAP_NONPRIO
expr_stmt|;
break|break;
block|}
name|tp
operator|->
name|tr_settime
operator|=
name|current_time
expr_stmt|;
name|tp
operator|->
name|tr_resets
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * First we heard of this guy.	Try to find a trap structure 	 * for him to use, clearing out lesser priority guys if we 	 * have to. Clear out anyone who's expired while we're at it. 	 */
name|tptouse
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|COUNTOF
argument_list|(
name|ctl_traps
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|tp
operator|=
operator|&
name|ctl_traps
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|TRAP_INUSE
operator|&
name|tp
operator|->
name|tr_flags
operator|)
operator|&&
operator|!
operator|(
name|TRAP_CONFIGURED
operator|&
name|tp
operator|->
name|tr_flags
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|tr_settime
operator|+
name|CTL_TRAPTIME
operator|)
operator|>
name|current_time
operator|)
condition|)
block|{
name|tp
operator|->
name|tr_flags
operator|=
literal|0
expr_stmt|;
name|num_ctl_traps
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|TRAP_INUSE
operator|&
name|tp
operator|->
name|tr_flags
operator|)
condition|)
block|{
name|tptouse
operator|=
name|tp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|TRAP_CONFIGURED
operator|&
name|tp
operator|->
name|tr_flags
operator|)
condition|)
block|{
switch|switch
condition|(
name|traptype
condition|)
block|{
case|case
name|TRAP_TYPE_CONFIG
case|:
if|if
condition|(
name|tptouse
operator|==
name|NULL
condition|)
block|{
name|tptouse
operator|=
name|tp
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|TRAP_NONPRIO
operator|&
name|tptouse
operator|->
name|tr_flags
operator|)
operator|&&
operator|!
operator|(
name|TRAP_NONPRIO
operator|&
name|tp
operator|->
name|tr_flags
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|TRAP_NONPRIO
operator|&
name|tptouse
operator|->
name|tr_flags
operator|)
operator|&&
operator|(
name|TRAP_NONPRIO
operator|&
name|tp
operator|->
name|tr_flags
operator|)
condition|)
block|{
name|tptouse
operator|=
name|tp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tptouse
operator|->
name|tr_origtime
operator|<
name|tp
operator|->
name|tr_origtime
condition|)
name|tptouse
operator|=
name|tp
expr_stmt|;
break|break;
case|case
name|TRAP_TYPE_PRIO
case|:
if|if
condition|(
name|TRAP_NONPRIO
operator|&
name|tp
operator|->
name|tr_flags
condition|)
block|{
if|if
condition|(
name|tptouse
operator|==
name|NULL
operator|||
operator|(
operator|(
name|TRAP_INUSE
operator|&
name|tptouse
operator|->
name|tr_flags
operator|)
operator|&&
name|tptouse
operator|->
name|tr_origtime
operator|<
name|tp
operator|->
name|tr_origtime
operator|)
condition|)
name|tptouse
operator|=
name|tp
expr_stmt|;
block|}
break|break;
case|case
name|TRAP_TYPE_NONPRIO
case|:
break|break;
block|}
block|}
block|}
comment|/* 	 * If we don't have room for him return an error. 	 */
if|if
condition|(
name|tptouse
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Set up this structure for him. 	 */
name|tptouse
operator|->
name|tr_settime
operator|=
name|tptouse
operator|->
name|tr_origtime
operator|=
name|current_time
expr_stmt|;
name|tptouse
operator|->
name|tr_count
operator|=
name|tptouse
operator|->
name|tr_resets
operator|=
literal|0
expr_stmt|;
name|tptouse
operator|->
name|tr_sequence
operator|=
literal|1
expr_stmt|;
name|tptouse
operator|->
name|tr_addr
operator|=
operator|*
name|raddr
expr_stmt|;
name|tptouse
operator|->
name|tr_localaddr
operator|=
name|linter
expr_stmt|;
name|tptouse
operator|->
name|tr_version
operator|=
operator|(
name|u_char
operator|)
name|version
expr_stmt|;
name|tptouse
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
expr_stmt|;
if|if
condition|(
name|traptype
operator|==
name|TRAP_TYPE_CONFIG
condition|)
name|tptouse
operator|->
name|tr_flags
operator||=
name|TRAP_CONFIGURED
expr_stmt|;
elseif|else
if|if
condition|(
name|traptype
operator|==
name|TRAP_TYPE_NONPRIO
condition|)
name|tptouse
operator|->
name|tr_flags
operator||=
name|TRAP_NONPRIO
expr_stmt|;
name|num_ctl_traps
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctlclrtrap - called to clear a trap  */
end_comment

begin_function
name|int
name|ctlclrtrap
parameter_list|(
name|sockaddr_u
modifier|*
name|raddr
parameter_list|,
name|struct
name|interface
modifier|*
name|linter
parameter_list|,
name|int
name|traptype
parameter_list|)
block|{
specifier|register
name|struct
name|ctl_trap
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctlfindtrap
argument_list|(
name|raddr
argument_list|,
name|linter
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
operator|&&
name|traptype
operator|!=
name|TRAP_TYPE_CONFIG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tp
operator|->
name|tr_flags
operator|=
literal|0
expr_stmt|;
name|num_ctl_traps
operator|--
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctlfindtrap - find a trap given the remote and local addresses  */
end_comment

begin_function
specifier|static
name|struct
name|ctl_trap
modifier|*
name|ctlfindtrap
parameter_list|(
name|sockaddr_u
modifier|*
name|raddr
parameter_list|,
name|struct
name|interface
modifier|*
name|linter
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|COUNTOF
argument_list|(
name|ctl_traps
argument_list|)
condition|;
name|n
operator|++
control|)
if|if
condition|(
operator|(
name|ctl_traps
index|[
name|n
index|]
operator|.
name|tr_flags
operator|&
name|TRAP_INUSE
operator|)
operator|&&
name|ADDR_PORT_EQ
argument_list|(
name|raddr
argument_list|,
operator|&
name|ctl_traps
index|[
name|n
index|]
operator|.
name|tr_addr
argument_list|)
operator|&&
operator|(
name|linter
operator|==
name|ctl_traps
index|[
name|n
index|]
operator|.
name|tr_localaddr
operator|)
condition|)
return|return
operator|&
name|ctl_traps
index|[
name|n
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * report_event - report an event to the trappers  */
end_comment

begin_function
name|void
name|report_event
parameter_list|(
name|int
name|err
parameter_list|,
comment|/* error code */
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
specifier|const
name|char
modifier|*
name|str
comment|/* protostats string */
parameter_list|)
block|{
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* 	 * Report the error to the protostats file, system log and 	 * trappers. 	 */
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Discard a system report if the number of reports of 		 * the same type exceeds the maximum. 		 */
if|if
condition|(
name|ctl_sys_last_event
operator|!=
operator|(
name|u_char
operator|)
name|err
condition|)
name|ctl_sys_num_events
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctl_sys_num_events
operator|>=
name|CTL_SYS_MAXEVENTS
condition|)
return|return;
name|ctl_sys_last_event
operator|=
operator|(
name|u_char
operator|)
name|err
expr_stmt|;
name|ctl_sys_num_events
operator|++
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"0.0.0.0 %04x %02x %s"
argument_list|,
name|ctlsysstatus
argument_list|()
argument_list|,
name|err
argument_list|,
name|eventstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|statstr
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
operator|-
name|len
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|NLOG
argument_list|(
argument|NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Discard a peer report if the number of reports of 		 * the same type exceeds the maximum for that peer. 		 */
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|u_char
name|errlast
decl_stmt|;
name|errlast
operator|=
operator|(
name|u_char
operator|)
name|err
operator|&
operator|~
name|PEER_EVENT
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|last_event
operator|==
name|errlast
condition|)
name|peer
operator|->
name|num_events
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|num_events
operator|>=
name|CTL_PEER_MAXEVENTS
condition|)
return|return;
name|peer
operator|->
name|last_event
operator|=
name|errlast
expr_stmt|;
name|peer
operator|->
name|num_events
operator|++
expr_stmt|;
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
condition|)
name|src
operator|=
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"%s %04x %02x %s"
argument_list|,
name|src
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|,
name|err
argument_list|,
name|eventstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|statstr
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
operator|-
name|len
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|NLOG
argument_list|(
argument|NLOG_PEEREVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
block|}
name|record_proto_stats
argument_list|(
name|statstr
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"event at %lu %s\n"
argument_list|,
name|current_time
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If no trappers, return. 	 */
if|if
condition|(
name|num_ctl_traps
operator|<=
literal|0
condition|)
return|return;
comment|/* 	 * Set up the outgoing packet variables 	 */
name|res_opcode
operator|=
name|CTL_OP_ASYNCMSG
expr_stmt|;
name|res_offset
operator|=
literal|0
expr_stmt|;
name|res_async
operator|=
name|TRUE
expr_stmt|;
name|res_authenticate
operator|=
name|FALSE
expr_stmt|;
name|datapt
operator|=
name|rpkt
operator|.
name|u
operator|.
name|data
expr_stmt|;
name|dataend
operator|=
operator|&
name|rpkt
operator|.
name|u
operator|.
name|data
index|[
name|CTL_MAX_DATA_LEN
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|err
operator|&
name|PEER_EVENT
operator|)
condition|)
block|{
name|rpkt
operator|.
name|associd
operator|=
literal|0
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Include the core system variables and the list. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CS_VARLIST
condition|;
name|i
operator|++
control|)
name|ctl_putsys
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NTP_INSIST
argument_list|(
name|peer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|associd
operator|=
name|htons
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump it all. Later, maybe less. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CP_MAX_NOAUTOKEY
condition|;
name|i
operator|++
control|)
name|ctl_putpeer
argument_list|(
name|i
argument_list|,
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 		 * for clock exception events: add clock variables to 		 * reflect info on exception 		 */
if|if
condition|(
name|err
operator|==
name|PEVNT_CLOCK
condition|)
block|{
name|struct
name|refclockstat
name|cs
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
name|cs
operator|.
name|kv_list
operator|=
name|NULL
expr_stmt|;
name|refclock_control
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|NULL
argument_list|,
operator|&
name|cs
argument_list|)
expr_stmt|;
name|ctl_puthex
argument_list|(
literal|"refclockstatus"
argument_list|,
name|ctlclkstatus
argument_list|(
operator|&
name|cs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CC_MAXCODE
condition|;
name|i
operator|++
control|)
name|ctl_putclock
argument_list|(
name|i
argument_list|,
operator|&
name|cs
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|cs
operator|.
name|kv_list
init|;
name|kv
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|EOV
operator|&
name|kv
operator|->
name|flags
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|DEF
operator|&
name|kv
operator|->
name|flags
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|cs
operator|.
name|kv_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
block|}
comment|/* 	 * We're done, return. 	 */
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mprintf_event - printf-style varargs variant of report_event()  */
end_comment

begin_function
name|int
name|mprintf_event
parameter_list|(
name|int
name|evcode
parameter_list|,
comment|/* event code */
name|struct
name|peer
modifier|*
name|p
parameter_list|,
comment|/* may be NULL */
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
comment|/* msnprintf format */
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|char
name|msg
index|[
literal|512
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mvsnprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|evcode
argument_list|,
name|p
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * ctl_clr_stats - clear stat counters  */
end_comment

begin_function
name|void
name|ctl_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|ctltimereset
operator|=
name|current_time
expr_stmt|;
name|numctlreq
operator|=
literal|0
expr_stmt|;
name|numctlbadpkts
operator|=
literal|0
expr_stmt|;
name|numctlresponses
operator|=
literal|0
expr_stmt|;
name|numctlfrags
operator|=
literal|0
expr_stmt|;
name|numctlerrors
operator|=
literal|0
expr_stmt|;
name|numctlfrags
operator|=
literal|0
expr_stmt|;
name|numctltooshort
operator|=
literal|0
expr_stmt|;
name|numctlinputresp
operator|=
literal|0
expr_stmt|;
name|numctlinputfrag
operator|=
literal|0
expr_stmt|;
name|numctlinputerr
operator|=
literal|0
expr_stmt|;
name|numctlbadoffset
operator|=
literal|0
expr_stmt|;
name|numctlbadversion
operator|=
literal|0
expr_stmt|;
name|numctldatatooshort
operator|=
literal|0
expr_stmt|;
name|numctlbadop
operator|=
literal|0
expr_stmt|;
name|numasyncmsgs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_short
name|count_var
parameter_list|(
specifier|const
name|struct
name|ctl_var
modifier|*
name|k
parameter_list|)
block|{
name|u_int
name|c
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|k
condition|)
return|return
literal|0
return|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|EOV
operator|&
operator|(
name|k
operator|++
operator|)
operator|->
name|flags
operator|)
condition|)
name|c
operator|++
expr_stmt|;
name|NTP_ENSURE
argument_list|(
name|c
operator|<=
name|USHRT_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
name|u_short
operator|)
name|c
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|add_var
parameter_list|(
name|struct
name|ctl_var
modifier|*
modifier|*
name|kv
parameter_list|,
name|u_long
name|size
parameter_list|,
name|u_short
name|def
parameter_list|)
block|{
name|u_short
name|c
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|c
operator|=
name|count_var
argument_list|(
operator|*
name|kv
argument_list|)
expr_stmt|;
operator|*
name|kv
operator|=
name|erealloc
argument_list|(
operator|*
name|kv
argument_list|,
operator|(
name|c
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|kv
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|=
operator|*
name|kv
expr_stmt|;
name|buf
operator|=
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|k
index|[
name|c
index|]
operator|.
name|code
operator|=
name|c
expr_stmt|;
name|k
index|[
name|c
index|]
operator|.
name|text
operator|=
name|buf
expr_stmt|;
name|k
index|[
name|c
index|]
operator|.
name|flags
operator|=
name|def
expr_stmt|;
name|k
index|[
name|c
operator|+
literal|1
index|]
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|k
index|[
name|c
operator|+
literal|1
index|]
operator|.
name|text
operator|=
name|NULL
expr_stmt|;
name|k
index|[
name|c
operator|+
literal|1
index|]
operator|.
name|flags
operator|=
name|EOV
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|set_var
parameter_list|(
name|struct
name|ctl_var
modifier|*
modifier|*
name|kv
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|u_long
name|size
parameter_list|,
name|u_short
name|def
parameter_list|)
block|{
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|td
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|data
operator|||
operator|!
name|size
condition|)
return|return;
name|k
operator|=
operator|*
name|kv
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|EOV
operator|&
name|k
operator|->
name|flags
operator|)
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|k
operator|->
name|text
condition|)
block|{
name|td
operator|=
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|td
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|k
operator|->
name|text
operator|=
name|td
expr_stmt|;
name|k
operator|->
name|flags
operator|=
name|def
expr_stmt|;
return|return;
block|}
else|else
block|{
name|s
operator|=
name|data
expr_stmt|;
name|t
operator|=
name|k
operator|->
name|text
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|!=
literal|'='
operator|&&
operator|*
name|s
operator|==
operator|*
name|t
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|t
operator|&&
operator|(
operator|(
operator|*
name|t
operator|==
literal|'='
operator|)
operator|||
operator|!
operator|*
name|t
operator|)
condition|)
block|{
name|td
operator|=
name|erealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|k
operator|->
name|text
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|td
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|k
operator|->
name|text
operator|=
name|td
expr_stmt|;
name|k
operator|->
name|flags
operator|=
name|def
expr_stmt|;
return|return;
block|}
block|}
name|k
operator|++
expr_stmt|;
block|}
block|}
name|td
operator|=
name|add_var
argument_list|(
name|kv
argument_list|,
name|size
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|td
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_sys_var
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|u_long
name|size
parameter_list|,
name|u_short
name|def
parameter_list|)
block|{
name|set_var
argument_list|(
operator|&
name|ext_sys_var
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get_ext_sys_var() retrieves the value of a user-defined variable or  * NULL if the variable has not been setvar'd.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_ext_sys_var
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
name|size_t
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|ext_sys_var
init|;
operator|!
operator|(
name|EOV
operator|&
name|v
operator|->
name|flags
operator|)
condition|;
name|v
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|v
operator|->
name|text
operator|&&
operator|!
name|memcmp
argument_list|(
name|tag
argument_list|,
name|v
operator|->
name|text
argument_list|,
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
literal|'='
operator|==
name|v
operator|->
name|text
index|[
name|c
index|]
condition|)
block|{
name|val
operator|=
name|v
operator|->
name|text
operator|+
name|c
operator|+
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
literal|'\0'
operator|==
name|v
operator|->
name|text
index|[
name|c
index|]
condition|)
block|{
name|val
operator|=
literal|""
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|free_varlist
parameter_list|(
name|struct
name|ctl_var
modifier|*
name|kv
parameter_list|)
block|{
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
if|if
condition|(
name|kv
condition|)
block|{
for|for
control|(
name|k
operator|=
name|kv
init|;
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

