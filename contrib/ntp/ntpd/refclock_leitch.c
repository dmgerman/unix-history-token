begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_leitch - clock driver for the Leitch CSD-5300 Master Clock  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_LEITCH
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STREAM
end_ifdef

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LEITCHCLK
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/clkdefs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LEITCHCLK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAM */
end_comment

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Driver for Leitch CSD-5300 Master Clock System  *  * COMMANDS:  *	DATE:	D<CR>  *	TIME:	T<CR>  *	STATUS:	S<CR>  *	LOOP:	L<CR>  *  * FORMAT:  *	DATE: YYMMDD<CR>  *	TIME:<CR>/HHMMSS<CR>/HHMMSS<CR>/HHMMSS<CR>/  *		second bondaried on the stop bit of the<CR>  *		second boundaries at '/' above.  *	STATUS: G (good), D (diag fail), T (time not provided) or  *		P (last phone update failed)  */
end_comment

begin_define
define|#
directive|define
name|MAXUNITS
value|1
end_define

begin_comment
comment|/* max number of LEITCH units */
end_comment

begin_define
define|#
directive|define
name|LEITCHREFID
value|"ATOM"
end_define

begin_comment
comment|/* reference id */
end_comment

begin_define
define|#
directive|define
name|LEITCH_DESCRIPTION
value|"Leitch: CSD 5300 Master Clock System Driver"
end_define

begin_define
define|#
directive|define
name|LEITCH232
value|"/dev/leitch%d"
end_define

begin_comment
comment|/* name of radio device */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B300
end_define

begin_comment
comment|/* uart speed (300 baud) */
end_comment

begin_define
define|#
directive|define
name|leitch_send
parameter_list|(
name|A
parameter_list|,
name|M
parameter_list|)
define|\
value|if (debug) fprintf(stderr,"write leitch %s\n",M); \ if ((write(A->leitchio.fd,M,sizeof(M))< 0)) {\ 						      if (debug) \ 									 fprintf(stderr, "leitch_send: unit %d send failed\n", A->unit); \ 																		 else \ 																			      msyslog(LOG_ERR, "leitch_send: unit %d send failed %m",A->unit);}
end_define

begin_define
define|#
directive|define
name|STATE_IDLE
value|0
end_define

begin_define
define|#
directive|define
name|STATE_DATE
value|1
end_define

begin_define
define|#
directive|define
name|STATE_TIME1
value|2
end_define

begin_define
define|#
directive|define
name|STATE_TIME2
value|3
end_define

begin_define
define|#
directive|define
name|STATE_TIME3
value|4
end_define

begin_comment
comment|/*  * LEITCH unit control structure  */
end_comment

begin_struct
struct|struct
name|leitchunit
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockio
name|leitchio
decl_stmt|;
name|u_char
name|unit
decl_stmt|;
name|short
name|year
decl_stmt|;
name|short
name|yearday
decl_stmt|;
name|short
name|month
decl_stmt|;
name|short
name|day
decl_stmt|;
name|short
name|hour
decl_stmt|;
name|short
name|second
decl_stmt|;
name|short
name|minute
decl_stmt|;
name|short
name|state
decl_stmt|;
name|u_short
name|fudge1
decl_stmt|;
name|l_fp
name|reftime1
decl_stmt|;
name|l_fp
name|reftime2
decl_stmt|;
name|l_fp
name|reftime3
decl_stmt|;
name|l_fp
name|codetime1
decl_stmt|;
name|l_fp
name|codetime2
decl_stmt|;
name|l_fp
name|codetime3
decl_stmt|;
name|u_long
name|yearstart
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|leitch_init
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|leitch_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|leitch_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|leitch_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|leitch_control
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|leitch_buginfo
value|noentry
end_define

begin_decl_stmt
specifier|static
name|void
name|leitch_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|leitch_process
name|P
argument_list|(
operator|(
expr|struct
name|leitchunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static	void	leitch_timeout	P((struct peer *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|leitch_get_date
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
expr|struct
name|leitchunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|leitch_get_time
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
expr|struct
name|leitchunit
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|days_per_year
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|leitchunit
name|leitchunits
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|unitinuse
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|stratumtouse
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32
name|refid
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|days_in_month
index|[]
init|=
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_leitch
init|=
block|{
name|leitch_start
block|,
name|leitch_shutdown
block|,
name|leitch_poll
block|,
name|leitch_control
block|,
name|leitch_init
block|,
name|leitch_buginfo
block|,
name|NOFLAGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * leitch_init - initialize internal leitch driver data  */
end_comment

begin_function
specifier|static
name|void
name|leitch_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|leitchunits
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|leitchunits
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unitinuse
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|unitinuse
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNITS
condition|;
name|i
operator|++
control|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|refid
index|[
name|i
index|]
argument_list|,
name|LEITCHREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * leitch_shutdown - shut down a LEITCH clock  */
end_comment

begin_function
specifier|static
name|void
name|leitch_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"leitch_shutdown()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * leitch_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|leitch_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|leitchunit
modifier|*
name|leitch
decl_stmt|;
comment|/* start the state machine rolling */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"leitch_poll()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unit
operator|>
name|MAXUNITS
condition|)
block|{
comment|/* XXXX syslog it */
return|return;
block|}
name|leitch
operator|=
operator|&
name|leitchunits
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|leitch
operator|->
name|state
operator|!=
name|STATE_IDLE
condition|)
block|{
comment|/* reset and wait for next poll */
comment|/* XXXX syslog it */
name|leitch
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
block|}
else|else
block|{
name|leitch_send
argument_list|(
name|leitch
argument_list|,
literal|"D\r"
argument_list|)
expr_stmt|;
name|leitch
operator|->
name|state
operator|=
name|STATE_DATE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|leitch_control
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|in
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out
parameter_list|,
name|struct
name|peer
modifier|*
name|passed_peer
parameter_list|)
block|{
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_control: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|in
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
condition|)
name|stratumtouse
index|[
name|unit
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|in
operator|->
name|fudgeval1
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL2
condition|)
name|refid
index|[
name|unit
index|]
operator|=
name|in
operator|->
name|fudgeval2
expr_stmt|;
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|peer
operator|=
operator|(
operator|&
name|leitchunits
index|[
name|unit
index|]
operator|)
operator|->
name|peer
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|refid
index|[
name|unit
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refclockstat
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|->
name|type
operator|=
name|REFCLK_ATOM_LEITCH
expr_stmt|;
name|out
operator|->
name|haveflags
operator|=
name|CLK_HAVEVAL1
operator||
name|CLK_HAVEVAL2
expr_stmt|;
name|out
operator|->
name|fudgeval1
operator|=
operator|(
name|int32
operator|)
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|fudgeval2
operator|=
name|refid
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|p_lastcode
operator|=
literal|""
expr_stmt|;
name|out
operator|->
name|clockdesc
operator|=
name|LEITCH_DESCRIPTION
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * leitch_start - open the LEITCH devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|leitch_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|leitchunit
modifier|*
name|leitch
decl_stmt|;
name|int
name|fd232
decl_stmt|;
name|char
name|leitchdev
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Check configuration info. 	 */
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: unit %d in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Open serial port. 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|leitchdev
argument_list|,
name|LEITCH232
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fd232
operator|=
name|open
argument_list|(
name|leitchdev
argument_list|,
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd232
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: open of %s: %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|leitch
operator|=
operator|&
name|leitchunits
index|[
name|unit
index|]
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|leitch
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|leitch
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
comment|/* 	 * System V serial line parameters (termio interface) 	 * 	 */
block|{
name|struct
name|termio
name|ttyb
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: ioctl(%s, TCGETA): %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyb
operator|.
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyb
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyb
operator|.
name|c_cflag
operator|=
name|SPEED232
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyb
operator|.
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyb
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyb
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: ioctl(%s, TCSETA): %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
comment|/* 	 * POSIX serial line parameters (termios interface) 	 * 	 * The LEITCHCLK option provides timestamping at the driver level.  	 * It requires the tty_clk streams module. 	 */
block|{
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd232
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: tcgetattr(%s): %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|SPEED232
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd232
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: tcsetattr(%s): %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|if
condition|(
name|tcflush
argument_list|(
name|fd232
argument_list|,
name|TCIOFLUSH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: tcflush(%s): %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|STREAM
if|#
directive|if
name|defined
argument_list|(
name|LEITCHCLK
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_PUSH
argument_list|,
literal|"clk"
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: ioctl(%s, I_PUSH, clk): %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|CLK_SETSTR
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: ioctl(%s, CLK_SETSTR): %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LEITCHCLK */
endif|#
directive|endif
comment|/* STREAM */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
comment|/* 	 * 4.3bsd serial line parameters (sgttyb interface) 	 * 	 * The LEITCHCLK option provides timestamping at the driver level.  	 * It requires the tty_clk line discipline and 4.3bsd or later. 	 */
block|{
name|struct
name|sgttyb
name|ttyb
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LEITCHCLK
argument_list|)
name|int
name|ldisc
init|=
name|CLKLDISC
decl_stmt|;
endif|#
directive|endif
comment|/* LEITCHCLK */
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: ioctl(%s, TIOCGETP): %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyb
operator|.
name|sg_ispeed
operator|=
name|ttyb
operator|.
name|sg_ospeed
operator|=
name|SPEED232
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LEITCHCLK
argument_list|)
name|ttyb
operator|.
name|sg_erase
operator|=
name|ttyb
operator|.
name|sg_kill
operator|=
literal|'\r'
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|=
name|RAW
expr_stmt|;
else|#
directive|else
name|ttyb
operator|.
name|sg_erase
operator|=
name|ttyb
operator|.
name|sg_kill
operator|=
literal|'\0'
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|=
name|EVENP
operator||
name|ODDP
operator||
name|CRMOD
expr_stmt|;
endif|#
directive|endif
comment|/* LEITCHCLK */
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: ioctl(%s, TIOCSETP): %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|LEITCHCLK
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitch_start: ioctl(%s, TIOCSETD): %m"
argument_list|,
name|leitchdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
endif|#
directive|endif
comment|/* LEITCHCLK */
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
comment|/* 	 * Set up the structures 	 */
name|leitch
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|leitch
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|leitch
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
name|leitch
operator|->
name|fudge1
operator|=
literal|15
expr_stmt|;
comment|/* 15ms */
name|leitch
operator|->
name|leitchio
operator|.
name|clock_recv
operator|=
name|leitch_receive
expr_stmt|;
name|leitch
operator|->
name|leitchio
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|leitch
expr_stmt|;
name|leitch
operator|->
name|leitchio
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|leitch
operator|->
name|leitchio
operator|.
name|fd
operator|=
name|fd232
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|leitch
operator|->
name|leitchio
argument_list|)
condition|)
block|{
goto|goto
name|screwed
goto|;
block|}
comment|/* 	 * All done.  Initialize a few random peer variables, then 	 * return success. 	 */
name|peer
operator|->
name|precision
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|refid
index|[
name|unit
index|]
expr_stmt|;
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Something broke; abandon ship. 	 */
name|screwed
label|:
name|close
argument_list|(
name|fd232
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * leitch_receive - receive data from the serial interface on a leitch  * clock  */
end_comment

begin_function
specifier|static
name|void
name|leitch_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|struct
name|leitchunit
modifier|*
name|leitch
init|=
operator|(
expr|struct
name|leitchunit
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"leitch_recieve(%*.*s)\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
name|rbufp
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|!=
literal|7
condition|)
return|return;
comment|/* The date is return with a trailing newline, 		       discard it. */
switch|switch
condition|(
name|leitch
operator|->
name|state
condition|)
block|{
case|case
name|STATE_IDLE
case|:
comment|/* unexpected, discard and resync */
return|return;
case|case
name|STATE_DATE
case|:
if|if
condition|(
operator|!
name|leitch_get_date
argument_list|(
name|rbufp
argument_list|,
name|leitch
argument_list|)
condition|)
block|{
name|leitch
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
break|break;
block|}
name|leitch_send
argument_list|(
name|leitch
argument_list|,
literal|"T\r"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%u\n"
argument_list|,
name|leitch
operator|->
name|yearday
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|leitch
operator|->
name|state
operator|=
name|STATE_TIME1
expr_stmt|;
break|break;
case|case
name|STATE_TIME1
case|:
if|if
condition|(
operator|!
name|leitch_get_time
argument_list|(
name|rbufp
argument_list|,
name|leitch
argument_list|,
literal|1
argument_list|)
condition|)
block|{ 		}
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|leitch
operator|->
name|yearday
argument_list|,
name|leitch
operator|->
name|hour
argument_list|,
name|leitch
operator|->
name|minute
argument_list|,
name|leitch
operator|->
name|second
argument_list|,
literal|1
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_ui
argument_list|,
operator|&
name|leitch
operator|->
name|yearstart
argument_list|,
operator|&
name|leitch
operator|->
name|reftime1
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|leitch
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|leitch
operator|->
name|reftime1
operator|.
name|l_ui
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MSUTOTSF
argument_list|(
name|leitch
operator|->
name|fudge1
argument_list|,
name|leitch
operator|->
name|reftime1
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|leitch
operator|->
name|codetime1
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|leitch
operator|->
name|state
operator|=
name|STATE_TIME2
expr_stmt|;
break|break;
case|case
name|STATE_TIME2
case|:
if|if
condition|(
operator|!
name|leitch_get_time
argument_list|(
name|rbufp
argument_list|,
name|leitch
argument_list|,
literal|2
argument_list|)
condition|)
block|{ 		}
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|leitch
operator|->
name|yearday
argument_list|,
name|leitch
operator|->
name|hour
argument_list|,
name|leitch
operator|->
name|minute
argument_list|,
name|leitch
operator|->
name|second
argument_list|,
literal|1
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_ui
argument_list|,
operator|&
name|leitch
operator|->
name|yearstart
argument_list|,
operator|&
name|leitch
operator|->
name|reftime2
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|leitch
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|leitch
operator|->
name|reftime2
operator|.
name|l_ui
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MSUTOTSF
argument_list|(
name|leitch
operator|->
name|fudge1
argument_list|,
name|leitch
operator|->
name|reftime2
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|leitch
operator|->
name|codetime2
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|leitch
operator|->
name|state
operator|=
name|STATE_TIME3
expr_stmt|;
break|break;
case|case
name|STATE_TIME3
case|:
if|if
condition|(
operator|!
name|leitch_get_time
argument_list|(
name|rbufp
argument_list|,
name|leitch
argument_list|,
literal|3
argument_list|)
condition|)
block|{ 		}
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|leitch
operator|->
name|yearday
argument_list|,
name|leitch
operator|->
name|hour
argument_list|,
name|leitch
operator|->
name|minute
argument_list|,
name|leitch
operator|->
name|second
argument_list|,
name|GMT
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_ui
argument_list|,
operator|&
name|leitch
operator|->
name|yearstart
argument_list|,
operator|&
name|leitch
operator|->
name|reftime3
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|leitch
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|leitch
operator|->
name|reftime3
operator|.
name|l_ui
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MSUTOTSF
argument_list|(
name|leitch
operator|->
name|fudge1
argument_list|,
name|leitch
operator|->
name|reftime3
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|leitch
operator|->
name|codetime3
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|leitch_process
argument_list|(
name|leitch
argument_list|)
expr_stmt|;
name|leitch
operator|->
name|state
operator|=
name|STATE_IDLE
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leitech_receive: invalid state %d unit %d"
argument_list|,
name|leitch
operator|->
name|state
argument_list|,
name|leitch
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * leitch_process - process a pile of samples from the clock  *  * This routine uses a three-stage median filter to calculate offset and  * dispersion. reduce jitter. The dispersion is calculated as the span  * of the filter (max - min), unless the quality character (format 2) is  * non-blank, in which case the dispersion is calculated on the basis of  * the inherent tolerance of the internal radio oscillator, which is  * +-2e-5 according to the radio specifications.  */
end_comment

begin_function
specifier|static
name|void
name|leitch_process
parameter_list|(
name|struct
name|leitchunit
modifier|*
name|leitch
parameter_list|)
block|{
name|l_fp
name|off
decl_stmt|;
name|l_fp
name|tmp_fp
decl_stmt|;
comment|/*double doffset;*/
name|off
operator|=
name|leitch
operator|->
name|reftime1
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|leitch
operator|->
name|codetime1
argument_list|)
expr_stmt|;
name|tmp_fp
operator|=
name|leitch
operator|->
name|reftime2
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tmp_fp
argument_list|,
operator|&
name|leitch
operator|->
name|codetime2
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISGEQ
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|tmp_fp
argument_list|)
condition|)
name|off
operator|=
name|tmp_fp
expr_stmt|;
name|tmp_fp
operator|=
name|leitch
operator|->
name|reftime3
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tmp_fp
argument_list|,
operator|&
name|leitch
operator|->
name|codetime3
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISGEQ
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|tmp_fp
argument_list|)
condition|)
name|off
operator|=
name|tmp_fp
expr_stmt|;
comment|/*LFPTOD(&off, doffset);*/
name|refclock_receive
argument_list|(
name|leitch
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * days_per_year  */
end_comment

begin_function
specifier|static
name|int
name|days_per_year
parameter_list|(
name|int
name|year
parameter_list|)
block|{
if|if
condition|(
name|year
operator|%
literal|4
condition|)
block|{
comment|/* not a potential leap year */
return|return
operator|(
literal|365
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|year
operator|%
literal|100
condition|)
block|{
comment|/* is a leap year */
return|return
operator|(
literal|366
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|year
operator|%
literal|400
condition|)
block|{
return|return
operator|(
literal|365
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|366
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|leitch_get_date
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|struct
name|leitchunit
modifier|*
name|leitch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|<
literal|6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|BAD
comment|/* confict: defined as (-1) in AIX sys/param.h */
define|#
directive|define
name|BAD
parameter_list|(
name|A
parameter_list|)
value|(rbufp->recv_buffer[A]< '0') || (rbufp->recv_buffer[A]> '9')
if|if
condition|(
name|BAD
argument_list|(
literal|0
argument_list|)
operator|||
name|BAD
argument_list|(
literal|1
argument_list|)
operator|||
name|BAD
argument_list|(
literal|2
argument_list|)
operator|||
name|BAD
argument_list|(
literal|3
argument_list|)
operator|||
name|BAD
argument_list|(
literal|4
argument_list|)
operator|||
name|BAD
argument_list|(
literal|5
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
define|#
directive|define
name|ATOB
parameter_list|(
name|A
parameter_list|)
value|((rbufp->recv_buffer[A])-'0')
name|leitch
operator|->
name|year
operator|=
name|ATOB
argument_list|(
literal|0
argument_list|)
operator|*
literal|10
operator|+
name|ATOB
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|leitch
operator|->
name|month
operator|=
name|ATOB
argument_list|(
literal|2
argument_list|)
operator|*
literal|10
operator|+
name|ATOB
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|leitch
operator|->
name|day
operator|=
name|ATOB
argument_list|(
literal|4
argument_list|)
operator|*
literal|10
operator|+
name|ATOB
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
name|leitch
operator|->
name|month
operator|>
literal|12
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|leitch
operator|->
name|day
operator|>
name|days_in_month
index|[
name|leitch
operator|->
name|month
operator|-
literal|1
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* calculate yearday */
name|i
operator|=
literal|0
expr_stmt|;
name|leitch
operator|->
name|yearday
operator|=
name|leitch
operator|->
name|day
expr_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|leitch
operator|->
name|month
operator|-
literal|1
operator|)
condition|)
name|leitch
operator|->
name|yearday
operator|+=
name|days_in_month
index|[
name|i
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|days_per_year
argument_list|(
operator|(
name|leitch
operator|->
name|year
operator|>
literal|90
condition|?
literal|1900
else|:
literal|2000
operator|)
operator|+
name|leitch
operator|->
name|year
argument_list|)
operator|==
literal|365
operator|)
operator|&&
name|leitch
operator|->
name|month
operator|>
literal|2
condition|)
name|leitch
operator|->
name|yearday
operator|--
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * leitch_get_time  */
end_comment

begin_function
specifier|static
name|int
name|leitch_get_time
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|struct
name|leitchunit
modifier|*
name|leitch
parameter_list|,
name|int
name|which
parameter_list|)
block|{
if|if
condition|(
name|BAD
argument_list|(
literal|0
argument_list|)
operator|||
name|BAD
argument_list|(
literal|1
argument_list|)
operator|||
name|BAD
argument_list|(
literal|2
argument_list|)
operator|||
name|BAD
argument_list|(
literal|3
argument_list|)
operator|||
name|BAD
argument_list|(
literal|4
argument_list|)
operator|||
name|BAD
argument_list|(
literal|5
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|leitch
operator|->
name|hour
operator|=
name|ATOB
argument_list|(
literal|0
argument_list|)
operator|*
literal|10
operator|+
name|ATOB
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|leitch
operator|->
name|minute
operator|=
name|ATOB
argument_list|(
literal|2
argument_list|)
operator|*
literal|10
operator|+
name|ATOB
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|leitch
operator|->
name|second
operator|=
name|ATOB
argument_list|(
literal|4
argument_list|)
operator|*
literal|10
operator|+
name|ATOB
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|leitch
operator|->
name|hour
operator|>
literal|23
operator|)
operator|||
operator|(
name|leitch
operator|->
name|minute
operator|>
literal|60
operator|)
operator|||
operator|(
name|leitch
operator|->
name|second
operator|>
literal|60
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_leitch_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

