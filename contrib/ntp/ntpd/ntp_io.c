begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_io.c - input/output routines for ntpd.	The socket-opening code  *		   was shamelessly stolen from ntpd.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"iosignal.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_request.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_comment
comment|/* Don't include ISC's version of IPv6 variables and structures */
end_comment

begin_define
define|#
directive|define
name|ISC_IPV6_H
value|1
end_define

begin_include
include|#
directive|include
file|<isc/interfaceiter.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_include
include|#
directive|include
file|"ntpsim.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_PARAM_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKIO_H
end_ifdef

begin_comment
comment|/* UXPV: SIOC* #defines (Frank Vance<fvance@waii.com>) */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * setsockopt does not always have the same arg declaration  * across all platforms. If it's not defined we make it empty  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SETSOCKOPT_ARG_CAST
end_ifndef

begin_define
define|#
directive|define
name|SETSOCKOPT_ARG_CAST
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * Set up some macros to look for IPv6 and IPv6 multicast  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIPV6
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DISABLE_IPV6
argument_list|)
end_if

begin_define
define|#
directive|define
name|INCLUDE_IPV6_SUPPORT
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INCLUDE_IPV6_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPV6_JOIN_GROUP
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPV6_LEAVE_GROUP
argument_list|)
end_if

begin_define
define|#
directive|define
name|INCLUDE_IPV6_MULTICAST_SUPPORT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPV6 Multicast Support */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPv6 Support */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !INCLUDE_IPV6_SUPPORT */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|listen_to_virtual_ips
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|specific_interface
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SO_TIMESTAMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCM_TIMESTAMP
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CMSG_FIRSTHDR
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_TIMESTAMP
end_define

begin_define
define|#
directive|define
name|USE_TIMESTAMP_CMSG
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TIMESTAMP_CTLMSGBUF_SIZE
end_ifndef

begin_define
define|#
directive|define
name|TIMESTAMP_CTLMSGBUF_SIZE
value|1536
end_define

begin_comment
comment|/* moderate default */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* fill in for old/other timestamp interfaces */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<transmitbuff.h>
end_include

begin_include
include|#
directive|include
file|<isc/win32os.h>
end_include

begin_comment
comment|/*  * Define this macro to control the behavior of connection  * resets on UDP sockets.  See Microsoft KnowledgeBase Article Q263823  * for details.  * NOTE: This requires that Windows 2000 systems install Service Pack 2  * or later.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIO_UDP_CONNRESET
end_ifndef

begin_define
define|#
directive|define
name|SIO_UDP_CONNRESET
value|_WSAIOW(IOC_VENDOR,12)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Windows C runtime ioctl() can't deal properly with sockets,   * map to ioctlsocket for this source file.  */
end_comment

begin_define
define|#
directive|define
name|ioctl
parameter_list|(
name|fd
parameter_list|,
name|opt
parameter_list|,
name|val
parameter_list|)
value|ioctlsocket((fd), (opt), (u_long *)(val))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * We do asynchronous input using the SIGIO facility.  A number of  * recvbuf buffers are preallocated for input.	In the signal  * handler we poll to see which sockets are ready and read the  * packets from them into the recvbuf's along with a time stamp and  * an indication of the source host and the interface it was received  * through.  This allows us to get as accurate receive time stamps  * as possible independent of other processing going on.  *  * We watch the number of recvbufs available to the signal handler  * and allocate more when this number drops below the low water  * mark.  If the signal handler should run out of buffers in the  * interim it will drop incoming frames, the idea being that it is  * better to drop a packet than to be inaccurate.  */
end_comment

begin_comment
comment|/*  * Other statistics of possible interest  */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_dropped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets dropped on reception */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_ignored
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets received on wild card interface */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_received
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets received */
end_comment

begin_decl_stmt
name|u_long
name|packets_sent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets sent */
end_comment

begin_decl_stmt
name|u_long
name|packets_notsent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets which couldn't be sent */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|handler_calls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of calls to interrupt handler */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|handler_pkts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pkts received by handler */
end_comment

begin_decl_stmt
name|u_long
name|io_timereset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time counters were reset */
end_comment

begin_comment
comment|/*  * Interface stuff  */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default ipv4 interface */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|any6_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default ipv6 interface */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|loopback_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* loopback ipv4 interface */
end_comment

begin_decl_stmt
name|int
name|ninterfaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of interfaces */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|disable_dynamic_updates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* when set to != 0 dynamic updates won't happen */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * Refclock stuff.	We keep a chain of structures with data concerning  * the guys we are doing I/O for.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|refclockio
modifier|*
name|refio
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_comment
comment|/*  * Define what the possible "soft" errors can be.  These are non-fatal returns  * of various network related functions, like recv() and so on.  *  * For some reason, BSDI (and perhaps others) will sometimes return<0  * from recv() but will have errno==0.  This is broken, but we have to  * work around it here.  */
end_comment

begin_define
define|#
directive|define
name|SOFT_ERROR
parameter_list|(
name|e
parameter_list|)
value|((e) == EAGAIN || \ 			 (e) == EWOULDBLOCK || \ 			 (e) == EINTR || \ 			 (e) == 0)
end_define

begin_comment
comment|/*  * File descriptor masks etc. for call to select  * Not needed for I/O Completion Ports  */
end_comment

begin_decl_stmt
name|fd_set
name|activefds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxactivefd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * bit alternating value to detect verified interfaces during an update cycle  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|sys_interphase
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|new_interface
name|P
argument_list|(
operator|(
expr|struct
name|interface
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_interface
name|P
argument_list|(
operator|(
expr|struct
name|interface
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_interfaces
name|P
argument_list|(
operator|(
name|u_short
operator|,
name|interface_receiver_t
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_interface
name|P
argument_list|(
operator|(
expr|struct
name|interface
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|create_interface
name|P
argument_list|(
operator|(
name|u_short
operator|,
expr|struct
name|interface
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|move_fd
name|P
argument_list|(
operator|(
name|SOCKET
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Multicast functions  */
end_comment

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|addr_ismulticast
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Not all platforms support multicast  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MCAST
end_ifdef

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|socket_multicast_enable
name|P
argument_list|(
operator|(
expr|struct
name|interface
operator|*
operator|,
name|int
operator|,
expr|struct
name|sockaddr_storage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|socket_multicast_disable
name|P
argument_list|(
operator|(
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|sockaddr_storage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|print_interface
name|P
argument_list|(
operator|(
expr|struct
name|interface
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DPRINT_INTERFACE
parameter_list|(
name|_LVL_
parameter_list|,
name|_ARGS_
parameter_list|)
value|do { if (debug>= (_LVL_)) { print_interface _ARGS_; } } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINT_INTERFACE
parameter_list|(
name|_LVL_
parameter_list|,
name|_ARGS_
parameter_list|)
value|do {} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|vsock
name|vsock_t
typedef|;
end_typedef

begin_enum
enum|enum
name|desc_type
block|{
name|FD_TYPE_SOCKET
block|,
name|FD_TYPE_FILE
block|}
enum|;
end_enum

begin_struct
struct|struct
name|vsock
block|{
name|SOCKET
name|fd
decl_stmt|;
name|enum
name|desc_type
name|type
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|vsock_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_ROUTING_SOCKET
argument_list|)
end_if

begin_comment
comment|/*  * async notification processing (e. g. routing sockets)  */
end_comment

begin_comment
comment|/*  * support for receiving data on fd that is not a refclock or a socket  * like e. g. routing sockets  */
end_comment

begin_struct
struct|struct
name|asyncio_reader
block|{
name|SOCKET
name|fd
decl_stmt|;
comment|/* fd to be read */
name|void
modifier|*
name|data
decl_stmt|;
comment|/* possibly local data */
name|void
function_decl|(
modifier|*
name|receiver
function_decl|)
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
parameter_list|)
function_decl|;
comment|/* input handler */
name|ISC_LINK
argument_list|(
argument|struct asyncio_reader
argument_list|)
name|link
expr_stmt|;
comment|/* the list this is being kept in */
block|}
struct|;
end_struct

begin_macro
name|ISC_LIST
argument_list|(
argument|struct asyncio_reader
argument_list|)
end_macro

begin_expr_stmt
name|asyncio_reader_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_asyncio_reader
name|P
argument_list|(
operator|(
expr|struct
name|asyncio_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|asyncio_reader
modifier|*
name|new_asyncio_reader
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_asyncio_reader
name|P
argument_list|(
operator|(
expr|struct
name|asyncio_reader
operator|*
operator|,
expr|enum
name|desc_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_asyncio_reader
name|P
argument_list|(
operator|(
expr|struct
name|asyncio_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_IO_COMPLETION_PORT)&& defined(HAS_ROUTING_SOCKET) */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_async_notifications
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|create_sockets
name|P
argument_list|(
operator|(
name|u_short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SOCKET
name|open_socket
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|interface
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fdbits
name|P
argument_list|(
operator|(
name|int
operator|,
name|fd_set
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_reuseaddr
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|socket_broadcast_enable
name|P
argument_list|(
operator|(
expr|struct
name|interface
operator|*
operator|,
name|SOCKET
operator|,
expr|struct
name|sockaddr_storage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|socket_broadcast_disable
name|P
argument_list|(
operator|(
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|sockaddr_storage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|ISC_LIST
argument_list|(
argument|vsock_t
argument_list|)
end_macro

begin_expr_stmt
name|fd_list
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|remaddr
name|remaddr_t
typedef|;
end_typedef

begin_struct
struct|struct
name|remaddr
block|{
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|struct
name|interface
modifier|*
name|interface
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|remaddr_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ISC_LIST
argument_list|(
argument|remaddr_t
argument_list|)
end_macro

begin_expr_stmt
name|remoteaddr_list
expr_stmt|;
end_expr_stmt

begin_macro
name|ISC_LIST
argument_list|(
argument|struct interface
argument_list|)
end_macro

begin_expr_stmt
name|inter_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|wildipv4
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|wildipv6
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_fd_to_list
name|P
argument_list|(
operator|(
name|SOCKET
operator|,
expr|enum
name|desc_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_and_delete_fd_from_list
name|P
argument_list|(
operator|(
name|SOCKET
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_addr_to_list
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_addr_from_list
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|find_addr_in_list
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|find_flagged_addr_in_list
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_wildcards
name|P
argument_list|(
operator|(
name|u_short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|address_okay
name|P
argument_list|(
operator|(
expr|struct
name|interface
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|convert_isc_if
name|P
argument_list|(
operator|(
name|isc_interface_t
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
name|u_short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_interface_from_list
name|P
argument_list|(
operator|(
expr|struct
name|interface
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|getinterface
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|findlocalinterface
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|findlocalcastinterface
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Routines to read the ntp packets  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|read_network_packet
name|P
argument_list|(
operator|(
name|SOCKET
operator|,
expr|struct
name|interface
operator|*
operator|,
name|l_fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|read_refclock_packet
name|P
argument_list|(
operator|(
name|SOCKET
operator|,
expr|struct
name|refclockio
operator|*
operator|,
name|l_fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_comment
comment|/*  * Windows 2000 systems incorrectly cause UDP sockets using WASRecvFrom  * to not work correctly, returning a WSACONNRESET error when a WSASendTo  * fails with an "ICMP port unreachable" response and preventing the  * socket from using the WSARecvFrom in subsequent operations.  * The function below fixes this, but requires that Windows 2000  * Service Pack 2 or later be installed on the system.  NT 4.0  * systems are not affected by this and work correctly.  * See Microsoft Knowledge Base Article Q263823 for details of this.  */
end_comment

begin_function
name|void
name|connection_reset_fix
parameter_list|(
name|SOCKET
name|fd
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|)
block|{
name|DWORD
name|dwBytesReturned
init|=
literal|0
decl_stmt|;
name|BOOL
name|bNewBehavior
init|=
name|FALSE
decl_stmt|;
name|DWORD
name|status
decl_stmt|;
comment|/* 	 * disable bad behavior using IOCTL: SIO_UDP_CONNRESET 	 * NT 4.0 has no problem 	 */
if|if
condition|(
name|isc_win32os_majorversion
argument_list|()
operator|>=
literal|5
condition|)
block|{
name|status
operator|=
name|WSAIoctl
argument_list|(
name|fd
argument_list|,
name|SIO_UDP_CONNRESET
argument_list|,
operator|&
name|bNewBehavior
argument_list|,
sizeof|sizeof
argument_list|(
name|bNewBehavior
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|dwBytesReturned
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOCKET_ERROR
operator|==
name|status
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"connection_reset_fix() "
literal|"failed for address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * on Unix systems the stdio library typically  * makes use of file descriptors in the lower  * integer range. stdio usually will make use  * of the file descriptor in the range of  * [0..FOPEN_MAX)  * in order to keep this range clean for socket  * file descriptors we attempt to move them above  * FOPEM_MAX. This is not as easy as it sounds as  * FOPEN_MAX changes from implementation to implementation  * and may exceed to current file decriptor limits.  * We are using following strategy:  * - keep a current socket fd boundary initialized with  *   max(0, min(getdtablesize() - FD_CHUNK, FOPEN_MAX))  * - attempt to move the descriptor to the boundary or  *   above.  *   - if that fails and boundary> 0 set boundary  *     to min(0, socket_fd_boundary - FD_CHUNK)  *     -> retry  *     if failure and boundary == 0 return old fd  *   - on success close old fd return new fd  *  * effects:  *   - fds will be moved above the socket fd boundary  *     if at all possible.  *   - the socket boundary will be reduced until  *     allocation is possible or 0 is reached - at this  *     point the algrithm will be disabled  */
end_comment

begin_function
specifier|static
name|int
name|move_fd
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_DUPFD
argument_list|)
ifndef|#
directive|ifndef
name|FD_CHUNK
define|#
directive|define
name|FD_CHUNK
value|10
endif|#
directive|endif
comment|/*  * number of fds we would like to have for  * stdio FILE* available.  * we can pick a "low" number as our use of  * FILE* is limited to log files and temporarily  * to data and config files. Except for log files  * we don't keep the other FILE* open beyond the  * scope of the function that opened it.  */
ifndef|#
directive|ifndef
name|FD_PREFERRED_SOCKBOUNDARY
define|#
directive|define
name|FD_PREFERRED_SOCKBOUNDARY
value|48
endif|#
directive|endif
ifndef|#
directive|ifndef
name|HAVE_GETDTABLESIZE
comment|/*  * if we have no idea about the max fd value set up things  * so we will start at FOPEN_MAX  */
define|#
directive|define
name|getdtablesize
parameter_list|()
value|(FOPEN_MAX+FD_CHUNK)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FOPEN_MAX
define|#
directive|define
name|FOPEN_MAX
value|20
comment|/* assume that for the lack of anything better */
endif|#
directive|endif
specifier|static
name|SOCKET
name|socket_boundary
init|=
operator|-
literal|1
decl_stmt|;
name|SOCKET
name|newfd
decl_stmt|;
comment|/* 	 * check whether boundary has be set up 	 * already 	 */
if|if
condition|(
name|socket_boundary
operator|==
operator|-
literal|1
condition|)
block|{
name|socket_boundary
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|min
argument_list|(
name|getdtablesize
argument_list|()
operator|-
name|FD_CHUNK
argument_list|,
name|min
argument_list|(
name|FOPEN_MAX
argument_list|,
name|FD_PREFERRED_SOCKBOUNDARY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ntp_io: estimated max descriptors: %d, initial socket boundary: %d"
argument_list|,
name|getdtablesize
argument_list|()
argument_list|,
name|socket_boundary
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Leave a space for stdio to work in. potentially moving the 	 * socket_boundary lower until allocation succeeds. 	 */
do|do
block|{
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fd
operator|<
name|socket_boundary
condition|)
block|{
comment|/* inside reserved range: attempt to move fd */
name|newfd
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
name|socket_boundary
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* success: drop the old one - return the new one */
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|newfd
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* outside reserved range: no work - return the original one */
return|return
operator|(
name|fd
operator|)
return|;
block|}
name|socket_boundary
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|socket_boundary
operator|-
name|FD_CHUNK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ntp_io: selecting new socket boundary: %d"
argument_list|,
name|socket_boundary
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|socket_boundary
operator|>
literal|0
condition|)
do|;
endif|#
directive|endif
comment|/* !defined(SYS_WINNT)&& defined(F_DUPFD) */
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_TIMING
end_ifdef

begin_comment
comment|/*  * collect timing information for various processing  * paths. currently we only pass then on to the file  * for later processing. this could also do histogram  * based analysis in other to reduce the load (and skew)  * dur to the file output  */
end_comment

begin_function
name|void
name|collect_timing
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rb
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|int
name|count
parameter_list|,
name|l_fp
modifier|*
name|dts
parameter_list|)
block|{
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s %d %s %s"
argument_list|,
operator|(
name|rb
operator|!=
name|NULL
operator|)
condition|?
operator|(
operator|(
name|rb
operator|->
name|dstadr
operator|)
condition|?
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
else|:
literal|"-REFCLOCK-"
operator|)
else|:
literal|"-"
argument_list|,
name|count
argument_list|,
name|lfptoa
argument_list|(
name|dts
argument_list|,
literal|9
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|record_timing_stats
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * About dynamic interfaces, sockets, reception and more...  *  * the code solves following tasks:  *  *   - keep a current list of active interfaces in order  *     to bind to to the interface address on NTP_PORT so that  *     all wild and specific bindings for NTP_PORT are taken by ntpd  *     to avoid other daemons messing with the time or sockets.  *   - all interfaces keep a list of peers that are referencing   *     the interface in order to quickly re-assign the peers to  *     new interface in case an interface is deleted (=> gone from system or  *     down)  *   - have a preconfigured socket ready with the right local address  *     for transmission and reception  *   - have an address list for all destination addresses used within ntpd  *     to find the "right" preconfigured socket.  *   - facilitate updating the internal interface list with respect to  *     the current kernel state  *  * special issues:  *  *   - mapping of multicast addresses to the interface affected is not always  *     one to one - especially on hosts with multiple interfaces  *     the code here currently allocates a separate interface entry for those  *     multicast addresses  *     iff it is able to bind to a *new* socket with the multicast address (flags |= MCASTIF)  *     in case of failure the multicast address is bound to an existing interface.  *   - on some systems it is perfectly legal to assign the same address to  *     multiple interfaces. Therefore this code does not keep a list of interfaces  *     but a list of interfaces that represent a unique address as determined by the kernel  *     by the procedure in findlocalinterface. Thus it is perfectly legal to see only  *     one representative of a group of real interfaces if they share the same address.  *   * Frank Kardel 20050910  */
end_comment

begin_comment
comment|/*  * init_io - initialize I/O data structures and call socket creation routine  */
end_comment

begin_function
name|void
name|init_io
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYS_WINNT
name|init_io_completion_port
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Win32InitSockets
argument_list|()
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No useable winsock.dll: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|init_transmitbuff
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Init buffer free list and stat counters 	 */
name|init_recvbuff
argument_list|(
name|RECV_INIT
argument_list|)
expr_stmt|;
name|packets_dropped
operator|=
name|packets_received
operator|=
literal|0
expr_stmt|;
name|packets_ignored
operator|=
literal|0
expr_stmt|;
name|packets_sent
operator|=
name|packets_notsent
operator|=
literal|0
expr_stmt|;
name|handler_calls
operator|=
name|handler_pkts
operator|=
literal|0
expr_stmt|;
name|io_timereset
operator|=
literal|0
expr_stmt|;
name|loopback_interface
operator|=
name|NULL
expr_stmt|;
name|any_interface
operator|=
name|NULL
expr_stmt|;
name|any6_interface
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
name|refio
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
operator|(
name|void
operator|)
name|set_signal
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ISC_LIST_INIT
argument_list|(
name|fd_list
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_ROUTING_SOCKET
argument_list|)
name|ISC_LIST_INIT
argument_list|(
name|asyncio_reader_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ISC_LIST_INIT
argument_list|(
name|remoteaddr_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|inter_list
argument_list|)
expr_stmt|;
comment|/* 	 * Create the sockets 	 */
name|BLOCKIO
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|create_sockets
argument_list|(
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
name|init_async_notifications
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"init_io: maxactivefd %d\n"
operator|,
name|maxactivefd
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * function to dump the contents of the interface structure  * for debugging use only.  */
end_comment

begin_function
name|void
name|interface_dump
parameter_list|(
name|struct
name|interface
modifier|*
name|itf
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Limit the size of the sockaddr_storage hex dump */
name|int
name|maxsize
init|=
name|min
argument_list|(
literal|32
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"Dumping interface: %p\n"
argument_list|,
name|itf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fd = %d\n"
argument_list|,
name|itf
operator|->
name|fd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bfd = %d\n"
argument_list|,
name|itf
operator|->
name|bfd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sin = %s,\n"
argument_list|,
name|stoa
argument_list|(
operator|&
operator|(
name|itf
operator|->
name|sin
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|itf
operator|->
name|sin
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxsize
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|4
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bcast = %s,\n"
argument_list|,
name|stoa
argument_list|(
operator|&
operator|(
name|itf
operator|->
name|bcast
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|itf
operator|->
name|bcast
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxsize
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|4
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mask = %s,\n"
argument_list|,
name|stoa
argument_list|(
operator|&
operator|(
name|itf
operator|->
name|mask
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|itf
operator|->
name|mask
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxsize
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|4
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"name = %s\n"
argument_list|,
name|itf
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flags = 0x%08x\n"
argument_list|,
name|itf
operator|->
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"last_ttl = %d\n"
argument_list|,
name|itf
operator|->
name|last_ttl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addr_refid = %08x\n"
argument_list|,
name|itf
operator|->
name|addr_refid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"num_mcast = %d\n"
argument_list|,
name|itf
operator|->
name|num_mcast
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"received = %ld\n"
argument_list|,
name|itf
operator|->
name|received
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sent = %ld\n"
argument_list|,
name|itf
operator|->
name|sent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"notsent = %ld\n"
argument_list|,
name|itf
operator|->
name|notsent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ifindex = %u\n"
argument_list|,
name|itf
operator|->
name|ifindex
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scopeid = %u\n"
argument_list|,
name|itf
operator|->
name|scopeid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"peercnt = %u\n"
argument_list|,
name|itf
operator|->
name|peercnt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"phase = %u\n"
argument_list|,
name|itf
operator|->
name|phase
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print_interface - helper to output debug information  */
end_comment

begin_function
specifier|static
name|void
name|print_interface
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|char
modifier|*
name|pfx
parameter_list|,
name|char
modifier|*
name|sfx
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%sinterface #%d: fd=%d, bfd=%d, name=%s, flags=0x%x, scope=%d, ifindex=%d"
argument_list|,
name|pfx
argument_list|,
name|iface
operator|->
name|ifnum
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|iface
operator|->
name|bfd
argument_list|,
name|iface
operator|->
name|name
argument_list|,
name|iface
operator|->
name|flags
argument_list|,
name|iface
operator|->
name|scopeid
argument_list|,
name|iface
operator|->
name|ifindex
argument_list|)
expr_stmt|;
comment|/* Leave these as three printf calls. */
name|printf
argument_list|(
literal|", sin=%s"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|iface
operator|->
name|sin
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|flags
operator|&
name|INT_BROADCAST
condition|)
name|printf
argument_list|(
literal|", bcast=%s,"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|iface
operator|->
name|bcast
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|family
operator|==
name|AF_INET
condition|)
name|printf
argument_list|(
literal|", mask=%s"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|iface
operator|->
name|mask
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %s:%s"
argument_list|,
name|iface
operator|->
name|ignore_packets
operator|==
name|ISC_FALSE
condition|?
literal|"Enabled"
else|:
literal|"Disabled"
argument_list|,
name|sfx
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
comment|/* in-depth debugging only */
name|interface_dump
argument_list|(
name|iface
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_ROUTING_SOCKET
argument_list|)
end_if

begin_comment
comment|/*  * create an asyncio_reader structure  */
end_comment

begin_function
specifier|static
name|struct
name|asyncio_reader
modifier|*
name|new_asyncio_reader
parameter_list|()
block|{
name|struct
name|asyncio_reader
modifier|*
name|reader
decl_stmt|;
name|reader
operator|=
operator|(
expr|struct
name|asyncio_reader
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|asyncio_reader
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reader
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reader
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|reader
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|reader
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
return|return
name|reader
return|;
block|}
end_function

begin_comment
comment|/*  * delete a reader  */
end_comment

begin_function
specifier|static
name|void
name|delete_asyncio_reader
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
name|reader
parameter_list|)
block|{
name|free
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * add asynchio_reader  */
end_comment

begin_function
specifier|static
name|void
name|add_asyncio_reader
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
name|reader
parameter_list|,
name|enum
name|desc_type
name|type
parameter_list|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|asyncio_reader_list
argument_list|,
name|reader
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|add_fd_to_list
argument_list|(
name|reader
operator|->
name|fd
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove asynchio_reader  */
end_comment

begin_function
specifier|static
name|void
name|remove_asyncio_reader
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
name|reader
parameter_list|)
block|{
name|ISC_LIST_UNLINK_TYPE
argument_list|(
name|asyncio_reader_list
argument_list|,
name|reader
argument_list|,
name|link
argument_list|,
expr|struct
name|asyncio_reader
argument_list|)
expr_stmt|;
if|if
condition|(
name|reader
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
name|close_and_delete_fd_from_list
argument_list|(
name|reader
operator|->
name|fd
argument_list|)
expr_stmt|;
name|reader
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_IO_COMPLETION_PORT)&& defined(HAS_ROUTING_SOCKET) */
end_comment

begin_comment
comment|/*  * interface list enumerator - visitor pattern  */
end_comment

begin_function
name|void
name|interface_enumerate
parameter_list|(
name|interface_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|interface_info_t
name|ifi
decl_stmt|;
name|struct
name|interface
modifier|*
name|interf
decl_stmt|;
name|ifi
operator|.
name|action
operator|=
name|IFS_EXISTS
expr_stmt|;
for|for
control|(
name|interf
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|inter_list
argument_list|)
init|;
name|interf
operator|!=
name|NULL
condition|;
name|interf
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|interf
argument_list|,
name|link
argument_list|)
control|)
block|{
name|ifi
operator|.
name|interface
operator|=
name|interf
expr_stmt|;
name|receiver
argument_list|(
name|data
argument_list|,
operator|&
name|ifi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * do standard initialization of interface structure  */
end_comment

begin_function
specifier|static
name|void
name|init_interface
parameter_list|(
name|struct
name|interface
modifier|*
name|interface
parameter_list|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|interface
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|interface
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|interface
operator|->
name|peers
argument_list|)
expr_stmt|;
name|interface
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|interface
operator|->
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|interface
operator|->
name|num_mcast
operator|=
literal|0
expr_stmt|;
name|interface
operator|->
name|received
operator|=
literal|0
expr_stmt|;
name|interface
operator|->
name|sent
operator|=
literal|0
expr_stmt|;
name|interface
operator|->
name|notsent
operator|=
literal|0
expr_stmt|;
name|interface
operator|->
name|peercnt
operator|=
literal|0
expr_stmt|;
name|interface
operator|->
name|phase
operator|=
name|sys_interphase
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * create new interface structure initialize from  * template structure or via standard initialization  * function  */
end_comment

begin_function
specifier|static
name|struct
name|interface
modifier|*
name|new_interface
parameter_list|(
name|struct
name|interface
modifier|*
name|interface
parameter_list|)
block|{
specifier|static
name|u_int
name|sys_ifnum
init|=
literal|0
decl_stmt|;
name|struct
name|interface
modifier|*
name|iface
init|=
operator|(
expr|struct
name|interface
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|interface
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|interface
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iface
argument_list|,
operator|(
name|char
operator|*
operator|)
name|interface
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|interface
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init_interface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
block|}
name|iface
operator|->
name|ifnum
operator|=
name|sys_ifnum
operator|++
expr_stmt|;
comment|/* count every new instance of an interface in the system */
name|iface
operator|->
name|starttime
operator|=
name|current_time
expr_stmt|;
return|return
name|iface
return|;
block|}
end_function

begin_comment
comment|/*  * return interface storage into free memory pool  */
end_comment

begin_function
specifier|static
name|void
name|delete_interface
parameter_list|(
name|struct
name|interface
modifier|*
name|interface
parameter_list|)
block|{
name|free
argument_list|(
name|interface
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * link interface into list of known interfaces  */
end_comment

begin_function
specifier|static
name|void
name|add_interface
parameter_list|(
name|struct
name|interface
modifier|*
name|interface
parameter_list|)
block|{
specifier|static
name|struct
name|interface
modifier|*
name|listhead
init|=
name|NULL
decl_stmt|;
comment|/* 	 * For ntpd, the first few interfaces (wildcard, localhost) 	 * will never be removed.  This means inter_list.head is 	 * unchanging once initialized.  Take advantage of that to 	 * watch for changes and catch corruption earlier.  This 	 * helped track down corruption caused by using FD_SET with 	 * a descriptor numerically larger than FD_SETSIZE. 	 */
if|if
condition|(
name|NULL
operator|==
name|listhead
condition|)
name|listhead
operator|=
name|inter_list
operator|.
name|head
expr_stmt|;
if|if
condition|(
name|listhead
operator|!=
name|inter_list
operator|.
name|head
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"add_interface inter_list.head corrupted: was %p now %p"
argument_list|,
name|listhead
argument_list|,
name|inter_list
operator|.
name|head
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate the address hash 	 */
name|interface
operator|->
name|addr_refid
operator|=
name|addr2refid
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|inter_list
argument_list|,
name|interface
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ninterfaces
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove interface from known interface list and clean up  * associated resources  */
end_comment

begin_function
specifier|static
name|void
name|remove_interface
parameter_list|(
name|struct
name|interface
modifier|*
name|interface
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|resmask
decl_stmt|;
name|ISC_LIST_UNLINK_TYPE
argument_list|(
name|inter_list
argument_list|,
name|interface
argument_list|,
name|link
argument_list|,
expr|struct
name|interface
argument_list|)
expr_stmt|;
name|delete_interface_from_list
argument_list|(
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Deleting interface #%d %s, %s#%d, interface stats: received=%ld, sent=%ld, dropped=%ld, active_time=%ld secs"
argument_list|,
name|interface
operator|->
name|ifnum
argument_list|,
name|interface
operator|->
name|name
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|interface
operator|->
name|sin
operator|)
argument_list|)
argument_list|,
name|NTP_PORT
argument_list|,
comment|/* XXX should extract port from sin structure */
name|interface
operator|->
name|received
argument_list|,
name|interface
operator|->
name|sent
argument_list|,
name|interface
operator|->
name|notsent
argument_list|,
name|current_time
operator|-
name|interface
operator|->
name|starttime
argument_list|)
expr_stmt|;
name|close_and_delete_fd_from_list
argument_list|(
name|interface
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interface
operator|->
name|bfd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Deleting interface #%d %s, broadcast address %s#%d"
argument_list|,
name|interface
operator|->
name|ifnum
argument_list|,
name|interface
operator|->
name|name
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|interface
operator|->
name|bcast
operator|)
argument_list|)
argument_list|,
operator|(
name|u_short
operator|)
name|NTP_PORT
argument_list|)
expr_stmt|;
comment|/* XXX extract port from sin structure */
name|close_and_delete_fd_from_list
argument_list|(
name|interface
operator|->
name|bfd
argument_list|)
expr_stmt|;
block|}
name|ninterfaces
operator|--
expr_stmt|;
name|ntp_monclearinterface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
comment|/* remove restrict interface entry */
comment|/* 	 * Blacklist bound interface address 	 */
name|SET_HOSTMASK
argument_list|(
operator|&
name|resmask
argument_list|,
name|interface
operator|->
name|sin
operator|.
name|ss_family
argument_list|)
expr_stmt|;
name|hack_restrict
argument_list|(
name|RESTRICT_REMOVEIF
argument_list|,
operator|&
name|interface
operator|->
name|sin
argument_list|,
operator|&
name|resmask
argument_list|,
name|RESM_NTPONLY
operator||
name|RESM_INTERFACE
argument_list|,
name|RES_IGNORE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|list_if_listening
parameter_list|(
name|struct
name|interface
modifier|*
name|interface
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Listening on interface #%d %s, %s#%d %s"
argument_list|,
name|interface
operator|->
name|ifnum
argument_list|,
name|interface
operator|->
name|name
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|interface
operator|->
name|sin
operator|)
argument_list|)
argument_list|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
argument_list|,
operator|(
name|interface
operator|->
name|ignore_packets
operator|==
name|ISC_FALSE
operator|)
condition|?
literal|"Enabled"
else|:
literal|"Disabled"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_wildcards
parameter_list|(
name|u_short
name|port
parameter_list|)
block|{
name|isc_boolean_t
name|okipv4
init|=
name|ISC_TRUE
decl_stmt|;
comment|/* 	 * create pseudo-interface with wildcard IPv4 address 	 */
ifdef|#
directive|ifdef
name|IPV6_V6ONLY
if|if
condition|(
name|isc_net_probeipv4
argument_list|()
operator|!=
name|ISC_R_SUCCESS
condition|)
name|okipv4
operator|=
name|ISC_FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|okipv4
operator|==
name|ISC_TRUE
condition|)
block|{
name|struct
name|interface
modifier|*
name|interface
init|=
name|new_interface
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|interface
operator|->
name|family
operator|=
name|AF_INET
expr_stmt|;
name|interface
operator|->
name|sin
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|interface
operator|->
name|name
argument_list|,
literal|"wildcard"
argument_list|,
sizeof|sizeof
argument_list|(
name|interface
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|interface
operator|->
name|mask
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|interface
operator|->
name|mask
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|~
operator|(
name|u_int32
operator|)
literal|0
argument_list|)
expr_stmt|;
name|interface
operator|->
name|flags
operator|=
name|INT_BROADCAST
operator||
name|INT_UP
operator||
name|INT_WILDCARD
expr_stmt|;
name|interface
operator|->
name|ignore_packets
operator|=
name|ISC_TRUE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MCAST
argument_list|)
comment|/* 		 * enable possible multicast reception on the broadcast socket 		 */
name|interface
operator|->
name|bcast
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|interface
operator|->
name|bcast
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|interface
operator|->
name|bcast
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MCAST */
name|interface
operator|->
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|,
name|interface
operator|->
name|flags
argument_list|,
literal|1
argument_list|,
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|wildipv4
operator|=
name|interface
expr_stmt|;
name|any_interface
operator|=
name|interface
expr_stmt|;
name|add_addr_to_list
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|add_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|list_if_listening
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to bind to wildcard socket address %s - another process may be running - EXITING"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|interface
operator|->
name|sin
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
comment|/* 	 * create pseudo-interface with wildcard IPv6 address 	 */
if|if
condition|(
name|isc_net_probeipv6
argument_list|()
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|struct
name|interface
modifier|*
name|interface
init|=
name|new_interface
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|interface
operator|->
name|family
operator|=
name|AF_INET6
expr_stmt|;
name|interface
operator|->
name|sin
operator|.
name|ss_family
operator|=
name|AF_INET6
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin6_addr
operator|=
name|in6addr_any
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESCOPEID
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|interface
operator|->
name|name
argument_list|,
literal|"wildcard"
argument_list|,
sizeof|sizeof
argument_list|(
name|interface
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|interface
operator|->
name|mask
operator|.
name|ss_family
operator|=
name|AF_INET6
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|interface
operator|->
name|mask
operator|)
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|interface
operator|->
name|flags
operator|=
name|INT_UP
operator||
name|INT_WILDCARD
expr_stmt|;
name|interface
operator|->
name|ignore_packets
operator|=
name|ISC_TRUE
expr_stmt|;
name|interface
operator|->
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|,
name|interface
operator|->
name|flags
argument_list|,
literal|1
argument_list|,
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|wildipv6
operator|=
name|interface
expr_stmt|;
name|any6_interface
operator|=
name|interface
expr_stmt|;
name|add_addr_to_list
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|add_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|list_if_listening
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to bind to wildcard socket address %s - another process may be running - EXITING"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|interface
operator|->
name|sin
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|address_okay
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"address_okay: listen Virtual: %d, IF name: %s\n"
operator|,
name|listen_to_virtual_ips
operator|,
name|iface
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Always allow the loopback 	 */
if|if
condition|(
operator|(
name|iface
operator|->
name|flags
operator|&
name|INT_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"address_okay: loopback - OK\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
comment|/* 	 * Check if the interface is specified 	 */
if|if
condition|(
name|specific_interface
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|iface
operator|->
name|name
argument_list|,
name|specific_interface
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"address_okay: specific interface name matched - OK\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"address_okay: specific interface name NOT matched - FAIL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|listen_to_virtual_ips
operator|==
literal|0
operator|&&
operator|(
name|strchr
argument_list|(
name|iface
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
literal|':'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"address_okay: virtual ip/alias - FAIL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"address_okay: OK\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_isc_if
parameter_list|(
name|isc_interface_t
modifier|*
name|isc_if
parameter_list|,
name|struct
name|interface
modifier|*
name|itf
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|itf
operator|->
name|scopeid
operator|=
literal|0
expr_stmt|;
name|itf
operator|->
name|family
operator|=
operator|(
name|short
operator|)
name|isc_if
operator|->
name|af
expr_stmt|;
name|strcpy
argument_list|(
name|itf
operator|->
name|name
argument_list|,
name|isc_if
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_if
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|itf
operator|->
name|sin
operator|.
name|ss_family
operator|=
operator|(
name|u_short
operator|)
name|isc_if
operator|->
name|af
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|sin
operator|)
operator|->
name|sin_addr
operator|)
argument_list|,
operator|&
operator|(
name|isc_if
operator|->
name|address
operator|.
name|type
operator|.
name|in
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|sin
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
if|if
condition|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_BROADCAST
operator|)
operator|!=
literal|0
condition|)
block|{
name|itf
operator|->
name|flags
operator||=
name|INT_BROADCAST
expr_stmt|;
name|itf
operator|->
name|bcast
operator|.
name|ss_family
operator|=
name|itf
operator|->
name|sin
operator|.
name|ss_family
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|bcast
operator|)
operator|->
name|sin_addr
operator|)
argument_list|,
operator|&
operator|(
name|isc_if
operator|->
name|broadcast
operator|.
name|type
operator|.
name|in
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|bcast
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
block|}
name|itf
operator|->
name|mask
operator|.
name|ss_family
operator|=
name|itf
operator|->
name|sin
operator|.
name|ss_family
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|mask
operator|)
operator|->
name|sin_addr
operator|)
argument_list|,
operator|&
operator|(
name|isc_if
operator|->
name|netmask
operator|.
name|type
operator|.
name|in
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|mask
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
elseif|else
if|if
condition|(
name|isc_if
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|itf
operator|->
name|sin
operator|.
name|ss_family
operator|=
operator|(
name|u_short
operator|)
name|isc_if
operator|->
name|af
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|itf
operator|->
name|sin
operator|)
operator|->
name|sin6_addr
operator|)
argument_list|,
operator|&
operator|(
name|isc_if
operator|->
name|address
operator|.
name|type
operator|.
name|in6
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|itf
operator|->
name|sin
operator|)
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|itf
operator|->
name|sin
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESCOPEID
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|itf
operator|->
name|sin
operator|)
operator|->
name|sin6_scope_id
operator|=
name|isc_netaddr_getzone
argument_list|(
operator|&
name|isc_if
operator|->
name|address
argument_list|)
expr_stmt|;
name|itf
operator|->
name|scopeid
operator|=
name|isc_netaddr_getzone
argument_list|(
operator|&
name|isc_if
operator|->
name|address
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|itf
operator|->
name|mask
operator|.
name|ss_family
operator|=
name|itf
operator|->
name|sin
operator|.
name|ss_family
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|itf
operator|->
name|mask
operator|)
operator|->
name|sin6_addr
operator|)
argument_list|,
operator|&
operator|(
name|isc_if
operator|->
name|netmask
operator|.
name|type
operator|.
name|in6
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|itf
operator|->
name|mask
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
comment|/* Copy the interface index */
name|itf
operator|->
name|ifindex
operator|=
name|isc_if
operator|->
name|ifindex
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT */
comment|/* Process the rest of the flags */
if|if
condition|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_UP
operator|)
operator|!=
literal|0
condition|)
name|itf
operator|->
name|flags
operator||=
name|INT_UP
expr_stmt|;
if|if
condition|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
name|itf
operator|->
name|flags
operator||=
name|INT_LOOPBACK
expr_stmt|;
if|if
condition|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_POINTTOPOINT
operator|)
operator|!=
literal|0
condition|)
name|itf
operator|->
name|flags
operator||=
name|INT_PPP
expr_stmt|;
if|if
condition|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_MULTICAST
operator|)
operator|!=
literal|0
condition|)
name|itf
operator|->
name|flags
operator||=
name|INT_MULTICAST
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refresh_interface  *  * some OSes have been observed to keep  * cached routes even when more specific routes  * become available.  * this can be mitigated by re-binding  * the socket.  */
end_comment

begin_function
specifier|static
name|int
name|refresh_interface
parameter_list|(
name|struct
name|interface
modifier|*
name|interface
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OS_MISSES_SPECIFIC_ROUTE_UPDATES
if|if
condition|(
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|close_and_delete_fd_from_list
argument_list|(
name|interface
operator|->
name|fd
argument_list|)
expr_stmt|;
name|interface
operator|->
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|,
name|interface
operator|->
name|flags
argument_list|,
literal|0
argument_list|,
name|interface
argument_list|)
expr_stmt|;
comment|/* 		  * reset TTL indication so TTL is is set again  		  * next time around 		  */
name|interface
operator|->
name|last_ttl
operator|=
literal|0
expr_stmt|;
return|return
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
comment|/* invalid sockets are not refreshable */
block|}
else|#
directive|else
comment|/* !OS_MISSES_SPECIFIC_ROUTE_UPDATES */
return|return
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
return|;
endif|#
directive|endif
comment|/* !OS_MISSES_SPECIFIC_ROUTE_UPDATES */
block|}
end_function

begin_comment
comment|/*  * interface_update - externally callable update function  */
end_comment

begin_function
name|void
name|interface_update
parameter_list|(
name|interface_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|disable_dynamic_updates
condition|)
block|{
name|int
name|new_interface_found
decl_stmt|;
name|BLOCKIO
argument_list|()
expr_stmt|;
name|new_interface_found
operator|=
name|update_interfaces
argument_list|(
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
argument_list|,
name|receiver
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_interface_found
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"new interface(s) found: waking up resolver"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* wake up the resolver thread */
if|if
condition|(
name|ResolverEventHandle
operator|!=
name|NULL
condition|)
name|SetEvent
argument_list|(
name|ResolverEventHandle
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* write any single byte to the pipe to wake up the resolver process */
name|write
argument_list|(
name|resolver_pipe_fd
index|[
literal|1
index|]
argument_list|,
operator|&
name|new_interface_found
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * find out if a given interface structure contains  * a wildcard address  */
end_comment

begin_function
specifier|static
name|int
name|is_wildcard_addr
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|sas
parameter_list|)
block|{
if|if
condition|(
name|sas
operator|->
name|ss_family
operator|==
name|AF_INET
operator|&&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
if|if
condition|(
name|sas
operator|->
name|ss_family
operator|==
name|AF_INET6
operator|&&
name|memcmp
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin6_addr
argument_list|,
operator|&
name|in6addr_any
argument_list|,
sizeof|sizeof
argument_list|(
name|in6addr_any
argument_list|)
operator|==
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OS_NEEDS_REUSEADDR_FOR_IFADDRBIND
end_ifdef

begin_comment
comment|/*  * enable/disable re-use of wildcard address socket  */
end_comment

begin_function
specifier|static
name|void
name|set_wildcard_reuse
parameter_list|(
name|int
name|family
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|int
name|onvalue
init|=
literal|1
decl_stmt|;
name|int
name|offvalue
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|onoff
decl_stmt|;
name|SOCKET
name|fd
init|=
name|INVALID_SOCKET
decl_stmt|;
name|onoff
operator|=
name|on
condition|?
operator|&
name|onvalue
else|:
operator|&
name|offvalue
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|any_interface
condition|)
block|{
name|fd
operator|=
name|any_interface
operator|->
name|fd
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
case|case
name|AF_INET6
case|:
if|if
condition|(
name|any6_interface
condition|)
block|{
name|fd
operator|=
name|any6_interface
operator|->
name|fd
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* !INCLUDE_IPV6_SUPPORT */
block|}
if|if
condition|(
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
name|onoff
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|onoff
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"set_wildcard_reuse: setsockopt(SO_REUSEADDR, %s) failed: %m"
argument_list|,
operator|*
name|onoff
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"set SO_REUSEADDR to %s on %s\n"
operator|,
operator|*
name|onoff
condition|?
literal|"ON"
else|:
literal|"OFF"
operator|,
name|stoa
argument_list|(
operator|(
name|family
operator|==
name|AF_INET
operator|)
condition|?
operator|&
name|any_interface
operator|->
name|sin
else|:
operator|&
name|any6_interface
operator|->
name|sin
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS_NEEDS_REUSEADDR_FOR_IFADDRBIND */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
end_ifdef

begin_function
specifier|static
name|isc_boolean_t
name|is_anycast
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SIOCGIFAFLAG_IN6
argument_list|)
operator|&&
name|defined
argument_list|(
name|IN6_IFF_ANYCAST
argument_list|)
name|struct
name|in6_ifreq
name|ifr6
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|u_int32_t
name|flags6
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
return|return
name|ISC_FALSE
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ISC_FALSE
return|;
name|memset
argument_list|(
operator|&
name|ifr6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr6
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ifr6
operator|.
name|ifr_addr
argument_list|,
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr6
operator|.
name|ifr_name
argument_list|,
name|name
argument_list|,
name|IF_NAMESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFAFLAG_IN6
argument_list|,
operator|&
name|ifr6
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|ISC_FALSE
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|flags6
operator|=
name|ifr6
operator|.
name|ifr_ifru
operator|.
name|ifru_flags6
expr_stmt|;
if|if
condition|(
operator|(
name|flags6
operator|&
name|IN6_IFF_ANYCAST
operator|)
operator|!=
literal|0
condition|)
return|return
name|ISC_TRUE
return|;
endif|#
directive|endif
comment|/* !SIOCGIFAFLAG_IN6 || !IN6_IFF_ANYCAST */
return|return
name|ISC_FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !INCLUDE_IPV6_SUPPORT */
end_comment

begin_comment
comment|/*  * update_interface strategy  *  * toggle configuration phase  *  * Phase 1:  * forall currently existing interfaces  *   if address is known:  *       drop socket - rebind again  *  *   if address is NOT known:  *     attempt to create a new interface entry  *  * Phase 2:  * forall currently known non MCAST and WILDCARD interfaces  *   if interface does not match configuration phase (not seen in phase 1):  *     remove interface from known interface list  *     forall peers associated with this interface  *       disconnect peer from this interface  *  * Phase 3:  *   attempt to re-assign interfaces to peers  *  */
end_comment

begin_function
specifier|static
name|int
name|update_interfaces
parameter_list|(
name|u_short
name|port
parameter_list|,
name|interface_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|interface_info_t
name|ifi
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|NULL
decl_stmt|;
name|isc_interfaceiter_t
modifier|*
name|iter
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|scan_ipv4
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|scan_ipv6
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|int
name|new_interface_found
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"update_interfaces(%d)\n"
operator|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
if|if
condition|(
name|isc_net_probeipv6
argument_list|()
operator|==
name|ISC_R_SUCCESS
condition|)
name|scan_ipv6
operator|=
name|ISC_TRUE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
elseif|else
if|if
condition|(
name|debug
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no IPv6 interfaces found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|isc_net_probeipv6
argument_list|()
operator|==
name|ISC_R_SUCCESS
condition|)
name|scan_ipv6
operator|=
name|ISC_TRUE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIPV6
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEBUG
argument_list|)
elseif|else
if|if
condition|(
name|debug
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no IPv6 interfaces found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isc_net_probeipv4
argument_list|()
operator|==
name|ISC_R_SUCCESS
condition|)
name|scan_ipv4
operator|=
name|ISC_TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|debug
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no IPv4 interfaces found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * phase one - scan interfaces 	 * - create those that are not found 	 * - update those that are found 	 */
name|result
operator|=
name|isc_interfaceiter_create
argument_list|(
name|mctx
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
literal|0
return|;
name|sys_interphase
operator|^=
literal|0x1
expr_stmt|;
comment|/* toggle system phase for finding untouched (to be deleted) interfaces */
for|for
control|(
name|result
operator|=
name|isc_interfaceiter_first
argument_list|(
name|iter
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|isc_interfaceiter_next
argument_list|(
name|iter
argument_list|)
control|)
block|{
name|isc_interface_t
name|isc_if
decl_stmt|;
name|unsigned
name|int
name|family
decl_stmt|;
name|struct
name|interface
name|interface
decl_stmt|;
name|struct
name|interface
modifier|*
name|iface
decl_stmt|;
name|result
operator|=
name|isc_interfaceiter_current
argument_list|(
name|iter
argument_list|,
operator|&
name|isc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
comment|/* See if we have a valid family to use */
name|family
operator|=
name|isc_if
operator|.
name|address
operator|.
name|family
expr_stmt|;
if|if
condition|(
name|family
operator|!=
name|AF_INET
operator|&&
name|family
operator|!=
name|AF_INET6
condition|)
continue|continue;
if|if
condition|(
name|scan_ipv4
operator|==
name|ISC_FALSE
operator|&&
name|family
operator|==
name|AF_INET
condition|)
continue|continue;
if|if
condition|(
name|scan_ipv6
operator|==
name|ISC_FALSE
operator|&&
name|family
operator|==
name|AF_INET6
condition|)
continue|continue;
comment|/* 		 * create prototype 		 */
name|init_interface
argument_list|(
operator|&
name|interface
argument_list|)
expr_stmt|;
name|convert_isc_if
argument_list|(
operator|&
name|isc_if
argument_list|,
operator|&
name|interface
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*  		 * Check to see if we are going to use the interface 		 * If we don't use it we mark it to drop any packet 		 * received but we still must create the socket and 		 * bind to it. This prevents other apps binding to it 		 * and potentially causing problems with more than one 		 * process fiddling with the clock 		 */
if|if
condition|(
name|address_okay
argument_list|(
operator|&
name|interface
argument_list|)
operator|==
name|ISC_TRUE
condition|)
block|{
name|interface
operator|.
name|ignore_packets
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|interface
operator|.
name|ignore_packets
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|DPRINT_INTERFACE
argument_list|(
literal|4
argument_list|,
operator|(
operator|&
name|interface
operator|,
literal|"examining "
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|interface
operator|.
name|flags
operator|&
name|INT_UP
operator|)
condition|)
block|{
comment|/* interfaces must be UP to be usable */
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"skipping interface %s (%s) - DOWN\n"
operator|,
name|interface
operator|.
name|name
operator|,
name|stoa
argument_list|(
operator|&
name|interface
operator|.
name|sin
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * skip any interfaces UP and bound to a wildcard 		 * address - some dhcp clients produce that in the 		 * wild 		 */
if|if
condition|(
name|is_wildcard_addr
argument_list|(
operator|&
name|interface
operator|.
name|sin
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
if|if
condition|(
name|is_anycast
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|interface
operator|.
name|sin
argument_list|,
name|isc_if
operator|.
name|name
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* !INCLUDE_IPV6_SUPPORT */
comment|/* 		 * map to local *address* in order 		 * to map all duplicate interfaces to an interface structure 		 * with the appropriate socket (our name space is 		 * (ip-address) - NOT (interface name, ip-address)) 		 */
name|iface
operator|=
name|getinterface
argument_list|(
operator|&
name|interface
operator|.
name|sin
argument_list|,
name|INT_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|&&
name|refresh_interface
argument_list|(
name|iface
argument_list|)
condition|)
block|{
comment|/* 			 * found existing and up to date interface - mark present 			 */
name|iface
operator|->
name|phase
operator|=
name|sys_interphase
expr_stmt|;
name|DPRINT_INTERFACE
argument_list|(
literal|4
argument_list|,
operator|(
name|iface
operator|,
literal|"updating "
operator|,
literal|" present\n"
operator|)
argument_list|)
expr_stmt|;
name|ifi
operator|.
name|action
operator|=
name|IFS_EXISTS
expr_stmt|;
name|ifi
operator|.
name|interface
operator|=
name|iface
expr_stmt|;
if|if
condition|(
name|receiver
condition|)
name|receiver
argument_list|(
name|data
argument_list|,
operator|&
name|ifi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * this is new or refreshing failed - add to our interface list 			 * if refreshing failed we will delete the interface structure in 			 * phase 2 as the interface was not marked current. We can bind to 			 * the address as the refresh code already closed the offending socket 			 */
name|iface
operator|=
name|create_interface
argument_list|(
name|port
argument_list|,
operator|&
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
condition|)
block|{
name|ifi
operator|.
name|action
operator|=
name|IFS_CREATED
expr_stmt|;
name|ifi
operator|.
name|interface
operator|=
name|iface
expr_stmt|;
if|if
condition|(
name|receiver
condition|)
name|receiver
argument_list|(
name|data
argument_list|,
operator|&
name|ifi
argument_list|)
expr_stmt|;
name|new_interface_found
operator|=
literal|1
expr_stmt|;
name|DPRINT_INTERFACE
argument_list|(
literal|3
argument_list|,
operator|(
name|iface
operator|,
literal|"updating "
operator|,
literal|" new - created\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINT_INTERFACE
argument_list|(
literal|3
argument_list|,
operator|(
operator|&
name|interface
operator|,
literal|"updating "
operator|,
literal|" new - creation FAILED"
operator|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"failed to initialize interface for address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|interface
operator|.
name|sin
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|isc_interfaceiter_destroy
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
comment|/* 	 * phase 2 - delete gone interfaces - reassigning peers to other interfaces 	 */
block|{
name|struct
name|interface
modifier|*
name|interf
init|=
name|ISC_LIST_HEAD
argument_list|(
name|inter_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|interf
operator|!=
name|NULL
condition|)
block|{
name|struct
name|interface
modifier|*
name|next
init|=
name|ISC_LIST_NEXT
argument_list|(
name|interf
argument_list|,
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|interf
operator|->
name|flags
operator|&
operator|(
name|INT_WILDCARD
operator||
name|INT_MCASTIF
operator|)
operator|)
condition|)
block|{
comment|/* 				 * if phase does not match sys_phase this interface was not 				 * enumerated during interface scan - so it is gone and 				 * will be deleted here unless it is solely an MCAST/WILDCARD interface 				 */
if|if
condition|(
name|interf
operator|->
name|phase
operator|!=
name|sys_interphase
condition|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|DPRINT_INTERFACE
argument_list|(
literal|3
argument_list|,
operator|(
name|interf
operator|,
literal|"updating "
operator|,
literal|"GONE - deleting\n"
operator|)
argument_list|)
expr_stmt|;
name|remove_interface
argument_list|(
name|interf
argument_list|)
expr_stmt|;
name|ifi
operator|.
name|action
operator|=
name|IFS_DELETED
expr_stmt|;
name|ifi
operator|.
name|interface
operator|=
name|interf
expr_stmt|;
if|if
condition|(
name|receiver
condition|)
name|receiver
argument_list|(
name|data
argument_list|,
operator|&
name|ifi
argument_list|)
expr_stmt|;
name|peer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|interf
operator|->
name|peers
argument_list|)
expr_stmt|;
comment|/* 					 * disconnect peer from deleted interface 					 */
while|while
condition|(
name|peer
operator|!=
name|NULL
condition|)
block|{
name|struct
name|peer
modifier|*
name|npeer
init|=
name|ISC_LIST_NEXT
argument_list|(
name|peer
argument_list|,
name|ilink
argument_list|)
decl_stmt|;
comment|/* 						 * this one just lost it's interface 						 */
name|set_peerdstadr
argument_list|(
name|peer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|peer
operator|=
name|npeer
expr_stmt|;
block|}
comment|/* 					 * update globals in case we lose  					 * a loopback interface 					 */
if|if
condition|(
name|interf
operator|==
name|loopback_interface
condition|)
name|loopback_interface
operator|=
name|NULL
expr_stmt|;
name|delete_interface
argument_list|(
name|interf
argument_list|)
expr_stmt|;
block|}
block|}
name|interf
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* 	 * phase 3 - re-configure as the world has changed if necessary 	 */
name|refresh_all_peerinterfaces
argument_list|()
expr_stmt|;
return|return
name|new_interface_found
return|;
block|}
end_function

begin_comment
comment|/*  * create_sockets - create a socket for each interface plus a default  *			socket for when we don't know where to send  */
end_comment

begin_function
specifier|static
name|int
name|create_sockets
parameter_list|(
name|u_short
name|port
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
comment|/* 	 * I/O Completion Ports don't care about the select and FD_SET 	 */
name|maxactivefd
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|activefds
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"create_sockets(%d)\n"
operator|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|create_wildcards
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|update_interfaces
argument_list|(
name|port
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we have opened all the sockets, turn off the reuse 	 * flag for security. 	 */
name|set_reuseaddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"create_sockets: Total interfaces = %d\n"
operator|,
name|ninterfaces
operator|)
argument_list|)
expr_stmt|;
return|return
name|ninterfaces
return|;
block|}
end_function

begin_comment
comment|/*  * create_interface - create a new interface for a given prototype  *		      binding the socket.  */
end_comment

begin_function
specifier|static
name|struct
name|interface
modifier|*
name|create_interface
parameter_list|(
name|u_short
name|port
parameter_list|,
name|struct
name|interface
modifier|*
name|iface
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|resmask
decl_stmt|;
name|struct
name|interface
modifier|*
name|interface
decl_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"create_interface(%s#%d)\n"
operator|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
operator|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* build an interface */
name|interface
operator|=
name|new_interface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
comment|/* 	 * create socket 	 */
name|interface
operator|->
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|,
name|interface
operator|->
name|flags
argument_list|,
literal|0
argument_list|,
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
name|list_if_listening
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|interface
operator|->
name|flags
operator|&
name|INT_BROADCAST
operator|)
operator|&&
name|interface
operator|->
name|bfd
operator|!=
name|INVALID_SOCKET
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Listening on broadcast address %s#%d"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|interface
operator|->
name|bcast
operator|)
argument_list|)
argument_list|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface
operator|->
name|fd
operator|==
name|INVALID_SOCKET
operator|&&
name|interface
operator|->
name|bfd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to create socket on %s (%d) for %s#%d"
argument_list|,
name|interface
operator|->
name|name
argument_list|,
name|interface
operator|->
name|ifnum
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|interface
operator|->
name|sin
operator|)
argument_list|)
argument_list|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|delete_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Blacklist bound interface address 	 */
name|SET_HOSTMASK
argument_list|(
operator|&
name|resmask
argument_list|,
name|interface
operator|->
name|sin
operator|.
name|ss_family
argument_list|)
expr_stmt|;
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|interface
operator|->
name|sin
argument_list|,
operator|&
name|resmask
argument_list|,
name|RESM_NTPONLY
operator||
name|RESM_INTERFACE
argument_list|,
name|RES_IGNORE
argument_list|)
expr_stmt|;
comment|/* 	 * set globals with the first found 	 * loopback interface of the appropriate class 	 */
if|if
condition|(
operator|(
name|loopback_interface
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|interface
operator|->
name|family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
operator|(
name|interface
operator|->
name|flags
operator|&
name|INT_LOOPBACK
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|loopback_interface
operator|=
name|interface
expr_stmt|;
block|}
comment|/* 	 * put into our interface list 	 */
name|add_addr_to_list
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|add_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|DPRINT_INTERFACE
argument_list|(
literal|2
argument_list|,
operator|(
name|interface
operator|,
literal|"created "
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|interface
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SO_EXCLUSIVEADDRUSE
end_ifdef

begin_function
specifier|static
name|void
name|set_excladdruse
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|one
init|=
literal|1
decl_stmt|;
name|int
name|failed
decl_stmt|;
name|failed
operator|=
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_EXCLUSIVEADDRUSE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|one
argument_list|,
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(%d, SO_EXCLUSIVEADDRUSE, on): %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SO_EXCLUSIVEADDRUSE */
end_comment

begin_comment
comment|/*  * set_reuseaddr() - set/clear REUSEADDR on all sockets  *			NB possible hole - should we be doing this on broadcast  *			fd's also?  */
end_comment

begin_function
specifier|static
name|void
name|set_reuseaddr
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|interf
decl_stmt|;
ifndef|#
directive|ifndef
name|SO_EXCLUSIVEADDRUSE
for|for
control|(
name|interf
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|inter_list
argument_list|)
init|;
name|interf
operator|!=
name|NULL
condition|;
name|interf
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|interf
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|interf
operator|->
name|flags
operator|&
name|INT_WILDCARD
condition|)
continue|continue;
comment|/* 		 * if interf->fd  is INVALID_SOCKET, we might have a adapter 		 * configured but not present 		 */
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"setting SO_REUSEADDR on %.16s@%s to %s\n"
operator|,
name|interf
operator|->
name|name
operator|,
name|stoa
argument_list|(
operator|&
name|interf
operator|->
name|sin
argument_list|)
operator|,
name|flag
condition|?
literal|"on"
else|:
literal|"off"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interf
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|interf
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flag
argument_list|,
sizeof|sizeof
argument_list|(
name|flag
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"set_reuseaddr: setsockopt(SO_REUSEADDR, %s) failed: %m"
argument_list|,
name|flag
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* ! SO_EXCLUSIVEADDRUSE */
block|}
end_function

begin_comment
comment|/*  * This is just a wrapper around an internal function so we can  * make other changes as necessary later on  */
end_comment

begin_function
name|void
name|enable_broadcast
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|baddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SO_BROADCAST
name|socket_broadcast_enable
argument_list|(
name|iface
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|baddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OPEN_BCAST_SOCKET
end_ifdef

begin_comment
comment|/*  * Enable a broadcast address to a given socket  * The socket is in the inter_list all we need to do is enable  * broadcasting. It is not this function's job to select the socket  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|socket_broadcast_enable
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|SOCKET
name|fd
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|maddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SO_BROADCAST
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|maddr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* if this interface can support broadcast, set SO_BROADCAST */
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(SO_BROADCAST) enable failure on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Broadcast enabled on socket %d for address %s\n"
argument_list|,
name|fd
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|iface
operator|->
name|flags
operator||=
name|INT_BCASTOPEN
expr_stmt|;
return|return
name|ISC_TRUE
return|;
else|#
directive|else
return|return
name|ISC_FALSE
return|;
endif|#
directive|endif
comment|/* SO_BROADCAST */
block|}
end_function

begin_comment
comment|/*  * Remove a broadcast address from a given socket  * The socket is in the inter_list all we need to do is disable  * broadcasting. It is not this function's job to select the socket  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|socket_broadcast_disable
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|maddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SO_BROADCAST
name|int
name|off
init|=
literal|0
decl_stmt|;
comment|/* This seems to be OK as an int */
if|if
condition|(
name|maddr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(SO_BROADCAST) disable failure on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|iface
operator|->
name|flags
operator|&=
operator|~
name|INT_BCASTOPEN
expr_stmt|;
return|return
name|ISC_TRUE
return|;
else|#
directive|else
return|return
name|ISC_FALSE
return|;
endif|#
directive|endif
comment|/* SO_BROADCAST */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPEN_BCAST_SOCKET */
end_comment

begin_comment
comment|/*  * Check to see if the address is a multicast address  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|addr_ismulticast
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|maddr
parameter_list|)
block|{
switch|switch
condition|(
name|maddr
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
operator|!
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|maddr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"multicast address %s not class D\n"
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
case|case
name|AF_INET6
case|:
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|maddr
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"address %s not IPv6 multicast address\n"
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
comment|/*  * If we don't have IPV6 support any IPV6 address is not multicast  */
else|#
directive|else
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Never valid 	 */
default|default:
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Multicast servers need to set the appropriate Multicast interface  * socket option in order for it to know which interface to use for  * send the multicast packet.  */
end_comment

begin_function
name|void
name|enable_multicast_if
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|maddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCAST
comment|/*u_char*/
name|TYPEOF_IP_MULTICAST_LOOP
name|off
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|maddr
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_IF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|iface
operator|->
name|sin
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_IF failure: %m on socket %d, addr %s for multicast address %s"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|IP_MULTICAST_LOOP
comment|/* 		 * Don't send back to itself, but allow it to fail to set it 		 */
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_LOOP
argument_list|,
name|SETSOCKOPT_ARG_CAST
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_LOOP failure: %m on socket %d, addr %s for multicast address %s"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Added IPv4 multicast interface on socket %d, addr %s for multicast address %s\n"
operator|,
name|iface
operator|->
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MULTICAST_IF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|iface
operator|->
name|scopeid
argument_list|,
sizeof|sizeof
argument_list|(
name|iface
operator|->
name|scopeid
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_MULTICAST_IF failure: %m on socket %d, addr %s, scope %d for multicast address %s"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|iface
operator|->
name|scopeid
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|IPV6_MULTICAST_LOOP
comment|/* 		 * Don't send back to itself, but allow it to fail to set it 		 */
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MULTICAST_LOOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_LOOP failure: %m on socket %d, addr %s for multicast address %s"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Added IPv6 multicast interface on socket %d, addr %s, scope %d for multicast address %s\n"
operator|,
name|iface
operator|->
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
operator|,
name|iface
operator|->
name|scopeid
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
return|return;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_MULTICAST_SUPPORT */
block|}
return|return;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Add a multicast address to a given socket  * The socket is in the inter_list all we need to do is enable  * multicasting. It is not this function's job to select the socket  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|socket_multicast_enable
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|int
name|lscope
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|maddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
name|struct
name|ipv6_mreq
name|mreq6
decl_stmt|;
name|struct
name|in6_addr
name|iaddr6
decl_stmt|;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_MULTICAST_SUPPORT */
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
if|if
condition|(
name|find_addr_in_list
argument_list|(
name|maddr
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"socket_multicast_enable(%s): already enabled\n"
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_TRUE
return|;
block|}
switch|switch
condition|(
name|maddr
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
expr_stmt|;
name|mreq
operator|.
name|imr_multiaddr
operator|=
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|maddr
operator|)
operator|->
name|sin_addr
operator|)
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_ADD_MEMBERSHIP failure: %m on socket %d, addr %s for %x / %x (%s)"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
argument_list|,
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ISC_FALSE
return|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Added IPv4 multicast membership on socket %d, addr %s for %x / %x (%s)\n"
operator|,
name|iface
operator|->
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
operator|,
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|,
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
comment|/* 		 * Enable reception of multicast packets 		 * If the address is link-local we can get the interface index 		 * from the scope id. Don't do this for other types of multicast 		 * addresses. For now let the kernel figure it out. 		 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq6
argument_list|)
argument_list|)
expr_stmt|;
name|iaddr6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|maddr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|mreq6
operator|.
name|ipv6mr_multiaddr
operator|=
name|iaddr6
expr_stmt|;
name|mreq6
operator|.
name|ipv6mr_interface
operator|=
name|lscope
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_JOIN_GROUP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq6
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq6
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_JOIN_GROUP failure: %m on socket %d, addr %s for interface %d(%s)"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|mreq6
operator|.
name|ipv6mr_interface
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ISC_FALSE
return|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Added IPv6 multicast group on socket %d, addr %s for interface %d(%s)\n"
operator|,
name|iface
operator|->
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
operator|,
name|mreq6
operator|.
name|ipv6mr_interface
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
return|return
name|ISC_FALSE
return|;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_MULTICAST_SUPPORT */
block|}
name|iface
operator|->
name|flags
operator||=
name|INT_MCASTOPEN
expr_stmt|;
name|iface
operator|->
name|num_mcast
operator|++
expr_stmt|;
name|add_addr_to_list
argument_list|(
name|maddr
argument_list|,
name|iface
argument_list|)
expr_stmt|;
return|return
name|ISC_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a multicast address from a given socket  * The socket is in the inter_list all we need to do is disable  * multicasting. It is not this function's job to select the socket  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|socket_multicast_disable
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|maddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
name|struct
name|ipv6_mreq
name|mreq6
decl_stmt|;
name|struct
name|in6_addr
name|iaddr6
decl_stmt|;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_MULTICAST_SUPPORT */
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_addr_in_list
argument_list|(
name|maddr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"socket_multicast_disable(%s): not enabled\n"
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_TRUE
return|;
block|}
switch|switch
condition|(
name|maddr
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|mreq
operator|.
name|imr_multiaddr
operator|=
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|maddr
operator|)
operator|->
name|sin_addr
operator|)
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|iface
operator|->
name|sin
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DROP_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_DROP_MEMBERSHIP failure: %m on socket %d, addr %s for %x / %x (%s)"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
argument_list|,
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ISC_FALSE
return|;
block|}
break|break;
case|case
name|AF_INET6
case|:
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
comment|/* 		 * Disable reception of multicast packets 		 * If the address is link-local we can get the interface index 		 * from the scope id. Don't do this for other types of multicast 		 * addresses. For now let the kernel figure it out. 		 */
name|iaddr6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|maddr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|mreq6
operator|.
name|ipv6mr_multiaddr
operator|=
name|iaddr6
expr_stmt|;
name|mreq6
operator|.
name|ipv6mr_interface
operator|=
name|iface
operator|->
name|scopeid
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_LEAVE_GROUP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq6
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq6
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_LEAVE_GROUP failure: %m on socket %d, addr %s for %d(%s)"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|mreq6
operator|.
name|ipv6mr_interface
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ISC_FALSE
return|;
block|}
break|break;
else|#
directive|else
return|return
name|ISC_FALSE
return|;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_MULTICAST_SUPPORT */
block|}
name|iface
operator|->
name|num_mcast
operator|--
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|num_mcast
operator|<=
literal|0
condition|)
block|{
name|iface
operator|->
name|num_mcast
operator|=
literal|0
expr_stmt|;
name|iface
operator|->
name|flags
operator|&=
operator|~
name|INT_MCASTOPEN
expr_stmt|;
block|}
return|return
name|ISC_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * io_setbclient - open the broadcast client sockets  */
end_comment

begin_function
name|void
name|io_setbclient
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OPEN_BCAST_SOCKET
name|struct
name|interface
modifier|*
name|interf
decl_stmt|;
name|int
name|nif
init|=
literal|0
decl_stmt|;
name|isc_boolean_t
name|jstatus
decl_stmt|;
name|SOCKET
name|fd
decl_stmt|;
name|set_reuseaddr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|interf
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|inter_list
argument_list|)
init|;
name|interf
operator|!=
name|NULL
condition|;
name|interf
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|interf
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|interf
operator|->
name|flags
operator|&
name|INT_WILDCARD
condition|)
continue|continue;
comment|/* use only allowed addresses */
if|if
condition|(
name|interf
operator|->
name|ignore_packets
operator|==
name|ISC_TRUE
condition|)
continue|continue;
comment|/* Only IPv4 addresses are valid for broadcast */
if|if
condition|(
name|interf
operator|->
name|sin
operator|.
name|ss_family
operator|!=
name|AF_INET
condition|)
continue|continue;
comment|/* Is this a broadcast address? */
if|if
condition|(
operator|!
operator|(
name|interf
operator|->
name|flags
operator|&
name|INT_BROADCAST
operator|)
condition|)
continue|continue;
comment|/* Skip the loopback addresses */
if|if
condition|(
name|interf
operator|->
name|flags
operator|&
name|INT_LOOPBACK
condition|)
continue|continue;
comment|/* Do we already have the broadcast address open? */
if|if
condition|(
name|interf
operator|->
name|flags
operator|&
name|INT_BCASTOPEN
condition|)
block|{
comment|/* account for already open interfaces to aviod misleading warning below */
name|nif
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Try to open the broadcast address 		 */
name|interf
operator|->
name|family
operator|=
name|AF_INET
expr_stmt|;
name|interf
operator|->
name|bfd
operator|=
name|open_socket
argument_list|(
operator|&
name|interf
operator|->
name|bcast
argument_list|,
name|INT_BROADCAST
argument_list|,
literal|0
argument_list|,
name|interf
argument_list|)
expr_stmt|;
comment|/* 		 * If we succeeded then we use it otherwise 		 * enable the underlying address 		 */
if|if
condition|(
name|interf
operator|->
name|bfd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|fd
operator|=
name|interf
operator|->
name|fd
expr_stmt|;
block|}
else|else
block|{
name|fd
operator|=
name|interf
operator|->
name|bfd
expr_stmt|;
block|}
comment|/* Enable Broadcast on socket */
name|jstatus
operator|=
name|socket_broadcast_enable
argument_list|(
name|interf
argument_list|,
name|fd
argument_list|,
operator|&
name|interf
operator|->
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|jstatus
operator|==
name|ISC_TRUE
condition|)
block|{
name|nif
operator|++
expr_stmt|;
name|netsyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"io_setbclient: Opened broadcast client on interface #%d %s, socket: %d"
argument_list|,
name|interf
operator|->
name|ifnum
argument_list|,
name|interf
operator|->
name|name
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|interf
operator|->
name|addr_refid
operator|=
name|addr2refid
argument_list|(
operator|&
name|interf
operator|->
name|sin
argument_list|)
expr_stmt|;
block|}
block|}
name|set_reuseaddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
if|if
condition|(
name|nif
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"io_setbclient: Opened broadcast clients\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nif
operator|==
literal|0
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to listen for broadcasts, no broadcast interfaces available"
argument_list|)
expr_stmt|;
else|#
directive|else
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"io_setbclient: Broadcast Client disabled by build"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * io_unsetbclient - close the broadcast client sockets  */
end_comment

begin_function
name|void
name|io_unsetbclient
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|interf
decl_stmt|;
name|isc_boolean_t
name|lstatus
decl_stmt|;
for|for
control|(
name|interf
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|inter_list
argument_list|)
init|;
name|interf
operator|!=
name|NULL
condition|;
name|interf
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|interf
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|interf
operator|->
name|flags
operator|&
name|INT_WILDCARD
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|interf
operator|->
name|flags
operator|&
name|INT_BCASTOPEN
operator|)
condition|)
continue|continue;
name|lstatus
operator|=
name|socket_broadcast_disable
argument_list|(
name|interf
argument_list|,
operator|&
name|interf
operator|->
name|sin
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * io_multicast_add() - add multicast group address  */
end_comment

begin_function
name|void
name|io_multicast_add
parameter_list|(
name|struct
name|sockaddr_storage
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCAST
name|struct
name|interface
modifier|*
name|interface
decl_stmt|;
ifndef|#
directive|ifndef
name|MULTICAST_NONEWSOCKET
name|struct
name|interface
modifier|*
name|iface
decl_stmt|;
endif|#
directive|endif
name|int
name|lscope
init|=
literal|0
decl_stmt|;
comment|/* 	 * Check to see if this is a multicast address 	 */
if|if
condition|(
name|addr_ismulticast
argument_list|(
operator|&
name|addr
argument_list|)
operator|==
name|ISC_FALSE
condition|)
return|return;
comment|/* If we already have it we can just return */
if|if
condition|(
name|find_flagged_addr_in_list
argument_list|(
operator|&
name|addr
argument_list|,
name|INT_MCASTOPEN
operator||
name|INT_MCASTIF
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Duplicate request found for multicast address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|MULTICAST_NONEWSOCKET
name|interface
operator|=
name|new_interface
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Open a new socket for the multicast address 	 */
name|interface
operator|->
name|sin
operator|.
name|ss_family
operator|=
name|addr
operator|.
name|ss_family
expr_stmt|;
name|interface
operator|->
name|family
operator|=
name|addr
operator|.
name|ss_family
expr_stmt|;
switch|switch
condition|(
name|addr
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin_addr
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|addr
operator|)
operator|->
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|interface
operator|->
name|mask
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin6_addr
operator|)
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESCOPEID
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin6_scope_id
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|addr
operator|)
operator|->
name|sin6_scope_id
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|interface
operator|->
name|mask
operator|)
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iface
operator|=
name|findlocalcastinterface
argument_list|(
operator|&
name|addr
argument_list|,
name|INT_MULTICAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
condition|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESCOPEID
name|lscope
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|iface
operator|->
name|sin
operator|)
operator|->
name|sin6_scope_id
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Found interface #%d %s, scope: %d for address %s\n"
operator|,
name|iface
operator|->
name|ifnum
operator|,
name|iface
operator|->
name|name
operator|,
name|lscope
operator|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|set_reuseaddr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|interface
operator|->
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|interface
operator|->
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|,
name|INT_MULTICAST
argument_list|,
literal|0
argument_list|,
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|interface
operator|->
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|interface
operator|->
name|ignore_packets
operator|=
name|ISC_FALSE
expr_stmt|;
name|interface
operator|->
name|flags
operator||=
name|INT_MCASTIF
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|interface
operator|->
name|name
argument_list|,
literal|"multicast"
argument_list|,
sizeof|sizeof
argument_list|(
name|interface
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|interface
operator|->
name|mask
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|~
operator|(
name|u_int32
operator|)
literal|0
argument_list|)
expr_stmt|;
name|DPRINT_INTERFACE
argument_list|(
literal|2
argument_list|,
operator|(
name|interface
operator|,
literal|"multicast add "
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* socket_multicast_enable() will add this address to the addresslist */
name|add_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|list_if_listening
argument_list|(
name|interface
argument_list|,
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delete_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
comment|/* re-use existing interface */
name|interface
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|ss_family
operator|==
name|AF_INET
condition|)
name|interface
operator|=
name|wildipv4
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|.
name|ss_family
operator|==
name|AF_INET6
condition|)
name|interface
operator|=
name|wildipv6
expr_stmt|;
if|if
condition|(
name|interface
operator|!=
name|NULL
condition|)
block|{
comment|/* HACK ! -- stuff in an address */
name|interface
operator|->
name|bcast
operator|=
name|addr
expr_stmt|;
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"...multicast address %s using wildcard interface #%d %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|,
name|interface
operator|->
name|ifnum
argument_list|,
name|interface
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No multicast socket available to use for address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|#
directive|else
comment|/* 	 * For the case where we can't use a separate socket 	 */
name|interface
operator|=
name|findlocalcastinterface
argument_list|(
operator|&
name|addr
argument_list|,
name|INT_MULTICAST
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have a valid socket, just return 	 */
if|if
condition|(
operator|!
name|interface
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot add multicast address %s: Cannot find slot"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
block|{
name|isc_boolean_t
name|jstatus
decl_stmt|;
name|jstatus
operator|=
name|socket_multicast_enable
argument_list|(
name|interface
argument_list|,
name|lscope
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|jstatus
operator|==
name|ISC_TRUE
condition|)
name|netsyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Added Multicast Listener %s on interface #%d %s\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|,
name|interface
operator|->
name|ifnum
argument_list|,
name|interface
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to add Multicast Listener %s\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* MCAST */
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot add multicast address %s: no Multicast support"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MCAST */
return|return;
block|}
end_function

begin_comment
comment|/*  * io_multicast_del() - delete multicast group address  */
end_comment

begin_function
name|void
name|io_multicast_del
parameter_list|(
name|struct
name|sockaddr_storage
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCAST
name|struct
name|interface
modifier|*
name|interface
decl_stmt|;
name|isc_boolean_t
name|lstatus
decl_stmt|;
comment|/* 	 * Check to see if this is a multicast address 	 */
if|if
condition|(
name|addr_ismulticast
argument_list|(
operator|&
name|addr
argument_list|)
operator|==
name|ISC_FALSE
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid multicast address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|addr
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
comment|/* 		 * Disable reception of multicast packets 		 */
name|interface
operator|=
name|find_flagged_addr_in_list
argument_list|(
operator|&
name|addr
argument_list|,
name|INT_MCASTOPEN
argument_list|)
expr_stmt|;
while|while
condition|(
name|interface
operator|!=
name|NULL
condition|)
block|{
name|lstatus
operator|=
name|socket_multicast_disable
argument_list|(
name|interface
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
name|interface
operator|=
name|find_flagged_addr_in_list
argument_list|(
operator|&
name|addr
argument_list|,
name|INT_MCASTOPEN
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
case|case
name|AF_INET6
case|:
comment|/* 		 * Disable reception of multicast packets 		 */
for|for
control|(
name|interface
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|inter_list
argument_list|)
init|;
name|interface
operator|!=
name|NULL
condition|;
name|interface
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|interface
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|interface
operator|->
name|flags
operator|&
name|INT_WILDCARD
condition|)
continue|continue;
comment|/* Be sure it's the correct family */
if|if
condition|(
name|interface
operator|->
name|sin
operator|.
name|ss_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|interface
operator|->
name|flags
operator|&
name|INT_MCASTOPEN
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|interface
operator|->
name|fd
operator|<
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|SOCKCMP
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|interface
operator|->
name|sin
argument_list|)
condition|)
continue|continue;
name|lstatus
operator|=
name|socket_multicast_disable
argument_list|(
name|interface
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_MULTICAST_SUPPORT */
block|}
comment|/* switch */
name|delete_addr_from_list
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not MCAST */
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"this function requires multicast kernel"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not MCAST */
block|}
end_function

begin_comment
comment|/*  * init_nonblocking_io() - set up descriptor to be non blocking  */
end_comment

begin_function
specifier|static
name|void
name|init_nonblocking_io
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
comment|/* 	 * set non-blocking, 	 */
ifdef|#
directive|ifdef
name|USE_FIONBIO
comment|/* in vxWorks we use FIONBIO, but the others are defined for old systems, so 	 * all hell breaks loose if we leave them defined 	 */
undef|#
directive|undef
name|O_NONBLOCK
undef|#
directive|undef
name|FNDELAY
undef|#
directive|undef
name|O_NDELAY
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
comment|/* POSIX */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NONBLOCK) fails on fd #%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY) fails on fd #%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
comment|/* generally the same as FNDELAY */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NDELAY) fails on fd #%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIONBIO
argument_list|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIONBIO) fails on fd #%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIOSNBIO
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOSNBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSNBIO) fails on fd #%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
include|#
directive|include
file|"Bletch: Need non-blocking I/O!"
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * open_socket - open a socket, returning the file descriptor  */
end_comment

begin_function
specifier|static
name|SOCKET
name|open_socket
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|turn_off_reuse
parameter_list|,
name|struct
name|interface
modifier|*
name|interf
parameter_list|)
block|{
name|int
name|errval
decl_stmt|;
name|SOCKET
name|fd
decl_stmt|;
comment|/* 	 * int is OK for REUSEADR per  	 * http://www.kohala.com/start/mcast.api.txt 	 */
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPTOS_LOWDELAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPPROTO_IP
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_TOS
argument_list|)
name|int
name|tos
decl_stmt|;
endif|#
directive|endif
comment|/* IPTOS_LOWDELAY&& IPPROTO_IP&& IP_TOS */
if|if
condition|(
operator|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|isc_net_probeipv6
argument_list|()
operator|!=
name|ISC_R_SUCCESS
operator|)
condition|)
return|return
operator|(
name|INVALID_SOCKET
operator|)
return|;
comment|/* create a datagram (UDP) socket */
name|fd
operator|=
name|socket
argument_list|(
name|addr
operator|->
name|ss_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_SOCKET
operator|==
name|fd
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
name|errval
operator|=
name|errno
expr_stmt|;
else|#
directive|else
name|errval
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket(AF_INET%s, SOCK_DGRAM, 0) failed on address %s: %m"
argument_list|,
operator|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
operator|)
condition|?
literal|"6"
else|:
literal|""
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errval
operator|==
name|EPROTONOSUPPORT
operator|||
name|errval
operator|==
name|EAFNOSUPPORT
operator|||
name|errval
operator|==
name|EPFNOSUPPORT
condition|)
return|return
operator|(
name|INVALID_SOCKET
operator|)
return|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unexpected error code %d (not PROTONOSUPPORT|AFNOSUPPORT|FPNOSUPPORT) - exiting"
argument_list|,
name|errval
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
ifdef|#
directive|ifdef
name|SYS_WINNT
name|connection_reset_fix
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Fixup the file descriptor for some systems 	 * See bug #530 for details of the issue. 	 */
name|fd
operator|=
name|move_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * set SO_REUSEADDR since we will be binding the same port 	 * number on each interface according to turn_off_reuse. 	 * This is undesirable on Windows versions starting with 	 * Windows XP (numeric version 5.1). 	 */
ifdef|#
directive|ifdef
name|SYS_WINNT
if|if
condition|(
name|isc_win32os_versioncheck
argument_list|(
literal|5
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
comment|/* before 5.1 */
endif|#
directive|endif
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|turn_off_reuse
condition|?
operator|&
name|off
else|:
operator|&
name|on
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt SO_REUSEADDR %s"
literal|" fails for address %s: %m"
argument_list|,
name|turn_off_reuse
condition|?
literal|"off"
else|:
literal|"on"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
ifdef|#
directive|ifdef
name|SO_EXCLUSIVEADDRUSE
comment|/* 	 * setting SO_EXCLUSIVEADDRUSE on the wildcard we open 	 * first will cause more specific binds to fail. 	 */
if|if
condition|(
operator|!
operator|(
name|interf
operator|->
name|flags
operator|&
name|INT_WILDCARD
operator|)
condition|)
name|set_excladdruse
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * IPv4 specific options go here 	 */
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPTOS_LOWDELAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPPROTO_IP
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_TOS
argument_list|)
comment|/* set IP_TOS to minimize packet delay */
name|tos
operator|=
name|IPTOS_LOWDELAY
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_TOS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tos
argument_list|,
sizeof|sizeof
argument_list|(
name|tos
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPTOS_LOWDELAY on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPTOS_LOWDELAY&& IPPROTO_IP&& IP_TOS */
block|}
comment|/* 	 * IPv6 specific options go here 	 */
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPV6_V6ONLY
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_V6ONLY on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPV6_V6ONLY */
if|#
directive|if
name|defined
argument_list|(
name|IPV6_BINDV6ONLY
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_BINDV6ONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_BINDV6ONLY on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPV6_BINDV6ONLY */
block|}
ifdef|#
directive|ifdef
name|OS_NEEDS_REUSEADDR_FOR_IFADDRBIND
comment|/* 	 * some OSes don't allow binding to more specific 	 * addresses if a wildcard address already bound 	 * to the port and SO_REUSEADDR is not set 	 */
if|if
condition|(
operator|!
name|is_wildcard_addr
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|set_wildcard_reuse
argument_list|(
name|addr
operator|->
name|ss_family
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * bind the local address. 	 */
name|errval
operator|=
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|SOCKLEN
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OS_NEEDS_REUSEADDR_FOR_IFADDRBIND
comment|/* 	 * some OSes don't allow binding to more specific 	 * addresses if a wildcard address already bound 	 * to the port and REUSE_ADDR is not set 	 */
if|if
condition|(
operator|!
name|is_wildcard_addr
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|set_wildcard_reuse
argument_list|(
name|addr
operator|->
name|ss_family
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|errval
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Don't log this under all conditions 		 */
if|if
condition|(
name|turn_off_reuse
operator|==
literal|0
ifdef|#
directive|ifdef
name|DEBUG
operator|||
name|debug
operator|>
literal|1
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind() fd %d, family AF_INET, port %d, addr %s, in_classd=%d flags=0x%x fails: %m"
argument_list|,
name|fd
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
elseif|else
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind() fd %d, family AF_INET6, port %d, scope %d, addr %s, mcast=%d flags=0x%x fails: %m"
argument_list|,
name|fd
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_port
argument_list|)
argument_list|,
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESCOPEID
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_scope_id
else|#
directive|else
operator|-
literal|1
endif|#
directive|endif
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMP
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_TIMESTAMP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"setsockopt SO_TIMESTAMP on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
else|else
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"setsockopt SO_TIMESTAMP enabled on fd %d address %s\n"
operator|,
name|fd
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"bind() fd %d, family %d, port %d, addr %s, flags=0x%x\n"
operator|,
name|fd
operator|,
name|addr
operator|->
name|ss_family
operator|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
argument_list|)
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|,
name|interf
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|init_nonblocking_io
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
name|init_socket_sig
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGNALED_IO */
name|add_fd_to_list
argument_list|(
name|fd
argument_list|,
name|FD_TYPE_SOCKET
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"flags for fd %d: 0x%x\n"
operator|,
name|fd
operator|,
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT || VMS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
comment|/*  * Add the socket to the completion port  */
if|if
condition|(
name|io_completion_port_add_socket
argument_list|(
name|fd
argument_list|,
name|interf
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to set up io completion port - EXITING"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE sendpkt similar in ntpq.c, ntpdc.c, ntp_io.c, ntptrace.c */
end_comment

begin_comment
comment|/*  * sendpkt - send a packet to the specified destination. Maintain a  * send error cache so that only the first consecutive error for a  * destination is logged.  */
end_comment

begin_function
name|void
name|sendpkt
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|dest
parameter_list|,
name|struct
name|interface
modifier|*
name|inter
parameter_list|,
name|int
name|ttl
parameter_list|,
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cc
decl_stmt|,
name|slot
decl_stmt|;
comment|/* 	 * Send error caches. Empty slots have port == 0 	 * Set ERRORCACHESIZE to 0 to disable 	 */
struct|struct
name|cache
block|{
name|u_short
name|port
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
block|}
struct|;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
struct|struct
name|cache6
block|{
name|u_short
name|port
decl_stmt|;
name|struct
name|in6_addr
name|addr
decl_stmt|;
block|}
struct|;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT */
ifndef|#
directive|ifndef
name|ERRORCACHESIZE
define|#
directive|define
name|ERRORCACHESIZE
value|8
endif|#
directive|endif
if|#
directive|if
name|ERRORCACHESIZE
operator|>
literal|0
specifier|static
name|struct
name|cache
name|badaddrs
index|[
name|ERRORCACHESIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
specifier|static
name|struct
name|cache6
name|badaddrs6
index|[
name|ERRORCACHESIZE
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT */
else|#
directive|else
define|#
directive|define
name|badaddrs
value|((struct cache *)0)
comment|/* Only used in empty loops! */
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
define|#
directive|define
name|badaddrs6
value|((struct cache6 *)0)
comment|/* Only used in empty loops! */
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|inter
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%ssendpkt(fd=%d dst=%s, src=%s, ttl=%d, len=%d)\n"
argument_list|,
operator|(
name|ttl
operator|>
literal|0
operator|)
condition|?
literal|"\tMCAST\t***** "
else|:
literal|""
argument_list|,
name|inter
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
name|dest
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|inter
operator|->
name|sin
argument_list|)
argument_list|,
name|ttl
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%ssendpkt(dst=%s, ttl=%d, len=%d): no interface - IGNORED\n"
argument_list|,
operator|(
name|ttl
operator|>
literal|0
operator|)
condition|?
literal|"\tMCAST\t***** "
else|:
literal|""
argument_list|,
name|stoa
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ttl
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|inter
operator|==
name|NULL
condition|)
comment|/* unbound peer - drop request and wait for better network conditions */
return|return;
ifdef|#
directive|ifdef
name|MCAST
comment|/* 	 * for the moment we use the bcast option to set multicast ttl 	 */
if|if
condition|(
name|ttl
operator|>
literal|0
operator|&&
name|ttl
operator|!=
name|inter
operator|->
name|last_ttl
condition|)
block|{
comment|/* 		 * set the multicast ttl for outgoing packets 		 */
name|int
name|rtc
decl_stmt|;
switch|switch
condition|(
name|inter
operator|->
name|sin
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
block|{
name|u_char
name|mttl
init|=
operator|(
name|u_char
operator|)
name|ttl
decl_stmt|;
name|rtc
operator|=
name|setsockopt
argument_list|(
name|inter
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_TTL
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|mttl
argument_list|,
sizeof|sizeof
argument_list|(
name|mttl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
case|case
name|AF_INET6
case|:
block|{
name|u_int
name|ittl
init|=
operator|(
name|u_char
operator|)
name|ttl
decl_stmt|;
name|rtc
operator|=
name|setsockopt
argument_list|(
name|inter
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MULTICAST_HOPS
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|ittl
argument_list|,
sizeof|sizeof
argument_list|(
name|ittl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT */
default|default:
comment|/* just NOP if not supported */
name|rtc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rtc
operator|!=
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_TTL/IPV6_MULTICAST_HOPS fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|inter
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inter
operator|->
name|last_ttl
operator|=
name|ttl
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MCAST */
for|for
control|(
name|slot
operator|=
name|ERRORCACHESIZE
init|;
operator|--
name|slot
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|dest
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin_port
operator|&&
name|badaddrs
index|[
name|slot
index|]
operator|.
name|addr
operator|.
name|s_addr
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
elseif|else
if|if
condition|(
name|dest
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|port
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin6_port
operator|&&
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|addr
operator|.
name|s6_addr
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin6_addr
operator|.
name|s6_addr
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
name|cc
operator|=
name|io_completion_port_sendto
argument_list|(
name|inter
argument_list|,
name|pkt
argument_list|,
name|len
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
name|ERROR_SUCCESS
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|SIM
name|cc
operator|=
name|srvr_rply
argument_list|(
operator|&
name|ntp_node
argument_list|,
name|dest
argument_list|,
name|inter
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SIM */
name|cc
operator|=
name|sendto
argument_list|(
name|inter
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dest
argument_list|,
name|SOCKLEN
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIM */
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|inter
operator|->
name|notsent
operator|++
expr_stmt|;
name|packets_notsent
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
if|if
condition|(
name|cc
operator|!=
name|WSAEWOULDBLOCK
operator|&&
name|cc
operator|!=
name|WSAENOBUFS
operator|&&
name|slot
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENOBUFS
operator|&&
name|slot
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
comment|/* 			 * Remember this, if there's an empty slot 			 */
switch|switch
condition|(
name|dest
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
for|for
control|(
name|slot
operator|=
name|ERRORCACHESIZE
init|;
operator|--
name|slot
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|==
literal|0
condition|)
block|{
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|=
name|SRCPORT
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|badaddrs
index|[
name|slot
index|]
operator|.
name|addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin_addr
expr_stmt|;
break|break;
block|}
break|break;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
case|case
name|AF_INET6
case|:
for|for
control|(
name|slot
operator|=
name|ERRORCACHESIZE
init|;
operator|--
name|slot
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|port
operator|==
literal|0
condition|)
block|{
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|port
operator|=
name|SRCPORT
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin6_addr
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT */
default|default:
comment|/* don't care if not supported */
break|break;
block|}
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto(%s) (fd=%d): %m"
argument_list|,
name|stoa
argument_list|(
name|dest
argument_list|)
argument_list|,
name|inter
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inter
operator|->
name|sent
operator|++
expr_stmt|;
name|packets_sent
operator|++
expr_stmt|;
comment|/* 		 * He's not bad any more 		 */
if|if
condition|(
name|slot
operator|>=
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Connection re-established to %s"
argument_list|,
name|stoa
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dest
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
case|case
name|AF_INET6
case|:
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|port
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT */
default|default:
comment|/* don't care if not supported */
break|break;
block|}
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
end_if

begin_comment
comment|/*  * fdbits - generate ascii representation of fd_set (FAU debug support)  * HFDF format - highest fd first.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fdbits
parameter_list|(
name|int
name|count
parameter_list|,
name|fd_set
modifier|*
name|set
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|buffer
decl_stmt|;
name|count
operator|=
operator|(
name|count
operator|<
literal|256
operator|)
condition|?
name|count
else|:
literal|255
expr_stmt|;
while|while
condition|(
name|count
operator|>=
literal|0
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|FD_ISSET
argument_list|(
name|count
argument_list|,
name|set
argument_list|)
condition|?
literal|'#'
else|:
literal|'-'
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*  * Routine to read the refclock packets for a specific interface  * Return the number of bytes read. That way we know if we should  * read it again or go on to the next one if no bytes returned  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|read_refclock_packet
parameter_list|(
name|SOCKET
name|fd
parameter_list|,
name|struct
name|refclockio
modifier|*
name|rp
parameter_list|,
name|l_fp
name|ts
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|buflen
decl_stmt|;
specifier|register
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
name|rb
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|rb
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No buffer space available - just drop the packet 		 */
name|char
name|buf
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
name|buflen
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|packets_dropped
operator|++
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
name|i
operator|=
operator|(
name|rp
operator|->
name|datalen
operator|==
literal|0
operator|||
name|rp
operator|->
name|datalen
operator|>
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
else|:
name|rp
operator|->
name|datalen
expr_stmt|;
name|buflen
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"clock read fd %d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
comment|/* 	 * Got one. Mark how and when it got here, 	 * put it on the full list and do bookkeeping. 	 */
name|rb
operator|->
name|recv_length
operator|=
name|buflen
expr_stmt|;
name|rb
operator|->
name|recv_srcclock
operator|=
name|rp
operator|->
name|srcclock
expr_stmt|;
name|rb
operator|->
name|dstadr
operator|=
literal|0
expr_stmt|;
name|rb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|receiver
operator|=
name|rp
operator|->
name|clock_recv
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|io_input
condition|)
block|{
comment|/* 		 * have direct input routine for refclocks 		 */
if|if
condition|(
name|rp
operator|->
name|io_input
argument_list|(
name|rb
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * data was consumed - nothing to pass up 			 * into block input machine 			 */
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
block|}
name|add_full_recv_buffer
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|rp
operator|->
name|recvcount
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMP
end_ifdef

begin_comment
comment|/*  * extract timestamps from control message buffer  */
end_comment

begin_function
specifier|static
name|l_fp
name|fetch_timestamp
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rb
parameter_list|,
name|struct
name|msghdr
modifier|*
name|msghdr
parameter_list|,
name|l_fp
name|ts
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_TIMESTAMP_CMSG
name|struct
name|cmsghdr
modifier|*
name|cmsghdr
decl_stmt|;
name|cmsghdr
operator|=
name|CMSG_FIRSTHDR
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmsghdr
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|cmsghdr
operator|->
name|cmsg_type
condition|)
block|{
case|case
name|SCM_TIMESTAMP
case|:
block|{
name|struct
name|timeval
modifier|*
name|tvp
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsghdr
argument_list|)
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
name|l_fp
name|nts
decl_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"fetch_timestamp: system network time stamp: %ld.%06ld\n"
operator|,
name|tvp
operator|->
name|tv_sec
operator|,
name|tvp
operator|->
name|tv_usec
operator|)
argument_list|)
expr_stmt|;
name|nts
operator|.
name|l_i
operator|=
name|tvp
operator|->
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|dtemp
operator|=
name|tvp
operator|->
name|tv_usec
operator|/
literal|1e6
expr_stmt|;
comment|/* fuzz lower bits not covered by precision */
if|if
condition|(
name|sys_precision
operator|!=
literal|0
condition|)
name|dtemp
operator|+=
operator|(
name|ntp_random
argument_list|()
operator|/
name|FRAC
operator|-
literal|.5
operator|)
operator|/
operator|(
literal|1
operator|<<
operator|-
name|sys_precision
operator|)
expr_stmt|;
name|nts
operator|.
name|l_uf
operator|=
call|(
name|u_int32
call|)
argument_list|(
name|dtemp
operator|*
name|FRAC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_TIMING
block|{
name|l_fp
name|dts
init|=
name|ts
decl_stmt|;
name|L_SUB
argument_list|(
operator|&
name|dts
argument_list|,
operator|&
name|nts
argument_list|)
expr_stmt|;
name|collect_timing
argument_list|(
name|rb
argument_list|,
literal|"input processing delay"
argument_list|,
literal|1
argument_list|,
operator|&
name|dts
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"fetch_timestamp: timestamp delta: %s (incl. prec fuzz)\n"
operator|,
name|lfptoa
argument_list|(
operator|&
name|dts
argument_list|,
literal|9
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ts
operator|=
name|nts
expr_stmt|;
comment|/* network time stamp */
break|break;
block|}
default|default:
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"fetch_timestamp: skipping control message 0x%x\n"
operator|,
name|cmsghdr
operator|->
name|cmsg_type
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|cmsghdr
operator|=
name|CMSG_NXTHDR
argument_list|(
name|msghdr
argument_list|,
name|cmsghdr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|ts
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Routine to read the network NTP packets for a specific interface  * Return the number of bytes read. That way we know if we should  * read it again or go on to the next one if no bytes returned  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|read_network_packet
parameter_list|(
name|SOCKET
name|fd
parameter_list|,
name|struct
name|interface
modifier|*
name|itf
parameter_list|,
name|l_fp
name|ts
parameter_list|)
block|{
name|GETSOCKNAME_SOCKLEN_TYPE
name|fromlen
decl_stmt|;
name|int
name|buflen
decl_stmt|;
specifier|register
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMP
name|struct
name|msghdr
name|msghdr
decl_stmt|;
name|struct
name|iovec
name|iovec
decl_stmt|;
name|char
name|control
index|[
name|TIMESTAMP_CTLMSGBUF_SIZE
index|]
decl_stmt|;
comment|/* pick up control messages */
endif|#
directive|endif
comment|/* 	 * Get a buffer and read the frame.  If we 	 * haven't got a buffer, or this is received 	 * on a disallowed socket, just dump the 	 * packet. 	 */
name|rb
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|rb
operator|==
name|NULL
operator|||
name|itf
operator|->
name|ignore_packets
operator|==
name|ISC_TRUE
condition|)
block|{
name|char
name|buf
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
name|struct
name|sockaddr_storage
name|from
decl_stmt|;
if|if
condition|(
name|rb
operator|!=
name|NULL
condition|)
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s on (%lu) fd=%d from %s\n"
operator|,
operator|(
name|itf
operator|->
name|ignore_packets
operator|==
name|ISC_TRUE
operator|)
condition|?
literal|"ignore"
else|:
literal|"drop"
operator|,
name|free_recvbuffs
argument_list|()
operator|,
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|from
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|itf
operator|->
name|ignore_packets
operator|==
name|ISC_TRUE
condition|)
name|packets_ignored
operator|++
expr_stmt|;
else|else
name|packets_dropped
operator|++
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_TIMESTAMP
name|rb
operator|->
name|recv_length
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
argument_list|,
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
else|#
directive|else
name|iovec
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
expr_stmt|;
name|iovec
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
expr_stmt|;
name|msghdr
operator|.
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_srcadr
expr_stmt|;
name|msghdr
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|msghdr
operator|.
name|msg_iov
operator|=
operator|&
name|iovec
expr_stmt|;
name|msghdr
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msghdr
operator|.
name|msg_control
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|control
expr_stmt|;
name|msghdr
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|msghdr
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|recvmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|msghdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buflen
operator|=
name|rb
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|buflen
operator|==
literal|0
operator|||
operator|(
name|buflen
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|EWOULDBLOCK
ifdef|#
directive|ifdef
name|EAGAIN
operator|||
name|errno
operator|==
name|EAGAIN
endif|#
directive|endif
operator|)
operator|)
condition|)
block|{
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"recvfrom(%s) fd=%d: %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"read_network_packet: fd=%d dropped (bad recvfrom)\n"
operator|,
name|fd
operator|)
argument_list|)
expr_stmt|;
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|rb
operator|->
name|recv_srcadr
operator|.
name|ss_family
operator|==
name|AF_INET
condition|)
name|printf
argument_list|(
literal|"read_network_packet: fd=%d length %d from %08lx %s\n"
argument_list|,
name|fd
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_srcadr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|&
literal|0x00000000ffffffff
argument_list|,
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"read_network_packet: fd=%d length %d from %s\n"
argument_list|,
name|fd
argument_list|,
name|buflen
argument_list|,
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Got one.  Mark how and when it got here, 	 * put it on the full list and do bookkeeping. 	 */
name|rb
operator|->
name|dstadr
operator|=
name|itf
expr_stmt|;
name|rb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMP
name|ts
operator|=
name|fetch_timestamp
argument_list|(
name|rb
argument_list|,
operator|&
name|msghdr
argument_list|,
name|ts
argument_list|)
expr_stmt|;
comment|/* pick up a network time stamp if possible */
endif|#
directive|endif
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|receiver
operator|=
name|receive
expr_stmt|;
name|add_full_recv_buffer
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|itf
operator|->
name|received
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * input_handler - receive packets asynchronously  */
end_comment

begin_function
name|void
name|input_handler
parameter_list|(
name|l_fp
modifier|*
name|cts
parameter_list|)
block|{
name|int
name|buflen
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|doing
decl_stmt|;
name|SOCKET
name|fd
decl_stmt|;
name|struct
name|timeval
name|tvzero
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
comment|/* Timestamp at BOselect() gob */
ifdef|#
directive|ifdef
name|DEBUG_TIMING
name|l_fp
name|ts_e
decl_stmt|;
comment|/* Timestamp at EOselect() gob */
endif|#
directive|endif
name|fd_set
name|fds
decl_stmt|;
name|int
name|select_count
init|=
literal|0
decl_stmt|;
name|struct
name|interface
modifier|*
name|interface
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_ROUTING_SOCKET
argument_list|)
name|struct
name|asyncio_reader
modifier|*
name|asyncio_reader
decl_stmt|;
endif|#
directive|endif
name|handler_calls
operator|++
expr_stmt|;
comment|/* 	 * If we have something to do, freeze a timestamp. 	 * See below for the other cases (nothing (left) to do or error) 	 */
name|ts
operator|=
operator|*
name|cts
expr_stmt|;
comment|/* 	 * Do a poll to see who has data 	 */
name|fds
operator|=
name|activefds
expr_stmt|;
name|tvzero
operator|.
name|tv_sec
operator|=
name|tvzero
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|maxactivefd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvzero
argument_list|)
expr_stmt|;
comment|/* 	 * If there are no packets waiting just return 	 */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
comment|/* 		 * extended FAU debugging output 		 */
if|if
condition|(
name|err
operator|!=
name|EINTR
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select(%d, %s, 0L, 0L,&0.0) error: %m"
argument_list|,
name|maxactivefd
operator|+
literal|1
argument_list|,
name|fdbits
argument_list|(
name|maxactivefd
argument_list|,
operator|&
name|activefds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBADF
condition|)
block|{
name|int
name|j
decl_stmt|,
name|b
decl_stmt|;
name|fds
operator|=
name|activefds
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|maxactivefd
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|FD_ISSET
argument_list|(
name|j
argument_list|,
operator|&
name|fds
argument_list|)
operator|&&
operator|(
name|read
argument_list|(
name|j
argument_list|,
operator|&
name|b
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Bad file descriptor %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
operator|++
name|handler_pkts
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 	 * Check out the reference clocks first, if any 	 */
if|if
condition|(
name|refio
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|struct
name|refclockio
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|refio
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
name|fd
operator|=
name|rp
operator|->
name|fd
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
do|do
block|{
operator|++
name|select_count
expr_stmt|;
name|buflen
operator|=
name|read_refclock_packet
argument_list|(
name|fd
argument_list|,
name|rp
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|buflen
operator|>
literal|0
condition|)
do|;
block|}
comment|/* End if (FD_ISSET(fd,&fds)) */
block|}
comment|/* End for (rp = refio; rp != 0&& n> 0; rp = rp->next) */
block|}
comment|/* End if (refio != 0) */
endif|#
directive|endif
comment|/* REFCLOCK */
comment|/* 	 * Loop through the interfaces looking for data to read. 	 */
for|for
control|(
name|interface
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|inter_list
argument_list|)
init|;
name|interface
operator|!=
name|NULL
condition|;
name|interface
operator|=
name|ISC_LIST_PREV
argument_list|(
name|interface
argument_list|,
name|link
argument_list|)
control|)
block|{
for|for
control|(
name|doing
operator|=
literal|0
init|;
operator|(
name|doing
operator|<
literal|2
operator|)
condition|;
name|doing
operator|++
control|)
block|{
if|if
condition|(
name|doing
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
name|interface
operator|->
name|fd
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|interface
operator|->
name|flags
operator|&
name|INT_BCASTOPEN
operator|)
condition|)
break|break;
name|fd
operator|=
name|interface
operator|->
name|bfd
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
do|do
block|{
operator|++
name|select_count
expr_stmt|;
name|buflen
operator|=
name|read_network_packet
argument_list|(
name|fd
argument_list|,
name|interface
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|buflen
operator|>
literal|0
condition|)
do|;
block|}
comment|/* Check more interfaces */
block|}
block|}
ifdef|#
directive|ifdef
name|HAS_ROUTING_SOCKET
comment|/* 	 * scan list of asyncio readers - currently only used for routing sockets 	 */
name|asyncio_reader
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|asyncio_reader_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|asyncio_reader
operator|!=
name|NULL
condition|)
block|{
name|struct
name|asyncio_reader
modifier|*
name|next
init|=
name|ISC_LIST_PREV
argument_list|(
name|asyncio_reader
argument_list|,
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|asyncio_reader
operator|->
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
operator|++
name|select_count
expr_stmt|;
name|asyncio_reader
operator|->
name|receiver
argument_list|(
name|asyncio_reader
argument_list|)
expr_stmt|;
block|}
name|asyncio_reader
operator|=
name|next
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_ROUTING_SOCKET */
comment|/* 	 * Done everything from that select. 	 */
comment|/* 	 * If nothing to do, just return. 	 * If an error occurred, complain and return. 	 */
if|if
condition|(
name|select_count
operator|==
literal|0
condition|)
comment|/* We really had nothing to do */
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|netsyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"input_handler: select() returned 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* We've done our work */
ifdef|#
directive|ifdef
name|DEBUG_TIMING
name|get_systime
argument_list|(
operator|&
name|ts_e
argument_list|)
expr_stmt|;
comment|/* 	 * (ts_e - ts) is the amount of time we spent 	 * processing this gob of file descriptors.  Log 	 * it. 	 */
name|L_SUB
argument_list|(
operator|&
name|ts_e
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|collect_timing
argument_list|(
name|NULL
argument_list|,
literal|"input handler"
argument_list|,
literal|1
argument_list|,
operator|&
name|ts_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|netsyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"input_handler: Processed a gob of fd's in %s msec"
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|ts_e
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* just bail. */
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * findinterface - find local interface corresponding to address  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|findinterface
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|interface
decl_stmt|;
name|interface
operator|=
name|findlocalinterface
argument_list|(
name|addr
argument_list|,
name|INT_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Found no interface for address %s - returning wildcard\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ANY_INTERFACE_CHOOSE
argument_list|(
name|addr
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Found interface #%d %s for address %s\n"
operator|,
name|interface
operator|->
name|ifnum
operator|,
name|interface
operator|->
name|name
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|interface
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * findlocalinterface - find local interface index corresponding to address  *  * This code attempts to find the local sending address for an outgoing  * address by connecting a new socket to destinationaddress:NTP_PORT  * and reading the sockname of the resulting connect.  * the complicated sequence simulates the routing table lookup  * for to first hop without duplicating any of the routing logic into  * ntpd. preferably we would have used an API call - but its not there -  * so this is the best we can do here short of duplicating to entire routing  * logic in ntpd which would be a silly and really unportable thing to do.  *  */
end_comment

begin_function
specifier|static
name|struct
name|interface
modifier|*
name|findlocalinterface
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|SOCKET
name|s
decl_stmt|;
name|int
name|rtn
decl_stmt|;
name|struct
name|sockaddr_storage
name|saddr
decl_stmt|;
name|GETSOCKNAME_SOCKLEN_TYPE
name|saddrlen
init|=
name|SOCKLEN
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|struct
name|interface
modifier|*
name|iface
decl_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Finding interface for addr %s in list of addresses\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|saddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
name|saddr
operator|.
name|ss_family
operator|=
name|addr
operator|->
name|ss_family
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|saddr
operator|)
operator|->
name|sin_addr
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|saddr
operator|)
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
elseif|else
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|saddr
operator|)
operator|->
name|sin6_addr
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|saddr
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESCOPEID
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|saddr
operator|)
operator|->
name|sin6_scope_id
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_scope_id
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|s
operator|=
name|socket
argument_list|(
name|addr
operator|->
name|ss_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|INVALID_SOCKET
condition|)
return|return
name|NULL
return|;
name|rtn
operator|=
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
name|SOCKLEN
argument_list|(
operator|&
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|rtn
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|rtn
operator|==
name|SOCKET_ERROR
condition|)
endif|#
directive|endif
block|{
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rtn
operator|=
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
operator|&
name|saddrlen
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|rtn
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|rtn
operator|==
name|SOCKET_ERROR
condition|)
endif|#
directive|endif
return|return
name|NULL
return|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"findlocalinterface: kernel maps %s to %s\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|,
name|stoa
argument_list|(
operator|&
name|saddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|iface
operator|=
name|getinterface
argument_list|(
operator|&
name|saddr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Don't both with ignore interfaces */
if|if
condition|(
name|iface
operator|!=
name|NULL
operator|&&
name|iface
operator|->
name|ignore_packets
operator|==
name|ISC_TRUE
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|iface
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * fetch an interface structure the matches the  * address is has the given flags not set  */
end_comment

begin_function
specifier|static
name|struct
name|interface
modifier|*
name|getinterface
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|interface
init|=
name|find_addr_in_list
argument_list|(
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|interface
operator|!=
name|NULL
operator|&&
name|interface
operator|->
name|flags
operator|&
name|flags
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|interface
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * findlocalcastinterface - find local *cast interface index corresponding to address  * depending on the flags passed  */
end_comment

begin_function
specifier|static
name|struct
name|interface
modifier|*
name|findlocalcastinterface
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|interface
decl_stmt|;
name|struct
name|interface
modifier|*
name|nif
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
name|isc_boolean_t
name|want_linklocal
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * see how kernel maps the mcast address 	 */
name|nif
operator|=
name|findlocalinterface
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nif
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"findlocalcastinterface: kernel recommends interface #%d %s\n"
operator|,
name|nif
operator|->
name|ifnum
operator|,
name|nif
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|nif
return|;
block|}
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
name|want_linklocal
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|addr_ismulticast
argument_list|(
name|addr
argument_list|)
operator|&&
name|flags
operator|==
name|INT_MULTICAST
condition|)
block|{
if|if
condition|(
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|want_linklocal
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_MC_SITELOCAL
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|want_linklocal
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|interface
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|inter_list
argument_list|)
init|;
name|interface
operator|!=
name|NULL
condition|;
name|interface
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|interface
argument_list|,
name|link
argument_list|)
control|)
block|{
comment|/* use only allowed addresses */
if|if
condition|(
name|interface
operator|->
name|ignore_packets
operator|==
name|ISC_TRUE
condition|)
continue|continue;
comment|/* Skip the loopback and wildcard addresses */
if|if
condition|(
name|interface
operator|->
name|flags
operator|&
operator|(
name|INT_LOOPBACK
operator||
name|INT_WILDCARD
operator|)
condition|)
continue|continue;
comment|/* Skip if different family */
if|if
condition|(
name|interface
operator|->
name|sin
operator|.
name|ss_family
operator|!=
name|addr
operator|->
name|ss_family
condition|)
continue|continue;
comment|/* Is this it one of these based on flags? */
if|if
condition|(
operator|!
operator|(
name|interface
operator|->
name|flags
operator|&
name|flags
operator|)
condition|)
continue|continue;
comment|/* for IPv6 multicast check the address for linklocal */
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
if|if
condition|(
name|flags
operator|==
name|INT_MULTICAST
operator|&&
name|interface
operator|->
name|sin
operator|.
name|ss_family
operator|==
name|AF_INET6
operator|&&
operator|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin6_addr
argument_list|)
operator|)
operator|&&
name|want_linklocal
operator|==
name|ISC_TRUE
condition|)
block|{
name|nif
operator|=
name|interface
expr_stmt|;
break|break;
block|}
comment|/* If we want a linklocal address and this isn't it, skip */
block|\
if|if
condition|(
name|want_linklocal
operator|==
name|ISC_TRUE
condition|)
continue|continue;
endif|#
directive|endif
comment|/* Otherwise just look for the flag */
if|if
condition|(
operator|(
name|interface
operator|->
name|flags
operator|&
name|flags
operator|)
condition|)
block|{
name|nif
operator|=
name|interface
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|nif
condition|)
name|printf
argument_list|(
literal|"findlocalcastinterface: found interface #%d %s\n"
argument_list|,
name|nif
operator|->
name|ifnum
argument_list|,
name|nif
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"findlocalcastinterface: no interface found for %s flags 0x%x\n"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|nif
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * findbcastinter - find broadcast interface corresponding to address  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|findbcastinter
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MPE
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|SIOCGIFCONF
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|)
name|struct
name|interface
modifier|*
name|interface
decl_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Finding broadcast/multicast interface for addr %s in list of addresses\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|interface
operator|=
name|findlocalinterface
argument_list|(
name|addr
argument_list|,
name|INT_LOOPBACK
operator||
name|INT_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Found bcast-/mcast- interface index #%d %s\n"
operator|,
name|interface
operator|->
name|ifnum
operator|,
name|interface
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|interface
return|;
block|}
comment|/* plan B - try to find something reasonable in our lists in case kernel lookup doesn't help */
for|for
control|(
name|interface
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|inter_list
argument_list|)
init|;
name|interface
operator|!=
name|NULL
condition|;
name|interface
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|interface
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|interface
operator|->
name|flags
operator|&
name|INT_WILDCARD
condition|)
continue|continue;
comment|/* Don't bother with ignored interfaces */
if|if
condition|(
name|interface
operator|->
name|ignore_packets
operator|==
name|ISC_TRUE
condition|)
continue|continue;
comment|/* 		 * First look if this is the correct family 		 */
if|if
condition|(
name|interface
operator|->
name|sin
operator|.
name|ss_family
operator|!=
name|addr
operator|->
name|ss_family
condition|)
continue|continue;
comment|/* Skip the loopback addresses */
if|if
condition|(
name|interface
operator|->
name|flags
operator|&
name|INT_LOOPBACK
condition|)
continue|continue;
comment|/* 		 * If we are looking to match a multicast address grab it. 		 */
if|if
condition|(
name|addr_ismulticast
argument_list|(
name|addr
argument_list|)
operator|==
name|ISC_TRUE
operator|&&
name|interface
operator|->
name|flags
operator|&
name|INT_MULTICAST
condition|)
block|{
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* Only use link-local address for link-scope mcast */
if|if
condition|(
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|interface
operator|->
name|sin
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
endif|#
directive|endif
break|break;
block|}
comment|/* 		 * We match only those interfaces marked as 		 * broadcastable and either the explicit broadcast 		 * address or the network portion of the IP address. 		 * Sloppy. 		 */
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|interface
operator|->
name|bcast
argument_list|,
name|addr
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|NSRCADR
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|)
operator|&
name|NSRCADR
argument_list|(
operator|&
name|interface
operator|->
name|mask
argument_list|)
operator|)
operator|==
operator|(
name|NSRCADR
argument_list|(
name|addr
argument_list|)
operator|&
name|NSRCADR
argument_list|(
operator|&
name|interface
operator|->
name|mask
argument_list|)
operator|)
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
elseif|else
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|interface
operator|->
name|bcast
argument_list|,
name|addr
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|SOCKCMP
argument_list|(
name|netof
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|)
argument_list|,
name|netof
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* SIOCGIFCONF */
if|if
condition|(
name|interface
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"No bcast interface found for %s\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|ANY_INTERFACE_CHOOSE
argument_list|(
name|addr
argument_list|)
return|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Found bcast-/mcast- interface index #%d %s\n"
operator|,
name|interface
operator|->
name|ifnum
operator|,
name|interface
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|interface
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * io_clr_stats - clear I/O module statistics  */
end_comment

begin_function
name|void
name|io_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|packets_dropped
operator|=
literal|0
expr_stmt|;
name|packets_ignored
operator|=
literal|0
expr_stmt|;
name|packets_received
operator|=
literal|0
expr_stmt|;
name|packets_sent
operator|=
literal|0
expr_stmt|;
name|packets_notsent
operator|=
literal|0
expr_stmt|;
name|handler_calls
operator|=
literal|0
expr_stmt|;
name|handler_pkts
operator|=
literal|0
expr_stmt|;
name|io_timereset
operator|=
name|current_time
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * io_addclock - add a reference clock to the list and arrange that we  *				 get SIGIO interrupts from it.  */
end_comment

begin_function
name|int
name|io_addclock
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* 	 * Stuff the I/O structure in the list and mark the descriptor 	 * in use.	There is a harmless (I hope) race condition here. 	 */
name|rio
operator|->
name|next
operator|=
name|refio
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
if|if
condition|(
name|init_clock_sig
argument_list|(
name|rio
argument_list|)
condition|)
block|{
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
if|if
condition|(
name|io_completion_port_add_clock_io
argument_list|(
name|rio
argument_list|)
condition|)
block|{
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* 	 * enqueue 	 */
name|refio
operator|=
name|rio
expr_stmt|;
comment|/* 	 * register fd 	 */
name|add_fd_to_list
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FD_TYPE_FILE
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * io_closeclock - close the clock in the I/O structure given  */
end_comment

begin_function
name|void
name|io_closeclock
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* 	 * Remove structure from the list 	 */
if|if
condition|(
name|refio
operator|==
name|rio
condition|)
block|{
name|refio
operator|=
name|rio
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|refclockio
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|refio
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
if|if
condition|(
name|rp
operator|->
name|next
operator|==
name|rio
condition|)
block|{
name|rp
operator|->
name|next
operator|=
name|rio
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Close the descriptor. 	 */
name|close_and_delete_fd_from_list
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_comment
comment|/*  * On NT a SOCKET is an unsigned int so we cannot possibly keep it in  * an array. So we use one of the ISC_LIST functions to hold the  * socket value and use that when we want to enumerate it.  */
end_comment

begin_function
name|void
name|kill_asyncio
parameter_list|(
name|int
name|startfd
parameter_list|)
block|{
name|vsock_t
modifier|*
name|lsock
decl_stmt|;
name|vsock_t
modifier|*
name|next
decl_stmt|;
name|BLOCKIO
argument_list|()
expr_stmt|;
name|lsock
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fd_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|lsock
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * careful here - list is being dismantled while 		 * we scan it - setting next here insures that 		 * we are able to correctly scan the list 		 */
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|lsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 		 * will remove socket from list 		 */
name|close_and_delete_fd_from_list
argument_list|(
name|lsock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|lsock
operator|=
name|next
expr_stmt|;
block|}
name|UNBLOCKIO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add and delete functions for the list of open sockets  */
end_comment

begin_function
specifier|static
name|void
name|add_fd_to_list
parameter_list|(
name|SOCKET
name|fd
parameter_list|,
name|enum
name|desc_type
name|type
parameter_list|)
block|{
name|vsock_t
modifier|*
name|lsock
init|=
operator|(
name|vsock_t
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vsock_t
argument_list|)
argument_list|)
decl_stmt|;
name|lsock
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|lsock
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fd_list
argument_list|,
name|lsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * I/O Completion Ports don't care about the select and FD_SET 	 */
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|fd
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Too many sockets in use, FD_SETSIZE %d exceeded"
argument_list|,
name|FD_SETSIZE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * keep activefds in sync 	 */
if|if
condition|(
name|fd
operator|>
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
operator|(
name|u_int
operator|)
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|close_and_delete_fd_from_list
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
name|vsock_t
modifier|*
name|next
decl_stmt|;
name|vsock_t
modifier|*
name|lsock
init|=
name|ISC_LIST_HEAD
argument_list|(
name|fd_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|lsock
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|lsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsock
operator|->
name|fd
operator|==
name|fd
condition|)
block|{
name|ISC_LIST_DEQUEUE_TYPE
argument_list|(
name|fd_list
argument_list|,
name|lsock
argument_list|,
name|link
argument_list|,
name|vsock_t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lsock
operator|->
name|type
condition|)
block|{
case|case
name|FD_TYPE_SOCKET
case|:
ifdef|#
directive|ifdef
name|SYS_WINNT
name|closesocket
argument_list|(
name|lsock
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FD_TYPE_FILE
case|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|lsock
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"internal error - illegal descriptor type %d - EXITING"
argument_list|,
operator|(
name|int
operator|)
name|lsock
operator|->
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|lsock
argument_list|)
expr_stmt|;
comment|/* 			 * I/O Completion Ports don't care about select and fd_set 			 */
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
comment|/* 			 * remove from activefds 			 */
name|FD_CLR
argument_list|(
operator|(
name|u_int
operator|)
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|maxactivefd
condition|)
block|{
name|int
name|i
decl_stmt|,
name|newmax
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxactivefd
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|activefds
argument_list|)
condition|)
name|newmax
operator|=
name|i
expr_stmt|;
name|maxactivefd
operator|=
name|newmax
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
name|lsock
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_addr_to_list
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|struct
name|interface
modifier|*
name|interface
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|find_addr_in_list
argument_list|(
name|addr
argument_list|)
operator|==
name|NULL
condition|)
block|{
endif|#
directive|endif
comment|/* not there yet - add to list */
name|remaddr_t
modifier|*
name|laddr
init|=
operator|(
name|remaddr_t
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|remaddr_t
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|laddr
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
argument_list|)
expr_stmt|;
name|laddr
operator|->
name|interface
operator|=
name|interface
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|remoteaddr_list
argument_list|,
name|laddr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Added addr %s to list of addresses\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"WARNING: Attempt to add duplicate addr %s to address list\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|delete_addr_from_list
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|next
decl_stmt|;
name|remaddr_t
modifier|*
name|laddr
init|=
name|ISC_LIST_HEAD
argument_list|(
name|remoteaddr_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|laddr
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|laddr
operator|->
name|addr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|ISC_LIST_DEQUEUE_TYPE
argument_list|(
name|remoteaddr_list
argument_list|,
name|laddr
argument_list|,
name|link
argument_list|,
name|remaddr_t
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Deleted addr %s from list of addresses\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
break|break;
block|}
name|laddr
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|delete_interface_from_list
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|next
decl_stmt|;
name|remaddr_t
modifier|*
name|laddr
init|=
name|ISC_LIST_HEAD
argument_list|(
name|remoteaddr_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|laddr
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|laddr
operator|->
name|interface
operator|==
name|iface
condition|)
block|{
name|ISC_LIST_DEQUEUE_TYPE
argument_list|(
name|remoteaddr_list
argument_list|,
name|laddr
argument_list|,
name|link
argument_list|,
name|remaddr_t
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Deleted addr %s for interface #%d %s from list of addresses\n"
operator|,
name|stoa
argument_list|(
operator|&
name|laddr
operator|->
name|addr
argument_list|)
operator|,
name|iface
operator|->
name|ifnum
operator|,
name|iface
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
block|}
name|laddr
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|interface
modifier|*
name|find_addr_in_list
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|next
decl_stmt|;
name|remaddr_t
modifier|*
name|laddr
init|=
name|ISC_LIST_HEAD
argument_list|(
name|remoteaddr_list
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Searching for addr %s in list of addresses - "
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|laddr
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|laddr
operator|->
name|addr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"FOUND\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|laddr
operator|->
name|interface
return|;
block|}
else|else
name|laddr
operator|=
name|next
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"NOT FOUND\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* Not found */
block|}
end_function

begin_comment
comment|/*  * Find the given address with the associated flag in the list  */
end_comment

begin_function
specifier|static
name|struct
name|interface
modifier|*
name|find_flagged_addr_in_list
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|next
decl_stmt|;
name|remaddr_t
modifier|*
name|laddr
init|=
name|ISC_LIST_HEAD
argument_list|(
name|remoteaddr_list
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Finding addr %s in list of addresses\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|laddr
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|laddr
operator|->
name|addr
argument_list|,
name|addr
argument_list|)
operator|&&
operator|(
name|laddr
operator|->
name|interface
operator|->
name|flags
operator|&
name|flag
operator|)
condition|)
block|{
return|return
name|laddr
operator|->
name|interface
return|;
break|break;
block|}
else|else
name|laddr
operator|=
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
comment|/* Not found */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_ROUTING_SOCKET
end_ifdef

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|UPDATE_GRACE
end_ifndef

begin_define
define|#
directive|define
name|UPDATE_GRACE
value|2
end_define

begin_comment
comment|/* wait UPDATE_GRACE seconds before scanning */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|process_routing_msgs
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
name|reader
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|5120
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buffer
decl_stmt|;
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|disable_dynamic_updates
condition|)
block|{
comment|/* 		 * discard ourselves if we are not need any more 		 * usually happens when running unprivileged 		 */
name|remove_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|delete_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
return|return;
block|}
name|cnt
operator|=
name|read
argument_list|(
name|reader
operator|->
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"i/o error on routing socket %m - disabling"
argument_list|)
expr_stmt|;
name|remove_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|delete_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * process routing message 	 */
while|while
condition|(
operator|(
name|p
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rt_msghdr
argument_list|)
operator|)
operator|<=
operator|(
name|buffer
operator|+
name|cnt
operator|)
condition|)
block|{
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
name|rtm
operator|=
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|rtm
operator|->
name|rtm_version
operator|!=
name|RTM_VERSION
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"version mismatch on routing socket %m - disabling"
argument_list|)
expr_stmt|;
name|remove_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|delete_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|rtm
operator|->
name|rtm_type
condition|)
block|{
ifdef|#
directive|ifdef
name|RTM_NEWADDR
case|case
name|RTM_NEWADDR
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_DELADDR
case|case
name|RTM_DELADDR
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_ADD
case|case
name|RTM_ADD
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_DELETE
case|case
name|RTM_DELETE
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_REDIRECT
case|case
name|RTM_REDIRECT
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_CHANGE
case|case
name|RTM_CHANGE
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_LOSING
case|case
name|RTM_LOSING
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_IFINFO
case|case
name|RTM_IFINFO
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_IFANNOUNCE
case|case
name|RTM_IFANNOUNCE
case|:
endif|#
directive|endif
comment|/* 			 * we are keen on new and deleted addresses and if an interface goes up and down or routing changes 			 */
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"routing message op = %d: scheduling interface update\n"
operator|,
name|rtm
operator|->
name|rtm_type
operator|)
argument_list|)
expr_stmt|;
name|timer_interfacetimeout
argument_list|(
name|current_time
operator|+
name|UPDATE_GRACE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 			 * the rest doesn't bother us. 			 */
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"routing message op = %d: ignored\n"
operator|,
name|rtm
operator|->
name|rtm_type
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|rtm
operator|->
name|rtm_msglen
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * set up routing notifications  */
end_comment

begin_function
specifier|static
name|void
name|init_async_notifications
parameter_list|()
block|{
name|struct
name|asyncio_reader
modifier|*
name|reader
decl_stmt|;
name|int
name|fd
init|=
name|socket
argument_list|(
name|PF_ROUTE
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|fd
operator|=
name|move_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|init_nonblocking_io
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
name|init_socket_sig
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGNALED_IO */
name|reader
operator|=
name|new_asyncio_reader
argument_list|()
expr_stmt|;
name|reader
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|reader
operator|->
name|receiver
operator|=
name|process_routing_msgs
expr_stmt|;
name|add_asyncio_reader
argument_list|(
name|reader
argument_list|,
name|FD_TYPE_SOCKET
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Listening on routing socket on fd #%d for interface updates"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to open routing socket (%m) - using polled interface update"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|init_async_notifications
parameter_list|()
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

