begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_io.c - input/output routines for ntpd.	The socket-opening code  *		   was shamelessly stolen from ntpd.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_PARAM_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_SYSTM_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Some old linux systems at least have in_system.h instead. */
end_comment

begin_include
include|#
directive|include
file|<netinet/in_system.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINET_IN_SYSTM_H */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKIO_H
end_ifdef

begin_comment
comment|/* UXPV: SIOC* #defines (Frank Vance<fvance@waii.com>) */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_if
if|#
directive|if
name|_BSDI_VERSION
operator|>=
literal|199510
end_if

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"iosignal.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_if.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_comment
comment|/* most likely UCX-specific */
end_comment

begin_include
include|#
directive|include
file|<UCX$INETDEF.H>
end_include

begin_comment
comment|/* "un*x"-compatible names for some items in UCX$INETDEF.H */
end_comment

begin_define
define|#
directive|define
name|ifreq
value|IFREQDEF
end_define

begin_define
define|#
directive|define
name|ifr_name
value|IFR$T_NAME
end_define

begin_define
define|#
directive|define
name|ifr_addr
value|IFR$R_DUMMY.IFR$T_ADDR
end_define

begin_define
define|#
directive|define
name|ifr_broadaddr
value|IFR$R_DUMMY.IFR$T_BROADADDR
end_define

begin_define
define|#
directive|define
name|ifr_flags
value|IFR$R_DUMMY.IFR$R_DUMMY_1_OVRL.IFR$W_FLAGS
end_define

begin_define
define|#
directive|define
name|IFF_UP
value|IFR$M_IFF_UP
end_define

begin_define
define|#
directive|define
name|IFF_BROADCAST
value|IFR$M_IFF_BROADCAST
end_define

begin_define
define|#
directive|define
name|IFF_LOOPBACK
value|IFR$M_IFF_LOOPBACK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_comment
comment|/* structure used in SIOCGIFCONF request (after [KSR] OSF/1) */
end_comment

begin_struct
struct|struct
name|ifconf
block|{
name|int
name|ifc_len
decl_stmt|;
comment|/* size of buffer */
union|union
block|{
name|caddr_t
name|ifcu_buf
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifcu_req
decl_stmt|;
block|}
name|ifc_ifcu
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ifc_buf
value|ifc_ifcu.ifcu_buf
end_define

begin_comment
comment|/* buffer address */
end_comment

begin_define
define|#
directive|define
name|ifc_req
value|ifc_ifcu.ifcu_req
end_define

begin_comment
comment|/* array of structures returned */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_TTY_SIGPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_UDP_SIGPOLL
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_AIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|_IO
argument_list|)
end_if

begin_comment
comment|/* XXX Identify AIX some other way */
end_comment

begin_undef
undef|#
directive|undef
name|_IO
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We do asynchronous input using the SIGIO facility.  A number of  * recvbuf buffers are preallocated for input.	In the signal  * handler we poll to see which sockets are ready and read the  * packets from them into the recvbuf's along with a time stamp and  * an indication of the source host and the interface it was received  * through.  This allows us to get as accurate receive time stamps  * as possible independent of other processing going on.  *  * We watch the number of recvbufs available to the signal handler  * and allocate more when this number drops below the low water  * mark.  If the signal handler should run out of buffers in the  * interim it will drop incoming frames, the idea being that it is  * better to drop a packet than to be inaccurate.  */
end_comment

begin_comment
comment|/*  * Other statistics of possible interest  */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_dropped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets dropped on reception */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_ignored
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets received on wild card interface */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_received
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets received */
end_comment

begin_decl_stmt
name|u_long
name|packets_sent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets sent */
end_comment

begin_decl_stmt
name|u_long
name|packets_notsent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets which couldn't be sent */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|handler_calls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of calls to interrupt handler */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|handler_pkts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pkts received by handler */
end_comment

begin_decl_stmt
name|u_long
name|io_timereset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time counters were reset */
end_comment

begin_comment
comment|/*  * Interface stuff  */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to default interface */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|loopback_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point to loopback interface */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|interface
name|inter_list
index|[
name|MAXINTERFACES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ninterfaces
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * Refclock stuff.	We keep a chain of structures with data concerning  * the guys we are doing I/O for.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|refclockio
modifier|*
name|refio
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_comment
comment|/*  * File descriptor masks etc. for call to select  */
end_comment

begin_decl_stmt
name|fd_set
name|activefds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxactivefd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|create_sockets
name|P
argument_list|(
operator|(
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|open_socket
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_socket
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_file
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fdbits
name|P
argument_list|(
operator|(
name|int
operator|,
name|fd_set
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * init_io - initialize I/O data structures and call socket creation routine  */
end_comment

begin_function
name|void
name|init_io
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYS_WINNT
name|WORD
name|wVersionRequested
decl_stmt|;
name|WSADATA
name|wsaData
decl_stmt|;
name|init_transmitbuff
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Init buffer free list and stat counters 	 */
name|init_recvbuff
argument_list|(
name|RECV_INIT
argument_list|)
expr_stmt|;
name|packets_dropped
operator|=
name|packets_received
operator|=
literal|0
expr_stmt|;
name|packets_ignored
operator|=
literal|0
expr_stmt|;
name|packets_sent
operator|=
name|packets_notsent
operator|=
literal|0
expr_stmt|;
name|handler_calls
operator|=
name|handler_pkts
operator|=
literal|0
expr_stmt|;
name|io_timereset
operator|=
literal|0
expr_stmt|;
name|loopback_interface
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
name|refio
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
operator|(
name|void
operator|)
name|set_signal
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_WINNT
name|wVersionRequested
operator|=
name|MAKEWORD
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No useable winsock.dll: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Create the sockets 	 */
name|BLOCKIO
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|create_sockets
argument_list|(
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"init_io: maxactivefd %d\n"
argument_list|,
name|maxactivefd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * create_sockets - create a socket for each interface plus a default  *			socket for when we don't know where to send  */
end_comment

begin_function
specifier|static
name|int
name|create_sockets
parameter_list|(
name|u_int
name|port
parameter_list|)
block|{
if|#
directive|if
name|_BSDI_VERSION
operator|>=
literal|199510
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|ifaddrs
modifier|*
name|ifaddrs
decl_stmt|,
modifier|*
name|ifap
decl_stmt|;
name|struct
name|sockaddr_in
name|resmask
decl_stmt|;
if|#
directive|if
name|_BSDI_VERSION
operator|<
literal|199701
name|struct
name|ifaddrs
modifier|*
name|lp
decl_stmt|;
name|int
name|num_if
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* _BSDI_VERSION>= 199510 */
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|struct
name|strioctl
name|ioc
decl_stmt|;
endif|#
directive|endif
comment|/* STREAMS_TLI */
name|char
name|buf
index|[
name|MAXINTERFACES
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
index|]
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
name|ifreq
decl_stmt|,
modifier|*
name|ifr
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|vs
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in
name|resmask
decl_stmt|;
endif|#
directive|endif
comment|/* _BSDI_VERSION>= 199510 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"create_sockets(%d)\n"
argument_list|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * create pseudo-interface with wildcard address 	 */
name|inter_list
index|[
literal|0
index|]
operator|.
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|inter_list
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
literal|"wildcard"
argument_list|,
sizeof|sizeof
argument_list|(
name|inter_list
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|mask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|~
operator|(
name|u_int32
operator|)
literal|0
argument_list|)
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|received
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|sent
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|notsent
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|flags
operator|=
name|INT_BROADCAST
expr_stmt|;
if|#
directive|if
name|_BSDI_VERSION
operator|>=
literal|199510
if|#
directive|if
name|_BSDI_VERSION
operator|>=
literal|199701
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifaddrs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getifaddrs: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ifap
operator|=
name|ifaddrs
init|;
name|ifap
operator|!=
name|NULL
condition|;
name|ifap
operator|=
name|ifap
operator|->
name|ifa_next
control|)
else|#
directive|else
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifaddrs
argument_list|,
operator|&
name|num_if
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: getifaddrs() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ifap
operator|=
name|ifaddrs
operator|,
name|lp
operator|=
name|ifap
operator|+
name|num_if
init|;
name|ifap
operator|<
name|lp
condition|;
name|ifap
operator|++
control|)
endif|#
directive|endif
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
if|if
condition|(
operator|!
name|ifap
operator|->
name|ifa_addr
condition|)
continue|continue;
if|if
condition|(
name|ifap
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifap
operator|->
name|ifa_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ifap
operator|->
name|ifa_flags
operator|&
name|IFF_LOOPBACK
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifap
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|!=
literal|0x7f000001
condition|)
block|{
continue|continue;
block|}
block|}
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifap
operator|->
name|ifa_flags
operator|&
name|IFF_BROADCAST
condition|)
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_BROADCAST
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|ifap
operator|->
name|ifa_name
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifap
operator|->
name|ifa_addr
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|=
operator|*
name|sin
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
if|if
condition|(
name|ifap
operator|->
name|ifa_flags
operator|&
name|IFF_LOOPBACK
condition|)
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|INT_LOOPBACK
expr_stmt|;
if|if
condition|(
name|loopback_interface
operator|==
name|NULL
operator|||
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|!=
literal|0x7f000001
condition|)
name|loopback_interface
operator|=
operator|&
name|inter_list
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifap
operator|->
name|ifa_broadaddr
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|=
operator|*
name|sin
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
block|}
if|if
condition|(
name|ifap
operator|->
name|ifa_flags
operator|&
operator|(
name|IFF_LOOPBACK
operator||
name|IFF_POINTOPOINT
operator|)
condition|)
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifap
operator|->
name|ifa_netmask
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|=
operator|*
name|sin
expr_stmt|;
block|}
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|.
name|sin_len
operator|=
sizeof|sizeof
expr|*
name|sin
expr_stmt|;
comment|/* 		 * look for an already existing source interface address.  If 		 * the machine has multiple point to point interfaces, then 		 * the local address may appear more than once. 		 * 		 * A second problem exists if we have two addresses on 		 * the same network (via "ifconfig alias ...").  Don't 		 * make two xntp interfaces for the two aliases on the 		 * one physical interface. -wsr 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|inter_list
index|[
name|j
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|&
name|inter_list
index|[
name|j
index|]
operator|.
name|mask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|inter_list
index|[
name|j
index|]
operator|.
name|flags
operator|&
name|INT_LOOPBACK
condition|)
name|inter_list
index|[
name|j
index|]
operator|=
name|inter_list
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|i
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|MAXINTERFACES
condition|)
break|break;
block|}
name|free
argument_list|(
name|ifaddrs
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _BSDI_VERSION>= 199510 */
ifdef|#
directive|ifdef
name|USE_STREAMS_DEVICE_FOR_IF_CONFIG
if|if
condition|(
operator|(
name|vs
operator|=
name|open
argument_list|(
literal|"/dev/ip"
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: open(/dev/ip) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not USE_STREAMS_DEVICE_FOR_IF_CONFIG */
if|if
condition|(
operator|(
name|vs
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|<
literal|0
else|#
directive|else
comment|/* SYS_WINNT */
operator|==
name|INVALID_SOCKET
endif|#
directive|endif
comment|/* SYS_WINNT */
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: socket(AF_INET, SOCK_DGRAM) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not USE_STREAMS_DEVICE_FOR_IF_CONFIG */
name|i
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|ioc
operator|.
name|ic_cmd
operator|=
name|SIOCGIFCONF
expr_stmt|;
name|ioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|ioc
operator|.
name|ic_dp
operator|=
operator|(
name|caddr_t
operator|)
name|buf
expr_stmt|;
name|ioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|I_STR
argument_list|,
operator|&
name|ioc
argument_list|)
operator|<
literal|0
operator|||
name|ioc
operator|.
name|ic_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: ioctl(I_STR:SIOCGIFCONF) failed: %m - exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIZE_RETURNED_IN_BUFFER
name|ifc
operator|.
name|ifc_len
operator|=
name|ioc
operator|.
name|ic_len
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not SIZE_RETURNED_IN_BUFFER */
name|ifc
operator|.
name|ifc_len
operator|=
name|ioc
operator|.
name|ic_len
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
endif|#
directive|endif
comment|/* not SIZE_RETURNED_IN_BUFFER */
else|#
directive|else
comment|/* not STREAMS_TLI */
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|WSAIoctl
argument_list|(
name|vs
argument_list|,
name|SIO_GET_INTERFACE_LIST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ifc
operator|.
name|ifc_buf
argument_list|,
name|ifc
operator|.
name|ifc_len
argument_list|,
operator|&
name|ifc
operator|.
name|ifc_len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|SOCKET_ERROR
condition|)
endif|#
directive|endif
comment|/* SYS_WINNT */
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: ioctl(SIOCGIFCONF) failed: %m - exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not STREAMS_TLI */
for|for
control|(
name|n
operator|=
name|ifc
operator|.
name|ifc_len
operator|,
name|ifr
operator|=
name|ifc
operator|.
name|ifc_req
init|;
name|n
operator|>
literal|0
condition|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ifr
operator|+
name|size
operator|)
control|)
block|{
specifier|extern
name|int
name|listen_to_virtual_ips
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ifr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN_IN_STRUCT_SOCKADDR
if|if
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_addr
argument_list|)
condition|)
name|size
operator|+=
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|-=
name|size
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
comment|/* Exclude logical interfaces (indicated by ':' in the interface name)	*/
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"interface<%s> "
argument_list|,
name|ifr
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|listen_to_virtual_ips
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|,
operator|(
name|int
operator|)
literal|':'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ignored\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"OK\n"
argument_list|)
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|VMS
comment|/* VMS+UCX */
operator|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|->
name|ifr_addr
operator|)
operator|)
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|)
else|#
directive|else
operator|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
operator|)
endif|#
directive|endif
comment|/* VMS+UCX */
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ignoring %s - not AF_INET\n"
argument_list|,
name|ifr
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
name|memcpy
argument_list|(
operator|&
name|ifreq
argument_list|,
name|ifr
argument_list|,
sizeof|sizeof
argument_list|(
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* is it broadcast capable? */
ifndef|#
directive|ifndef
name|SYS_WINNT
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|ioc
operator|.
name|ic_cmd
operator|=
name|SIOCGIFFLAGS
expr_stmt|;
name|ioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|ioc
operator|.
name|ic_dp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ifreq
expr_stmt|;
name|ioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|I_STR
argument_list|,
operator|&
name|ioc
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: ioctl(I_STR:SIOCGIFFLAGS) failed: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
comment|/* not STREAMS_TLI */
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENXIO
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: ioctl(SIOCGIFFLAGS) failed: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* not STREAMS_TLI */
if|if
condition|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ignoring %s - interface not UP\n"
argument_list|,
name|ifr
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_BROADCAST
condition|)
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_BROADCAST
expr_stmt|;
endif|#
directive|endif
comment|/* not SYS_WINNT */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SUN_3_3_STINKS
argument_list|)
if|if
condition|(
if|#
directive|if
name|defined
argument_list|(
name|IFF_LOCAL_LOOPBACK
argument_list|)
comment|/* defined(SYS_HPUX)&& (SYS_HPUX< 8) */
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_LOCAL_LOOPBACK
operator|)
elif|#
directive|elif
name|defined
argument_list|(
name|IFF_LOOPBACK
argument_list|)
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_LOOPBACK
operator|)
else|#
directive|else
comment|/* not IFF_LOCAL_LOOPBACK and not IFF_LOOPBACK */
comment|/* test against 127.0.0.1 (yuck!!) */
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|inet_addr
argument_list|(
literal|"127.0.0.1"
argument_list|)
operator|)
endif|#
directive|endif
comment|/* not IFF_LOCAL_LOOPBACK and not IFF_LOOPBACK */
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_LOOPBACK
expr_stmt|;
endif|#
directive|endif
comment|/* not SYS_WINNT */
if|if
condition|(
name|loopback_interface
operator|==
literal|0
condition|)
block|{
name|loopback_interface
operator|=
operator|&
name|inter_list
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not SUN_3_3_STINKS */
if|#
directive|if
literal|0
ifndef|#
directive|ifndef
name|SYS_WINNT
ifdef|#
directive|ifdef
name|STREAMS_TLI
block|ioc.ic_cmd = SIOCGIFADDR; 		ioc.ic_timout = 0; 		ioc.ic_dp = (caddr_t)&ifreq; 		ioc.ic_len = sizeof(struct ifreq); 		if (ioctl(vs, I_STR,&ioc)) 		{ 			msyslog(LOG_ERR, "create_sockets: ioctl(I_STR:SIOCGIFADDR) failed: %m"); 			continue; 		}
else|#
directive|else
comment|/* not STREAMS_TLI */
block|if (ioctl(vs, SIOCGIFADDR, (char *)&ifreq)< 0) 		{ 			if (errno != ENXIO) 			    msyslog(LOG_ERR, "create_sockets: ioctl(SIOCGIFADDR) failed: %m"); 			continue; 		}
endif|#
directive|endif
comment|/* not STREAMS_TLI */
endif|#
directive|endif
comment|/* not SYS_WINNT */
endif|#
directive|endif
comment|/* 0 */
if|#
directive|if
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
block|{
name|int
name|TODO_FillInTheNameWithSomeThingReasonble
decl_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_addr
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SUN_3_3_STINKS
argument_list|)
comment|/* 		 * Oh, barf!  I'm too disgusted to even explain this 		 */
if|if
condition|(
name|SRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
operator|==
literal|0x7f000001
condition|)
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_LOOPBACK
expr_stmt|;
if|if
condition|(
name|loopback_interface
operator|==
literal|0
condition|)
name|loopback_interface
operator|=
operator|&
name|inter_list
index|[
name|i
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SUN_3_3_STINKS */
if|#
directive|if
operator|!
name|defined
name|SYS_WINNT
operator|&&
operator|!
name|defined
name|SYS_CYGWIN32
comment|/* no interface flags on NT */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
condition|)
block|{
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|ioc
operator|.
name|ic_cmd
operator|=
name|SIOCGIFBRDADDR
expr_stmt|;
name|ioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|ioc
operator|.
name|ic_dp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ifreq
expr_stmt|;
name|ioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|I_STR
argument_list|,
operator|&
name|ioc
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: ioctl(I_STR:SIOCGIFBRDADDR) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not STREAMS_TLI */
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFBRDADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: ioctl(SIOCGIFBRDADDR) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not STREAMS_TLI */
ifndef|#
directive|ifndef
name|ifr_broadaddr
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
expr_stmt|;
else|#
directive|else
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_broadaddr
expr_stmt|;
endif|#
directive|endif
comment|/* ifr_broadaddr */
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|ioc
operator|.
name|ic_cmd
operator|=
name|SIOCGIFNETMASK
expr_stmt|;
name|ioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|ioc
operator|.
name|ic_dp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ifreq
expr_stmt|;
name|ioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|I_STR
argument_list|,
operator|&
name|ioc
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: ioctl(I_STR:SIOCGIFNETMASK) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not STREAMS_TLI */
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: ioctl(SIOCGIFNETMASK) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not STREAMS_TLI */
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
expr_stmt|;
else|#
directive|else
comment|/* winnt here */
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|=
name|ifreq
operator|.
name|ifr_broadaddr
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|=
name|ifreq
operator|.
name|ifr_mask
expr_stmt|;
endif|#
directive|endif
comment|/* not SYS_WINNT */
comment|/* 		 * look for an already existing source interface address.  If 		 * the machine has multiple point to point interfaces, then 		 * the local address may appear more than once. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|inter_list
index|[
name|j
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|i
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|MAXINTERFACES
condition|)
break|break;
block|}
name|closesocket
argument_list|(
name|vs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _BSDI_VERSION>= 199510 */
name|ninterfaces
operator|=
name|i
expr_stmt|;
name|maxactivefd
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|activefds
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now that we have opened all the sockets, turn off the reuse flag for 	 * security. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
comment|/* 		 * if inter_list[ n ].fd  is -1, we might have a adapter 		 * configured but not present 		 */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_sockets: setsockopt(SO_REUSEADDR,off) failed: %m"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|MCAST
argument_list|)
comment|/* 	 * enable possible multicast reception on the broadcast socket 	 */
name|inter_list
index|[
literal|0
index|]
operator|.
name|bcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|bcast
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|bcast
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
endif|#
directive|endif
comment|/* MCAST */
comment|/* 	 * Blacklist all bound interface addresses 	 */
name|resmask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|~
operator|(
name|u_int32
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|,
operator|&
name|resmask
argument_list|,
name|RESM_NTPONLY
operator||
name|RESM_INTERFACE
argument_list|,
name|RES_IGNORE
argument_list|)
expr_stmt|;
name|any_interface
operator|=
operator|&
name|inter_list
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"create_sockets: ninterfaces=%d\n"
argument_list|,
name|ninterfaces
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"interface %d:  fd=%d,  bfd=%d,  name=%.8s,  flags=0x%x\n"
argument_list|,
name|i
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
comment|/* Leave these as three printf calls. */
name|printf
argument_list|(
literal|"              sin=%s"
argument_list|,
name|inet_ntoa
argument_list|(
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
condition|)
name|printf
argument_list|(
literal|"  bcast=%s,"
argument_list|,
name|inet_ntoa
argument_list|(
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_addr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  mask=%s\n"
argument_list|,
name|inet_ntoa
argument_list|(
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|.
name|sin_addr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
name|io_completion_port_add_socket
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|ninterfaces
return|;
block|}
end_function

begin_comment
comment|/*  * io_setbclient - open the broadcast client sockets  */
end_comment

begin_function
name|void
name|io_setbclient
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
operator|)
condition|)
continue|continue;
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BCASTOPEN
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|SYS_SOLARIS
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPEN_BCAST_SOCKET
comment|/* Was: !SYS_DOMAINOS&& !SYS_LINUX */
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
name|open_socket
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
argument_list|,
name|INT_BROADCAST
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_BCASTOPEN
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * io_multicast_add() - add multicast group address  */
end_comment

begin_function
name|void
name|io_multicast_add
parameter_list|(
name|u_int32
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCAST
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
name|int
name|i
init|=
name|ninterfaces
decl_stmt|;
comment|/* Use the next interface */
name|u_int32
name|haddr
init|=
name|ntohl
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|struct
name|in_addr
name|iaddr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sinp
decl_stmt|;
name|iaddr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
operator|!
name|IN_CLASSD
argument_list|(
name|haddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot add multicast address %s as it is not class D"
argument_list|,
name|inet_ntoa
argument_list|(
name|iaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* Already have this address */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|addr
condition|)
return|return;
comment|/* found a free slot */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|<=
literal|0
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|<=
literal|0
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|==
literal|0
condition|)
break|break;
block|}
name|sinp
operator|=
operator|&
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|inter_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sinp
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sinp
operator|->
name|sin_addr
operator|=
name|iaddr
expr_stmt|;
name|sinp
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
literal|123
argument_list|)
expr_stmt|;
name|s
operator|=
name|open_socket
argument_list|(
name|sinp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Try opening a socket for the specified class D address */
comment|/* This works under SunOS 4.x, but not OSF1 .. :-( */
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|inter_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* HACK ! -- stuff in an address */
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"...multicast address %s using wildcard socket"
argument_list|,
name|inet_ntoa
argument_list|(
name|iaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|s
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"multicast"
argument_list|,
sizeof|sizeof
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|~
operator|(
name|u_int32
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * enable reception of multicast packets 	 */
name|mreq
operator|.
name|imr_multiaddr
operator|=
name|iaddr
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_ADD_MEMBERSHIP fails: %m for %x / %x (%s)"
argument_list|,
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
argument_list|,
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
argument_list|,
name|inet_ntoa
argument_list|(
name|iaddr
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_MULTICAST
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|ninterfaces
condition|)
name|ninterfaces
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|#
directive|else
comment|/* MCAST */
name|struct
name|in_addr
name|iaddr
decl_stmt|;
name|iaddr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot add multicast address %s as no MCAST support"
argument_list|,
name|inet_ntoa
argument_list|(
name|iaddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MCAST */
block|}
end_function

begin_comment
comment|/*  * io_unsetbclient - close the broadcast client sockets  */
end_comment

begin_function
name|void
name|io_unsetbclient
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BCASTOPEN
operator|)
condition|)
continue|continue;
name|close_socket
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
operator|-
literal|1
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&=
operator|~
name|INT_BCASTOPEN
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * io_multicast_del() - delete multicast group address  */
end_comment

begin_function
name|void
name|io_multicast_del
parameter_list|(
name|u_int32
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCAST
name|int
name|i
decl_stmt|;
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
name|u_int32
name|haddr
init|=
name|ntohl
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_in
name|sinaddr
decl_stmt|;
if|if
condition|(
operator|!
name|IN_CLASSD
argument_list|(
name|haddr
argument_list|)
condition|)
block|{
name|sinaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid multicast address %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|sinaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Disable reception of multicast packets 	 */
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_MULTICAST
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|<
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|!=
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
continue|continue;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* we have an explicit fd, so we can close it */
name|close_socket
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|inter_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We are sharing "any address" port :-(  Don't close it! */
if|if
condition|(
name|setsockopt
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DROP_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_DROP_MEMBERSHIP fails: %m"
argument_list|)
expr_stmt|;
comment|/* This is **WRONG** -- there may be others ! */
comment|/* There should be a count of users ... */
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&=
operator|~
name|INT_MULTICAST
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* not MCAST */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"this function requires multicast kernel"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not MCAST */
block|}
end_function

begin_comment
comment|/*  * open_socket - open a socket, returning the file descriptor  */
end_comment

begin_function
specifier|static
name|int
name|open_socket
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|turn_off_reuse
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|tos
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|,
name|off
init|=
literal|0
decl_stmt|;
comment|/* create a datagram (UDP) socket */
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|<
literal|0
else|#
directive|else
operator|==
name|INVALID_SOCKET
endif|#
directive|endif
comment|/* SYS_WINNT */
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket(AF_INET, SOCK_DGRAM, 0) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* set SO_REUSEADDR since we will be binding the same port 	   number on each interface */
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt SO_REUSEADDR on fails: %m"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|IPTOS_LOWDELAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPPROTO_IP
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_TOS
argument_list|)
comment|/* set IP_TOS to minimize packet delay */
name|tos
operator|=
name|IPTOS_LOWDELAY
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_TOS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tos
argument_list|,
sizeof|sizeof
argument_list|(
name|tos
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPTOS_LOWDELAY on fails: %m"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPTOS_LOWDELAY&& IPPROTO_IP&& IP_TOS */
comment|/* 	 * bind the local address. 	 */
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|buff
index|[
literal|160
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"bind() fd %d, family %d, port %d, addr %s, in_classd=%d flags=%d fails: %%m"
argument_list|,
name|fd
argument_list|,
name|addr
operator|->
name|sin_family
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|addr
operator|->
name|sin_port
argument_list|)
argument_list|,
name|ntoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 		 * soft fail if opening a class D address 		 */
if|if
condition|(
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
literal|0
block|exit(1);
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bind() fd %d, family %d, port %d, addr %s, flags=%d\n"
argument_list|,
name|fd
argument_list|,
name|addr
operator|->
name|sin_family
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|addr
operator|->
name|sin_port
argument_list|)
argument_list|,
name|ntoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|>
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
comment|/* 	 * set non-blocking, 	 */
ifdef|#
directive|ifdef
name|USE_FIONBIO
comment|/* in vxWorks we use FIONBIO, but the others are defined for old systems, so 	 * all hell breaks loose if we leave them defined 	 */
undef|#
directive|undef
name|O_NONBLOCK
undef|#
directive|undef
name|FNDELAY
undef|#
directive|undef
name|O_NDELAY
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
comment|/* POSIX */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NONBLOCK) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
comment|/* generally the same as FNDELAY */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NDELAY) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIONBIO
argument_list|)
if|if
condition|(
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
literal|1
argument_list|)
operator|<
literal|0
operator|)
elif|#
directive|elif
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|(
name|ioctlsocket
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
name|SOCKET_ERROR
operator|)
else|#
directive|else
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
operator|)
endif|#
directive|endif
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIONBIO) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIOSNBIO
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOSNBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSNBIO) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
include|#
directive|include
file|"Bletch: Need non-blocking I/O!"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
name|init_socket_sig
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGNALED_IO */
comment|/* 	 *	Turn off the SO_REUSEADDR socket option.  It apparently 	 *	causes heartburn on systems with multicast IP installed. 	 *	On normal systems it only gets looked at when the address 	 *	is being bound anyway.. 	 */
if|if
condition|(
name|turn_off_reuse
condition|)
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt SO_REUSEADDR off fails: %m"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SO_BROADCAST
comment|/* if this interface can support broadcast, set SO_BROADCAST */
if|if
condition|(
name|flags
operator|&
name|INT_BROADCAST
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(SO_BROADCAST): %m"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SO_BROADCAST */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"flags for fd %d: 0%o\n"
argument_list|,
name|fd
argument_list|,
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SYS_WINNT || VMS */
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  * close_socket - close a socket and remove from the activefd list  */
end_comment

begin_function
specifier|static
name|void
name|close_socket
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|newmax
decl_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
operator|(
name|u_int
operator|)
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|maxactivefd
condition|)
block|{
name|newmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxactivefd
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|activefds
argument_list|)
condition|)
name|newmax
operator|=
name|i
expr_stmt|;
name|maxactivefd
operator|=
name|newmax
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * close_file - close a file and remove from the activefd list  * added 1/31/1997 Greg Schueman for Windows NT portability  */
end_comment

begin_function
specifier|static
name|void
name|close_file
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|newmax
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
operator|(
name|u_int
operator|)
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|maxactivefd
condition|)
block|{
name|newmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxactivefd
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|activefds
argument_list|)
condition|)
name|newmax
operator|=
name|i
expr_stmt|;
name|maxactivefd
operator|=
name|newmax
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * findbcastinter - find broadcast interface corresponding to address  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|findbcastinter
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SIOCGIFCONF
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_int32
name|netnum
decl_stmt|;
name|netnum
operator|=
name|NSRCADR
argument_list|(
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
operator|)
condition|)
continue|continue;
if|if
condition|(
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
argument_list|)
operator|==
name|netnum
condition|)
return|return
operator|&
name|inter_list
index|[
name|i
index|]
return|;
if|if
condition|(
operator|(
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
operator|&
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
argument_list|)
operator|)
operator|==
operator|(
name|netnum
operator|&
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
argument_list|)
operator|)
condition|)
return|return
operator|&
name|inter_list
index|[
name|i
index|]
return|;
block|}
endif|#
directive|endif
comment|/* SIOCGIFCONF */
return|return
name|any_interface
return|;
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE sendpkt similar in ntpq.c, ntpdc.c, ntp_io.c, ntptrace.c */
end_comment

begin_comment
comment|/*  * sendpkt - send a packet to the specified destination. Maintain a  * send error cache so that only the first consecutive error for a  * destination is logged.  */
end_comment

begin_function
name|void
name|sendpkt
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|dest
parameter_list|,
name|struct
name|interface
modifier|*
name|inter
parameter_list|,
name|int
name|ttl
parameter_list|,
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cc
decl_stmt|,
name|slot
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|DWORD
name|err
decl_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Send error cache. Empty slots have port == 0 	 * Set ERRORCACHESIZE to 0 to disable 	 */
struct|struct
name|cache
block|{
name|u_short
name|port
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
block|}
struct|;
ifndef|#
directive|ifndef
name|ERRORCACHESIZE
define|#
directive|define
name|ERRORCACHESIZE
value|8
endif|#
directive|endif
if|#
directive|if
name|ERRORCACHESIZE
operator|>
literal|0
specifier|static
name|struct
name|cache
name|badaddrs
index|[
name|ERRORCACHESIZE
index|]
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|badaddrs
value|((struct cache *)0)
comment|/* Only used in empty loops! */
endif|#
directive|endif
comment|/* 	 * check if the source address is a multicast address - replace 	 * interface with any-interface if so. 	 */
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|inter
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
name|inter
operator|=
name|any_interface
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%ssendpkt(fd=%d dst=%s, src=%s, ttl=%d, len=%d)\n"
argument_list|,
operator|(
name|ttl
operator|>=
literal|0
operator|)
condition|?
literal|"\tMCAST\t*****"
else|:
literal|""
argument_list|,
name|inter
operator|->
name|fd
argument_list|,
name|ntoa
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|inter
operator|->
name|sin
argument_list|)
argument_list|,
name|ttl
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MCAST
comment|/* for the moment we use the bcast option to set multicast ttl */
if|if
condition|(
name|ttl
operator|>=
literal|0
operator|&&
name|ttl
operator|!=
name|inter
operator|->
name|last_ttl
condition|)
block|{
name|char
name|mttl
init|=
name|ttl
decl_stmt|;
comment|/* set the multicast ttl for outgoing packets */
if|if
condition|(
name|setsockopt
argument_list|(
name|inter
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_TTL
argument_list|,
operator|&
name|mttl
argument_list|,
sizeof|sizeof
argument_list|(
name|mttl
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_TTL fails: %m"
argument_list|)
expr_stmt|;
block|}
else|else
name|inter
operator|->
name|last_ttl
operator|=
name|ttl
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MCAST */
for|for
control|(
name|slot
operator|=
name|ERRORCACHESIZE
init|;
operator|--
name|slot
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|==
name|dest
operator|->
name|sin_port
operator|&&
name|badaddrs
index|[
name|slot
index|]
operator|.
name|addr
operator|.
name|s_addr
operator|==
name|dest
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
break|break;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
name|err
operator|=
name|io_completion_port_sendto
argument_list|(
name|inter
argument_list|,
name|pkt
argument_list|,
name|len
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ERROR_SUCCESS
condition|)
else|#
directive|else
name|cc
operator|=
name|sendto
argument_list|(
name|inter
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|inter
operator|->
name|notsent
operator|++
expr_stmt|;
name|packets_notsent
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
if|if
condition|(
name|err
operator|!=
name|WSAEWOULDBLOCK
operator|&&
name|err
operator|!=
name|WSAENOBUFS
operator|&&
name|slot
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENOBUFS
operator|&&
name|slot
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
comment|/* 			 * Remember this, if there's an empty slot 			 */
for|for
control|(
name|slot
operator|=
name|ERRORCACHESIZE
init|;
operator|--
name|slot
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|==
literal|0
condition|)
block|{
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|=
name|dest
operator|->
name|sin_port
expr_stmt|;
name|badaddrs
index|[
name|slot
index|]
operator|.
name|addr
operator|=
name|dest
operator|->
name|sin_addr
expr_stmt|;
break|break;
block|}
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto(%s): %m"
argument_list|,
name|ntoa
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inter
operator|->
name|sent
operator|++
expr_stmt|;
name|packets_sent
operator|++
expr_stmt|;
comment|/* 		 * He's not bad any more 		 */
if|if
condition|(
name|slot
operator|>=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Connection re-established to %s"
argument_list|,
name|ntoa
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
end_if

begin_comment
comment|/*  * fdbits - generate ascii representation of fd_set (FAU debug support)  * HFDF format - highest fd first.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fdbits
parameter_list|(
name|int
name|count
parameter_list|,
name|fd_set
modifier|*
name|set
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|buffer
decl_stmt|;
name|count
operator|=
operator|(
name|count
operator|<
literal|256
operator|)
condition|?
name|count
else|:
literal|255
expr_stmt|;
while|while
condition|(
name|count
operator|>=
literal|0
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|FD_ISSET
argument_list|(
name|count
argument_list|,
name|set
argument_list|)
condition|?
literal|'#'
else|:
literal|'-'
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*  * input_handler - receive packets asynchronously  */
end_comment

begin_function
specifier|extern
name|void
name|input_handler
parameter_list|(
name|l_fp
modifier|*
name|cts
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
specifier|register
name|int
name|doing
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|struct
name|timeval
name|tvzero
decl_stmt|;
name|int
name|fromlen
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
comment|/* Timestamp at BOselect() gob */
name|l_fp
name|ts_e
decl_stmt|;
comment|/* Timestamp at EOselect() gob */
name|fd_set
name|fds
decl_stmt|;
name|int
name|select_count
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|handler_count
init|=
literal|0
decl_stmt|;
operator|++
name|handler_count
expr_stmt|;
if|if
condition|(
name|handler_count
operator|!=
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"input_handler: handler_count is %d!"
argument_list|,
name|handler_count
argument_list|)
expr_stmt|;
name|handler_calls
operator|++
expr_stmt|;
name|ts
operator|=
operator|*
name|cts
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Do a poll to see who has data 		 */
name|fds
operator|=
name|activefds
expr_stmt|;
name|tvzero
operator|.
name|tv_sec
operator|=
name|tvzero
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If we have something to do, freeze a timestamp. 		 * See below for the other cases (nothing (left) to do or error) 		 */
while|while
condition|(
literal|0
operator|<
operator|(
name|n
operator|=
name|select
argument_list|(
name|maxactivefd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvzero
argument_list|)
operator|)
condition|)
block|{
operator|++
name|select_count
expr_stmt|;
operator|++
name|handler_pkts
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 			 * Check out the reference clocks first, if any 			 */
if|if
condition|(
name|refio
operator|!=
literal|0
condition|)
block|{
specifier|register
name|struct
name|refclockio
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|refio
init|;
name|rp
operator|!=
literal|0
operator|&&
name|n
operator|>
literal|0
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
name|fd
operator|=
name|rp
operator|->
name|fd
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|free_recvbuffs
argument_list|()
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|packets_dropped
operator|++
expr_stmt|;
goto|goto
name|select_again
goto|;
block|}
name|rb
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
name|i
operator|=
operator|(
name|rp
operator|->
name|datalen
operator|==
literal|0
operator|||
name|rp
operator|->
name|datalen
operator|>
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
else|:
name|rp
operator|->
name|datalen
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"clock read fd %d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
goto|goto
name|select_again
goto|;
block|}
comment|/* 						 * Got one.  Mark how and when it got here, 						 * put it on the full list and do bookkeeping. 						 */
name|rb
operator|->
name|recv_srcclock
operator|=
name|rp
operator|->
name|srcclock
expr_stmt|;
name|rb
operator|->
name|dstadr
operator|=
literal|0
expr_stmt|;
name|rb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|receiver
operator|=
name|rp
operator|->
name|clock_recv
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|io_input
condition|)
block|{
comment|/* 							 * have direct input routine for refclocks 							 */
if|if
condition|(
name|rp
operator|->
name|io_input
argument_list|(
name|rb
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 								 * data was consumed - nothing to pass up 								 * into block input machine 								 */
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
goto|goto
name|select_again
goto|;
else|#
directive|else
continue|continue;
endif|#
directive|endif
block|}
block|}
name|add_full_recv_buffer
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|rp
operator|->
name|recvcount
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
comment|/* 			 * Loop through the interfaces looking for data to read. 			 */
for|for
control|(
name|i
operator|=
name|ninterfaces
operator|-
literal|1
init|;
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|n
operator|>
literal|0
operator|)
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|doing
operator|=
literal|0
init|;
operator|(
name|doing
operator|<
literal|2
operator|)
operator|&&
operator|(
name|n
operator|>
literal|0
operator|)
condition|;
name|doing
operator|++
control|)
block|{
if|if
condition|(
name|doing
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BCASTOPEN
operator|)
condition|)
break|break;
name|fd
operator|=
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|n
operator|--
expr_stmt|;
comment|/* 						 * Get a buffer and read the frame.  If we 						 * haven't got a buffer, or this is received 						 * on the wild card socket, just dump the 						 * packet. 						 */
if|if
condition|(
ifdef|#
directive|ifdef
name|UDP_WILDCARD_DELIVERY
comment|/* 				 * these guys manage to put properly addressed 				 * packets into the wildcard queue 				 */
operator|(
name|free_recvbuffs
argument_list|()
operator|==
literal|0
operator|)
else|#
directive|else
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
name|free_recvbuffs
argument_list|()
operator|==
literal|0
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|char
name|buf
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
name|struct
name|sockaddr
name|from
decl_stmt|;
name|fromlen
operator|=
sizeof|sizeof
name|from
expr_stmt|;
operator|(
name|void
operator|)
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s on %d(%lu) fd=%d from %s\n"
argument_list|,
operator|(
name|i
operator|)
condition|?
literal|"drop"
else|:
literal|"ignore"
argument_list|,
name|i
argument_list|,
name|free_recvbuffs
argument_list|()
argument_list|,
name|fd
argument_list|,
name|inet_ntoa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|from
operator|)
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|packets_ignored
operator|++
expr_stmt|;
else|else
name|packets_dropped
operator|++
expr_stmt|;
goto|goto
name|select_again
goto|;
block|}
name|rb
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
argument_list|,
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|==
literal|0
ifdef|#
directive|ifdef
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|EWOULDBLOCK
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAGAIN
operator|||
name|errno
operator|==
name|EAGAIN
endif|#
directive|endif
condition|)
block|{
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"recvfrom() fd=%d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"input_handler: fd=%d dropped (bad recvfrom)\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"input_handler: fd=%d length %d from %08lx %s\n"
argument_list|,
name|fd
argument_list|,
name|rb
operator|->
name|recv_length
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|rb
operator|->
name|recv_srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|&
literal|0x00000000ffffffff
argument_list|,
name|inet_ntoa
argument_list|(
name|rb
operator|->
name|recv_srcadr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Got one.  Mark how and when it got here, 	 * put it on the full list and do bookkeeping. 	 */
name|rb
operator|->
name|dstadr
operator|=
operator|&
name|inter_list
index|[
name|i
index|]
expr_stmt|;
name|rb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|receiver
operator|=
name|receive
expr_stmt|;
name|add_full_recv_buffer
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|received
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
goto|goto
name|select_again
goto|;
block|}
comment|/* Check more interfaces */
block|}
block|}
name|select_again
label|:
empty_stmt|;
comment|/* 			 * Done everything from that select.  Poll again. 			 */
block|}
comment|/* 		 * If nothing more to do, try again. 		 * If nothing to do, just return. 		 * If an error occurred, complain and return. 		 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|select_count
operator|==
literal|0
condition|)
comment|/* We really had nothing to do */
block|{
if|if
condition|(
name|debug
condition|)
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"input_handler: select() returned 0"
argument_list|)
expr_stmt|;
operator|--
name|handler_count
expr_stmt|;
return|return;
block|}
comment|/* We've done our work */
name|get_systime
argument_list|(
operator|&
name|ts_e
argument_list|)
expr_stmt|;
comment|/* 			 * (ts_e - ts) is the amount of time we spent processing 			 * this gob of file descriptors.  Log it. 			 */
name|L_SUB
argument_list|(
operator|&
name|ts_e
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"input_handler: Processed a gob of fd's in %s msec"
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|ts_e
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
comment|/* just bail. */
operator|--
name|handler_count
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
comment|/* 			 * extended FAU debugging output 			 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select(%d, %s, 0L, 0L,&0.000000) error: %m"
argument_list|,
name|maxactivefd
operator|+
literal|1
argument_list|,
name|fdbits
argument_list|(
name|maxactivefd
argument_list|,
operator|&
name|activefds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBADF
condition|)
block|{
name|int
name|j
decl_stmt|,
name|b
decl_stmt|;
name|fds
operator|=
name|activefds
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|maxactivefd
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|FD_ISSET
argument_list|(
name|j
argument_list|,
operator|&
name|fds
argument_list|)
operator|&&
operator|(
name|read
argument_list|(
name|j
argument_list|,
operator|&
name|b
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Bad file descriptor %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
operator|--
name|handler_count
expr_stmt|;
return|return;
block|}
block|}
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"input_handler: fell out of infinite for(;;) loop!"
argument_list|)
expr_stmt|;
operator|--
name|handler_count
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * findinterface - utility used by other modules to find an interface  *		   given an address.  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|findinterface
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_int32
name|saddr
decl_stmt|;
comment|/* 	 * Just match the address portion. 	 */
name|saddr
operator|=
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|saddr
condition|)
return|return
operator|&
name|inter_list
index|[
name|i
index|]
return|;
block|}
return|return
operator|(
expr|struct
name|interface
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * io_clr_stats - clear I/O module statistics  */
end_comment

begin_function
name|void
name|io_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|packets_dropped
operator|=
literal|0
expr_stmt|;
name|packets_ignored
operator|=
literal|0
expr_stmt|;
name|packets_received
operator|=
literal|0
expr_stmt|;
name|packets_sent
operator|=
literal|0
expr_stmt|;
name|packets_notsent
operator|=
literal|0
expr_stmt|;
name|handler_calls
operator|=
literal|0
expr_stmt|;
name|handler_pkts
operator|=
literal|0
expr_stmt|;
name|io_timereset
operator|=
name|current_time
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * This is a hack so that I don't have to fool with these ioctls in the  * pps driver ... we are already non-blocking and turn on SIGIO thru  * another mechanisim  */
end_comment

begin_function
name|int
name|io_addclock_simple
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* 	 * Stuff the I/O structure in the list and mark the descriptor 	 * in use.	There is a harmless (I hope) race condition here. 	 */
name|rio
operator|->
name|next
operator|=
name|refio
expr_stmt|;
name|refio
operator|=
name|rio
expr_stmt|;
if|if
condition|(
name|rio
operator|->
name|fd
operator|>
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * io_addclock - add a reference clock to the list and arrange that we  *				 get SIGIO interrupts from it.  */
end_comment

begin_function
name|int
name|io_addclock
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* 	 * Stuff the I/O structure in the list and mark the descriptor 	 * in use.	There is a harmless (I hope) race condition here. 	 */
name|rio
operator|->
name|next
operator|=
name|refio
expr_stmt|;
name|refio
operator|=
name|rio
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
if|if
condition|(
name|init_clock_sig
argument_list|(
name|rio
argument_list|)
condition|)
block|{
name|refio
operator|=
name|rio
operator|->
name|next
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
if|if
condition|(
name|io_completion_port_add_clock_io
argument_list|(
name|rio
argument_list|)
condition|)
block|{
name|refio
operator|=
name|rio
operator|->
name|next
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rio
operator|->
name|fd
operator|>
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * io_closeclock - close the clock in the I/O structure given  */
end_comment

begin_function
name|void
name|io_closeclock
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
comment|/* 	 * Remove structure from the list 	 */
if|if
condition|(
name|refio
operator|==
name|rio
condition|)
block|{
name|refio
operator|=
name|rio
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|refclockio
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|refio
init|;
name|rp
operator|!=
literal|0
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
if|if
condition|(
name|rp
operator|->
name|next
operator|==
name|rio
condition|)
block|{
name|rp
operator|->
name|next
operator|=
name|rio
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rp
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Internal error.	Report it. 			 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"internal error: refclockio structure not found"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Close the descriptor. 	 */
name|close_file
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_function
name|void
name|kill_asyncio
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|BLOCKIO
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxactivefd
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|close_socket
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

