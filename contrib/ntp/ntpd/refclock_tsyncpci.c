begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* * *  Module  : refclock_tsyncpci.c *  Date    : 09/08/08 *  Purpose : Implements a reference clock driver for the NTP daemon.  This *            reference clock driver provides a means to communicate with *            the Spectracom TSYNC PCI timing devices and use them as a time *            source. * *  (C) Copyright 2008 Spectracom Corporation * *  This software is provided by Spectracom Corporation 'as is' and *  any express or implied warranties, including, but not limited to, the *  implied warranties of merchantability and fitness for a particular purpose *  are disclaimed.  In no event shall Spectracom Corporation be liable *  for any direct, indirect, incidental, special, exemplary, or consequential *  damages (including, but not limited to, procurement of substitute goods *  or services; loss of use, data, or profits; or business interruption) *  however caused and on any theory of liability, whether in contract, strict *  liability, or tort (including negligence or otherwise) arising in any way *  out of the use of this software, even if advised of the possibility of *  such damage. * *  This software is released for distribution according to the NTP copyright *  and license contained in html/copyright.html of NTP source. * *******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_TSYNCPCI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<asm/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_comment
comment|/******************************************************************************* ** ** This driver supports the Spectracom TSYNC PCI GPS receiver.  It requires ** that the tsyncpci.o device driver be installed and loaded. ** *******************************************************************************/
end_comment

begin_define
define|#
directive|define
name|TSYNC_PCI_REVISION
value|"1.11"
end_define

begin_comment
comment|/* ** TPRO interface definitions */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/tsyncpci"
end_define

begin_comment
comment|/* device name */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (1 us) */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"Spectracom TSYNC-PCI"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|SECONDS_1900_TO_1970
value|(2208988800U)
end_define

begin_define
define|#
directive|define
name|TSYNC_REF_IID
value|(0x2500)
end_define

begin_comment
comment|// SS CAI, REF IID
end_comment

begin_define
define|#
directive|define
name|TSYNC_REF_DEST_ID
value|(0x0001)
end_define

begin_comment
comment|// KTS Firmware
end_comment

begin_define
define|#
directive|define
name|TSYNC_REF_IN_PYLD_OFF
value|(0)
end_define

begin_define
define|#
directive|define
name|TSYNC_REF_IN_LEN
value|(0)
end_define

begin_define
define|#
directive|define
name|TSYNC_REF_OUT_PYLD_OFF
value|(0)
end_define

begin_define
define|#
directive|define
name|TSYNC_REF_OUT_LEN
value|(8)
end_define

begin_define
define|#
directive|define
name|TSYNC_REF_MAX_OUT_LEN
value|(16)
end_define

begin_define
define|#
directive|define
name|TSYNC_REF_PYLD_LEN
value|(TSYNC_REF_IN_LEN +                     \                                      TSYNC_REF_MAX_OUT_LEN)
end_define

begin_define
define|#
directive|define
name|TSYNC_REF_LEN
value|(4)
end_define

begin_define
define|#
directive|define
name|TSYNC_REF_LOCAL
value|("LOCL")
end_define

begin_define
define|#
directive|define
name|TSYNC_TMSCL_IID
value|(0x2301)
end_define

begin_comment
comment|// CS CAI, TIMESCALE IID
end_comment

begin_define
define|#
directive|define
name|TSYNC_TMSCL_DEST_ID
value|(0x0001)
end_define

begin_comment
comment|// KTS Firmware
end_comment

begin_define
define|#
directive|define
name|TSYNC_TMSCL_IN_PYLD_OFF
value|(0)
end_define

begin_define
define|#
directive|define
name|TSYNC_TMSCL_IN_LEN
value|(0)
end_define

begin_define
define|#
directive|define
name|TSYNC_TMSCL_OUT_PYLD_OFF
value|(0)
end_define

begin_define
define|#
directive|define
name|TSYNC_TMSCL_OUT_LEN
value|(4)
end_define

begin_define
define|#
directive|define
name|TSYNC_TMSCL_MAX_OUT_LEN
value|(12)
end_define

begin_define
define|#
directive|define
name|TSYNC_TMSCL_PYLD_LEN
value|(TSYNC_TMSCL_IN_LEN +                    \                                      TSYNC_TMSCL_MAX_OUT_LEN)
end_define

begin_define
define|#
directive|define
name|TSYNC_LEAP_IID
value|(0x2307)
end_define

begin_comment
comment|// CS CAI, LEAP SEC IID
end_comment

begin_define
define|#
directive|define
name|TSYNC_LEAP_DEST_ID
value|(0x0001)
end_define

begin_comment
comment|// KTS Firmware
end_comment

begin_define
define|#
directive|define
name|TSYNC_LEAP_IN_PYLD_OFF
value|(0)
end_define

begin_define
define|#
directive|define
name|TSYNC_LEAP_IN_LEN
value|(0)
end_define

begin_define
define|#
directive|define
name|TSYNC_LEAP_OUT_PYLD_OFF
value|(0)
end_define

begin_define
define|#
directive|define
name|TSYNC_LEAP_OUT_LEN
value|(28)
end_define

begin_define
define|#
directive|define
name|TSYNC_LEAP_MAX_OUT_LEN
value|(36)
end_define

begin_define
define|#
directive|define
name|TSYNC_LEAP_PYLD_LEN
value|(TSYNC_LEAP_IN_LEN +                    \                                      TSYNC_LEAP_MAX_OUT_LEN)
end_define

begin_comment
comment|// These define the base date/time of the system clock.  The system time will
end_comment

begin_comment
comment|// be tracked as the number of seconds from this date/time.
end_comment

begin_define
define|#
directive|define
name|TSYNC_TIME_BASE_YEAR
value|(1970)
end_define

begin_comment
comment|// earliest acceptable year
end_comment

begin_define
define|#
directive|define
name|TSYNC_LCL_STRATUM
value|(0)
end_define

begin_comment
comment|/* ** TSYNC Time Scales type */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|TIME_SCALE_UTC
init|=
literal|0
block|,
comment|// Universal Coordinated Time
name|TIME_SCALE_TAI
init|=
literal|1
block|,
comment|// International Atomic Time
name|TIME_SCALE_GPS
init|=
literal|2
block|,
comment|// Global Positioning System
name|TIME_SCALE_LOCAL
init|=
literal|3
block|,
comment|// UTC w/local rules for time zone and DST
name|NUM_TIME_SCALES
init|=
literal|4
block|,
comment|// Number of time scales
name|TIME_SCALE_MAX
init|=
literal|15
comment|// Maximum number of timescales
block|}
name|TIME_SCALE
typedef|;
end_typedef

begin_comment
comment|/* ** TSYNC Board Object */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BoardObj
block|{
name|int
name|file_descriptor
decl_stmt|;
name|unsigned
name|short
name|devid
decl_stmt|;
name|unsigned
name|short
name|options
decl_stmt|;
name|unsigned
name|char
name|firmware
index|[
literal|5
index|]
decl_stmt|;
name|unsigned
name|char
name|FPGA
index|[
literal|5
index|]
decl_stmt|;
name|unsigned
name|char
name|driver
index|[
literal|7
index|]
decl_stmt|;
block|}
name|BoardObj
typedef|;
end_typedef

begin_comment
comment|/* ** TSYNC Time Object */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TimeObj
block|{
name|unsigned
name|char
name|syncOption
decl_stmt|;
comment|/* -M option */
name|unsigned
name|int
name|secsDouble
decl_stmt|;
comment|/* seconds floating pt */
name|unsigned
name|char
name|seconds
decl_stmt|;
comment|/* seconds whole num */
name|unsigned
name|char
name|minutes
decl_stmt|;
name|unsigned
name|char
name|hours
decl_stmt|;
name|unsigned
name|short
name|days
decl_stmt|;
name|unsigned
name|short
name|year
decl_stmt|;
name|unsigned
name|short
name|flags
decl_stmt|;
comment|/* bit 2 SYNC, bit 1 TCODE; all others 0 */
block|}
name|TimeObj
typedef|;
end_typedef

begin_comment
comment|/* ** NTP Time Object */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|NtpTimeObj
block|{
name|TimeObj
name|timeObj
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|unsigned
name|int
name|refId
decl_stmt|;
block|}
name|NtpTimeObj
typedef|;
end_typedef

begin_comment
comment|/* ** TSYNC Supervisor Reference Object */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ReferenceObj
block|{
name|char
name|time
index|[
name|TSYNC_REF_LEN
index|]
decl_stmt|;
name|char
name|pps
index|[
name|TSYNC_REF_LEN
index|]
decl_stmt|;
block|}
name|ReferenceObj
typedef|;
end_typedef

begin_comment
comment|/* ** TSYNC Seconds Time Object */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|SecTimeObj
block|{
name|unsigned
name|int
name|seconds
decl_stmt|;
name|unsigned
name|int
name|ns
decl_stmt|;
block|}
name|SecTimeObj
typedef|;
end_typedef

begin_comment
comment|/* ** TSYNC DOY Time Object */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|DoyTimeObj
block|{
name|unsigned
name|int
name|year
decl_stmt|;
name|unsigned
name|int
name|doy
decl_stmt|;
name|unsigned
name|int
name|hour
decl_stmt|;
name|unsigned
name|int
name|minute
decl_stmt|;
name|unsigned
name|int
name|second
decl_stmt|;
name|unsigned
name|int
name|ns
decl_stmt|;
block|}
name|DoyTimeObj
typedef|;
end_typedef

begin_comment
comment|/* ** TSYNC Leap Second Object */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|LeapSecondObj
block|{
name|int
name|offset
decl_stmt|;
name|DoyTimeObj
name|utcDate
decl_stmt|;
block|}
name|LeapSecondObj
typedef|;
end_typedef

begin_comment
comment|/*  * structures for ioctl interactions with driver  */
end_comment

begin_define
define|#
directive|define
name|DI_PAYLOADS_STARTER_LENGTH
value|4
end_define

begin_typedef
typedef|typedef
struct|struct
name|ioctl_trans_di
block|{
comment|// input parameters
name|uint16_t
name|dest
decl_stmt|;
name|uint16_t
name|iid
decl_stmt|;
name|uint32_t
name|inPayloadOffset
decl_stmt|;
name|uint32_t
name|inLength
decl_stmt|;
name|uint32_t
name|outPayloadOffset
decl_stmt|;
name|uint32_t
name|maxOutLength
decl_stmt|;
comment|// output parameters
name|uint32_t
name|actualOutLength
decl_stmt|;
name|int32_t
name|status
decl_stmt|;
comment|// Input and output
comment|// The payloads field MUST be last in ioctl_trans_di.
name|uint8_t
name|payloads
index|[
name|DI_PAYLOADS_STARTER_LENGTH
index|]
decl_stmt|;
block|}
name|ioctl_trans_di
typedef|;
end_typedef

begin_comment
comment|/*  * structure for looking up a reference ID from a reference name  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|pRef
decl_stmt|;
comment|// KTS Reference Name
specifier|const
name|char
modifier|*
name|pRefId
decl_stmt|;
comment|// NTP Reference ID
block|}
name|RefIdLookup
typedef|;
end_typedef

begin_comment
comment|/*  * unit control structure  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|refPrefer
decl_stmt|;
comment|// Reference prefer flag
name|uint32_t
name|refId
decl_stmt|;
comment|// Host peer reference ID
name|uint8_t
name|refStratum
decl_stmt|;
comment|// Host peer reference stratum
block|}
name|TsyncUnit
typedef|;
end_typedef

begin_comment
comment|/* **  Function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|tsync_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tsync_shutdown
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tsync_start
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* **  Helper functions */
end_comment

begin_function_decl
specifier|static
name|void
name|ApplyTimeOffset
parameter_list|(
name|DoyTimeObj
modifier|*
name|pDt
parameter_list|,
name|int
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SecTimeFromDoyTime
parameter_list|(
name|SecTimeObj
modifier|*
name|pSt
parameter_list|,
name|DoyTimeObj
modifier|*
name|pDt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DoyTimeFromSecTime
parameter_list|(
name|DoyTimeObj
modifier|*
name|pDt
parameter_list|,
name|SecTimeObj
modifier|*
name|pSt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* **  Transfer vector */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_tsyncpci
init|=
block|{
name|tsync_start
block|,
comment|/* start up driver */
name|tsync_shutdown
block|,
comment|/* shut down driver */
name|tsync_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old tsync_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old tsync_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reference ID lookup table  */
end_comment

begin_decl_stmt
specifier|static
name|RefIdLookup
name|RefIdLookupTbl
index|[]
init|=
block|{
block|{
literal|"gps"
block|,
literal|"GPS"
block|}
block|,
block|{
literal|"ir"
block|,
literal|"IRIG"
block|}
block|,
block|{
literal|"hvq"
block|,
literal|"HVQ"
block|}
block|,
block|{
literal|"frq"
block|,
literal|"FREQ"
block|}
block|,
block|{
literal|"mdm"
block|,
literal|"ACTS"
block|}
block|,
block|{
literal|"epp"
block|,
literal|"PPS"
block|}
block|,
block|{
literal|"ptp"
block|,
literal|"PTP"
block|}
block|,
block|{
literal|"asc"
block|,
literal|"ATC"
block|}
block|,
block|{
literal|"hst0"
block|,
literal|"USER"
block|}
block|,
block|{
literal|"hst"
block|,
name|TSYNC_REF_LOCAL
block|}
block|,
block|{
literal|"self"
block|,
name|TSYNC_REF_LOCAL
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************* **          IOCTL DEFINITIONS *******************************************************************************/
end_comment

begin_define
define|#
directive|define
name|IOCTL_TPRO_ID
value|'t'
end_define

begin_define
define|#
directive|define
name|IOCTL_TPRO_OPEN
value|_IOWR(IOCTL_TPRO_ID, 0,  BoardObj)
end_define

begin_define
define|#
directive|define
name|IOCTL_TPRO_GET_NTP_TIME
value|_IOWR(IOCTL_TPRO_ID, 25, NtpTimeObj)
end_define

begin_define
define|#
directive|define
name|IOCTL_TSYNC_GET
value|_IOWR(IOCTL_TPRO_ID, 26, ioctl_trans_di)
end_define

begin_comment
comment|/******************************************************************************  *  * Function:    tsync_start()  * Description: Used to intialize the Spectracom TSYNC reference driver.  *  * Parameters:  *     IN:  unit - not used.  *         *peer - pointer to this reference clock's peer structure  *     Returns: 0 - unsuccessful  *              1 - successful  * *******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|tsync_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|TsyncUnit
modifier|*
name|up
decl_stmt|;
comment|/*     **  initialize reference clock and peer parameters     */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|noentry
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
comment|// Allocate and initialize unit structure
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
name|TsyncUnit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TsyncUnit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|// Store reference preference
name|up
operator|->
name|refPrefer
operator|=
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
expr_stmt|;
comment|// Initialize reference stratum level and ID
name|up
operator|->
name|refStratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|up
operator|->
name|refId
argument_list|,
name|TSYNC_REF_LOCAL
argument_list|,
name|TSYNC_REF_LEN
argument_list|)
expr_stmt|;
comment|// Attach unit structure
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* Declare our refId as local in the beginning because we do not know      * what our actual refid is yet.      */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|TSYNC_REF_LOCAL
argument_list|,
name|TSYNC_REF_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* End - tsync_start() */
end_comment

begin_comment
comment|/******************************************************************************* ** ** Function:    tsync_shutdown() ** Description: Handles anything related to shutting down the reference clock **              driver. Nothing at this point in time. ** ** Parameters: **     IN:  unit - not used. **         *peer - pointer to this reference clock's peer structure **     Returns: none. ** *******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|tsync_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{  }
end_function

begin_comment
comment|/* End - tsync_shutdown() */
end_comment

begin_comment
comment|/******************************************************************************  *  * Function:    tsync_poll()  * Description: Retrieve time from the TSYNC device.  *  * Parameters:  *     IN:  unit - not used.  *         *peer - pointer to this reference clock's peer structure  *     Returns: none.  * *******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|tsync_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|char
name|device
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|calendar
name|jt
decl_stmt|;
name|TsyncUnit
modifier|*
name|up
decl_stmt|;
name|unsigned
name|char
name|synch
decl_stmt|;
name|double
name|seconds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|err1
decl_stmt|;
name|int
name|err2
decl_stmt|;
name|int
name|err3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|int
name|itAllocationLength
decl_stmt|;
name|unsigned
name|int
name|itAllocationLength1
decl_stmt|;
name|unsigned
name|int
name|itAllocationLength2
decl_stmt|;
name|NtpTimeObj
name|TimeContext
decl_stmt|;
name|BoardObj
name|hBoard
decl_stmt|;
name|char
name|timeRef
index|[
name|TSYNC_REF_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|ppsRef
index|[
name|TSYNC_REF_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|TIME_SCALE
name|tmscl
init|=
name|TIME_SCALE_UTC
decl_stmt|;
name|LeapSecondObj
name|leapSec
decl_stmt|;
name|ioctl_trans_di
modifier|*
name|it
decl_stmt|;
name|ioctl_trans_di
modifier|*
name|it1
decl_stmt|;
name|ioctl_trans_di
modifier|*
name|it2
decl_stmt|;
name|l_fp
name|offset
decl_stmt|;
name|l_fp
name|ltemp
decl_stmt|;
name|ReferenceObj
modifier|*
name|pRefObj
decl_stmt|;
comment|/* Construct the device name */
name|sprintf
argument_list|(
name|device
argument_list|,
literal|"%s%d"
argument_list|,
name|DEVICE
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|refclkunit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Polling device number %d...\n"
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|refclkunit
argument_list|)
expr_stmt|;
comment|/* Open the TSYNC device */
name|hBoard
operator|.
name|file_descriptor
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDONLY
operator||
name|O_NDELAY
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
comment|/* If error opening TSYNC device... */
if|if
condition|(
name|hBoard
operator|.
name|file_descriptor
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't open device"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If error while initializing the board... */
if|if
condition|(
name|ioctl
argument_list|(
name|hBoard
operator|.
name|file_descriptor
argument_list|,
name|IOCTL_TPRO_OPEN
argument_list|,
operator|&
name|hBoard
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't initialize device"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|hBoard
operator|.
name|file_descriptor
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allocate memory for ioctl message */
name|itAllocationLength
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|ioctl_trans_di
argument_list|)
operator|-
name|DI_PAYLOADS_STARTER_LENGTH
operator|)
operator|+
name|TSYNC_REF_IN_LEN
operator|+
name|TSYNC_REF_MAX_OUT_LEN
expr_stmt|;
name|it
operator|=
operator|(
name|ioctl_trans_di
operator|*
operator|)
name|alloca
argument_list|(
name|itAllocationLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't allocate transaction memory - Reference"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Build SS_GetRef ioctl message */
name|it
operator|->
name|dest
operator|=
name|TSYNC_REF_DEST_ID
expr_stmt|;
name|it
operator|->
name|iid
operator|=
name|TSYNC_REF_IID
expr_stmt|;
name|it
operator|->
name|inPayloadOffset
operator|=
name|TSYNC_REF_IN_PYLD_OFF
expr_stmt|;
name|it
operator|->
name|inLength
operator|=
name|TSYNC_REF_IN_LEN
expr_stmt|;
name|it
operator|->
name|outPayloadOffset
operator|=
name|TSYNC_REF_OUT_PYLD_OFF
expr_stmt|;
name|it
operator|->
name|maxOutLength
operator|=
name|TSYNC_REF_MAX_OUT_LEN
expr_stmt|;
name|it
operator|->
name|actualOutLength
operator|=
literal|0
expr_stmt|;
name|it
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|it
operator|->
name|payloads
argument_list|,
literal|0
argument_list|,
name|TSYNC_REF_MAX_OUT_LEN
argument_list|)
expr_stmt|;
comment|/* Read the reference from the TSYNC-PCI device */
name|err
operator|=
name|ioctl
argument_list|(
name|hBoard
operator|.
name|file_descriptor
argument_list|,
name|IOCTL_TSYNC_GET
argument_list|,
operator|(
name|char
operator|*
operator|)
name|it
argument_list|)
expr_stmt|;
comment|/* Allocate memory for ioctl message */
name|itAllocationLength1
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|ioctl_trans_di
argument_list|)
operator|-
name|DI_PAYLOADS_STARTER_LENGTH
operator|)
operator|+
name|TSYNC_TMSCL_IN_LEN
operator|+
name|TSYNC_TMSCL_MAX_OUT_LEN
expr_stmt|;
name|it1
operator|=
operator|(
name|ioctl_trans_di
operator|*
operator|)
name|alloca
argument_list|(
name|itAllocationLength1
argument_list|)
expr_stmt|;
if|if
condition|(
name|it1
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't allocate transaction memory - Time Scale"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Build CS_GetTimeScale ioctl message */
name|it1
operator|->
name|dest
operator|=
name|TSYNC_TMSCL_DEST_ID
expr_stmt|;
name|it1
operator|->
name|iid
operator|=
name|TSYNC_TMSCL_IID
expr_stmt|;
name|it1
operator|->
name|inPayloadOffset
operator|=
name|TSYNC_TMSCL_IN_PYLD_OFF
expr_stmt|;
name|it1
operator|->
name|inLength
operator|=
name|TSYNC_TMSCL_IN_LEN
expr_stmt|;
name|it1
operator|->
name|outPayloadOffset
operator|=
name|TSYNC_TMSCL_OUT_PYLD_OFF
expr_stmt|;
name|it1
operator|->
name|maxOutLength
operator|=
name|TSYNC_TMSCL_MAX_OUT_LEN
expr_stmt|;
name|it1
operator|->
name|actualOutLength
operator|=
literal|0
expr_stmt|;
name|it1
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|it1
operator|->
name|payloads
argument_list|,
literal|0
argument_list|,
name|TSYNC_TMSCL_MAX_OUT_LEN
argument_list|)
expr_stmt|;
comment|/* Read the Time Scale info from the TSYNC-PCI device */
name|err1
operator|=
name|ioctl
argument_list|(
name|hBoard
operator|.
name|file_descriptor
argument_list|,
name|IOCTL_TSYNC_GET
argument_list|,
operator|(
name|char
operator|*
operator|)
name|it1
argument_list|)
expr_stmt|;
comment|/* Allocate memory for ioctl message */
name|itAllocationLength2
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|ioctl_trans_di
argument_list|)
operator|-
name|DI_PAYLOADS_STARTER_LENGTH
operator|)
operator|+
name|TSYNC_LEAP_IN_LEN
operator|+
name|TSYNC_LEAP_MAX_OUT_LEN
expr_stmt|;
name|it2
operator|=
operator|(
name|ioctl_trans_di
operator|*
operator|)
name|alloca
argument_list|(
name|itAllocationLength2
argument_list|)
expr_stmt|;
if|if
condition|(
name|it2
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't allocate transaction memory - Leap Second"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Build CS_GetLeapSec ioctl message */
name|it2
operator|->
name|dest
operator|=
name|TSYNC_LEAP_DEST_ID
expr_stmt|;
name|it2
operator|->
name|iid
operator|=
name|TSYNC_LEAP_IID
expr_stmt|;
name|it2
operator|->
name|inPayloadOffset
operator|=
name|TSYNC_LEAP_IN_PYLD_OFF
expr_stmt|;
name|it2
operator|->
name|inLength
operator|=
name|TSYNC_LEAP_IN_LEN
expr_stmt|;
name|it2
operator|->
name|outPayloadOffset
operator|=
name|TSYNC_LEAP_OUT_PYLD_OFF
expr_stmt|;
name|it2
operator|->
name|maxOutLength
operator|=
name|TSYNC_LEAP_MAX_OUT_LEN
expr_stmt|;
name|it2
operator|->
name|actualOutLength
operator|=
literal|0
expr_stmt|;
name|it2
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|it2
operator|->
name|payloads
argument_list|,
literal|0
argument_list|,
name|TSYNC_LEAP_MAX_OUT_LEN
argument_list|)
expr_stmt|;
comment|/* Read the leap seconds info from the TSYNC-PCI device */
name|err2
operator|=
name|ioctl
argument_list|(
name|hBoard
operator|.
name|file_descriptor
argument_list|,
name|IOCTL_TSYNC_GET
argument_list|,
operator|(
name|char
operator|*
operator|)
name|it2
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
name|TsyncUnit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* Read the time from the TSYNC-PCI device */
name|err3
operator|=
name|ioctl
argument_list|(
name|hBoard
operator|.
name|file_descriptor
argument_list|,
name|IOCTL_TPRO_GET_NTP_TIME
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|TimeContext
argument_list|)
expr_stmt|;
comment|/* Close the TSYNC device */
name|close
argument_list|(
name|hBoard
operator|.
name|file_descriptor
argument_list|)
expr_stmt|;
comment|// Check for errors
if|if
condition|(
operator|(
name|err
operator|<
literal|0
operator|)
operator|||
operator|(
name|err1
operator|<
literal|0
operator|)
operator|||
operator|(
name|err2
operator|<
literal|0
operator|)
operator|||
operator|(
name|err3
operator|<
literal|0
operator|)
operator|||
operator|(
name|it
operator|->
name|status
operator|!=
literal|0
operator|)
operator|||
operator|(
name|it1
operator|->
name|status
operator|!=
literal|0
operator|)
operator|||
operator|(
name|it2
operator|->
name|status
operator|!=
literal|0
operator|)
operator|||
operator|(
name|it
operator|->
name|actualOutLength
operator|!=
name|TSYNC_REF_OUT_LEN
operator|)
operator|||
operator|(
name|it1
operator|->
name|actualOutLength
operator|!=
name|TSYNC_TMSCL_OUT_LEN
operator|)
operator|||
operator|(
name|it2
operator|->
name|actualOutLength
operator|!=
name|TSYNC_LEAP_OUT_LEN
operator|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Extract reference identifiers from ioctl payload
name|memset
argument_list|(
name|timeRef
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|timeRef
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ppsRef
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ppsRef
argument_list|)
argument_list|)
expr_stmt|;
name|pRefObj
operator|=
operator|(
name|void
operator|*
operator|)
name|it
operator|->
name|payloads
expr_stmt|;
name|memcpy
argument_list|(
name|timeRef
argument_list|,
name|pRefObj
operator|->
name|time
argument_list|,
name|TSYNC_REF_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ppsRef
argument_list|,
name|pRefObj
operator|->
name|pps
argument_list|,
name|TSYNC_REF_LEN
argument_list|)
expr_stmt|;
comment|// Extract the Clock Service Time Scale and convert to correct byte order
name|memcpy
argument_list|(
operator|&
name|tmscl
argument_list|,
operator|(
operator|(
name|TIME_SCALE
operator|*
operator|)
operator|(
name|it1
operator|->
name|payloads
operator|)
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmscl
argument_list|)
argument_list|)
expr_stmt|;
name|tmscl
operator|=
name|ntohl
argument_list|(
name|tmscl
argument_list|)
expr_stmt|;
comment|// Extract leap second info from ioctl payload and perform byte swapping
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|leapSec
argument_list|)
operator|/
literal|4
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|leapSec
operator|)
index|[
operator|(
name|i
operator|*
literal|4
operator|)
operator|+
name|j
index|]
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|it2
operator|->
name|payloads
operator|)
operator|)
index|[
operator|(
name|i
operator|*
literal|4
operator|)
operator|+
operator|(
literal|3
operator|-
name|j
operator|)
index|]
expr_stmt|;
block|}
block|}
comment|// Determine time reference ID from reference name
for|for
control|(
name|i
operator|=
literal|0
init|;
name|RefIdLookupTbl
index|[
name|i
index|]
operator|.
name|pRef
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
comment|// Search RefID table
if|if
condition|(
name|strstr
argument_list|(
name|timeRef
argument_list|,
name|RefIdLookupTbl
index|[
name|i
index|]
operator|.
name|pRef
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|// Found the matching string
break|break;
block|}
block|}
comment|// Determine pps reference ID from reference name
for|for
control|(
name|j
operator|=
literal|0
init|;
name|RefIdLookupTbl
index|[
name|j
index|]
operator|.
name|pRef
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
comment|// Search RefID table
if|if
condition|(
name|strstr
argument_list|(
name|ppsRef
argument_list|,
name|RefIdLookupTbl
index|[
name|j
index|]
operator|.
name|pRef
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|// Found the matching string
break|break;
block|}
block|}
comment|// Determine synchronization state from flags
name|synch
operator|=
operator|(
name|TimeContext
operator|.
name|timeObj
operator|.
name|flags
operator|==
literal|0x4
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|// Pull seconds information from time object
name|seconds
operator|=
call|(
name|double
call|)
argument_list|(
name|TimeContext
operator|.
name|timeObj
operator|.
name|secsDouble
argument_list|)
expr_stmt|;
name|seconds
operator|/=
operator|(
name|double
operator|)
literal|1000000.0
expr_stmt|;
comment|/*     ** Convert the number of microseconds to double and then place in the     ** peer's last received long floating point format.     */
name|DTOLFP
argument_list|(
operator|(
operator|(
name|double
operator|)
name|TimeContext
operator|.
name|tv
operator|.
name|tv_usec
operator|/
literal|1000000.0
operator|)
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
comment|/*     ** The specTimeStamp is the number of seconds since 1/1/1970, while the     ** peer's lastrec time should be compatible with NTP which is seconds since     ** 1/1/1900.  So Add the number of seconds between 1900 and 1970 to the     ** specTimeStamp and place in the peer's lastrec long floating point struct.     */
name|pp
operator|->
name|lastrec
operator|.
name|Ul_i
operator|.
name|Xl_ui
operator|+=
operator|(
name|unsigned
name|int
operator|)
name|TimeContext
operator|.
name|tv
operator|.
name|tv_sec
operator|+
name|SECONDS_1900_TO_1970
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
comment|/*     **  set the reference clock object     */
name|sprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%03d %02d:%02d:%02.6f"
argument_list|,
name|TimeContext
operator|.
name|timeObj
operator|.
name|days
argument_list|,
name|TimeContext
operator|.
name|timeObj
operator|.
name|hours
argument_list|,
name|TimeContext
operator|.
name|timeObj
operator|.
name|minutes
argument_list|,
name|seconds
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|pp
operator|->
name|day
operator|=
name|TimeContext
operator|.
name|timeObj
operator|.
name|days
expr_stmt|;
name|pp
operator|->
name|hour
operator|=
name|TimeContext
operator|.
name|timeObj
operator|.
name|hours
expr_stmt|;
name|pp
operator|->
name|minute
operator|=
name|TimeContext
operator|.
name|timeObj
operator|.
name|minutes
expr_stmt|;
name|pp
operator|->
name|second
operator|=
operator|(
name|int
operator|)
name|seconds
expr_stmt|;
name|seconds
operator|=
operator|(
name|seconds
operator|-
call|(
name|double
call|)
argument_list|(
name|pp
operator|->
name|second
operator|/
literal|1.0
argument_list|)
operator|)
operator|*
literal|1000000000
expr_stmt|;
name|pp
operator|->
name|nsec
operator|=
operator|(
name|long
operator|)
name|seconds
expr_stmt|;
comment|/*     **  calculate year start     */
name|jt
operator|.
name|year
operator|=
name|TimeContext
operator|.
name|timeObj
operator|.
name|year
expr_stmt|;
name|jt
operator|.
name|yearday
operator|=
literal|1
expr_stmt|;
name|jt
operator|.
name|monthday
operator|=
literal|1
expr_stmt|;
name|jt
operator|.
name|month
operator|=
literal|1
expr_stmt|;
name|jt
operator|.
name|hour
operator|=
literal|0
expr_stmt|;
name|jt
operator|.
name|minute
operator|=
literal|0
expr_stmt|;
name|jt
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|yearstart
operator|=
name|caltontp
argument_list|(
operator|&
name|jt
argument_list|)
expr_stmt|;
comment|// Calculate and report reference clock offset
name|offset
operator|.
name|l_ui
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|pp
operator|->
name|day
operator|-
literal|1
operator|)
operator|*
literal|24
operator|)
operator|+
name|pp
operator|->
name|hour
operator|+
name|GMT
argument_list|)
expr_stmt|;
name|offset
operator|.
name|l_ui
operator|=
operator|(
name|offset
operator|.
name|l_ui
operator|*
literal|60
operator|)
operator|+
operator|(
name|long
operator|)
name|pp
operator|->
name|minute
expr_stmt|;
name|offset
operator|.
name|l_ui
operator|=
operator|(
name|offset
operator|.
name|l_ui
operator|*
literal|60
operator|)
operator|+
operator|(
name|long
operator|)
name|pp
operator|->
name|second
expr_stmt|;
name|offset
operator|.
name|l_ui
operator|=
name|offset
operator|.
name|l_ui
operator|+
operator|(
name|long
operator|)
name|pp
operator|->
name|yearstart
expr_stmt|;
name|offset
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
name|DTOLFP
argument_list|(
name|pp
operator|->
name|nsec
operator|/
literal|1e9
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|offset
argument_list|,
name|pp
operator|->
name|lastrec
argument_list|,
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
comment|// KTS in sync
if|if
condition|(
name|synch
condition|)
block|{
comment|// Subtract leap second info by one second to determine effective day
name|ApplyTimeOffset
argument_list|(
operator|&
operator|(
name|leapSec
operator|.
name|utcDate
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// If there is a leap second today and the KTS is using a time scale
comment|// which handles leap seconds then
if|if
condition|(
operator|(
name|tmscl
operator|!=
name|TIME_SCALE_GPS
operator|)
operator|&&
operator|(
name|tmscl
operator|!=
name|TIME_SCALE_TAI
operator|)
operator|&&
operator|(
name|leapSec
operator|.
name|utcDate
operator|.
name|year
operator|==
operator|(
name|unsigned
name|int
operator|)
name|TimeContext
operator|.
name|timeObj
operator|.
name|year
operator|)
operator|&&
operator|(
name|leapSec
operator|.
name|utcDate
operator|.
name|doy
operator|==
operator|(
name|unsigned
name|int
operator|)
name|TimeContext
operator|.
name|timeObj
operator|.
name|days
operator|)
condition|)
block|{
comment|// If adding a second
if|if
condition|(
name|leapSec
operator|.
name|offset
operator|==
literal|1
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
block|}
comment|// Else if removing a second
elseif|else
if|if
condition|(
name|leapSec
operator|.
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
block|}
comment|// Else report no leap second pending (no handling of offsets
comment|// other than +1 or -1)
else|else
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
block|}
block|}
comment|// Else report no leap second pending
else|else
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
block|}
name|peer
operator|->
name|leap
operator|=
name|pp
operator|->
name|leap
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
comment|// If reference name reported, then not in holdover
if|if
condition|(
operator|(
name|RefIdLookupTbl
index|[
name|i
index|]
operator|.
name|pRef
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|RefIdLookupTbl
index|[
name|j
index|]
operator|.
name|pRef
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|// Determine if KTS being synchronized by host (identified as
comment|// "LOCL")
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|RefIdLookupTbl
index|[
name|i
index|]
operator|.
name|pRefId
argument_list|,
name|TSYNC_REF_LOCAL
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|RefIdLookupTbl
index|[
name|j
index|]
operator|.
name|pRefId
argument_list|,
name|TSYNC_REF_LOCAL
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|// Clear prefer flag
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PREFER
expr_stmt|;
comment|// Set reference clock stratum level as unusable
name|pp
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|pp
operator|->
name|stratum
expr_stmt|;
comment|// If a valid peer is available
if|if
condition|(
operator|(
name|sys_peer
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sys_peer
operator|!=
name|peer
operator|)
condition|)
block|{
comment|// Store reference peer stratum level and ID
name|up
operator|->
name|refStratum
operator|=
name|sys_peer
operator|->
name|stratum
expr_stmt|;
name|up
operator|->
name|refId
operator|=
name|addr2refid
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Restore prefer flag
name|peer
operator|->
name|flags
operator||=
name|up
operator|->
name|refPrefer
expr_stmt|;
comment|// Store reference stratum as local clock
name|up
operator|->
name|refStratum
operator|=
name|TSYNC_LCL_STRATUM
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|up
operator|->
name|refId
argument_list|,
name|RefIdLookupTbl
index|[
name|j
index|]
operator|.
name|pRefId
argument_list|,
name|TSYNC_REF_LEN
argument_list|)
expr_stmt|;
comment|// Set reference clock stratum level as local clock
name|pp
operator|->
name|stratum
operator|=
name|TSYNC_LCL_STRATUM
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|pp
operator|->
name|stratum
expr_stmt|;
block|}
comment|// Update reference name
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|RefIdLookupTbl
index|[
name|j
index|]
operator|.
name|pRefId
argument_list|,
name|TSYNC_REF_LEN
argument_list|)
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
block|}
comment|// Else in holdover
else|else
block|{
comment|// Restore prefer flag
name|peer
operator|->
name|flags
operator||=
name|up
operator|->
name|refPrefer
expr_stmt|;
comment|// Update reference ID to saved ID
name|pp
operator|->
name|refid
operator|=
name|up
operator|->
name|refId
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
comment|// Update stratum level to saved stratum level
name|pp
operator|->
name|stratum
operator|=
name|up
operator|->
name|refStratum
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|pp
operator|->
name|stratum
expr_stmt|;
block|}
block|}
comment|// Else KTS not in sync
else|else
block|{
comment|// Place local identifier in peer RefID
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|TSYNC_REF_LOCAL
argument_list|,
name|TSYNC_REF_LEN
argument_list|)
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
comment|// Report not in sync
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|peer
operator|->
name|leap
operator|=
name|pp
operator|->
name|leap
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* Increment the number of times the reference has been polled */
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End - tsync_poll() */
end_comment

begin_comment
comment|////////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// Function:    ApplyTimeOffset
end_comment

begin_comment
comment|// Description: The ApplyTimeOffset function adds an offset (in seconds) to a
end_comment

begin_comment
comment|//              specified date and time.  The specified date and time is passed
end_comment

begin_comment
comment|//              back after being modified.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Assumptions: 1. Every fourth year is a leap year.  Therefore, this function
end_comment

begin_comment
comment|//                 is only accurate through Feb 28, 2100.
end_comment

begin_comment
comment|////////////////////////////////////////////////////////////////////////////////
end_comment

begin_function
name|void
name|ApplyTimeOffset
parameter_list|(
name|DoyTimeObj
modifier|*
name|pDt
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|SecTimeObj
name|st
decl_stmt|;
comment|// Time, in seconds
comment|// Convert date and time to seconds
name|SecTimeFromDoyTime
argument_list|(
operator|&
name|st
argument_list|,
name|pDt
argument_list|)
expr_stmt|;
comment|// Apply offset
name|st
operator|.
name|seconds
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|signed
name|long
name|long
operator|)
name|st
operator|.
name|seconds
operator|+
operator|(
name|signed
name|long
name|long
operator|)
name|off
argument_list|)
expr_stmt|;
comment|// Convert seconds to date and time
name|DoyTimeFromSecTime
argument_list|(
name|pDt
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// End ApplyTimeOffset
end_comment

begin_comment
comment|////////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// Function:    SecTimeFromDoyTime
end_comment

begin_comment
comment|// Description: The SecTimeFromDoyTime function converts a specified date
end_comment

begin_comment
comment|//              and time into a count of seconds since the base time.  This
end_comment

begin_comment
comment|//              function operates across the range Base Time to Max Time for
end_comment

begin_comment
comment|//              the system.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Assumptions: 1. A leap year is any year evenly divisible by 4.  Therefore,
end_comment

begin_comment
comment|//                 this function is only accurate through Feb 28, 2100.
end_comment

begin_comment
comment|//              2. Conversion does not account for leap seconds.
end_comment

begin_comment
comment|////////////////////////////////////////////////////////////////////////////////
end_comment

begin_function
name|void
name|SecTimeFromDoyTime
parameter_list|(
name|SecTimeObj
modifier|*
name|pSt
parameter_list|,
name|DoyTimeObj
modifier|*
name|pDt
parameter_list|)
block|{
name|unsigned
name|int
name|yrs
decl_stmt|;
comment|// Years
name|unsigned
name|int
name|lyrs
decl_stmt|;
comment|// Leap years
comment|// Start with accumulated time of 0
name|pSt
operator|->
name|seconds
operator|=
literal|0
expr_stmt|;
comment|// Calculate the number of years and leap years
name|yrs
operator|=
name|pDt
operator|->
name|year
operator|-
name|TSYNC_TIME_BASE_YEAR
expr_stmt|;
name|lyrs
operator|=
operator|(
name|yrs
operator|+
literal|1
operator|)
operator|/
literal|4
expr_stmt|;
comment|// Convert leap years and years
name|pSt
operator|->
name|seconds
operator|+=
name|lyrs
operator|*
name|SECSPERLEAPYEAR
expr_stmt|;
name|pSt
operator|->
name|seconds
operator|+=
operator|(
name|yrs
operator|-
name|lyrs
operator|)
operator|*
name|SECSPERYEAR
expr_stmt|;
comment|// Convert days, hours, minutes and seconds
name|pSt
operator|->
name|seconds
operator|+=
operator|(
name|pDt
operator|->
name|doy
operator|-
literal|1
operator|)
operator|*
name|SECSPERDAY
expr_stmt|;
name|pSt
operator|->
name|seconds
operator|+=
name|pDt
operator|->
name|hour
operator|*
name|SECSPERHR
expr_stmt|;
name|pSt
operator|->
name|seconds
operator|+=
name|pDt
operator|->
name|minute
operator|*
name|SECSPERMIN
expr_stmt|;
name|pSt
operator|->
name|seconds
operator|+=
name|pDt
operator|->
name|second
expr_stmt|;
comment|// Copy the subseconds count
name|pSt
operator|->
name|ns
operator|=
name|pDt
operator|->
name|ns
expr_stmt|;
block|}
end_function

begin_comment
comment|// End SecTimeFromDoyTime
end_comment

begin_comment
comment|////////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// Function:    DoyTimeFromSecTime
end_comment

begin_comment
comment|// Description: The DoyTimeFromSecTime function converts a specified count
end_comment

begin_comment
comment|//              of seconds since the start of our base time into a SecTimeObj
end_comment

begin_comment
comment|//              structure.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Assumptions: 1. A leap year is any year evenly divisible by 4.  Therefore,
end_comment

begin_comment
comment|//                 this function is only accurate through Feb 28, 2100.
end_comment

begin_comment
comment|//              2. Conversion does not account for leap seconds.
end_comment

begin_comment
comment|////////////////////////////////////////////////////////////////////////////////
end_comment

begin_function
name|void
name|DoyTimeFromSecTime
parameter_list|(
name|DoyTimeObj
modifier|*
name|pDt
parameter_list|,
name|SecTimeObj
modifier|*
name|pSt
parameter_list|)
block|{
name|signed
name|long
name|long
name|secs
decl_stmt|;
comment|// Seconds accumulator variable
name|unsigned
name|int
name|yrs
decl_stmt|;
comment|// Years accumulator variable
name|unsigned
name|int
name|doys
decl_stmt|;
comment|// Days accumulator variable
name|unsigned
name|int
name|hrs
decl_stmt|;
comment|// Hours accumulator variable
name|unsigned
name|int
name|mins
decl_stmt|;
comment|// Minutes accumulator variable
comment|// Convert the seconds count into a signed 64-bit number for calculations
name|secs
operator|=
call|(
name|signed
name|long
name|long
call|)
argument_list|(
name|pSt
operator|->
name|seconds
argument_list|)
expr_stmt|;
comment|// Calculate the number of 4 year chunks
name|yrs
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|secs
operator|/
operator|(
operator|(
name|SECSPERYEAR
operator|*
literal|3
operator|)
operator|+
name|SECSPERLEAPYEAR
operator|)
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|secs
operator|%=
operator|(
operator|(
name|SECSPERYEAR
operator|*
literal|3
operator|)
operator|+
name|SECSPERLEAPYEAR
operator|)
expr_stmt|;
comment|// If there is at least a normal year worth of time left
if|if
condition|(
name|secs
operator|>=
name|SECSPERYEAR
condition|)
block|{
comment|// Increment the number of years and subtract a normal year of time
name|yrs
operator|++
expr_stmt|;
name|secs
operator|-=
name|SECSPERYEAR
expr_stmt|;
block|}
comment|// If there is still at least a normal year worth of time left
if|if
condition|(
name|secs
operator|>=
name|SECSPERYEAR
condition|)
block|{
comment|// Increment the number of years and subtract a normal year of time
name|yrs
operator|++
expr_stmt|;
name|secs
operator|-=
name|SECSPERYEAR
expr_stmt|;
block|}
comment|// If there is still at least a leap year worth of time left
if|if
condition|(
name|secs
operator|>=
name|SECSPERLEAPYEAR
condition|)
block|{
comment|// Increment the number of years and subtract a leap year of time
name|yrs
operator|++
expr_stmt|;
name|secs
operator|-=
name|SECSPERLEAPYEAR
expr_stmt|;
block|}
comment|// Calculate the day of year as the number of days left, then add 1
comment|// because months start on the 1st.
name|doys
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|secs
operator|/
name|SECSPERDAY
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|secs
operator|%=
name|SECSPERDAY
expr_stmt|;
comment|// Calculate the hour
name|hrs
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|secs
operator|/
name|SECSPERHR
argument_list|)
expr_stmt|;
name|secs
operator|%=
name|SECSPERHR
expr_stmt|;
comment|// Calculate the minute
name|mins
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|secs
operator|/
name|SECSPERMIN
argument_list|)
expr_stmt|;
name|secs
operator|%=
name|SECSPERMIN
expr_stmt|;
comment|// Fill in the doytime structure
name|pDt
operator|->
name|year
operator|=
name|yrs
operator|+
name|TSYNC_TIME_BASE_YEAR
expr_stmt|;
name|pDt
operator|->
name|doy
operator|=
name|doys
expr_stmt|;
name|pDt
operator|->
name|hour
operator|=
name|hrs
expr_stmt|;
name|pDt
operator|->
name|minute
operator|=
name|mins
expr_stmt|;
name|pDt
operator|->
name|second
operator|=
operator|(
name|unsigned
name|int
operator|)
name|secs
expr_stmt|;
name|pDt
operator|->
name|ns
operator|=
name|pSt
operator|->
name|ns
expr_stmt|;
block|}
end_function

begin_comment
comment|// End DoyTimeFromSecTime
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_tsyncpci_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

