begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_atom - clock driver for 1-pps signals  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_ATOM
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_include
include|#
directive|include
file|"ppsapi_timepps.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * This driver furnishes an interface for pulse-per-second (PPS) signals  * produced by a cesium clock, timing receiver or related equipment. It  * can be used to remove accumulated jitter and retime a secondary  * server when synchronized to a primary server over a congested, wide-  * area network and before redistributing the time to local clients.  *  * Before this driver becomes active, the local clock must be set to  * within +-500 ms by another means, such as a radio clock or NTP  * itself. There are two ways to connect the PPS signal, normally at TTL  * levels, to the computer. One is to shift to EIA levels and connect to  * pin 8 (DCD) of a serial port. This requires a level converter and  * may require a one-shot flipflop to lengthen the pulse. The other is  * to connect the PPS signal directly to pin 10 (ACK) of a PC paralell  * port. These methods are architecture dependent.  *  * Both methods require a modified device driver and kernel interface  * compatible with the Pulse-per-Second API for Unix-like Operating  * Systems, Version 1.0, RFC-2783 (PPSAPI). Implementations are  * available for FreeBSD, Linux, SunOS, Solaris and Alpha. However, at  * present only the Alpha implementation provides the full generality of  * the API with multiple PPS drivers and multiple handles per driver. If  * the PPSAPI is normally implemented in the /usr/include/sys/timepps.h  * header file and kernel support specific to each operating system.  * However, this driver can operate without this interface if means are  * proviced to call the pps_sample() routine from another driver. Please  * note; if the PPSAPI interface is present, it must be used.  *  * In many configurations a single port is used for the radio timecode  * and PPS signal. In order to provide for this configuration and others  * involving dedicated multiple serial/parallel ports, the driver first  * attempts to open the device /dev/pps%d, where %d is the unit number.  * If this fails, the driver attempts to open the device specified by  * the pps configuration command. If a port is to be shared, the pps  * command must be placed before the radio device(s) and the radio  * device(s) must be placed before the PPS driver(s) in the  * configuration file.  *  * This driver normally uses the PLL/FLL clock discipline implemented in  * the ntpd code. Ordinarily, this is the most accurate means, as the  * median filter in the driver interface is much larger than in the  * kernel. However, if the systemic clock frequency error is large (tens  * to hundreds of PPM), it's better to used the kernel support, if  * available.  *  * Fudge Factors  *  * If flag2 is dim (default), the on-time epoch is the assert edge of  * the PPS signal; if lit, the on-time epoch is the clear edge. If flag2  * is lit, the assert edge is used; if flag3 is dim (default), the  * kernel PPS support is disabled; if lit it is enabled. The time1  * parameter can be used to compensate for miscellaneous device driver  * and OS delays.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/pps%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (about 1 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"PPS\0"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"PPS Clock Discipline"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|NANOSECOND
value|1000000000
end_define

begin_comment
comment|/* one second (ns) */
end_comment

begin_define
define|#
directive|define
name|RANGEGATE
value|500000
end_define

begin_comment
comment|/* range gate (ns) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|peer
modifier|*
name|pps_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* atom driver for PPS sources */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_comment
comment|/*  * PPS unit control structure  */
end_comment

begin_struct
struct|struct
name|ppsunit
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* last timestamp */
name|int
name|fddev
decl_stmt|;
comment|/* pps device descriptor */
name|pps_params_t
name|pps_params
decl_stmt|;
comment|/* pps parameters */
name|pps_info_t
name|pps_info
decl_stmt|;
comment|/* last pps data */
name|pps_handle_t
name|handle
decl_stmt|;
comment|/* pps handlebars */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|atom_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|atom_control
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom_timer
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atom_ppsapi
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_decl_stmt
name|struct
name|refclock
name|refclock_atom
init|=
block|{
name|atom_start
block|,
comment|/* start up driver */
name|atom_shutdown
block|,
comment|/* shut down driver */
name|atom_poll
block|,
comment|/* transmit poll message */
name|atom_control
block|,
comment|/* fudge control */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* buginfo (not used) */
name|atom_timer
block|,
comment|/* called once per second */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_atom
init|=
block|{
name|atom_start
block|,
comment|/* start up driver */
name|atom_shutdown
block|,
comment|/* shut down driver */
name|atom_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* fudge control (not used) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* buginfo (not used) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPPSAPI */
end_comment

begin_comment
comment|/*  * atom_start - initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|atom_start
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* unit number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
specifier|register
name|struct
name|ppsunit
modifier|*
name|up
decl_stmt|;
name|char
name|device
index|[
literal|80
index|]
decl_stmt|;
name|int
name|mode
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
comment|/* 	 * Allocate and initialize unit structure 	 */
name|pps_peer
operator|=
name|peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|pp
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|up
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppsunit
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppsunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Open PPS device. This can be any serial or parallel port and 	 * not necessarily the port used for the associated radio. 	 */
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|up
operator|->
name|fddev
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fddev
operator|<=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: %s: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Light off the PPSAPI interface. 	 */
if|if
condition|(
name|time_pps_create
argument_list|(
name|up
operator|->
name|fddev
argument_list|,
operator|&
name|up
operator|->
name|handle
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: time_pps_create failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the mode is nonzero, use that for the time_pps_setparams() 	 * mode; otherwise, PPS_CAPTUREASSERT. Enable kernel PPS if 	 * flag3 is lit. 	 */
name|mode
operator|=
name|peer
operator|->
name|ttl
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|mode
operator|=
name|PPS_CAPTUREASSERT
expr_stmt|;
return|return
operator|(
name|atom_ppsapi
argument_list|(
name|peer
argument_list|,
name|mode
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* HAVE_PPSAPI */
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
block|}
end_function

begin_comment
comment|/*  * atom_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|atom_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* unit number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|ppsunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|ppsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
if|if
condition|(
name|up
operator|->
name|fddev
operator|>
literal|0
condition|)
name|close
argument_list|(
name|up
operator|->
name|fddev
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|handle
operator|!=
literal|0
condition|)
name|time_pps_destroy
argument_list|(
name|up
operator|->
name|handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
if|if
condition|(
name|pps_peer
operator|==
name|peer
condition|)
name|pps_peer
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_comment
comment|/*  * atom_control - fudge control  */
end_comment

begin_function
specifier|static
name|void
name|atom_control
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* unit (not used */
name|struct
name|refclockstat
modifier|*
name|in
parameter_list|,
comment|/* input parameters (not uded) */
name|struct
name|refclockstat
modifier|*
name|out
parameter_list|,
comment|/* output parameters (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ttl
operator|!=
literal|0
condition|)
comment|/* all legal modes must be nonzero */
return|return;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
name|mode
operator|=
name|PPS_CAPTURECLEAR
expr_stmt|;
else|else
name|mode
operator|=
name|PPS_CAPTUREASSERT
expr_stmt|;
name|atom_ppsapi
argument_list|(
name|peer
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize PPSAPI  */
end_comment

begin_function
name|int
name|atom_ppsapi
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|mode
comment|/* mode */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|ppsunit
modifier|*
name|up
decl_stmt|;
name|int
name|capability
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|ppsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|handle
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|time_pps_getcap
argument_list|(
name|up
operator|->
name|handle
argument_list|,
operator|&
name|capability
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: time_pps_getcap failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|up
operator|->
name|pps_params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pps_params_t
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|pps_params
operator|.
name|api_version
operator|=
name|PPS_API_VERS_1
expr_stmt|;
name|up
operator|->
name|pps_params
operator|.
name|mode
operator|=
name|mode
operator||
name|PPS_TSFMT_TSPEC
expr_stmt|;
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|up
operator|->
name|handle
argument_list|,
operator|&
name|up
operator|->
name|pps_params
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: time_pps_setparams failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
condition|)
block|{
if|if
condition|(
name|time_pps_kcbind
argument_list|(
name|up
operator|->
name|handle
argument_list|,
name|PPS_KC_HARDPPS
argument_list|,
name|up
operator|->
name|pps_params
operator|.
name|mode
operator|&
operator|~
name|PPS_TSFMT_TSPEC
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: time_pps_kcbind failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pps_enable
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|time_pps_getparams
argument_list|(
name|up
operator|->
name|handle
argument_list|,
operator|&
name|up
operator|->
name|pps_params
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"refclock_ppsapi: fd %d capability 0x%x version %d mode 0x%x\n"
argument_list|,
name|up
operator|->
name|fddev
argument_list|,
name|capability
argument_list|,
name|up
operator|->
name|pps_params
operator|.
name|api_version
argument_list|,
name|up
operator|->
name|pps_params
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * atom_timer - called once per second  *  * This routine is called once per second when the PPSAPI interface is  * present. It snatches the PPS timestamp from the kernel and saves the  * sign-extended fraction in a circular buffer for processing at the  * next poll event.  */
end_comment

begin_function
specifier|static
name|void
name|atom_timer
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* unit number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
specifier|register
name|struct
name|ppsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pps_info_t
name|pps_info
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|,
name|ts
decl_stmt|;
name|long
name|sec
decl_stmt|,
name|nsec
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* monitor buffer */
comment|/* 	 * Convert the timespec nanoseconds field to signed double and 	 * save in the median filter. for billboards. No harm is done if 	 * previous data are overwritten. If the discipline comes bum or 	 * the data grow stale, just forget it. A range gate rejects new 	 * samples if less than a jiggle time from the next second. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|ppsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|handle
operator|==
literal|0
condition|)
return|return;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pps_info
argument_list|,
operator|&
name|up
operator|->
name|pps_info
argument_list|,
sizeof|sizeof
argument_list|(
name|pps_info_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_pps_fetch
argument_list|(
name|up
operator|->
name|handle
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|up
operator|->
name|pps_info
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|up
operator|->
name|pps_params
operator|.
name|mode
operator|&
name|PPS_CAPTUREASSERT
condition|)
block|{
name|ts
operator|=
name|up
operator|->
name|pps_info
operator|.
name|assert_timestamp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|pps_params
operator|.
name|mode
operator|&
name|PPS_CAPTURECLEAR
condition|)
block|{
name|ts
operator|=
name|up
operator|->
name|pps_info
operator|.
name|clear_timestamp
expr_stmt|;
block|}
else|else
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * There can be zero, one or two PPS seconds between polls. If 	 * zero, either the poll clock is slightly faster than the PPS 	 * clock or the PPS clock has died. If the PPS clock advanced 	 * once between polls, we make sure the fraction time difference 	 * since the last sample is within the range gate of 5 ms (500 	 * PPM). If the PPS clock advanced twice since the last poll, 	 * the poll bracketed more than one second and the first second 	 * was lost to a slip. Since the interval since the last sample 	 * found is now two seconds, just widen the range gate. If the 	 * PPS clock advanced three or more times, either the signal has 	 * failed for a number of seconds or we have runts, in which 	 * case just ignore them. 	 * 	 * If flag4 is lit, record each second offset to clockstats. 	 * That's so we can make awesome Allan deviation plots. 	 */
name|sec
operator|=
name|ts
operator|.
name|tv_sec
operator|-
name|up
operator|->
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|nsec
operator|=
name|ts
operator|.
name|tv_nsec
operator|-
name|up
operator|->
name|ts
operator|.
name|tv_nsec
expr_stmt|;
name|up
operator|->
name|ts
operator|=
name|ts
expr_stmt|;
if|if
condition|(
name|nsec
operator|<
literal|0
condition|)
block|{
name|sec
operator|--
expr_stmt|;
name|nsec
operator|+=
name|NANOSECOND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nsec
operator|>=
name|NANOSECOND
condition|)
block|{
name|sec
operator|++
expr_stmt|;
name|nsec
operator|-=
name|NANOSECOND
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|*
name|NANOSECOND
operator|+
name|nsec
operator|>
name|NANOSECOND
operator|+
name|RANGEGATE
condition|)
return|return;
elseif|else
if|if
condition|(
name|sec
operator|*
name|NANOSECOND
operator|+
name|nsec
operator|<
name|NANOSECOND
operator|-
name|RANGEGATE
condition|)
return|return;
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
operator|=
name|ts
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|dtemp
operator|=
name|ts
operator|.
name|tv_nsec
operator|*
name|FRAC
operator|/
literal|1e9
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>=
name|FRAC
condition|)
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
operator|++
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|.
name|l_uf
operator|=
operator|(
name|u_int32
operator|)
name|dtemp
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|>
name|NANOSECOND
operator|/
literal|2
condition|)
name|ts
operator|.
name|tv_nsec
operator|-=
name|NANOSECOND
expr_stmt|;
name|dtemp
operator|=
operator|-
operator|(
name|double
operator|)
name|ts
operator|.
name|tv_nsec
operator|/
name|NANOSECOND
expr_stmt|;
name|SAMPLE
argument_list|(
name|dtemp
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%.9f"
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"atom_timer: %lu %f %f\n"
argument_list|,
name|current_time
argument_list|,
name|dtemp
argument_list|,
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * pps_sample - receive PPS data from some other clock driver  *  * This routine is called once per second when the external clock driver  * processes PPS information. It processes the PPS timestamp and saves  * the sign-extended fraction in a circular buffer for processing at the  * next poll event. This works only for a single PPS device.  *  * The routine should be used by another configured driver ONLY when  * this driver is configured as well and the PPSAPI is NOT in use.  */
end_comment

begin_function
name|int
name|pps_sample
parameter_list|(
name|l_fp
modifier|*
name|offset
comment|/* PPS offset */
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|l_fp
name|lftmp
decl_stmt|;
name|double
name|doffset
decl_stmt|;
name|peer
operator|=
name|pps_peer
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
comment|/* 	 * Convert the timeval to l_fp and save for billboards. Sign- 	 * extend the fraction and stash in the buffer. No harm is done 	 * if previous data are overwritten. If the discipline comes bum 	 * or the data grow stale, just forget it. 	 */
name|pp
operator|->
name|lastrec
operator|=
operator|*
name|offset
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|lftmp
argument_list|)
expr_stmt|;
name|L_ADDF
argument_list|(
operator|&
name|lftmp
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_f
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|lftmp
argument_list|,
name|doffset
argument_list|)
expr_stmt|;
name|SAMPLE
argument_list|(
operator|-
name|doffset
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * atom_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|atom_poll
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* unit number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
comment|/* 	 * Valid time is returned only if the prefer peer has survived 	 * the intersection algorithm and within 0.4 s of local time 	 * and not too long ago. This ensures the PPS time is within 	 * 0.5 s of the local time and the seconds numbering is 	 * unambiguous. Note that the leap bits, stratum and refid are 	 * set from the prefer peer, unless overriden by a fudge 	 * command. 	 */
if|if
condition|(
name|pp
operator|->
name|codeproc
operator|==
name|pp
operator|->
name|coderecv
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sys_prefer
operator|==
name|NULL
condition|)
block|{
name|pp
operator|->
name|codeproc
operator|=
name|pp
operator|->
name|coderecv
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|sys_prefer
operator|->
name|offset
argument_list|)
operator|>=
literal|0.4
condition|)
block|{
name|pp
operator|->
name|codeproc
operator|=
name|pp
operator|->
name|coderecv
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|leap
operator|=
name|sys_prefer
operator|->
name|leap
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|stratum
operator|>=
name|STRATUM_UNSPEC
condition|)
name|peer
operator|->
name|stratum
operator|=
name|sys_prefer
operator|->
name|stratum
expr_stmt|;
else|else
name|peer
operator|->
name|stratum
operator|=
name|pp
operator|->
name|stratum
expr_stmt|;
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_atom_bs
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pps_sample
parameter_list|(
name|l_fp
modifier|*
name|offset
comment|/* PPS offset */
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

