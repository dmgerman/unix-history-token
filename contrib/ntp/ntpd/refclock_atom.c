begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_atom - clock driver for 1-pps signals  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_ATOM
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<timepps.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * This driver furnishes an interface for pulse-per-second (PPS) signals  * produced by a cesium clock, timing receiver or related equipment. It  * can be used to remove accumulated jitter and retime a secondary  * server when synchronized to a primary server over a congested, wide-  * area network and before redistributing the time to local clients.  *  * Before this driver becomes active, the local clock must be set to  * within +-500 ms by another means, such as a radio clock or NTP  * itself. There are two ways to connect the PPS signal, normally at TTL  * levels, to the computer. One is to shift to EIA levels and connect to  * pin 8 (DCD) of a serial port. This requires a level converter and  * may require a one-shot flipflop to lengthen the pulse. The other is  * to connect the PPS signal directly to pin 10 (ACK) of a PC paralell  * port. These methods are architecture dependent.  *  * Both methods require a modified device driver and kernel interface  * compatible with the Pulse-per-Second API for Unix-like Operating  * Systems, Version 1.0, RFC-2783 (PPSAPI). Implementations are  * available for FreeBSD, Linux, SunOS, Solaris and Alpha. However, at  * present only the Alpha implementation provides the full generality of  * the API with multiple PPS drivers and multiple handles per driver.  *  * In many configurations a single port is used for the radio timecode  * and PPS signal. In order to provide for this configuration and others  * involving dedicated multiple serial/parallel ports, the driver first  * attempts to open the device /dev/pps%d, where %d is the unit number.  * If this fails, the driver attempts to open the device specified by  * the pps configuration command. If a port is to be shared, the pps  * command must be placed before the radio device(s) and the radio  * device(s) must be placed before the PPS driver(s) in the  * configuration file.  *  * This driver normally uses the PLL/FLL clock discipline implemented in  * the ntpd code. If kernel support is available, the kernel PLL/FLL  * clock discipline is used instead. The default configuration is not to  * use the kernel PPS discipline, if present. The kernel PPS discipline  * can be enabled using the pps command.  *  * Fudge Factors  *  * There are no special fudge factors other than the generic. The fudge  * time1 parameter can be used to compensate for miscellaneous device  * driver and OS delays.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|pps_assert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* selects rising or falling edge */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|pps_hardpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enables the kernel PPS interface */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/pps%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (about 1 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"PPS\0"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"PPS Clock Discipline"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|NANOSECOND
value|1000000000
end_define

begin_comment
comment|/* one second (ns) */
end_comment

begin_define
define|#
directive|define
name|RANGEGATE
value|500000
end_define

begin_comment
comment|/* range gate (ns) */
end_comment

begin_define
define|#
directive|define
name|ASTAGE
value|8
end_define

begin_comment
comment|/* filter stages */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|peer
modifier|*
name|pps_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* atom driver for PPS sources */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_comment
comment|/*  * PPS unit control structure  */
end_comment

begin_struct
struct|struct
name|ppsunit
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* last timestamp */
name|int
name|fddev
decl_stmt|;
comment|/* pps device descriptor */
name|pps_params_t
name|pps_params
decl_stmt|;
comment|/* pps parameters */
name|pps_info_t
name|pps_info
decl_stmt|;
comment|/* last pps data */
name|pps_handle_t
name|handle
decl_stmt|;
comment|/* pps handlebars */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|atom_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|atom_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom_control
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atom_pps
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atom_ppsapi
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_atom
init|=
block|{
name|atom_start
block|,
comment|/* start up driver */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|atom_shutdown
block|,
comment|/* shut down driver */
else|#
directive|else
name|noentry
block|,
comment|/* shut down driver */
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
name|atom_poll
block|,
comment|/* transmit poll message */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|atom_control
block|,
comment|/* fudge control */
else|#
directive|else
name|noentry
block|,
comment|/* fudge control */
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
name|noentry
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* not used (old atom_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * atom_start - initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|atom_start
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* unit number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
specifier|register
name|struct
name|ppsunit
modifier|*
name|up
decl_stmt|;
name|char
name|device
index|[
literal|80
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
comment|/* 	 * Allocate and initialize unit structure 	 */
name|pps_peer
operator|=
name|peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|ASTAGE
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|up
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppsunit
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppsunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Open PPS device. If this fails and some driver has already 	 * opened the associated radio device, fdpps has the file 	 * descriptor for it. 	 */
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|up
operator|->
name|fddev
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fddev
operator|<=
literal|0
operator|&&
name|fdpps
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|device
argument_list|,
name|pps_device
argument_list|)
expr_stmt|;
name|up
operator|->
name|fddev
operator|=
name|fdpps
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|fddev
operator|<=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: %s: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Light off the PPSAPI interface. If this PPS device is shared 	 * with the radio device, take the default options from the pps 	 * command. This is for legacy purposes. 	 */
if|if
condition|(
name|time_pps_create
argument_list|(
name|up
operator|->
name|fddev
argument_list|,
operator|&
name|up
operator|->
name|handle
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: time_pps_create failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|atom_ppsapi
argument_list|(
name|peer
argument_list|,
name|pps_assert
argument_list|,
name|pps_hardpps
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* HAVE_PPSAPI */
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_comment
comment|/*  * atom_control - fudge control  */
end_comment

begin_function
specifier|static
name|void
name|atom_control
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* unit (not used */
name|struct
name|refclockstat
modifier|*
name|in
parameter_list|,
comment|/* input parameters (not uded) */
name|struct
name|refclockstat
modifier|*
name|out
parameter_list|,
comment|/* output parameters (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|atom_ppsapi
argument_list|(
name|peer
argument_list|,
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
argument_list|,
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize PPSAPI  */
end_comment

begin_function
name|int
name|atom_ppsapi
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|enb_clear
parameter_list|,
comment|/* clear enable */
name|int
name|enb_hardpps
comment|/* hardpps enable */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|ppsunit
modifier|*
name|up
decl_stmt|;
name|int
name|capability
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|ppsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|time_pps_getcap
argument_list|(
name|up
operator|->
name|handle
argument_list|,
operator|&
name|capability
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: time_pps_getcap failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|up
operator|->
name|pps_params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pps_params_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enb_clear
condition|)
name|up
operator|->
name|pps_params
operator|.
name|mode
operator|=
name|capability
operator|&
name|PPS_CAPTURECLEAR
expr_stmt|;
else|else
name|up
operator|->
name|pps_params
operator|.
name|mode
operator|=
name|capability
operator|&
name|PPS_CAPTUREASSERT
expr_stmt|;
if|if
condition|(
operator|!
name|up
operator|->
name|pps_params
operator|.
name|mode
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: invalid capture edge %d"
argument_list|,
name|pps_assert
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|up
operator|->
name|pps_params
operator|.
name|mode
operator||=
name|PPS_TSFMT_TSPEC
expr_stmt|;
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|up
operator|->
name|handle
argument_list|,
operator|&
name|up
operator|->
name|pps_params
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: time_pps_setparams failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|enb_hardpps
condition|)
block|{
if|if
condition|(
name|time_pps_kcbind
argument_list|(
name|up
operator|->
name|handle
argument_list|,
name|PPS_KC_HARDPPS
argument_list|,
name|up
operator|->
name|pps_params
operator|.
name|mode
operator|&
operator|~
name|PPS_TSFMT_TSPEC
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_atom: time_pps_kcbind failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pps_enable
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|time_pps_getparams
argument_list|(
name|up
operator|->
name|handle
argument_list|,
operator|&
name|up
operator|->
name|pps_params
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"refclock_ppsapi: fd %d capability 0x%x version %d mode 0x%x kern %d\n"
argument_list|,
name|up
operator|->
name|fddev
argument_list|,
name|capability
argument_list|,
name|up
operator|->
name|pps_params
operator|.
name|api_version
argument_list|,
name|up
operator|->
name|pps_params
operator|.
name|mode
argument_list|,
name|enb_hardpps
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * atom_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|atom_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* unit number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|ppsunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|ppsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fddev
operator|>
literal|0
condition|)
name|close
argument_list|(
name|up
operator|->
name|fddev
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|handle
operator|!=
literal|0
condition|)
name|time_pps_destroy
argument_list|(
name|up
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|pps_peer
operator|==
name|peer
condition|)
name|pps_peer
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * atom_pps - receive data from the PPSAPI interface  *  * This routine is called once per second when the PPSAPI interface is  * present. It snatches the PPS timestamp from the kernel and saves the  * sign-extended fraction in a circular buffer for processing at the  * next poll event.  */
end_comment

begin_function
specifier|static
name|int
name|atom_pps
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
specifier|register
name|struct
name|ppsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pps_info_t
name|pps_info
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|,
name|ts
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
comment|/* 	 * Convert the timespec nanoseconds field to signed double and 	 * save in the median filter. for billboards. No harm is done if 	 * previous data are overwritten. If the discipline comes bum or 	 * the data grow stale, just forget it. A range gate rejects new 	 * samples if less than a jiggle time from the next second. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|ppsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|handle
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pps_info
argument_list|,
operator|&
name|up
operator|->
name|pps_info
argument_list|,
sizeof|sizeof
argument_list|(
name|pps_info_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_pps_fetch
argument_list|(
name|up
operator|->
name|handle
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|up
operator|->
name|pps_info
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|up
operator|->
name|pps_params
operator|.
name|mode
operator|&
name|PPS_CAPTUREASSERT
condition|)
block|{
if|if
condition|(
name|pps_info
operator|.
name|assert_sequence
operator|==
name|up
operator|->
name|pps_info
operator|.
name|assert_sequence
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ts
operator|=
name|up
operator|->
name|pps_info
operator|.
name|assert_timestamp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|pps_params
operator|.
name|mode
operator|&
name|PPS_CAPTURECLEAR
condition|)
block|{
if|if
condition|(
name|pps_info
operator|.
name|clear_sequence
operator|==
name|up
operator|->
name|pps_info
operator|.
name|clear_sequence
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ts
operator|=
name|up
operator|->
name|pps_info
operator|.
name|clear_timestamp
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|ts
operator|.
name|tv_sec
operator|==
name|up
operator|->
name|ts
operator|.
name|tv_sec
operator|&&
name|ts
operator|.
name|tv_nsec
operator|-
name|up
operator|->
name|ts
operator|.
name|tv_nsec
operator|>
name|NANOSECOND
operator|-
name|RANGEGATE
operator|)
operator|||
operator|(
name|ts
operator|.
name|tv_sec
operator|-
name|up
operator|->
name|ts
operator|.
name|tv_sec
operator|==
literal|1
operator|&&
name|ts
operator|.
name|tv_nsec
operator|-
name|up
operator|->
name|ts
operator|.
name|tv_nsec
operator|<
name|RANGEGATE
operator|)
operator|)
condition|)
block|{
name|up
operator|->
name|ts
operator|=
name|ts
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|up
operator|->
name|ts
operator|=
name|ts
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
operator|=
name|ts
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|dtemp
operator|=
name|ts
operator|.
name|tv_nsec
operator|*
name|FRAC
operator|/
literal|1e9
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>=
name|FRAC
condition|)
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
operator|++
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|.
name|l_uf
operator|=
operator|(
name|u_int32
operator|)
name|dtemp
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|>
name|NANOSECOND
operator|/
literal|2
condition|)
name|ts
operator|.
name|tv_nsec
operator|-=
name|NANOSECOND
expr_stmt|;
name|dtemp
operator|=
operator|-
operator|(
name|double
operator|)
name|ts
operator|.
name|tv_nsec
operator|/
name|NANOSECOND
expr_stmt|;
name|SAMPLE
argument_list|(
name|dtemp
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"atom_pps %f %f\n"
argument_list|,
name|dtemp
argument_list|,
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * pps_sample - receive PPS data from some other clock driver  *  * This routine is called once per second when the external clock driver  * processes PPS information. It processes the PPS timestamp and saves  * the sign-extended fraction in a circular buffer for processing at the  * next poll event. This works only for a single PPS device.  */
end_comment

begin_function
name|int
name|pps_sample
parameter_list|(
name|l_fp
modifier|*
name|offset
comment|/* PPS offset */
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|l_fp
name|lftmp
decl_stmt|;
name|double
name|doffset
decl_stmt|;
name|peer
operator|=
name|pps_peer
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
comment|/* nobody home */
return|return
operator|(
literal|1
operator|)
return|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
comment|/* 	 * Convert the timeval to l_fp and save for billboards. Sign- 	 * extend the fraction and stash in the buffer. No harm is done 	 * if previous data are overwritten. If the discipline comes bum 	 * or the data grow stale, just forget it. 	 */
name|pp
operator|->
name|lastrec
operator|=
operator|*
name|offset
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|lftmp
argument_list|)
expr_stmt|;
name|L_ADDF
argument_list|(
operator|&
name|lftmp
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_f
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|lftmp
argument_list|,
name|doffset
argument_list|)
expr_stmt|;
name|SAMPLE
argument_list|(
operator|-
name|doffset
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * atom_poll - called by the transmit procedure  *  * This routine is called once per second when in burst mode to save PPS  * sample offsets in the median filter. At the end of the burst period  * the samples are processed as a heap and the clock filter updated.  */
end_comment

begin_function
specifier|static
name|void
name|atom_poll
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* unit number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|int
name|err
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
comment|/* 	 * Accumulate samples in the median filter. If a noise sample, 	 * return with no prejudice; if a protocol error, get mean; 	 * otherwise, cool. At the end of each poll interval, do a 	 * little bookeeping and process the surviving samples. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|err
operator|=
name|atom_pps
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
comment|/* 	 * Valid time is returned only if the prefer peer has survived 	 * the intersection algorithm and within clock_max of local time 	 * and not too long ago. This ensures the PPS time is within 	 * +-0.5 s of the local time and the seconds numbering is 	 * unambiguous. Note that the leap bits are set no-warning on 	 * the first valid update and the stratum is set at the prefer 	 * peer. 	 */
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
return|return;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|codeproc
operator|==
name|pp
operator|->
name|coderecv
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|ASTAGE
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|sys_prefer
condition|)
block|{
name|pp
operator|->
name|codeproc
operator|=
name|pp
operator|->
name|coderecv
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|ASTAGE
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|sys_prefer
operator|->
name|offset
argument_list|)
operator|>
name|clock_max
condition|)
block|{
name|pp
operator|->
name|codeproc
operator|=
name|pp
operator|->
name|coderecv
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|ASTAGE
expr_stmt|;
return|return;
block|}
name|peer
operator|->
name|stratum
operator|=
name|sys_prefer
operator|->
name|stratum
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
literal|1
condition|)
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
else|else
name|peer
operator|->
name|refid
operator|=
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|ASTAGE
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_atom_bs
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pps_sample
parameter_list|(
name|l_fp
modifier|*
name|offset
comment|/* PPS offset */
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

