begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_atom - clock driver for 1-pps signals  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_ATOM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TERMIOS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PPSCLOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<timepps.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * This driver furnishes an interface for pulse-per-second (PPS) signals  * produced by a cesium clock, timing receiver or related  equipment. It  * can be used to remove accumulated jitter and retime a secondary  * server when synchronized to a primary server over a congested, wide-  * area network and before redistributing the time to local clients.  *  * In order for this driver to work, the local clock must be set to  * within +-500 ms by another means, such as a radio clock or NTP  * itself. The 1-pps signal is connected via a serial port and gadget  * box consisting of a one-shot flopflop and RS232 level converter.  * Conntection is either via the carrier detect (DCD) lead or via the  * receive data (RD) lead. The incidental jitter using the DCD lead is  * essentially the interrupt latency. The incidental jitter using the RD  * lead has an additional component due to the line sampling clock. When  * operated at 38.4 kbps, this arrangement has a worst-case jitter less  * than 26 us.  *  * There are four ways in which this driver can be used. They are  * described in decreasing order of merit below. The first way uses the  * ppsapi STREAMS module and the LDISC_PPS line discipline, while the  * second way uses the ppsclock STREAMS module and the LDISC_PPS line  * discipline. Either of these works only for the baseboard serial ports  * of the Sun SPARC IPC and clones. However, the ppsapi uses the  * proposed IETF interface expected to become standard for PPS signals.  * The serial port to be used is specified by the pps command in the  * configuration file. This driver reads the timestamp directly by a  * designated ioctl() system call.  *  * The third way uses the LDISC_CLKPPS line discipline and works for  * any architecture supporting a serial port. If after a few seconds  * this driver finds no ppsclock module configured, it attempts to open  * a serial port device /dev/pps%d, where %d is the unit number, and  * assign the LDISC_CLKPPS line discipline to it. If the line discipline  * fails, no harm is done except the accuracy is reduced somewhat. The  * pulse generator in the gadget box is adjusted to produce a start bit  * of length 26 usec at 38400 bps. Used with the LDISC_CLKPPS line  * discipline, this produces an ASCII DEL character ('\377') followed by  * a timestamp at each seconds epoch.   *  * The fourth way involves an auxiliary radio clock driver which calls  * the PPS driver with a timestamp captured by that driver. This use is  * documented in the source code for the driver(s) involved.  Note that  * some drivers collect the sample information themselves before calling  * pps_sample(), and others call knowing only that they are running  * shortly after an on-time tick and they expect to retrieve the PPS  * offset, fudge their result, and insert it into the timestream.  *  * Fudge Factors  *  * There are no special fudge factors other than the generic. The fudge  * time1 parameter can be used to compensate for miscellaneous UART and  * OS delays. Allow about 247 us for uart delays at 38400 bps and about  * 1 ms for STREAMS nonsense with older workstations. Velocities may  * vary with modern workstations.   */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|pps_assert
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TTYCLK
end_ifdef

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/pps%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|B38400
end_ifdef

begin_define
define|#
directive|define
name|SPEED232
value|B38400
end_define

begin_comment
comment|/* uart speed (38400 baud) */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SPEED232
value|EXTB
end_define

begin_comment
comment|/* as above */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TTYCLK */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (about 1 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"PPS\0"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"PPS Clock Discipline"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|FLAG_TTY
value|0x01
end_define

begin_comment
comment|/* tty_clk heard from */
end_comment

begin_define
define|#
directive|define
name|FLAG_PPS
value|0x02
end_define

begin_comment
comment|/* ppsclock heard from */
end_comment

begin_define
define|#
directive|define
name|FLAG_AUX
value|0x04
end_define

begin_comment
comment|/* auxiliary PPS source */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|peer
modifier|*
name|pps_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* atom driver for auxiliary PPS sources */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TTYCLK
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|atom_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TTYCLK */
end_comment

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|atomunit
block|{
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|pps_info_t
name|pps_info
decl_stmt|;
comment|/* pps_info control */
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
ifdef|#
directive|ifdef
name|PPS
name|struct
name|ppsclockev
name|ev
decl_stmt|;
comment|/* ppsclock control */
endif|#
directive|endif
comment|/* PPS */
name|int
name|flags
decl_stmt|;
comment|/* flags that wave */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|atom_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|atom_pps
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS || HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_atom
init|=
block|{
name|atom_start
block|,
comment|/* start up driver */
name|atom_shutdown
block|,
comment|/* shut down driver */
name|atom_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old atom_control) */
name|noentry
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* not used (old atom_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * atom_start - initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|atom_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|TTYCLK
name|int
name|fd
init|=
literal|0
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
name|int
name|ldisc
init|=
name|LDISC_CLKPPS
decl_stmt|;
endif|#
directive|endif
comment|/* TTYCLK */
name|pps_peer
operator|=
name|peer
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TTYCLK
if|#
directive|if
name|defined
argument_list|(
name|SCO5_CLOCK
argument_list|)
name|ldisc
operator|=
name|LDISC_RAW
expr_stmt|;
comment|/* DCD timestamps without any line discipline */
endif|#
directive|endif
comment|/* 	 * Open serial port. Use LDISC_CLKPPS line discipline only 	 * if the LDISC_PPS line discipline is not availble, 	 */
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
if|if
condition|(
name|fdpps
operator|<=
literal|0
condition|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|ldisc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|FLAG_TTY
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TTYCLK */
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|atomunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TTYCLK
if|if
condition|(
name|flags
operator|&
name|FLAG_TTY
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TTYCLK */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atomunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
ifdef|#
directive|ifdef
name|TTYCLK
if|if
condition|(
name|flags
operator|&
name|FLAG_TTY
condition|)
block|{
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|atom_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* TTYCLK */
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * atom_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|atom_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
ifdef|#
directive|ifdef
name|TTYCLK
if|if
condition|(
name|up
operator|->
name|flags
operator|&
name|FLAG_TTY
condition|)
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TTYCLK */
if|if
condition|(
name|pps_peer
operator|==
name|peer
condition|)
name|pps_peer
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
end_if

begin_comment
comment|/*  * atom_pps - receive data from the LDISC_PPS discipline  */
end_comment

begin_function
specifier|static
name|int
name|atom_pps
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|struct
name|timespec
name|timeout
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMESPEC
name|struct
name|timespec
name|ts
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
name|ts
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TIMESPEC */
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
name|l_fp
name|lftmp
decl_stmt|;
name|double
name|doffset
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
name|int
name|request
init|=
ifdef|#
directive|ifdef
name|HAVE_CIOGETEV
name|CIOGETEV
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIOCGPPSEV
name|TIOCGPPSEV
endif|#
directive|endif
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
comment|/* 	 * This routine is called once per second when the LDISC_PPS 	 * discipline is present. It snatches the pps timestamp from the 	 * kernel and saves the sign-extended fraction in a circular 	 * buffer for processing at the next poll event. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Convert the timeval to l_fp and save for billboards. Sign- 	 * extend the fraction and stash in the buffer. No harm is done 	 * if previous data are overwritten. If the discipline comes bum 	 * or the data grow stale, just forget it. Round the nanoseconds 	 * to microseconds with great care. 	 */
if|if
condition|(
name|fdpps
operator|<=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|up
operator|->
name|pps_info
operator|.
name|assert_sequence
expr_stmt|;
if|if
condition|(
name|time_pps_fetch
argument_list|(
name|fdpps
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|up
operator|->
name|pps_info
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|2
operator|)
return|;
if|if
condition|(
name|i
operator|==
name|up
operator|->
name|pps_info
operator|.
name|assert_sequence
condition|)
return|return
operator|(
literal|3
operator|)
return|;
if|if
condition|(
name|pps_assert
condition|)
name|ts
operator|=
name|up
operator|->
name|pps_info
operator|.
name|assert_timestamp
expr_stmt|;
else|else
name|ts
operator|=
name|up
operator|->
name|pps_info
operator|.
name|clear_timestamp
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
operator|=
name|ts
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
operator|(
name|ts
operator|.
name|tv_nsec
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|>
literal|1000000
condition|)
block|{
name|ts
operator|.
name|tv_nsec
operator|-=
literal|1000000
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|++
expr_stmt|;
block|}
name|TVUTOTSF
argument_list|(
name|ts
operator|.
name|tv_nsec
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_uf
argument_list|)
expr_stmt|;
else|#
directive|else
name|i
operator|=
name|up
operator|->
name|ev
operator|.
name|serial
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fdpps
argument_list|,
name|request
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|up
operator|->
name|ev
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|2
operator|)
return|;
if|if
condition|(
name|i
operator|==
name|up
operator|->
name|ev
operator|.
name|serial
condition|)
return|return
operator|(
literal|3
operator|)
return|;
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
operator|=
name|up
operator|->
name|ev
operator|.
name|tv
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|up
operator|->
name|ev
operator|.
name|tv
operator|.
name|tv_usec
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_uf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
name|up
operator|->
name|flags
operator||=
name|FLAG_PPS
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|lftmp
argument_list|)
expr_stmt|;
name|L_ADDF
argument_list|(
operator|&
name|lftmp
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_f
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|lftmp
argument_list|,
name|doffset
argument_list|)
expr_stmt|;
name|SAMPLE
argument_list|(
operator|-
name|doffset
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS || HAVE_PPSAPI */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TTYCLK
end_ifdef

begin_comment
comment|/*  * atom_receive - receive data from the LDISC_CLK discipline  */
end_comment

begin_function
specifier|static
name|void
name|atom_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|l_fp
name|lftmp
decl_stmt|;
name|double
name|doffset
decl_stmt|;
comment|/* 	 * This routine is called once per second when the serial 	 * interface is in use. It snatches the timestamp from the 	 * buffer and saves the sign-extended fraction in a circular 	 * buffer for processing at the next poll event. 	 */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
comment|/* 	 * Save the timestamp for billboards. Sign-extend the fraction 	 * and stash in the buffer. No harm is done if previous data are 	 * overwritten. Do this only if the ppsclock gizmo is not 	 * working. 	 */
if|if
condition|(
name|up
operator|->
name|flags
operator|&
name|FLAG_PPS
condition|)
return|return;
name|L_CLR
argument_list|(
operator|&
name|lftmp
argument_list|)
expr_stmt|;
name|L_ADDF
argument_list|(
operator|&
name|lftmp
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_f
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|lftmp
argument_list|,
name|doffset
argument_list|)
expr_stmt|;
name|SAMPLE
argument_list|(
operator|-
name|doffset
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TTYCLK */
end_comment

begin_comment
comment|/*  * pps_sample - receive PPS data from some other clock driver  */
end_comment

begin_function
name|int
name|pps_sample
parameter_list|(
name|l_fp
modifier|*
name|offset
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|l_fp
name|lftmp
decl_stmt|;
name|double
name|doffset
decl_stmt|;
comment|/* 	 * This routine is called once per second when the external 	 * clock driver processes PPS information. It processes the pps 	 * timestamp and saves the sign-extended fraction in a circular 	 * buffer for processing at the next poll event. 	 */
name|peer
operator|=
name|pps_peer
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
comment|/* nobody home */
return|return
literal|1
return|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Convert the timeval to l_fp and save for billboards. Sign- 	 * extend the fraction and stash in the buffer. No harm is done 	 * if previous data are overwritten. If the discipline comes bum 	 * or the data grow stale, just forget it. 	 */
name|up
operator|->
name|flags
operator||=
name|FLAG_AUX
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|=
operator|*
name|offset
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|lftmp
argument_list|)
expr_stmt|;
name|L_ADDF
argument_list|(
operator|&
name|lftmp
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_f
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|lftmp
argument_list|,
name|doffset
argument_list|)
expr_stmt|;
name|SAMPLE
argument_list|(
operator|-
name|doffset
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * atom_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|atom_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
endif|#
directive|endif
comment|/* PPS || HAVE_PPSAPI */
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * Accumulate samples in the median filter. At the end of each 	 * poll interval, do a little bookeeping and process the 	 * samples. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|flags
operator|&
operator|!
operator|(
name|FLAG_AUX
operator||
name|FLAG_TTY
operator|)
operator|)
condition|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|atom_pps
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|>
literal|0
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* PPS || HAVE_PPSAPI */
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Valid time (leap bits zero) is returned only if the prefer 	 * peer has survived the intersection algorithm and within 	 * clock_max of local time and not too long ago.  This ensures 	 * the pps time is within +-0.5 s of the local time and the 	 * seconds numbering is unambiguous. 	 */
if|if
condition|(
name|pps_update
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|variance
operator|=
literal|0
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|MAXSTAGE
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_atom_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

