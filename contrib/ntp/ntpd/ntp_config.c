begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_config.c - read and apply configuration information  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SIGCHLD
end_ifndef

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_include
include|#
directive|include
file|<netinfo/ni.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_filegen.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_decl_stmt
specifier|extern
name|HANDLE
name|ResolverThreadHandle
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * These routines are used to read the configuration file at  * startup time.  An entry in the file must fit on a single line.  * Entries are processed as multiple tokens separated by white space  * Lines are considered terminated when a '#' is encountered.  Blank  * lines are ignored.  */
end_comment

begin_comment
comment|/*  * Configuration file name  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_FILE
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_define
define|#
directive|define
name|CONFIG_FILE
value|"/etc/ntp.conf"
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_define
define|#
directive|define
name|CONFIG_FILE
value|"%windir%\\system32\\drivers\\etc\\ntp.conf"
end_define

begin_define
define|#
directive|define
name|ALT_CONFIG_FILE
value|"%windir%\\ntp.conf"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CONFIG_FILE */
end_comment

begin_comment
comment|/*  * We understand the following configuration entries and defaults.  *  * peer [ addr ] [ version 3 ] [ key 0 ] [ minpoll 6 ] [ maxpoll 10 ]  * server [ addr ] [ version 3 ] [ key 0 ] [ minpoll 6 ] [ maxpoll 10 ]  * broadcast [ addr ] [ version 3 ] [ key 0 ] [ ttl 1 ]  * broadcastclient  * multicastclient [ 224.0.1.1 ]  * manycastclient [ addr ] [ version 3 ] [ key 0 ] [ minpoll 6 ] [ maxpoll 10 ]  * manycastserver [ 224.0.1.1 ]  * broadcastdelay 0.0102  * restrict [ addr ] [ mask 255.255.255.0 ] ignore|noserve|notrust|noquery  * driftfile file_name  * keys file_name  * statsdir /var/NTP/  * filegen peerstats [ file peerstats ] [ type day ] [ link ]  * clientlimit [ n ]  * clientperiod [ 3600 ]  * trustedkey [ key ]  * requestkey [ key]  * controlkey [ key ]  * trap [ addr ]  * fudge [ addr ] [ stratum ] [ refid ] ...  * pidfile [ ]  * setvar [ ]  * logfile logfile  * logconfig [+|-|=][{sync|sys|peer|clock}{{,all}{info|statistics|events|status}}]...  * enable auth|bclient|pll|kernel|monitor|stats  * disable auth|bclient|pll|kernel|monitor|stats  * phone ...  * pps device [assert|clear] [hardpps]  */
end_comment

begin_comment
comment|/*  * Types of entries we understand.  */
end_comment

begin_define
define|#
directive|define
name|CONFIG_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|CONFIG_PEER
value|1
end_define

begin_define
define|#
directive|define
name|CONFIG_SERVER
value|2
end_define

begin_define
define|#
directive|define
name|CONFIG_AUTOMAX
value|3
end_define

begin_define
define|#
directive|define
name|CONFIG_DRIFTFILE
value|4
end_define

begin_define
define|#
directive|define
name|CONFIG_BROADCAST
value|5
end_define

begin_define
define|#
directive|define
name|CONFIG_BROADCASTCLIENT
value|6
end_define

begin_define
define|#
directive|define
name|CONFIG_AUTHENTICATE
value|7
end_define

begin_define
define|#
directive|define
name|CONFIG_KEYS
value|8
end_define

begin_define
define|#
directive|define
name|CONFIG_REVOKE
value|9
end_define

begin_define
define|#
directive|define
name|CONFIG_PPS
value|10
end_define

begin_define
define|#
directive|define
name|CONFIG_RESTRICT
value|11
end_define

begin_define
define|#
directive|define
name|CONFIG_BDELAY
value|12
end_define

begin_define
define|#
directive|define
name|CONFIG_TRUSTEDKEY
value|13
end_define

begin_define
define|#
directive|define
name|CONFIG_REQUESTKEY
value|14
end_define

begin_define
define|#
directive|define
name|CONFIG_CONTROLKEY
value|15
end_define

begin_define
define|#
directive|define
name|CONFIG_TRAP
value|16
end_define

begin_define
define|#
directive|define
name|CONFIG_FUDGE
value|17
end_define

begin_define
define|#
directive|define
name|CONFIG_18
value|18
end_define

begin_comment
comment|/* unused */
end_comment

begin_define
define|#
directive|define
name|CONFIG_STATSDIR
value|19
end_define

begin_define
define|#
directive|define
name|CONFIG_FILEGEN
value|20
end_define

begin_define
define|#
directive|define
name|CONFIG_STATISTICS
value|21
end_define

begin_define
define|#
directive|define
name|CONFIG_PIDFILE
value|22
end_define

begin_define
define|#
directive|define
name|CONFIG_SETVAR
value|23
end_define

begin_define
define|#
directive|define
name|CONFIG_CLIENTLIMIT
value|24
end_define

begin_define
define|#
directive|define
name|CONFIG_CLIENTPERIOD
value|25
end_define

begin_define
define|#
directive|define
name|CONFIG_MULTICASTCLIENT
value|26
end_define

begin_define
define|#
directive|define
name|CONFIG_ENABLE
value|27
end_define

begin_define
define|#
directive|define
name|CONFIG_DISABLE
value|28
end_define

begin_define
define|#
directive|define
name|CONFIG_PHONE
value|29
end_define

begin_define
define|#
directive|define
name|CONFIG_LOGFILE
value|30
end_define

begin_define
define|#
directive|define
name|CONFIG_LOGCONFIG
value|31
end_define

begin_define
define|#
directive|define
name|CONFIG_MANYCASTCLIENT
value|32
end_define

begin_define
define|#
directive|define
name|CONFIG_MANYCASTSERVER
value|33
end_define

begin_define
define|#
directive|define
name|CONF_MOD_VERSION
value|1
end_define

begin_define
define|#
directive|define
name|CONF_MOD_KEY
value|2
end_define

begin_define
define|#
directive|define
name|CONF_MOD_MINPOLL
value|3
end_define

begin_define
define|#
directive|define
name|CONF_MOD_MAXPOLL
value|4
end_define

begin_define
define|#
directive|define
name|CONF_MOD_PREFER
value|5
end_define

begin_define
define|#
directive|define
name|CONF_MOD_BURST
value|6
end_define

begin_define
define|#
directive|define
name|CONF_MOD_SKEY
value|7
end_define

begin_define
define|#
directive|define
name|CONF_MOD_TTL
value|8
end_define

begin_define
define|#
directive|define
name|CONF_MOD_MODE
value|9
end_define

begin_define
define|#
directive|define
name|CONF_MOD_NOSELECT
value|10
end_define

begin_define
define|#
directive|define
name|CONF_RES_MASK
value|1
end_define

begin_define
define|#
directive|define
name|CONF_RES_IGNORE
value|2
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOSERVE
value|3
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOTRUST
value|4
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOQUERY
value|5
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOMODIFY
value|6
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOPEER
value|7
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOTRAP
value|8
end_define

begin_define
define|#
directive|define
name|CONF_RES_LPTRAP
value|9
end_define

begin_define
define|#
directive|define
name|CONF_RES_NTPPORT
value|10
end_define

begin_define
define|#
directive|define
name|CONF_RES_LIMITED
value|11
end_define

begin_define
define|#
directive|define
name|CONF_TRAP_PORT
value|1
end_define

begin_define
define|#
directive|define
name|CONF_TRAP_INTERFACE
value|2
end_define

begin_define
define|#
directive|define
name|CONF_FDG_TIME1
value|1
end_define

begin_define
define|#
directive|define
name|CONF_FDG_TIME2
value|2
end_define

begin_define
define|#
directive|define
name|CONF_FDG_STRATUM
value|3
end_define

begin_define
define|#
directive|define
name|CONF_FDG_REFID
value|4
end_define

begin_define
define|#
directive|define
name|CONF_FDG_FLAG1
value|5
end_define

begin_define
define|#
directive|define
name|CONF_FDG_FLAG2
value|6
end_define

begin_define
define|#
directive|define
name|CONF_FDG_FLAG3
value|7
end_define

begin_define
define|#
directive|define
name|CONF_FDG_FLAG4
value|8
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_FILE
value|1
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_TYPE
value|2
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_FLAG_LINK
value|3
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_FLAG_NOLINK
value|4
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_FLAG_ENABLE
value|5
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_FLAG_DISABLE
value|6
end_define

begin_define
define|#
directive|define
name|CONF_PPS_ASSERT
value|1
end_define

begin_define
define|#
directive|define
name|CONF_PPS_CLEAR
value|2
end_define

begin_define
define|#
directive|define
name|CONF_PPS_HARDPPS
value|3
end_define

begin_comment
comment|/*  * Translation table - keywords to function index  */
end_comment

begin_struct
struct|struct
name|keyword
block|{
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|keytype
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Command keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|keywords
index|[]
init|=
block|{
block|{
literal|"peer"
block|,
name|CONFIG_PEER
block|}
block|,
block|{
literal|"server"
block|,
name|CONFIG_SERVER
block|}
block|,
block|{
literal|"driftfile"
block|,
name|CONFIG_DRIFTFILE
block|}
block|,
block|{
literal|"broadcast"
block|,
name|CONFIG_BROADCAST
block|}
block|,
block|{
literal|"broadcastclient"
block|,
name|CONFIG_BROADCASTCLIENT
block|}
block|,
block|{
literal|"multicastclient"
block|,
name|CONFIG_MULTICASTCLIENT
block|}
block|,
block|{
literal|"manycastclient"
block|,
name|CONFIG_MANYCASTCLIENT
block|}
block|,
block|{
literal|"manycastserver"
block|,
name|CONFIG_MANYCASTSERVER
block|}
block|,
block|{
literal|"authenticate"
block|,
name|CONFIG_AUTHENTICATE
block|}
block|,
block|{
literal|"keys"
block|,
name|CONFIG_KEYS
block|}
block|,
block|{
literal|"revoke"
block|,
name|CONFIG_REVOKE
block|}
block|,
block|{
literal|"pps"
block|,
name|CONFIG_PPS
block|}
block|,
block|{
literal|"automax"
block|,
name|CONFIG_AUTOMAX
block|}
block|,
block|{
literal|"restrict"
block|,
name|CONFIG_RESTRICT
block|}
block|,
block|{
literal|"broadcastdelay"
block|,
name|CONFIG_BDELAY
block|}
block|,
block|{
literal|"trustedkey"
block|,
name|CONFIG_TRUSTEDKEY
block|}
block|,
block|{
literal|"requestkey"
block|,
name|CONFIG_REQUESTKEY
block|}
block|,
block|{
literal|"controlkey"
block|,
name|CONFIG_CONTROLKEY
block|}
block|,
block|{
literal|"trap"
block|,
name|CONFIG_TRAP
block|}
block|,
block|{
literal|"fudge"
block|,
name|CONFIG_FUDGE
block|}
block|,
block|{
literal|"statsdir"
block|,
name|CONFIG_STATSDIR
block|}
block|,
block|{
literal|"filegen"
block|,
name|CONFIG_FILEGEN
block|}
block|,
block|{
literal|"statistics"
block|,
name|CONFIG_STATISTICS
block|}
block|,
block|{
literal|"pidfile"
block|,
name|CONFIG_PIDFILE
block|}
block|,
block|{
literal|"setvar"
block|,
name|CONFIG_SETVAR
block|}
block|,
block|{
literal|"clientlimit"
block|,
name|CONFIG_CLIENTLIMIT
block|}
block|,
block|{
literal|"clientperiod"
block|,
name|CONFIG_CLIENTPERIOD
block|}
block|,
block|{
literal|"enable"
block|,
name|CONFIG_ENABLE
block|}
block|,
block|{
literal|"disable"
block|,
name|CONFIG_DISABLE
block|}
block|,
block|{
literal|"phone"
block|,
name|CONFIG_PHONE
block|}
block|,
block|{
literal|"logfile"
block|,
name|CONFIG_LOGFILE
block|}
block|,
block|{
literal|"logconfig"
block|,
name|CONFIG_LOGCONFIG
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "peer", "server", "broadcast" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|mod_keywords
index|[]
init|=
block|{
block|{
literal|"version"
block|,
name|CONF_MOD_VERSION
block|}
block|,
block|{
literal|"key"
block|,
name|CONF_MOD_KEY
block|}
block|,
block|{
literal|"minpoll"
block|,
name|CONF_MOD_MINPOLL
block|}
block|,
block|{
literal|"maxpoll"
block|,
name|CONF_MOD_MAXPOLL
block|}
block|,
block|{
literal|"prefer"
block|,
name|CONF_MOD_PREFER
block|}
block|,
block|{
literal|"noselect"
block|,
name|CONF_MOD_NOSELECT
block|}
block|,
block|{
literal|"burst"
block|,
name|CONF_MOD_BURST
block|}
block|,
block|{
literal|"autokey"
block|,
name|CONF_MOD_SKEY
block|}
block|,
block|{
literal|"mode"
block|,
name|CONF_MOD_MODE
block|}
block|,
comment|/* reference clocks */
block|{
literal|"ttl"
block|,
name|CONF_MOD_TTL
block|}
block|,
comment|/* NTP peers */
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "restrict" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|res_keywords
index|[]
init|=
block|{
block|{
literal|"mask"
block|,
name|CONF_RES_MASK
block|}
block|,
block|{
literal|"ignore"
block|,
name|CONF_RES_IGNORE
block|}
block|,
block|{
literal|"noserve"
block|,
name|CONF_RES_NOSERVE
block|}
block|,
block|{
literal|"notrust"
block|,
name|CONF_RES_NOTRUST
block|}
block|,
block|{
literal|"noquery"
block|,
name|CONF_RES_NOQUERY
block|}
block|,
block|{
literal|"nomodify"
block|,
name|CONF_RES_NOMODIFY
block|}
block|,
block|{
literal|"nopeer"
block|,
name|CONF_RES_NOPEER
block|}
block|,
block|{
literal|"notrap"
block|,
name|CONF_RES_NOTRAP
block|}
block|,
block|{
literal|"lowpriotrap"
block|,
name|CONF_RES_LPTRAP
block|}
block|,
block|{
literal|"ntpport"
block|,
name|CONF_RES_NTPPORT
block|}
block|,
block|{
literal|"limited"
block|,
name|CONF_RES_LIMITED
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "trap" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|trap_keywords
index|[]
init|=
block|{
block|{
literal|"port"
block|,
name|CONF_TRAP_PORT
block|}
block|,
block|{
literal|"interface"
block|,
name|CONF_TRAP_INTERFACE
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "fudge" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|fudge_keywords
index|[]
init|=
block|{
block|{
literal|"time1"
block|,
name|CONF_FDG_TIME1
block|}
block|,
block|{
literal|"time2"
block|,
name|CONF_FDG_TIME2
block|}
block|,
block|{
literal|"stratum"
block|,
name|CONF_FDG_STRATUM
block|}
block|,
block|{
literal|"refid"
block|,
name|CONF_FDG_REFID
block|}
block|,
block|{
literal|"flag1"
block|,
name|CONF_FDG_FLAG1
block|}
block|,
block|{
literal|"flag2"
block|,
name|CONF_FDG_FLAG2
block|}
block|,
block|{
literal|"flag3"
block|,
name|CONF_FDG_FLAG3
block|}
block|,
block|{
literal|"flag4"
block|,
name|CONF_FDG_FLAG4
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "filegen" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|filegen_keywords
index|[]
init|=
block|{
block|{
literal|"file"
block|,
name|CONF_FGEN_FILE
block|}
block|,
block|{
literal|"type"
block|,
name|CONF_FGEN_TYPE
block|}
block|,
block|{
literal|"link"
block|,
name|CONF_FGEN_FLAG_LINK
block|}
block|,
block|{
literal|"nolink"
block|,
name|CONF_FGEN_FLAG_NOLINK
block|}
block|,
block|{
literal|"enable"
block|,
name|CONF_FGEN_FLAG_ENABLE
block|}
block|,
block|{
literal|"disable"
block|,
name|CONF_FGEN_FLAG_DISABLE
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "type" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|fgen_types
index|[]
init|=
block|{
block|{
literal|"none"
block|,
name|FILEGEN_NONE
block|}
block|,
block|{
literal|"pid"
block|,
name|FILEGEN_PID
block|}
block|,
block|{
literal|"day"
block|,
name|FILEGEN_DAY
block|}
block|,
block|{
literal|"week"
block|,
name|FILEGEN_WEEK
block|}
block|,
block|{
literal|"month"
block|,
name|FILEGEN_MONTH
block|}
block|,
block|{
literal|"year"
block|,
name|FILEGEN_YEAR
block|}
block|,
block|{
literal|"age"
block|,
name|FILEGEN_AGE
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "enable", "disable" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|flags_keywords
index|[]
init|=
block|{
block|{
literal|"auth"
block|,
name|PROTO_AUTHENTICATE
block|}
block|,
block|{
literal|"bclient"
block|,
name|PROTO_BROADCLIENT
block|}
block|,
block|{
literal|"ntp"
block|,
name|PROTO_NTP
block|}
block|,
block|{
literal|"kernel"
block|,
name|PROTO_KERNEL
block|}
block|,
block|{
literal|"monitor"
block|,
name|PROTO_MONITOR
block|}
block|,
block|{
literal|"stats"
block|,
name|PROTO_FILEGEN
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pps modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|pps_keywords
index|[]
init|=
block|{
block|{
literal|"assert"
block|,
name|CONF_PPS_ASSERT
block|}
block|,
block|{
literal|"clear"
block|,
name|CONF_PPS_CLEAR
block|}
block|,
block|{
literal|"hardpps"
block|,
name|CONF_PPS_HARDPPS
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "logconfig" building blocks  */
end_comment

begin_struct
struct|struct
name|masks
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|masks
name|logcfg_class
index|[]
init|=
block|{
block|{
literal|"sys"
block|,
name|NLOG_OSYS
block|}
block|,
block|{
literal|"peer"
block|,
name|NLOG_OPEER
block|}
block|,
block|{
literal|"clock"
block|,
name|NLOG_OCLOCK
block|}
block|,
block|{
literal|"sync"
block|,
name|NLOG_OSYNC
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|masks
name|logcfg_item
index|[]
init|=
block|{
block|{
literal|"info"
block|,
name|NLOG_INFO
block|}
block|,
block|{
literal|"allinfo"
block|,
name|NLOG_SYSINFO
operator||
name|NLOG_PEERINFO
operator||
name|NLOG_CLOCKINFO
operator||
name|NLOG_SYNCINFO
block|}
block|,
block|{
literal|"events"
block|,
name|NLOG_EVENT
block|}
block|,
block|{
literal|"allevents"
block|,
name|NLOG_SYSEVENT
operator||
name|NLOG_PEEREVENT
operator||
name|NLOG_CLOCKEVENT
operator||
name|NLOG_SYNCEVENT
block|}
block|,
block|{
literal|"status"
block|,
name|NLOG_STATUS
block|}
block|,
block|{
literal|"allstatus"
block|,
name|NLOG_SYSSTATUS
operator||
name|NLOG_PEERSTATUS
operator||
name|NLOG_CLOCKSTATUS
operator||
name|NLOG_SYNCSTATUS
block|}
block|,
block|{
literal|"statistics"
block|,
name|NLOG_STATIST
block|}
block|,
block|{
literal|"allstatistics"
block|,
name|NLOG_SYSSTATIST
operator||
name|NLOG_PEERSTATIST
operator||
name|NLOG_CLOCKSTATIST
operator||
name|NLOG_SYNCSTATIST
block|}
block|,
block|{
literal|"allclock"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OCLOCK
block|}
block|,
block|{
literal|"allpeer"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OPEER
block|}
block|,
block|{
literal|"allsys"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OSYS
block|}
block|,
block|{
literal|"allsync"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OSYNC
block|}
block|,
block|{
literal|"all"
block|,
name|NLOG_SYSMASK
operator||
name|NLOG_PEERMASK
operator||
name|NLOG_CLOCKMASK
operator||
name|NLOG_SYNCMASK
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Limits on things  */
end_comment

begin_define
define|#
directive|define
name|MAXTOKENS
value|20
end_define

begin_comment
comment|/* 20 tokens on line */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|1024
end_define

begin_comment
comment|/* maximum length of line */
end_comment

begin_define
define|#
directive|define
name|MAXPHONE
value|5
end_define

begin_comment
comment|/* maximum number of phone strings */
end_comment

begin_define
define|#
directive|define
name|MAXPPS
value|20
end_define

begin_comment
comment|/* maximum length of PPS device string */
end_comment

begin_define
define|#
directive|define
name|MAXFILENAME
value|128
end_define

begin_comment
comment|/* maximum length of a file name (alloca()?) */
end_comment

begin_comment
comment|/*  * Miscellaneous macros  */
end_comment

begin_define
define|#
directive|define
name|STRSAME
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(*(s1) == *(s2)&& strcmp((s1), (s2)) == 0)
end_define

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '#' || (c) == '\n' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * File descriptor used by the resolver save routines, and temporary file  * name.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|res_fp
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|res_file
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enough for /tmp/ntpXXXXXX\0 */
end_comment

begin_define
define|#
directive|define
name|RES_TEMPFILE
value|"/tmp/ntpXXXXXX"
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|res_file
index|[
name|MAX_PATH
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * Definitions of things either imported from or exported to outside  */
end_comment

begin_decl_stmt
name|char
specifier|const
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|sys_phone
index|[
name|MAXPHONE
index|]
index|[
name|MAXDIAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ACTS phone numbers */
end_comment

begin_decl_stmt
name|char
name|pps_device
index|[
name|MAXPPS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PPS device name */
end_comment

begin_decl_stmt
name|int
name|pps_assert
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pps_hardpps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|listen_to_virtual_ips
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SCHED_SETSCHEDULER
argument_list|)
end_if

begin_decl_stmt
name|int
name|config_priority_override
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|config_priority
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ntp_options
init|=
literal|"aAbc:dD:f:gk:l:Lmnp:P:r:s:t:v:V:x"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_comment
comment|/*  * NetInfo configuration state  */
end_comment

begin_struct
struct|struct
name|netinfo_config_state
block|{
name|void
modifier|*
name|domain
decl_stmt|;
comment|/* domain with config */
name|ni_id
name|config_dir
decl_stmt|;
comment|/* ID config dir      */
name|int
name|prop_index
decl_stmt|;
comment|/* current property   */
name|int
name|val_index
decl_stmt|;
comment|/* current value      */
name|char
modifier|*
modifier|*
name|val_list
decl_stmt|;
comment|/* value list         */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_pfxmatch
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|masks
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_match
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|masks
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_logmask
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|netinfo_config_state
modifier|*
name|get_netinfo_config
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_netinfo_config
name|P
argument_list|(
operator|(
expr|struct
name|netinfo_config_state
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gettokens_netinfo
name|P
argument_list|(
operator|(
expr|struct
name|netinfo_config_state
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|gettokens
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|matchkey
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|keyword
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getnetnum
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|sockaddr_in
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_resolve
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_resolve_internal
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|abort_resolve
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|catchchild
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/*  * get_pfxmatch - find value for prefixmatch  * and update char * accordingly  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_pfxmatch
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|,
name|struct
name|masks
modifier|*
name|m
parameter_list|)
block|{
while|while
condition|(
name|m
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|s
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|m
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|s
operator|+=
name|strlen
argument_list|(
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|m
operator|->
name|mask
return|;
block|}
else|else
block|{
name|m
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_match - find logmask value  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_match
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|struct
name|masks
modifier|*
name|m
parameter_list|)
block|{
while|while
condition|(
name|m
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|m
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|m
operator|->
name|mask
return|;
block|}
else|else
block|{
name|m
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_logmask - build bitmask for ntp_syslogmask  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_logmask
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|t
operator|=
name|s
expr_stmt|;
name|offset
operator|=
name|get_pfxmatch
argument_list|(
operator|&
name|t
argument_list|,
name|logcfg_class
argument_list|)
expr_stmt|;
name|mask
operator|=
name|get_match
argument_list|(
name|t
argument_list|,
name|logcfg_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
return|return
name|mask
operator|<<
name|offset
return|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"logconfig: illegal argument %s - ignored"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * getstartup - search through the options looking for a debugging flag  */
end_comment

begin_function
name|void
name|getstartup
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|errflg
decl_stmt|;
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|0
expr_stmt|;
comment|/* no debugging by default */
endif|#
directive|endif
comment|/* 	 * This is a big hack.	We don't really want to read command line 	 * configuration until everything else is initialized, since 	 * the ability to configure the system may depend on storage 	 * and the like having been initialized.  Except that we also 	 * don't want to initialize anything until after detaching from 	 * the terminal, but we won't know to do that until we've 	 * parsed the command line.  Do that now, crudely, and do it 	 * again later.  Our ntp_getopt() is explicitly reusable, by the 	 * way.  Your own mileage may vary. 	 * 	 * This hack is even called twice (to allow complete logging to file) 	 */
name|errflg
operator|=
literal|0
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Decode argument list 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|ntp_options
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|debug
operator|=
operator|(
name|int
operator|)
name|atol
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Debug1: %s -> %x = %d\n"
argument_list|,
name|ntp_optarg
argument_list|,
name|debug
argument_list|,
name|debug
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ntpd not compiled with -DDEBUG option - no DEBUG support"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ntpd not compiled with -DDEBUG option - no DEBUG support"
argument_list|)
expr_stmt|;
operator|++
name|errflg
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'L'
case|:
name|listen_to_virtual_ips
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
block|{
name|FILE
modifier|*
name|new_file
decl_stmt|;
name|new_file
operator|=
name|fopen
argument_list|(
name|ntp_optarg
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_file
operator|!=
name|NULL
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"logging to file %s"
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
operator|&&
name|fileno
argument_list|(
name|syslog_file
argument_list|)
operator|!=
name|fileno
argument_list|(
name|new_file
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|syslog_file
argument_list|)
expr_stmt|;
name|syslog_file
operator|=
name|new_file
expr_stmt|;
name|syslogit
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot open log file %s"
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
operator|++
name|nofork
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|++
name|errflg
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|errflg
operator|||
name|ntp_optind
operator|!=
name|argc
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [ -abdgmnx ] [ -c config_file ] [ -e e_delay ]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -f freq_file ] [ -k key_file ] [ -l log_file ]\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -p pid_file ] [ -r broad_delay ] [ -s statdir ]\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -t trust_key ] [ -v sys_var ] [ -V default_sysvar ]\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SCHED_SETSCHEDULER
argument_list|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -P fixed_process_priority ]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ntp_optind
operator|=
literal|0
expr_stmt|;
comment|/* reset ntp_optind to restart ntp_getopt */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SETVBUF
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|buf
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * getconfig - get command line options and read the configuration file  */
end_comment

begin_function
name|void
name|getconfig
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|errflg
decl_stmt|;
name|int
name|peerversion
decl_stmt|;
name|int
name|minpoll
decl_stmt|;
name|int
name|maxpoll
decl_stmt|;
name|int
name|ttl
decl_stmt|;
name|u_long
name|peerkey
decl_stmt|;
name|u_long
name|lpeerkey
decl_stmt|;
name|int
name|peerflags
decl_stmt|;
name|int
name|hmode
decl_stmt|;
name|struct
name|sockaddr_in
name|peeraddr
decl_stmt|;
name|struct
name|sockaddr_in
name|maskaddr
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|line
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
argument_list|*
operator|(
name|tokens
index|[
name|MAXTOKENS
index|]
operator|)
argument_list|;
name|int
name|ntokens
argument_list|;
name|int
name|tok
operator|=
name|CONFIG_UNKNOWN
argument_list|;
expr|struct
name|interface
operator|*
name|localaddr
argument_list|;
specifier|const
name|char
operator|*
name|config_file
argument_list|;
ifdef|#
directive|ifdef
name|HAVE_NETINFO
expr|struct
name|netinfo_config_state
operator|*
name|config_netinfo
operator|=
name|NULL
argument_list|;
name|int
name|check_netinfo
operator|=
literal|1
argument_list|;
endif|#
directive|endif
comment|/* HAVE_NETINFO */
ifdef|#
directive|ifdef
name|SYS_WINNT
name|char
operator|*
name|alt_config_file
argument_list|;
name|LPTSTR
name|temp
argument_list|;
name|char
name|config_file_storage
index|[
name|MAX_PATH
index|]
argument_list|;
name|char
name|alt_config_file_storage
index|[
name|MAX_PATH
index|]
argument_list|;
endif|#
directive|endif
comment|/* SYS_WINNT */
expr|struct
name|refclockstat
name|clock_stat
argument_list|;
name|FILEGEN
operator|*
name|filegen
argument_list|;
comment|/* 	 * Initialize, initialize 	 */
name|errflg
operator|=
literal|0
argument_list|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|0
argument_list|;
endif|#
directive|endif
comment|/* DEBUG */
ifndef|#
directive|ifndef
name|SYS_WINNT
name|config_file
operator|=
name|CONFIG_FILE
argument_list|;
else|#
directive|else
name|temp
operator|=
name|CONFIG_FILE
argument_list|; 	if
operator|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
operator|(
name|LPCTSTR
operator|)
name|temp
argument_list|,
operator|(
name|LPTSTR
operator|)
name|config_file_storage
argument_list|,
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|config_file_storage
argument_list|)
argument_list|)
operator|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings CONFIG_FILE failed: %m\n"
argument_list|)
block|;
name|exit
argument_list|(
literal|1
argument_list|)
block|; 	}
name|config_file
operator|=
name|config_file_storage
argument_list|;
name|temp
operator|=
name|ALT_CONFIG_FILE
argument_list|; 	if
operator|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
operator|(
name|LPCTSTR
operator|)
name|temp
argument_list|,
operator|(
name|LPTSTR
operator|)
name|alt_config_file_storage
argument_list|,
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|alt_config_file_storage
argument_list|)
argument_list|)
operator|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings ALT_CONFIG_FILE failed: %m\n"
argument_list|)
block|;
name|exit
argument_list|(
literal|1
argument_list|)
block|; 	}
name|alt_config_file
operator|=
name|alt_config_file_storage
argument_list|;
endif|#
directive|endif
comment|/* SYS_WINNT */
name|progname
operator|=
name|argv
index|[
literal|0
index|]
argument_list|;
name|res_fp
operator|=
name|NULL
argument_list|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sys_phone
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sys_phone
argument_list|)
argument_list|)
argument_list|;
name|ntp_syslogmask
operator|=
name|NLOG_SYNCMASK
argument_list|;
comment|/* set more via logconfig */
comment|/* 	 * install a non default variable with this daemon version 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"daemon_version=\"%s\""
argument_list|,
name|Version
argument_list|)
argument_list|;
name|set_sys_var
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
argument_list|;
comment|/* 	 * Say how we're setting the time of day 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"settimeofday=\"%s\""
argument_list|,
name|set_tod_using
argument_list|)
argument_list|;
name|set_sys_var
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
argument_list|;
comment|/* 	 * Initialize the loop. 	 */
name|loop_config
argument_list|(
name|LOOP_DRIFTINIT
argument_list|,
literal|0.
argument_list|)
argument_list|;
comment|/* 	 * Decode argument list 	 */
argument_list|while
operator|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|ntp_options
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|proto_config
argument_list|(
name|PROTO_AUTHENTICATE
argument_list|,
literal|1
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|proto_config
argument_list|(
name|PROTO_AUTHENTICATE
argument_list|,
literal|0
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
literal|1
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|config_file
operator|=
name|ntp_optarg
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NETINFO
name|check_netinfo
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|++
expr_stmt|;
else|#
directive|else
name|errflg
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
case|case
literal|'D'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
operator|(
name|int
operator|)
name|atol
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Debug2: %s -> %x = %d\n"
argument_list|,
name|ntp_optarg
argument_list|,
name|debug
argument_list|,
name|debug
argument_list|)
expr_stmt|;
else|#
directive|else
name|errflg
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
case|case
literal|'f'
case|:
name|stats_config
argument_list|(
name|STATS_FREQ_FILE
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|correct_any
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|getauthkeys
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* already done at pre-scan */
case|case
literal|'l'
case|:
comment|/* already done at pre-scan */
break|break;
case|case
literal|'m'
case|:
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
name|htonl
argument_list|(
name|INADDR_NTP
argument_list|)
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
name|sys_bclient
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* already done at pre-scan */
break|break;
case|case
literal|'p'
case|:
name|stats_config
argument_list|(
name|STATS_PID_FILE
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SCHED_SETSCHEDULER
argument_list|)
name|config_priority
operator|=
operator|(
name|int
operator|)
name|atol
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
name|config_priority_override
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|errflg
operator|++
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'r'
case|:
do|do
block|{
name|double
name|tmp
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|ntp_optarg
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|tmp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"command line broadcast delay value %s undecodable"
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proto_config
argument_list|(
name|PROTO_BROADDELAY
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_while
while|while
condition|(
literal|0
condition|)
empty_stmt|;
end_while

begin_break
break|break;
end_break

begin_case
case|case
literal|'s'
case|:
end_case

begin_expr_stmt
name|stats_config
argument_list|(
name|STATS_STATSDIR
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
literal|'t'
case|:
end_case

begin_do
do|do
block|{
name|u_long
name|tkey
decl_stmt|;
name|tkey
operator|=
operator|(
name|int
operator|)
name|atol
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tkey
operator|<=
literal|0
operator|||
name|tkey
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"command line trusted key %s is invalid"
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authtrust
argument_list|(
name|tkey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
end_do

begin_break
break|break;
end_break

begin_case
case|case
literal|'v'
case|:
end_case

begin_case
case|case
literal|'V'
case|:
end_case

begin_expr_stmt
name|set_sys_var
argument_list|(
name|ntp_optarg
argument_list|,
name|strlen
argument_list|(
name|ntp_optarg
argument_list|)
operator|+
literal|1
argument_list|,
name|RW
operator||
operator|(
operator|(
name|c
operator|==
literal|'V'
operator|)
condition|?
name|DEF
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
literal|'x'
case|:
end_case

begin_expr_stmt
name|allow_set_backward
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_expr_stmt
name|errflg
operator|++
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_if
unit|} 	}
if|if
condition|(
name|errflg
operator|||
name|ntp_optind
operator|!=
name|argc
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [ -abdgmnx ] [ -c config_file ] [ -e e_delay ]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -f freq_file ] [ -k key_file ] [ -l log_file ]\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -p pid_file ] [ -r broad_delay ] [ -s statdir ]\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -t trust_key ] [ -v sys_var ] [ -V default_sysvar ]\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SCHED_SETSCHEDULER
argument_list|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -P fixed_process_priority ]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
ifdef|#
directive|ifdef
name|HAVE_NETINFO
comment|/* If there is no config_file, try NetInfo. */
operator|&&
name|check_netinfo
operator|&&
operator|!
operator|(
name|config_netinfo
operator|=
name|get_netinfo_config
argument_list|()
operator|)
endif|#
directive|endif
comment|/* HAVE_NETINFO */
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getconfig: Couldn't open<%s>\n"
argument_list|,
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* Under WinNT try alternate_config_file name, first NTP.CONF, then NTP.INI */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Broadcast clients can sometimes run without 			 * a configuration file. 			 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getconfig: Couldn't open<%s>\n"
argument_list|,
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
comment|/* not SYS_WINNT */
return|return;
endif|#
directive|endif
comment|/* not SYS_WINNT */
block|}
end_if

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fp
condition|)
name|tok
operator|=
name|gettokens
argument_list|(
name|fp
argument_list|,
name|line
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntokens
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NETINFO
else|else
name|tok
operator|=
name|gettokens_netinfo
argument_list|(
name|config_netinfo
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntokens
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NETINFO */
if|if
condition|(
name|tok
operator|==
name|CONFIG_UNKNOWN
condition|)
break|break;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|CONFIG_PEER
case|:
case|case
name|CONFIG_SERVER
case|:
case|case
name|CONFIG_MANYCASTCLIENT
case|:
case|case
name|CONFIG_BROADCAST
case|:
if|if
condition|(
name|tok
operator|==
name|CONFIG_PEER
condition|)
name|hmode
operator|=
name|MODE_ACTIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|CONFIG_SERVER
condition|)
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|CONFIG_MANYCASTCLIENT
condition|)
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
else|else
name|hmode
operator|=
name|MODE_BROADCAST
expr_stmt|;
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No address for %s, line ignored"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|errflg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|errflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|REFCLOCK
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|&&
endif|#
directive|endif
name|ISBADADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 				 * Shouldn't be able to specify multicast 				 * address for server/peer! 				 * and unicast address for manycastclient! 				 */
if|if
condition|(
operator|(
operator|(
name|tok
operator|==
name|CONFIG_SERVER
operator|)
operator|||
operator|(
name|tok
operator|==
name|CONFIG_PEER
operator|)
operator|)
operator|&&
ifdef|#
directive|ifdef
name|REFCLOCK
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|&&
endif|#
directive|endif
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|tok
operator|==
name|CONFIG_MANYCASTCLIENT
operator|)
operator|&&
operator|!
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|peerversion
operator|=
name|NTP_VERSION
expr_stmt|;
name|minpoll
operator|=
name|NTP_MINDPOLL
expr_stmt|;
name|maxpoll
operator|=
name|NTP_MAXDPOLL
expr_stmt|;
name|peerkey
operator|=
literal|0
expr_stmt|;
name|peerflags
operator|=
literal|0
expr_stmt|;
name|ttl
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|mod_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_MOD_VERSION
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"peer/server version requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peerversion
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_char
operator|)
name|peerversion
operator|>
name|NTP_VERSION
operator|||
operator|(
name|u_char
operator|)
name|peerversion
operator|<
name|NTP_OLDVERSION
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"inappropriate version number %s, line ignored"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONF_MOD_KEY
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"key: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peerkey
operator|=
operator|(
name|int
operator|)
name|atol
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|peerflags
operator||=
name|FLAG_AUTHENABLE
expr_stmt|;
break|break;
case|case
name|CONF_MOD_MINPOLL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"minpoll: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|minpoll
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|minpoll
operator|<
name|NTP_MINPOLL
condition|)
name|minpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
break|break;
case|case
name|CONF_MOD_MAXPOLL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"maxpoll: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|maxpoll
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxpoll
operator|>
name|NTP_MAXPOLL
condition|)
name|maxpoll
operator|=
name|NTP_MAXPOLL
expr_stmt|;
break|break;
case|case
name|CONF_MOD_PREFER
case|:
name|peerflags
operator||=
name|FLAG_PREFER
expr_stmt|;
break|break;
case|case
name|CONF_MOD_NOSELECT
case|:
name|peerflags
operator||=
name|FLAG_NOSELECT
expr_stmt|;
break|break;
case|case
name|CONF_MOD_BURST
case|:
name|peerflags
operator||=
name|FLAG_BURST
expr_stmt|;
break|break;
case|case
name|CONF_MOD_SKEY
case|:
name|peerflags
operator||=
name|FLAG_SKEY
operator||
name|FLAG_AUTHENABLE
expr_stmt|;
break|break;
case|case
name|CONF_MOD_TTL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ttl: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ttl
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONF_MOD_MODE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mode: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ttl
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|minpoll
operator|>
name|maxpoll
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"config error: minpoll> maxpoll"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|errflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer_config
argument_list|(
operator|&
name|peeraddr
argument_list|,
operator|(
expr|struct
name|interface
operator|*
operator|)
literal|0
argument_list|,
name|hmode
argument_list|,
name|peerversion
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|peerflags
argument_list|,
name|ttl
argument_list|,
name|peerkey
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"configuration of %s failed"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|errflg
operator|==
operator|-
literal|1
condition|)
block|{
name|save_resolve
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
name|hmode
argument_list|,
name|peerversion
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|peerflags
argument_list|,
name|ttl
argument_list|,
name|peerkey
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_DRIFTFILE
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
name|stats_config
argument_list|(
name|STATS_FREQ_FILE
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|stats_config
argument_list|(
name|STATS_FREQ_FILE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_PIDFILE
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
name|stats_config
argument_list|(
name|STATS_PID_FILE
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|stats_config
argument_list|(
name|STATS_PID_FILE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_LOGFILE
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|FILE
modifier|*
name|new_file
decl_stmt|;
name|new_file
operator|=
name|fopen
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_file
operator|!=
name|NULL
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"logging to file %s"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
operator|&&
name|fileno
argument_list|(
name|syslog_file
argument_list|)
operator|!=
name|fileno
argument_list|(
name|new_file
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|syslog_file
argument_list|)
expr_stmt|;
name|syslog_file
operator|=
name|new_file
expr_stmt|;
name|syslogit
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot open log file %s"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"logfile needs one argument"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_LOGCONFIG
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|add
init|=
literal|1
decl_stmt|;
name|int
name|equals
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|&
name|tokens
index|[
name|i
index|]
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'='
case|:
name|add
operator|=
operator|*
name|s
operator|==
literal|'+'
expr_stmt|;
name|equals
operator|=
operator|*
name|s
operator|==
literal|'='
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|equals
condition|)
block|{
name|ntp_syslogmask
operator|=
name|get_logmask
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|add
condition|)
block|{
name|ntp_syslogmask
operator||=
name|get_logmask
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntp_syslogmask
operator|&=
operator|~
name|get_logmask
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ntp_syslogmask = 0x%08lx (%s)\n"
argument_list|,
name|ntp_syslogmask
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|CONFIG_BROADCASTCLIENT
case|:
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
literal|1
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_MULTICASTCLIENT
case|:
case|case
name|CONFIG_MANYCASTSERVER
case|:
if|if
condition|(
name|ntokens
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|getnetnum
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|)
condition|)
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
name|htonl
argument_list|(
name|INADDR_NTP
argument_list|)
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|CONFIG_MULTICASTCLIENT
condition|)
block|{
name|sys_bclient
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"sys_bclient\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|CONFIG_MANYCASTSERVER
condition|)
block|{
name|sys_manycastserver
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"sys_manycastserver\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
break|break;
case|case
name|CONFIG_AUTHENTICATE
case|:
name|errflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|proto_config
argument_list|(
name|PROTO_AUTHENTICATE
argument_list|,
literal|1
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"no"
argument_list|)
condition|)
name|proto_config
argument_list|(
name|PROTO_AUTHENTICATE
argument_list|,
literal|0
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
else|else
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errflg
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"should be `authenticate yes|no'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_KEYS
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|getauthkeys
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_REVOKE
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|sys_revoke
operator|=
literal|1
operator|<<
name|max
argument_list|(
name|atoi
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_AUTOMAX
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|sys_automax
operator|=
literal|1
operator|<<
name|max
argument_list|(
name|atoi
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_RESTRICT
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"restrict requires an address"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"default"
argument_list|)
condition|)
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
comment|/* 			 * Use peerversion as flags, peerkey as mflags.  Ick. 			 */
name|peerversion
operator|=
literal|0
expr_stmt|;
name|peerkey
operator|=
literal|0
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
name|maskaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|~
operator|(
name|u_int32
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|res_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_RES_MASK
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mask keyword needs argument"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
operator|&
name|maskaddr
argument_list|,
literal|1
argument_list|)
condition|)
name|errflg
operator|++
expr_stmt|;
break|break;
case|case
name|CONF_RES_IGNORE
case|:
name|peerversion
operator||=
name|RES_IGNORE
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOSERVE
case|:
name|peerversion
operator||=
name|RES_DONTSERVE
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOTRUST
case|:
name|peerversion
operator||=
name|RES_DONTTRUST
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOQUERY
case|:
name|peerversion
operator||=
name|RES_NOQUERY
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOMODIFY
case|:
name|peerversion
operator||=
name|RES_NOMODIFY
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOPEER
case|:
name|peerversion
operator||=
name|RES_NOPEER
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOTRAP
case|:
name|peerversion
operator||=
name|RES_NOTRAP
expr_stmt|;
break|break;
case|case
name|CONF_RES_LPTRAP
case|:
name|peerversion
operator||=
name|RES_LPTRAP
expr_stmt|;
break|break;
case|case
name|CONF_RES_NTPPORT
case|:
name|peerkey
operator||=
name|RESM_NTPONLY
expr_stmt|;
break|break;
case|case
name|CONF_RES_LIMITED
case|:
name|peerversion
operator||=
name|RES_LIMITED
expr_stmt|;
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|SRCADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|==
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
condition|)
name|maskaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errflg
condition|)
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|peeraddr
argument_list|,
operator|&
name|maskaddr
argument_list|,
operator|(
name|int
operator|)
name|peerkey
argument_list|,
name|peerversion
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_BDELAY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|double
name|tmp
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|tmp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"broadcastdelay value %s undecodable"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proto_config
argument_list|(
name|PROTO_BROADDELAY
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_TRUSTEDKEY
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|u_long
name|tkey
decl_stmt|;
name|tkey
operator|=
name|atol
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tkey
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"trusted key %s unlikely"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authtrust
argument_list|(
name|tkey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_REQUESTKEY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|u_long
name|rkey
decl_stmt|;
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|rkey
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s is undecodable as request key"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rkey
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s makes a poor request keyid"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"set info_auth_key to %lu\n"
argument_list|,
name|rkey
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info_auth_keyid
operator|=
name|rkey
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_CONTROLKEY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|u_long
name|ckey
decl_stmt|;
name|ckey
operator|=
name|atol
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckey
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s makes a poor control keyid"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_auth_keyid
operator|=
name|ckey
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_TRAP
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no address for trap command, line ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
comment|/* 			 * Use peerversion for port number.  Barf. 			 */
name|errflg
operator|=
literal|0
expr_stmt|;
name|peerversion
operator|=
literal|0
expr_stmt|;
name|localaddr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
operator|-
literal|1
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|trap_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_TRAP_PORT
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"trap port requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peerversion
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|peerversion
operator|<=
literal|0
operator|||
name|peerversion
operator|>
literal|32767
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid port number %s, trap ignored"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONF_TRAP_INTERFACE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"trap interface requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|maskaddr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|localaddr
operator|=
name|findinterface
argument_list|(
operator|&
name|maskaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|localaddr
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't find interface with address %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|maskaddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|errflg
condition|)
block|{
if|if
condition|(
name|peerversion
operator|!=
literal|0
condition|)
name|peeraddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|peerversion
argument_list|)
expr_stmt|;
else|else
name|peeraddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|TRAPPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|localaddr
operator|==
name|NULL
condition|)
name|localaddr
operator|=
name|any_interface
expr_stmt|;
if|if
condition|(
operator|!
name|ctlsettrap
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|localaddr
argument_list|,
literal|0
argument_list|,
name|NTP_VERSION
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't set trap for %s, no resources"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_FUDGE
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no address for fudge command, line ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s is inappropriate address for the fudge command, line ignored"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|clock_stat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|clock_stat
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|c
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|fudge_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_FDG_TIME1
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|clock_stat
operator|.
name|fudgetime1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s time1 value in error"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVETIME1
expr_stmt|;
break|break;
case|case
name|CONF_FDG_TIME2
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|clock_stat
operator|.
name|fudgetime2
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s time2 value in error"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVETIME2
expr_stmt|;
break|break;
case|case
name|CONF_FDG_STRATUM
case|:
comment|/* HMS: the (long *)_ may be trouble */
if|if
condition|(
operator|!
name|atoint
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|(
name|long
operator|*
operator|)
operator|&
name|clock_stat
operator|.
name|fudgeval1
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s stratum value in error"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEVAL1
expr_stmt|;
break|break;
case|case
name|CONF_FDG_REFID
case|:
comment|/* HMS: Endianness and 0 bytes? */
comment|/* XXX */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|clock_stat
operator|.
name|fudgeval2
argument_list|,
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEVAL2
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG1
case|:
case|case
name|CONF_FDG_FLAG2
case|:
case|case
name|CONF_FDG_FLAG3
case|:
case|case
name|CONF_FDG_FLAG4
case|:
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|lpeerkey
argument_list|)
operator|||
name|lpeerkey
operator|>
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s flag value in error"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|peerkey
operator|=
name|lpeerkey
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|peerkey
operator|=
name|lpeerkey
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CONF_FDG_FLAG1
case|:
name|c
operator|=
name|CLK_FLAG1
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG1
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG2
case|:
name|c
operator|=
name|CLK_FLAG2
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG2
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG3
case|:
name|c
operator|=
name|CLK_FLAG3
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG3
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG4
case|:
name|c
operator|=
name|CLK_FLAG4
expr_stmt|;
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|peerkey
operator|==
literal|0
condition|)
name|clock_stat
operator|.
name|flags
operator|&=
operator|~
name|c
expr_stmt|;
else|else
name|clock_stat
operator|.
name|flags
operator||=
name|c
expr_stmt|;
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 			 * If reference clock support isn't defined the 			 * fudge line will still be accepted and syntax 			 * checked, but will essentially do nothing. 			 */
if|if
condition|(
operator|!
name|errflg
condition|)
block|{
name|refclock_control
argument_list|(
operator|&
name|peeraddr
argument_list|,
operator|&
name|clock_stat
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|CONFIG_STATSDIR
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|stats_config
argument_list|(
name|STATS_STATSDIR
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_STATISTICS
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|filegen
operator|=
name|filegen_get
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|filegen
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no statistics named %s available"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"enabling filegen for %s statistics \"%s%s\"\n"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|,
name|filegen
operator|->
name|prefix
argument_list|,
name|filegen
operator|->
name|basename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|filegen
operator|->
name|flag
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_FILEGEN
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no id for filegen command, line ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
name|filegen
operator|=
name|filegen_get
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|filegen
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown filegen \"%s\" ignored"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * peerversion is (ab)used for filegen file (index) 			 * peerkey	   is (ab)used for filegen type 			 * peerflags   is (ab)used for filegen flags 			 */
name|peerversion
operator|=
literal|0
expr_stmt|;
name|peerkey
operator|=
name|filegen
operator|->
name|type
expr_stmt|;
name|peerflags
operator|=
name|filegen
operator|->
name|flag
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|filegen_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_FGEN_FILE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filegen %s file requires argument"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|peerversion
operator|=
operator|++
name|i
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_TYPE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filegen %s type requires argument"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|peerkey
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
name|fgen_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|peerkey
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filegen %s unknown type \"%s\""
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CONF_FGEN_FLAG_LINK
case|:
name|peerflags
operator||=
name|FGEN_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_FLAG_NOLINK
case|:
name|peerflags
operator|&=
operator|~
name|FGEN_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_FLAG_ENABLE
case|:
name|peerflags
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_FLAG_DISABLE
case|:
name|peerflags
operator|&=
operator|~
name|FGEN_FLAG_ENABLED
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|errflg
condition|)
block|{
name|filegen_config
argument_list|(
name|filegen
argument_list|,
name|tokens
index|[
name|peerversion
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|peerkey
argument_list|,
operator|(
name|u_char
operator|)
name|peerflags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_SETVAR
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no value for setvar command - line ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_sys_var
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
name|strlen
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|,
name|RW
operator||
operator|(
operator|(
operator|(
operator|(
name|ntokens
operator|>
literal|2
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|tokens
index|[
literal|2
index|]
argument_list|,
literal|"default"
argument_list|)
operator|)
operator|)
condition|?
name|DEF
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_CLIENTLIMIT
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no value for clientlimit command - line ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_long
name|ui
decl_stmt|;
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|ui
argument_list|)
operator|||
operator|!
name|ui
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"illegal value for clientlimit command - line ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|bp
index|[
literal|80
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"client_limit=%lu"
argument_list|,
name|ui
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_sys_var
argument_list|(
name|bp
argument_list|,
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|client_limit
operator|=
name|ui
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_CLIENTPERIOD
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no value for clientperiod command - line ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_long
name|ui
decl_stmt|;
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|ui
argument_list|)
operator|||
name|ui
operator|<
literal|64
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"illegal value for clientperiod command - line ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|bp
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"client_limit_period=%ld"
argument_list|,
name|ui
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|bp
argument_list|,
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|client_limit_period
operator|=
name|ui
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_ENABLE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flag
decl_stmt|;
name|flag
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|flags_keywords
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"enable unknown flag %s"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|proto_config
argument_list|(
name|flag
argument_list|,
literal|1
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_DISABLE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flag
decl_stmt|;
name|flag
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|flags_keywords
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"disable unknown flag %s"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|proto_config
argument_list|(
name|flag
argument_list|,
literal|0
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_PHONE
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
operator|&&
name|i
operator|<
name|MAXPHONE
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|sys_phone
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|,
name|MAXDIAL
argument_list|)
expr_stmt|;
block|}
name|sys_phone
index|[
name|i
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|CONFIG_PPS
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pps missing device name"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|pps_device
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|,
name|MAXPPS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flag
decl_stmt|;
name|flag
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|pps_keywords
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|CONF_PPS_ASSERT
case|:
name|pps_assert
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CONF_PPS_CLEAR
case|:
name|pps_assert
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CONF_PPS_HARDPPS
case|:
name|pps_hardpps
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pps unknown flag %s"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errflg
condition|)
break|break;
block|}
break|break;
block|}
block|}
end_for

begin_if
if|if
condition|(
name|fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_if
if|if
condition|(
name|config_netinfo
condition|)
name|free_netinfo_config
argument_list|(
name|config_netinfo
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINFO */
end_comment

begin_if
if|if
condition|(
name|res_fp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Need name resolution 		 */
name|do_resolve_internal
argument_list|()
expr_stmt|;
block|}
end_if

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_comment
comment|/*   * get_netinfo_config - find the nearest NetInfo domain with an ntp  * configuration and initialize the configuration state.  */
end_comment

begin_function
unit|static
name|struct
name|netinfo_config_state
modifier|*
name|get_netinfo_config
parameter_list|()
block|{
name|ni_status
name|status
decl_stmt|;
name|void
modifier|*
name|domain
decl_stmt|;
name|ni_id
name|config_dir
decl_stmt|;
name|struct
name|netinfo_config_state
modifier|*
name|config
decl_stmt|;
if|if
condition|(
name|ni_open
argument_list|(
name|NULL
argument_list|,
literal|"."
argument_list|,
operator|&
name|domain
argument_list|)
operator|!=
name|NI_OK
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|(
name|status
operator|=
name|ni_pathsearch
argument_list|(
name|domain
argument_list|,
operator|&
name|config_dir
argument_list|,
name|NETINFO_CONFIG_DIR
argument_list|)
operator|)
operator|==
name|NI_NODIR
condition|)
block|{
name|void
modifier|*
name|next_domain
decl_stmt|;
if|if
condition|(
name|ni_open
argument_list|(
name|domain
argument_list|,
literal|".."
argument_list|,
operator|&
name|next_domain
argument_list|)
operator|!=
name|NI_OK
condition|)
block|{
name|ni_free
argument_list|(
name|next_domain
argument_list|)
expr_stmt|;
break|break;
block|}
name|ni_free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|domain
operator|=
name|next_domain
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|NI_OK
condition|)
block|{
name|ni_free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|config
operator|=
operator|(
expr|struct
name|netinfo_config_state
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo_config_state
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
name|config
operator|->
name|config_dir
operator|=
name|config_dir
expr_stmt|;
name|config
operator|->
name|prop_index
operator|=
literal|0
expr_stmt|;
name|config
operator|->
name|val_index
operator|=
literal|0
expr_stmt|;
name|config
operator|->
name|val_list
operator|=
name|NULL
expr_stmt|;
return|return
name|config
return|;
block|}
end_function

begin_comment
comment|/*  * free_netinfo_config - release NetInfo configuration state  */
end_comment

begin_function
specifier|static
name|void
name|free_netinfo_config
parameter_list|(
name|struct
name|netinfo_config_state
modifier|*
name|config
parameter_list|)
block|{
name|ni_free
argument_list|(
name|config
operator|->
name|domain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * gettokens_netinfo - return tokens from NetInfo  */
end_comment

begin_function
specifier|static
name|int
name|gettokens_netinfo
parameter_list|(
name|struct
name|netinfo_config_state
modifier|*
name|config
parameter_list|,
name|char
modifier|*
modifier|*
name|tokenlist
parameter_list|,
name|int
modifier|*
name|ntokens
parameter_list|)
block|{
name|int
name|prop_index
init|=
name|config
operator|->
name|prop_index
decl_stmt|;
name|int
name|val_index
init|=
name|config
operator|->
name|val_index
decl_stmt|;
name|char
modifier|*
modifier|*
name|val_list
init|=
name|config
operator|->
name|val_list
decl_stmt|;
comment|/* 	 * Iterate through each keyword and look for a property that matches it. 	 */
name|again
label|:
if|if
condition|(
operator|!
name|val_list
condition|)
block|{
for|for
control|(
init|;
name|prop_index
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|keywords
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|keywords
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|prop_index
operator|++
control|)
block|{
name|ni_namelist
name|namelist
decl_stmt|;
name|struct
name|keyword
name|current_prop
init|=
name|keywords
index|[
name|prop_index
index|]
decl_stmt|;
comment|/* 			 * For each value associated in the property, we're going to return 			 * a separate line. We squirrel away the values in the config state 			 * so the next time through, we don't need to do this lookup. 			 */
name|NI_INIT
argument_list|(
operator|&
name|namelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni_lookupprop
argument_list|(
name|config
operator|->
name|domain
argument_list|,
operator|&
name|config
operator|->
name|config_dir
argument_list|,
name|current_prop
operator|.
name|text
argument_list|,
operator|&
name|namelist
argument_list|)
operator|==
name|NI_OK
condition|)
block|{
name|ni_index
name|index
decl_stmt|;
comment|/* Found the property, but it has no values */
if|if
condition|(
name|namelist
operator|.
name|ni_namelist_len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|val_list
operator|=
name|config
operator|->
name|val_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|namelist
operator|.
name|ni_namelist_len
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"out of memory while configuring"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|namelist
operator|.
name|ni_namelist_len
condition|;
name|index
operator|++
control|)
block|{
name|char
modifier|*
name|value
init|=
name|namelist
operator|.
name|ni_namelist_val
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|val_list
index|[
name|index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|value
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"out of memory while configuring"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|val_list
index|[
name|index
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|val_list
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|ni_namelist_free
argument_list|(
operator|&
name|namelist
argument_list|)
expr_stmt|;
block|}
name|config
operator|->
name|prop_index
operator|=
name|prop_index
expr_stmt|;
block|}
comment|/* No list; we're done here. */
if|if
condition|(
operator|!
name|val_list
condition|)
return|return
name|CONFIG_UNKNOWN
return|;
comment|/* 	 * We have a list of values for the current property. 	 * Iterate through them and return each in order. 	 */
if|if
condition|(
name|val_list
index|[
name|val_index
index|]
condition|)
block|{
name|int
name|ntok
init|=
literal|1
decl_stmt|;
name|int
name|quoted
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tokens
init|=
name|val_list
index|[
name|val_index
index|]
decl_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s %s"
argument_list|,
name|keywords
index|[
name|prop_index
index|]
operator|.
name|text
argument_list|,
name|val_list
index|[
name|val_index
index|]
argument_list|)
expr_stmt|;
operator|(
specifier|const
name|char
operator|*
operator|)
name|tokenlist
index|[
literal|0
index|]
operator|=
name|keywords
index|[
name|prop_index
index|]
operator|.
name|text
expr_stmt|;
for|for
control|(
name|ntok
operator|=
literal|1
init|;
name|ntok
operator|<
name|MAXTOKENS
condition|;
name|ntok
operator|++
control|)
block|{
name|tokenlist
index|[
name|ntok
index|]
operator|=
name|tokens
expr_stmt|;
while|while
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|tokens
argument_list|)
operator|||
name|quoted
operator|)
condition|)
name|quoted
operator|^=
operator|(
operator|*
name|tokens
operator|++
operator|==
literal|'"'
operator|)
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
block|{
operator|*
name|tokens
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* must be space */
operator|*
name|tokens
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
name|tokens
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
break|break;
block|}
block|}
operator|*
name|ntokens
operator|=
name|ntok
operator|+
literal|1
expr_stmt|;
name|config
operator|->
name|val_index
operator|++
expr_stmt|;
return|return
name|keywords
index|[
name|prop_index
index|]
operator|.
name|keytype
return|;
block|}
comment|/* We're done with the current property. */
name|prop_index
operator|=
operator|++
name|config
operator|->
name|prop_index
expr_stmt|;
comment|/* Free val_list and reset counters. */
for|for
control|(
name|val_index
operator|=
literal|0
init|;
name|val_list
index|[
name|val_index
index|]
condition|;
name|val_index
operator|++
control|)
name|free
argument_list|(
name|val_list
index|[
name|val_index
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val_list
argument_list|)
expr_stmt|;
name|val_list
operator|=
name|config
operator|->
name|val_list
operator|=
name|NULL
expr_stmt|;
name|val_index
operator|=
name|config
operator|->
name|val_index
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINFO */
end_comment

begin_comment
comment|/*  * gettokens - read a line and return tokens  */
end_comment

begin_function
specifier|static
name|int
name|gettokens
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
modifier|*
name|tokenlist
parameter_list|,
name|int
modifier|*
name|ntokens
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|ntok
decl_stmt|;
specifier|register
name|int
name|quoted
init|=
literal|0
decl_stmt|;
comment|/* 	 * Find start of first token 	 */
name|again
label|:
while|while
condition|(
operator|(
name|cp
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
name|MAXLINE
argument_list|,
name|fp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|*
name|ntokens
operator|=
literal|0
expr_stmt|;
return|return
name|CONFIG_UNKNOWN
return|;
comment|/* hack.  Is recognized as EOF */
block|}
comment|/* 	 * Now separate out the tokens 	 */
for|for
control|(
name|ntok
operator|=
literal|0
init|;
name|ntok
operator|<
name|MAXTOKENS
condition|;
name|ntok
operator|++
control|)
block|{
name|tokenlist
index|[
name|ntok
index|]
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|quoted
operator|)
condition|)
name|quoted
operator|^=
operator|(
operator|*
name|cp
operator|++
operator|==
literal|'"'
operator|)
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* must be space */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 	 * Return the match 	 */
operator|*
name|ntokens
operator|=
name|ntok
operator|+
literal|1
expr_stmt|;
name|ntok
operator|=
name|matchkey
argument_list|(
name|tokenlist
index|[
literal|0
index|]
argument_list|,
name|keywords
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
name|CONFIG_UNKNOWN
condition|)
goto|goto
name|again
goto|;
return|return
name|ntok
return|;
block|}
end_function

begin_comment
comment|/*  * matchkey - match a keyword to a list  */
end_comment

begin_function
specifier|static
name|int
name|matchkey
parameter_list|(
specifier|register
name|char
modifier|*
name|word
parameter_list|,
specifier|register
name|struct
name|keyword
modifier|*
name|keys
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|keys
operator|->
name|keytype
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"configure: keyword \"%s\" unknown, line ignored"
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
name|CONFIG_UNKNOWN
return|;
block|}
if|if
condition|(
name|STRSAME
argument_list|(
name|word
argument_list|,
name|keys
operator|->
name|text
argument_list|)
condition|)
return|return
name|keys
operator|->
name|keytype
return|;
name|keys
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * getnetnum - return a net number (this is crude, but careful)  */
end_comment

begin_function
specifier|static
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|num
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|,
name|int
name|complain
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* will core dump on really stupid stuff */
name|u_int32
name|netnum
decl_stmt|;
comment|/* XXX ELIMINATE replace with decodenetnum */
name|cp
operator|=
name|num
expr_stmt|;
name|netnum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|buf
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'.'
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
break|break;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|255
condition|)
break|break;
name|netnum
operator|<<=
literal|8
expr_stmt|;
name|netnum
operator|+=
name|temp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"getnetnum %s step %d buf %s temp %d netnum %lu\n"
argument_list|,
name|num
argument_list|,
name|i
argument_list|,
name|buf
argument_list|,
name|temp
argument_list|,
operator|(
name|u_long
operator|)
name|netnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getnetnum: \"%s\" invalid host number, line ignored"
argument_list|,
name|num
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"getnetnum: \"%s\" invalid host number, line ignored\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* 	 * make up socket address.	Clear it out for neatness. 	 */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|netnum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"getnetnum given %s, got %s (%lx)\n"
argument_list|,
name|num
argument_list|,
name|ntoa
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|netnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_comment
comment|/*  * catchchild - receive the resolver's exit status  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|catchchild
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
comment|/* 	 * We only start up one child, and if we're here 	 * it should have already exited.  Hence the following 	 * shouldn't hang.  If it does, please tell me. 	 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
operator|(
name|void
operator|)
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT&& VXWORKS*/
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/*  * save_resolve - save configuration info into a file for later name resolution  */
end_comment

begin_function
specifier|static
name|void
name|save_resolve
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|minpoll
parameter_list|,
name|int
name|maxpoll
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|ttl
parameter_list|,
name|u_long
name|keyid
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SYS_VXWORKS
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|res_file
argument_list|,
name|RES_TEMPFILE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no /tmp directory under NT */
block|{
name|DWORD
name|len
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|=
name|GetTempPath
argument_list|(
operator|(
name|DWORD
operator|)
name|MAX_PATH
argument_list|,
operator|(
name|LPTSTR
operator|)
name|res_file
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot get pathname for temporary directory: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|res_file
argument_list|,
literal|"ntpdXXXXXX"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
ifdef|#
directive|ifdef
name|HAVE_MKSTEMP
block|{
name|int
name|fd
decl_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|res_file
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|res_fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|fopen
argument_list|(
name|res_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open failed for %s: %m"
argument_list|,
name|res_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"resolving %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|res_fp
argument_list|,
literal|"%s %d %d %d %d %d %d %lu\n"
argument_list|,
name|name
argument_list|,
name|mode
argument_list|,
name|version
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|flags
argument_list|,
name|ttl
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SYS_VXWORKS */
comment|/* save resolve info to a struct */
endif|#
directive|endif
comment|/* SYS_VXWORKS */
block|}
end_function

begin_comment
comment|/*  * abort_resolve - terminate the resolver stuff and delete the file  */
end_comment

begin_function
specifier|static
name|void
name|abort_resolve
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * In an ideal world we would might reread the file and 	 * log the hosts which aren't getting configured.  Since 	 * this is too much work, however, just close and delete 	 * the temp file. 	 */
if|if
condition|(
name|res_fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|res_fp
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_VXWORKS
comment|/* we don't open the file to begin with */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|delete
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
endif|#
directive|endif
comment|/* SYS_VXWORKS */
block|}
end_function

begin_define
define|#
directive|define
name|KEY_TYPE_MD5
value|4
end_define

begin_comment
comment|/*  * do_resolve_internal - start up the resolver function (not program)  */
end_comment

begin_comment
comment|/*  * On VMS, this routine will simply refuse to resolve anything.  *  * Possible implementation: keep `res_file' in memory, do async  * name resolution via QIO, update from within completion AST.  * I'm unlikely to find the time for doing this, though. -wjm  */
end_comment

begin_function
specifier|static
name|void
name|do_resolve_internal
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
comment|/* belch */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"internal error in do_resolve_internal: res_fp == NULL"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* we are done with this now */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|res_fp
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
comment|/* find a keyid */
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
name|req_keyid
operator|=
literal|65535
expr_stmt|;
else|else
name|req_keyid
operator|=
name|info_auth_keyid
expr_stmt|;
comment|/* if doesn't exist, make up one at random */
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|req_keyid
argument_list|)
condition|)
block|{
name|char
name|rankey
index|[
literal|8
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|rankey
index|[
name|i
index|]
operator|=
name|RANDOM
operator|&
literal|0xff
expr_stmt|;
name|authusekey
argument_list|(
name|req_keyid
argument_list|,
name|KEY_TYPE_MD5
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|rankey
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|req_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* save keyid so we will accept config requests with it */
name|info_auth_keyid
operator|=
name|req_keyid
expr_stmt|;
name|req_file
operator|=
name|res_file
expr_stmt|;
comment|/* set up pointer to res file */
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|catchchild
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_VXWORKS
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 		 * this used to close everything 		 * I don't think this is necessary 		 */
comment|/* 		 * To the unknown commenter above: 		 * Well, I think it's better to clean up 		 * after oneself. I have had problems with 		 * refclock-io when intres was running - things 		 * where fine again when ntpintres was gone. 		 * So some systems react erratic at least. 		 * 		 *			Frank Kardel 		 * 		 * 94-11-16: 		 * Further debugging has proven that the above is 		 * absolutely harmful. The internal resolver 		 * is still in the SIGIO process group and the lingering 		 * async io information causes it to process requests from 		 * all file decriptor causing a race between the NTP daemon 		 * and the resolver. which then eats data when it wins 8-(. 		 * It is absolutly necessary to kill ane io associations 		 * shared with the NTP daemon. I currently don't want 		 * 		 * we also block SIGIO (currently no portes means to 		 * disable the signal handle for IO). 		 * 		 * Thanks to wgstuken@informatik.uni-erlangen.de to notice 		 * that it is the ntp-resolver child running into trouble. 		 * 		 * THUS: 		 */
name|closelog
argument_list|()
expr_stmt|;
name|kill_asyncio
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
literal|0
condition|)
name|debug
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"ntpd_initres"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LOG_DAEMON */
ifndef|#
directive|ifndef
name|LOG_NTP
define|#
directive|define
name|LOG_NTP
value|LOG_DAEMON
endif|#
directive|endif
name|openlog
argument_list|(
literal|"ntpd_initres"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_NTP
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_CYGWIN32
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* DEBUG */
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* @@@ was INFO */
endif|#
directive|endif
comment|/* LOG_DAEMON */
endif|#
directive|endif
name|ntp_intres
argument_list|()
expr_stmt|;
comment|/* 		 * If we got here, the intres code screwed up. 		 * Print something so we don't die without complaint 		 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"call to ntp_intres lost"
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* vxWorks spawns a thread... -casey */
name|i
operator|=
name|sp
argument_list|(
name|ntp_intres
argument_list|)
expr_stmt|;
comment|/*i = taskSpawn("ntp_intres",100,VX_FP_TASK,20000,ntp_intres);*/
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork() failed, can't start ntp_intres: %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|/* SYS_WINNT */
block|{
comment|/* NT's equivalent of fork() is _spawn(), but the start point 		 * of the new process is an executable filename rather than 		 * a function name as desired here. 		 */
name|DWORD
name|dwThreadId
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ResolverThreadHandle
operator|=
name|CreateThread
argument_list|(
name|NULL
argument_list|,
comment|/* no security attributes	*/
literal|0
argument_list|,
comment|/* use default stack size	*/
operator|(
name|LPTHREAD_START_ROUTINE
operator|)
name|ntp_intres
argument_list|,
comment|/* thread function		*/
name|NULL
argument_list|,
comment|/* argument to thread function   */
literal|0
argument_list|,
comment|/* use default creation flags	  */
operator|&
name|dwThreadId
argument_list|)
operator|)
condition|)
block|{
comment|/* returns the thread identifier */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"CreateThread() failed, can't start ntp_intres"
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
else|#
directive|else
comment|/* VMS  VX_WORKS */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Name resolution not implemented for VMS - use numeric addresses"
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VMS VX_WORKS */
block|}
end_function

end_unit

