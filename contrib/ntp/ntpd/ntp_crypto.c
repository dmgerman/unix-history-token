begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_crypto.c - NTP version 4 public key routines  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"openssl/asn1_mac.h"
end_include

begin_include
include|#
directive|include
file|"openssl/bn.h"
end_include

begin_include
include|#
directive|include
file|"openssl/err.h"
end_include

begin_include
include|#
directive|include
file|"openssl/evp.h"
end_include

begin_include
include|#
directive|include
file|"openssl/pem.h"
end_include

begin_include
include|#
directive|include
file|"openssl/rand.h"
end_include

begin_include
include|#
directive|include
file|"openssl/x509v3.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL_PLL
end_ifdef

begin_include
include|#
directive|include
file|"ntp_syscall.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

begin_comment
comment|/*  * Extension field message format  *  * These are always signed and saved before sending in network byte  * order. They must be converted to and from host byte order for  * processing.  *  * +-------+-------+  * |   op  |  len  |<- extension pointer  * +-------+-------+  * |    assocID    |  * +---------------+  * |   timestamp   |<- value pointer  * +---------------+  * |   filestamp   |  * +---------------+  * |   value len   |  * +---------------+  * |               |  * =     value     =  * |               |  * +---------------+  * | signature len |  * +---------------+  * |               |  * =   signature   =  * |               |  * +---------------+  *  * The CRYPTO_RESP bit is set to 0 for requests, 1 for responses.  * Requests carry the association ID of the receiver; responses carry  * the association ID of the sender. Some messages include only the  * operation/length and association ID words and so have length 8  * octets. Ohers include the value structure and associated value and  * signature fields. These messages include the timestamp, filestamp,  * value and signature words and so have length at least 24 octets. The  * signature and/or value fields can be empty, in which case the  * respective length words are zero. An empty value with nonempty  * signature is syntactically valid, but semantically questionable.  *  * The filestamp represents the time when a cryptographic data file such  * as a public/private key pair is created. It follows every reference  * depending on that file and serves as a means to obsolete earlier data  * of the same type. The timestamp represents the time when the  * cryptographic data of the message were last signed. Creation of a  * cryptographic data file or signing a message can occur only when the  * creator or signor is synchronized to an authoritative source and  * proventicated to a trusted authority.  *  * Note there are four conditions required for server trust. First, the  * public key on the certificate must be verified, which involves a  * number of format, content and consistency checks. Next, the server  * identity must be confirmed by one of four schemes: private  * certificate, IFF scheme, GQ scheme or certificate trail hike to a  * self signed trusted certificate. Finally, the server signature must  * be verified.  */
end_comment

begin_comment
comment|/*  * Cryptodefines  */
end_comment

begin_define
define|#
directive|define
name|TAI_1972
value|10
end_define

begin_comment
comment|/* initial TAI offset (s) */
end_comment

begin_define
define|#
directive|define
name|MAX_LEAP
value|100
end_define

begin_comment
comment|/* max UTC leapseconds (s) */
end_comment

begin_define
define|#
directive|define
name|VALUE_LEN
value|(6 * 4)
end_define

begin_comment
comment|/* min response field length */
end_comment

begin_define
define|#
directive|define
name|YEAR
value|(60 * 60 * 24 * 365)
end_define

begin_comment
comment|/* seconds in year */
end_comment

begin_comment
comment|/*  * Global cryptodata in host byte order  */
end_comment

begin_decl_stmt
name|u_int32
name|crypto_flags
init|=
literal|0x0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status word */
end_comment

begin_decl_stmt
name|u_int
name|sys_tai
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current UTC offset from TAI */
end_comment

begin_comment
comment|/*  * Global cryptodata in network byte order  */
end_comment

begin_decl_stmt
name|struct
name|cert_info
modifier|*
name|cinfo
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* certificate info/value */
end_comment

begin_decl_stmt
name|struct
name|value
name|hostval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host value */
end_comment

begin_decl_stmt
name|struct
name|value
name|pubkey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* public key */
end_comment

begin_decl_stmt
name|struct
name|value
name|tai_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* leapseconds table */
end_comment

begin_comment
comment|/*  * Private cryptodata in host byte order  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|passwd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private key password */
end_comment

begin_decl_stmt
specifier|static
name|EVP_PKEY
modifier|*
name|host_pkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host key */
end_comment

begin_decl_stmt
specifier|static
name|EVP_PKEY
modifier|*
name|sign_pkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sign key */
end_comment

begin_decl_stmt
specifier|static
name|EVP_PKEY
modifier|*
name|iffpar_pkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IFF parameters */
end_comment

begin_decl_stmt
specifier|static
name|EVP_PKEY
modifier|*
name|gqpar_pkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GQ parameters */
end_comment

begin_decl_stmt
specifier|static
name|EVP_PKEY
modifier|*
name|mvpar_pkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MV parameters */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|EVP_MD
modifier|*
name|sign_digest
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sign digest */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sign_siglen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sign key length */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rand_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* random seed file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|host_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host key file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sign_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sign key file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|iffpar_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IFF parameters file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gqpar_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GQ parameters file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mvpar_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MV parameters file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cert_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* certificate file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|leap_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* leapseconds file */
end_comment

begin_decl_stmt
specifier|static
name|tstamp_t
name|if_fstamp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IFF file stamp */
end_comment

begin_decl_stmt
specifier|static
name|tstamp_t
name|gq_fstamp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GQ file stamp */
end_comment

begin_decl_stmt
specifier|static
name|tstamp_t
name|mv_fstamp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MV file stamp */
end_comment

begin_comment
comment|/*  * Cryptotypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|crypto_verify
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|value
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|crypto_encrypt
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|value
operator|*
operator|,
name|keyid_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|crypto_alice
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
expr|struct
name|value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|crypto_alice2
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
expr|struct
name|value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|crypto_alice3
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
expr|struct
name|value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|crypto_bob
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|crypto_bob2
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|crypto_bob3
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|crypto_iff
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|crypto_gq
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|crypto_mv
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|crypto_send
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tstamp_t
name|crypto_time
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|asn2ntp
name|P
argument_list|(
operator|(
name|ASN1_TIME
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cert_info
modifier|*
name|cert_parse
name|P
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|u_int
operator|,
name|tstamp_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cert_sign
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cert_valid
name|P
argument_list|(
operator|(
expr|struct
name|cert_info
operator|*
operator|,
name|EVP_PKEY
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cert_install
name|P
argument_list|(
operator|(
expr|struct
name|exten
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cert_free
name|P
argument_list|(
operator|(
expr|struct
name|cert_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EVP_PKEY
modifier|*
name|crypto_key
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tstamp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bighash
name|P
argument_list|(
operator|(
name|BIGNUM
operator|*
operator|,
name|BIGNUM
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cert_info
modifier|*
name|crypto_cert
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|crypto_tai
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_function
name|int
name|readlink
parameter_list|(
name|char
modifier|*
name|link
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * session_key - generate session key  *  * This routine generates a session key from the source address,  * destination address, key ID and private value. The value of the  * session key is the MD5 hash of these values, while the next key ID is  * the first four octets of the hash.  *  * Returns the next key ID  */
end_comment

begin_function
name|keyid_t
name|session_key
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|srcadr
parameter_list|,
comment|/* source address */
name|struct
name|sockaddr_storage
modifier|*
name|dstadr
parameter_list|,
comment|/* destination address */
name|keyid_t
name|keyno
parameter_list|,
comment|/* key ID */
name|keyid_t
name|private
parameter_list|,
comment|/* private value */
name|u_long
name|lifetime
comment|/* key lifetime */
parameter_list|)
block|{
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* message digest context */
name|u_char
name|dgst
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
comment|/* message digest */
name|keyid_t
name|keyid
decl_stmt|;
comment|/* key identifer */
name|u_int32
name|header
index|[
literal|10
index|]
decl_stmt|;
comment|/* data in network byte order */
name|u_int
name|hdlen
decl_stmt|,
name|len
decl_stmt|;
comment|/* 	 * Generate the session key and key ID. If the lifetime is 	 * greater than zero, install the key and call it trusted. 	 */
name|hdlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|srcadr
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|header
index|[
literal|0
index|]
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|srcadr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|header
index|[
literal|1
index|]
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dstadr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|header
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
name|header
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|private
argument_list|)
expr_stmt|;
name|hdlen
operator|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|memcpy
argument_list|(
operator|&
name|header
index|[
literal|0
index|]
argument_list|,
operator|&
name|GET_INADDR6
argument_list|(
operator|*
name|srcadr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|header
index|[
literal|4
index|]
argument_list|,
operator|&
name|GET_INADDR6
argument_list|(
operator|*
name|dstadr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|header
index|[
literal|8
index|]
operator|=
name|htonl
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
name|header
index|[
literal|9
index|]
operator|=
name|htonl
argument_list|(
name|private
argument_list|)
expr_stmt|;
name|hdlen
operator|=
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
expr_stmt|;
break|break;
block|}
name|EVP_DigestInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|EVP_md5
argument_list|()
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|header
argument_list|,
name|hdlen
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|dgst
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|keyid
argument_list|,
name|dgst
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|keyid
operator|=
name|ntohl
argument_list|(
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lifetime
operator|!=
literal|0
condition|)
block|{
name|MD5auth_setkey
argument_list|(
name|keyno
argument_list|,
name|dgst
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|keyno
argument_list|,
name|lifetime
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"session_key: %s> %s %08x %08x hash %08x life %lu\n"
argument_list|,
name|stoa
argument_list|(
name|srcadr
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|dstadr
argument_list|)
argument_list|,
name|keyno
argument_list|,
name|private
argument_list|,
name|keyid
argument_list|,
name|lifetime
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|keyid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * make_keylist - generate key list  *  * This routine constructs a pseudo-random sequence by repeatedly  * hashing the session key starting from a given source address,  * destination address, private value and the next key ID of the  * preceeding session key. The last entry on the list is saved along  * with its sequence number and public signature.  */
end_comment

begin_function
name|void
name|make_keylist
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|struct
name|interface
modifier|*
name|dstadr
comment|/* interface */
parameter_list|)
block|{
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|struct
name|autokey
modifier|*
name|ap
decl_stmt|;
comment|/* autokey pointer */
name|struct
name|value
modifier|*
name|vp
decl_stmt|;
comment|/* value pointer */
name|keyid_t
name|keyid
init|=
literal|0
decl_stmt|;
comment|/* next key ID */
name|keyid_t
name|cookie
decl_stmt|;
comment|/* private value */
name|u_long
name|lifetime
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Allocate the key list if necessary. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|keylist
operator|==
name|NULL
condition|)
name|peer
operator|->
name|keylist
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|keyid_t
argument_list|)
operator|*
name|NTP_MAXSESSION
argument_list|)
expr_stmt|;
comment|/* 	 * Generate an initial key ID which is unique and greater than 	 * NTP_MAXKEY. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|keyid
operator|=
operator|(
name|u_long
operator|)
name|RANDOM
operator|&
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|keyid
operator|<=
name|NTP_MAXKEY
condition|)
continue|continue;
if|if
condition|(
name|authhavekey
argument_list|(
name|keyid
argument_list|)
condition|)
continue|continue;
break|break;
block|}
comment|/* 	 * Generate up to NTP_MAXSESSION session keys. Stop if the 	 * next one would not be unique or not a session key ID or if 	 * it would expire before the next poll. The private value 	 * included in the hash is zero if broadcast mode, the peer 	 * cookie if client mode or the host cookie if symmetric modes. 	 */
name|lifetime
operator|=
name|min
argument_list|(
name|sys_automax
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|NTP_MAXSESSION
operator|*
operator|(
literal|1
operator|<<
operator|(
name|peer
operator|->
name|kpoll
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
condition|)
name|cookie
operator|=
literal|0
expr_stmt|;
else|else
name|cookie
operator|=
name|peer
operator|->
name|pcookie
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_MAXSESSION
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|keylist
index|[
name|i
index|]
operator|=
name|keyid
expr_stmt|;
name|peer
operator|->
name|keynumber
operator|=
name|i
expr_stmt|;
name|keyid
operator|=
name|session_key
argument_list|(
operator|&
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|keyid
argument_list|,
name|cookie
argument_list|,
name|lifetime
argument_list|)
expr_stmt|;
name|lifetime
operator|-=
literal|1
operator|<<
name|peer
operator|->
name|kpoll
expr_stmt|;
if|if
condition|(
name|auth_havekey
argument_list|(
name|keyid
argument_list|)
operator|||
name|keyid
operator|<=
name|NTP_MAXKEY
operator|||
name|lifetime
operator|<=
call|(
name|unsigned
name|long
call|)
argument_list|(
literal|1
operator|<<
operator|(
name|peer
operator|->
name|kpoll
operator|)
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * Save the last session key ID, sequence number and timestamp, 	 * then sign these values for later retrieval by the clients. Be 	 * careful not to use invalid key media. Use the public values 	 * timestamp as filestamp.  	 */
name|vp
operator|=
operator|&
name|peer
operator|->
name|sndval
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|ptr
operator|==
name|NULL
condition|)
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|autokey
argument_list|)
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|(
expr|struct
name|autokey
operator|*
operator|)
name|vp
operator|->
name|ptr
expr_stmt|;
name|ap
operator|->
name|seq
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|keynumber
argument_list|)
expr_stmt|;
name|ap
operator|->
name|key
operator|=
name|htonl
argument_list|(
name|keyid
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|autokey
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|tstamp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|sig
operator|==
name|NULL
condition|)
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|vp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|autokey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"make_keys %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_ASSOC
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"make_keys: %d %08x %08x ts %u fs %u poll %d\n"
argument_list|,
name|ntohl
argument_list|(
name|ap
operator|->
name|seq
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ap
operator|->
name|key
argument_list|)
argument_list|,
name|cookie
argument_list|,
name|ntohl
argument_list|(
name|vp
operator|->
name|tstamp
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|vp
operator|->
name|fstamp
argument_list|)
argument_list|,
name|peer
operator|->
name|kpoll
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * crypto_recv - parse extension fields  *  * This routine is called when the packet has been matched to an  * association and passed sanity, format and MAC checks. We believe the  * extension field values only if the field has proper format and  * length, the timestamp and filestamp are valid and the signature has  * valid length and is verified. There are a few cases where some values  * are believed even if the signature fails, but only if the proventic  * bit is not set.  */
end_comment

begin_function
name|int
name|crypto_recv
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* packet buffer pointer */
parameter_list|)
block|{
specifier|const
name|EVP_MD
modifier|*
name|dp
decl_stmt|;
comment|/* message digest algorithm */
name|u_int32
modifier|*
name|pkt
decl_stmt|;
comment|/* receive packet pointer */
name|struct
name|autokey
modifier|*
name|ap
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
comment|/* autokey pointer */
name|struct
name|exten
modifier|*
name|ep
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
comment|/* extension pointers */
name|int
name|has_mac
decl_stmt|;
comment|/* length of MAC field */
name|int
name|authlen
decl_stmt|;
comment|/* offset of MAC field */
name|associd_t
name|associd
decl_stmt|;
comment|/* association ID */
name|tstamp_t
name|tstamp
init|=
literal|0
decl_stmt|;
comment|/* timestamp */
name|tstamp_t
name|fstamp
init|=
literal|0
decl_stmt|;
comment|/* filestamp */
name|u_int
name|len
decl_stmt|;
comment|/* extension field length */
name|u_int
name|code
decl_stmt|;
comment|/* extension field opcode */
name|u_int
name|vallen
init|=
literal|0
decl_stmt|;
comment|/* value length */
name|X509
modifier|*
name|cert
decl_stmt|;
comment|/* X509 certificate */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|keyid_t
name|cookie
decl_stmt|;
comment|/* crumbles */
name|int
name|rval
init|=
name|XEVNT_OK
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|u_int32
name|temp32
decl_stmt|;
ifdef|#
directive|ifdef
name|KERNEL_PLL
if|#
directive|if
name|NTP_API
operator|>
literal|3
name|struct
name|timex
name|ntv
decl_stmt|;
comment|/* kernel interface structure */
endif|#
directive|endif
comment|/* NTP_API */
endif|#
directive|endif
comment|/* KERNEL_PLL */
comment|/* 	 * Initialize. Note that the packet has already been checked for 	 * valid format and extension field lengths. First extract the 	 * field length, command code and association ID in host byte 	 * order. These are used with all commands and modes. Then check 	 * the version number, which must be 2, and length, which must 	 * be at least 8 for requests and VALUE_LEN (24) for responses. 	 * Packets that fail either test sink without a trace. The 	 * association ID is saved only if nonzero. 	 */
name|authlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
while|while
condition|(
operator|(
name|has_mac
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|authlen
operator|)
operator|>
name|MAX_MAC_LEN
condition|)
block|{
name|pkt
operator|=
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_pkt
operator|+
name|authlen
operator|/
literal|4
expr_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|exten
operator|*
operator|)
name|pkt
expr_stmt|;
name|code
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
operator|&
literal|0xffff0000
expr_stmt|;
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|associd
operator|=
operator|(
name|associd_t
operator|)
name|ntohl
argument_list|(
name|pkt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rval
operator|=
name|XEVNT_OK
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: flags 0x%x ext offset %d len %u code %x assocID %d\n"
argument_list|,
name|peer
operator|->
name|crypto
argument_list|,
name|authlen
argument_list|,
name|len
argument_list|,
name|code
operator|>>
literal|16
argument_list|,
name|associd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Check version number and field length. If bad, 		 * quietly ignore the packet. 		 */
if|if
condition|(
operator|(
operator|(
name|code
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
operator|)
operator|!=
name|CRYPTO_VN
operator|||
name|len
operator|<
literal|8
operator|||
operator|(
name|len
operator|<
name|VALUE_LEN
operator|&&
operator|(
name|code
operator|&
name|CRYPTO_RESP
operator|)
operator|)
condition|)
block|{
name|sys_unknownversion
operator|++
expr_stmt|;
name|code
operator||=
name|CRYPTO_ERROR
expr_stmt|;
block|}
comment|/* 		 * Little vulnerability bandage here. If a perp tosses a 		 * fake association ID over the fence, we better toss it 		 * out. Only the first one counts. 		 */
if|if
condition|(
name|code
operator|&
name|CRYPTO_RESP
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|assoc
operator|==
literal|0
condition|)
name|peer
operator|->
name|assoc
operator|=
name|associd
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|->
name|assoc
operator|!=
name|associd
condition|)
name|code
operator||=
name|CRYPTO_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
name|VALUE_LEN
condition|)
block|{
name|tstamp
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|tstamp
argument_list|)
expr_stmt|;
name|fstamp
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|vallen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* 		 * Install status word, host name, signature scheme and 		 * association ID. In OpenSSL the signature algorithm is 		 * bound to the digest algorithm, so the NID completely 		 * defines the signature scheme. Note the request and 		 * response are identical, but neither is validated by 		 * signature. The request is processed here only in 		 * symmetric modes. The server name field would be 		 * useful to implement access controls in future. 		 */
case|case
name|CRYPTO_ASSOC
case|:
comment|/* 			 * Pass the extension field to the transmit 			 * side. 			 */
name|fp
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fp
argument_list|,
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|temp32
operator|=
name|CRYPTO_RESP
expr_stmt|;
name|fp
operator|->
name|opcode
operator||=
name|htonl
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|fp
expr_stmt|;
comment|/* fall through */
case|case
name|CRYPTO_ASSOC
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if it has already been 			 * stored or the server is not synchronized. 			 */
if|if
condition|(
name|peer
operator|->
name|crypto
operator|||
operator|!
name|fstamp
condition|)
break|break;
if|if
condition|(
name|len
operator|<
name|VALUE_LEN
operator|+
name|vallen
condition|)
block|{
name|rval
operator|=
name|XEVNT_LEN
expr_stmt|;
break|break;
block|}
comment|/* 			 * Check the identity schemes are compatible. If 			 * the client has PC, the server must have PC, 			 * in which case the server public key and 			 * identity are presumed valid, so we skip the 			 * certificate and identity exchanges and move 			 * immediately to the cookie exchange which 			 * confirms the server signature. If the client 			 * has IFF or GC or both, the server must have 			 * the same one or both. Otherwise, the default 			 * TC scheme is used. 			 */
if|if
condition|(
name|crypto_flags
operator|&
name|CRYPTO_FLAG_PRIV
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fstamp
operator|&
name|CRYPTO_FLAG_PRIV
operator|)
condition|)
name|rval
operator|=
name|XEVNT_KEY
expr_stmt|;
else|else
name|fstamp
operator||=
name|CRYPTO_FLAG_VALID
operator||
name|CRYPTO_FLAG_VRFY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crypto_flags
operator|&
name|CRYPTO_FLAG_MASK
operator|&&
operator|!
operator|(
name|crypto_flags
operator|&
name|fstamp
operator|&
name|CRYPTO_FLAG_MASK
operator|)
condition|)
block|{
name|rval
operator|=
name|XEVNT_KEY
expr_stmt|;
block|}
comment|/* 			 * Discard the message if identity error. 			 */
if|if
condition|(
name|rval
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Discard the message if the host name length 			 * is unreasonable or the signature digest NID 			 * is not supported. 			 */
name|temp32
operator|=
operator|(
name|fstamp
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|dp
operator|=
operator|(
specifier|const
name|EVP_MD
operator|*
operator|)
name|EVP_get_digestbynid
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
if|if
condition|(
name|vallen
operator|==
literal|0
operator|||
name|vallen
operator|>
name|MAXHOSTNAME
condition|)
name|rval
operator|=
name|XEVNT_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XEVNT_MD
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Save status word, host name and message 			 * digest/signature type. If PC identity, be 			 * sure not to sign the certificate. 			 */
if|if
condition|(
name|crypto_flags
operator|&
name|CRYPTO_FLAG_PRIV
condition|)
name|fstamp
operator||=
name|CRYPTO_FLAG_SIGN
expr_stmt|;
name|peer
operator|->
name|crypto
operator|=
name|fstamp
expr_stmt|;
name|peer
operator|->
name|digest
operator|=
name|dp
expr_stmt|;
name|peer
operator|->
name|subject
operator|=
name|emalloc
argument_list|(
name|vallen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|peer
operator|->
name|subject
argument_list|,
name|ep
operator|->
name|pkt
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|peer
operator|->
name|subject
index|[
name|vallen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|peer
operator|->
name|issuer
operator|=
name|emalloc
argument_list|(
name|vallen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|peer
operator|->
name|issuer
argument_list|,
name|peer
operator|->
name|subject
argument_list|)
expr_stmt|;
name|temp32
operator|=
operator|(
name|fstamp
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"flags 0x%x host %s signature %s"
argument_list|,
name|fstamp
argument_list|,
name|peer
operator|->
name|subject
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|temp32
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Decode X509 certificate in ASN.1 format and extract 		 * the data containing, among other things, subject 		 * name and public key. In the default identification 		 * scheme, the certificate trail is followed to a self 		 * signed trusted certificate. 		 */
case|case
name|CRYPTO_CERT
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid or identity 			 * already confirmed. 			 */
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Scan the certificate list to delete old 			 * versions and link the newest version first on 			 * the list. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|cert_install
argument_list|(
name|ep
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * If we snatch the certificate before the 			 * server certificate has been signed by its 			 * server, it will be self signed. When it is, 			 * we chase the certificate issuer, which the 			 * server has, and keep going until a self 			 * signed trusted certificate is found. Be sure 			 * to update the issuer field, since it may 			 * change. 			 */
if|if
condition|(
name|peer
operator|->
name|issuer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|issuer
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|cinfo
operator|->
name|issuer
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|peer
operator|->
name|issuer
argument_list|,
name|cinfo
operator|->
name|issuer
argument_list|)
expr_stmt|;
comment|/* 			 * We plug in the public key and group key in 			 * the first certificate received. However, note 			 * that this certificate might not be signed by 			 * the server, so we can't check the 			 * signature/digest NID. 			 */
if|if
condition|(
name|peer
operator|->
name|pkey
operator|==
name|NULL
condition|)
block|{
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cinfo
operator|->
name|cert
operator|.
name|ptr
expr_stmt|;
name|cert
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|ntohl
argument_list|(
name|cinfo
operator|->
name|cert
operator|.
name|vallen
argument_list|)
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
name|temp32
operator|=
name|cinfo
operator|->
name|nid
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"cert %s 0x%x %s (%u) fs %u"
argument_list|,
name|cinfo
operator|->
name|subject
argument_list|,
name|cinfo
operator|->
name|flags
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|temp32
argument_list|)
argument_list|,
name|temp32
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Schnorr (IFF)identity scheme. This scheme is designed 		 * for use with shared secret group keys and where the 		 * certificate may be generated by a third party. The 		 * client sends a challenge to the server, which 		 * performs a calculation and returns the result. A 		 * positive result is possible only if both client and 		 * server contain the same secret group key. 		 */
case|case
name|CRYPTO_IFF
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid or identity 			 * already confirmed. 			 */
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * If the the challenge matches the response, 			 * the certificate public key, as well as the 			 * server public key, signatyre and identity are 			 * all verified at the same time. The server is 			 * declared trusted, so we skip further 			 * certificate stages and move immediately to 			 * the cookie stage. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_iff
argument_list|(
name|ep
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_VRFY
operator||
name|CRYPTO_FLAG_PROV
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"iff fs %u"
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Guillou-Quisquater (GQ) identity scheme. This scheme 		 * is designed for use with public certificates carrying 		 * the GQ public key in an extension field. The client 		 * sends a challenge to the server, which performs a 		 * calculation and returns the result. A positive result 		 * is possible only if both client and server contain 		 * the same group key and the server has the matching GQ 		 * private key. 		 */
case|case
name|CRYPTO_GQ
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid or identity 			 * already confirmed. 			 */
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * If the the challenge matches the response, 			 * the certificate public key, as well as the 			 * server public key, signatyre and identity are 			 * all verified at the same time. The server is 			 * declared trusted, so we skip further 			 * certificate stages and move immediately to 			 * the cookie stage. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_gq
argument_list|(
name|ep
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_VRFY
operator||
name|CRYPTO_FLAG_PROV
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"gq fs %u"
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * MV 		 */
case|case
name|CRYPTO_MV
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid or identity 			 * already confirmed. 			 */
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * If the the challenge matches the response, 			 * the certificate public key, as well as the 			 * server public key, signatyre and identity are 			 * all verified at the same time. The server is 			 * declared trusted, so we skip further 			 * certificate stages and move immediately to 			 * the cookie stage. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_mv
argument_list|(
name|ep
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_VRFY
operator||
name|CRYPTO_FLAG_PROV
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"mv fs %u"
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * X509 certificate sign response. Validate the 		 * certificate signed by the server and install. Later 		 * this can be provided to clients of this server in 		 * lieu of the self signed certificate in order to 		 * validate the public key. 		 */
case|case
name|CRYPTO_SIGN
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid or identity 			 * not confirmed. 			 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Scan the certificate list to delete old 			 * versions and link the newest version first on 			 * the list. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|cert_install
argument_list|(
name|ep
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_SIGN
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
name|temp32
operator|=
name|cinfo
operator|->
name|nid
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"sign %s 0x%x %s (%u) fs %u"
argument_list|,
name|cinfo
operator|->
name|issuer
argument_list|,
name|cinfo
operator|->
name|flags
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|temp32
argument_list|)
argument_list|,
name|temp32
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Cookie request in symmetric modes. Roll a random 		 * cookie and install in symmetric mode. Encrypt for the 		 * response, which is transmitted later. 		 */
case|case
name|CRYPTO_COOK
case|:
comment|/* 			 * Discard the message if invalid or identity 			 * not confirmed. 			 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Pass the extension field to the transmit 			 * side. If already agreed, walk away. 			 */
name|fp
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fp
argument_list|,
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|temp32
operator|=
name|CRYPTO_RESP
expr_stmt|;
name|fp
operator|->
name|opcode
operator||=
name|htonl
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AGREE
condition|)
block|{
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
break|break;
block|}
comment|/* 			 * Install cookie values and light the cookie 			 * bit. The transmit side will pick up and 			 * encrypt it for the response. 			 */
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cookval
operator|.
name|tstamp
operator|=
name|ep
operator|->
name|tstamp
expr_stmt|;
name|peer
operator|->
name|cookval
operator|.
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
name|RAND_bytes
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|peer
operator|->
name|pcookie
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|peer
operator|->
name|crypto
operator|&=
operator|~
name|CRYPTO_FLAG_AUTO
expr_stmt|;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_AGREE
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"cook %x ts %u fs %u"
argument_list|,
name|peer
operator|->
name|pcookie
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|tstamp
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Cookie response in client and symmetric modes. If the 		 * cookie bit is set, the working cookie is the EXOR of 		 * the current and new values. 		 */
case|case
name|CRYPTO_COOK
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid or identity 			 * not confirmed or signature not verified with 			 * respect to the cookie values. 			 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
operator|&
name|peer
operator|->
name|cookval
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Decrypt the cookie, hunting all the time for 			 * errors. 			 */
if|if
condition|(
name|vallen
operator|==
operator|(
name|u_int
operator|)
name|EVP_PKEY_size
argument_list|(
name|host_pkey
argument_list|)
condition|)
block|{
name|RSA_private_decrypt
argument_list|(
name|vallen
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|temp32
argument_list|,
name|host_pkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|,
name|RSA_PKCS1_OAEP_PADDING
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|ntohl
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|XEVNT_CKY
expr_stmt|;
break|break;
block|}
comment|/* 			 * Install cookie values and light the cookie 			 * bit. If this is not broadcast client mode, we 			 * are done here. 			 */
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cookval
operator|.
name|tstamp
operator|=
name|ep
operator|->
name|tstamp
expr_stmt|;
name|peer
operator|->
name|cookval
operator|.
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AGREE
condition|)
name|peer
operator|->
name|pcookie
operator|^=
name|cookie
expr_stmt|;
else|else
name|peer
operator|->
name|pcookie
operator|=
name|cookie
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_CLIENT
operator|&&
operator|!
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
operator|)
condition|)
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_AUTO
expr_stmt|;
else|else
name|peer
operator|->
name|crypto
operator|&=
operator|~
name|CRYPTO_FLAG_AUTO
expr_stmt|;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_AGREE
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"cook %x ts %u fs %u"
argument_list|,
name|peer
operator|->
name|pcookie
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|tstamp
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Install autokey values in broadcast client and 		 * symmetric modes. We have to do this every time the 		 * sever/peer cookie changes or a new keylist is 		 * rolled. Ordinarily, this is automatic as this message 		 * is piggybacked on the first NTP packet sent upon 		 * either of these events. Note that a broadcast client 		 * or symmetric peer can receive this response without a 		 * matching request. 		 */
case|case
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid or identity 			 * not confirmed or signature not verified with 			 * respect to the receive autokey values. 			 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
operator|&
name|peer
operator|->
name|recval
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Install autokey values and light the 			 * autokey bit. This is not hard. 			 */
if|if
condition|(
name|peer
operator|->
name|recval
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|peer
operator|->
name|recval
operator|.
name|ptr
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|autokey
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|autokey
operator|*
operator|)
name|peer
operator|->
name|recval
operator|.
name|ptr
expr_stmt|;
name|peer
operator|->
name|recval
operator|.
name|tstamp
operator|=
name|ep
operator|->
name|tstamp
expr_stmt|;
name|peer
operator|->
name|recval
operator|.
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
name|ap
operator|=
operator|(
expr|struct
name|autokey
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
name|bp
operator|->
name|seq
operator|=
name|ntohl
argument_list|(
name|ap
operator|->
name|seq
argument_list|)
expr_stmt|;
name|bp
operator|->
name|key
operator|=
name|ntohl
argument_list|(
name|ap
operator|->
name|key
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pkeyid
operator|=
name|bp
operator|->
name|key
expr_stmt|;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_AUTO
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"auto seq %d key %x ts %u fs %u"
argument_list|,
name|bp
operator|->
name|seq
argument_list|,
name|bp
operator|->
name|key
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|tstamp
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Install leapseconds table in symmetric modes. This 		 * table is proventicated to the NIST primary servers, 		 * either by copying the file containing the table from 		 * a NIST server to a trusted server or directly using 		 * this protocol. While the entire table is installed at 		 * the server, presently only the current TAI offset is 		 * provided via the kernel to other applications. 		 */
case|case
name|CRYPTO_TAI
case|:
comment|/* 			 * Discard the message if invalid or identity 			 * not confirmed. 			 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Pass the extension field to the transmit 			 * side. Continue below if a leapseconds table 			 * accompanies the message. 			 */
name|fp
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fp
argument_list|,
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|temp32
operator|=
name|CRYPTO_RESP
expr_stmt|;
name|fp
operator|->
name|opcode
operator||=
name|htonl
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|VALUE_LEN
condition|)
block|{
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
break|break;
block|}
comment|/* fall through */
case|case
name|CRYPTO_TAI
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid or identity 			 * not confirmed or signature not verified with 			 * respect to the leapsecond table values. 			 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
operator|&
name|peer
operator|->
name|tai_leap
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Initialize peer variables, leapseconds 			 * structure and extension field in network byte 			 * order. Since a filestamp may have changed, 			 * recompute the signatures. 			 */
name|peer
operator|->
name|tai_leap
operator|.
name|tstamp
operator|=
name|ep
operator|->
name|tstamp
expr_stmt|;
name|peer
operator|->
name|tai_leap
operator|.
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
name|peer
operator|->
name|tai_leap
operator|.
name|vallen
operator|=
name|ep
operator|->
name|vallen
expr_stmt|;
comment|/* 			 * Install the new table if there is no stored 			 * table or the new table is more recent than 			 * the stored table. Since a filestamp may have 			 * changed, recompute the signatures. 			 */
if|if
condition|(
name|ntohl
argument_list|(
name|peer
operator|->
name|tai_leap
operator|.
name|fstamp
argument_list|)
operator|>
name|ntohl
argument_list|(
name|tai_leap
operator|.
name|fstamp
argument_list|)
condition|)
block|{
name|tai_leap
operator|.
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
name|tai_leap
operator|.
name|vallen
operator|=
name|ep
operator|->
name|vallen
expr_stmt|;
if|if
condition|(
name|tai_leap
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tai_leap
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|tai_leap
operator|.
name|ptr
operator|=
name|emalloc
argument_list|(
name|vallen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tai_leap
operator|.
name|ptr
argument_list|,
name|ep
operator|->
name|pkt
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|crypto_update
argument_list|()
expr_stmt|;
name|sys_tai
operator|=
name|vallen
operator|/
literal|4
operator|+
name|TAI_1972
operator|-
literal|1
expr_stmt|;
block|}
name|crypto_flags
operator||=
name|CRYPTO_FLAG_TAI
expr_stmt|;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_LEAP
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST10
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNEL_PLL
if|#
directive|if
name|NTP_API
operator|>
literal|3
comment|/* 			 * If the kernel cooperates, initialize the 			 * current TAI offset. 			 */
name|ntv
operator|.
name|modes
operator|=
name|MOD_TAI
expr_stmt|;
name|ntv
operator|.
name|constant
operator|=
name|sys_tai
expr_stmt|;
operator|(
name|void
operator|)
name|ntp_adjtime
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NTP_API */
endif|#
directive|endif
comment|/* KERNEL_PLL */
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"leap %u ts %u fs %u"
argument_list|,
name|vallen
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|tstamp
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * We come here in symmetric modes for miscellaneous 		 * commands that have value fields but are processed on 		 * the transmit side. All we need do here is check for 		 * valid field length. Remaining checks are below and on 		 * the transmit side. 		 */
case|case
name|CRYPTO_IFF
case|:
case|case
name|CRYPTO_GQ
case|:
case|case
name|CRYPTO_MV
case|:
case|case
name|CRYPTO_SIGN
case|:
if|if
condition|(
name|len
operator|<
name|VALUE_LEN
condition|)
block|{
name|rval
operator|=
name|XEVNT_LEN
expr_stmt|;
break|break;
block|}
comment|/* fall through */
comment|/* 		 * We come here for miscellaneous requests and unknown 		 * requests and responses. If an unknown response or 		 * error, forget it. If a request, save the extension 		 * field for later. Unknown requests will be caught on 		 * the transmit side. 		 */
default|default:
if|if
condition|(
name|code
operator|&
operator|(
name|CRYPTO_RESP
operator||
name|CRYPTO_ERROR
operator|)
condition|)
block|{
name|rval
operator|=
name|XEVNT_LEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
block|{
name|fp
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fp
argument_list|,
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|temp32
operator|=
name|CRYPTO_RESP
expr_stmt|;
name|fp
operator|->
name|opcode
operator||=
name|htonl
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|fp
expr_stmt|;
block|}
block|}
comment|/* 		 * We log everything except length/format errors and 		 * duplicates, which are log clogging vulnerabilities. 		 * The first error found terminates the extension field 		 * scan and we return the laundry to the caller. 		 */
if|if
condition|(
name|rval
operator|!=
name|XEVNT_OK
condition|)
block|{
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"error %x opcode %x ts %u fs %u"
argument_list|,
name|rval
argument_list|,
name|code
argument_list|,
name|tstamp
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|>
name|XEVNT_TSP
condition|)
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|rval
argument_list|,
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|authlen
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_xmit - construct extension fields  *  * This routine is called both when an association is configured and  * when one is not. The only case where this matters is to retrieve the  * autokey information, in which case the caller has to provide the  * association ID to match the association.  *  * Returns length of extension field.  */
end_comment

begin_function
name|int
name|crypto_xmit
parameter_list|(
name|struct
name|pkt
modifier|*
name|xpkt
parameter_list|,
comment|/* transmit packet pointer */
name|struct
name|sockaddr_storage
modifier|*
name|srcadr_sin
parameter_list|,
comment|/* active runway */
name|int
name|start
parameter_list|,
comment|/* offset to extension field */
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|keyid_t
name|cookie
comment|/* session cookie */
parameter_list|)
block|{
name|u_int32
modifier|*
name|pkt
decl_stmt|;
comment|/* packet pointer */
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* peer structure pointer */
name|u_int
name|opcode
decl_stmt|;
comment|/* extension field opcode */
name|struct
name|exten
modifier|*
name|fp
decl_stmt|;
comment|/* extension pointers */
name|struct
name|cert_info
modifier|*
name|cp
decl_stmt|;
comment|/* certificate info/value pointer */
name|char
name|certname
index|[
name|MAXHOSTNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* subject name buffer */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|u_int
name|vallen
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|struct
name|value
name|vtemp
decl_stmt|;
name|associd_t
name|associd
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|keyid_t
name|tcookie
decl_stmt|;
comment|/* 	 * Generate the requested extension field request code, length 	 * and association ID. If this is a response and the host is not 	 * synchronized, light the error bit and go home. 	 */
name|pkt
operator|=
operator|(
name|u_int32
operator|*
operator|)
name|xpkt
operator|+
name|start
operator|/
literal|4
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|exten
operator|*
operator|)
name|pkt
expr_stmt|;
name|opcode
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|associd
operator|=
operator|(
name|associd_t
operator|)
name|ntohl
argument_list|(
name|ep
operator|->
name|associd
argument_list|)
expr_stmt|;
name|fp
operator|->
name|associd
operator|=
name|htonl
argument_list|(
name|associd
argument_list|)
expr_stmt|;
name|len
operator|=
literal|8
expr_stmt|;
name|rval
operator|=
name|XEVNT_OK
expr_stmt|;
switch|switch
condition|(
name|opcode
operator|&
literal|0xffff0000
condition|)
block|{
comment|/* 	 * Send association request and response with status word and 	 * host name. Note, this message is not signed and the filestamp 	 * contains only the status word. We check at this point whether 	 * the identity schemes are compatible to save tears later on. 	 */
case|case
name|CRYPTO_ASSOC
operator||
name|CRYPTO_RESP
case|:
case|case
name|CRYPTO_ASSOC
case|:
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|hostval
argument_list|)
expr_stmt|;
if|if
condition|(
name|crypto_time
argument_list|()
operator|==
literal|0
condition|)
name|fp
operator|->
name|fstamp
operator|=
literal|0
expr_stmt|;
else|else
name|fp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|crypto_flags
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send certificate request. Use the values from the extension 	 * field. 	 */
case|case
name|CRYPTO_CERT
case|:
name|memset
argument_list|(
operator|&
name|vtemp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vtemp
argument_list|)
argument_list|)
expr_stmt|;
name|vtemp
operator|.
name|tstamp
operator|=
name|ep
operator|->
name|tstamp
expr_stmt|;
name|vtemp
operator|.
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
name|vtemp
operator|.
name|vallen
operator|=
name|ep
operator|->
name|vallen
expr_stmt|;
name|vtemp
operator|.
name|ptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send certificate response or sign request. Use the values 	 * from the certificate. If the request contains no subject 	 * name, assume the name of this host. This is for backwards 	 * compatibility.  Light the error bit if no certificate with 	 * the given subject name is found. Of course, private 	 * certificates are never sent. 	 */
case|case
name|CRYPTO_SIGN
case|:
case|case
name|CRYPTO_CERT
operator||
name|CRYPTO_RESP
case|:
name|vallen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|vallen
operator|==
literal|8
condition|)
block|{
name|strcpy
argument_list|(
name|certname
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vallen
operator|==
literal|0
operator|||
name|vallen
operator|>
name|MAXHOSTNAME
condition|)
block|{
name|opcode
operator||=
name|CRYPTO_ERROR
expr_stmt|;
break|break;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|certname
argument_list|,
name|ep
operator|->
name|pkt
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|certname
index|[
name|vallen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|cinfo
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|cp
operator|->
name|link
control|)
block|{
if|if
condition|(
name|cp
operator|->
name|flags
operator|&
name|CERT_PRIV
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|certname
argument_list|,
name|cp
operator|->
name|subject
argument_list|)
operator|==
literal|0
condition|)
block|{
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|cp
operator|->
name|cert
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|opcode
operator||=
name|CRYPTO_ERROR
expr_stmt|;
break|break;
comment|/* 	 * Send challenge in Schnorr (IFF) identity scheme. 	 */
case|case
name|CRYPTO_IFF
case|:
if|if
condition|(
operator|(
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|ep
operator|->
name|pkt
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|opcode
operator||=
name|CRYPTO_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_alice
argument_list|(
name|peer
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send response in Schnorr (IFF) identity scheme. 	 */
case|case
name|CRYPTO_IFF
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_bob
argument_list|(
name|ep
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send challenge in Guillou-Quisquater (GQ) identity scheme. 	 */
case|case
name|CRYPTO_GQ
case|:
if|if
condition|(
operator|(
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|ep
operator|->
name|pkt
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|opcode
operator||=
name|CRYPTO_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_alice2
argument_list|(
name|peer
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send response in Guillou-Quisquater (GQ) identity scheme. 	 */
case|case
name|CRYPTO_GQ
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_bob2
argument_list|(
name|ep
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send challenge in MV identity scheme. 	 */
case|case
name|CRYPTO_MV
case|:
if|if
condition|(
operator|(
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|ep
operator|->
name|pkt
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|opcode
operator||=
name|CRYPTO_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_alice3
argument_list|(
name|peer
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send response in MV identity scheme. 	 */
case|case
name|CRYPTO_MV
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_bob3
argument_list|(
name|ep
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send certificate sign response. The integrity of the request 	 * certificate has already been verified on the receive side. 	 * Sign the response using the local server key. Use the 	 * filestamp from the request and use the timestamp as the 	 * current time. Light the error bit if the certificate is 	 * invalid or contains an unverified signature. 	 */
case|case
name|CRYPTO_SIGN
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
operator|(
name|rval
operator|=
name|cert_sign
argument_list|(
name|ep
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send public key and signature. Use the values from the public 	 * key. 	 */
case|case
name|CRYPTO_COOK
case|:
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|pubkey
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Encrypt and send cookie and signature. Light the error bit if 	 * anything goes wrong. 	 */
case|case
name|CRYPTO_COOK
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
operator|(
name|opcode
operator|&
literal|0xffff
operator|)
operator|<
name|VALUE_LEN
condition|)
block|{
name|opcode
operator||=
name|CRYPTO_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|PKT_MODE
argument_list|(
name|xpkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_SERVER
condition|)
block|{
name|tcookie
operator|=
name|cookie
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|associd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|opcode
operator||=
name|CRYPTO_ERROR
expr_stmt|;
break|break;
block|}
name|tcookie
operator|=
name|peer
operator|->
name|pcookie
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_encrypt
argument_list|(
name|ep
argument_list|,
operator|&
name|vtemp
argument_list|,
operator|&
name|tcookie
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Find peer and send autokey data and signature in broadcast 	 * server and symmetric modes. Use the values in the autokey 	 * structure. If no association is found, either the server has 	 * restarted with new associations or some perp has replayed an 	 * old message, in which case light the error bit. 	 */
case|case
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
operator|(
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|associd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|opcode
operator||=
name|CRYPTO_ERROR
expr_stmt|;
break|break;
block|}
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_ASSOC
expr_stmt|;
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|peer
operator|->
name|sndval
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send leapseconds table and signature. Use the values from the 	 * tai structure. If no table has been loaded, just send a 	 * request. 	 */
case|case
name|CRYPTO_TAI
case|:
case|case
name|CRYPTO_TAI
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
name|crypto_flags
operator|&
name|CRYPTO_FLAG_TAI
condition|)
name|len
operator|+=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|tai_leap
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Default - Fall through for requests; for unknown responses, 	 * flag as error. 	 */
default|default:
if|if
condition|(
name|opcode
operator|&
name|CRYPTO_RESP
condition|)
name|opcode
operator||=
name|CRYPTO_ERROR
expr_stmt|;
block|}
comment|/* 	 * We ignore length/format errors and duplicates. Other errors 	 * are reported to the log and deny further service. To really 	 * persistent rascals we toss back a kiss-of-death grenade. 	 */
if|if
condition|(
name|rval
operator|>
name|XEVNT_TSP
condition|)
block|{
name|opcode
operator||=
name|CRYPTO_ERROR
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"error %x opcode %x"
argument_list|,
name|rval
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
name|srcadr_sin
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_xmit: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Round up the field length to a multiple of 8 bytes and save 	 * the request code and length. 	 */
name|len
operator|=
operator|(
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|*
literal|8
expr_stmt|;
name|fp
operator|->
name|opcode
operator|=
name|htonl
argument_list|(
operator|(
name|opcode
operator|&
literal|0xffff0000
operator|)
operator||
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_xmit: ext offset %d len %u code %x assocID %d\n"
argument_list|,
name|start
argument_list|,
name|len
argument_list|,
name|opcode
operator|>>
literal|16
argument_list|,
name|associd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_verify - parse and verify the extension field and value  *  * Returns  * XEVNT_OK	success  * XEVNT_LEN	bad field format or length  * XEVNT_TSP	bad timestamp  * XEVNT_FSP	bad filestamp  * XEVNT_PUB	bad or missing public key  * XEVNT_SGL	bad signature length  * XEVNT_SIG	signature not verified  */
end_comment

begin_function
specifier|static
name|int
name|crypto_verify
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|value
modifier|*
name|vp
parameter_list|,
comment|/* value pointer */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* server public key */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* timestamp */
name|tstamp_t
name|fstamp
decl_stmt|;
comment|/* filestamp */
name|u_int
name|vallen
decl_stmt|;
comment|/* value length */
name|u_int
name|siglen
decl_stmt|;
comment|/* signature length */
name|u_int
name|opcode
decl_stmt|,
name|len
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * We require valid opcode and field length, timestamp, 	 * filestamp, public key, digest, signature length and 	 * signature, where relevant. Note that preliminary length 	 * checks are done in the main loop. 	 */
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|opcode
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
operator|&
literal|0xffff0000
expr_stmt|;
comment|/* 	 * Check for valid operation code and protocol. The opcode must 	 * not have the error bit set. If a response, it must have a 	 * value header. If a request and does not contain a value 	 * header, no need for further checking. 	 */
if|if
condition|(
name|opcode
operator|&
name|CRYPTO_ERROR
condition|)
return|return
operator|(
name|XEVNT_LEN
operator|)
return|;
if|if
condition|(
name|opcode
operator|&
name|CRYPTO_RESP
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|VALUE_LEN
condition|)
return|return
operator|(
name|XEVNT_LEN
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|<
name|VALUE_LEN
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
comment|/* 	 * We have a value header. Check for valid field lengths. The 	 * field length must be long enough to contain the value header, 	 * value and signature. If a request and a previous request of 	 * the same type is pending, discard the previous request. If a 	 * request but no signature, there is no need for further 	 * checking. 	 */
name|vallen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
operator|(
operator|(
name|VALUE_LEN
operator|+
name|vallen
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
condition|)
return|return
operator|(
name|XEVNT_LEN
operator|)
return|;
name|i
operator|=
operator|(
name|vallen
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|siglen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|pkt
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|VALUE_LEN
operator|+
name|vallen
operator|+
name|siglen
condition|)
return|return
operator|(
name|XEVNT_LEN
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|opcode
operator|&
name|CRYPTO_RESP
operator|)
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|opcode
operator||
name|CRYPTO_RESP
operator|)
operator|==
operator|(
name|ntohl
argument_list|(
name|peer
operator|->
name|cmmd
operator|->
name|opcode
argument_list|)
operator|&
literal|0xffff0000
operator|)
condition|)
block|{
name|free
argument_list|(
name|peer
operator|->
name|cmmd
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|XEVNT_LEN
operator|)
return|;
block|}
block|}
if|if
condition|(
name|siglen
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
comment|/* 	 * We have a signature. Check for valid timestamp and filestamp. 	 * The timestamp must not precede the filestamp. The timestamp 	 * and filestamp must not precede the corresponding values in 	 * the value structure. Once the autokey values have been 	 * installed, the timestamp must always be later than the 	 * corresponding value in the value structure. Duplicate 	 * timestamps are illegal once the cookie has been validated. 	 */
name|rval
operator|=
name|XEVNT_OK
expr_stmt|;
if|if
condition|(
name|crypto_flags
operator|&
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_PRIV
condition|)
name|pkey
operator|=
name|sign_pkey
expr_stmt|;
else|else
name|pkey
operator|=
name|peer
operator|->
name|pkey
expr_stmt|;
name|tstamp
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|tstamp
argument_list|)
expr_stmt|;
name|fstamp
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
operator|||
name|tstamp
operator|<
name|fstamp
condition|)
block|{
name|rval
operator|=
name|XEVNT_TSP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|!=
name|NULL
operator|&&
operator|(
name|tstamp
operator|<
name|ntohl
argument_list|(
name|vp
operator|->
name|tstamp
argument_list|)
operator|||
operator|(
name|tstamp
operator|==
name|ntohl
argument_list|(
name|vp
operator|->
name|tstamp
argument_list|)
operator|&&
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_AUTO
operator|)
operator|)
operator|)
condition|)
block|{
name|rval
operator|=
name|XEVNT_TSP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|!=
name|NULL
operator|&&
operator|(
name|tstamp
operator|<
name|ntohl
argument_list|(
name|vp
operator|->
name|fstamp
argument_list|)
operator|||
name|fstamp
operator|<
name|ntohl
argument_list|(
name|vp
operator|->
name|fstamp
argument_list|)
operator|)
condition|)
block|{
name|rval
operator|=
name|XEVNT_FSP
expr_stmt|;
comment|/* 	 * If a public key and digest is present, and if valid key 	 * length, check for valid signature. Note that the first valid 	 * signature lights the proventic bit. 	 */
block|}
elseif|else
if|if
condition|(
name|pkey
operator|==
name|NULL
operator|||
name|peer
operator|->
name|digest
operator|==
name|NULL
condition|)
block|{
comment|/* fall through */
block|}
elseif|else
if|if
condition|(
name|siglen
operator|!=
operator|(
name|u_int
operator|)
name|EVP_PKEY_size
argument_list|(
name|pkey
argument_list|)
condition|)
block|{
name|rval
operator|=
name|XEVNT_SGL
expr_stmt|;
block|}
else|else
block|{
name|EVP_VerifyInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|peer
operator|->
name|digest
argument_list|)
expr_stmt|;
name|EVP_VerifyUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ep
operator|->
name|tstamp
argument_list|,
name|vallen
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_VerifyFinal
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ep
operator|->
name|pkt
index|[
name|i
index|]
argument_list|,
name|siglen
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
condition|)
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_PROV
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|XEVNT_SIG
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"crypto_recv: verify %x vallen %u siglen %u ts %u fs %u\n"
argument_list|,
name|rval
argument_list|,
name|vallen
argument_list|,
name|siglen
argument_list|,
name|tstamp
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_encrypt - construct encrypted cookie and signature from  * extension field and cookie  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  * XEVNT_CKY	bad or missing cookie  */
end_comment

begin_function
specifier|static
name|int
name|crypto_encrypt
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|value
modifier|*
name|vp
parameter_list|,
comment|/* value pointer */
name|keyid_t
modifier|*
name|cookie
comment|/* server cookie */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* public key */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|u_int32
name|temp32
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
comment|/* 	 * Extract the public key from the request. 	 */
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
name|pkey
operator|=
name|d2i_PublicKey
argument_list|(
name|EVP_PKEY_RSA
argument_list|,
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_encrypt %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Encrypt the cookie, encode in ASN.1 and sign. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|len
operator|=
name|EVP_PKEY_size
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|temp32
operator|=
name|htonl
argument_list|(
operator|*
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RSA_public_encrypt
argument_list|(
literal|4
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|temp32
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|,
name|RSA_PKCS1_OAEP_PADDING
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_encrypt %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_CKY
operator|)
return|;
block|}
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_ident - construct extension field for identity scheme  *  * This routine determines which identity scheme is in use and  * constructs an extension field for that scheme.  */
end_comment

begin_function
name|u_int
name|crypto_ident
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|char
name|filename
index|[
name|MAXFILENAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * If the server identity has already been verified, no further 	 * action is necessary. Otherwise, try to load the identity file 	 * of the certificate issuer. If the issuer file is not found, 	 * try the host file. If nothing found, declare a cryptobust. 	 * Note we can't get here unless the trusted certificate has 	 * been found and the CRYPTO_FLAG_VALID bit is set, so the 	 * certificate issuer is valid. 	 */
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|peer
operator|->
name|ident_pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_GQ
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_gq_%s"
argument_list|,
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|ident_pkey
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
operator|&
name|peer
operator|->
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|!=
name|NULL
condition|)
return|return
operator|(
name|CRYPTO_GQ
operator|)
return|;
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_gq_%s"
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
name|peer
operator|->
name|ident_pkey
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
operator|&
name|peer
operator|->
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|!=
name|NULL
condition|)
return|return
operator|(
name|CRYPTO_GQ
operator|)
return|;
block|}
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_IFF
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_iff_%s"
argument_list|,
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|ident_pkey
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
operator|&
name|peer
operator|->
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|!=
name|NULL
condition|)
return|return
operator|(
name|CRYPTO_IFF
operator|)
return|;
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_iff_%s"
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
name|peer
operator|->
name|ident_pkey
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
operator|&
name|peer
operator|->
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|!=
name|NULL
condition|)
return|return
operator|(
name|CRYPTO_IFF
operator|)
return|;
block|}
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_MV
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_mv_%s"
argument_list|,
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|ident_pkey
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
operator|&
name|peer
operator|->
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|!=
name|NULL
condition|)
return|return
operator|(
name|CRYPTO_MV
operator|)
return|;
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_mv_%s"
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
name|peer
operator|->
name|ident_pkey
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
operator|&
name|peer
operator|->
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|!=
name|NULL
condition|)
return|return
operator|(
name|CRYPTO_MV
operator|)
return|;
block|}
comment|/* 	 * No compatible identity scheme is available. Use the default 	 * TC scheme. 	 */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_ident: no compatible identity scheme found"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_args - construct extension field from arguments  *  * This routine creates an extension field with current timestamps and  * specified opcode, association ID and optional string. Note that the  * extension field is created here, but freed after the crypto_xmit()  * call in the protocol module.  *  * Returns extension field pointer (no errors).  */
end_comment

begin_function
name|struct
name|exten
modifier|*
name|crypto_args
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|u_int
name|opcode
parameter_list|,
comment|/* operation code */
name|char
modifier|*
name|str
comment|/* argument string */
parameter_list|)
block|{
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|struct
name|exten
modifier|*
name|ep
decl_stmt|;
comment|/* extension field pointer */
name|u_int
name|len
decl_stmt|;
comment|/* extension field length */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|exten
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ep
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ep
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ep
operator|->
name|opcode
operator|=
name|htonl
argument_list|(
name|opcode
operator|+
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * If a response, send our ID; if a request, send the 	 * responder's ID. 	 */
if|if
condition|(
name|opcode
operator|&
name|CRYPTO_RESP
condition|)
name|ep
operator|->
name|associd
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
else|else
name|ep
operator|->
name|associd
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
name|ep
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|ep
operator|->
name|fstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|ep
operator|->
name|vallen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|ep
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|->
name|pkt
index|[
literal|0
index|]
operator|=
name|peer
operator|->
name|associd
expr_stmt|;
block|}
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_send - construct extension field from value components  *  * Returns extension field length. Note: it is not polite to send a  * nonempty signature with zero timestamp or a nonzero timestamp with  * empty signature, but these rules are not enforced here.  */
end_comment

begin_function
name|u_int
name|crypto_send
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension field pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|,
name|temp32
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Copy data. If the data field is empty or zero length, encode 	 * an empty value with length zero. 	 */
name|ep
operator|->
name|tstamp
operator|=
name|vp
operator|->
name|tstamp
expr_stmt|;
name|ep
operator|->
name|fstamp
operator|=
name|vp
operator|->
name|fstamp
expr_stmt|;
name|ep
operator|->
name|vallen
operator|=
name|vp
operator|->
name|vallen
expr_stmt|;
name|len
operator|=
literal|12
expr_stmt|;
name|temp32
operator|=
name|ntohl
argument_list|(
name|vp
operator|->
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp32
operator|>
literal|0
operator|&&
name|vp
operator|->
name|ptr
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|ep
operator|->
name|pkt
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|temp32
argument_list|)
expr_stmt|;
comment|/* 	 * Copy signature. If the signature field is empty or zero 	 * length, encode an empty signature with length zero. 	 */
name|i
operator|=
operator|(
name|temp32
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|len
operator|+=
name|i
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
name|ep
operator|->
name|pkt
index|[
name|i
operator|++
index|]
operator|=
name|vp
operator|->
name|siglen
expr_stmt|;
name|temp32
operator|=
name|ntohl
argument_list|(
name|vp
operator|->
name|siglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp32
operator|>
literal|0
operator|&&
name|vp
operator|->
name|sig
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
operator|&
name|ep
operator|->
name|pkt
index|[
name|i
index|]
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
name|temp32
argument_list|)
expr_stmt|;
name|len
operator|+=
name|temp32
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_update - compute new public value and sign extension fields  *  * This routine runs periodically, like once a day, and when something  * changes. It updates the timestamps on three value structures and one  * value structure list, then signs all the structures:  *  * hostval	host name (not signed)  * pubkey	public key  * cinfo	certificate info/value list  * tai_leap	leapseconds file  *  * Filestamps are proventicated data, so this routine is run only when  * the host has been synchronized to a proventicated source. Thus, the  * timestamp is proventicated, too, and can be used to deflect  * clogging attacks and even cook breakfast.  *  * Returns void (no errors)  */
end_comment

begin_function
name|void
name|crypto_update
parameter_list|(
name|void
parameter_list|)
block|{
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* message digest context */
name|struct
name|cert_info
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpn
decl_stmt|,
modifier|*
modifier|*
name|zp
decl_stmt|;
comment|/* certificate info/value */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|u_int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|tstamp
operator|=
name|crypto_time
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return;
name|hostval
operator|.
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
comment|/* 	 * Sign public key and timestamps. The filestamp is derived from 	 * the host key file extension from wherever the file was 	 * generated.  	 */
if|if
condition|(
name|pubkey
operator|.
name|vallen
operator|!=
literal|0
condition|)
block|{
name|pubkey
operator|.
name|tstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|pubkey
operator|.
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pubkey
operator|.
name|sig
operator|==
name|NULL
condition|)
name|pubkey
operator|.
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pubkey
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|pubkey
operator|.
name|ptr
argument_list|,
name|ntohl
argument_list|(
name|pubkey
operator|.
name|vallen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|pubkey
operator|.
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|pubkey
operator|.
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Sign certificates and timestamps. The filestamp is derived 	 * from the certificate file extension from wherever the file 	 * was generated. At the same time expired certificates are 	 * expunged. 	 */
name|zp
operator|=
operator|&
name|cinfo
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cinfo
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|cpn
control|)
block|{
name|cpn
operator|=
name|cp
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|tstamp
operator|>
name|cp
operator|->
name|last
condition|)
block|{
operator|*
name|zp
operator|=
name|cpn
expr_stmt|;
name|cert_free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|->
name|cert
operator|.
name|tstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|cp
operator|->
name|cert
operator|.
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|cert
operator|.
name|sig
operator|==
name|NULL
condition|)
name|cp
operator|->
name|cert
operator|.
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|cp
operator|->
name|cert
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|cp
operator|->
name|cert
operator|.
name|ptr
argument_list|,
name|ntohl
argument_list|(
name|cp
operator|->
name|cert
operator|.
name|vallen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|cp
operator|->
name|cert
operator|.
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|cp
operator|->
name|cert
operator|.
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|zp
operator|=
operator|&
name|cp
operator|->
name|link
expr_stmt|;
block|}
block|}
comment|/* 	 * Sign leapseconds table and timestamps. The filestamp is 	 * derived from the leapsecond file extension from wherever the 	 * file was generated. 	 */
if|if
condition|(
name|tai_leap
operator|.
name|vallen
operator|!=
literal|0
condition|)
block|{
name|tai_leap
operator|.
name|tstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|tai_leap
operator|.
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tai_leap
operator|.
name|sig
operator|==
name|NULL
condition|)
name|tai_leap
operator|.
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tai_leap
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|tai_leap
operator|.
name|ptr
argument_list|,
name|ntohl
argument_list|(
name|tai_leap
operator|.
name|vallen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|tai_leap
operator|.
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|tai_leap
operator|.
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"update ts %u"
argument_list|,
name|ntohl
argument_list|(
name|hostval
operator|.
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
name|NULL
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_update: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * value_free - free value structure components.  *  * Returns void (no errors)  */
end_comment

begin_function
name|void
name|value_free
parameter_list|(
name|struct
name|value
modifier|*
name|vp
comment|/* value structure */
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|->
name|ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|sig
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vp
operator|->
name|sig
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * crypto_time - returns current NTP time in seconds.  */
end_comment

begin_function
name|tstamp_t
name|crypto_time
parameter_list|()
block|{
name|l_fp
name|tstamp
decl_stmt|;
comment|/* NTP time */
name|L_CLR
argument_list|(
operator|&
name|tstamp
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|tstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
name|get_systime
argument_list|(
operator|&
name|tstamp
argument_list|)
expr_stmt|;
return|return
operator|(
name|tstamp
operator|.
name|l_ui
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * asn2ntp - convert ASN1_TIME time structure to NTP time in seconds.  */
end_comment

begin_function
name|u_long
name|asn2ntp
parameter_list|(
name|ASN1_TIME
modifier|*
name|asn1time
comment|/* pointer to ASN1_TIME structure */
parameter_list|)
block|{
name|char
modifier|*
name|v
decl_stmt|;
comment|/* pointer to ASN1_TIME string */
name|struct
name|tm
name|tm
decl_stmt|;
comment|/* used to convert to NTP time */
comment|/* 	 * Extract time string YYMMDDHHMMSSZ from ASN1 time structure. 	 * Note that the YY, MM, DD fields start with one, the HH, MM, 	 * SS fiels start with zero and the Z character should be 'Z' 	 * for UTC. Also note that years less than 50 map to years 	 * greater than 100. Dontcha love ASN.1? Better than MIL-188. 	 */
if|if
condition|(
name|asn1time
operator|->
name|length
operator|>
literal|13
condition|)
return|return
operator|(
call|(
name|u_long
call|)
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
return|;
comment|/* We can't use -1 here. It's invalid */
name|v
operator|=
operator|(
name|char
operator|*
operator|)
name|asn1time
operator|->
name|data
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|v
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|<
literal|50
condition|)
name|tm
operator|.
name|tm_year
operator|+=
literal|100
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
operator|(
name|v
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|v
index|[
literal|3
index|]
operator|-
literal|'0'
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
operator|(
name|v
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|v
index|[
literal|5
index|]
operator|-
literal|'0'
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
operator|(
name|v
index|[
literal|6
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|v
index|[
literal|7
index|]
operator|-
literal|'0'
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
operator|(
name|v
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|v
index|[
literal|9
index|]
operator|-
literal|'0'
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
operator|(
name|v
index|[
literal|10
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|v
index|[
literal|11
index|]
operator|-
literal|'0'
expr_stmt|;
name|tm
operator|.
name|tm_wday
operator|=
literal|0
expr_stmt|;
name|tm
operator|.
name|tm_yday
operator|=
literal|0
expr_stmt|;
name|tm
operator|.
name|tm_isdst
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|timegm
argument_list|(
operator|&
name|tm
argument_list|)
operator|+
name|JAN_1970
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bigdig() - compute a BIGNUM MD5 hash of a BIGNUM number.  */
end_comment

begin_function
specifier|static
name|int
name|bighash
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|,
comment|/* BIGNUM * from */
name|BIGNUM
modifier|*
name|bk
comment|/* BIGNUM * to */
parameter_list|)
block|{
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* message digest context */
name|u_char
name|dgst
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
comment|/* message digest */
name|u_char
modifier|*
name|ptr
decl_stmt|;
comment|/* a BIGNUM as binary string */
name|u_int
name|len
decl_stmt|;
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|bn
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|EVP_DigestInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|EVP_md5
argument_list|()
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|dgst
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|dgst
argument_list|,
name|len
argument_list|,
name|bk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines implement the Schnorr (IFF) identity scheme  *  *								       *  ***********************************************************************  *  * The Schnorr (IFF) identity scheme is intended for use when  * the ntp-genkeys program does not generate the certificates used in  * the protocol and the group key cannot be conveyed in the certificate  * itself. For this purpose, new generations of IFF values must be  * securely transmitted to all members of the group before use. The  * scheme is self contained and independent of new generations of host  * keys, sign keys and certificates.  *  * The IFF identity scheme is based on DSA cryptography and algorithms  * described in Stinson p. 285. The IFF values hide in a DSA cuckoo  * structure, but only the primes and generator are used. The p is a  * 512-bit prime, q a 160-bit prime that divides p - 1 and is a qth root  * of 1 mod p; that is, g^q = 1 mod p. The TA rolls primvate random  * group key b disguised as a DSA structure member, then computes public  * key g^(q - b). These values are shared only among group members and  * never revealed in messages. Alice challenges Bob to confirm identity  * using the protocol described below.  *  * How it works  *  * The scheme goes like this. Both Alice and Bob have the public primes  * p, q and generator g. The TA gives private key b to Bob and public  * key v = g^(q - a) mod p to Alice.  *  * Alice rolls new random challenge r and sends to Bob in the IFF  * request message. Bob rolls new random k, then computes y = k + b r  * mod q and x = g^k mod p and sends (y, hash(x)) to Alice in the  * response message. Besides making the response shorter, the hash makes  * it effectivey impossible for an intruder to solve for b by observing  * a number of these messages.  *   * Alice receives the response and computes g^y v^r mod p. After a bit  * of algebra, this simplifies to g^k. If the hash of this result  * matches hash(x), Alice knows that Bob has the group key b. The signed  * response binds this knowledge to Bob's private key and the public key  * previously received in his certificate.  *  * crypto_alice - construct Alice's challenge in IFF scheme  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  * XEVNT_ID	bad or missing identity parameters  */
end_comment

begin_function
specifier|static
name|int
name|crypto_alice
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* IFF parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * The identity parameters must have correct format and content. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
if|if
condition|(
operator|(
name|dsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|.
name|dsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_alice: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Roll new random r (0< r< q). The OpenSSL library has a bug 	 * omitting BN_rand_range, so we have to do it the hard way. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|iffval
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|len
operator|*
literal|8
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* r */
name|BN_mod
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
comment|/* 	 * Sign and send to Bob. The filestamp is from the local file. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_bob - construct Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  */
end_comment

begin_function
specifier|static
name|int
name|crypto_bob
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* IFF parameters */
name|DSA_SIG
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA signature context fake */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|BIGNUM
modifier|*
name|bn
decl_stmt|,
modifier|*
name|bk
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * If the IFF parameters are not valid, something awful 	 * happened or we are being tormented. 	 */
if|if
condition|(
operator|!
operator|(
name|crypto_flags
operator|&
name|CRYPTO_FLAG_IFF
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_bob: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
name|dsa
operator|=
name|iffpar_pkey
operator|->
name|pkey
operator|.
name|dsa
expr_stmt|;
comment|/* 	 * Extract r from the challenge. 	 */
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|BN_bin2bn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Bob rolls random k (0< k< q), computes y = k + b r mod q 	 * and x = g^k mod p, then sends (y, hash(x)) to Alice. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bk
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|=
name|DSA_SIG_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|bk
argument_list|,
name|len
operator|*
literal|8
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* k */
name|BN_mod_mul
argument_list|(
name|bn
argument_list|,
name|dsa
operator|->
name|priv_key
argument_list|,
name|r
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* b r mod q */
name|BN_add
argument_list|(
name|bn
argument_list|,
name|bn
argument_list|,
name|bk
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|bn
argument_list|,
name|bn
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* k + b r mod q */
name|sdsa
operator|->
name|r
operator|=
name|BN_dup
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|bk
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|bk
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* g^k mod p */
name|bighash
argument_list|(
name|bk
argument_list|,
name|bk
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|s
operator|=
name|BN_dup
argument_list|(
name|bk
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bk
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the values in ASN.1 and sign. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|if_fstamp
argument_list|)
expr_stmt|;
name|len
operator|=
name|i2d_DSA_SIG
argument_list|(
name|sdsa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|i2d_DSA_SIG
argument_list|(
name|sdsa
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_iff - verify Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  * XEVNT_FSP	bad filestamp  * XEVNT_ID	bad or missing identity parameters  */
end_comment

begin_function
name|int
name|crypto_iff
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* IFF parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|DSA_SIG
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA parameters */
name|BIGNUM
modifier|*
name|bn
decl_stmt|,
modifier|*
name|bk
decl_stmt|;
name|u_int
name|len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|temp
decl_stmt|;
comment|/* 	 * If the IFF parameters are not valid or no challenge was sent, 	 * something awful happened or we are being tormented. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_iff: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
operator|!=
name|peer
operator|->
name|fstamp
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_iff: invalid filestamp %u"
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_FSP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|.
name|dsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_iff: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
if|if
condition|(
name|peer
operator|->
name|iffval
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_iff: missing challenge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Extract the k + b r and g^k values from the response. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bk
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
if|if
condition|(
operator|(
name|sdsa
operator|=
name|d2i_DSA_SIG
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_iff %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Compute g^(k + b r) g^(q - b)r mod p. 	 */
name|BN_mod_exp
argument_list|(
name|bn
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|bk
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|sdsa
operator|->
name|r
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|bn
argument_list|,
name|bn
argument_list|,
name|bk
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* 	 * Verify the hash of the result matches hash(x). 	 */
name|bighash
argument_list|(
name|bn
argument_list|,
name|bn
argument_list|)
expr_stmt|;
name|temp
operator|=
name|BN_cmp
argument_list|(
name|bn
argument_list|,
name|sdsa
operator|->
name|s
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bk
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|NULL
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
else|else
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines implement the Guillou-Quisquater (GQ)        *  * identity scheme                                                     *  *								       *  ***********************************************************************  *  * The Guillou-Quisquater (GQ) identity scheme is intended for use when  * the ntp-genkeys program generates the certificates used in the  * protocol and the group key can be conveyed in a certificate extension  * field. The scheme is self contained and independent of new  * generations of host keys, sign keys and certificates.  *  * The GQ identity scheme is based on RSA cryptography and algorithms  * described in Stinson p. 300 (with errors). The GQ values hide in a  * RSA cuckoo structure, but only the modulus is used. The 512-bit  * public modulus is n = p q, where p and q are secret large primes. The  * TA rolls random group key b disguised as a RSA structure member.  * Except for the public key, these values are shared only among group  * members and never revealed in messages.  *  * When rolling new certificates, Bob recomputes the private and  * public keys. The private key u is a random roll, while the public key  * is the inverse obscured by the group key v = (u^-1)^b. These values  * replace the private and public keys normally generated by the RSA  * scheme. Alice challenges Bob to confirm identity using the protocol  * described below.  *  * How it works  *  * The scheme goes like this. Both Alice and Bob have the same modulus n  * and some random b as the group key. These values are computed and  * distributed in advance via secret means, although only the group key  * b is truly secret. Each has a private random private key u and public  * key (u^-1)^b, although not necessarily the same ones. Bob and Alice  * can regenerate the key pair from time to time without affecting  * operations. The public key is conveyed on the certificate in an  * extension field; the private key is never revealed.  *  * Alice rolls new random challenge r and sends to Bob in the GQ  * request message. Bob rolls new random k, then computes y = k u^r mod  * n and x = k^b mod n and sends (y, hash(x)) to Alice in the response  * message. Besides making the response shorter, the hash makes it  * effectivey impossible for an intruder to solve for b by observing  * a number of these messages.  *   * Alice receives the response and computes y^b v^r mod n. After a bit  * of algebra, this simplifies to k^b. If the hash of this result  * matches hash(x), Alice knows that Bob has the group key b. The signed  * response binds this knowledge to Bob's private key and the public key  * previously received in his certificate.  *  * crypto_alice2 - construct Alice's challenge in GQ scheme  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  * XEVNT_ID	bad or missing identity parameters  */
end_comment

begin_function
specifier|static
name|int
name|crypto_alice2
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* GQ parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * The identity parameters must have correct format and content. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
if|if
condition|(
operator|(
name|rsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|.
name|rsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_alice2: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Roll new random r (0< r< n). The OpenSSL library has a bug 	 * omitting BN_rand_range, so we have to do it the hard way. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|iffval
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|len
operator|*
literal|8
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* r mod n */
name|BN_mod
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
comment|/* 	 * Sign and send to Bob. The filestamp is from the local file. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_bob2 - construct Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  */
end_comment

begin_function
specifier|static
name|int
name|crypto_bob2
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* GQ parameters */
name|DSA_SIG
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|BIGNUM
modifier|*
name|r
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|g
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * If the GQ parameters are not valid, something awful 	 * happened or we are being tormented. 	 */
if|if
condition|(
operator|!
operator|(
name|crypto_flags
operator|&
name|CRYPTO_FLAG_GQ
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_bob2: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
name|rsa
operator|=
name|gqpar_pkey
operator|->
name|pkey
operator|.
name|rsa
expr_stmt|;
comment|/* 	 * Extract r from the challenge. 	 */
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|BN_bin2bn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob2 %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Bob rolls random k (0< k< n), computes y = k u^r mod n and 	 * x = k^b mod n, then sends (y, hash(x)) to Alice.  	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|k
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|g
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|y
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|=
name|DSA_SIG_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|k
argument_list|,
name|len
operator|*
literal|8
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* k */
name|BN_mod
argument_list|(
name|k
argument_list|,
name|k
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|y
argument_list|,
name|rsa
operator|->
name|p
argument_list|,
name|r
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* u^r mod n */
name|BN_mod_mul
argument_list|(
name|y
argument_list|,
name|k
argument_list|,
name|y
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* k u^r mod n */
name|sdsa
operator|->
name|r
operator|=
name|BN_dup
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|g
argument_list|,
name|k
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* k^b mod n */
name|bighash
argument_list|(
name|g
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|s
operator|=
name|BN_dup
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the values in ASN.1 and sign. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|gq_fstamp
argument_list|)
expr_stmt|;
name|len
operator|=
name|i2d_DSA_SIG
argument_list|(
name|sdsa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob2 %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|i2d_DSA_SIG
argument_list|(
name|sdsa
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_gq - verify Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  * XEVNT_FSP	bad filestamp  * XEVNT_ID	bad or missing identity parameters  */
end_comment

begin_function
name|int
name|crypto_gq
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* GQ parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|DSA_SIG
modifier|*
name|sdsa
decl_stmt|;
comment|/* RSA signature context fake */
name|BIGNUM
modifier|*
name|y
decl_stmt|,
modifier|*
name|v
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|int
name|temp
decl_stmt|;
comment|/* 	 * If the GQ parameters are not valid or no challenge was sent, 	 * something awful happened or we are being tormented. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_gq: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
operator|!=
name|peer
operator|->
name|fstamp
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_gq: invalid filestamp %u"
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_FSP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|.
name|rsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_gq: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
if|if
condition|(
name|peer
operator|->
name|iffval
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_gq: missing challenge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Extract the y = k u^r and hash(x = k^b) values from the 	 * response. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|y
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|v
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
if|if
condition|(
operator|(
name|sdsa
operator|=
name|d2i_DSA_SIG
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_gq %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Compute v^r y^b mod n. 	 */
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|peer
operator|->
name|grpkey
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* v^r mod n */
name|BN_mod_exp
argument_list|(
name|y
argument_list|,
name|sdsa
operator|->
name|r
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* y^b mod n */
name|BN_mod_mul
argument_list|(
name|y
argument_list|,
name|v
argument_list|,
name|y
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* v^r y^b mod n */
comment|/* 	 * Verify the hash of the result matches hash(x). 	 */
name|bighash
argument_list|(
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|temp
operator|=
name|BN_cmp
argument_list|(
name|y
argument_list|,
name|sdsa
operator|->
name|s
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|NULL
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
else|else
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines implement the Mu-Varadharajan (MV) identity  *  * scheme                                                              *  *								       *  ***********************************************************************  */
end_comment

begin_comment
comment|/*  * The Mu-Varadharajan (MV) cryptosystem was originally intended when  * servers broadcast messages to clients, but clients never send  * messages to servers. There is one encryption key for the server and a  * separate decryption key for each client. It operated something like a  * pay-per-view satellite broadcasting system where the session key is  * encrypted by the broadcaster and the decryption keys are held in a  * tamperproof set-top box.  *  * The MV parameters and private encryption key hide in a DSA cuckoo  * structure which uses the same parameters, but generated in a  * different way. The values are used in an encryption scheme similar to  * El Gamal cryptography and a polynomial formed from the expansion of  * product terms (x - x[j]), as described in Mu, Y., and V.  * Varadharajan: Robust and Secure Broadcasting, Proc. Indocrypt 2001,  * 223-231. The paper has significant errors and serious omissions.  *  * Let q be the product of n distinct primes s'[j] (j = 1...n), where  * each s'[j] has m significant bits. Let p be a prime p = 2 * q + 1, so  * that q and each s'[j] divide p - 1 and p has M = n * m + 1  * significant bits. The elements x mod q of Zq with the elements 2 and  * the primes removed form a field Zq* valid for polynomial arithetic.  * Let g be a generator of Zp; that is, gcd(g, p - 1) = 1 and g^q = 1  * mod p. We expect M to be in the 500-bit range and n relatively small,  * like 25, so the likelihood of a randomly generated element of x mod q  * of Zq colliding with a factor of p - 1 is very small and can be  * avoided. Associated with each s'[j] is an element s[j] such that s[j]  * s'[j] = s'[j] mod q. We find s[j] as the quotient (q + s'[j]) /  * s'[j]. These are the parameters of the scheme and they are expensive  * to compute.  *  * We set up an instance of the scheme as follows. A set of random  * values x[j] mod q (j = 1...n), are generated as the zeros of a  * polynomial of order n. The product terms (x - x[j]) are expanded to  * form coefficients a[i] mod q (i = 0...n) in powers of x. These are  * used as exponents of the generator g mod p to generate the private  * encryption key A. The pair (gbar, ghat) of public server keys and the  * pairs (xbar[j], xhat[j]) (j = 1...n) of private client keys are used  * to construct the decryption keys. The devil is in the details.  *  * The distinguishing characteristic of this scheme is the capability to  * revoke keys. Included in the calculation of E, gbar and ghat is the  * product s = prod(s'[j]) (j = 1...n) above. If the factor s'[j] is  * subsequently removed from the product and E, gbar and ghat  * recomputed, the jth client will no longer be able to compute E^-1 and  * thus unable to decrypt the block.  *  * How it works  *  * The scheme goes like this. Bob has the server values (p, A, q, gbar,  * ghat) and Alice the client values (p, xbar, xhat).  *  * Alice rolls new random challenge r (0< r< p) and sends to Bob in  * the MV request message. Bob rolls new random k (0< k< q), encrypts  * y = A^k mod p (a permutation) and sends (hash(y), gbar^k, ghat^k) to  * Alice.  *   * Alice receives the response and computes the decryption key (the  * inverse permutation) from previously obtained (xbar, xhat) and  * (gbar^k, ghat^k) in the message. She computes the inverse, which is  * unique by reasons explained in the ntp-keygen.c program sources. If  * the hash of this result matches hash(y), Alice knows that Bob has the  * group key b. The signed response binds this knowledge to Bob's  * private key and the public key previously received in his  * certificate.  *  * crypto_alice3 - construct Alice's challenge in MV scheme  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  * XEVNT_ID	bad or missing identity parameters  */
end_comment

begin_function
specifier|static
name|int
name|crypto_alice3
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* MV parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * The identity parameters must have correct format and content. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
if|if
condition|(
operator|(
name|dsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|.
name|dsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_alice3: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Roll new random r (0< r< q). The OpenSSL library has a bug 	 * omitting BN_rand_range, so we have to do it the hard way. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|iffval
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|len
operator|*
literal|8
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* r */
name|BN_mod
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
comment|/* 	 * Sign and send to Bob. The filestamp is from the local file. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_bob3 - construct Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  */
end_comment

begin_function
specifier|static
name|int
name|crypto_bob3
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* MV parameters */
name|DSA
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA signature context fake */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|BIGNUM
modifier|*
name|r
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * If the MV parameters are not valid, something awful 	 * happened or we are being tormented. 	 */
if|if
condition|(
operator|!
operator|(
name|crypto_flags
operator|&
name|CRYPTO_FLAG_MV
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_bob3: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
name|dsa
operator|=
name|mvpar_pkey
operator|->
name|pkey
operator|.
name|dsa
expr_stmt|;
comment|/* 	 * Extract r from the challenge. 	 */
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|BN_bin2bn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob3 %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Bob rolls random k (0< k< q), making sure it is not a 	 * factor of q. He then computes y = A^k r and sends (hash(y), 	 * gbar^k, ghat^k) to Alice. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|k
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|u
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|=
name|DSA_new
argument_list|()
expr_stmt|;
name|sdsa
operator|->
name|p
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|->
name|q
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|->
name|g
operator|=
name|BN_new
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BN_rand
argument_list|(
name|k
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|k
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_gcd
argument_list|(
name|u
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
break|break;
block|}
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* A r */
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|r
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|bighash
argument_list|(
name|u
argument_list|,
name|sdsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|sdsa
operator|->
name|q
argument_list|,
name|dsa
operator|->
name|priv_key
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* gbar */
name|BN_mod_exp
argument_list|(
name|sdsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* ghat */
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
comment|/* 	 * Encode the values in ASN.1 and sign. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|mv_fstamp
argument_list|)
expr_stmt|;
name|len
operator|=
name|i2d_DSAparams
argument_list|(
name|sdsa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob3 %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|i2d_DSAparams
argument_list|(
name|sdsa
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_mv - verify Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  * XEVNT_FSP	bad filestamp  * XEVNT_ID	bad or missing identity parameters  */
end_comment

begin_function
name|int
name|crypto_mv
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* MV parameters */
name|DSA
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|BIGNUM
modifier|*
name|k
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|u_int
name|len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|temp
decl_stmt|;
comment|/* 	 * If the MV parameters are not valid or no challenge was sent, 	 * something awful happened or we are being tormented. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_mv: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
operator|!=
name|peer
operator|->
name|fstamp
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_mv: invalid filestamp %u"
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_FSP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|.
name|dsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_mv: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
if|if
condition|(
name|peer
operator|->
name|iffval
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_mv: missing challenge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Extract the (hash(y), gbar, ghat) values from the response. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|k
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|u
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|v
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
if|if
condition|(
operator|(
name|sdsa
operator|=
name|d2i_DSAparams
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_mv %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Compute (gbar^xhat ghat^xbar)^-1 mod p. 	 */
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|sdsa
operator|->
name|q
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|sdsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|priv_key
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_inverse
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|u
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* 	 * The result should match the hash of r mod p. 	 */
name|bighash
argument_list|(
name|v
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|temp
operator|=
name|BN_cmp
argument_list|(
name|v
argument_list|,
name|sdsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|NULL
expr_stmt|;
name|DSA_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
else|else
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines are used to manipulate certificates          *  *								       *  ***********************************************************************  */
end_comment

begin_comment
comment|/*  * cert_parse - parse x509 certificate and create info/value structures.  *  * The server certificate includes the version number, issuer name,  * subject name, public key and valid date interval. If the issuer name  * is the same as the subject name, the certificate is self signed and  * valid only if the server is configured as trustable. If the names are  * different, another issuer has signed the server certificate and  * vouched for it. In this case the server certificate is valid if  * verified by the issuer public key.  *  * Returns certificate info/value pointer if valid, NULL if not.  */
end_comment

begin_function
name|struct
name|cert_info
modifier|*
comment|/* certificate information structure */
name|cert_parse
parameter_list|(
name|u_char
modifier|*
name|asn1cert
parameter_list|,
comment|/* X509 certificate */
name|u_int
name|len
parameter_list|,
comment|/* certificate length */
name|tstamp_t
name|fstamp
comment|/* filestamp */
parameter_list|)
block|{
name|X509
modifier|*
name|cert
decl_stmt|;
comment|/* X509 certificate */
name|X509_EXTENSION
modifier|*
name|ext
decl_stmt|;
comment|/* X509v3 extension */
name|struct
name|cert_info
modifier|*
name|ret
decl_stmt|;
comment|/* certificate info/value */
name|BIO
modifier|*
name|bp
decl_stmt|;
name|X509V3_EXT_METHOD
modifier|*
name|method
decl_stmt|;
name|char
name|pathbuf
index|[
name|MAXFILENAME
index|]
decl_stmt|;
name|u_char
modifier|*
name|uptr
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|temp
decl_stmt|,
name|cnt
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Decode ASN.1 objects and construct certificate structure. 	 */
name|uptr
operator|=
name|asn1cert
expr_stmt|;
if|if
condition|(
operator|(
name|cert
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|uptr
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cert_parse %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Extract version, subject name and public key. 	 */
name|ret
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cert_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cert_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|->
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|cert
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cert_parse %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ret
operator|->
name|version
operator|=
name|X509_get_version
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|X509_NAME_oneline
argument_list|(
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|pathbuf
argument_list|,
name|MAXFILENAME
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|strstr
argument_list|(
name|pathbuf
argument_list|,
literal|"CN="
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"cert_parse: invalid subject %s"
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ret
operator|->
name|subject
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
operator|->
name|subject
argument_list|,
name|ptr
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* 	 * Extract remaining objects. Note that the NTP serial number is 	 * the NTP seconds at the time of signing, but this might not be 	 * the case for other authority. We don't bother to check the 	 * objects at this time, since the real crunch can happen only 	 * when the time is valid but not yet certificated. 	 */
name|ret
operator|->
name|nid
operator|=
name|OBJ_obj2nid
argument_list|(
name|cert
operator|->
name|cert_info
operator|->
name|signature
operator|->
name|algorithm
argument_list|)
expr_stmt|;
name|ret
operator|->
name|digest
operator|=
operator|(
specifier|const
name|EVP_MD
operator|*
operator|)
name|EVP_get_digestbynid
argument_list|(
name|ret
operator|->
name|nid
argument_list|)
expr_stmt|;
name|ret
operator|->
name|serial
operator|=
operator|(
name|u_long
operator|)
name|ASN1_INTEGER_get
argument_list|(
name|X509_get_serialNumber
argument_list|(
name|cert
argument_list|)
argument_list|)
expr_stmt|;
name|X509_NAME_oneline
argument_list|(
name|X509_get_issuer_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|pathbuf
argument_list|,
name|MAXFILENAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strstr
argument_list|(
name|pathbuf
argument_list|,
literal|"CN="
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"cert_parse: invalid issuer %s"
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ret
operator|->
name|issuer
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
operator|->
name|issuer
argument_list|,
name|ptr
operator|+
literal|3
argument_list|)
expr_stmt|;
name|ret
operator|->
name|first
operator|=
name|asn2ntp
argument_list|(
name|X509_get_notBefore
argument_list|(
name|cert
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|last
operator|=
name|asn2ntp
argument_list|(
name|X509_get_notAfter
argument_list|(
name|cert
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Extract extension fields. These are ad hoc ripoffs of 	 * currently assigned functions and will certainly be changed 	 * before prime time. 	 */
name|cnt
operator|=
name|X509_get_ext_count
argument_list|(
name|cert
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|ext
operator|=
name|X509_get_ext
argument_list|(
name|cert
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|method
operator|=
name|X509V3_EXT_get
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|temp
operator|=
name|OBJ_obj2nid
argument_list|(
name|ext
operator|->
name|object
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
comment|/* 		 * If a key_usage field is present, we decode whether 		 * this is a trusted or private certificate. This is 		 * dorky; all we want is to compare NIDs, but OpenSSL 		 * insists on BIO text strings. 		 */
case|case
name|NID_ext_key_usage
case|:
name|bp
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|X509V3_EXT_print
argument_list|(
name|bp
argument_list|,
name|ext
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BIO_gets
argument_list|(
name|bp
argument_list|,
name|pathbuf
argument_list|,
name|MAXFILENAME
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"cert_parse: %s: %s\n"
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|temp
argument_list|)
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|pathbuf
argument_list|,
literal|"Trust Root"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|->
name|flags
operator||=
name|CERT_TRUST
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pathbuf
argument_list|,
literal|"Private"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|->
name|flags
operator||=
name|CERT_PRIV
expr_stmt|;
break|break;
comment|/* 		 * If a NID_subject_key_identifier field is present, it 		 * contains the GQ public key. 		 */
case|case
name|NID_subject_key_identifier
case|:
name|ret
operator|->
name|grplen
operator|=
name|ext
operator|->
name|value
operator|->
name|length
operator|-
literal|2
expr_stmt|;
name|ret
operator|->
name|grpkey
operator|=
name|emalloc
argument_list|(
name|ret
operator|->
name|grplen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
operator|->
name|grpkey
argument_list|,
operator|&
name|ext
operator|->
name|value
operator|->
name|data
index|[
literal|2
index|]
argument_list|,
name|ret
operator|->
name|grplen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If certificate is self signed, verify signature. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|ret
operator|->
name|subject
argument_list|,
name|ret
operator|->
name|issuer
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|X509_verify
argument_list|(
name|cert
argument_list|,
name|ret
operator|->
name|pkey
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"cert_parse: invalid signature not verified %s"
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * Verify certificate valid times. Note that certificates cannot 	 * be retroactive. 	 */
if|if
condition|(
name|ret
operator|->
name|first
operator|>
name|ret
operator|->
name|last
operator|||
name|ret
operator|->
name|first
operator|<
name|fstamp
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"cert_parse: expired %s"
argument_list|,
name|ret
operator|->
name|subject
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Build the value structure to sign and send later. 	 */
name|ret
operator|->
name|cert
operator|.
name|fstamp
operator|=
name|htonl
argument_list|(
name|fstamp
argument_list|)
expr_stmt|;
name|ret
operator|->
name|cert
operator|.
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ret
operator|->
name|cert
operator|.
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
operator|->
name|cert
operator|.
name|ptr
argument_list|,
name|asn1cert
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|X509_print_fp
argument_list|(
name|stdout
argument_list|,
name|cert
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cert_sign - sign x509 certificate and update value structure.  *  * The certificate request is a copy of the client certificate, which  * includes the version number, subject name and public key of the  * client. The resulting certificate includes these values plus the  * serial number, issuer name and validity interval of the server. The  * validity interval extends from the current time to the same time one  * year hence. For NTP purposes, it is convenient to use the NTP seconds  * of the current time as the serial number.  *  * Returns  * XEVNT_OK	success  * XEVNT_PUB	bad or missing public key  * XEVNT_CRT	bad or missing certificate  * XEVNT_VFY	certificate not verified  */
end_comment

begin_function
specifier|static
name|int
name|cert_sign
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension field pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|X509
modifier|*
name|req
decl_stmt|;
comment|/* X509 certificate request */
name|X509
modifier|*
name|cert
decl_stmt|;
comment|/* X509 certificate */
name|X509_EXTENSION
modifier|*
name|ext
decl_stmt|;
comment|/* certificate extension */
name|ASN1_INTEGER
modifier|*
name|serial
decl_stmt|;
comment|/* serial number */
name|X509_NAME
modifier|*
name|subj
decl_stmt|;
comment|/* distinguished (common) name */
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* public key */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* message digest context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|u_int
name|len
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|temp
decl_stmt|;
comment|/* 	 * Decode ASN.1 objects and construct certificate structure. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_TSP
operator|)
return|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cert_sign %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_CRT
operator|)
return|;
block|}
comment|/* 	 * Extract public key and check for errors. 	 */
if|if
condition|(
operator|(
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|req
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cert_sign %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Generate X509 certificate signed by this server. For this 	 * prupose the issuer name is the server name. Also copy any 	 * extensions that might be present. 	 */
name|cert
operator|=
name|X509_new
argument_list|()
expr_stmt|;
name|X509_set_version
argument_list|(
name|cert
argument_list|,
name|X509_get_version
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|serial
operator|=
name|ASN1_INTEGER_new
argument_list|()
expr_stmt|;
name|ASN1_INTEGER_set
argument_list|(
name|serial
argument_list|,
name|tstamp
argument_list|)
expr_stmt|;
name|X509_set_serialNumber
argument_list|(
name|cert
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|X509_gmtime_adj
argument_list|(
name|X509_get_notBefore
argument_list|(
name|cert
argument_list|)
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|X509_gmtime_adj
argument_list|(
name|X509_get_notAfter
argument_list|(
name|cert
argument_list|)
argument_list|,
name|YEAR
argument_list|)
expr_stmt|;
name|subj
operator|=
name|X509_get_issuer_name
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|X509_NAME_add_entry_by_txt
argument_list|(
name|subj
argument_list|,
literal|"commonName"
argument_list|,
name|MBSTRING_ASC
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sys_hostname
argument_list|,
name|strlen
argument_list|(
name|sys_hostname
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subj
operator|=
name|X509_get_subject_name
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|X509_set_subject_name
argument_list|(
name|cert
argument_list|,
name|subj
argument_list|)
expr_stmt|;
name|X509_set_pubkey
argument_list|(
name|cert
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
name|ext
operator|=
name|X509_get_ext
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|X509_get_ext_count
argument_list|(
name|req
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|temp
condition|;
name|i
operator|++
control|)
block|{
name|ext
operator|=
name|X509_get_ext
argument_list|(
name|req
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|X509_add_ext
argument_list|(
name|cert
argument_list|,
name|ext
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|X509_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* 	 * Sign and verify the certificate. 	 */
name|X509_sign
argument_list|(
name|cert
argument_list|,
name|sign_pkey
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_verify
argument_list|(
name|cert
argument_list|,
name|sign_pkey
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cert_sign\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_VFY
operator|)
return|;
block|}
name|len
operator|=
name|i2d_X509
argument_list|(
name|cert
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Build and sign the value structure. We have to sign it here, 	 * since the response has to be returned right away. This is a 	 * clogging hazard. 	 */
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|vp
operator|->
name|ptr
expr_stmt|;
name|i2d_X509
argument_list|(
name|cert
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|vp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|X509_print_fp
argument_list|(
name|stdout
argument_list|,
name|cert
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cert_valid - verify certificate with given public key  *  * This is pretty ugly, as the certificate has to be verified in the  * OpenSSL X509 structure, not in the DER format in the info/value  * structure.  *  * Returns  * XEVNT_OK	success  * XEVNT_VFY	certificate not verified  */
end_comment

begin_function
name|int
name|cert_valid
parameter_list|(
name|struct
name|cert_info
modifier|*
name|cinf
parameter_list|,
comment|/* certificate information structure */
name|EVP_PKEY
modifier|*
name|pkey
comment|/* public key */
parameter_list|)
block|{
name|X509
modifier|*
name|cert
decl_stmt|;
comment|/* X509 certificate */
name|u_char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|cinf
operator|->
name|flags
operator|&
name|CERT_SIGN
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cinf
operator|->
name|cert
operator|.
name|ptr
expr_stmt|;
name|cert
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|ntohl
argument_list|(
name|cinf
operator|->
name|cert
operator|.
name|vallen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_verify
argument_list|(
name|cert
argument_list|,
name|pkey
argument_list|)
condition|)
return|return
operator|(
name|XEVNT_VFY
operator|)
return|;
name|cinf
operator|->
name|flags
operator||=
name|CERT_SIGN
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cert - install certificate in certificate list  *  * This routine encodes an extension field into a certificate info/value  * structure. It searches the certificate list for duplicates and  * expunges whichever is older. It then searches the list for other  * certificates that might be verified by this latest one. Finally, it  * inserts this certificate first on the list.  *  * Returns  * XEVNT_OK	success  * XEVNT_PER	certificate expired  * XEVNT_CRT	bad or missing certificate   */
end_comment

begin_function
name|int
name|cert_install
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* cert info/value */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure */
parameter_list|)
block|{
name|struct
name|cert_info
modifier|*
name|cp
decl_stmt|,
modifier|*
name|xp
decl_stmt|,
modifier|*
name|yp
decl_stmt|,
modifier|*
modifier|*
name|zp
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* 	 * Parse and validate the signed certificate. If valid, 	 * construct the info/value structure; otherwise, scamper home. 	 * Note this allows a certificate not-before time to be in the 	 * future, but not a not-after time to be in the past. 	 */
if|if
condition|(
operator|(
name|cp
operator|=
name|cert_parse
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|XEVNT_CRT
operator|)
return|;
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|tstamp
operator|>
name|cp
operator|->
name|last
condition|)
block|{
name|cert_free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PER
operator|)
return|;
block|}
comment|/* 	 * Scan certificate list looking for another certificate with 	 * the same subject and issuer. If another is found with the 	 * same or older filestamp, unlink it and return the goodies to 	 * the heap. If another is found with a later filetsamp, discard 	 * the new one and leave the building. 	 */
name|rval
operator|=
name|XEVNT_OK
expr_stmt|;
name|yp
operator|=
name|cp
expr_stmt|;
name|zp
operator|=
operator|&
name|cinfo
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|cinfo
init|;
name|xp
operator|!=
name|NULL
condition|;
name|xp
operator|=
name|xp
operator|->
name|link
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cp
operator|->
name|subject
argument_list|,
name|xp
operator|->
name|subject
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|cp
operator|->
name|issuer
argument_list|,
name|xp
operator|->
name|issuer
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|cp
operator|->
name|cert
operator|.
name|fstamp
argument_list|)
operator|<=
name|ntohl
argument_list|(
name|xp
operator|->
name|cert
operator|.
name|fstamp
argument_list|)
condition|)
block|{
operator|*
name|zp
operator|=
name|xp
operator|->
name|link
expr_stmt|;
empty_stmt|;
name|cert_free
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cert_free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_TSP
operator|)
return|;
block|}
break|break;
block|}
name|zp
operator|=
operator|&
name|xp
operator|->
name|link
expr_stmt|;
block|}
name|yp
operator|->
name|link
operator|=
name|cinfo
expr_stmt|;
name|cinfo
operator|=
name|yp
expr_stmt|;
comment|/* 	 * Scan the certificate list to see if Y is signed by X. 	 */
for|for
control|(
name|yp
operator|=
name|cinfo
init|;
name|yp
operator|!=
name|NULL
condition|;
name|yp
operator|=
name|yp
operator|->
name|link
control|)
block|{
for|for
control|(
name|xp
operator|=
name|cinfo
init|;
name|xp
operator|!=
name|NULL
condition|;
name|xp
operator|=
name|xp
operator|->
name|link
control|)
block|{
if|if
condition|(
name|yp
operator|->
name|flags
operator|&
name|CERT_ERROR
condition|)
continue|continue;
comment|/* 			 * If issuer Y matches subject X and signature Y 			 * is valid using public key X, then Y is valid. 			 */
if|if
condition|(
name|strcmp
argument_list|(
name|yp
operator|->
name|issuer
argument_list|,
name|xp
operator|->
name|subject
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cert_valid
argument_list|(
name|yp
argument_list|,
name|xp
operator|->
name|pkey
argument_list|)
operator|!=
name|XEVNT_OK
condition|)
block|{
name|yp
operator|->
name|flags
operator||=
name|CERT_ERROR
expr_stmt|;
continue|continue;
block|}
name|xp
operator|->
name|flags
operator||=
name|CERT_SIGN
expr_stmt|;
comment|/* 			 * If X is trusted, then Y is trusted. Note that 			 * we might stumble over a self signed 			 * certificate that is not trusted, at least 			 * temporarily. This can happen when a dude 			 * first comes up, but has not synchronized the 			 * clock and had its certificate signed by its 			 * server. In case of broken certificate trail, 			 * this might result in a loop that could 			 * persist until timeout. 			 */
if|if
condition|(
operator|!
operator|(
name|xp
operator|->
name|flags
operator|&
name|CERT_TRUST
operator|)
condition|)
continue|continue;
name|yp
operator|->
name|flags
operator||=
name|CERT_TRUST
expr_stmt|;
comment|/* 			 * If subject Y matches the server subject name, 			 * then Y has completed the certificate trail. 			 * Save the group key and light the valid bit. 			 */
if|if
condition|(
name|strcmp
argument_list|(
name|yp
operator|->
name|subject
argument_list|,
name|peer
operator|->
name|subject
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|yp
operator|->
name|grpkey
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|grpkey
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|grpkey
argument_list|)
expr_stmt|;
name|peer
operator|->
name|grpkey
operator|=
name|BN_bin2bn
argument_list|(
name|yp
operator|->
name|grpkey
argument_list|,
name|yp
operator|->
name|grplen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_VALID
expr_stmt|;
comment|/* 			 * If the server has an an identity scheme, 			 * fetch the identity credentials. If not, the 			 * identity is verified only by the trusted 			 * certificate. The next signature will set the 			 * server proventic. 			 */
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
operator|(
name|CRYPTO_FLAG_GQ
operator||
name|CRYPTO_FLAG_IFF
operator||
name|CRYPTO_FLAG_MV
operator|)
condition|)
continue|continue;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_VRFY
expr_stmt|;
block|}
block|}
comment|/* 	 * That was awesome. Now update the timestamps and signatures. 	 */
name|crypto_update
argument_list|()
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cert_free - free certificate information structure  */
end_comment

begin_function
name|void
name|cert_free
parameter_list|(
name|struct
name|cert_info
modifier|*
name|cinf
comment|/* certificate info/value structure */
parameter_list|)
block|{
if|if
condition|(
name|cinf
operator|->
name|pkey
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|cinf
operator|->
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinf
operator|->
name|subject
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cinf
operator|->
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinf
operator|->
name|issuer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cinf
operator|->
name|issuer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinf
operator|->
name|grpkey
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cinf
operator|->
name|grpkey
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|cinf
operator|->
name|cert
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cinf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines are used only at initialization time         *  *								       *  ***********************************************************************  */
end_comment

begin_comment
comment|/*  * crypto_key - load cryptographic parameters and keys from files  *  * This routine loads a PEM-encoded public/private key pair and extracts  * the filestamp from the file name.  *  * Returns public key pointer if valid, NULL if not. Side effect updates  * the filestamp if valid.  */
end_comment

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|crypto_key
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
comment|/* file name */
name|tstamp_t
modifier|*
name|fstamp
comment|/* filestamp */
parameter_list|)
block|{
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
comment|/* public/private key */
name|char
name|filename
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* name of key file */
name|char
name|linkname
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* filestamp buffer) */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* 	 * Open the key file. If the first character of the file name is 	 * not '/', prepend the keys directory string. If something goes 	 * wrong, abandon ship. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"%s/%s"
argument_list|,
name|keysdir
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|str
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Read the filestamp, which is contained in the first line. 	 */
if|if
condition|(
operator|(
name|ptr
operator|=
name|fgets
argument_list|(
name|linkname
argument_list|,
name|MAXFILENAME
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_key: no data %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|ptr
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_key: no filestamp %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%u"
argument_list|,
name|fstamp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_key: invalid timestamp %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Read and decrypt PEM-encoded private key. 	 */
name|pkey
operator|=
name|PEM_read_PrivateKey
argument_list|(
name|str
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|passwd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_key %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Leave tracks in the cryptostats. 	 */
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|linkname
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"%s mod %d"
argument_list|,
operator|&
name|linkname
index|[
literal|2
index|]
argument_list|,
name|EVP_PKEY_size
argument_list|(
name|pkey
argument_list|)
operator|*
literal|8
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
name|NULL
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_key: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|EVP_MD_type
argument_list|(
name|pkey
argument_list|)
operator|==
name|EVP_PKEY_DSA
condition|)
name|DSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|RSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_cert - load certificate from file  *  * This routine loads a X.509 RSA or DSA certificate from a file and  * constructs a info/cert value structure for this machine. The  * structure includes a filestamp extracted from the file name. Later  * the certificate can be sent to another machine by request.  *  * Returns certificate info/value pointer if valid, NULL if not.  */
end_comment

begin_function
specifier|static
name|struct
name|cert_info
modifier|*
comment|/* certificate information */
name|crypto_cert
parameter_list|(
name|char
modifier|*
name|cp
comment|/* file name */
parameter_list|)
block|{
name|struct
name|cert_info
modifier|*
name|ret
decl_stmt|;
comment|/* certificate information */
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|char
name|filename
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* name of certificate file */
name|char
name|linkname
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* filestamp buffer */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|tstamp_t
name|fstamp
decl_stmt|;
comment|/* filestamp */
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|header
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
comment|/* 	 * Open the certificate file. If the first character of the file 	 * name is not '/', prepend the keys directory string. If 	 * something goes wrong, abandon ship. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"%s/%s"
argument_list|,
name|keysdir
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|str
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Read the filestamp, which is contained in the first line. 	 */
if|if
condition|(
operator|(
name|ptr
operator|=
name|fgets
argument_list|(
name|linkname
argument_list|,
name|MAXFILENAME
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_cert: no data %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|ptr
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_cert: no filestamp %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|fstamp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_cert: invalid filestamp %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Read PEM-encoded certificate and install. 	 */
if|if
condition|(
operator|!
name|PEM_read
argument_list|(
name|str
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|header
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_cert %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|free
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"CERTIFICATE"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_cert: wrong PEM type %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Parse certificate and generate info/value structure. 	 */
name|ret
operator|=
name|cert_parse
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|linkname
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"%s 0x%x len %lu"
argument_list|,
operator|&
name|linkname
index|[
literal|2
index|]
argument_list|,
name|ret
operator|->
name|flags
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
name|NULL
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_cert: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_tai - load leapseconds table from file  *  * This routine loads the ERTS leapsecond file in NIST text format,  * converts to a value structure and extracts a filestamp from the file  * name. The data are used to establish the TAI offset from UTC, which  * is provided to the kernel if supported. Later the data can be sent to  * another machine on request.  */
end_comment

begin_function
specifier|static
name|void
name|crypto_tai
parameter_list|(
name|char
modifier|*
name|cp
comment|/* file name */
parameter_list|)
block|{
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|char
name|buf
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* file line buffer */
name|u_int
name|leapsec
index|[
name|MAX_LEAP
index|]
decl_stmt|;
comment|/* NTP time at leaps */
name|u_int
name|offset
decl_stmt|;
comment|/* offset at leap (s) */
name|char
name|filename
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* name of leapseconds file */
name|char
name|linkname
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* file link (for filestamp) */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|tstamp_t
name|fstamp
decl_stmt|;
comment|/* filestamp */
name|u_int
name|len
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|KERNEL_PLL
if|#
directive|if
name|NTP_API
operator|>
literal|3
name|struct
name|timex
name|ntv
decl_stmt|;
comment|/* kernel interface structure */
endif|#
directive|endif
comment|/* NTP_API */
endif|#
directive|endif
comment|/* KERNEL_PLL */
comment|/* 	 * Open the file and discard comment lines. If the first 	 * character of the file name is not '/', prepend the keys 	 * directory string. If the file is not found, not to worry; it 	 * can be retrieved over the net. But, if it is found with 	 * errors, we crash and burn. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"%s/%s"
argument_list|,
name|keysdir
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|str
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Extract filestamp if present. 	 */
name|rval
operator|=
name|readlink
argument_list|(
name|filename
argument_list|,
name|linkname
argument_list|,
name|MAXFILENAME
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|>
literal|0
condition|)
block|{
name|linkname
index|[
name|rval
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ptr
operator|=
name|strrchr
argument_list|(
name|linkname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|fstamp
argument_list|)
expr_stmt|;
else|else
name|fstamp
operator|=
literal|0
expr_stmt|;
name|tai_leap
operator|.
name|fstamp
operator|=
name|htonl
argument_list|(
name|fstamp
argument_list|)
expr_stmt|;
comment|/* 	 * We are rather paranoid here, since an intruder might cause a 	 * coredump by infiltrating naughty values. Empty lines and 	 * comments are ignored. Other lines must begin with two 	 * integers followed by junk or comments. The first integer is 	 * the NTP seconds of leap insertion, the second is the offset 	 * of TAI relative to UTC after that insertion. The second word 	 * must equal the initial insertion of ten seconds on 1 January 	 * 1972 plus one second for each succeeding insertion. 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|MAX_LEAP
condition|)
block|{
name|ptr
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|NTP_MAXSTRLEN
operator|-
literal|1
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|<
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%u %u"
argument_list|,
operator|&
name|leapsec
index|[
name|i
index|]
argument_list|,
operator|&
name|offset
argument_list|)
operator|!=
literal|2
condition|)
continue|continue;
if|if
condition|(
name|i
operator|!=
call|(
name|int
call|)
argument_list|(
name|offset
operator|-
name|TAI_1972
argument_list|)
condition|)
block|{
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_tai: leapseconds file %s error %d"
argument_list|,
name|cp
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The extension field table entries consists of the NTP seconds 	 * of leap insertion in reverse order, so that the most recent 	 * insertion is the first entry in the table. 	 */
name|len
operator|=
name|i
operator|*
literal|4
expr_stmt|;
name|tai_leap
operator|.
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|tai_leap
operator|.
name|ptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptr
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
operator|(
name|char
operator|)
name|htonl
argument_list|(
name|leapsec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|crypto_flags
operator||=
name|CRYPTO_FLAG_TAI
expr_stmt|;
name|sys_tai
operator|=
name|len
operator|/
literal|4
operator|+
name|TAI_1972
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNEL_PLL
if|#
directive|if
name|NTP_API
operator|>
literal|3
name|ntv
operator|.
name|modes
operator|=
name|MOD_TAI
expr_stmt|;
name|ntv
operator|.
name|constant
operator|=
name|sys_tai
expr_stmt|;
if|if
condition|(
name|ntp_adjtime
argument_list|(
operator|&
name|ntv
argument_list|)
operator|==
name|TIME_ERROR
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"crypto_tai: kernel TAI update failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NTP_API */
endif|#
directive|endif
comment|/* KERNEL_PLL */
name|sprintf
argument_list|(
name|statstr
argument_list|,
literal|"%s link %d fs %u offset %u"
argument_list|,
name|cp
argument_list|,
name|rval
argument_list|,
name|fstamp
argument_list|,
name|ntohl
argument_list|(
name|tai_leap
operator|.
name|vallen
argument_list|)
operator|/
literal|4
operator|+
name|TAI_1972
operator|-
literal|1
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
name|NULL
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_tai: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * crypto_setup - load keys, certificate and leapseconds table  *  * This routine loads the public/private host key and certificate. If  * available, it loads the public/private sign key, which defaults to  * the host key, and leapseconds table. The host key must be RSA, but  * the sign key can be either RSA or DSA. In either case, the public key  * on the certificate must agree with the sign key.  */
end_comment

begin_function
name|void
name|crypto_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private/public key pair */
name|char
name|filename
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* file name buffer */
name|l_fp
name|seed
decl_stmt|;
comment|/* crypto PRNG seed as NTP timestamp */
name|tstamp_t
name|fstamp
decl_stmt|;
comment|/* filestamp */
name|tstamp_t
name|sstamp
decl_stmt|;
comment|/* sign filestamp */
name|u_int
name|len
decl_stmt|,
name|bytes
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
comment|/* 	 * Initialize structures. 	 */
if|if
condition|(
operator|!
name|crypto_flags
condition|)
return|return;
name|gethostname
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|sys_hostname
operator|=
name|emalloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sys_hostname
argument_list|,
name|filename
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|passwd
operator|==
name|NULL
condition|)
name|passwd
operator|=
name|sys_hostname
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hostval
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hostval
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pubkey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pubkey
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tai_leap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tai_leap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Load required random seed file and seed the random number 	 * generator. Be default, it is found in the user home 	 * directory. The root home directory may be / or /root, 	 * depending on the system. Wiggle the contents a bit and write 	 * it back so the sequence does not repeat when we next restart. 	 */
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
if|if
condition|(
name|rand_file
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|RAND_file_name
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rand_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rand_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|rand_file
operator|!=
literal|'/'
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"%s/%s"
argument_list|,
name|keysdir
argument_list|,
name|rand_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rand_file
argument_list|)
expr_stmt|;
name|rand_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rand_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rand_file
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: random seed file not specified"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bytes
operator|=
name|RAND_load_file
argument_list|(
name|rand_file
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: random seed file %s not found\n"
argument_list|,
name|rand_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|get_systime
argument_list|(
operator|&
name|seed
argument_list|)
expr_stmt|;
name|RAND_seed
argument_list|(
operator|&
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|)
expr_stmt|;
name|RAND_write_file
argument_list|(
name|rand_file
argument_list|)
expr_stmt|;
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_setup: OpenSSL version %lx random seed file %s bytes read %d\n"
argument_list|,
name|SSLeay
argument_list|()
argument_list|,
name|rand_file
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Load required host key from file "ntpkey_host_<hostname>". It 	 * also becomes the default sign key. 	 */
if|if
condition|(
name|host_file
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_host_%s"
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
name|host_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|host_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|pkey
operator|=
name|crypto_key
argument_list|(
name|host_file
argument_list|,
operator|&
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: host key file %s not found or corrupt"
argument_list|,
name|host_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|host_pkey
operator|=
name|pkey
expr_stmt|;
name|sign_pkey
operator|=
name|pkey
expr_stmt|;
name|sstamp
operator|=
name|fstamp
expr_stmt|;
name|hostval
operator|.
name|fstamp
operator|=
name|htonl
argument_list|(
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_MD_type
argument_list|(
name|host_pkey
argument_list|)
operator|!=
name|EVP_PKEY_RSA
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: host key is not RSA key type"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|hostval
operator|.
name|vallen
operator|=
name|htonl
argument_list|(
name|strlen
argument_list|(
name|sys_hostname
argument_list|)
argument_list|)
expr_stmt|;
name|hostval
operator|.
name|ptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sys_hostname
expr_stmt|;
comment|/* 	 * Construct public key extension field for agreement scheme. 	 */
name|len
operator|=
name|i2d_PublicKey
argument_list|(
name|host_pkey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|pubkey
operator|.
name|ptr
operator|=
name|ptr
expr_stmt|;
name|i2d_PublicKey
argument_list|(
name|host_pkey
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|pubkey
operator|.
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|pubkey
operator|.
name|fstamp
operator|=
name|hostval
operator|.
name|fstamp
expr_stmt|;
comment|/* 	 * Load optional sign key from file "ntpkey_sign_<hostname>". If 	 * loaded, it becomes the sign key. 	 */
if|if
condition|(
name|sign_file
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_sign_%s"
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
name|sign_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sign_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|pkey
operator|=
name|crypto_key
argument_list|(
name|sign_file
argument_list|,
operator|&
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
operator|!=
name|NULL
condition|)
block|{
name|sign_pkey
operator|=
name|pkey
expr_stmt|;
name|sstamp
operator|=
name|fstamp
expr_stmt|;
block|}
name|sign_siglen
operator|=
name|EVP_PKEY_size
argument_list|(
name|sign_pkey
argument_list|)
expr_stmt|;
comment|/* 	 * Load optional IFF parameters from file 	 * "ntpkey_iff_<hostname>". 	 */
if|if
condition|(
name|iffpar_file
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_iff_%s"
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
name|iffpar_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iffpar_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|iffpar_pkey
operator|=
name|crypto_key
argument_list|(
name|iffpar_file
argument_list|,
operator|&
name|if_fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|iffpar_pkey
operator|!=
name|NULL
condition|)
name|crypto_flags
operator||=
name|CRYPTO_FLAG_IFF
expr_stmt|;
comment|/* 	 * Load optional GQ parameters from file "ntpkey_gq_<hostname>". 	 */
if|if
condition|(
name|gqpar_file
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_gq_%s"
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
name|gqpar_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|gqpar_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|gqpar_pkey
operator|=
name|crypto_key
argument_list|(
name|gqpar_file
argument_list|,
operator|&
name|gq_fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gqpar_pkey
operator|!=
name|NULL
condition|)
name|crypto_flags
operator||=
name|CRYPTO_FLAG_GQ
expr_stmt|;
comment|/* 	 * Load optional MV parameters from file "ntpkey_mv_<hostname>". 	 */
if|if
condition|(
name|mvpar_file
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_mv_%s"
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
name|mvpar_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mvpar_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|mvpar_pkey
operator|=
name|crypto_key
argument_list|(
name|mvpar_file
argument_list|,
operator|&
name|mv_fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvpar_pkey
operator|!=
name|NULL
condition|)
name|crypto_flags
operator||=
name|CRYPTO_FLAG_MV
expr_stmt|;
comment|/* 	 * Load required certificate from file "ntpkey_cert_<hostname>". 	 */
if|if
condition|(
name|cert_file
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
name|MAXFILENAME
argument_list|,
literal|"ntpkey_cert_%s"
argument_list|,
name|sys_hostname
argument_list|)
expr_stmt|;
name|cert_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cert_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cinfo
operator|=
name|crypto_cert
argument_list|(
name|cert_file
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"certificate file %s not found or corrupt"
argument_list|,
name|cert_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The subject name must be the same as the host name, unless 	 * the certificate is private, in which case it may have come 	 * from another host. 	 */
if|if
condition|(
operator|!
operator|(
name|cinfo
operator|->
name|flags
operator|&
name|CERT_PRIV
operator|)
operator|&&
name|strcmp
argument_list|(
name|cinfo
operator|->
name|subject
argument_list|,
name|sys_hostname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: certificate %s not for this host"
argument_list|,
name|cert_file
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * It the certificate is trusted, the subject must be the same 	 * as the issuer, in other words it must be self signed. 	 */
if|if
condition|(
name|cinfo
operator|->
name|flags
operator|&
name|CERT_PRIV
operator|&&
name|strcmp
argument_list|(
name|cinfo
operator|->
name|subject
argument_list|,
name|cinfo
operator|->
name|issuer
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cert_valid
argument_list|(
name|cinfo
argument_list|,
name|sign_pkey
argument_list|)
operator|!=
name|XEVNT_OK
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: certificate %s is trusted, but not self signed."
argument_list|,
name|cert_file
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sign_digest
operator|=
name|cinfo
operator|->
name|digest
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|flags
operator|&
name|CERT_PRIV
condition|)
name|crypto_flags
operator||=
name|CRYPTO_FLAG_PRIV
expr_stmt|;
name|crypto_flags
operator||=
name|cinfo
operator|->
name|nid
operator|<<
literal|16
expr_stmt|;
comment|/* 	 * Load optional leapseconds table from file "ntpkey_leap". If 	 * the file is missing or defective, the values can later be 	 * retrieved from a server. 	 */
if|if
condition|(
name|leap_file
operator|==
name|NULL
condition|)
name|leap_file
operator|=
literal|"ntpkey_leap"
expr_stmt|;
name|crypto_tai
argument_list|(
name|leap_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_setup: flags 0x%x host %s signature %s\n"
argument_list|,
name|crypto_flags
argument_list|,
name|sys_hostname
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|cinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * crypto_config - configure data from crypto configuration command.  */
end_comment

begin_function
name|void
name|crypto_config
parameter_list|(
name|int
name|item
parameter_list|,
comment|/* configuration item */
name|char
modifier|*
name|cp
comment|/* file name */
parameter_list|)
block|{
switch|switch
condition|(
name|item
condition|)
block|{
comment|/* 	 * Set random seed file name. 	 */
case|case
name|CRYPTO_CONF_RAND
case|:
name|rand_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rand_file
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set private key password. 	 */
case|case
name|CRYPTO_CONF_PW
case|:
name|passwd
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|passwd
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set host file name. 	 */
case|case
name|CRYPTO_CONF_PRIV
case|:
name|host_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|host_file
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set sign key file name. 	 */
case|case
name|CRYPTO_CONF_SIGN
case|:
name|sign_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sign_file
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set iff parameters file name. 	 */
case|case
name|CRYPTO_CONF_IFFPAR
case|:
name|iffpar_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iffpar_file
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set gq parameters file name. 	 */
case|case
name|CRYPTO_CONF_GQPAR
case|:
name|gqpar_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|gqpar_file
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set mv parameters file name. 	 */
case|case
name|CRYPTO_CONF_MVPAR
case|:
name|mvpar_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mvpar_file
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set certificate file name. 	 */
case|case
name|CRYPTO_CONF_CERT
case|:
name|cert_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cert_file
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set leapseconds file name. 	 */
case|case
name|CRYPTO_CONF_LEAP
case|:
name|leap_file
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|leap_file
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
name|crypto_flags
operator||=
name|CRYPTO_FLAG_ENAB
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|ntp_crypto_bs_pubkey
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

end_unit

