begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_crypto.c - NTP version 4 public key routines  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* strtoul */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_random.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_leapsec.h"
end_include

begin_include
include|#
directive|include
file|"openssl/asn1_mac.h"
end_include

begin_include
include|#
directive|include
file|"openssl/bn.h"
end_include

begin_include
include|#
directive|include
file|"openssl/err.h"
end_include

begin_include
include|#
directive|include
file|"openssl/evp.h"
end_include

begin_include
include|#
directive|include
file|"openssl/pem.h"
end_include

begin_include
include|#
directive|include
file|"openssl/rand.h"
end_include

begin_include
include|#
directive|include
file|"openssl/x509v3.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL_PLL
end_ifdef

begin_include
include|#
directive|include
file|"ntp_syscall.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

begin_comment
comment|/*  * calcomp - compare two calendar structures, ignoring yearday and weekday; like strcmp  * No, it's not a plotter.  If you don't understand that, you're too young.  */
end_comment

begin_function
specifier|static
name|int
name|calcomp
parameter_list|(
name|struct
name|calendar
modifier|*
name|pjd1
parameter_list|,
name|struct
name|calendar
modifier|*
name|pjd2
parameter_list|)
block|{
name|int32_t
name|diff
decl_stmt|;
comment|/* large enough to hold the signed difference between two uint16_t values */
name|diff
operator|=
name|pjd1
operator|->
name|year
operator|-
name|pjd2
operator|->
name|year
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
return|return
literal|1
return|;
comment|/* same year; compare months */
name|diff
operator|=
name|pjd1
operator|->
name|month
operator|-
name|pjd2
operator|->
name|month
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
return|return
literal|1
return|;
comment|/* same year and month; compare monthday */
name|diff
operator|=
name|pjd1
operator|->
name|monthday
operator|-
name|pjd2
operator|->
name|monthday
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
return|return
literal|1
return|;
comment|/* same year and month and monthday; compare time */
name|diff
operator|=
name|pjd1
operator|->
name|hour
operator|-
name|pjd2
operator|->
name|hour
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
return|return
literal|1
return|;
name|diff
operator|=
name|pjd1
operator|->
name|minute
operator|-
name|pjd2
operator|->
name|minute
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
return|return
literal|1
return|;
name|diff
operator|=
name|pjd1
operator|->
name|second
operator|-
name|pjd2
operator|->
name|second
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
return|return
literal|1
return|;
comment|/* identical */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Extension field message format  *  * These are always signed and saved before sending in network byte  * order. They must be converted to and from host byte order for  * processing.  *  * +-------+-------+  * |   op  |  len  |<- extension pointer  * +-------+-------+  * |    associd    |  * +---------------+  * |   timestamp   |<- value pointer  * +---------------+  * |   filestamp   |  * +---------------+  * |   value len   |  * +---------------+  * |               |  * =     value     =  * |               |  * +---------------+  * | signature len |  * +---------------+  * |               |  * =   signature   =  * |               |  * +---------------+  *  * The CRYPTO_RESP bit is set to 0 for requests, 1 for responses.  * Requests carry the association ID of the receiver; responses carry  * the association ID of the sender. Some messages include only the  * operation/length and association ID words and so have length 8  * octets. Ohers include the value structure and associated value and  * signature fields. These messages include the timestamp, filestamp,  * value and signature words and so have length at least 24 octets. The  * signature and/or value fields can be empty, in which case the  * respective length words are zero. An empty value with nonempty  * signature is syntactically valid, but semantically questionable.  *  * The filestamp represents the time when a cryptographic data file such  * as a public/private key pair is created. It follows every reference  * depending on that file and serves as a means to obsolete earlier data  * of the same type. The timestamp represents the time when the  * cryptographic data of the message were last signed. Creation of a  * cryptographic data file or signing a message can occur only when the  * creator or signor is synchronized to an authoritative source and  * proventicated to a trusted authority.  *  * Note there are several conditions required for server trust. First,  * the public key on the server certificate must be verified, which can  * involve a hike along the certificate trail to a trusted host. Next,  * the server trust must be confirmed by one of several identity  * schemes. Valid cryptographic values are signed with attached  * timestamp and filestamp. Individual packet trust is confirmed  * relative to these values by a message digest with keys generated by a  * reverse-order pseudorandom hash.  *  * State decomposition. These flags are lit in the order given. They are  * dim only when the association is demobilized.  *  * CRYPTO_FLAG_ENAB	Lit upon acceptance of a CRYPTO_ASSOC message  * CRYPTO_FLAG_CERT	Lit when a self-digned trusted certificate is  *			accepted.  * CRYPTO_FLAG_VRFY	Lit when identity is confirmed.  * CRYPTO_FLAG_PROV	Lit when the first signature is verified.  * CRYPTO_FLAG_COOK	Lit when a valid cookie is accepted.  * CRYPTO_FLAG_AUTO	Lit when valid autokey values are accepted.  * CRYPTO_FLAG_SIGN	Lit when the server signed certificate is  *			accepted.  * CRYPTO_FLAG_LEAP	Lit when the leapsecond values are accepted.  */
end_comment

begin_comment
comment|/*  * Cryptodefines  */
end_comment

begin_define
define|#
directive|define
name|TAI_1972
value|10
end_define

begin_comment
comment|/* initial TAI offset (s) */
end_comment

begin_define
define|#
directive|define
name|MAX_LEAP
value|100
end_define

begin_comment
comment|/* max UTC leapseconds (s) */
end_comment

begin_define
define|#
directive|define
name|VALUE_LEN
value|(6 * 4)
end_define

begin_comment
comment|/* min response field length */
end_comment

begin_define
define|#
directive|define
name|MAX_VALLEN
value|(65535 - VALUE_LEN)
end_define

begin_define
define|#
directive|define
name|YEAR
value|(60 * 60 * 24 * 365)
end_define

begin_comment
comment|/* seconds in year */
end_comment

begin_comment
comment|/*  * Global cryptodata in host byte order  */
end_comment

begin_decl_stmt
name|u_int32
name|crypto_flags
init|=
literal|0x0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status word */
end_comment

begin_decl_stmt
name|int
name|crypto_nid
init|=
name|KEY_TYPE_MD5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* digest nid */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sys_hostname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sys_groupname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|host_filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host file name */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ident_filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* group file name */
end_comment

begin_comment
comment|/*  * Global cryptodata in network byte order  */
end_comment

begin_decl_stmt
name|struct
name|cert_info
modifier|*
name|cinfo
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* certificate info/value cache */
end_comment

begin_decl_stmt
name|struct
name|cert_info
modifier|*
name|cert_host
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host certificate */
end_comment

begin_decl_stmt
name|struct
name|pkey_info
modifier|*
name|pkinfo
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key info/value cache */
end_comment

begin_decl_stmt
name|struct
name|value
name|hostval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host value */
end_comment

begin_decl_stmt
name|struct
name|value
name|pubkey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* public key */
end_comment

begin_decl_stmt
name|struct
name|value
name|tai_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* leapseconds values */
end_comment

begin_decl_stmt
name|struct
name|pkey_info
modifier|*
name|iffkey_info
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IFF keys */
end_comment

begin_decl_stmt
name|struct
name|pkey_info
modifier|*
name|gqkey_info
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GQ keys */
end_comment

begin_decl_stmt
name|struct
name|pkey_info
modifier|*
name|mvkey_info
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MV keys */
end_comment

begin_comment
comment|/*  * Private cryptodata in host byte order  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|passwd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private key password */
end_comment

begin_decl_stmt
specifier|static
name|EVP_PKEY
modifier|*
name|host_pkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host key */
end_comment

begin_decl_stmt
specifier|static
name|EVP_PKEY
modifier|*
name|sign_pkey
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sign key */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|EVP_MD
modifier|*
name|sign_digest
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sign digest */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|sign_siglen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sign key length */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rand_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* random seed file */
end_comment

begin_comment
comment|/*  * Cryptotypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|crypto_verify
parameter_list|(
name|struct
name|exten
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_encrypt
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|keyid_t
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_alice
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_alice2
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_alice3
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_bob
parameter_list|(
name|struct
name|exten
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_bob2
parameter_list|(
name|struct
name|exten
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_bob3
parameter_list|(
name|struct
name|exten
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_iff
parameter_list|(
name|struct
name|exten
modifier|*
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_gq
parameter_list|(
name|struct
name|exten
modifier|*
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_mv
parameter_list|(
name|struct
name|exten
modifier|*
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|crypto_send
parameter_list|(
name|struct
name|exten
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tstamp_t
name|crypto_time
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|asn_to_calendar
parameter_list|(
name|ASN1_TIME
modifier|*
parameter_list|,
name|struct
name|calendar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cert_info
modifier|*
name|cert_parse
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|long
parameter_list|,
name|tstamp_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cert_sign
parameter_list|(
name|struct
name|exten
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cert_info
modifier|*
name|cert_install
parameter_list|(
name|struct
name|exten
modifier|*
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cert_hike
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|struct
name|cert_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cert_free
parameter_list|(
name|struct
name|cert_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pkey_info
modifier|*
name|crypto_key
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bighash
parameter_list|(
name|BIGNUM
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cert_info
modifier|*
name|crypto_cert
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_function
name|int
name|readlink
parameter_list|(
name|char
modifier|*
name|link
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * session_key - generate session key  *  * This routine generates a session key from the source address,  * destination address, key ID and private value. The value of the  * session key is the MD5 hash of these values, while the next key ID is  * the first four octets of the hash.  *  * Returns the next key ID or 0 if there is no destination address.  */
end_comment

begin_function
name|keyid_t
name|session_key
parameter_list|(
name|sockaddr_u
modifier|*
name|srcadr
parameter_list|,
comment|/* source address */
name|sockaddr_u
modifier|*
name|dstadr
parameter_list|,
comment|/* destination address */
name|keyid_t
name|keyno
parameter_list|,
comment|/* key ID */
name|keyid_t
name|private
parameter_list|,
comment|/* private value */
name|u_long
name|lifetime
comment|/* key lifetime */
parameter_list|)
block|{
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* message digest context */
name|u_char
name|dgst
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
comment|/* message digest */
name|keyid_t
name|keyid
decl_stmt|;
comment|/* key identifer */
name|u_int32
name|header
index|[
literal|10
index|]
decl_stmt|;
comment|/* data in network byte order */
name|u_int
name|hdlen
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|dstadr
condition|)
return|return
literal|0
return|;
comment|/* 	 * Generate the session key and key ID. If the lifetime is 	 * greater than zero, install the key and call it trusted. 	 */
name|hdlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|AF
argument_list|(
name|srcadr
argument_list|)
condition|)
block|{
case|case
name|AF_INET
case|:
name|header
index|[
literal|0
index|]
operator|=
name|NSRCADR
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
name|header
index|[
literal|1
index|]
operator|=
name|NSRCADR
argument_list|(
name|dstadr
argument_list|)
expr_stmt|;
name|header
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
name|header
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|private
argument_list|)
expr_stmt|;
name|hdlen
operator|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|memcpy
argument_list|(
operator|&
name|header
index|[
literal|0
index|]
argument_list|,
name|PSOCK_ADDR6
argument_list|(
name|srcadr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|header
index|[
literal|4
index|]
argument_list|,
name|PSOCK_ADDR6
argument_list|(
name|dstadr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|header
index|[
literal|8
index|]
operator|=
name|htonl
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
name|header
index|[
literal|9
index|]
operator|=
name|htonl
argument_list|(
name|private
argument_list|)
expr_stmt|;
name|hdlen
operator|=
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
expr_stmt|;
break|break;
block|}
name|EVP_DigestInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|EVP_get_digestbynid
argument_list|(
name|crypto_nid
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|header
argument_list|,
name|hdlen
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|dgst
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|keyid
argument_list|,
name|dgst
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|keyid
operator|=
name|ntohl
argument_list|(
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lifetime
operator|!=
literal|0
condition|)
block|{
name|MD5auth_setkey
argument_list|(
name|keyno
argument_list|,
name|crypto_nid
argument_list|,
name|dgst
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|keyno
argument_list|,
name|lifetime
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"session_key: %s> %s %08x %08x hash %08x life %lu\n"
operator|,
name|stoa
argument_list|(
name|srcadr
argument_list|)
operator|,
name|stoa
argument_list|(
name|dstadr
argument_list|)
operator|,
name|keyno
operator|,
name|private
operator|,
name|keyid
operator|,
name|lifetime
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|keyid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * make_keylist - generate key list  *  * Returns  * XEVNT_OK	success  * XEVNT_ERR	protocol error  *  * This routine constructs a pseudo-random sequence by repeatedly  * hashing the session key starting from a given source address,  * destination address, private value and the next key ID of the  * preceeding session key. The last entry on the list is saved along  * with its sequence number and public signature.  */
end_comment

begin_function
name|int
name|make_keylist
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|struct
name|interface
modifier|*
name|dstadr
comment|/* interface */
parameter_list|)
block|{
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|struct
name|autokey
modifier|*
name|ap
decl_stmt|;
comment|/* autokey pointer */
name|struct
name|value
modifier|*
name|vp
decl_stmt|;
comment|/* value pointer */
name|keyid_t
name|keyid
init|=
literal|0
decl_stmt|;
comment|/* next key ID */
name|keyid_t
name|cookie
decl_stmt|;
comment|/* private value */
name|long
name|lifetime
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|mpoll
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dstadr
condition|)
return|return
name|XEVNT_ERR
return|;
comment|/* 	 * Allocate the key list if necessary. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|keylist
operator|==
name|NULL
condition|)
name|peer
operator|->
name|keylist
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|keyid_t
argument_list|)
operator|*
name|NTP_MAXSESSION
argument_list|)
expr_stmt|;
comment|/* 	 * Generate an initial key ID which is unique and greater than 	 * NTP_MAXKEY. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|keyid
operator|=
name|ntp_random
argument_list|()
operator|&
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|keyid
operator|<=
name|NTP_MAXKEY
condition|)
continue|continue;
if|if
condition|(
name|authhavekey
argument_list|(
name|keyid
argument_list|)
condition|)
continue|continue;
break|break;
block|}
comment|/* 	 * Generate up to NTP_MAXSESSION session keys. Stop if the 	 * next one would not be unique or not a session key ID or if 	 * it would expire before the next poll. The private value 	 * included in the hash is zero if broadcast mode, the peer 	 * cookie if client mode or the host cookie if symmetric modes. 	 */
name|mpoll
operator|=
literal|1
operator|<<
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
name|lifetime
operator|=
name|min
argument_list|(
literal|1U
operator|<<
name|sys_automax
argument_list|,
name|NTP_MAXSESSION
operator|*
name|mpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
condition|)
name|cookie
operator|=
literal|0
expr_stmt|;
else|else
name|cookie
operator|=
name|peer
operator|->
name|pcookie
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_MAXSESSION
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|keylist
index|[
name|i
index|]
operator|=
name|keyid
expr_stmt|;
name|peer
operator|->
name|keynumber
operator|=
name|i
expr_stmt|;
name|keyid
operator|=
name|session_key
argument_list|(
operator|&
name|dstadr
operator|->
name|sin
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|keyid
argument_list|,
name|cookie
argument_list|,
name|lifetime
operator|+
name|mpoll
argument_list|)
expr_stmt|;
name|lifetime
operator|-=
name|mpoll
expr_stmt|;
if|if
condition|(
name|auth_havekey
argument_list|(
name|keyid
argument_list|)
operator|||
name|keyid
operator|<=
name|NTP_MAXKEY
operator|||
name|lifetime
operator|<
literal|0
operator|||
name|tstamp
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 	 * Save the last session key ID, sequence number and timestamp, 	 * then sign these values for later retrieval by the clients. Be 	 * careful not to use invalid key media. Use the public values 	 * timestamp as filestamp.  	 */
name|vp
operator|=
operator|&
name|peer
operator|->
name|sndval
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|ptr
operator|==
name|NULL
condition|)
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|autokey
argument_list|)
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|(
expr|struct
name|autokey
operator|*
operator|)
name|vp
operator|->
name|ptr
expr_stmt|;
name|ap
operator|->
name|seq
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|keynumber
argument_list|)
expr_stmt|;
name|ap
operator|->
name|key
operator|=
name|htonl
argument_list|(
name|keyid
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|autokey
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstamp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|sig
operator|==
name|NULL
condition|)
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|vp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|autokey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
block|{
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_ASSOC
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"make_keys: %d %08x %08x ts %u fs %u poll %d\n"
argument_list|,
name|peer
operator|->
name|keynumber
argument_list|,
name|keyid
argument_list|,
name|cookie
argument_list|,
name|ntohl
argument_list|(
name|vp
operator|->
name|tstamp
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|vp
operator|->
name|fstamp
argument_list|)
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_recv - parse extension fields  *  * This routine is called when the packet has been matched to an  * association and passed sanity, format and MAC checks. We believe the  * extension field values only if the field has proper format and  * length, the timestamp and filestamp are valid and the signature has  * valid length and is verified. There are a few cases where some values  * are believed even if the signature fails, but only if the proventic  * bit is not set.  *  * Returns  * XEVNT_OK	success  * XEVNT_ERR	protocol error  * XEVNT_LEN	bad field format or length  */
end_comment

begin_function
name|int
name|crypto_recv
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* packet buffer pointer */
parameter_list|)
block|{
specifier|const
name|EVP_MD
modifier|*
name|dp
decl_stmt|;
comment|/* message digest algorithm */
name|u_int32
modifier|*
name|pkt
decl_stmt|;
comment|/* receive packet pointer */
name|struct
name|autokey
modifier|*
name|ap
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
comment|/* autokey pointer */
name|struct
name|exten
modifier|*
name|ep
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
comment|/* extension pointers */
name|struct
name|cert_info
modifier|*
name|xinfo
decl_stmt|;
comment|/* certificate info pointer */
name|int
name|has_mac
decl_stmt|;
comment|/* length of MAC field */
name|int
name|authlen
decl_stmt|;
comment|/* offset of MAC field */
name|associd_t
name|associd
decl_stmt|;
comment|/* association ID */
name|tstamp_t
name|fstamp
init|=
literal|0
decl_stmt|;
comment|/* filestamp */
name|u_int
name|len
decl_stmt|;
comment|/* extension field length */
name|u_int
name|code
decl_stmt|;
comment|/* extension field opcode */
name|u_int
name|vallen
init|=
literal|0
decl_stmt|;
comment|/* value length */
name|X509
modifier|*
name|cert
decl_stmt|;
comment|/* X509 certificate */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|keyid_t
name|cookie
decl_stmt|;
comment|/* crumbles */
name|int
name|hismode
decl_stmt|;
comment|/* packet mode */
name|int
name|rval
init|=
name|XEVNT_OK
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|puch
decl_stmt|;
name|u_int32
name|temp32
decl_stmt|;
comment|/* 	 * Initialize. Note that the packet has already been checked for 	 * valid format and extension field lengths. First extract the 	 * field length, command code and association ID in host byte 	 * order. These are used with all commands and modes. Then check 	 * the version number, which must be 2, and length, which must 	 * be at least 8 for requests and VALUE_LEN (24) for responses. 	 * Packets that fail either test sink without a trace. The 	 * association ID is saved only if nonzero. 	 */
name|authlen
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
name|hismode
operator|=
operator|(
name|int
operator|)
name|PKT_MODE
argument_list|(
operator|(
operator|&
name|rbufp
operator|->
name|recv_pkt
operator|)
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|has_mac
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|authlen
operator|)
operator|>
operator|(
name|int
operator|)
name|MAX_MAC_LEN
condition|)
block|{
name|pkt
operator|=
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_pkt
operator|+
name|authlen
operator|/
literal|4
expr_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|exten
operator|*
operator|)
name|pkt
expr_stmt|;
name|code
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
operator|&
literal|0xffff0000
expr_stmt|;
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
comment|// HMS: Why pkt[1] instead of ep->associd ?
name|associd
operator|=
operator|(
name|associd_t
operator|)
name|ntohl
argument_list|(
name|pkt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rval
operator|=
name|XEVNT_OK
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: flags 0x%x ext offset %d len %u code 0x%x associd %d\n"
argument_list|,
name|peer
operator|->
name|crypto
argument_list|,
name|authlen
argument_list|,
name|len
argument_list|,
name|code
operator|>>
literal|16
argument_list|,
name|associd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Check version number and field length. If bad, 		 * quietly ignore the packet. 		 */
if|if
condition|(
operator|(
operator|(
name|code
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
operator|)
operator|!=
name|CRYPTO_VN
operator|||
name|len
operator|<
literal|8
condition|)
block|{
name|sys_badlength
operator|++
expr_stmt|;
name|code
operator||=
name|CRYPTO_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
name|VALUE_LEN
condition|)
block|{
name|fstamp
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|vallen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
comment|/* 			 * Bug 2761: I hope this isn't too early... 			 */
if|if
condition|(
name|vallen
operator|==
literal|0
operator|||
name|len
operator|-
name|VALUE_LEN
operator|<
name|vallen
condition|)
return|return
name|XEVNT_LEN
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* 		 * Install status word, host name, signature scheme and 		 * association ID. In OpenSSL the signature algorithm is 		 * bound to the digest algorithm, so the NID completely 		 * defines the signature scheme. Note the request and 		 * response are identical, but neither is validated by 		 * signature. The request is processed here only in 		 * symmetric modes. The server name field might be 		 * useful to implement access controls in future. 		 */
case|case
name|CRYPTO_ASSOC
case|:
comment|/* 			 * If our state machine is running when this 			 * message arrives, the other fellow might have 			 * restarted. However, this could be an 			 * intruder, so just clamp the poll interval and 			 * find out for ourselves. Otherwise, pass the 			 * extension field to the transmit side. 			 */
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_CERT
condition|)
block|{
name|rval
operator|=
name|XEVNT_ERR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|peer
operator|->
name|cmmd
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|assoc
operator|!=
name|associd
condition|)
block|{
name|rval
operator|=
name|XEVNT_ERR
expr_stmt|;
break|break;
block|}
block|}
name|fp
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fp
argument_list|,
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fp
operator|->
name|associd
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|fp
expr_stmt|;
comment|/* fall through */
case|case
name|CRYPTO_ASSOC
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if it has already been 			 * stored or the message has been amputated. 			 */
if|if
condition|(
name|peer
operator|->
name|crypto
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|assoc
operator|!=
name|associd
condition|)
name|rval
operator|=
name|XEVNT_ERR
expr_stmt|;
break|break;
block|}
name|INSIST
argument_list|(
name|len
operator|>=
name|VALUE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|vallen
operator|==
literal|0
operator|||
name|vallen
operator|>
name|MAXHOSTNAME
operator|||
name|len
operator|-
name|VALUE_LEN
operator|<
name|vallen
condition|)
block|{
name|rval
operator|=
name|XEVNT_LEN
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: ident host 0x%x %d server 0x%x %d\n"
argument_list|,
name|crypto_flags
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|fstamp
argument_list|,
name|peer
operator|->
name|assoc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|temp32
operator|=
name|crypto_flags
operator|&
name|CRYPTO_FLAG_MASK
expr_stmt|;
comment|/* 			 * If the client scheme is PC, the server scheme 			 * must be PC. The public key and identity are 			 * presumed valid, so we skip the certificate 			 * and identity exchanges and move immediately 			 * to the cookie exchange which confirms the 			 * server signature. 			 */
if|if
condition|(
name|crypto_flags
operator|&
name|CRYPTO_FLAG_PRIV
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fstamp
operator|&
name|CRYPTO_FLAG_PRIV
operator|)
condition|)
block|{
name|rval
operator|=
name|XEVNT_KEY
expr_stmt|;
break|break;
block|}
name|fstamp
operator||=
name|CRYPTO_FLAG_CERT
operator||
name|CRYPTO_FLAG_VRFY
operator||
name|CRYPTO_FLAG_SIGN
expr_stmt|;
comment|/* 			 * It is an error if either peer supports 			 * identity, but the other does not. 			 */
block|}
elseif|else
if|if
condition|(
name|hismode
operator|==
name|MODE_ACTIVE
operator|||
name|hismode
operator|==
name|MODE_PASSIVE
condition|)
block|{
if|if
condition|(
operator|(
name|temp32
operator|&&
operator|!
operator|(
name|fstamp
operator|&
name|CRYPTO_FLAG_MASK
operator|)
operator|)
operator|||
operator|(
operator|!
name|temp32
operator|&&
operator|(
name|fstamp
operator|&
name|CRYPTO_FLAG_MASK
operator|)
operator|)
condition|)
block|{
name|rval
operator|=
name|XEVNT_KEY
expr_stmt|;
break|break;
block|}
block|}
comment|/* 			 * Discard the message if the signature digest 			 * NID is not supported. 			 */
name|temp32
operator|=
operator|(
name|fstamp
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|dp
operator|=
operator|(
specifier|const
name|EVP_MD
operator|*
operator|)
name|EVP_get_digestbynid
argument_list|(
name|temp32
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|XEVNT_MD
expr_stmt|;
break|break;
block|}
comment|/* 			 * Save status word, host name and message 			 * digest/signature type. If this is from a 			 * broadcast and the association ID has changed, 			 * request the autokey values. 			 */
name|peer
operator|->
name|assoc
operator|=
name|associd
expr_stmt|;
if|if
condition|(
name|hismode
operator|==
name|MODE_SERVER
condition|)
name|fstamp
operator||=
name|CRYPTO_FLAG_AUTO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fstamp
operator|&
name|CRYPTO_FLAG_TAI
operator|)
condition|)
name|fstamp
operator||=
name|CRYPTO_FLAG_LEAP
expr_stmt|;
name|RAND_bytes
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|peer
operator|->
name|hcookie
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|peer
operator|->
name|crypto
operator|=
name|fstamp
expr_stmt|;
name|peer
operator|->
name|digest
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|subject
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|subject
argument_list|)
expr_stmt|;
name|peer
operator|->
name|subject
operator|=
name|emalloc
argument_list|(
name|vallen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|peer
operator|->
name|subject
argument_list|,
name|ep
operator|->
name|pkt
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|peer
operator|->
name|subject
index|[
name|vallen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|issuer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|issuer
operator|=
name|estrdup
argument_list|(
name|peer
operator|->
name|subject
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"assoc %d %d host %s %s"
argument_list|,
name|peer
operator|->
name|associd
argument_list|,
name|peer
operator|->
name|assoc
argument_list|,
name|peer
operator|->
name|subject
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|temp32
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Decode X509 certificate in ASN.1 format and extract 		 * the data containing, among other things, subject 		 * name and public key. In the default identification 		 * scheme, the certificate trail is followed to a self 		 * signed trusted certificate. 		 */
case|case
name|CRYPTO_CERT
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if empty or invalid. 			 */
if|if
condition|(
name|len
operator|<
name|VALUE_LEN
condition|)
break|break;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Scan the certificate list to delete old 			 * versions and link the newest version first on 			 * the list. Then, verify the signature. If the 			 * certificate is bad or missing, just ignore 			 * it. 			 */
if|if
condition|(
operator|(
name|xinfo
operator|=
name|cert_install
argument_list|(
name|ep
argument_list|,
name|peer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|XEVNT_CRT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|cert_hike
argument_list|(
name|peer
argument_list|,
name|xinfo
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * We plug in the public key and lifetime from 			 * the first certificate received. However, note 			 * that this certificate might not be signed by 			 * the server, so we can't check the 			 * signature/digest NID. 			 */
if|if
condition|(
name|peer
operator|->
name|pkey
operator|==
name|NULL
condition|)
block|{
name|puch
operator|=
name|xinfo
operator|->
name|cert
operator|.
name|ptr
expr_stmt|;
name|cert
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|puch
argument_list|,
name|ntohl
argument_list|(
name|xinfo
operator|->
name|cert
operator|.
name|vallen
argument_list|)
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
name|temp32
operator|=
name|xinfo
operator|->
name|nid
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"cert %s %s 0x%x %s (%u) fs %u"
argument_list|,
name|xinfo
operator|->
name|subject
argument_list|,
name|xinfo
operator|->
name|issuer
argument_list|,
name|xinfo
operator|->
name|flags
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|temp32
argument_list|)
argument_list|,
name|temp32
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Schnorr (IFF) identity scheme. This scheme is 		 * designed for use with shared secret server group keys 		 * and where the certificate may be generated by a third 		 * party. The client sends a challenge to the server, 		 * which performs a calculation and returns the result. 		 * A positive result is possible only if both client and 		 * server contain the same secret group key. 		 */
case|case
name|CRYPTO_IFF
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * If the challenge matches the response, the 			 * server public key, signature and identity are 			 * all verified at the same time. The server is 			 * declared trusted, so we skip further 			 * certificate exchanges and move immediately to 			 * the cookie exchange. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_iff
argument_list|(
name|ep
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_VRFY
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"iff %s fs %u"
argument_list|,
name|peer
operator|->
name|issuer
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Guillou-Quisquater (GQ) identity scheme. This scheme 		 * is designed for use with public certificates carrying 		 * the GQ public key in an extension field. The client 		 * sends a challenge to the server, which performs a 		 * calculation and returns the result. A positive result 		 * is possible only if both client and server contain 		 * the same group key and the server has the matching GQ 		 * private key. 		 */
case|case
name|CRYPTO_GQ
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * If the challenge matches the response, the 			 * server public key, signature and identity are 			 * all verified at the same time. The server is 			 * declared trusted, so we skip further 			 * certificate exchanges and move immediately to 			 * the cookie exchange. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_gq
argument_list|(
name|ep
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_VRFY
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"gq %s fs %u"
argument_list|,
name|peer
operator|->
name|issuer
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Mu-Varadharajan (MV) identity scheme. This scheme is 		 * designed for use with three levels of trust, trusted 		 * host, server and client. The trusted host key is 		 * opaque to servers and clients; the server keys are 		 * opaque to clients and each client key is different. 		 * Client keys can be revoked without requiring new key 		 * generations. 		 */
case|case
name|CRYPTO_MV
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * If the challenge matches the response, the 			 * server public key, signature and identity are 			 * all verified at the same time. The server is 			 * declared trusted, so we skip further 			 * certificate exchanges and move immediately to 			 * the cookie exchange. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_mv
argument_list|(
name|ep
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_VRFY
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"mv %s fs %u"
argument_list|,
name|peer
operator|->
name|issuer
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Cookie response in client and symmetric modes. If the 		 * cookie bit is set, the working cookie is the EXOR of 		 * the current and new values. 		 */
case|case
name|CRYPTO_COOK
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid or signature 			 * not verified with respect to the cookie 			 * values. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
operator|&
name|peer
operator|->
name|cookval
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Decrypt the cookie, hunting all the time for 			 * errors. 			 */
if|if
condition|(
name|vallen
operator|==
operator|(
name|u_int
operator|)
name|EVP_PKEY_size
argument_list|(
name|host_pkey
argument_list|)
condition|)
block|{
name|u_int32
modifier|*
name|cookiebuf
init|=
name|malloc
argument_list|(
name|RSA_size
argument_list|(
name|host_pkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cookiebuf
condition|)
block|{
name|rval
operator|=
name|XEVNT_CKY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|RSA_private_decrypt
argument_list|(
name|vallen
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cookiebuf
argument_list|,
name|host_pkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|,
name|RSA_PKCS1_OAEP_PADDING
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|rval
operator|=
name|XEVNT_CKY
expr_stmt|;
name|free
argument_list|(
name|cookiebuf
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|cookie
operator|=
name|ntohl
argument_list|(
operator|*
name|cookiebuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cookiebuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rval
operator|=
name|XEVNT_CKY
expr_stmt|;
break|break;
block|}
comment|/* 			 * Install cookie values and light the cookie 			 * bit. If this is not broadcast client mode, we 			 * are done here. 			 */
name|key_expire
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|hismode
operator|==
name|MODE_ACTIVE
operator|||
name|hismode
operator|==
name|MODE_PASSIVE
condition|)
name|peer
operator|->
name|pcookie
operator|=
name|peer
operator|->
name|hcookie
operator|^
name|cookie
expr_stmt|;
else|else
name|peer
operator|->
name|pcookie
operator|=
name|cookie
expr_stmt|;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_COOK
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"cook %x ts %u fs %u"
argument_list|,
name|peer
operator|->
name|pcookie
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|tstamp
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Install autokey values in broadcast client and 		 * symmetric modes. We have to do this every time the 		 * sever/peer cookie changes or a new keylist is 		 * rolled. Ordinarily, this is automatic as this message 		 * is piggybacked on the first NTP packet sent upon 		 * either of these events. Note that a broadcast client 		 * or symmetric peer can receive this response without a 		 * matching request. 		 */
case|case
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid or signature 			 * not verified with respect to the receive 			 * autokey values. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
operator|&
name|peer
operator|->
name|recval
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Discard the message if a broadcast client and 			 * the association ID does not match. This might 			 * happen if a broacast server restarts the 			 * protocol. A protocol restart will occur at 			 * the next ASSOC message. 			 */
if|if
condition|(
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
operator|)
operator|&&
name|peer
operator|->
name|assoc
operator|!=
name|associd
condition|)
break|break;
comment|/* 			 * Install autokey values and light the 			 * autokey bit. This is not hard. 			 */
if|if
condition|(
name|ep
operator|->
name|tstamp
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|peer
operator|->
name|recval
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|peer
operator|->
name|recval
operator|.
name|ptr
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|autokey
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|autokey
operator|*
operator|)
name|peer
operator|->
name|recval
operator|.
name|ptr
expr_stmt|;
name|peer
operator|->
name|recval
operator|.
name|tstamp
operator|=
name|ep
operator|->
name|tstamp
expr_stmt|;
name|peer
operator|->
name|recval
operator|.
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
name|ap
operator|=
operator|(
expr|struct
name|autokey
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
name|bp
operator|->
name|seq
operator|=
name|ntohl
argument_list|(
name|ap
operator|->
name|seq
argument_list|)
expr_stmt|;
name|bp
operator|->
name|key
operator|=
name|ntohl
argument_list|(
name|ap
operator|->
name|key
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pkeyid
operator|=
name|bp
operator|->
name|key
expr_stmt|;
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_AUTO
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"auto seq %d key %x ts %u fs %u"
argument_list|,
name|bp
operator|->
name|seq
argument_list|,
name|bp
operator|->
name|key
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|tstamp
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * X509 certificate sign response. Validate the 		 * certificate signed by the server and install. Later 		 * this can be provided to clients of this server in 		 * lieu of the self signed certificate in order to 		 * validate the public key. 		 */
case|case
name|CRYPTO_SIGN
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * Scan the certificate list to delete old 			 * versions and link the newest version first on 			 * the list. 			 */
if|if
condition|(
operator|(
name|xinfo
operator|=
name|cert_install
argument_list|(
name|ep
argument_list|,
name|peer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|XEVNT_CRT
expr_stmt|;
break|break;
block|}
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_SIGN
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
name|temp32
operator|=
name|xinfo
operator|->
name|nid
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"sign %s %s 0x%x %s (%u) fs %u"
argument_list|,
name|xinfo
operator|->
name|subject
argument_list|,
name|xinfo
operator|->
name|issuer
argument_list|,
name|xinfo
operator|->
name|flags
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|temp32
argument_list|)
argument_list|,
name|temp32
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * Install leapseconds values. While the leapsecond 		 * values epoch, TAI offset and values expiration epoch 		 * are retained, only the current TAI offset is provided 		 * via the kernel to other applications. 		 */
case|case
name|CRYPTO_LEAP
operator||
name|CRYPTO_RESP
case|:
comment|/* 			 * Discard the message if invalid. We can't 			 * compare the value timestamps here, as they 			 * can be updated by different servers. 			 */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_verify
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|,
name|peer
argument_list|)
operator|)
operator|!=
name|XEVNT_OK
condition|)
break|break;
comment|/* 			 * If the packet leap values are more recent 			 * than the stored ones, install the new leap 			 * values and recompute the signatures. 			 */
if|if
condition|(
name|leapsec_add_fix
argument_list|(
name|ntohl
argument_list|(
name|ep
operator|->
name|pkt
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|pkt
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|pkt
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|leap_signature_t
name|lsig
decl_stmt|;
name|leapsec_getsig
argument_list|(
operator|&
name|lsig
argument_list|)
expr_stmt|;
name|tai_leap
operator|.
name|tstamp
operator|=
name|ep
operator|->
name|tstamp
expr_stmt|;
name|tai_leap
operator|.
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
name|tai_leap
operator|.
name|vallen
operator|=
name|ep
operator|->
name|vallen
expr_stmt|;
name|crypto_update
argument_list|()
expr_stmt|;
name|mprintf_event
argument_list|(
name|EVNT_TAI
argument_list|,
name|peer
argument_list|,
literal|"%d leap %s expire %s"
argument_list|,
name|lsig
operator|.
name|taiof
argument_list|,
name|fstostr
argument_list|(
name|lsig
operator|.
name|ttime
argument_list|)
argument_list|,
name|fstostr
argument_list|(
name|lsig
operator|.
name|etime
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_LEAP
expr_stmt|;
name|peer
operator|->
name|flash
operator|&=
operator|~
name|TEST8
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"leap TAI offset %d at %u expire %u fs %u"
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|pkt
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|pkt
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|pkt
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * We come here in symmetric modes for miscellaneous 		 * commands that have value fields but are processed on 		 * the transmit side. All we need do here is check for 		 * valid field length. Note that ASSOC is handled 		 * separately. 		 */
case|case
name|CRYPTO_CERT
case|:
case|case
name|CRYPTO_IFF
case|:
case|case
name|CRYPTO_GQ
case|:
case|case
name|CRYPTO_MV
case|:
case|case
name|CRYPTO_COOK
case|:
case|case
name|CRYPTO_SIGN
case|:
if|if
condition|(
name|len
operator|<
name|VALUE_LEN
condition|)
block|{
name|rval
operator|=
name|XEVNT_LEN
expr_stmt|;
break|break;
block|}
comment|/* fall through */
comment|/* 		 * We come here in symmetric modes for requests 		 * requiring a response (above plus AUTO and LEAP) and 		 * for responses. If a request, save the extension field 		 * for later; invalid requests will be caught on the 		 * transmit side. If an error or invalid response, 		 * declare a protocol error. 		 */
default|default:
if|if
condition|(
name|code
operator|&
operator|(
name|CRYPTO_RESP
operator||
name|CRYPTO_ERROR
operator|)
condition|)
block|{
name|rval
operator|=
name|XEVNT_ERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|cmmd
operator|==
name|NULL
condition|)
block|{
name|fp
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fp
argument_list|,
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|peer
operator|->
name|cmmd
operator|=
name|fp
expr_stmt|;
block|}
block|}
comment|/* 		 * The first error found terminates the extension field 		 * scan and we return the laundry to the caller. 		 */
if|if
condition|(
name|rval
operator|!=
name|XEVNT_OK
condition|)
block|{
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"%04x %d %02x %s"
argument_list|,
name|htonl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
argument_list|,
name|associd
argument_list|,
name|rval
argument_list|,
name|eventstr
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_recv: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rval
operator|)
return|;
block|}
name|authlen
operator|+=
operator|(
name|len
operator|+
literal|3
operator|)
operator|/
literal|4
operator|*
literal|4
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_xmit - construct extension fields  *  * This routine is called both when an association is configured and  * when one is not. The only case where this matters is to retrieve the  * autokey information, in which case the caller has to provide the  * association ID to match the association.  *  * Side effect: update the packet offset.  *  * Errors  * XEVNT_OK	success  * XEVNT_CRT	bad or missing certificate  * XEVNT_ERR	protocol error  * XEVNT_LEN	bad field format or length  * XEVNT_PER	host certificate expired  */
end_comment

begin_function
name|int
name|crypto_xmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|struct
name|pkt
modifier|*
name|xpkt
parameter_list|,
comment|/* transmit packet pointer */
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
comment|/* receive buffer pointer */
name|int
name|start
parameter_list|,
comment|/* offset to extension field */
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|keyid_t
name|cookie
comment|/* session cookie */
parameter_list|)
block|{
name|struct
name|exten
modifier|*
name|fp
decl_stmt|;
comment|/* extension pointers */
name|struct
name|cert_info
modifier|*
name|cp
decl_stmt|,
modifier|*
name|xp
decl_stmt|,
modifier|*
name|yp
decl_stmt|;
comment|/* cert info/value pointer */
name|sockaddr_u
modifier|*
name|srcadr_sin
decl_stmt|;
comment|/* source address */
name|u_int32
modifier|*
name|pkt
decl_stmt|;
comment|/* packet pointer */
name|u_int
name|opcode
decl_stmt|;
comment|/* extension field opcode */
name|char
name|certname
index|[
name|MAXHOSTNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* subject name buffer */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|tstamp_t
name|tstamp
decl_stmt|;
name|struct
name|calendar
name|tscal
decl_stmt|;
name|u_int
name|vallen
decl_stmt|;
name|struct
name|value
name|vtemp
decl_stmt|;
name|associd_t
name|associd
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|int
name|len
decl_stmt|;
name|keyid_t
name|tcookie
decl_stmt|;
comment|/* 	 * Generate the requested extension field request code, length 	 * and association ID. If this is a response and the host is not 	 * synchronized, light the error bit and go home. 	 */
name|pkt
operator|=
operator|(
name|u_int32
operator|*
operator|)
name|xpkt
operator|+
name|start
operator|/
literal|4
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|exten
operator|*
operator|)
name|pkt
expr_stmt|;
name|opcode
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
block|{
name|srcadr_sin
operator|=
operator|&
name|peer
operator|->
name|srcadr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opcode
operator|&
name|CRYPTO_RESP
operator|)
condition|)
name|peer
operator|->
name|opcode
operator|=
name|ep
operator|->
name|opcode
expr_stmt|;
block|}
else|else
block|{
name|srcadr_sin
operator|=
operator|&
name|rbufp
operator|->
name|recv_srcadr
expr_stmt|;
block|}
name|associd
operator|=
operator|(
name|associd_t
operator|)
name|ntohl
argument_list|(
name|ep
operator|->
name|associd
argument_list|)
expr_stmt|;
name|len
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|opcode
operator|=
name|htonl
argument_list|(
operator|(
name|opcode
operator|&
literal|0xffff0000
operator|)
operator||
name|len
argument_list|)
expr_stmt|;
name|fp
operator|->
name|associd
operator|=
name|ep
operator|->
name|associd
expr_stmt|;
name|rval
operator|=
name|XEVNT_OK
expr_stmt|;
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|opcode
operator|&
literal|0xffff0000
condition|)
block|{
comment|/* 	 * Send association request and response with status word and 	 * host name. Note, this message is not signed and the filestamp 	 * contains only the status word. 	 */
case|case
name|CRYPTO_ASSOC
case|:
case|case
name|CRYPTO_ASSOC
operator||
name|CRYPTO_RESP
case|:
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|hostval
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|crypto_flags
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send certificate request. Use the values from the extension 	 * field. 	 */
case|case
name|CRYPTO_CERT
case|:
name|memset
argument_list|(
operator|&
name|vtemp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vtemp
argument_list|)
argument_list|)
expr_stmt|;
name|vtemp
operator|.
name|tstamp
operator|=
name|ep
operator|->
name|tstamp
expr_stmt|;
name|vtemp
operator|.
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
name|vtemp
operator|.
name|vallen
operator|=
name|ep
operator|->
name|vallen
expr_stmt|;
name|vtemp
operator|.
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send sign request. Use the host certificate, which is self- 	 * signed and may or may not be trusted. 	 */
case|case
name|CRYPTO_SIGN
case|:
operator|(
name|void
operator|)
name|ntpcal_ntp_to_date
argument_list|(
operator|&
name|tscal
argument_list|,
name|tstamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|calcomp
argument_list|(
operator|&
name|tscal
argument_list|,
operator|&
operator|(
name|cert_host
operator|->
name|first
operator|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|calcomp
argument_list|(
operator|&
name|tscal
argument_list|,
operator|&
operator|(
name|cert_host
operator|->
name|last
operator|)
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|rval
operator|=
name|XEVNT_PER
expr_stmt|;
else|else
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|cert_host
operator|->
name|cert
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send certificate response. Use the name in the extension 	 * field to find the certificate in the cache. If the request 	 * contains no subject name, assume the name of this host. This 	 * is for backwards compatibility. Private certificates are 	 * never sent. 	 * 	 * There may be several certificates matching the request. First 	 * choice is a self-signed trusted certificate; second choice is 	 * any certificate signed by another host. There is no third 	 * choice.  	 */
case|case
name|CRYPTO_CERT
operator||
name|CRYPTO_RESP
case|:
name|vallen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
comment|/* Must be<64k */
if|if
condition|(
name|vallen
operator|==
literal|0
operator|||
name|vallen
operator|>
name|MAXHOSTNAME
operator|||
name|len
operator|-
name|VALUE_LEN
operator|<
name|vallen
condition|)
block|{
name|rval
operator|=
name|XEVNT_LEN
expr_stmt|;
break|break;
block|}
comment|/* 		 * Find all public valid certificates with matching 		 * subject. If a self-signed, trusted certificate is 		 * found, use that certificate. If not, use the last non 		 * self-signed certificate. 		 */
name|memcpy
argument_list|(
name|certname
argument_list|,
name|ep
operator|->
name|pkt
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|certname
index|[
name|vallen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xp
operator|=
name|yp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cinfo
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|cp
operator|->
name|link
control|)
block|{
if|if
condition|(
name|cp
operator|->
name|flags
operator|&
operator|(
name|CERT_PRIV
operator||
name|CERT_ERROR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|certname
argument_list|,
name|cp
operator|->
name|subject
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|certname
argument_list|,
name|cp
operator|->
name|issuer
argument_list|)
operator|!=
literal|0
condition|)
name|yp
operator|=
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|flags
operator|&
name|CERT_TRUST
condition|)
name|xp
operator|=
name|cp
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Be careful who you trust. If the certificate is not 		 * found, return an empty response. Note that we dont 		 * enforce lifetimes here. 		 * 		 * The timestamp and filestamp are taken from the 		 * certificate value structure. For all certificates the 		 * timestamp is the latest signature update time. For 		 * host and imported certificates the filestamp is the 		 * creation epoch. For signed certificates the filestamp 		 * is the creation epoch of the trusted certificate at 		 * the root of the certificate trail. In principle, this 		 * allows strong checking for signature masquerade. 		 */
if|if
condition|(
name|xp
operator|==
name|NULL
condition|)
name|xp
operator|=
name|yp
expr_stmt|;
if|if
condition|(
name|xp
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|xp
operator|->
name|cert
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send challenge in Schnorr (IFF) identity scheme. 	 */
case|case
name|CRYPTO_IFF
case|:
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
break|break;
comment|/* hack attack */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_alice
argument_list|(
name|peer
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
block|{
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Send response in Schnorr (IFF) identity scheme. 	 */
case|case
name|CRYPTO_IFF
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_bob
argument_list|(
name|ep
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
block|{
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Send challenge in Guillou-Quisquater (GQ) identity scheme. 	 */
case|case
name|CRYPTO_GQ
case|:
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
break|break;
comment|/* hack attack */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_alice2
argument_list|(
name|peer
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
block|{
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Send response in Guillou-Quisquater (GQ) identity scheme. 	 */
case|case
name|CRYPTO_GQ
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_bob2
argument_list|(
name|ep
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
block|{
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Send challenge in MV identity scheme. 	 */
case|case
name|CRYPTO_MV
case|:
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
break|break;
comment|/* hack attack */
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_alice3
argument_list|(
name|peer
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
block|{
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Send response in MV identity scheme. 	 */
case|case
name|CRYPTO_MV
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_bob3
argument_list|(
name|ep
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
block|{
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Send certificate sign response. The integrity of the request 	 * certificate has already been verified on the receive side. 	 * Sign the response using the local server key. Use the 	 * filestamp from the request and use the timestamp as the 	 * current time. Light the error bit if the certificate is 	 * invalid or contains an unverified signature. 	 */
case|case
name|CRYPTO_SIGN
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
operator|(
name|rval
operator|=
name|cert_sign
argument_list|(
name|ep
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
block|{
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Send public key and signature. Use the values from the public 	 * key. 	 */
case|case
name|CRYPTO_COOK
case|:
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|pubkey
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Encrypt and send cookie and signature. Light the error bit if 	 * anything goes wrong. 	 */
case|case
name|CRYPTO_COOK
operator||
name|CRYPTO_RESP
case|:
name|vallen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
comment|/* Must be<64k */
if|if
condition|(
name|vallen
operator|==
literal|0
operator|||
operator|(
name|vallen
operator|>=
name|MAX_VALLEN
operator|)
operator|||
operator|(
name|opcode
operator|&
literal|0x0000ffff
operator|)
operator|<
name|VALUE_LEN
operator|+
name|vallen
condition|)
block|{
name|rval
operator|=
name|XEVNT_LEN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
name|tcookie
operator|=
name|cookie
expr_stmt|;
else|else
name|tcookie
operator|=
name|peer
operator|->
name|hcookie
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|crypto_encrypt
argument_list|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
name|vallen
argument_list|,
operator|&
name|tcookie
argument_list|,
operator|&
name|vtemp
argument_list|)
operator|)
operator|==
name|XEVNT_OK
condition|)
block|{
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|vtemp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|vtemp
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Find peer and send autokey data and signature in broadcast 	 * server and symmetric modes. Use the values in the autokey 	 * structure. If no association is found, either the server has 	 * restarted with new associations or some perp has replayed an 	 * old message, in which case light the error bit. 	 */
case|case
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
case|:
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
name|associd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|XEVNT_ERR
expr_stmt|;
break|break;
block|}
block|}
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_ASSOC
expr_stmt|;
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|peer
operator|->
name|sndval
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Send leapseconds values and signature. Use the values from 	 * the tai structure. If no table has been loaded, just send an 	 * empty request. 	 */
case|case
name|CRYPTO_LEAP
operator||
name|CRYPTO_RESP
case|:
name|len
operator|=
name|crypto_send
argument_list|(
name|fp
argument_list|,
operator|&
name|tai_leap
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Default - Send a valid command for unknown requests; send 	 * an error response for unknown resonses. 	 */
default|default:
if|if
condition|(
name|opcode
operator|&
name|CRYPTO_RESP
condition|)
name|rval
operator|=
name|XEVNT_ERR
expr_stmt|;
block|}
comment|/* 	 * In case of error, flame the log. If a request, toss the 	 * puppy; if a response, return so the sender can flame, too. 	 */
if|if
condition|(
name|rval
operator|!=
name|XEVNT_OK
condition|)
block|{
name|u_int32
name|uint32
decl_stmt|;
name|uint32
operator|=
name|CRYPTO_ERROR
expr_stmt|;
name|opcode
operator||=
name|uint32
expr_stmt|;
name|fp
operator|->
name|opcode
operator||=
name|htonl
argument_list|(
name|uint32
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"%04x %d %02x %s"
argument_list|,
name|opcode
argument_list|,
name|associd
argument_list|,
name|rval
argument_list|,
name|eventstr
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
name|srcadr_sin
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_xmit: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|opcode
operator|&
name|CRYPTO_RESP
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_xmit: flags 0x%x offset %d len %d code 0x%x associd %d\n"
argument_list|,
name|crypto_flags
argument_list|,
name|start
argument_list|,
name|len
argument_list|,
name|opcode
operator|>>
literal|16
argument_list|,
name|associd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_verify - verify the extension field value and signature  *  * Returns  * XEVNT_OK	success  * XEVNT_ERR	protocol error  * XEVNT_FSP	bad filestamp  * XEVNT_LEN	bad field format or length  * XEVNT_PUB	bad or missing public key  * XEVNT_SGL	bad signature length  * XEVNT_SIG	signature not verified  * XEVNT_TSP	bad timestamp  */
end_comment

begin_function
specifier|static
name|int
name|crypto_verify
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|value
modifier|*
name|vp
parameter_list|,
comment|/* value pointer */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* server public key */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|,
name|tstamp1
init|=
literal|0
decl_stmt|;
comment|/* timestamp */
name|tstamp_t
name|fstamp
decl_stmt|,
name|fstamp1
init|=
literal|0
decl_stmt|;
comment|/* filestamp */
name|u_int
name|vallen
decl_stmt|;
comment|/* value length */
name|u_int
name|siglen
decl_stmt|;
comment|/* signature length */
name|u_int
name|opcode
decl_stmt|,
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * We are extremely parannoyed. We require valid opcode, length, 	 * association ID, timestamp, filestamp, public key, digest, 	 * signature length and signature, where relevant. Note that 	 * preliminary length checks are done in the main loop. 	 */
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|opcode
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
operator|&
literal|0xffff0000
expr_stmt|;
comment|/* 	 * Check for valid value header, association ID and extension 	 * field length. Remember, it is not an error to receive an 	 * unsolicited response; however, the response ID must match 	 * the association ID. 	 */
if|if
condition|(
name|opcode
operator|&
name|CRYPTO_ERROR
condition|)
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
if|if
condition|(
name|len
operator|<
name|VALUE_LEN
condition|)
return|return
operator|(
name|XEVNT_LEN
operator|)
return|;
if|if
condition|(
name|opcode
operator|==
operator|(
name|CRYPTO_AUTO
operator||
name|CRYPTO_RESP
operator|)
operator|&&
operator|(
name|peer
operator|->
name|pmode
operator|==
name|MODE_BROADCAST
operator|||
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_BCLNT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|ep
operator|->
name|associd
argument_list|)
operator|!=
name|peer
operator|->
name|assoc
condition|)
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|ep
operator|->
name|associd
argument_list|)
operator|!=
name|peer
operator|->
name|associd
condition|)
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
comment|/* 	 * We have a valid value header. Check for valid value and 	 * signature field lengths. The extension field length must be 	 * long enough to contain the value header, value and signature. 	 * Note both the value and signature field lengths are rounded 	 * up to the next word (4 octets). 	 */
name|vallen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|vallen
operator|==
literal|0
operator|||
name|vallen
operator|>
name|MAX_VALLEN
condition|)
return|return
operator|(
name|XEVNT_LEN
operator|)
return|;
name|i
operator|=
operator|(
name|vallen
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|siglen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|pkt
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|siglen
operator|>
name|MAX_VALLEN
operator|||
name|len
operator|-
name|VALUE_LEN
operator|<
operator|(
operator|(
name|vallen
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
operator|||
name|len
operator|-
name|VALUE_LEN
operator|-
operator|(
operator|(
name|vallen
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
operator|<
operator|(
operator|(
name|siglen
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
condition|)
return|return
operator|(
name|XEVNT_LEN
operator|)
return|;
comment|/* 	 * Check for valid timestamp and filestamp. If the timestamp is 	 * zero, the sender is not synchronized and signatures are 	 * not possible. If nonzero the timestamp must not precede the 	 * filestamp. The timestamp and filestamp must not precede the 	 * corresponding values in the value structure, if present.  	 */
name|tstamp
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|tstamp
argument_list|)
expr_stmt|;
name|fstamp
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_TSP
operator|)
return|;
if|if
condition|(
name|tstamp
operator|<
name|fstamp
condition|)
return|return
operator|(
name|XEVNT_TSP
operator|)
return|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|tstamp1
operator|=
name|ntohl
argument_list|(
name|vp
operator|->
name|tstamp
argument_list|)
expr_stmt|;
name|fstamp1
operator|=
name|ntohl
argument_list|(
name|vp
operator|->
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstamp1
operator|!=
literal|0
operator|&&
name|fstamp1
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tstamp
operator|<
name|tstamp1
condition|)
return|return
operator|(
name|XEVNT_TSP
operator|)
return|;
if|if
condition|(
operator|(
name|tstamp
operator|<
name|fstamp1
operator|||
name|fstamp
operator|<
name|fstamp1
operator|)
condition|)
return|return
operator|(
name|XEVNT_FSP
operator|)
return|;
block|}
block|}
comment|/* 	 * At the time the certificate message is validated, the public 	 * key in the message is not available. Thus, don't try to 	 * verify the signature. 	 */
if|if
condition|(
name|opcode
operator|==
operator|(
name|CRYPTO_CERT
operator||
name|CRYPTO_RESP
operator|)
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
comment|/* 	 * Check for valid signature length, public key and digest 	 * algorithm. 	 */
if|if
condition|(
name|crypto_flags
operator|&
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_PRIV
condition|)
name|pkey
operator|=
name|sign_pkey
expr_stmt|;
else|else
name|pkey
operator|=
name|peer
operator|->
name|pkey
expr_stmt|;
if|if
condition|(
name|siglen
operator|==
literal|0
operator|||
name|pkey
operator|==
name|NULL
operator|||
name|peer
operator|->
name|digest
operator|==
name|NULL
condition|)
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
if|if
condition|(
name|siglen
operator|!=
operator|(
name|u_int
operator|)
name|EVP_PKEY_size
argument_list|(
name|pkey
argument_list|)
condition|)
return|return
operator|(
name|XEVNT_SGL
operator|)
return|;
comment|/* 	 * Darn, I thought we would never get here. Verify the 	 * signature. If the identity exchange is verified, light the 	 * proventic bit. What a relief. 	 */
name|EVP_VerifyInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|peer
operator|->
name|digest
argument_list|)
expr_stmt|;
comment|/* XXX: the "+ 12" needs to be at least documented... */
name|EVP_VerifyUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ep
operator|->
name|tstamp
argument_list|,
name|vallen
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_VerifyFinal
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ep
operator|->
name|pkt
index|[
name|i
index|]
argument_list|,
name|siglen
argument_list|,
name|pkey
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|XEVNT_SIG
operator|)
return|;
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_VRFY
condition|)
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_PROV
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_encrypt - construct vp (encrypted cookie and signature) from  * the public key and cookie.  *  * Returns:  * XEVNT_OK	success  * XEVNT_CKY	bad or missing cookie  * XEVNT_PUB	bad or missing public key  */
end_comment

begin_function
specifier|static
name|int
name|crypto_encrypt
parameter_list|(
specifier|const
name|u_char
modifier|*
name|ptr
parameter_list|,
comment|/* Public Key */
name|u_int
name|vallen
parameter_list|,
comment|/* Length of Public Key */
name|keyid_t
modifier|*
name|cookie
parameter_list|,
comment|/* server cookie */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* public key */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|u_int32
name|temp32
decl_stmt|;
name|u_char
modifier|*
name|puch
decl_stmt|;
comment|/* 	 * Extract the public key from the request. 	 */
name|pkey
operator|=
name|d2i_PublicKey
argument_list|(
name|EVP_PKEY_RSA
argument_list|,
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_encrypt: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Encrypt the cookie, encode in ASN.1 and sign. 	 */
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|vallen
operator|=
name|EVP_PKEY_size
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|vallen
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
name|vallen
argument_list|)
expr_stmt|;
name|puch
operator|=
name|vp
operator|->
name|ptr
expr_stmt|;
name|temp32
operator|=
name|htonl
argument_list|(
operator|*
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|RSA_public_encrypt
argument_list|(
literal|4
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|temp32
argument_list|,
name|puch
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|,
name|RSA_PKCS1_OAEP_PADDING
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_encrypt: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_CKY
operator|)
return|;
block|}
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|vallen
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_ident - construct extension field for identity scheme  *  * This routine determines which identity scheme is in use and  * constructs an extension field for that scheme.  *  * Returns  * CRYTPO_IFF	IFF scheme  * CRYPTO_GQ	GQ scheme  * CRYPTO_MV	MV scheme  * CRYPTO_NULL	no available scheme  */
end_comment

begin_function
name|u_int
name|crypto_ident
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|char
name|filename
index|[
name|MAXFILENAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|scheme_name
decl_stmt|;
name|u_int
name|scheme_id
decl_stmt|;
comment|/* 	 * We come here after the group trusted host has been found; its 	 * name defines the group name. Search the key cache for all 	 * keys matching the same group name in order IFF, GQ and MV. 	 * Use the first one available. 	 */
name|scheme_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_IFF
condition|)
block|{
name|scheme_name
operator|=
literal|"iff"
expr_stmt|;
name|scheme_id
operator|=
name|CRYPTO_IFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_GQ
condition|)
block|{
name|scheme_name
operator|=
literal|"gq"
expr_stmt|;
name|scheme_id
operator|=
name|CRYPTO_GQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_MV
condition|)
block|{
name|scheme_name
operator|=
literal|"mv"
expr_stmt|;
name|scheme_id
operator|=
name|CRYPTO_MV
expr_stmt|;
block|}
if|if
condition|(
name|scheme_name
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_%spar_%s"
argument_list|,
name|scheme_name
argument_list|,
name|peer
operator|->
name|ident
argument_list|)
expr_stmt|;
name|peer
operator|->
name|ident_pkey
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
name|NULL
argument_list|,
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|!=
name|NULL
condition|)
return|return
name|scheme_id
return|;
block|}
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_ident: no identity parameters found for group %s"
argument_list|,
name|peer
operator|->
name|ident
argument_list|)
expr_stmt|;
return|return
name|CRYPTO_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_args - construct extension field from arguments  *  * This routine creates an extension field with current timestamps and  * specified opcode, association ID and optional string. Note that the  * extension field is created here, but freed after the crypto_xmit()  * call in the protocol module.  *  * Returns extension field pointer (no errors)  *  * XXX: opcode and len should really be 32-bit quantities and  * we should make sure that str is not too big.  */
end_comment

begin_function
name|struct
name|exten
modifier|*
name|crypto_args
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|u_int
name|opcode
parameter_list|,
comment|/* operation code */
name|associd_t
name|associd
parameter_list|,
comment|/* association ID */
name|char
modifier|*
name|str
comment|/* argument string */
parameter_list|)
block|{
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|struct
name|exten
modifier|*
name|ep
decl_stmt|;
comment|/* extension field pointer */
name|u_int
name|len
decl_stmt|;
comment|/* extension field length */
name|size_t
name|slen
decl_stmt|;
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|exten
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|slen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|slen
operator|<
name|MAX_VALLEN
argument_list|)
expr_stmt|;
name|len
operator|+=
name|slen
expr_stmt|;
block|}
name|ep
operator|=
name|emalloc_zero
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
return|return
operator|(
name|ep
operator|)
return|;
name|REQUIRE
argument_list|(
literal|0
operator|==
operator|(
name|len
operator|&
operator|~
literal|0x0000ffff
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
literal|0
operator|==
operator|(
name|opcode
operator|&
operator|~
literal|0xffff0000
operator|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|opcode
operator|=
name|htonl
argument_list|(
name|opcode
operator|+
name|len
argument_list|)
expr_stmt|;
name|ep
operator|->
name|associd
operator|=
name|htonl
argument_list|(
name|associd
argument_list|)
expr_stmt|;
name|ep
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|ep
operator|->
name|fstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|ep
operator|->
name|vallen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|ep
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|slen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
name|str
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_send - construct extension field from value components  *  * The value and signature fields are zero-padded to a word boundary.  * Note: it is not polite to send a nonempty signature with zero  * timestamp or a nonzero timestamp with an empty signature, but those  * rules are not enforced here.  *  * XXX This code won't work on a box with 16-bit ints.  */
end_comment

begin_function
name|int
name|crypto_send
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension field pointer */
name|struct
name|value
modifier|*
name|vp
parameter_list|,
comment|/* value pointer */
name|int
name|start
comment|/* buffer offset */
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|,
name|vallen
decl_stmt|,
name|siglen
decl_stmt|,
name|opcode
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Calculate extension field length and check for buffer 	 * overflow. Leave room for the MAC. 	 */
name|len
operator|=
literal|16
expr_stmt|;
comment|/* XXX Document! */
name|vallen
operator|=
name|ntohl
argument_list|(
name|vp
operator|->
name|vallen
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|vallen
operator|<=
name|MAX_VALLEN
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
operator|(
name|vallen
operator|+
literal|3
operator|)
operator|/
literal|4
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
name|siglen
operator|=
name|ntohl
argument_list|(
name|vp
operator|->
name|siglen
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
operator|(
name|siglen
operator|+
literal|3
operator|)
operator|/
literal|4
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|start
operator|+
name|len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|pkt
argument_list|)
operator|-
name|MAX_MAC_LEN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Copy timestamps. 	 */
name|ep
operator|->
name|tstamp
operator|=
name|vp
operator|->
name|tstamp
expr_stmt|;
name|ep
operator|->
name|fstamp
operator|=
name|vp
operator|->
name|fstamp
expr_stmt|;
name|ep
operator|->
name|vallen
operator|=
name|vp
operator|->
name|vallen
expr_stmt|;
comment|/* 	 * Copy value. If the data field is empty or zero length, 	 * encode an empty value with length zero. 	 */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vallen
operator|>
literal|0
operator|&&
name|vp
operator|->
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|j
operator|=
name|vallen
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|j
operator|*
literal|4
operator|<
name|vallen
condition|)
name|ep
operator|->
name|pkt
index|[
name|i
operator|+
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ep
operator|->
name|pkt
index|[
name|i
index|]
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
block|}
comment|/* 	 * Copy signature. If the signature field is empty or zero 	 * length, encode an empty signature with length zero. 	 */
name|ep
operator|->
name|pkt
index|[
name|i
operator|++
index|]
operator|=
name|vp
operator|->
name|siglen
expr_stmt|;
if|if
condition|(
name|siglen
operator|>
literal|0
operator|&&
name|vp
operator|->
name|sig
operator|!=
name|NULL
condition|)
block|{
name|j
operator|=
name|siglen
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|j
operator|*
literal|4
operator|<
name|siglen
condition|)
name|ep
operator|->
name|pkt
index|[
name|i
operator|+
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ep
operator|->
name|pkt
index|[
name|i
index|]
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
block|}
name|opcode
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|ep
operator|->
name|opcode
operator|=
name|htonl
argument_list|(
operator|(
name|opcode
operator|&
literal|0xffff0000
operator|)
operator||
name|len
argument_list|)
expr_stmt|;
name|ENSURE
argument_list|(
name|len
operator|<=
name|MAX_VALLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_update - compute new public value and sign extension fields  *  * This routine runs periodically, like once a day, and when something  * changes. It updates the timestamps on three value structures and one  * value structure list, then signs all the structures:  *  * hostval	host name (not signed)  * pubkey	public key  * cinfo	certificate info/value list  * tai_leap	leap values  *  * Filestamps are proventic data, so this routine runs only when the  * host is synchronized to a proventicated source. Thus, the timestamp  * is proventic and can be used to deflect clogging attacks.  *  * Returns void (no errors)  */
end_comment

begin_function
name|void
name|crypto_update
parameter_list|(
name|void
parameter_list|)
block|{
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* message digest context */
name|struct
name|cert_info
modifier|*
name|cp
decl_stmt|;
comment|/* certificate info/value */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|u_int32
modifier|*
name|ptr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|leap_signature_t
name|lsig
decl_stmt|;
name|hostval
operator|.
name|tstamp
operator|=
name|htonl
argument_list|(
name|crypto_time
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostval
operator|.
name|tstamp
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Sign public key and timestamps. The filestamp is derived from 	 * the host key file extension from wherever the file was 	 * generated.  	 */
if|if
condition|(
name|pubkey
operator|.
name|vallen
operator|!=
literal|0
condition|)
block|{
name|pubkey
operator|.
name|tstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|pubkey
operator|.
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pubkey
operator|.
name|sig
operator|==
name|NULL
condition|)
name|pubkey
operator|.
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pubkey
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|pubkey
operator|.
name|ptr
argument_list|,
name|ntohl
argument_list|(
name|pubkey
operator|.
name|vallen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|pubkey
operator|.
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|pubkey
operator|.
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Sign certificates and timestamps. The filestamp is derived 	 * from the certificate file extension from wherever the file 	 * was generated. Note we do not throw expired certificates 	 * away; they may have signed younger ones. 	 */
for|for
control|(
name|cp
operator|=
name|cinfo
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|cp
operator|->
name|link
control|)
block|{
name|cp
operator|->
name|cert
operator|.
name|tstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|cp
operator|->
name|cert
operator|.
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|cert
operator|.
name|sig
operator|==
name|NULL
condition|)
name|cp
operator|->
name|cert
operator|.
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|cp
operator|->
name|cert
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|cp
operator|->
name|cert
operator|.
name|ptr
argument_list|,
name|ntohl
argument_list|(
name|cp
operator|->
name|cert
operator|.
name|vallen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|cp
operator|->
name|cert
operator|.
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|cp
operator|->
name|cert
operator|.
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Sign leapseconds values and timestamps. Note it is not an 	 * error to return null values. 	 */
name|tai_leap
operator|.
name|tstamp
operator|=
name|hostval
operator|.
name|tstamp
expr_stmt|;
name|tai_leap
operator|.
name|fstamp
operator|=
name|hostval
operator|.
name|fstamp
expr_stmt|;
name|len
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
expr_stmt|;
if|if
condition|(
name|tai_leap
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|tai_leap
operator|.
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|tai_leap
operator|.
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_int32
operator|*
operator|)
name|tai_leap
operator|.
name|ptr
expr_stmt|;
name|leapsec_getsig
argument_list|(
operator|&
name|lsig
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|lsig
operator|.
name|taiof
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|lsig
operator|.
name|ttime
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
name|lsig
operator|.
name|etime
argument_list|)
expr_stmt|;
if|if
condition|(
name|tai_leap
operator|.
name|sig
operator|==
name|NULL
condition|)
name|tai_leap
operator|.
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tai_leap
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|tai_leap
operator|.
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|tai_leap
operator|.
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|tai_leap
operator|.
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsig
operator|.
name|ttime
operator|>
literal|0
condition|)
name|crypto_flags
operator||=
name|CRYPTO_FLAG_TAI
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"signature update ts %u"
argument_list|,
name|ntohl
argument_list|(
name|hostval
operator|.
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
name|NULL
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_update: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * value_free - free value structure components.  *  * Returns void (no errors)  */
end_comment

begin_function
name|void
name|value_free
parameter_list|(
name|struct
name|value
modifier|*
name|vp
comment|/* value structure */
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|->
name|ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|sig
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vp
operator|->
name|sig
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * crypto_time - returns current NTP time.  *  * Returns NTP seconds if in synch, 0 otherwise  */
end_comment

begin_function
name|tstamp_t
name|crypto_time
parameter_list|()
block|{
name|l_fp
name|tstamp
decl_stmt|;
comment|/* NTP time */
name|L_CLR
argument_list|(
operator|&
name|tstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
name|get_systime
argument_list|(
operator|&
name|tstamp
argument_list|)
expr_stmt|;
return|return
operator|(
name|tstamp
operator|.
name|l_ui
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * asn_to_calendar - convert ASN1_TIME time structure to struct calendar.  *  */
end_comment

begin_function
specifier|static
name|void
name|asn_to_calendar
parameter_list|(
name|ASN1_TIME
modifier|*
name|asn1time
parameter_list|,
comment|/* pointer to ASN1_TIME structure */
name|struct
name|calendar
modifier|*
name|pjd
comment|/* pointer to result */
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
comment|/* length of ASN1_TIME string */
name|char
name|v
index|[
literal|24
index|]
decl_stmt|;
comment|/* writable copy of ASN1_TIME string */
name|unsigned
name|long
name|temp
decl_stmt|;
comment|/* result from strtoul */
comment|/* 	 * Extract time string YYMMDDHHMMSSZ from ASN1 time structure. 	 * Or YYYYMMDDHHMMSSZ. 	 * Note that the YY, MM, DD fields start with one, the HH, MM, 	 * SS fields start with zero and the Z character is ignored. 	 * Also note that two-digit years less than 50 map to years greater than 	 * 100. Dontcha love ASN.1? Better than MIL-188. 	 */
name|len
operator|=
name|asn1time
operator|->
name|length
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|asn1time
operator|->
name|data
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|len
operator|>=
literal|13
argument_list|)
expr_stmt|;
name|temp
operator|=
name|strtoul
argument_list|(
name|v
operator|+
name|len
operator|-
literal|3
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|pjd
operator|->
name|second
operator|=
name|temp
expr_stmt|;
name|v
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|strtoul
argument_list|(
name|v
operator|+
name|len
operator|-
literal|5
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|pjd
operator|->
name|minute
operator|=
name|temp
expr_stmt|;
name|v
index|[
name|len
operator|-
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|strtoul
argument_list|(
name|v
operator|+
name|len
operator|-
literal|7
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|pjd
operator|->
name|hour
operator|=
name|temp
expr_stmt|;
name|v
index|[
name|len
operator|-
literal|7
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|strtoul
argument_list|(
name|v
operator|+
name|len
operator|-
literal|9
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|pjd
operator|->
name|monthday
operator|=
name|temp
expr_stmt|;
name|v
index|[
name|len
operator|-
literal|9
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|strtoul
argument_list|(
name|v
operator|+
name|len
operator|-
literal|11
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|pjd
operator|->
name|month
operator|=
name|temp
expr_stmt|;
name|v
index|[
name|len
operator|-
literal|11
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|strtoul
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* handle two-digit years */
if|if
condition|(
name|temp
operator|<
literal|50UL
condition|)
name|temp
operator|+=
literal|100UL
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|150UL
condition|)
name|temp
operator|+=
literal|1900UL
expr_stmt|;
name|pjd
operator|->
name|year
operator|=
name|temp
expr_stmt|;
name|pjd
operator|->
name|yearday
operator|=
name|pjd
operator|->
name|weekday
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * bigdig() - compute a BIGNUM MD5 hash of a BIGNUM number.  *  * Returns void (no errors)  */
end_comment

begin_function
specifier|static
name|void
name|bighash
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|,
comment|/* BIGNUM * from */
name|BIGNUM
modifier|*
name|bk
comment|/* BIGNUM * to */
parameter_list|)
block|{
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* message digest context */
name|u_char
name|dgst
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
comment|/* message digest */
name|u_char
modifier|*
name|ptr
decl_stmt|;
comment|/* a BIGNUM as binary string */
name|u_int
name|len
decl_stmt|;
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|bn
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|EVP_DigestInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|EVP_md5
argument_list|()
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|dgst
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|BN_bin2bn
argument_list|(
name|dgst
argument_list|,
name|len
argument_list|,
name|bk
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines implement the Schnorr (IFF) identity scheme  *  *								       *  ***********************************************************************  *  * The Schnorr (IFF) identity scheme is intended for use when  * certificates are generated by some other trusted certificate  * authority and the certificate cannot be used to convey public  * parameters. There are two kinds of files: encrypted server files that  * contain private and public values and nonencrypted client files that  * contain only public values. New generations of server files must be  * securely transmitted to all servers of the group; client files can be  * distributed by any means. The scheme is self contained and  * independent of new generations of host keys, sign keys and  * certificates.  *  * The IFF values hide in a DSA cuckoo structure which uses the same  * parameters. The values are used by an identity scheme based on DSA  * cryptography and described in Stimson p. 285. The p is a 512-bit  * prime, g a generator of Zp* and q a 160-bit prime that divides p - 1  * and is a qth root of 1 mod p; that is, g^q = 1 mod p. The TA rolls a  * private random group key b (0< b< q) and public key v = g^b, then  * sends (p, q, g, b) to the servers and (p, q, g, v) to the clients.  * Alice challenges Bob to confirm identity using the protocol described  * below.  *  * How it works  *  * The scheme goes like this. Both Alice and Bob have the public primes  * p, q and generator g. The TA gives private key b to Bob and public  * key v to Alice.  *  * Alice rolls new random challenge r (o< r< q) and sends to Bob in  * the IFF request message. Bob rolls new random k (0< k< q), then  * computes y = k + b r mod q and x = g^k mod p and sends (y, hash(x))  * to Alice in the response message. Besides making the response  * shorter, the hash makes it effectivey impossible for an intruder to  * solve for b by observing a number of these messages.  *   * Alice receives the response and computes g^y v^r mod p. After a bit  * of algebra, this simplifies to g^k. If the hash of this result  * matches hash(x), Alice knows that Bob has the group key b. The signed  * response binds this knowledge to Bob's private key and the public key  * previously received in his certificate.  *  * crypto_alice - construct Alice's challenge in IFF scheme  *  * Returns  * XEVNT_OK	success  * XEVNT_ID	bad or missing group key  * XEVNT_PUB	bad or missing public key  */
end_comment

begin_function
specifier|static
name|int
name|crypto_alice
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* IFF parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * The identity parameters must have correct format and content. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_alice: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|->
name|pkey
operator|.
name|dsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_alice: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Roll new random r (0< r< q). 	 */
if|if
condition|(
name|peer
operator|->
name|iffval
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BN_rand
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|len
operator|*
literal|8
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* r mod q*/
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|BN_mod
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
comment|/* 	 * Sign and send to Bob. The filestamp is from the local file. 	 */
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|ident_pkey
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_bob - construct Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_ERR	protocol error  * XEVNT_ID	bad or missing group key  */
end_comment

begin_function
specifier|static
name|int
name|crypto_bob
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* IFF parameters */
name|DSA_SIG
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA signature context fake */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|BIGNUM
modifier|*
name|bn
decl_stmt|,
modifier|*
name|bk
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* extension field length */
name|u_int
name|vallen
init|=
literal|0
decl_stmt|;
comment|/* value length */
comment|/* 	 * If the IFF parameters are not valid, something awful 	 * happened or we are being tormented. 	 */
if|if
condition|(
name|iffkey_info
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_bob: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
name|dsa
operator|=
name|iffkey_info
operator|->
name|pkey
operator|->
name|pkey
operator|.
name|dsa
expr_stmt|;
comment|/* 	 * Extract r from the challenge. 	 */
name|vallen
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
if|if
condition|(
name|vallen
operator|==
literal|0
operator|||
name|len
operator|<
name|VALUE_LEN
operator|||
name|len
operator|-
name|VALUE_LEN
operator|<
name|vallen
condition|)
return|return
name|XEVNT_LEN
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|BN_bin2bn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
name|vallen
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
comment|/* 	 * Bob rolls random k (0< k< q), computes y = k + b r mod q 	 * and x = g^k mod p, then sends (y, hash(x)) to Alice. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bk
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|=
name|DSA_SIG_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|bk
argument_list|,
name|vallen
operator|*
literal|8
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* k */
name|BN_mod_mul
argument_list|(
name|bn
argument_list|,
name|dsa
operator|->
name|priv_key
argument_list|,
name|r
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* b r mod q */
name|BN_add
argument_list|(
name|bn
argument_list|,
name|bn
argument_list|,
name|bk
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|bn
argument_list|,
name|bn
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* k + b r mod q */
name|sdsa
operator|->
name|r
operator|=
name|BN_dup
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|bk
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|bk
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* g^k mod p */
name|bighash
argument_list|(
name|bk
argument_list|,
name|bk
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|s
operator|=
name|BN_dup
argument_list|(
name|bk
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bk
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|DSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Encode the values in ASN.1 and sign. The filestamp is from 	 * the local file. 	 */
name|vallen
operator|=
name|i2d_DSA_SIG
argument_list|(
name|sdsa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vallen
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
if|if
condition|(
name|vallen
operator|>
name|MAX_VALLEN
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob: signature is too big: %d"
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_LEN
operator|)
return|;
block|}
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|iffkey_info
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|vallen
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|vallen
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|i2d_DSA_SIG
argument_list|(
name|sdsa
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
comment|/* XXX: more validation to make sure the sign fits... */
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|vallen
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_iff - verify Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_FSP	bad filestamp  * XEVNT_ID	bad or missing group key  * XEVNT_PUB	bad or missing public key  */
end_comment

begin_function
name|int
name|crypto_iff
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* IFF parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|DSA_SIG
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA parameters */
name|BIGNUM
modifier|*
name|bn
decl_stmt|,
modifier|*
name|bk
decl_stmt|;
name|u_int
name|len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|temp
decl_stmt|;
comment|/* 	 * If the IFF parameters are not valid or no challenge was sent, 	 * something awful happened or we are being tormented. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_iff: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
operator|!=
name|peer
operator|->
name|ident_pkey
operator|->
name|fstamp
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_iff: invalid filestamp %u"
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_FSP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|->
name|pkey
operator|.
name|dsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_iff: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
if|if
condition|(
name|peer
operator|->
name|iffval
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_iff: missing challenge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
comment|/* 	 * Extract the k + b r and g^k values from the response. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bk
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
if|if
condition|(
operator|(
name|sdsa
operator|=
name|d2i_DSA_SIG
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bk
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_iff: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
comment|/* 	 * Compute g^(k + b r) g^(q - b)r mod p. 	 */
name|BN_mod_exp
argument_list|(
name|bn
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|bk
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|sdsa
operator|->
name|r
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|bn
argument_list|,
name|bn
argument_list|,
name|bk
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* 	 * Verify the hash of the result matches hash(x). 	 */
name|bighash
argument_list|(
name|bn
argument_list|,
name|bn
argument_list|)
expr_stmt|;
name|temp
operator|=
name|BN_cmp
argument_list|(
name|bn
argument_list|,
name|sdsa
operator|->
name|s
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bk
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|NULL
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_iff: identity not verified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines implement the Guillou-Quisquater (GQ)        *  * identity scheme                                                     *  *								       *  ***********************************************************************  *  * The Guillou-Quisquater (GQ) identity scheme is intended for use when  * the certificate can be used to convey public parameters. The scheme  * uses a X509v3 certificate extension field do convey the public key of  * a private key known only to servers. There are two kinds of files:  * encrypted server files that contain private and public values and  * nonencrypted client files that contain only public values. New  * generations of server files must be securely transmitted to all  * servers of the group; client files can be distributed by any means.  * The scheme is self contained and independent of new generations of  * host keys and sign keys. The scheme is self contained and independent  * of new generations of host keys and sign keys.  *  * The GQ parameters hide in a RSA cuckoo structure which uses the same  * parameters. The values are used by an identity scheme based on RSA  * cryptography and described in Stimson p. 300 (with errors). The 512-  * bit public modulus is n = p q, where p and q are secret large primes.  * The TA rolls private random group key b as RSA exponent. These values  * are known to all group members.  *  * When rolling new certificates, a server recomputes the private and  * public keys. The private key u is a random roll, while the public key  * is the inverse obscured by the group key v = (u^-1)^b. These values  * replace the private and public keys normally generated by the RSA  * scheme. Alice challenges Bob to confirm identity using the protocol  * described below.  *  * How it works  *  * The scheme goes like this. Both Alice and Bob have the same modulus n  * and some random b as the group key. These values are computed and  * distributed in advance via secret means, although only the group key  * b is truly secret. Each has a private random private key u and public  * key (u^-1)^b, although not necessarily the same ones. Bob and Alice  * can regenerate the key pair from time to time without affecting  * operations. The public key is conveyed on the certificate in an  * extension field; the private key is never revealed.  *  * Alice rolls new random challenge r and sends to Bob in the GQ  * request message. Bob rolls new random k, then computes y = k u^r mod  * n and x = k^b mod n and sends (y, hash(x)) to Alice in the response  * message. Besides making the response shorter, the hash makes it  * effectivey impossible for an intruder to solve for b by observing  * a number of these messages.  *   * Alice receives the response and computes y^b v^r mod n. After a bit  * of algebra, this simplifies to k^b. If the hash of this result  * matches hash(x), Alice knows that Bob has the group key b. The signed  * response binds this knowledge to Bob's private key and the public key  * previously received in his certificate.  *  * crypto_alice2 - construct Alice's challenge in GQ scheme  *  * Returns  * XEVNT_OK	success  * XEVNT_ID	bad or missing group key  * XEVNT_PUB	bad or missing public key  */
end_comment

begin_function
specifier|static
name|int
name|crypto_alice2
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* GQ parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * The identity parameters must have correct format and content. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
if|if
condition|(
operator|(
name|rsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|->
name|pkey
operator|.
name|rsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_alice2: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Roll new random r (0< r< n). 	 */
if|if
condition|(
name|peer
operator|->
name|iffval
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
expr_stmt|;
name|BN_rand
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|len
operator|*
literal|8
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* r mod n */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|BN_mod
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
comment|/* 	 * Sign and send to Bob. The filestamp is from the local file. 	 */
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|ident_pkey
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_bob2 - construct Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_ERR	protocol error  * XEVNT_ID	bad or missing group key  */
end_comment

begin_function
specifier|static
name|int
name|crypto_bob2
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* GQ parameters */
name|DSA_SIG
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|BIGNUM
modifier|*
name|r
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|g
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|int
name|s_len
decl_stmt|;
comment|/* 	 * If the GQ parameters are not valid, something awful 	 * happened or we are being tormented. 	 */
if|if
condition|(
name|gqkey_info
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_bob2: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
name|rsa
operator|=
name|gqkey_info
operator|->
name|pkey
operator|->
name|pkey
operator|.
name|rsa
expr_stmt|;
comment|/* 	 * Extract r from the challenge. 	 */
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|BN_bin2bn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob2: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
comment|/* 	 * Bob rolls random k (0< k< n), computes y = k u^r mod n and 	 * x = k^b mod n, then sends (y, hash(x)) to Alice.  	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|k
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|g
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|y
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|=
name|DSA_SIG_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|k
argument_list|,
name|len
operator|*
literal|8
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* k */
name|BN_mod
argument_list|(
name|k
argument_list|,
name|k
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|y
argument_list|,
name|rsa
operator|->
name|p
argument_list|,
name|r
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* u^r mod n */
name|BN_mod_mul
argument_list|(
name|y
argument_list|,
name|k
argument_list|,
name|y
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* k u^r mod n */
name|sdsa
operator|->
name|r
operator|=
name|BN_dup
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|g
argument_list|,
name|k
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* k^b mod n */
name|bighash
argument_list|(
name|g
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|s
operator|=
name|BN_dup
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|RSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Encode the values in ASN.1 and sign. The filestamp is from 	 * the local file. 	 */
name|len
operator|=
name|s_len
operator|=
name|i2d_DSA_SIG
argument_list|(
name|sdsa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_len
operator|<=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob2: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|gqkey_info
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|i2d_DSA_SIG
argument_list|(
name|sdsa
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_gq - verify Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_ERR	protocol error  * XEVNT_FSP	bad filestamp  * XEVNT_ID	bad or missing group keys  * XEVNT_PUB	bad or missing public key  */
end_comment

begin_function
name|int
name|crypto_gq
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* GQ parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|DSA_SIG
modifier|*
name|sdsa
decl_stmt|;
comment|/* RSA signature context fake */
name|BIGNUM
modifier|*
name|y
decl_stmt|,
modifier|*
name|v
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|long
name|len
decl_stmt|;
name|u_int
name|temp
decl_stmt|;
comment|/* 	 * If the GQ parameters are not valid or no challenge was sent, 	 * something awful happened or we are being tormented. Note that 	 * the filestamp on the local key file can be greater than on 	 * the remote parameter file if the keys have been refreshed. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_gq: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
operator|<
name|peer
operator|->
name|ident_pkey
operator|->
name|fstamp
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_gq: invalid filestamp %u"
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_FSP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|->
name|pkey
operator|.
name|rsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_gq: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
if|if
condition|(
name|peer
operator|->
name|iffval
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_gq: missing challenge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
comment|/* 	 * Extract the y = k u^r and hash(x = k^b) values from the 	 * response. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|y
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|v
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
if|if
condition|(
operator|(
name|sdsa
operator|=
name|d2i_DSA_SIG
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_gq: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
comment|/* 	 * Compute v^r y^b mod n. 	 */
if|if
condition|(
name|peer
operator|->
name|grpkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_gq: missing group key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|peer
operator|->
name|grpkey
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* v^r mod n */
name|BN_mod_exp
argument_list|(
name|y
argument_list|,
name|sdsa
operator|->
name|r
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* y^b mod n */
name|BN_mod_mul
argument_list|(
name|y
argument_list|,
name|v
argument_list|,
name|y
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* v^r y^b mod n */
comment|/* 	 * Verify the hash of the result matches hash(x). 	 */
name|bighash
argument_list|(
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|temp
operator|=
name|BN_cmp
argument_list|(
name|y
argument_list|,
name|sdsa
operator|->
name|s
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|NULL
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_gq: identity not verified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines implement the Mu-Varadharajan (MV) identity  *  * scheme                                                              *  *								       *  ***********************************************************************  *  * The Mu-Varadharajan (MV) cryptosystem was originally intended when  * servers broadcast messages to clients, but clients never send  * messages to servers. There is one encryption key for the server and a  * separate decryption key for each client. It operated something like a  * pay-per-view satellite broadcasting system where the session key is  * encrypted by the broadcaster and the decryption keys are held in a  * tamperproof set-top box.  *  * The MV parameters and private encryption key hide in a DSA cuckoo  * structure which uses the same parameters, but generated in a  * different way. The values are used in an encryption scheme similar to  * El Gamal cryptography and a polynomial formed from the expansion of  * product terms (x - x[j]), as described in Mu, Y., and V.  * Varadharajan: Robust and Secure Broadcasting, Proc. Indocrypt 2001,  * 223-231. The paper has significant errors and serious omissions.  *  * Let q be the product of n distinct primes s1[j] (j = 1...n), where  * each s1[j] has m significant bits. Let p be a prime p = 2 * q + 1, so  * that q and each s1[j] divide p - 1 and p has M = n * m + 1  * significant bits. Let g be a generator of Zp; that is, gcd(g, p - 1)  * = 1 and g^q = 1 mod p. We do modular arithmetic over Zq and then  * project into Zp* as exponents of g. Sometimes we have to compute an  * inverse b^-1 of random b in Zq, but for that purpose we require  * gcd(b, q) = 1. We expect M to be in the 500-bit range and n  * relatively small, like 30. These are the parameters of the scheme and  * they are expensive to compute.  *  * We set up an instance of the scheme as follows. A set of random  * values x[j] mod q (j = 1...n), are generated as the zeros of a  * polynomial of order n. The product terms (x - x[j]) are expanded to  * form coefficients a[i] mod q (i = 0...n) in powers of x. These are  * used as exponents of the generator g mod p to generate the private  * encryption key A. The pair (gbar, ghat) of public server keys and the  * pairs (xbar[j], xhat[j]) (j = 1...n) of private client keys are used  * to construct the decryption keys. The devil is in the details.  *  * This routine generates a private server encryption file including the  * private encryption key E and partial decryption keys gbar and ghat.  * It then generates public client decryption files including the public  * keys xbar[j] and xhat[j] for each client j. The partial decryption  * files are used to compute the inverse of E. These values are suitably  * blinded so secrets are not revealed.  *  * The distinguishing characteristic of this scheme is the capability to  * revoke keys. Included in the calculation of E, gbar and ghat is the  * product s = prod(s1[j]) (j = 1...n) above. If the factor s1[j] is  * subsequently removed from the product and E, gbar and ghat  * recomputed, the jth client will no longer be able to compute E^-1 and  * thus unable to decrypt the messageblock.  *  * How it works  *  * The scheme goes like this. Bob has the server values (p, E, q, gbar,  * ghat) and Alice has the client values (p, xbar, xhat).  *  * Alice rolls new random nonce r mod p and sends to Bob in the MV  * request message. Bob rolls random nonce k mod q, encrypts y = r E^k  * mod p and sends (y, gbar^k, ghat^k) to Alice.  *   * Alice receives the response and computes the inverse (E^k)^-1 from  * the partial decryption keys gbar^k, ghat^k, xbar and xhat. She then  * decrypts y and verifies it matches the original r. The signed  * response binds this knowledge to Bob's private key and the public key  * previously received in his certificate.  *  * crypto_alice3 - construct Alice's challenge in MV scheme  *  * Returns  * XEVNT_OK	success  * XEVNT_ID	bad or missing group key  * XEVNT_PUB	bad or missing public key  */
end_comment

begin_function
specifier|static
name|int
name|crypto_alice3
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* MV parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * The identity parameters must have correct format and content. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
if|if
condition|(
operator|(
name|dsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|->
name|pkey
operator|.
name|dsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_alice3: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Roll new random r (0< r< q). 	 */
if|if
condition|(
name|peer
operator|->
name|iffval
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|BN_num_bytes
argument_list|(
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BN_rand
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|len
operator|*
literal|8
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* r mod p */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|BN_mod
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|peer
operator|->
name|iffval
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
comment|/* 	 * Sign and send to Bob. The filestamp is from the local file. 	 */
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|ident_pkey
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|BN_bn2bin
argument_list|(
name|peer
operator|->
name|iffval
argument_list|,
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_bob3 - construct Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_ERR	protocol error  */
end_comment

begin_function
specifier|static
name|int
name|crypto_bob3
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* MV parameters */
name|DSA
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA signature context fake */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* signature context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|BIGNUM
modifier|*
name|r
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * If the MV parameters are not valid, something awful 	 * happened or we are being tormented. 	 */
if|if
condition|(
name|mvkey_info
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_bob3: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
name|dsa
operator|=
name|mvkey_info
operator|->
name|pkey
operator|->
name|pkey
operator|.
name|dsa
expr_stmt|;
comment|/* 	 * Extract r from the challenge. 	 */
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|BN_bin2bn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob3: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
comment|/* 	 * Bob rolls random k (0< k< q), making sure it is not a 	 * factor of q. He then computes y = r A^k and sends (y, gbar^k, 	 * and ghat^k) to Alice. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|k
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|u
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|=
name|DSA_new
argument_list|()
expr_stmt|;
name|sdsa
operator|->
name|p
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|->
name|q
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|->
name|g
operator|=
name|BN_new
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BN_rand
argument_list|(
name|k
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|k
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_gcd
argument_list|(
name|u
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
break|break;
block|}
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* A^k r */
name|BN_mod_mul
argument_list|(
name|sdsa
operator|->
name|p
argument_list|,
name|u
argument_list|,
name|r
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|sdsa
operator|->
name|q
argument_list|,
name|dsa
operator|->
name|priv_key
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* gbar */
name|BN_mod_exp
argument_list|(
name|sdsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* ghat */
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|DSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|sdsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Encode the values in ASN.1 and sign. The filestamp is from 	 * the local file. 	 */
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|htonl
argument_list|(
name|mvkey_info
operator|->
name|fstamp
argument_list|)
expr_stmt|;
name|len
operator|=
name|i2d_DSAparams
argument_list|(
name|sdsa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_bob3: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|i2d_DSAparams
argument_list|(
name|sdsa
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|vp
operator|->
name|tstamp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_mv - verify Bob's response to Alice's challenge  *  * Returns  * XEVNT_OK	success  * XEVNT_ERR	protocol error  * XEVNT_FSP	bad filestamp  * XEVNT_ID	bad or missing group key  * XEVNT_PUB	bad or missing public key  */
end_comment

begin_function
name|int
name|crypto_mv
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension pointer */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* MV parameters */
name|DSA
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA parameters */
name|BN_CTX
modifier|*
name|bctx
decl_stmt|;
comment|/* BIGNUM context */
name|BIGNUM
modifier|*
name|k
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|u_int
name|len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|temp
decl_stmt|;
comment|/* 	 * If the MV parameters are not valid or no challenge was sent, 	 * something awful happened or we are being tormented. 	 */
if|if
condition|(
name|peer
operator|->
name|ident_pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_mv: scheme unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
operator|!=
name|peer
operator|->
name|ident_pkey
operator|->
name|fstamp
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_mv: invalid filestamp %u"
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_FSP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dsa
operator|=
name|peer
operator|->
name|ident_pkey
operator|->
name|pkey
operator|->
name|pkey
operator|.
name|dsa
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_mv: defective key"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
if|if
condition|(
name|peer
operator|->
name|iffval
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_mv: missing challenge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
comment|/* 	 * Extract the y, gbar and ghat values from the response. 	 */
name|bctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|k
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|u
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|v
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|len
operator|=
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
if|if
condition|(
operator|(
name|sdsa
operator|=
name|d2i_DSAparams
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_mv: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ERR
operator|)
return|;
block|}
comment|/* 	 * Compute (gbar^xhat ghat^xbar) mod p. 	 */
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|sdsa
operator|->
name|q
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|sdsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|priv_key
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|sdsa
operator|->
name|p
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
comment|/* 	 * The result should match r. 	 */
name|temp
operator|=
name|BN_cmp
argument_list|(
name|u
argument_list|,
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|bctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|peer
operator|->
name|iffval
argument_list|)
expr_stmt|;
name|peer
operator|->
name|iffval
operator|=
name|NULL
expr_stmt|;
name|DSA_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_mv: identity not verified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_ID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines are used to manipulate certificates          *  *								       *  ***********************************************************************  */
end_comment

begin_comment
comment|/*  * cert_sign - sign x509 certificate equest and update value structure.  *  * The certificate request includes a copy of the host certificate,  * which includes the version number, subject name and public key of the  * host. The resulting certificate includes these values plus the  * serial number, issuer name and valid interval of the server. The  * valid interval extends from the current time to the same time one  * year hence. This may extend the life of the signed certificate beyond  * that of the signer certificate.  *  * It is convenient to use the NTP seconds of the current time as the  * serial number. In the value structure the timestamp is the current  * time and the filestamp is taken from the extension field. Note this  * routine is called only when the client clock is synchronized to a  * proventic source, so timestamp comparisons are valid.  *  * The host certificate is valid from the time it was generated for a  * period of one year. A signed certificate is valid from the time of  * signature for a period of one year, but only the host certificate (or  * sign certificate if used) is actually used to encrypt and decrypt  * signatures. The signature trail is built from the client via the  * intermediate servers to the trusted server. Each signature on the  * trail must be valid at the time of signature, but it could happen  * that a signer certificate expire before the signed certificate, which  * remains valid until its expiration.   *  * Returns  * XEVNT_OK	success  * XEVNT_CRT	bad or missing certificate  * XEVNT_PER	host certificate expired  * XEVNT_PUB	bad or missing public key  * XEVNT_VFY	certificate not verified  */
end_comment

begin_function
specifier|static
name|int
name|cert_sign
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* extension field pointer */
name|struct
name|value
modifier|*
name|vp
comment|/* value pointer */
parameter_list|)
block|{
name|X509
modifier|*
name|req
decl_stmt|;
comment|/* X509 certificate request */
name|X509
modifier|*
name|cert
decl_stmt|;
comment|/* X509 certificate */
name|X509_EXTENSION
modifier|*
name|ext
decl_stmt|;
comment|/* certificate extension */
name|ASN1_INTEGER
modifier|*
name|serial
decl_stmt|;
comment|/* serial number */
name|X509_NAME
modifier|*
name|subj
decl_stmt|;
comment|/* distinguished (common) name */
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* public key */
name|EVP_MD_CTX
name|ctx
decl_stmt|;
comment|/* message digest context */
name|tstamp_t
name|tstamp
decl_stmt|;
comment|/* NTP timestamp */
name|struct
name|calendar
name|tscal
decl_stmt|;
name|u_int
name|len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cptr
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|temp
decl_stmt|;
comment|/* 	 * Decode ASN.1 objects and construct certificate structure. 	 * Make sure the system clock is synchronized to a proventic 	 * source. 	 */
name|tstamp
operator|=
name|crypto_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|tstamp
operator|==
literal|0
condition|)
return|return
operator|(
name|XEVNT_TSP
operator|)
return|;
name|cptr
operator|=
operator|(
name|void
operator|*
operator|)
name|ep
operator|->
name|pkt
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|cptr
argument_list|,
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cert_sign: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_CRT
operator|)
return|;
block|}
comment|/* 	 * Extract public key and check for errors. 	 */
if|if
condition|(
operator|(
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|req
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cert_sign: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PUB
operator|)
return|;
block|}
comment|/* 	 * Generate X509 certificate signed by this server. If this is a 	 * trusted host, the issuer name is the group name; otherwise, 	 * it is the host name. Also copy any extensions that might be 	 * present. 	 */
name|cert
operator|=
name|X509_new
argument_list|()
expr_stmt|;
name|X509_set_version
argument_list|(
name|cert
argument_list|,
name|X509_get_version
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|serial
operator|=
name|ASN1_INTEGER_new
argument_list|()
expr_stmt|;
name|ASN1_INTEGER_set
argument_list|(
name|serial
argument_list|,
name|tstamp
argument_list|)
expr_stmt|;
name|X509_set_serialNumber
argument_list|(
name|cert
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|X509_gmtime_adj
argument_list|(
name|X509_get_notBefore
argument_list|(
name|cert
argument_list|)
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|X509_gmtime_adj
argument_list|(
name|X509_get_notAfter
argument_list|(
name|cert
argument_list|)
argument_list|,
name|YEAR
argument_list|)
expr_stmt|;
name|subj
operator|=
name|X509_get_issuer_name
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|X509_NAME_add_entry_by_txt
argument_list|(
name|subj
argument_list|,
literal|"commonName"
argument_list|,
name|MBSTRING_ASC
argument_list|,
name|hostval
operator|.
name|ptr
argument_list|,
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|hostval
operator|.
name|ptr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subj
operator|=
name|X509_get_subject_name
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|X509_set_subject_name
argument_list|(
name|cert
argument_list|,
name|subj
argument_list|)
expr_stmt|;
name|X509_set_pubkey
argument_list|(
name|cert
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
name|temp
operator|=
name|X509_get_ext_count
argument_list|(
name|req
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|temp
condition|;
name|i
operator|++
control|)
block|{
name|ext
operator|=
name|X509_get_ext
argument_list|(
name|req
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|X509_add_ext
argument_list|(
name|cert
argument_list|,
name|ext
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|X509_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* 	 * Sign and verify the client certificate, but only if the host 	 * certificate has not expired. 	 */
operator|(
name|void
operator|)
name|ntpcal_ntp_to_date
argument_list|(
operator|&
name|tscal
argument_list|,
name|tstamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|calcomp
argument_list|(
operator|&
name|tscal
argument_list|,
operator|&
operator|(
name|cert_host
operator|->
name|first
operator|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|calcomp
argument_list|(
operator|&
name|tscal
argument_list|,
operator|&
operator|(
name|cert_host
operator|->
name|last
operator|)
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_PER
operator|)
return|;
block|}
name|X509_sign
argument_list|(
name|cert
argument_list|,
name|sign_pkey
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
if|if
condition|(
name|X509_verify
argument_list|(
name|cert
argument_list|,
name|sign_pkey
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cert_sign: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_VFY
operator|)
return|;
block|}
name|len
operator|=
name|i2d_X509
argument_list|(
name|cert
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Build and sign the value structure. We have to sign it here, 	 * since the response has to be returned right away. This is a 	 * clogging hazard. 	 */
name|memset
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tstamp
operator|=
name|htonl
argument_list|(
name|tstamp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|fstamp
operator|=
name|ep
operator|->
name|fstamp
expr_stmt|;
name|vp
operator|->
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|vp
operator|->
name|ptr
expr_stmt|;
name|i2d_X509
argument_list|(
name|cert
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|(
name|intptr_t
operator|)
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|vp
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstamp
operator|!=
literal|0
condition|)
block|{
name|vp
operator|->
name|sig
operator|=
name|emalloc
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|sign_digest
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|vp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|vp
operator|->
name|sig
argument_list|,
operator|&
name|len
argument_list|,
name|sign_pkey
argument_list|)
condition|)
name|vp
operator|->
name|siglen
operator|=
name|htonl
argument_list|(
name|sign_siglen
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|X509_print_fp
argument_list|(
name|stdout
argument_list|,
name|cert
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cert_install - install certificate in certificate cache  *  * This routine encodes an extension field into a certificate info/value  * structure. It searches the certificate list for duplicates and  * expunges whichever is older. Finally, it inserts this certificate  * first on the list.  *  * Returns certificate info pointer if valid, NULL if not.  */
end_comment

begin_function
name|struct
name|cert_info
modifier|*
name|cert_install
parameter_list|(
name|struct
name|exten
modifier|*
name|ep
parameter_list|,
comment|/* cert info/value */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure */
parameter_list|)
block|{
name|struct
name|cert_info
modifier|*
name|cp
decl_stmt|,
modifier|*
name|xp
decl_stmt|,
modifier|*
modifier|*
name|zp
decl_stmt|;
comment|/* 	 * Parse and validate the signed certificate. If valid, 	 * construct the info/value structure; otherwise, scamper home 	 * empty handed. 	 */
if|if
condition|(
operator|(
name|cp
operator|=
name|cert_parse
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|->
name|pkt
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|ep
operator|->
name|vallen
argument_list|)
argument_list|,
operator|(
name|tstamp_t
operator|)
name|ntohl
argument_list|(
name|ep
operator|->
name|fstamp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Scan certificate list looking for another certificate with 	 * the same subject and issuer. If another is found with the 	 * same or older filestamp, unlink it and return the goodies to 	 * the heap. If another is found with a later filestamp, discard 	 * the new one and leave the building with the old one. 	 * 	 * Make a note to study this issue again. An earlier certificate 	 * with a long lifetime might be overtaken by a later 	 * certificate with a short lifetime, thus invalidating the 	 * earlier signature. However, we gotta find a way to leak old 	 * stuff from the cache, so we do it anyway.  	 */
name|zp
operator|=
operator|&
name|cinfo
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|cinfo
init|;
name|xp
operator|!=
name|NULL
condition|;
name|xp
operator|=
name|xp
operator|->
name|link
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cp
operator|->
name|subject
argument_list|,
name|xp
operator|->
name|subject
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|cp
operator|->
name|issuer
argument_list|,
name|xp
operator|->
name|issuer
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|cp
operator|->
name|cert
operator|.
name|fstamp
argument_list|)
operator|<=
name|ntohl
argument_list|(
name|xp
operator|->
name|cert
operator|.
name|fstamp
argument_list|)
condition|)
block|{
name|cert_free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|xp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|zp
operator|=
name|xp
operator|->
name|link
expr_stmt|;
name|cert_free
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|xp
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
name|zp
operator|=
operator|&
name|xp
operator|->
name|link
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|->
name|link
operator|=
name|cinfo
expr_stmt|;
name|cinfo
operator|=
name|cp
expr_stmt|;
block|}
name|cp
operator|->
name|flags
operator||=
name|CERT_VALID
expr_stmt|;
name|crypto_update
argument_list|()
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cert_hike - verify the signature using the issuer public key  *  * Returns  * XEVNT_OK	success  * XEVNT_CRT	bad or missing certificate  * XEVNT_PER	host certificate expired  * XEVNT_VFY	certificate not verified  */
end_comment

begin_function
name|int
name|cert_hike
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|struct
name|cert_info
modifier|*
name|yp
comment|/* issuer certificate */
parameter_list|)
block|{
name|struct
name|cert_info
modifier|*
name|xp
decl_stmt|;
comment|/* subject certificate */
name|X509
modifier|*
name|cert
decl_stmt|;
comment|/* X509 certificate */
specifier|const
name|u_char
modifier|*
name|ptr
decl_stmt|;
comment|/* 	 * Save the issuer on the new certificate, but remember the old 	 * one. 	 */
if|if
condition|(
name|peer
operator|->
name|issuer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|peer
operator|->
name|issuer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|issuer
operator|=
name|estrdup
argument_list|(
name|yp
operator|->
name|issuer
argument_list|)
expr_stmt|;
name|xp
operator|=
name|peer
operator|->
name|xinfo
expr_stmt|;
name|peer
operator|->
name|xinfo
operator|=
name|yp
expr_stmt|;
comment|/* 	 * If subject Y matches issuer Y, then the certificate trail is 	 * complete. If Y is not trusted, the server certificate has yet 	 * been signed, so keep trying. Otherwise, save the group key 	 * and light the valid bit. If the host certificate is trusted, 	 * do not execute a sign exchange. If no identity scheme is in 	 * use, light the identity and proventic bits. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|yp
operator|->
name|subject
argument_list|,
name|yp
operator|->
name|issuer
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|flags
operator|&
name|CERT_TRUST
operator|)
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
comment|/* 		 * If the server has an an identity scheme, fetch the 		 * identity credentials. If not, the identity is 		 * verified only by the trusted certificate. The next 		 * signature will set the server proventic. 		 */
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_CERT
expr_stmt|;
name|peer
operator|->
name|grpkey
operator|=
name|yp
operator|->
name|grpkey
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ident
operator|==
name|NULL
operator|||
operator|!
operator|(
name|peer
operator|->
name|crypto
operator|&
name|CRYPTO_FLAG_MASK
operator|)
condition|)
name|peer
operator|->
name|crypto
operator||=
name|CRYPTO_FLAG_VRFY
expr_stmt|;
block|}
comment|/* 	 * If X exists, verify signature X using public key Y. 	 */
if|if
condition|(
name|xp
operator|==
name|NULL
condition|)
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|xp
operator|->
name|cert
operator|.
name|ptr
expr_stmt|;
name|cert
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|ntohl
argument_list|(
name|xp
operator|->
name|cert
operator|.
name|vallen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cert
operator|==
name|NULL
condition|)
block|{
name|xp
operator|->
name|flags
operator||=
name|CERT_ERROR
expr_stmt|;
return|return
operator|(
name|XEVNT_CRT
operator|)
return|;
block|}
if|if
condition|(
name|X509_verify
argument_list|(
name|cert
argument_list|,
name|yp
operator|->
name|pkey
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|xp
operator|->
name|flags
operator||=
name|CERT_ERROR
expr_stmt|;
return|return
operator|(
name|XEVNT_VFY
operator|)
return|;
block|}
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
comment|/* 	 * Signature X is valid only if it begins during the 	 * lifetime of Y.  	 */
if|if
condition|(
operator|(
name|calcomp
argument_list|(
operator|&
operator|(
name|xp
operator|->
name|first
operator|)
argument_list|,
operator|&
operator|(
name|yp
operator|->
name|first
operator|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|calcomp
argument_list|(
operator|&
operator|(
name|xp
operator|->
name|first
operator|)
argument_list|,
operator|&
operator|(
name|yp
operator|->
name|last
operator|)
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|xp
operator|->
name|flags
operator||=
name|CERT_ERROR
expr_stmt|;
return|return
operator|(
name|XEVNT_PER
operator|)
return|;
block|}
name|xp
operator|->
name|flags
operator||=
name|CERT_SIGN
expr_stmt|;
return|return
operator|(
name|XEVNT_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cert_parse - parse x509 certificate and create info/value structures.  *  * The server certificate includes the version number, issuer name,  * subject name, public key and valid date interval. If the issuer name  * is the same as the subject name, the certificate is self signed and  * valid only if the server is configured as trustable. If the names are  * different, another issuer has signed the server certificate and  * vouched for it. In this case the server certificate is valid if  * verified by the issuer public key.  *  * Returns certificate info/value pointer if valid, NULL if not.  */
end_comment

begin_function
name|struct
name|cert_info
modifier|*
comment|/* certificate information structure */
name|cert_parse
parameter_list|(
specifier|const
name|u_char
modifier|*
name|asn1cert
parameter_list|,
comment|/* X509 certificate */
name|long
name|len
parameter_list|,
comment|/* certificate length */
name|tstamp_t
name|fstamp
comment|/* filestamp */
parameter_list|)
block|{
name|X509
modifier|*
name|cert
decl_stmt|;
comment|/* X509 certificate */
name|X509_EXTENSION
modifier|*
name|ext
decl_stmt|;
comment|/* X509v3 extension */
name|struct
name|cert_info
modifier|*
name|ret
decl_stmt|;
comment|/* certificate info/value */
name|BIO
modifier|*
name|bp
decl_stmt|;
name|char
name|pathbuf
index|[
name|MAXFILENAME
index|]
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|pch
decl_stmt|;
name|int
name|temp
decl_stmt|,
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|calendar
name|fscal
decl_stmt|;
comment|/* 	 * Decode ASN.1 objects and construct certificate structure. 	 */
name|ptr
operator|=
name|asn1cert
expr_stmt|;
if|if
condition|(
operator|(
name|cert
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cert_parse: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|X509_print_fp
argument_list|(
name|stdout
argument_list|,
name|cert
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Extract version, subject name and public key. 	 */
name|ret
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|->
name|pkey
operator|=
name|X509_get_pubkey
argument_list|(
name|cert
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cert_parse: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ret
operator|->
name|version
operator|=
name|X509_get_version
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|X509_NAME_oneline
argument_list|(
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|pathbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|)
expr_stmt|;
name|pch
operator|=
name|strstr
argument_list|(
name|pathbuf
argument_list|,
literal|"CN="
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pch
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cert_parse: invalid subject %s"
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ret
operator|->
name|subject
operator|=
name|estrdup
argument_list|(
name|pch
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* 	 * Extract remaining objects. Note that the NTP serial number is 	 * the NTP seconds at the time of signing, but this might not be 	 * the case for other authority. We don't bother to check the 	 * objects at this time, since the real crunch can happen only 	 * when the time is valid but not yet certificated. 	 */
name|ret
operator|->
name|nid
operator|=
name|OBJ_obj2nid
argument_list|(
name|cert
operator|->
name|cert_info
operator|->
name|signature
operator|->
name|algorithm
argument_list|)
expr_stmt|;
name|ret
operator|->
name|digest
operator|=
operator|(
specifier|const
name|EVP_MD
operator|*
operator|)
name|EVP_get_digestbynid
argument_list|(
name|ret
operator|->
name|nid
argument_list|)
expr_stmt|;
name|ret
operator|->
name|serial
operator|=
operator|(
name|u_long
operator|)
name|ASN1_INTEGER_get
argument_list|(
name|X509_get_serialNumber
argument_list|(
name|cert
argument_list|)
argument_list|)
expr_stmt|;
name|X509_NAME_oneline
argument_list|(
name|X509_get_issuer_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|pathbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pch
operator|=
name|strstr
argument_list|(
name|pathbuf
argument_list|,
literal|"CN="
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cert_parse: invalid issuer %s"
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ret
operator|->
name|issuer
operator|=
name|estrdup
argument_list|(
name|pch
operator|+
literal|3
argument_list|)
expr_stmt|;
name|asn_to_calendar
argument_list|(
name|X509_get_notBefore
argument_list|(
name|cert
argument_list|)
argument_list|,
operator|&
operator|(
name|ret
operator|->
name|first
operator|)
argument_list|)
expr_stmt|;
name|asn_to_calendar
argument_list|(
name|X509_get_notAfter
argument_list|(
name|cert
argument_list|)
argument_list|,
operator|&
operator|(
name|ret
operator|->
name|last
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Extract extension fields. These are ad hoc ripoffs of 	 * currently assigned functions and will certainly be changed 	 * before prime time. 	 */
name|cnt
operator|=
name|X509_get_ext_count
argument_list|(
name|cert
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|ext
operator|=
name|X509_get_ext
argument_list|(
name|cert
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|temp
operator|=
name|OBJ_obj2nid
argument_list|(
name|ext
operator|->
name|object
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
comment|/* 		 * If a key_usage field is present, we decode whether 		 * this is a trusted or private certificate. This is 		 * dorky; all we want is to compare NIDs, but OpenSSL 		 * insists on BIO text strings. 		 */
case|case
name|NID_ext_key_usage
case|:
name|bp
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|X509V3_EXT_print
argument_list|(
name|bp
argument_list|,
name|ext
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BIO_gets
argument_list|(
name|bp
argument_list|,
name|pathbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pathbuf
argument_list|,
literal|"Trust Root"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|->
name|flags
operator||=
name|CERT_TRUST
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pathbuf
argument_list|,
literal|"Private"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|->
name|flags
operator||=
name|CERT_PRIV
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"cert_parse: %s: %s\n"
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|temp
argument_list|)
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* 		 * If a NID_subject_key_identifier field is present, it 		 * contains the GQ public key. 		 */
case|case
name|NID_subject_key_identifier
case|:
name|ret
operator|->
name|grpkey
operator|=
name|BN_bin2bn
argument_list|(
operator|&
name|ext
operator|->
name|value
operator|->
name|data
index|[
literal|2
index|]
argument_list|,
name|ext
operator|->
name|value
operator|->
name|length
operator|-
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* fall through */
if|#
directive|if
name|DEBUG
default|default:
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"cert_parse: %s\n"
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|ret
operator|->
name|subject
argument_list|,
name|ret
operator|->
name|issuer
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If certificate is self signed, verify signature. 		 */
if|if
condition|(
name|X509_verify
argument_list|(
name|cert
argument_list|,
name|ret
operator|->
name|pkey
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cert_parse: signature not verified %s"
argument_list|,
name|ret
operator|->
name|subject
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Check for a certificate loop. 		 */
if|if
condition|(
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|hostval
operator|.
name|ptr
argument_list|,
name|ret
operator|->
name|issuer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cert_parse: certificate trail loop %s"
argument_list|,
name|ret
operator|->
name|subject
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * Verify certificate valid times. Note that certificates cannot 	 * be retroactive. 	 */
operator|(
name|void
operator|)
name|ntpcal_ntp_to_date
argument_list|(
operator|&
name|fscal
argument_list|,
name|fstamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|calcomp
argument_list|(
operator|&
operator|(
name|ret
operator|->
name|first
operator|)
argument_list|,
operator|&
operator|(
name|ret
operator|->
name|last
operator|)
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|calcomp
argument_list|(
operator|&
operator|(
name|ret
operator|->
name|first
operator|)
argument_list|,
operator|&
name|fscal
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cert_parse: invalid times %s first %u-%02u-%02uT%02u:%02u:%02u last %u-%02u-%02uT%02u:%02u:%02u fstamp %u-%02u-%02uT%02u:%02u:%02u"
argument_list|,
name|ret
operator|->
name|subject
argument_list|,
name|ret
operator|->
name|first
operator|.
name|year
argument_list|,
name|ret
operator|->
name|first
operator|.
name|month
argument_list|,
name|ret
operator|->
name|first
operator|.
name|monthday
argument_list|,
name|ret
operator|->
name|first
operator|.
name|hour
argument_list|,
name|ret
operator|->
name|first
operator|.
name|minute
argument_list|,
name|ret
operator|->
name|first
operator|.
name|second
argument_list|,
name|ret
operator|->
name|last
operator|.
name|year
argument_list|,
name|ret
operator|->
name|last
operator|.
name|month
argument_list|,
name|ret
operator|->
name|last
operator|.
name|monthday
argument_list|,
name|ret
operator|->
name|last
operator|.
name|hour
argument_list|,
name|ret
operator|->
name|last
operator|.
name|minute
argument_list|,
name|ret
operator|->
name|last
operator|.
name|second
argument_list|,
name|fscal
operator|.
name|year
argument_list|,
name|fscal
operator|.
name|month
argument_list|,
name|fscal
operator|.
name|monthday
argument_list|,
name|fscal
operator|.
name|hour
argument_list|,
name|fscal
operator|.
name|minute
argument_list|,
name|fscal
operator|.
name|second
argument_list|)
expr_stmt|;
name|cert_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Build the value structure to sign and send later. 	 */
name|ret
operator|->
name|cert
operator|.
name|fstamp
operator|=
name|htonl
argument_list|(
name|fstamp
argument_list|)
expr_stmt|;
name|ret
operator|->
name|cert
operator|.
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ret
operator|->
name|cert
operator|.
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
operator|->
name|cert
operator|.
name|ptr
argument_list|,
name|asn1cert
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cert_free - free certificate information structure  */
end_comment

begin_function
name|void
name|cert_free
parameter_list|(
name|struct
name|cert_info
modifier|*
name|cinf
comment|/* certificate info/value structure */
parameter_list|)
block|{
if|if
condition|(
name|cinf
operator|->
name|pkey
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|cinf
operator|->
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinf
operator|->
name|subject
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cinf
operator|->
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinf
operator|->
name|issuer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cinf
operator|->
name|issuer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinf
operator|->
name|grpkey
operator|!=
name|NULL
condition|)
name|BN_free
argument_list|(
name|cinf
operator|->
name|grpkey
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
operator|&
name|cinf
operator|->
name|cert
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cinf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * crypto_key - load cryptographic parameters and keys  *  * This routine searches the key cache for matching name in the form  * ntpkey_<key>_<name>, where<key> is one of host, sign, iff, gq, mv,  * and<name> is the host/group name. If not found, it tries to load a  * PEM-encoded file of the same name and extracts the filestamp from  * the first line of the file name. It returns the key pointer if valid,  * NULL if not.  */
end_comment

begin_function
specifier|static
name|struct
name|pkey_info
modifier|*
name|crypto_key
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
comment|/* file name */
name|char
modifier|*
name|passwd1
parameter_list|,
comment|/* password */
name|sockaddr_u
modifier|*
name|addr
comment|/* IP address */
parameter_list|)
block|{
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|struct
name|pkey_info
modifier|*
name|pkp
decl_stmt|;
comment|/* generic key */
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
comment|/* public/private key */
name|tstamp_t
name|fstamp
decl_stmt|;
name|char
name|filename
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* name of key file */
name|char
name|linkname
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* filestamp buffer) */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* 	 * Search the key cache for matching key and name. 	 */
for|for
control|(
name|pkp
operator|=
name|pkinfo
init|;
name|pkp
operator|!=
name|NULL
condition|;
name|pkp
operator|=
name|pkp
operator|->
name|link
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|pkp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|pkp
operator|)
return|;
block|}
comment|/* 	 * Open the key file. If the first character of the file name is 	 * not '/', prepend the keys directory string. If something goes 	 * wrong, abandon ship. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|strlcpy
argument_list|(
name|filename
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|keysdir
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|str
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Read the filestamp, which is contained in the first line. 	 */
if|if
condition|(
operator|(
name|ptr
operator|=
name|fgets
argument_list|(
name|linkname
argument_list|,
sizeof|sizeof
argument_list|(
name|linkname
argument_list|)
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_key: empty file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|ptr
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_key: no filestamp %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|fstamp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_key: invalid filestamp %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Read and decrypt PEM-encoded private key. If it fails to 	 * decrypt, game over. 	 */
name|pkey
operator|=
name|PEM_read_PrivateKey
argument_list|(
name|str
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_key: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make a new entry in the key cache. 	 */
name|pkp
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pkey_info
argument_list|)
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|link
operator|=
name|pkinfo
expr_stmt|;
name|pkinfo
operator|=
name|pkp
expr_stmt|;
name|pkp
operator|->
name|pkey
operator|=
name|pkey
expr_stmt|;
name|pkp
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|fstamp
operator|=
name|fstamp
expr_stmt|;
comment|/* 	 * Leave tracks in the cryptostats. 	 */
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|linkname
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"%s mod %d"
argument_list|,
operator|&
name|linkname
index|[
literal|2
index|]
argument_list|,
name|EVP_PKEY_size
argument_list|(
name|pkey
argument_list|)
operator|*
literal|8
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
name|addr
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_key: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|pkey
operator|->
name|type
operator|==
name|EVP_PKEY_DSA
condition|)
name|DSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pkey
operator|->
name|type
operator|==
name|EVP_PKEY_RSA
condition|)
name|RSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|pkp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines are used only at initialization time         *  *								       *  ***********************************************************************  */
end_comment

begin_comment
comment|/*  * crypto_cert - load certificate from file  *  * This routine loads an X.509 RSA or DSA certificate from a file and  * constructs a info/cert value structure for this machine. The  * structure includes a filestamp extracted from the file name. Later  * the certificate can be sent to another machine on request.  *  * Returns certificate info/value pointer if valid, NULL if not.  */
end_comment

begin_function
specifier|static
name|struct
name|cert_info
modifier|*
comment|/* certificate information */
name|crypto_cert
parameter_list|(
name|char
modifier|*
name|cp
comment|/* file name */
parameter_list|)
block|{
name|struct
name|cert_info
modifier|*
name|ret
decl_stmt|;
comment|/* certificate information */
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|char
name|filename
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* name of certificate file */
name|char
name|linkname
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* filestamp buffer */
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|tstamp_t
name|fstamp
decl_stmt|;
comment|/* filestamp */
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|header
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
comment|/* 	 * Open the certificate file. If the first character of the file 	 * name is not '/', prepend the keys directory string. If 	 * something goes wrong, abandon ship. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|strlcpy
argument_list|(
name|filename
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|keysdir
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|str
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Read the filestamp, which is contained in the first line. 	 */
if|if
condition|(
operator|(
name|ptr
operator|=
name|fgets
argument_list|(
name|linkname
argument_list|,
sizeof|sizeof
argument_list|(
name|linkname
argument_list|)
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_cert: empty file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|ptr
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_cert: no filestamp %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|fstamp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_cert: invalid filestamp %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Read PEM-encoded certificate and install. 	 */
if|if
condition|(
operator|!
name|PEM_read
argument_list|(
name|str
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|header
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_cert: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"CERTIFICATE"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_cert: wrong PEM type %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Parse certificate and generate info/value structure. The 	 * pointer and copy nonsense is due something broken in Solaris. 	 */
name|ret
operator|=
name|cert_parse
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|linkname
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"%s 0x%x len %lu"
argument_list|,
operator|&
name|linkname
index|[
literal|2
index|]
argument_list|,
name|ret
operator|->
name|flags
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
name|NULL
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_cert: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * crypto_setup - load keys, certificate and identity parameters  *  * This routine loads the public/private host key and certificate. If  * available, it loads the public/private sign key, which defaults to  * the host key. The host key must be RSA, but the sign key can be  * either RSA or DSA. If a trusted certificate, it loads the identity  * parameters. In either case, the public key on the certificate must  * agree with the sign key.  *  * Required but missing files and inconsistent data and errors are  * fatal. Allowing configuration to continue would be hazardous and  * require really messy error checks.  */
end_comment

begin_function
name|void
name|crypto_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pkey_info
modifier|*
name|pinfo
decl_stmt|;
comment|/* private/public key */
name|char
name|filename
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* file name buffer */
name|char
name|hostname
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* host name buffer */
name|char
modifier|*
name|randfile
decl_stmt|;
name|char
name|statstr
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* statistics for filegen */
name|l_fp
name|seed
decl_stmt|;
comment|/* crypto PRNG seed as NTP timestamp */
name|u_int
name|len
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
comment|/* 	 * Check for correct OpenSSL version and avoid initialization in 	 * the case of multiple crypto commands. 	 */
if|if
condition|(
name|crypto_flags
operator|&
name|CRYPTO_FLAG_ENAB
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"crypto_setup: spurious crypto command"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ssl_check_version
argument_list|()
expr_stmt|;
comment|/* 	 * Load required random seed file and seed the random number 	 * generator. Be default, it is found as .rnd in the user home 	 * directory. The root home directory may be / or /root, 	 * depending on the system. Wiggle the contents a bit and write 	 * it back so the sequence does not repeat when we next restart. 	 */
if|if
condition|(
operator|!
name|RAND_status
argument_list|()
condition|)
block|{
if|if
condition|(
name|rand_file
operator|==
name|NULL
condition|)
block|{
name|RAND_file_name
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|randfile
operator|=
name|filename
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|rand_file
operator|!=
literal|'/'
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|keysdir
argument_list|,
name|rand_file
argument_list|)
expr_stmt|;
name|randfile
operator|=
name|filename
expr_stmt|;
block|}
else|else
name|randfile
operator|=
name|rand_file
expr_stmt|;
if|if
condition|(
operator|(
name|bytes
operator|=
name|RAND_load_file
argument_list|(
name|randfile
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: random seed file %s missing"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|arc4random_buf
argument_list|(
operator|&
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|)
expr_stmt|;
name|RAND_seed
argument_list|(
operator|&
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|)
expr_stmt|;
name|RAND_write_file
argument_list|(
name|randfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_setup: OpenSSL version %lx random seed file %s bytes read %d\n"
argument_list|,
name|SSLeay
argument_list|()
argument_list|,
name|randfile
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Initialize structures. 	 */
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_filename
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|hostname
argument_list|,
name|host_filename
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|passwd
operator|==
name|NULL
condition|)
name|passwd
operator|=
name|estrdup
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hostval
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hostval
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pubkey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pubkey
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tai_leap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tai_leap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Load required host key from file "ntpkey_host_<hostname>". If 	 * no host key file is not found or has invalid password, life 	 * as we know it ends. The host key also becomes the default 	 * sign key.  	 */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_host_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|pinfo
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
name|passwd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: host key file %s not found or corrupt"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pinfo
operator|->
name|pkey
operator|->
name|type
operator|!=
name|EVP_PKEY_RSA
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: host key is not RSA key type"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|host_pkey
operator|=
name|pinfo
operator|->
name|pkey
expr_stmt|;
name|sign_pkey
operator|=
name|host_pkey
expr_stmt|;
name|hostval
operator|.
name|fstamp
operator|=
name|htonl
argument_list|(
name|pinfo
operator|->
name|fstamp
argument_list|)
expr_stmt|;
comment|/* 	 * Construct public key extension field for agreement scheme. 	 */
name|len
operator|=
name|i2d_PublicKey
argument_list|(
name|host_pkey
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|pubkey
operator|.
name|ptr
operator|=
name|ptr
expr_stmt|;
name|i2d_PublicKey
argument_list|(
name|host_pkey
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|pubkey
operator|.
name|fstamp
operator|=
name|hostval
operator|.
name|fstamp
expr_stmt|;
name|pubkey
operator|.
name|vallen
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Load optional sign key from file "ntpkey_sign_<hostname>". If 	 * available, it becomes the sign key. 	 */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_sign_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|pinfo
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
name|passwd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|!=
name|NULL
condition|)
name|sign_pkey
operator|=
name|pinfo
operator|->
name|pkey
expr_stmt|;
comment|/* 	 * Load required certificate from file "ntpkey_cert_<hostname>". 	 */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_cert_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|cinfo
operator|=
name|crypto_cert
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: certificate file %s not found or corrupt"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cert_host
operator|=
name|cinfo
expr_stmt|;
name|sign_digest
operator|=
name|cinfo
operator|->
name|digest
expr_stmt|;
name|sign_siglen
operator|=
name|EVP_PKEY_size
argument_list|(
name|sign_pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|flags
operator|&
name|CERT_PRIV
condition|)
name|crypto_flags
operator||=
name|CRYPTO_FLAG_PRIV
expr_stmt|;
comment|/* 	 * The certificate must be self-signed. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|cinfo
operator|->
name|subject
argument_list|,
name|cinfo
operator|->
name|issuer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_setup: certificate %s is not self-signed"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|hostval
operator|.
name|ptr
operator|=
name|estrdup
argument_list|(
name|cinfo
operator|->
name|subject
argument_list|)
expr_stmt|;
name|hostval
operator|.
name|vallen
operator|=
name|htonl
argument_list|(
name|strlen
argument_list|(
name|cinfo
operator|->
name|subject
argument_list|)
argument_list|)
expr_stmt|;
name|sys_hostname
operator|=
name|hostval
operator|.
name|ptr
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|strchr
argument_list|(
name|sys_hostname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|sys_groupname
operator|=
name|estrdup
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|++
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident_filename
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|hostname
argument_list|,
name|ident_filename
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Load optional IFF parameters from file 	 * "ntpkey_iffkey_<hostname>". 	 */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_iffkey_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|iffkey_info
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
name|passwd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|iffkey_info
operator|!=
name|NULL
condition|)
name|crypto_flags
operator||=
name|CRYPTO_FLAG_IFF
expr_stmt|;
comment|/* 	 * Load optional GQ parameters from file 	 * "ntpkey_gqkey_<hostname>". 	 */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_gqkey_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|gqkey_info
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
name|passwd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gqkey_info
operator|!=
name|NULL
condition|)
name|crypto_flags
operator||=
name|CRYPTO_FLAG_GQ
expr_stmt|;
comment|/* 	 * Load optional MV parameters from file 	 * "ntpkey_mvkey_<hostname>". 	 */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_mvkey_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|mvkey_info
operator|=
name|crypto_key
argument_list|(
name|filename
argument_list|,
name|passwd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvkey_info
operator|!=
name|NULL
condition|)
name|crypto_flags
operator||=
name|CRYPTO_FLAG_MV
expr_stmt|;
comment|/* 	 * We met the enemy and he is us. Now strike up the dance. 	 */
name|crypto_flags
operator||=
name|CRYPTO_FLAG_ENAB
operator||
operator|(
name|cinfo
operator|->
name|nid
operator|<<
literal|16
operator|)
expr_stmt|;
name|snprintf
argument_list|(
name|statstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statstr
argument_list|)
argument_list|,
literal|"setup 0x%x host %s %s"
argument_list|,
name|crypto_flags
argument_list|,
name|hostname
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|cinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|record_crypto_stats
argument_list|(
name|NULL
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"crypto_setup: %s\n"
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * crypto_config - configure data from the crypto command.  */
end_comment

begin_function
name|void
name|crypto_config
parameter_list|(
name|int
name|item
parameter_list|,
comment|/* configuration item */
name|char
modifier|*
name|cp
comment|/* item name */
parameter_list|)
block|{
name|int
name|nid
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"crypto_config: item %d %s\n"
argument_list|,
name|item
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|item
condition|)
block|{
comment|/* 	 * Set host name (host). 	 */
case|case
name|CRYPTO_CONF_PRIV
case|:
if|if
condition|(
name|NULL
operator|!=
name|host_filename
condition|)
name|free
argument_list|(
name|host_filename
argument_list|)
expr_stmt|;
name|host_filename
operator|=
name|estrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set group name (ident). 	 */
case|case
name|CRYPTO_CONF_IDENT
case|:
if|if
condition|(
name|NULL
operator|!=
name|ident_filename
condition|)
name|free
argument_list|(
name|ident_filename
argument_list|)
expr_stmt|;
name|ident_filename
operator|=
name|estrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set private key password (pw). 	 */
case|case
name|CRYPTO_CONF_PW
case|:
if|if
condition|(
name|NULL
operator|!=
name|passwd
condition|)
name|free
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|passwd
operator|=
name|estrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set random seed file name (randfile). 	 */
case|case
name|CRYPTO_CONF_RAND
case|:
if|if
condition|(
name|NULL
operator|!=
name|rand_file
condition|)
name|free
argument_list|(
name|rand_file
argument_list|)
expr_stmt|;
name|rand_file
operator|=
name|estrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set message digest NID. 	 */
case|case
name|CRYPTO_CONF_NID
case|:
name|nid
operator|=
name|OBJ_sn2nid
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nid
operator|==
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"crypto_config: invalid digest name %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|crypto_nid
operator|=
name|nid
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !AUTOKEY follows */
end_comment

begin_decl_stmt
name|int
name|ntp_crypto_bs_pubkey
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !AUTOKEY */
end_comment

end_unit

