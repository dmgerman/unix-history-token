begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * refclock_oncore.c  *  * Driver for some of the various the Motorola Oncore GPS receivers.  *   should work with Basic, PVT6, VP, UT, UT+, GT, GT+, SL, M12.  *	The receivers with TRAIM (VP, UT, UT+), will be more accurate than the others.  *	The receivers without position hold (GT, GT+) will be less accurate.  *  * Tested with:  *  *		(UT)				   (VP)  *   COPYRIGHT 1991-1997 MOTOROLA INC.	COPYRIGHT 1991-1996 MOTOROLA INC.  *   SFTW P/N #     98-P36848P		SFTW P/N # 98-P36830P  *   SOFTWARE VER # 2			SOFTWARE VER # 8  *   SOFTWARE REV # 2			SOFTWARE REV # 8  *   SOFTWARE DATE  APR 24 1998 	SOFTWARE DATE  06 Aug 1996  *   MODEL #	R1121N1114		MODEL #    B4121P1155  *   HWDR P/N # 1			HDWR P/N # _  *   SERIAL #	R0010A			SERIAL #   SSG0226478  *   MANUFACTUR DATE 6H07		MANUFACTUR DATE 7E02  *					OPTIONS LIST	IB  *  *	      (Basic)				   (M12)  *   COPYRIGHT 1991-1996 MOTOROLA INC.	COPYRIGHT 1991-2000 MOTOROLA INC.  *   SFTW P/N # 98-P36830P		SFTW P/N # 61-G10002A  *   SOFTWARE VER # 8			SOFTWARE VER # 1  *   SOFTWARE REV # 8			SOFTWARE REV # 3  *   SOFTWARE DATE  06 Aug 1996 	SOFTWARE DATE  Mar 13 2000  *   MODEL #	B4121P1155		MODEL #    P143T12NR1  *   HDWR P/N # _			HWDR P/N # 1  *   SERIAL #	SSG0226478		SERIAL #   P003UD  *   MANUFACTUR DATE 7E02		MANUFACTUR DATE 0C27  *   OPTIONS LIST    IB  *  * --------------------------------------------------------------------------  * This code uses the two devices  *	/dev/oncore.serial.n  *	/dev/oncore.pps.n  * which may be linked to the same device.  * and can read initialization data from the file  *	/etc/ntp.oncoreN, /etc/ntp.oncore.N, or /etc/ntp.oncore, where  *	n or N are the unit number, viz 127.127.30.N.  * --------------------------------------------------------------------------  * Reg.Clemens<reg@dwf.com> Sep98.  *  Original code written for FreeBSD.  *  With these mods it works on FreeBSD, SunOS, Solaris and Linux  *    (SunOS 4.1.3 + ppsclock)  *    (Solaris7 + MU4)  *    (RedHat 5.1 2.0.35 + PPSKit, 2.1.126 + or later).  *  *  Lat,Long,Ht, cable-delay, offset, and the ReceiverID (along with the  *  state machine state) are printed to CLOCKSTATS if that file is enabled  *  in /etc/ntp.conf.  *  * --------------------------------------------------------------------------  *  * According to the ONCORE manual (TRM0003, Rev 3.2, June 1998, page 3.13)  * doing an average of 10000 valid 2D and 3D fixes is what the automatic  * site survey mode does.  Looking at the output from the receiver  * it seems like it is only using 3D fixes.  * When we do it ourselves, take 10000 3D fixes.  */
end_comment

begin_define
define|#
directive|define
name|POS_HOLD_AVERAGE
value|10000
end_define

begin_comment
comment|/* nb, 10000s ~= 2h45m */
end_comment

begin_comment
comment|/*  * ONCORE_SHMEM_STATUS will create a mmap(2)'ed file named according to a  * "STATUS" line in the oncore config file, which contains the most recent  * copy of all types of messages we recognize.	This file can be mmap(2)'ed  * by monitoring and statistics programs.  *  * See separate HTML documentation for this option.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_ONCORE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ONCORE_SHMEM_STATUS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MMAN_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|((u_char *) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MAP_FAILED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_MMAN_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ONCORE_SHMEM_STATUS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<timepps.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/sio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TERMIOS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PPSCLOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRUCT_PPSCLOCKEV
end_ifndef

begin_struct
struct|struct
name|ppsclockev
block|{
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|struct
name|timespec
name|tv
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
name|tv
decl_stmt|;
endif|#
directive|endif
name|u_int
name|serial
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_STRUCT_PPSCLOCKEV */
end_comment

begin_enum
enum|enum
name|receive_state
block|{
name|ONCORE_NO_IDEA
block|,
name|ONCORE_ID_SENT
block|,
name|ONCORE_RESET_SENT
block|,
name|ONCORE_TEST_SENT
block|,
name|ONCORE_INIT
block|,
name|ONCORE_ALMANAC
block|,
name|ONCORE_RUN
block|}
enum|;
end_enum

begin_enum
enum|enum
name|site_survey_state
block|{
name|ONCORE_SS_UNKNOWN
block|,
name|ONCORE_SS_TESTING
block|,
name|ONCORE_SS_HW
block|,
name|ONCORE_SS_SW
block|,
name|ONCORE_SS_DONE
block|}
enum|;
end_enum

begin_comment
comment|/* Model Name, derived from the @@Cj message.  * Used to initialize some variables.  */
end_comment

begin_enum
enum|enum
name|oncore_model
block|{
name|ONCORE_BASIC
block|,
name|ONCORE_PVT6
block|,
name|ONCORE_VP
block|,
name|ONCORE_UT
block|,
name|ONCORE_UTPLUS
block|,
name|ONCORE_GT
block|,
name|ONCORE_GTPLUS
block|,
name|ONCORE_SL
block|,
name|ONCORE_M12
block|,
name|ONCORE_UNKNOWN
block|}
enum|;
end_enum

begin_comment
comment|/* the bits that describe these properties are in the same place  * on the VP/UT, but have moved on the M12.  As such we extract  * them, and use them from this struct.  *  */
end_comment

begin_struct
struct|struct
name|RSM
block|{
name|u_char
name|posn0D
decl_stmt|;
name|u_char
name|posn2D
decl_stmt|;
name|u_char
name|posn3D
decl_stmt|;
name|u_char
name|bad_almanac
decl_stmt|;
name|u_char
name|bad_fix
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* It is possible to test the VP/UT each cycle (@@Ea or equivalent) to  * see what mode it is in.  The bits on the M12 are multiplexed with  * other messages, so we have to 'keep' the last known mode here.  */
end_comment

begin_enum
enum|enum
name|posn_mode
block|{
name|MODE_UNKNOWN
block|,
name|MODE_0D
block|,
name|MODE_2D
block|,
name|MODE_3D
block|}
enum|;
end_enum

begin_struct
struct|struct
name|instance
block|{
name|int
name|unit
decl_stmt|;
comment|/* 127.127.30.unit */
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|ttyfd
decl_stmt|;
comment|/* TTY file descriptor */
name|int
name|ppsfd
decl_stmt|;
comment|/* PPS file descriptor */
name|int
name|statusfd
decl_stmt|;
comment|/* Status shm descriptor */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|pps_handle_t
name|pps_h
decl_stmt|;
name|pps_params_t
name|pps_p
decl_stmt|;
endif|#
directive|endif
name|enum
name|receive_state
name|o_state
decl_stmt|;
comment|/* Receive state */
name|enum
name|posn_mode
name|mode
decl_stmt|;
comment|/* 0D, 2D, 3D */
name|enum
name|site_survey_state
name|site_survey
decl_stmt|;
comment|/* Site Survey state */
name|int
name|Bj_day
decl_stmt|;
name|u_long
name|delay
decl_stmt|;
comment|/* ns */
name|long
name|offset
decl_stmt|;
comment|/* ns */
name|u_char
modifier|*
name|shmem
decl_stmt|;
name|char
modifier|*
name|shmem_fname
decl_stmt|;
name|u_int
name|shmem_Cb
decl_stmt|;
name|u_int
name|shmem_Ba
decl_stmt|;
name|u_int
name|shmem_Ea
decl_stmt|;
name|u_int
name|shmem_Ha
decl_stmt|;
name|u_char
name|shmem_first
decl_stmt|;
name|u_char
name|shmem_reset
decl_stmt|;
name|u_char
name|shmem_Posn
decl_stmt|;
name|double
name|ss_lat
decl_stmt|;
name|double
name|ss_long
decl_stmt|;
name|double
name|ss_ht
decl_stmt|;
name|double
name|dH
decl_stmt|;
name|int
name|ss_count
decl_stmt|;
name|u_char
name|posn_set
decl_stmt|;
name|enum
name|oncore_model
name|model
decl_stmt|;
name|u_int
name|version
decl_stmt|;
name|u_int
name|revision
decl_stmt|;
name|u_char
name|chan
decl_stmt|;
comment|/* 6 for PVT6 or BASIC, 8 for UT/VP, 12 for m12, 0 if unknown */
name|s_char
name|traim
decl_stmt|;
comment|/* do we have traim? yes UT/VP, no BASIC, GT, -1 unknown, 0 no, +1 yes */
name|u_char
name|traim_delay
decl_stmt|;
comment|/* seconds counter, waiting for reply */
name|struct
name|RSM
name|rsm
decl_stmt|;
comment|/* bits extracted from Receiver Status Msg in @@Ea */
name|u_char
name|printed
decl_stmt|;
name|u_char
name|polled
decl_stmt|;
name|int
name|pollcnt
decl_stmt|;
name|u_int
name|ev_serial
decl_stmt|;
name|int
name|Rcvptr
decl_stmt|;
name|u_char
name|Rcvbuf
index|[
literal|500
index|]
decl_stmt|;
name|u_char
name|Ea
index|[
literal|160
index|]
decl_stmt|;
comment|/* Ba, Ea or Ha */
name|u_char
name|En
index|[
literal|70
index|]
decl_stmt|;
comment|/* Bn or En */
name|u_char
name|Cj
index|[
literal|300
index|]
decl_stmt|;
name|u_char
name|As
decl_stmt|;
name|u_char
name|Ay
decl_stmt|;
name|u_char
name|Az
decl_stmt|;
name|u_char
name|have_dH
decl_stmt|;
name|u_char
name|init_type
decl_stmt|;
name|s_char
name|saw_tooth
decl_stmt|;
name|u_int
name|timeout
decl_stmt|;
comment|/* count to retry Cj after Fa self-test */
name|u_char
name|count
decl_stmt|;
comment|/* cycles thru Ea before starting */
name|s_char
name|assert
decl_stmt|;
name|u_int
name|saw_At
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|rcvbuf
value|instance->Rcvbuf
end_define

begin_define
define|#
directive|define
name|rcvptr
value|instance->Rcvptr
end_define

begin_decl_stmt
specifier|static
name|void
name|oncore_consume
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_read_config
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_sendmsg
name|P
argument_list|(
operator|(
name|int
name|fd
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oncore_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_get_timestamp
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|long
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_init_shmem
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_print_As
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_any
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_As
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_At
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Ay
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Az
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_BaEaHa
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Bj
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_BnEn
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_CaFaIa
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cb
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cf
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cj
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cj_id
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cj_init
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Gj
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Sz
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|refclock
name|refclock_oncore
init|=
block|{
name|oncore_start
block|,
comment|/* start up driver */
name|oncore_shutdown
block|,
comment|/* shut down driver */
name|oncore_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used */
name|noentry
block|,
comment|/* not used */
name|noentry
block|,
comment|/* not used */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Understanding the next bit here is not easy unless you have a manual  * for the the various Oncore Models.  */
end_comment

begin_struct
specifier|static
struct|struct
name|msg_desc
block|{
specifier|const
name|char
name|flag
index|[
literal|3
index|]
decl_stmt|;
specifier|const
name|int
name|len
decl_stmt|;
name|void
argument_list|(
argument|*handler
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|shmem
decl_stmt|;
block|}
name|oncore_messages
index|[]
init|=
block|{
comment|/* Ea and En first since they're most common */
block|{
literal|"Ea"
block|,
literal|76
block|,
name|oncore_msg_BaEaHa
block|,
literal|"mdyyhmsffffaaaaoooohhhhmmmmvvhhddtntimsdimsdimsdimsdimsdimsdimsdimsdsC"
block|}
block|,
block|{
literal|"Ba"
block|,
literal|68
block|,
name|oncore_msg_BaEaHa
block|,
literal|"mdyyhmsffffaaaaoooohhhhmmmmvvhhddtntimsdimsdimsdimsdimsdimsdsC"
block|}
block|,
block|{
literal|"Ha"
block|,
literal|154
block|,
name|oncore_msg_BaEaHa
block|,
literal|"mdyyhmsffffaaaaoooohhhhmmmmaaaaoooohhhhmmmmVVvvhhddntimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddssrrccooooTTushmvvvvvvC"
block|}
block|,
block|{
literal|"En"
block|,
literal|69
block|,
name|oncore_msg_BnEn
block|,
literal|"otaapxxxxxxxxxxpysreensffffsffffsffffsffffsffffsffffsffffsffffC"
block|}
block|,
block|{
literal|"Bn"
block|,
literal|59
block|,
name|oncore_msg_BnEn
block|,
literal|"otaapxxxxxxxxxxpysreensffffsffffsffffsffffsffffsffffC"
block|}
block|,
block|{
literal|"Ab"
block|,
literal|10
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ac"
block|,
literal|11
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ad"
block|,
literal|11
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ae"
block|,
literal|11
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Af"
block|,
literal|15
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"As"
block|,
literal|20
block|,
name|oncore_msg_As
block|,
literal|""
block|}
block|,
block|{
literal|"At"
block|,
literal|8
block|,
name|oncore_msg_At
block|,
literal|""
block|}
block|,
block|{
literal|"Au"
block|,
literal|12
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Av"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Aw"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ay"
block|,
literal|11
block|,
name|oncore_msg_Ay
block|,
literal|""
block|}
block|,
block|{
literal|"Az"
block|,
literal|11
block|,
name|oncore_msg_Az
block|,
literal|""
block|}
block|,
block|{
literal|"AB"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Bb"
block|,
literal|92
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Bj"
block|,
literal|8
block|,
name|oncore_msg_Bj
block|,
literal|""
block|}
block|,
block|{
literal|"Ca"
block|,
literal|9
block|,
name|oncore_msg_CaFaIa
block|,
literal|""
block|}
block|,
block|{
literal|"Cb"
block|,
literal|33
block|,
name|oncore_msg_Cb
block|,
literal|""
block|}
block|,
block|{
literal|"Cf"
block|,
literal|7
block|,
name|oncore_msg_Cf
block|,
literal|""
block|}
block|,
block|{
literal|"Cg"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ch"
block|,
literal|9
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Cj"
block|,
literal|294
block|,
name|oncore_msg_Cj
block|,
literal|""
block|}
block|,
block|{
literal|"Ek"
block|,
literal|71
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Fa"
block|,
literal|9
block|,
name|oncore_msg_CaFaIa
block|,
literal|""
block|}
block|,
block|{
literal|"Gd"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Gj"
block|,
literal|21
block|,
name|oncore_msg_Gj
block|,
literal|""
block|}
block|,
block|{
literal|"Ia"
block|,
literal|10
block|,
name|oncore_msg_CaFaIa
block|,
literal|""
block|}
block|,
block|{
literal|"Sz"
block|,
literal|8
block|,
name|oncore_msg_Sz
block|,
literal|""
block|}
block|,
block|{
block|{
literal|0
block|}
block|,
literal|7
block|,
literal|0
block|,
literal|""
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Position Set.  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Ad
index|[]
init|=
block|{
literal|'A'
block|,
literal|'d'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Ae
index|[]
init|=
block|{
literal|'A'
block|,
literal|'e'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Af
index|[]
init|=
block|{
literal|'A'
block|,
literal|'f'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Ga
index|[]
init|=
block|{
literal|'G'
block|,
literal|'a'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Position-Hold Mode  *    Start automatic site survey  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_At0
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Posn Hold off */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_At1
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Posn Hold on  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_At2
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start Site Survey */
end_comment

begin_comment
comment|/*  * 0D/2D Position and Set.  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_As
index|[]
init|=
block|{
literal|'A'
block|,
literal|'s'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Asx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'s'
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Au
index|[]
init|=
block|{
literal|'A'
block|,
literal|'u'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Av0
index|[]
init|=
block|{
literal|'A'
block|,
literal|'v'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Av1
index|[]
init|=
block|{
literal|'A'
block|,
literal|'v'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Gd0
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3D */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Gd1
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0D */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Gd2
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2D */
end_comment

begin_comment
comment|/*  * Set to UTC time (not GPS).  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Aw
index|[]
init|=
block|{
literal|'A'
block|,
literal|'w'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Output Almanac when it changes  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Be
index|[]
init|=
block|{
literal|'B'
block|,
literal|'e'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read back PPS Offset for Output  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Ay
index|[]
init|=
block|{
literal|'A'
block|,
literal|'y'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Ayx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'y'
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read back Cable Delay for Output  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Az
index|[]
init|=
block|{
literal|'A'
block|,
literal|'z'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Azx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'z'
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Application type = static.  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_AB
index|[]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Visible Satellite Status Msg.  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Bb
index|[]
init|=
block|{
literal|'B'
block|,
literal|'b'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Leap Second Pending Message  *    Request message once  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Bj
index|[]
init|=
block|{
literal|'B'
block|,
literal|'j'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Gj
index|[]
init|=
block|{
literal|'G'
block|,
literal|'j'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set to Defaults  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Cf
index|[]
init|=
block|{
literal|'C'
block|,
literal|'f'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set to Position Fix mode (only needed on VP).  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Cg
index|[]
init|=
block|{
literal|'C'
block|,
literal|'g'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Receiver Id  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Cj
index|[]
init|=
block|{
literal|'C'
block|,
literal|'j'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Position/Status/Data message  *    Send once per second  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ea
index|[]
init|=
block|{
literal|'E'
block|,
literal|'a'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ba
index|[]
init|=
block|{
literal|'B'
block|,
literal|'a'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ha
index|[]
init|=
block|{
literal|'H'
block|,
literal|'a'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ea0
index|[]
init|=
block|{
literal|'E'
block|,
literal|'a'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ba0
index|[]
init|=
block|{
literal|'B'
block|,
literal|'a'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Position/Status Extension Msg  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Ek
index|[]
init|=
block|{
literal|'E'
block|,
literal|'k'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* just turn off */
end_comment

begin_comment
comment|/*  * Time Raim Setup& Status Message  *    Send once per second  *    Time-RAIM on  *    Alarm limit 1us  *    PPS on when we have the first sat  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_En
index|[]
init|=
block|{
literal|'E'
block|,
literal|'n'
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_En0
index|[]
init|=
block|{
literal|'E'
block|,
literal|'n'
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bn
index|[]
init|=
block|{
literal|'B'
block|,
literal|'n'
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bn0
index|[]
init|=
block|{
literal|'B'
block|,
literal|'n'
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Self-test  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ca
index|[]
init|=
block|{
literal|'C'
block|,
literal|'a'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  6 Chan */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Fa
index|[]
init|=
block|{
literal|'F'
block|,
literal|'a'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  8 Chan */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ia
index|[]
init|=
block|{
literal|'I'
block|,
literal|'a'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12 Chan */
end_comment

begin_define
define|#
directive|define
name|DEVICE1
value|"/dev/oncore.serial.%d"
end_define

begin_comment
comment|/* name of serial device */
end_comment

begin_define
define|#
directive|define
name|DEVICE2
value|"/dev/oncore.pps.%d"
end_define

begin_comment
comment|/* name of pps device */
end_comment

begin_define
define|#
directive|define
name|INIT_FILE
value|"/etc/ntp.oncore"
end_define

begin_comment
comment|/* optional init file */
end_comment

begin_define
define|#
directive|define
name|SPEED
value|B9600
end_define

begin_comment
comment|/* Oncore Binary speed (9600 bps) */
end_comment

begin_comment
comment|/*  * Assemble and disassemble 32bit signed quantities from a buffer.  *  */
end_comment

begin_comment
comment|/* to buffer, int w, u_char *buf */
end_comment

begin_define
define|#
directive|define
name|w32_buf
parameter_list|(
name|buf
parameter_list|,
name|w
parameter_list|)
value|{ u_int i_tmp;			   \ 			  i_tmp = (w<0) ? (~(-w)+1) : (w); \ 			  (buf)[0] = (i_tmp>> 24)& 0xff; \ 			  (buf)[1] = (i_tmp>> 16)& 0xff; \ 			  (buf)[2] = (i_tmp>>	8)& 0xff; \ 			  (buf)[3] = (i_tmp	 )& 0xff; \ 			}
end_define

begin_define
define|#
directive|define
name|w32
parameter_list|(
name|buf
parameter_list|)
value|(((buf)[0]&0xff)<< 24 | \ 		       ((buf)[1]&0xff)<< 16 | \ 		       ((buf)[2]&0xff)<<  8 | \ 		       ((buf)[3]&0xff) )
end_define

begin_comment
comment|/* from buffer, char *buf, result to an int */
end_comment

begin_define
define|#
directive|define
name|buf_w32
parameter_list|(
name|buf
parameter_list|)
value|(((buf)[0]&0200) ? (-(~w32(buf)+1)) : w32(buf))
end_define

begin_decl_stmt
specifier|extern
name|int
name|pps_assert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pps_hardpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * oncore_start - initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|oncore_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|,
name|mode
decl_stmt|;
name|char
name|device1
index|[
literal|30
index|]
decl_stmt|,
name|device2
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|stat
name|stat1
decl_stmt|,
name|stat2
decl_stmt|;
comment|/* OPEN DEVICES */
comment|/* opening different devices for fd1 and fd2 presents no problems */
comment|/* opening the SAME device twice, seems to be OS dependent. 		(a) on Linux (no streams) no problem 		(b) on SunOS (and possibly Solaris, untested), (streams) 			never see the line discipline. 	   Since things ALWAYS work if we only open the device once, we check 	     to see if the two devices are in fact the same, then proceed to 	     do one open or two. 	*/
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device1
argument_list|,
name|DEVICE1
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device2
argument_list|,
name|DEVICE2
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|device1
argument_list|,
operator|&
name|stat1
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: stat fd1"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|device2
argument_list|,
operator|&
name|stat2
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: stat fd2"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat1
operator|.
name|st_dev
operator|==
name|stat2
operator|.
name|st_dev
operator|)
operator|&&
operator|(
name|stat1
operator|.
name|st_ino
operator|==
name|stat2
operator|.
name|st_ino
operator|)
condition|)
block|{
comment|/* same device here */
if|if
condition|(
operator|!
operator|(
name|fd1
operator|=
name|refclock_open
argument_list|(
name|device1
argument_list|,
name|SPEED
argument_list|,
name|LDISC_RAW
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCDCDTIMESTAMP
argument_list|)
operator||
name|LDISC_PPS
endif|#
directive|endif
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: fd1"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fd2
operator|=
name|fd1
expr_stmt|;
block|}
else|else
block|{
comment|/* different devices here */
if|if
condition|(
operator|!
operator|(
name|fd1
operator|=
name|refclock_open
argument_list|(
name|device1
argument_list|,
name|SPEED
argument_list|,
name|LDISC_RAW
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: fd1"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd2
operator|=
name|open
argument_list|(
name|device2
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: fd2"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Devices now open, create instance structure for this unit */
if|if
condition|(
operator|!
operator|(
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|instance
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|instance
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|instance
argument_list|)
expr_stmt|;
comment|/* link instance up and down */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|instance
expr_stmt|;
name|instance
operator|->
name|pp
operator|=
name|pp
expr_stmt|;
name|instance
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|instance
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
comment|/* initialize miscellaneous variables */
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_NO_IDEA
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_NO_IDEA"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ttyfd
operator|=
name|fd1
expr_stmt|;
name|instance
operator|->
name|ppsfd
operator|=
name|fd2
expr_stmt|;
name|instance
operator|->
name|Bj_day
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|assert
operator|=
name|pps_assert
expr_stmt|;
name|instance
operator|->
name|traim
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UNKNOWN
expr_stmt|;
name|instance
operator|->
name|mode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_UNKNOWN
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
operator|-
literal|26
expr_stmt|;
name|peer
operator|->
name|minpoll
operator|=
literal|4
expr_stmt|;
name|peer
operator|->
name|maxpoll
operator|=
literal|4
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
literal|"Motorola Oncore GPS Receiver"
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
literal|"GPS\0"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
comment|/* go read any input data in /etc/ntp.oncoreX */
name|oncore_read_config
argument_list|(
name|instance
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
if|if
condition|(
name|time_pps_create
argument_list|(
name|fd2
argument_list|,
operator|&
name|instance
operator|->
name|pps_h
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"time_pps_create"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|time_pps_getcap
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getcap failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|time_pps_getparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|instance
operator|->
name|pps_p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getparams failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* nb. only turn things on, if someone else has turned something 	 *	on before we get here, leave it alone! 	 */
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
block|{
comment|/* nb, default or ON */
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator|=
name|PPS_CAPTUREASSERT
operator||
name|PPS_OFFSETASSERT
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|assert_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|assert_offset
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator|=
name|PPS_CAPTURECLEAR
operator||
name|PPS_OFFSETCLEAR
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|clear_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|clear_offset
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator||=
name|PPS_TSFMT_TSPEC
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator|&=
name|mode
expr_stmt|;
comment|/* only set what is legal */
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|instance
operator|->
name|pps_p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"time_pps_setparams"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pps_device
operator|&&
name|pps_device
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|pps_device
argument_list|,
operator|&
name|stat1
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: stat pps_device"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* must have hardpps ON, and fd2 must be the same device as on the pps line */
if|if
condition|(
name|pps_hardpps
operator|&&
operator|(
operator|(
name|stat1
operator|.
name|st_dev
operator|==
name|stat2
operator|.
name|st_dev
operator|)
operator|&&
operator|(
name|stat1
operator|.
name|st_ino
operator|==
name|stat2
operator|.
name|st_ino
operator|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|i
operator|=
name|PPS_CAPTUREASSERT
expr_stmt|;
else|else
name|i
operator|=
name|PPS_CAPTURECLEAR
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|mode
condition|)
block|{
if|if
condition|(
name|time_pps_kcbind
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
name|PPS_KC_HARDPPS
argument_list|,
name|i
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_kcbind failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pps_enable
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|oncore_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd1
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"io_addclock"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|instance
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * This will return the Model Number of the Oncore receiver. 	 */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_ID_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_ID SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|4
expr_stmt|;
name|instance
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read Input file if it exists.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_read_config
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
comment|/*  * First we try to open the configuration file  *    /etc/oncoreN  * where N is the unit number viz 127.127.30.N.  * If we don't find it we try  *    /etc/ntp.oncore.N  * and then  *    /etc/ntp.oncore  *  * If we don't find any then we don't have the cable delay or PPS offset  * and we choose MODE (4) below.  *  * Five Choices for MODE  *    (0) ONCORE is preinitialized, don't do anything to change it.  *	    nb, DON'T set 0D mode, DON'T set Delay, position...  *    (1) NO RESET, Read Position, delays from data file, lock it in, go to 0D mode.  *    (2) NO RESET, Read Delays from data file, do SITE SURVEY to get position,  *		    lock this in, go to 0D mode.  *    (3) HARD RESET, Read Position, delays from data file, lock it in, go to 0D mode.  *    (4) HARD RESET, Read Delays from data file, do SITE SURVEY to get position,  *		    lock this in, go to 0D mode.  *     NB. If a POSITION is specified in the config file with mode=(2,4) [SITE SURVEY]  *	   then this position is set as the INITIAL position of the ONCORE.  *	   This can reduce the time to first fix.  * -------------------------------------------------------------------------------  * Note that an Oncore UT without a battery backup retains NO information if it is  *   power cycled, with a Battery Backup it remembers the almanac, etc.  * For an Oncore VP, there is an eeprom that will contain this data, along with the  *   option of Battery Backup.  * So a UT without Battery Backup is equivalent to doing a HARD RESET on each  *   power cycle, since there is nowhere to store the data.  * -------------------------------------------------------------------------------  *  * If we open one or the other of the files, we read it looking for  *   MODE, LAT, LON, (HT, HTGPS, HTMSL), DELAY, OFFSET, ASSERT, CLEAR, STATUS,  *   POSN3D, POSN2D, CHAN, TRAIM  * then initialize using method MODE.  For Mode = (1,3) all of (LAT, LON, HT) must  *   be present or mode reverts to (2,4).  *  * Read input file.  *  *	# is comment to end of line  *	= allowed between 1st and 2nd fields.  *  *	Expect to see one line with 'MODE' as first field, followed by an integer  *	   in the range 0-4 (default = 4).  *  *	Expect to see two lines with 'LONG', 'LAT' followed by 1-3 fields.  *	All numbers are floating point.  *		DDD.ddd  *		DDD  MMM.mmm  *		DDD  MMM  SSS.sss  *  *	Expect to see one line with 'HT' as first field,  *	   followed by 1-2 fields.  First is a number, the second is 'FT' or 'M'  *	   for feet or meters.	HT is the height above the GPS ellipsoid.  *	   If the reciever reports height in both GPS and MSL, then we will report  *	   the difference GPS-MSL on the clockstats file.  *  *	There is an optional line, starting with DELAY, followed  *	   by 1 or two fields.	The first is a number (a time) the second is  *	   'MS', 'US' or 'NS' for miliseconds, microseconds or nanoseconds.  *	    DELAY  is cable delay, typically a few tens of ns.  *  *	There is an optional line, starting with OFFSET, followed  *	   by 1 or two fields.	The first is a number (a time) the second is  *	   'MS', 'US' or 'NS' for miliseconds, microseconds or nanoseconds.  *	   OFFSET is the offset of the PPS pulse from 0. (only fully implemented  *		with the PPSAPI, we need to be able to tell the Kernel about this  *		offset if the Kernel PLL is in use, but can only do this presently  *		when using the PPSAPI interface.  If not using the Kernel PLL,  *		then there is no problem.  *  *	There is an optional line, with either ASSERT or CLEAR on it, which  *	   determine which transition of the PPS signal is used for timing by the  *	   PPSAPI.  If neither is present, then ASSERT is assumed.  *  *	There are three options that have to do with using the shared memory opition.  *	   First, to enable the option there must be an ASSERT line with a file name.  *	   The file name is the file associated with the shared memory.  *  *	In the shared memory there are three 'records' containing the @@Ea (or equivalent)  *	   data, and this contains the position data.  There will always be data in the  *	   record cooresponding to the '0D' @@Ea record, and the user has a choice of  *	   filling the '3D' @@Ea record by specifying POSN3D, or the '2D' record by  *	   specifying POSN2D.  In either case the '2D' or '3D' record is filled once  *	   every 15s.  *  *	Two additional variables that can be set are CHAN and TRAIM.  These should be  *	   set correctly by the code examining the @@Cj record, but we bring them out here  *	   to allow the user to override either the # of channels, or the existance of TRAIM.  *	   CHAN expects to be followed by in integer: 6, 8, or 12. TRAIM expects to be  *	   followed by YES or NO.  *  * So acceptable input would be  *	# these are my coordinates (RWC)  *	LON  -106 34.610  *	LAT    35 08.999  *	HT	1589	# could equally well say HT 5215 FT  *	DELAY  60 ns  */
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cc
decl_stmt|,
modifier|*
name|ca
decl_stmt|,
name|line
index|[
literal|100
index|]
decl_stmt|,
name|units
index|[
literal|2
index|]
decl_stmt|,
name|device
index|[
literal|20
index|]
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sign
decl_stmt|,
name|lat_flg
decl_stmt|,
name|long_flg
decl_stmt|,
name|ht_flg
decl_stmt|,
name|mode
decl_stmt|;
name|double
name|f1
decl_stmt|,
name|f2
decl_stmt|,
name|f3
decl_stmt|;
name|sprintf
argument_list|(
name|device
argument_list|,
literal|"%s%d"
argument_list|,
name|INIT_FILE
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* try "ntp.oncore0" first */
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|device
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/*   it was in the original documentation */
name|sprintf
argument_list|(
name|device
argument_list|,
literal|"%s.%d"
argument_list|,
name|INIT_FILE
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* then try "ntp.oncore.0 */
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|device
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|INIT_FILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* and finally "ntp.oncore" */
name|instance
operator|->
name|init_type
operator|=
literal|4
expr_stmt|;
return|return;
block|}
block|}
block|}
name|mode
operator|=
literal|0
expr_stmt|;
name|lat_flg
operator|=
name|long_flg
operator|=
name|ht_flg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|100
argument_list|,
name|fd
argument_list|)
condition|)
block|{
comment|/* Remove comments */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'#'
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove trailing space */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
init|;
name|i
operator|>
literal|0
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
name|line
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|line
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|;
control|)
name|line
index|[
operator|--
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove leading space */
for|for
control|(
name|cc
operator|=
name|line
init|;
operator|*
name|cc
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|)
condition|;
name|cc
operator|++
control|)
continue|continue;
comment|/* Stop if nothing left */
if|if
condition|(
operator|!
operator|*
name|cc
condition|)
continue|continue;
comment|/* Uppercase the command and find the arg */
for|for
control|(
name|ca
operator|=
name|cc
init|;
operator|*
name|ca
condition|;
name|ca
operator|++
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
condition|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
condition|)
block|{
operator|*
name|ca
operator|=
name|toupper
argument_list|(
operator|*
name|ca
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|||
operator|(
operator|*
name|ca
operator|==
literal|'='
operator|)
condition|)
break|break;
block|}
block|}
comment|/* Remove space (and possible =) leading the arg */
for|for
control|(
init|;
operator|*
name|ca
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|&&
operator|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|||
operator|(
operator|*
name|ca
operator|==
literal|'='
operator|)
operator|)
condition|;
name|ca
operator|++
control|)
continue|continue;
comment|/* 		 * move call to oncore_shmem_init() from here to after 		 * we have determined Oncore Model, so we can ignore 		 * request if model doesnt 'support' it 		 */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"STATUS"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"SHMEM"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|ca
argument_list|)
expr_stmt|;
name|instance
operator|->
name|shmem_fname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|,
name|ca
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Uppercase argument as well */
for|for
control|(
name|cp
operator|=
name|ca
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|&&
name|islower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"LAT"
argument_list|,
operator|(
name|size_t
operator|)
literal|3
argument_list|)
condition|)
block|{
name|f1
operator|=
name|f2
operator|=
name|f3
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %lf %lf"
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|,
operator|&
name|f3
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
condition|)
block|{
name|f1
operator|=
operator|-
name|f1
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|instance
operator|->
name|ss_lat
operator|=
name|sign
operator|*
literal|1000
operator|*
operator|(
name|fabs
argument_list|(
name|f3
argument_list|)
operator|+
literal|60
operator|*
operator|(
name|fabs
argument_list|(
name|f2
argument_list|)
operator|+
literal|60
operator|*
name|f1
operator|)
operator|)
expr_stmt|;
comment|/*miliseconds*/
name|lat_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"LON"
argument_list|,
operator|(
name|size_t
operator|)
literal|3
argument_list|)
condition|)
block|{
name|f1
operator|=
name|f2
operator|=
name|f3
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %lf %lf"
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|,
operator|&
name|f3
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
condition|)
block|{
name|f1
operator|=
operator|-
name|f1
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|instance
operator|->
name|ss_long
operator|=
name|sign
operator|*
literal|1000
operator|*
operator|(
name|fabs
argument_list|(
name|f3
argument_list|)
operator|+
literal|60
operator|*
operator|(
name|fabs
argument_list|(
name|f2
argument_list|)
operator|+
literal|60
operator|*
name|f1
operator|)
operator|)
expr_stmt|;
comment|/*miliseconds*/
name|long_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"HT"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'F'
condition|)
name|f1
operator|=
literal|0.3048
operator|*
name|f1
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
literal|100
operator|*
name|f1
expr_stmt|;
comment|/* cm */
name|ht_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"DELAY"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'U'
condition|)
name|f1
operator|=
literal|1000
operator|*
name|f1
expr_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
name|f1
operator|=
literal|1000000
operator|*
name|f1
expr_stmt|;
else|else
name|f1
operator|=
literal|1000000000
operator|*
name|f1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|1.e9
condition|)
name|f1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|999999
condition|)
block|{
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"PPS Cable delay of %fns out of Range, ignored"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
else|else
name|instance
operator|->
name|delay
operator|=
name|f1
expr_stmt|;
comment|/* delay in ns */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"OFFSET"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'U'
condition|)
name|f1
operator|=
literal|1000
operator|*
name|f1
expr_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
name|f1
operator|=
literal|1000000
operator|*
name|f1
expr_stmt|;
else|else
name|f1
operator|=
literal|1000000000
operator|*
name|f1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|1.e9
condition|)
name|f1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|999999999.
condition|)
block|{
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"PPS Offset of %fns out of Range, ignored"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
else|else
name|instance
operator|->
name|offset
operator|=
name|f1
expr_stmt|;
comment|/* offset in ns */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"MODE"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
literal|0
operator|||
name|mode
operator|>
literal|4
condition|)
name|mode
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"ASSERT"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|instance
operator|->
name|assert
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"CLEAR"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|instance
operator|->
name|assert
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"POSN2D"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Posn
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"POSN3D"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Posn
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"CHAN"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|6
operator|)
operator|||
operator|(
name|i
operator|==
literal|8
operator|)
operator|||
operator|(
name|i
operator|==
literal|12
operator|)
condition|)
name|instance
operator|->
name|chan
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"TRAIM"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|instance
operator|->
name|traim
operator|=
literal|1
expr_stmt|;
comment|/* so TRAIM alone is YES */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ca
argument_list|,
literal|"NO"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ca
argument_list|,
literal|"OFF"
argument_list|)
condition|)
comment|/* Yes/No, On/Off */
name|instance
operator|->
name|traim
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 *    OK, have read all of data file, and extracted the good stuff. 	 *    If lat/long/ht specified they ALL must be specified for mode = (1,3). 	 */
name|instance
operator|->
name|posn_set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|lat_flg
operator|||
name|long_flg
operator|||
name|ht_flg
operator|)
operator|&&
operator|!
operator|(
name|lat_flg
operator|*
name|long_flg
operator|*
name|ht_flg
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: incomplete data on %s\n"
argument_list|,
name|INIT_FILE
argument_list|)
expr_stmt|;
name|instance
operator|->
name|posn_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|1
operator|||
name|mode
operator|==
literal|3
condition|)
block|{
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Input Mode = %d, but no/incomplete position, mode set to %d"
argument_list|,
name|mode
argument_list|,
name|mode
operator|+
literal|1
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|mode
operator|++
expr_stmt|;
block|}
block|}
name|instance
operator|->
name|init_type
operator|=
name|mode
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Input mode = %d"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_init_shmem
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ONCORE_SHMEM_STATUS
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|msg_desc
modifier|*
name|mp
decl_stmt|;
name|size_t
name|oncore_shmem_length
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem_first
condition|)
return|return;
name|instance
operator|->
name|shmem_first
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|instance
operator|->
name|statusfd
operator|=
name|open
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|oncore_messages
init|;
name|mp
operator|->
name|flag
index|[
literal|0
index|]
condition|;
name|mp
operator|++
control|)
block|{
name|mp
operator|->
name|shmem
operator|=
name|n
expr_stmt|;
comment|/* Allocate space for multiplexed almanac, and 0D/2D/3D @@Ea records */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Cb
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|34
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ba"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Ba
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ea"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Ea
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ha"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Ha
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|3
expr_stmt|;
block|}
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
expr_stmt|;
block|}
name|oncore_shmem_length
operator|=
name|n
operator|+
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ONCORE: SHMEM length: %d bytes\n"
argument_list|,
operator|(
name|int
operator|)
name|oncore_shmem_length
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|oncore_shmem_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|write
argument_list|(
name|instance
operator|->
name|statusfd
argument_list|,
name|buf
argument_list|,
name|oncore_shmem_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|oncore_shmem_length
condition|)
block|{
name|perror
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|instance
operator|->
name|shmem
operator|=
operator|(
name|u_char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|oncore_shmem_length
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
ifdef|#
directive|ifdef
name|MAP_HASSEMAPHORE
name|MAP_HASSEMAPHORE
operator||
endif|#
directive|endif
name|MAP_SHARED
argument_list|,
name|instance
operator|->
name|statusfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem
operator|==
operator|(
name|u_char
operator|*
operator|)
name|MAP_FAILED
condition|)
block|{
name|instance
operator|->
name|shmem
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|instance
operator|->
name|statusfd
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|mp
operator|=
name|oncore_messages
init|;
name|mp
operator|->
name|flag
index|[
literal|0
index|]
condition|;
name|mp
operator|++
control|)
block|{
name|l
operator|=
name|mp
operator|->
name|shmem
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|0
index|]
operator|=
name|mp
operator|->
name|len
operator|>>
literal|8
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|1
index|]
operator|=
name|mp
operator|->
name|len
operator|&
literal|0xff
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|3
index|]
operator|=
literal|'@'
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|4
index|]
operator|=
literal|'@'
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|5
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|0
index|]
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|6
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ba"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ea"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ha"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
condition|)
name|n
operator|=
literal|35
expr_stmt|;
else|else
name|n
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|0
index|]
operator|=
name|mp
operator|->
name|len
operator|>>
literal|8
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|1
index|]
operator|=
name|mp
operator|->
name|len
operator|&
literal|0xff
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|3
index|]
operator|=
literal|'@'
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|4
index|]
operator|=
literal|'@'
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|5
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|0
index|]
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|6
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* ONCORE_SHMEM_STATUS */
block|}
end_function

begin_comment
comment|/*  * oncore_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|oncore_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * oncore_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|oncore_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|timeout
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|instance
operator|->
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
literal|"Oncore: No response from @@Cj, shutting down driver"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_shutdown
argument_list|(
name|unit
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
literal|"Oncore: Resend @@Cj"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|instance
operator|->
name|pollcnt
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|instance
operator|->
name|pollcnt
operator|--
expr_stmt|;
name|peer
operator|->
name|procptr
operator|->
name|polls
operator|++
expr_stmt|;
name|instance
operator|->
name|polled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * move data from NTP to buffer (toss in unlikely case it wont fit)  */
end_comment

begin_function
specifier|static
name|void
name|oncore_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
if|#
directive|if
literal|0
block|if (debug> 4) { 		int i; 		printf("ONCORE:>>>"); 		for(i=0; i<rbufp->recv_length; i++) 			printf("%02x ", p[i]); 		printf("\n"); 		printf("ONCORE:>>>"); 		for(i=0; i<rbufp->recv_length; i++) 			printf("%03o ", p[i]); 		printf("\n"); 	}
endif|#
directive|endif
name|i
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|rcvbuf
operator|+
name|rcvptr
operator|+
name|i
operator|>
operator|&
name|rcvbuf
index|[
sizeof|sizeof
name|rcvbuf
index|]
condition|)
name|i
operator|=
sizeof|sizeof
argument_list|(
name|rcvbuf
argument_list|)
operator|-
name|rcvptr
expr_stmt|;
comment|/* and some char will be lost */
name|memcpy
argument_list|(
name|rcvbuf
operator|+
name|rcvptr
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rcvptr
operator|+=
name|i
expr_stmt|;
name|oncore_consume
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deal with any complete messages  */
end_comment

begin_function
specifier|static
name|void
name|oncore_consume
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|m
decl_stmt|;
name|unsigned
name|l
decl_stmt|;
while|while
condition|(
name|rcvptr
operator|>=
literal|7
condition|)
block|{
if|if
condition|(
name|rcvbuf
index|[
literal|0
index|]
operator|!=
literal|'@'
operator|||
name|rcvbuf
index|[
literal|1
index|]
operator|!=
literal|'@'
condition|)
block|{
comment|/* We're not in sync, lets try to get there */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rcvptr
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rcvbuf
index|[
name|i
index|]
operator|==
literal|'@'
operator|&&
name|rcvbuf
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'@'
condition|)
break|break;
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"ONCORE[%d]:>>> skipping %d chars\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|rcvptr
condition|)
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
name|i
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|rcvptr
operator|-
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* Ok, we have a header now */
name|l
operator|=
sizeof|sizeof
argument_list|(
name|oncore_messages
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|oncore_messages
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|l
condition|;
name|m
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|oncore_messages
index|[
name|m
index|]
operator|.
name|flag
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|rcvbuf
operator|+
literal|2
operator|)
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|l
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"ONCORE[%d]:>>> Unknown MSG, skipping 4 (%c%c)\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|rcvbuf
index|[
literal|2
index|]
argument_list|,
name|rcvbuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
literal|4
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
literal|4
expr_stmt|;
continue|continue;
block|}
name|l
operator|=
name|oncore_messages
index|[
name|m
index|]
operator|.
name|len
expr_stmt|;
if|#
directive|if
literal|0
block|if (debug> 3) 			printf("ONCORE[%d]: GOT: %c%c  %d of %d entry %d\n", instance->unit, rcvbuf[2], rcvbuf[3], rcvptr, l, m);
endif|#
directive|endif
comment|/* Got the entire message ? */
if|if
condition|(
name|rcvptr
operator|<
name|l
condition|)
return|return;
comment|/* are we at the end of message? should be<Cksum><CR><LF> */
if|if
condition|(
name|rcvbuf
index|[
name|l
operator|-
literal|2
index|]
operator|!=
literal|'\r'
operator|||
name|rcvbuf
index|[
name|l
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ONCORE[%d]: NO<CR><LF> at end of message\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* check the CheckSum */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|l
operator|-
literal|3
condition|;
name|i
operator|++
control|)
name|j
operator|^=
name|rcvbuf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|rcvbuf
index|[
name|l
operator|-
literal|3
index|]
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|shmem
operator|!=
name|NULL
condition|)
block|{
name|instance
operator|->
name|shmem
index|[
name|oncore_messages
index|[
name|m
index|]
operator|.
name|shmem
operator|+
literal|2
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|instance
operator|->
name|shmem
operator|+
name|oncore_messages
index|[
name|m
index|]
operator|.
name|shmem
operator|+
literal|3
argument_list|,
name|rcvbuf
argument_list|,
operator|(
name|size_t
operator|)
name|l
argument_list|)
expr_stmt|;
block|}
name|oncore_msg_any
argument_list|(
name|instance
argument_list|,
name|rcvbuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|l
operator|-
literal|3
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|oncore_messages
index|[
name|m
index|]
operator|.
name|handler
condition|)
name|oncore_messages
index|[
name|m
index|]
operator|.
name|handler
argument_list|(
name|instance
argument_list|,
name|rcvbuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|l
operator|-
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE[%d]: Checksum mismatch! calc %o is %o\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|j
argument_list|,
name|rcvbuf
index|[
name|l
operator|-
literal|3
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ONCORE[%d]: @@%c%c "
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|rcvbuf
index|[
literal|2
index|]
argument_list|,
name|rcvbuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%03o "
argument_list|,
name|rcvbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l
operator|!=
name|rcvptr
condition|)
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
name|l
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|rcvptr
operator|-
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
name|l
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * write message to Oncore.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_sendmsg
parameter_list|(
name|int
name|fd
parameter_list|,
name|u_char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u_char
name|cs
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"ONCORE: Send @@%c%c %d\n"
argument_list|,
name|ptr
index|[
literal|0
index|]
argument_list|,
name|ptr
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
literal|"@@"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|cs
operator|^=
operator|*
name|ptr
operator|++
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|cs
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
literal|"\r\n"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print Oncore response message.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_any
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|oncore_messages
index|[
name|idx
index|]
operator|.
name|fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
name|struct
name|timespec
name|ts
decl_stmt|;
endif|#
directive|endif
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
operator|(
name|void
operator|)
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"ONCORE[%d]: %ld.%06ld\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|fmt
condition|)
block|{
name|printf
argument_list|(
literal|">>@@%c%c "
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|len
operator|&&
name|i
operator|<
literal|2400
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"##"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fmt
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%c%c"
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fmt
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Demultiplex the almanac into shmem  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cb
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|5
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|4
operator|&&
name|buf
index|[
literal|5
index|]
operator|<=
literal|5
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
operator|+
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|4
operator|&&
name|buf
index|[
literal|5
index|]
operator|<=
literal|10
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
operator|+
literal|23
expr_stmt|;
else|else
name|i
operator|=
literal|34
expr_stmt|;
name|i
operator|*=
literal|36
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Cb
operator|+
name|i
operator|+
literal|2
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|instance
operator|->
name|shmem
operator|+
name|instance
operator|->
name|shmem_Cb
operator|+
name|i
operator|+
literal|3
argument_list|,
name|buf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|len
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We do an @@Cj twice in the initialization sequence.  * o Once at the very beginning to get the Model number so we know what commands  *   we can issue,  * o And once later after we have done a reset and test, (which may hang),  *   as we are about to initialize the Oncore and start it running.  * o We have one routine below for each case.  */
end_comment

begin_comment
comment|/*  * Determine the Type from the Model #, this determines #chan and if TRAIM is  *   available.  We use ONLY the #chans, and determint TRAIM by trying it.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|memcpy
argument_list|(
name|instance
operator|->
name|Cj
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_ID_SENT
condition|)
name|oncore_msg_Cj_id
argument_list|(
name|instance
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_INIT
condition|)
name|oncore_msg_Cj_init
argument_list|(
name|instance
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The information on determing a Oncore 'Model', viz VP, UT, etc, from  *	the Model Number comes from "Richard M. Hambly"<rick@cnssys.com>  *	and from Motorola.  Until recently Rick was the only source of  *	this information as Motorola didnt give the information out.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cj_id
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
name|Model
index|[
literal|21
index|]
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* Write Receiver ID message to clockstats file */
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|instance
operator|->
name|Cj
init|;
name|cp
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
condition|;
control|)
block|{
name|cp1
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp1
condition|)
name|cp1
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
expr_stmt|;
operator|*
name|cp1
operator|=
literal|'\0'
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|=
literal|'\r'
expr_stmt|;
name|cp
operator|=
name|cp1
operator|+
literal|2
expr_stmt|;
block|}
comment|/* next, the Firmware Version and Revision numbers */
name|instance
operator|->
name|version
operator|=
name|atoi
argument_list|(
operator|&
name|instance
operator|->
name|Cj
index|[
literal|83
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|revision
operator|=
name|atoi
argument_list|(
operator|&
name|instance
operator|->
name|Cj
index|[
literal|111
index|]
argument_list|)
expr_stmt|;
comment|/* from model number decide which Oncore this is, 		and then the number of channels */
for|for
control|(
name|cp
operator|=
operator|&
name|instance
operator|->
name|Cj
index|[
literal|160
index|]
init|;
operator|*
name|cp
operator|==
literal|' '
condition|;
name|cp
operator|++
control|)
comment|/* start right after 'Model #' */
empty_stmt|;
name|cp1
operator|=
name|cp
expr_stmt|;
name|cp2
operator|=
name|Model
expr_stmt|;
for|for
control|(
init|;
operator|!
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|&&
name|cp
operator|-
name|cp1
operator|<
literal|20
condition|;
name|cp
operator|++
operator|,
name|cp2
operator|++
control|)
operator|*
name|cp2
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|Model
argument_list|,
literal|"PVT6"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|cp
operator|=
literal|"PVT6"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_PVT6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'A'
condition|)
block|{
name|cp
operator|=
literal|"Basic"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_BASIC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'B'
operator|||
operator|!
name|strncmp
argument_list|(
name|Model
argument_list|,
literal|"T8"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
condition|)
block|{
name|cp
operator|=
literal|"VP"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_VP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|Model
argument_list|,
literal|"P1"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
condition|)
block|{
name|cp
operator|=
literal|"M12"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_M12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'R'
condition|)
block|{
if|if
condition|(
name|Model
index|[
literal|5
index|]
operator|==
literal|'N'
condition|)
block|{
name|cp
operator|=
literal|"GT"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_GT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'3'
operator|||
name|Model
index|[
literal|1
index|]
operator|==
literal|'4'
operator|)
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'G'
condition|)
block|{
name|cp
operator|=
literal|"GT+"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_GTPLUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'5'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'U'
operator|)
operator|||
operator|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'1'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'A'
operator|)
condition|)
block|{
name|cp
operator|=
literal|"UT"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'5'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'G'
condition|)
block|{
name|cp
operator|=
literal|"UT+"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UTPLUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'6'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'G'
condition|)
block|{
name|cp
operator|=
literal|"SL"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_SL
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
literal|"Unknown"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UNKNOWN
expr_stmt|;
block|}
block|}
else|else
block|{
name|cp
operator|=
literal|"Unknown"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UNKNOWN
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"This looks like an Oncore %s with version %d.%d firmware."
argument_list|,
name|cp
argument_list|,
name|instance
operator|->
name|version
argument_list|,
name|instance
operator|->
name|revision
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|0
condition|)
block|{
comment|/* dont reset if set in input data */
name|instance
operator|->
name|chan
operator|=
literal|8
expr_stmt|;
comment|/* default */
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_BASIC
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_PVT6
condition|)
name|instance
operator|->
name|chan
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_VP
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UT
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UTPLUS
condition|)
name|instance
operator|->
name|chan
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_M12
condition|)
name|instance
operator|->
name|chan
operator|=
literal|12
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|->
name|traim
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* dont reset if set in input data */
name|instance
operator|->
name|traim
operator|=
literal|0
expr_stmt|;
comment|/* default */
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_BASIC
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_PVT6
condition|)
name|instance
operator|->
name|traim
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_VP
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UT
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UTPLUS
condition|)
name|instance
operator|->
name|traim
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_M12
condition|)
name|instance
operator|->
name|traim
operator|=
literal|0
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Channels = %d, TRAIM = %s"
argument_list|,
name|instance
operator|->
name|chan
argument_list|,
operator|(
operator|(
name|instance
operator|->
name|traim
operator|<
literal|0
operator|)
condition|?
literal|"UNKNOWN"
else|:
operator|(
operator|(
name|instance
operator|->
name|traim
operator|>
literal|0
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
comment|/* The M12 with 1.3 Firmware, looses track of all Satellites and has to 	 * start again if we go from 0D -> 3D, then looses them again when we 	 * go from 3D -> 0D.  We do this to get a @@Ea message for SHMEM. 	 * For NOW we have SHMEM turned off for the M12, v1.3 	 */
comment|/*BAD M12*/
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_M12
operator|&&
name|instance
operator|->
name|version
operator|==
literal|1
operator|&&
name|instance
operator|->
name|revision
operator|<=
literal|3
condition|)
block|{
name|instance
operator|->
name|shmem_fname
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
literal|"*** SHMEM turned off for ONCORE M12 ***"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * we now know model number and have zeroed 	 * instance->shmem_fname if SHMEM is not supported 	 */
if|if
condition|(
name|instance
operator|->
name|shmem_fname
condition|)
empty_stmt|;
name|oncore_init_shmem
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem
condition|)
name|cp
operator|=
literal|"SHMEM is available"
expr_stmt|;
else|else
name|cp
operator|=
literal|"SHMEM is NOT available"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|cp
operator|=
literal|"Timing on Assert."
expr_stmt|;
else|else
name|cp
operator|=
literal|"Timing on Clear."
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|3
operator|||
name|mode
operator|==
literal|4
condition|)
block|{
comment|/* Cf will call Fa */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cf
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cf
argument_list|)
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_RESET_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_RESET_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ca
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ca
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Fa
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Fa
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ia
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ia
argument_list|)
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_TEST_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_TEST_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_msg_Cj_init
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|Cmd
index|[
literal|20
index|]
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* OK, know type of Oncore, have possibly reset, and have tested. 	 * If we have or don't have TRAIM and position hold may still be unknown. 	 * Now initialize. 	 */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cg
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set Posn Fix mode (not Idle (VP)) */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bb
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* turn on for shmem */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ek
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ek
argument_list|)
argument_list|)
expr_stmt|;
comment|/* turn off */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Aw
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Aw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* UTC time */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_AB
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_AB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Appl type static */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Be
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Be
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell us the Almanac for shmem */
comment|/* Turn OFF position hold, it needs to be off to set position (for some units), 	   will get set ON in @@Ea later */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE[%d]: INIT mode = %d\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ONCORE[%d]: chan = %d\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|instance
operator|->
name|chan
argument_list|)
expr_stmt|;
block|}
comment|/* If there is Position input in the Config file 	 * and mode = (1,3) set it as posn hold posn, goto 0D mode. 	 *  or mode = (2,4) set it as INITIAL position, and do Site Survey. 	 */
if|if
condition|(
name|instance
operator|->
name|posn_set
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
comment|/* if we have a position, put it in as posn and posn-hold posn */
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_As
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_As
argument_list|)
argument_list|)
expr_stmt|;
comment|/* dont modify static variables */
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|6
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|10
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_As
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Au
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Au
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Au
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ga
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ga
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|6
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|10
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ga
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ad
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ad
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ad
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ae
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ae
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ae
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Af
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Af
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Af
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* NO initialization, don't change anything */
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|3
case|:
comment|/* Use given Position */
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|4
case|:
comment|/* Site Survey */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
comment|/* no 12chan site survey command */
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_SW
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Initiating software 3D site survey (%d samples)"
argument_list|,
name|POS_HOLD_AVERAGE
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_TESTING
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At2
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|mode
operator|!=
literal|0
condition|)
block|{
comment|/* cable delay in ns */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Az
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Az
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|2
index|]
argument_list|,
name|instance
operator|->
name|delay
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Az
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PPS offset in ns */
if|if
condition|(
name|instance
operator|->
name|offset
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_VP
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UT
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UTPLUS
condition|)
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ay
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ay
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|2
index|]
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ay
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
literal|"Can only set PPS OFFSET for VP/UT/UT+, offset ignored"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* 6, 8 12 chan - Position/Status/Data Output Message, 1/s */
comment|/* now we're really running */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
block|{
comment|/* kill 8 chan commands, possibly testing VP in 6chan mode */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ba
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ba
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ea0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ea0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_En0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_En0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
comment|/* kill 6chan commands */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ea
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ea
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ba0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ba0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bn0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bn0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ha
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ha
argument_list|)
argument_list|)
expr_stmt|;
name|instance
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_ALMANAC
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_ALMANAC"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set to Factory Defaults (Reasonable for UT w/ no Battery Backup  *	not so for VP (eeprom) or any unit with a battery  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cf
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_RESET_SENT
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ca
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ca
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Fa
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Fa
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ia
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ia
argument_list|)
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_TEST_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_TEST_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Here for @@Ca, @@Fa and @@Ia messages */
end_comment

begin_comment
comment|/* There are good reasons NOT to do a @@Ca or @@Fa command with the ONCORE.  * Doing it, it was found that under some circumstances the following  * command would fail if issued immediately after the return from the  * @@Fa, but a 2sec delay seemed to fix things.  Since simply calling  * sleep(2) is wastefull, and may cause trouble for some OS's, repeating  * itimer, we set a flag, and test it at the next POLL.  If it hasnt  * been cleared, we reissue the @@Cj that is issued below.  * Note that we do a @@Cj at the beginning, and again here.  * The first is to get the info, the 2nd is just used as a safe command  * after the @@Fa for all Oncores (and it was in this posn in the  * original code).  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_CaFaIa
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_TEST_SENT
condition|)
block|{
name|int
name|antenna
decl_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'I'
condition|)
name|printf
argument_list|(
literal|"ONCORE[%d]:>>@@%ca %x %x %x\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|,
name|buf
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ONCORE[%d]:>>@@%ca %x %x\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|antenna
operator|=
name|buf
index|[
literal|4
index|]
operator|&
literal|0xc0
expr_stmt|;
name|antenna
operator|>>=
literal|6
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|&=
operator|~
literal|0xc0
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|||
name|buf
index|[
literal|5
index|]
operator|||
operator|(
operator|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'I'
operator|)
operator|&&
name|buf
index|[
literal|6
index|]
operator|)
condition|)
block|{
name|cp
operator|=
literal|"ONCORE: Self Test Failed, shutting down driver"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_shutdown
argument_list|(
name|instance
operator|->
name|unit
argument_list|,
name|instance
operator|->
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|antenna
condition|)
block|{
name|char
modifier|*
name|cp1
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|cp1
operator|=
operator|(
name|antenna
operator|==
literal|0x1
operator|)
condition|?
literal|"(Over Current)"
else|:
operator|(
operator|(
name|antenna
operator|==
literal|0x2
operator|)
condition|?
literal|"(Under Current)"
else|:
literal|"(No Voltage)"
operator|)
expr_stmt|;
name|cp
operator|=
literal|"ONCORE: Self Test, NonFatal Antenna Problems "
expr_stmt|;
name|strcpy
argument_list|(
name|Msg
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|Msg
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_INIT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_INIT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ba, Ea and Ha come here */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_BaEaHa
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|,
name|Cmd
index|[
literal|20
index|]
decl_stmt|;
name|u_char
modifier|*
name|vp
decl_stmt|;
comment|/* pointer to start of shared mem for Ba/Ea/Ha */
name|size_t
name|Len
decl_stmt|;
comment|/* At the beginning of Ea here there are various 'timers'. 	 * We enter Ea 1/sec, and since the upper levels of NTP have usurped 	 * the use of timers, we use the 1/sec entry to Ea to do things that 	 * we would normally do with timers... 	 */
if|if
condition|(
name|instance
operator|->
name|count
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|count
operator|++
operator|<
literal|5
condition|)
comment|/* make sure results are stable, using position */
return|return;
name|instance
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_ALMANAC
operator|&&
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_RUN
condition|)
return|return;
name|Len
operator|=
name|len
operator|+
literal|3
expr_stmt|;
comment|/* message length @@ -> CR,LF */
name|memcpy
argument_list|(
name|instance
operator|->
name|Ea
argument_list|,
name|buf
argument_list|,
name|Len
argument_list|)
expr_stmt|;
comment|/* Ba, Ea or Ha */
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'B'
condition|)
block|{
comment|/* 6chan */
if|if
condition|(
name|instance
operator|->
name|Ea
index|[
literal|64
index|]
operator|&
literal|0x8
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_0D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|Ea
index|[
literal|64
index|]
operator|&
literal|0x10
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_2D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|Ea
index|[
literal|64
index|]
operator|&
literal|0x20
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_3D
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* 8chan */
if|if
condition|(
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
operator|&
literal|0x8
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_0D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
operator|&
literal|0x10
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_2D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
operator|&
literal|0x20
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_3D
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'H'
condition|)
block|{
comment|/* 12chan */
name|int
name|bits
decl_stmt|;
name|bits
operator|=
operator|(
name|instance
operator|->
name|Ea
index|[
literal|129
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
expr_stmt|;
comment|/* actually Ha */
if|if
condition|(
name|bits
operator|==
literal|0x4
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_0D
expr_stmt|;
elseif|else
if|if
condition|(
name|bits
operator|==
literal|0x6
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_2D
expr_stmt|;
elseif|else
if|if
condition|(
name|bits
operator|==
literal|0x7
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_3D
expr_stmt|;
block|}
name|vp
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
comment|/* just to keep compiler happy */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
block|{
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
operator|=
name|instance
operator|->
name|Ea
index|[
literal|64
index|]
operator|&
literal|0x1
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
operator|=
name|instance
operator|->
name|Ea
index|[
literal|64
index|]
operator|&
literal|0x52
expr_stmt|;
name|vp
operator|=
operator|&
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Ba
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
operator|=
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
operator|&
literal|0x1
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
operator|=
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
operator|&
literal|0x52
expr_stmt|;
name|vp
operator|=
operator|&
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Ea
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|int
name|bits1
decl_stmt|,
name|bits2
decl_stmt|;
name|bits1
operator|=
operator|(
name|instance
operator|->
name|Ea
index|[
literal|129
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
expr_stmt|;
comment|/* actually Ha */
name|bits2
operator|=
name|instance
operator|->
name|Ea
index|[
literal|130
index|]
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
operator|=
operator|(
name|bits2
operator|&
literal|0x80
operator|)
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
operator|=
operator|(
name|bits2
operator|&
literal|0x8
operator|)
operator|||
operator|(
name|bits1
operator|==
literal|0x2
operator|)
expr_stmt|;
comment|/* too few sat     Bad Geom	  */
name|vp
operator|=
operator|&
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Ha
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf(stderr, "ONCORE: DEBUG BITS: (%x %x), (%x %x),  %x %x %x %x %x\n", 		instance->Ea[129], instance->Ea[130], bits1, bits2, instance->mode == MODE_0D, instance->mode == MODE_2D, 		instance->mode == MODE_3D, instance->rsm.bad_almanac, instance->rsm.bad_fix);
endif|#
directive|endif
block|}
comment|/* Here calculate dH = GPS - MSL for output message */
comment|/* also set Altitude Hold mode if GT */
if|if
condition|(
operator|!
name|instance
operator|->
name|have_dH
condition|)
block|{
name|int
name|GPS
decl_stmt|,
name|MSL
decl_stmt|;
name|instance
operator|->
name|have_dH
operator|++
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|GPS
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|Ea
index|[
literal|39
index|]
argument_list|)
expr_stmt|;
name|MSL
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|Ea
index|[
literal|43
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GPS
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|Ea
index|[
literal|23
index|]
argument_list|)
expr_stmt|;
name|MSL
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|Ea
index|[
literal|27
index|]
argument_list|)
expr_stmt|;
block|}
name|instance
operator|->
name|dH
operator|=
name|GPS
operator|-
name|MSL
expr_stmt|;
name|instance
operator|->
name|dH
operator|/=
literal|100.
expr_stmt|;
if|if
condition|(
name|MSL
condition|)
block|{
comment|/* not set ! */
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"dH = (GPS - MSL) = %.2fm"
argument_list|,
name|instance
operator|->
name|dH
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/* stuck in here as it only gets done once */
if|if
condition|(
name|instance
operator|->
name|chan
operator|!=
literal|12
operator|&&
operator|!
name|instance
operator|->
name|saw_At
condition|)
block|{
name|cp
operator|=
literal|"Not Good, no @@At command, must be a GT/GT+"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * For instance->site_survey to be ONCORE_SS_TESTING, this must be the first 	 * time thru @@Ea.  There are two choices 	 *   (a) We did not get a response to the @@At0 or @@At2 commands, 	 *	   must be a GT/GT+/SL with no position hold mode. 	 *   (b) Saw the @@At0, @@At2 commands, but @@At2 failed, 	 *	   must be a VP or older UT which doesnt have Site Survey mode. 	 *	   We will have to do it ourselves. 	 */
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_TESTING
condition|)
block|{
comment|/* first time thru Ea */
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Initiating software 3D site survey (%d samples)"
argument_list|,
name|POS_HOLD_AVERAGE
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_SW
expr_stmt|;
name|instance
operator|->
name|ss_lat
operator|=
name|instance
operator|->
name|ss_long
operator|=
name|instance
operator|->
name|ss_ht
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disable */
block|}
if|if
condition|(
name|instance
operator|->
name|shmem
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|mode
operator|==
name|MODE_0D
condition|)
comment|/* 0D, Position Hold */
name|i
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|mode
operator|==
name|MODE_2D
condition|)
comment|/* 2D, Altitude Hold */
name|i
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|mode
operator|==
name|MODE_3D
condition|)
comment|/* 3D fix */
name|i
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|i
operator|*=
operator|(
name|Len
operator|+
literal|3
operator|)
expr_stmt|;
name|vp
index|[
name|i
operator|+
literal|2
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|vp
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|buf
argument_list|,
name|Len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Almanac mode, waiting for Almanac, cant do anything till we have it */
comment|/* When we have an almanac, start the En/Bn messages */
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_ALMANAC
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ONCORE: waiting for almanac\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Here we have almanac. 			     Start TRAIM (@@En/@@Bn) dependant on TRAIM flag. 			     If flag == -1, then we dont know if this unit supports 			     traim, and we issue the command and then wait up to 			     5sec to see if we get a reply */
if|if
condition|(
name|instance
operator|->
name|traim
operator|!=
literal|0
condition|)
block|{
comment|/* either yes or unknown */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bn
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_En
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_En
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|traim
operator|==
operator|-
literal|1
condition|)
name|instance
operator|->
name|traim_delay
operator|=
literal|1
expr_stmt|;
block|}
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_RUN
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_RUN"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * check if timer active 	 * if it hasnt been cleared, then @@En/@@Bn did not respond 	 */
if|if
condition|(
name|instance
operator|->
name|traim_delay
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|traim_delay
operator|++
operator|>
literal|5
condition|)
block|{
name|instance
operator|->
name|traim
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|traim_delay
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
literal|"ONCORE: Did not detect TRAIM response, TRAIM = OFF"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * must be ONCORE_RUN if we are here. 	 */
name|instance
operator|->
name|pp
operator|->
name|year
operator|=
name|buf
index|[
literal|6
index|]
operator|*
literal|256
operator|+
name|buf
index|[
literal|7
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|day
operator|=
name|ymd2yd
argument_list|(
name|buf
index|[
literal|6
index|]
operator|*
literal|256
operator|+
name|buf
index|[
literal|7
index|]
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|hour
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|minute
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|second
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
comment|/* 	 * Check to see if Hardware SiteSurvey has Finished. 	 */
if|if
condition|(
operator|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_HW
operator|)
operator|&&
operator|!
operator|(
name|instance
operator|->
name|Ea
index|[
literal|37
index|]
operator|&
literal|0x20
operator|)
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Now in 0D mode"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|instance
operator|->
name|printed
operator|&&
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_DONE
condition|)
block|{
name|instance
operator|->
name|printed
operator|=
literal|1
expr_stmt|;
comment|/* Read back Position Hold Params (cant for GT) */
if|if
condition|(
name|instance
operator|->
name|saw_At
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Asx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Asx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|oncore_print_As
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* Read back PPS Offset for Output */
comment|/* Nb. This will fail silently for early UT (no plus) and M12 models */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ayx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ayx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read back Cable Delay for Output */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Azx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Azx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check the leap second status once per day. 	 */
if|if
condition|(
name|instance
operator|->
name|Bj_day
operator|!=
name|buf
index|[
literal|5
index|]
condition|)
block|{
comment|/* do this 1/day */
name|instance
operator|->
name|Bj_day
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gj
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * The following additional check, checking for June/December, is a 			 * workaround for incorrect ONCORE firmware.  The oncore starts 			 * reporting the leap second when the GPS satellite data message 			 * (page 18, subframe 4) is updated to a date in the future, which 			 * can be several months before the leap second.  WWV and other 			 * services seem to wait until the month of the event to turn 			 * on their indicators (which is usually a single bit). 			 */
if|if
condition|(
operator|(
name|buf
index|[
literal|4
index|]
operator|==
literal|6
operator|)
operator|||
operator|(
name|buf
index|[
literal|4
index|]
operator|==
literal|12
operator|)
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * if SHMEM active, every 15s, steal one 'tick' to get 2D or 3D posn. 	 */
if|if
condition|(
name|instance
operator|->
name|shmem
operator|&&
name|instance
operator|->
name|shmem_Posn
operator|&&
operator|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_DONE
operator|)
condition|)
block|{
comment|/* dont screw up the SS by changing mode */
if|if
condition|(
name|instance
operator|->
name|pp
operator|->
name|second
operator|%
literal|15
operator|==
literal|3
condition|)
block|{
comment|/* start the sequence */
name|instance
operator|->
name|shmem_reset
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|shmem_Posn
operator|==
literal|2
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd2
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 2D */
else|else
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 3D */
block|}
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|saw_At
condition|)
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* out of 0D to 3D mode */
if|if
condition|(
name|instance
operator|->
name|shmem_Posn
operator|==
literal|2
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 3D to 2D mode */
block|}
else|else
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|shmem_reset
operator|||
operator|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_0D
operator|)
condition|)
block|{
name|instance
operator|->
name|shmem_reset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 0D */
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|saw_At
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|mode
operator|==
name|MODE_2D
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 2D -> 3D or 0D */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* to 0D mode */
block|}
else|else
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|instance
operator|->
name|traim
operator|==
literal|0
condition|)
comment|/* NO traim, go get tick */
name|oncore_get_timestamp
argument_list|(
name|instance
argument_list|,
name|instance
operator|->
name|offset
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|!=
name|ONCORE_SS_SW
condition|)
return|return;
comment|/* 	 * We have to average our own position for the Position Hold Mode 	 *   We use Heights from the GPS ellipsoid. 	 */
if|if
condition|(
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
condition|)
comment|/* Not if poor geometry or less than 3 sats */
return|return;
if|if
condition|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_3D
condition|)
comment|/* Only 3D Fix */
return|return;
name|instance
operator|->
name|ss_lat
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|Ea
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|Ea
index|[
literal|19
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|Ea
index|[
literal|23
index|]
argument_list|)
expr_stmt|;
comment|/* GPS ellipsoid */
name|instance
operator|->
name|ss_count
operator|++
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|ss_count
operator|!=
name|POS_HOLD_AVERAGE
condition|)
return|return;
name|instance
operator|->
name|ss_lat
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Surveyed posn:  lat %.3f long %.3f ht %.3f"
argument_list|,
name|instance
operator|->
name|ss_lat
argument_list|,
name|instance
operator|->
name|ss_long
argument_list|,
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
comment|/* set newly determined position as 3D Position hold position */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_As
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_As
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|6
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|10
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_As
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set height seperately for 2D */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Au
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Au
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Au
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and set Position Hold */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|saw_At
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Now in 0D mode"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_msg_BnEn
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|long
name|dt1
decl_stmt|,
name|dt2
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_RUN
condition|)
return|return;
if|if
condition|(
name|instance
operator|->
name|traim_delay
condition|)
block|{
comment|/* flag that @@En/@@Bn returned */
name|instance
operator|->
name|traim
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|traim_delay
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
literal|"ONCORE: Detected TRAIM, TRAIM = ON"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|instance
operator|->
name|En
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* En or Bn */
comment|/* If Time RAIM doesn't like it, don't trust it */
if|if
condition|(
name|instance
operator|->
name|En
index|[
literal|21
index|]
condition|)
return|return;
name|dt1
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
comment|/* dt this time step */
name|instance
operator|->
name|saw_tooth
operator|=
operator|(
name|s_char
operator|)
name|instance
operator|->
name|En
index|[
literal|25
index|]
expr_stmt|;
comment|/* update for next time */
name|dt2
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
comment|/* dt next time step */
name|oncore_get_timestamp
argument_list|(
name|instance
argument_list|,
name|dt1
argument_list|,
name|dt2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_get_timestamp
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|long
name|dt1
parameter_list|,
comment|/* tick offset THIS time step */
name|long
name|dt2
comment|/* tick offset NEXT time step */
parameter_list|)
block|{
name|int
name|Rsm
decl_stmt|;
name|u_long
name|i
decl_stmt|,
name|j
decl_stmt|;
name|l_fp
name|ts
decl_stmt|,
name|ts_tmp
decl_stmt|;
name|double
name|dmy
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|struct
name|timespec
modifier|*
name|tsp
init|=
literal|0
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
modifier|*
name|tsp
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|int
name|current_mode
decl_stmt|;
name|pps_params_t
name|current_params
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|pps_info_t
name|pps_i
decl_stmt|;
else|#
directive|else
comment|/* ! HAVE_PPSAPI */
ifdef|#
directive|ifdef
name|HAVE_CIOGETEV
name|struct
name|ppsclockev
name|ev
decl_stmt|;
name|int
name|r
init|=
name|CIOGETEV
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIOCGPPSEV
name|struct
name|ppsclockev
name|ev
decl_stmt|;
name|int
name|r
init|=
name|TIOCGPPSEV
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TIOCDCDTIMESTAMP
name|struct
name|timeval
name|tv
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ! HAVE_PPS_API */
if|if
condition|(
operator|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_DONE
operator|)
operator|&&
operator|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_0D
operator|)
condition|)
return|return;
comment|/* Don't do anything without an almanac to define the GPS->UTC delta */
if|if
condition|(
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
condition|)
return|return;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|j
operator|=
name|instance
operator|->
name|ev_serial
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|time_pps_fetch
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|pps_i
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: time_pps_fetch failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
block|{
name|tsp
operator|=
operator|&
name|pps_i
operator|.
name|assert_timestamp
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|i
operator|=
operator|(
name|u_long
operator|)
name|pps_i
operator|.
name|assert_sequence
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|printf
argument_list|(
literal|"ONCORE[%d]: serial/j (%lu, %lu) %ld.%09ld\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"ONCORE[%d]: serial/j (%lu, %lu) %ld.%06ld\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pps_i
operator|.
name|assert_sequence
operator|==
name|j
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: oncore_get_timestamp, error serial pps\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|pps_i
operator|.
name|assert_sequence
expr_stmt|;
block|}
else|else
block|{
name|tsp
operator|=
operator|&
name|pps_i
operator|.
name|clear_timestamp
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|i
operator|=
operator|(
name|u_long
operator|)
name|pps_i
operator|.
name|clear_sequence
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|printf
argument_list|(
literal|"ONCORE[%d]: serial/j (%lu, %lu) %ld.%09ld\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"ONCORE[%d]: serial/j (%lu, %lu) %ld.%06ld\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pps_i
operator|.
name|clear_sequence
operator|==
name|j
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: oncore_get_timestamp, error serial pps\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|pps_i
operator|.
name|clear_sequence
expr_stmt|;
block|}
comment|/* convert timespec -> ntp l_fp */
name|dmy
operator|=
name|tsp
operator|->
name|tv_nsec
expr_stmt|;
name|dmy
operator|/=
literal|1e9
expr_stmt|;
name|ts
operator|.
name|l_uf
operator|=
name|dmy
operator|*
literal|4294967296.0
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|=
name|tsp
operator|->
name|tv_sec
expr_stmt|;
if|#
directive|if
literal|0
block|alternate code for previous 4 lines is 	dmy = 1.0e-9*tsp->tv_nsec;
comment|/* fractional part */
block|DTOLFP(dmy,&ts); 	dmy = tsp->tv_sec;
comment|/* integer part */
block|DTOLFP(dmy,&ts_tmp); 	L_ADD(&ts,&ts_tmp);      or more simply 	dmy = 1.0e-9*tsp->tv_nsec;
comment|/* fractional part */
block|DTOLFP(dmy,&ts); 	ts.l_ui = tsp->tv_sec;
endif|#
directive|endif
comment|/* 0 */
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TIOCGPPSEV
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_CIOGETEV
argument_list|)
name|j
operator|=
name|instance
operator|->
name|ev_serial
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|instance
operator|->
name|ppsfd
argument_list|,
name|r
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: IOCTL:"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tsp
operator|=
operator|&
name|ev
operator|.
name|tv
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|printf
argument_list|(
literal|"ONCORE: serial/j (%d, %d) %ld.%09ld\n"
argument_list|,
name|ev
operator|.
name|serial
argument_list|,
name|j
argument_list|,
name|tsp
operator|->
name|tv_sec
argument_list|,
name|tsp
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"ONCORE: serial/j (%d, %d) %ld.%06ld\n"
argument_list|,
name|ev
operator|.
name|serial
argument_list|,
name|j
argument_list|,
name|tsp
operator|->
name|tv_sec
argument_list|,
name|tsp
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ev
operator|.
name|serial
operator|==
name|j
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: oncore_get_timestamp, error serial pps\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|ev
operator|.
name|serial
expr_stmt|;
comment|/* convert timeval -> ntp l_fp */
name|TVTOTS
argument_list|(
name|tsp
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|TIOCDCDTIMESTAMP
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|instance
operator|->
name|ppsfd
argument_list|,
name|TIOCDCDTIMESTAMP
argument_list|,
operator|&
name|tv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: ioctl(TIOCDCDTIMESTAMP)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tsp
operator|=
operator|&
name|tv
expr_stmt|;
name|TVTOTS
argument_list|(
name|tsp
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"Cannot compile -- no PPS mechanism configured!"
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* now have timestamp in ts */
comment|/* add in saw_tooth and offset, these will be ZERO if no TRAIM */
comment|/* saw_tooth not really necessary if using TIMEVAL */
comment|/* since its only precise to us, but do it anyway. */
comment|/* offset in ns, and is positive (late), we subtract */
comment|/* to put the PPS time transition back where it belongs */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
comment|/* must hand the offset for the NEXT sec off to the Kernel to do */
comment|/* the addition, so that the Kernel PLL sees the offset too */
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|instance
operator|->
name|pps_p
operator|.
name|assert_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
else|else
name|instance
operator|->
name|pps_p
operator|.
name|clear_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
comment|/* The following code is necessary, and not just a time_pps_setparams, 	 * using the saved instance->pps_p, since some other process on the 	 * machine may have diddled with the mode bits (say adding something 	 * that it needs).  We take what is there and ADD what we need. 	 * [[ The results from the time_pps_getcap is unlikely to change so 	 *    we could probably just save it, but I choose to do the call ]] 	 * Unfortunately, there is only ONE set of mode bits in the kernel per 	 * interface, and not one set for each open handle. 	 * 	 * There is still a race condition here where we might mess up someone 	 * elses mode, but if he is being careful too, he should survive. 	 */
if|if
condition|(
name|time_pps_getcap
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|current_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getcap failed: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|time_pps_getparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|current_params
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getparams failed: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* or current and mine */
name|current_params
operator|.
name|mode
operator||=
name|instance
operator|->
name|pps_p
operator|.
name|mode
expr_stmt|;
comment|/* but only set whats legal */
name|current_params
operator|.
name|mode
operator|&=
name|current_mode
expr_stmt|;
name|current_params
operator|.
name|assert_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|current_params
operator|.
name|assert_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
name|current_params
operator|.
name|clear_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|current_params
operator|.
name|clear_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|current_params
argument_list|)
condition|)
name|perror
argument_list|(
literal|"time_pps_setparams"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* if not PPSAPI, no way to inform kernel of OFFSET, just add the */
comment|/* offset for THIS second */
name|dmy
operator|=
operator|-
literal|1.0e-9
operator|*
name|dt1
expr_stmt|;
name|DTOLFP
argument_list|(
name|dmy
argument_list|,
operator|&
name|ts_tmp
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|ts_tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* have time from UNIX origin, convert to NTP origin. */
name|ts
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|lastrec
operator|=
name|ts
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|msec
operator|=
literal|0
expr_stmt|;
name|ts_tmp
operator|=
name|ts
expr_stmt|;
name|ts_tmp
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
comment|/* zero integer part */
name|LFPTOD
argument_list|(
operator|&
name|ts_tmp
argument_list|,
name|dmy
argument_list|)
expr_stmt|;
comment|/* convert fractional part to a double */
name|j
operator|=
literal|1.0e9
operator|*
name|dmy
expr_stmt|;
comment|/* then to integer ns */
name|Rsm
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|Rsm
operator|=
name|instance
operator|->
name|Ea
index|[
literal|64
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|Rsm
operator|=
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|Rsm
operator|=
operator|(
operator|(
name|instance
operator|->
name|Ea
index|[
literal|129
index|]
operator|<<
literal|8
operator|)
operator||
name|instance
operator|->
name|Ea
index|[
literal|130
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
operator|||
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
name|sprintf
argument_list|(
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|,
comment|/* MAX length 128, currently at 117 */
literal|"%u.%09lu %d %d %2d %2d %2d %2ld rstat   %02x dop %4.1f nsat %2d,%d traim %d sigma %d neg-sawtooth %3d sat %d%d%d%d%d%d%d%d"
argument_list|,
name|ts
operator|.
name|l_ui
argument_list|,
name|j
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|year
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|day
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|hour
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|minute
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|second
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
operator|%
literal|60
argument_list|,
name|Rsm
argument_list|,
literal|0.1
operator|*
operator|(
literal|256
operator|*
name|instance
operator|->
name|Ea
index|[
literal|35
index|]
operator|+
name|instance
operator|->
name|Ea
index|[
literal|36
index|]
operator|)
argument_list|,
comment|/*rsat	dop */
name|instance
operator|->
name|Ea
index|[
literal|38
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|39
index|]
argument_list|,
name|instance
operator|->
name|En
index|[
literal|21
index|]
argument_list|,
comment|/*	nsat visible,	  nsat tracked,     traim */
name|instance
operator|->
name|En
index|[
literal|23
index|]
operator|*
literal|256
operator|+
name|instance
operator|->
name|En
index|[
literal|24
index|]
argument_list|,
operator|(
name|s_char
operator|)
name|instance
operator|->
name|En
index|[
literal|25
index|]
argument_list|,
comment|/* sigma				   neg-sawtooth */
comment|/*sat*/
name|instance
operator|->
name|Ea
index|[
literal|41
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|45
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|49
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|53
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|57
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|61
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|65
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|69
index|]
argument_list|)
expr_stmt|;
comment|/* will be 0 for 6 chan */
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|sprintf
argument_list|(
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%u.%09lu %d %d %2d %2d %2d %2ld rstat %02x dop %4.1f nsat %2d,%d sat %d%d%d%d%d%d%d%d%d%d%d%d"
argument_list|,
name|ts
operator|.
name|l_ui
argument_list|,
name|j
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|year
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|day
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|hour
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|minute
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|second
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
operator|%
literal|60
argument_list|,
name|Rsm
argument_list|,
literal|0.1
operator|*
operator|(
literal|256
operator|*
name|instance
operator|->
name|Ea
index|[
literal|53
index|]
operator|+
name|instance
operator|->
name|Ea
index|[
literal|54
index|]
operator|)
argument_list|,
comment|/*rsat	dop */
name|instance
operator|->
name|Ea
index|[
literal|55
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|56
index|]
argument_list|,
comment|/*	nsat visible,	  nsat tracked	*/
comment|/*sat*/
name|instance
operator|->
name|Ea
index|[
literal|58
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|64
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|70
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|76
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|82
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|88
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|94
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|100
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|106
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|112
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|118
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|124
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ONCORE[%d]: len = %d %s\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|n
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|instance
operator|->
name|pp
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|instance
operator|->
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|instance
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|polled
condition|)
block|{
name|instance
operator|->
name|polled
operator|=
literal|0
expr_stmt|;
comment|/* 		instance->pp->dispersion = instance->pp->skew = 0; */
name|refclock_receive
argument_list|(
name|instance
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Try to use Oncore UT+ Auto Survey Feature  *	If its not there (VP), set flag to do it ourselves.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_At
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|instance
operator|->
name|saw_At
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_TESTING
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|2
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Initiating hardware 3D site survey"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_HW
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* get leap-second warning message */
end_comment

begin_comment
comment|/*  * @@Bj does NOT behave as documented in current Oncore firmware.  * It turns on the LEAP indicator when the data is set, and does not,  * as documented, wait until the beginning of the month when the  * leap second will occur.  * Until this firmware bug is fixed, @@Bj is only called in June/December.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Bj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|4
index|]
condition|)
block|{
case|case
literal|1
case|:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_ADDSECOND"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_DELSECOND"
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_NOWARNING"
expr_stmt|;
break|break;
block|}
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Leap Second for M12, gives all info from satellite message */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Gj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|dt
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
modifier|*
name|Month
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jly"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
comment|/* print the message to verify whats there */
name|dt
operator|=
name|buf
index|[
literal|5
index|]
operator|-
name|buf
index|[
literal|4
index|]
expr_stmt|;
if|#
directive|if
literal|1
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"ONCORE[%d]: Leap Sec Msg: %d %d %d %d %d %d %d %d %d %d"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|,
literal|256
operator|*
name|buf
index|[
literal|6
index|]
operator|+
name|buf
index|[
literal|7
index|]
argument_list|,
name|buf
index|[
literal|8
index|]
argument_list|,
name|buf
index|[
literal|9
index|]
argument_list|,
name|buf
index|[
literal|10
index|]
argument_list|,
operator|(
name|buf
index|[
literal|14
index|]
operator|+
literal|256
operator|*
operator|(
name|buf
index|[
literal|13
index|]
operator|+
literal|256
operator|*
operator|(
name|buf
index|[
literal|12
index|]
operator|+
literal|256
operator|*
name|buf
index|[
literal|11
index|]
operator|)
operator|)
operator|)
argument_list|,
name|buf
index|[
literal|15
index|]
argument_list|,
name|buf
index|[
literal|16
index|]
argument_list|,
name|buf
index|[
literal|17
index|]
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dt
condition|)
block|{
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"ONCORE[%d]: Leap second (%d) scheduled for %d%s%d at %d:%d:%d"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|dt
argument_list|,
name|buf
index|[
literal|9
index|]
argument_list|,
name|Month
index|[
name|buf
index|[
literal|8
index|]
index|]
argument_list|,
literal|256
operator|*
name|buf
index|[
literal|6
index|]
operator|+
name|buf
index|[
literal|7
index|]
argument_list|,
name|buf
index|[
literal|15
index|]
argument_list|,
name|buf
index|[
literal|16
index|]
argument_list|,
name|buf
index|[
literal|17
index|]
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/* Only raise warning within a month of the leap second */
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_NOWARNING"
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|6
index|]
operator|==
name|instance
operator|->
name|Ea
index|[
literal|6
index|]
operator|&&
name|buf
index|[
literal|7
index|]
operator|==
name|instance
operator|->
name|Ea
index|[
literal|7
index|]
operator|&&
comment|/* year */
name|buf
index|[
literal|8
index|]
operator|==
name|instance
operator|->
name|Ea
index|[
literal|4
index|]
condition|)
block|{
comment|/* month */
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
name|dt
operator|<
literal|0
condition|)
block|{
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_DELSECOND"
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_ADDSECOND"
expr_stmt|;
block|}
block|}
block|}
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get Position hold position  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_As
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|instance
operator|->
name|printed
operator|||
name|instance
operator|->
name|As
condition|)
return|return;
name|instance
operator|->
name|As
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|ss_lat
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
comment|/* Print out Position */
name|oncore_print_As
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_print_As
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|,
name|ew
decl_stmt|,
name|ns
decl_stmt|;
name|double
name|xd
decl_stmt|,
name|xm
decl_stmt|,
name|xs
decl_stmt|,
name|yd
decl_stmt|,
name|ym
decl_stmt|,
name|ys
decl_stmt|,
name|hm
decl_stmt|,
name|hft
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|idy
decl_stmt|,
name|is
decl_stmt|,
name|imx
decl_stmt|,
name|imy
decl_stmt|;
name|long
name|lat
decl_stmt|,
name|lon
decl_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Posn:"
argument_list|)
expr_stmt|;
name|ew
operator|=
literal|'E'
expr_stmt|;
name|lon
operator|=
name|instance
operator|->
name|ss_long
expr_stmt|;
if|if
condition|(
name|lon
operator|<
literal|0
condition|)
block|{
name|ew
operator|=
literal|'W'
expr_stmt|;
name|lon
operator|=
operator|-
name|lon
expr_stmt|;
block|}
name|ns
operator|=
literal|'N'
expr_stmt|;
name|lat
operator|=
name|instance
operator|->
name|ss_lat
expr_stmt|;
if|if
condition|(
name|lat
operator|<
literal|0
condition|)
block|{
name|ns
operator|=
literal|'S'
expr_stmt|;
name|lat
operator|=
operator|-
name|lat
expr_stmt|;
block|}
name|hm
operator|=
name|instance
operator|->
name|ss_ht
operator|/
literal|100.
expr_stmt|;
name|hft
operator|=
name|hm
operator|/
literal|0.3048
expr_stmt|;
name|xd
operator|=
name|lat
operator|/
literal|3600000.
expr_stmt|;
comment|/* lat, lon in int msec arc, ht in cm. */
name|yd
operator|=
name|lon
operator|/
literal|3600000.
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Lat = %c %11.7fdeg,    Long = %c %11.7fdeg,    Alt = %5.2fm (%5.2fft) GPS"
argument_list|,
name|ns
argument_list|,
name|xd
argument_list|,
name|ew
argument_list|,
name|yd
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|idx
operator|=
name|xd
expr_stmt|;
name|idy
operator|=
name|yd
expr_stmt|;
name|imx
operator|=
name|lat
operator|%
literal|3600000
expr_stmt|;
name|imy
operator|=
name|lon
operator|%
literal|3600000
expr_stmt|;
name|xm
operator|=
name|imx
operator|/
literal|60000.
expr_stmt|;
name|ym
operator|=
name|imy
operator|/
literal|60000.
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Lat = %c %3ddeg %7.4fm,   Long = %c %3ddeg %8.5fm,  Alt = %7.2fm (%7.2fft) GPS"
argument_list|,
name|ns
argument_list|,
name|idx
argument_list|,
name|xm
argument_list|,
name|ew
argument_list|,
name|idy
argument_list|,
name|ym
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|imx
operator|=
name|xm
expr_stmt|;
name|imy
operator|=
name|ym
expr_stmt|;
name|is
operator|=
name|lat
operator|%
literal|60000
expr_stmt|;
name|xs
operator|=
name|is
operator|/
literal|1000.
expr_stmt|;
name|is
operator|=
name|lon
operator|%
literal|60000
expr_stmt|;
name|ys
operator|=
name|is
operator|/
literal|1000.
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Lat = %c %3ddeg %2dm %5.2fs, Long = %c %3ddeg %2dm %5.2fs, Alt = %7.2fm (%7.2fft) GPS"
argument_list|,
name|ns
argument_list|,
name|idx
argument_list|,
name|imx
argument_list|,
name|xs
argument_list|,
name|ew
argument_list|,
name|idy
argument_list|,
name|imy
argument_list|,
name|ys
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get PPS Offset  * Nb. @@Ay is not supported for early UT (no plus) model  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Ay
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|instance
operator|->
name|printed
operator|||
name|instance
operator|->
name|Ay
condition|)
return|return;
name|instance
operator|->
name|Ay
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|offset
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"PPS Offset  is set to %ld ns"
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get Cable Delay  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Az
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|instance
operator|->
name|printed
operator|||
name|instance
operator|->
name|Az
condition|)
return|return;
name|instance
operator|->
name|Az
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|delay
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Cable delay is set to %ld ns"
argument_list|,
name|instance
operator|->
name|delay
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_msg_Sz
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
literal|"Oncore: System Failure at Power On"
expr_stmt|;
if|if
condition|(
name|instance
operator|&&
name|instance
operator|->
name|peer
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_shutdown
argument_list|(
name|instance
operator|->
name|unit
argument_list|,
name|instance
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_oncore_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

