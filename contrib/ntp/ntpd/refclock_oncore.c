begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * refclock_oncore.c  *  * Driver for some of the various the Motorola Oncore GPS receivers.  *   should work with Basic, PVT6, VP, UT, UT+, GT, GT+, SL, M12, M12+T  *	The receivers with TRAIM (VP, UT, UT+, M12+T), will be more accurate  *	than the others.  *	The receivers without position hold (GT, GT+) will be less accurate.  *  * Tested with:  *  *		(UT)				   (VP)  *   COPYRIGHT 1991-1997 MOTOROLA INC.	COPYRIGHT 1991-1996 MOTOROLA INC.  *   SFTW P/N #     98-P36848P		SFTW P/N # 98-P36830P  *   SOFTWARE VER # 2			SOFTWARE VER # 8  *   SOFTWARE REV # 2			SOFTWARE REV # 8  *   SOFTWARE DATE  APR 24 1998 	SOFTWARE DATE  06 Aug 1996  *   MODEL #	R1121N1114		MODEL #    B4121P1155  *   HWDR P/N # 1			HDWR P/N # _  *   SERIAL #	R0010A			SERIAL #   SSG0226478  *   MANUFACTUR DATE 6H07		MANUFACTUR DATE 7E02  *					OPTIONS LIST	IB  *  *	      (Basic)				   (M12)  *   COPYRIGHT 1991-1994 MOTOROLA INC.	COPYRIGHT 1991-2000 MOTOROLA INC.  *   SFTW P/N # 98-P39949M		SFTW P/N # 61-G10002A  *   SOFTWARE VER # 5			SOFTWARE VER # 1  *   SOFTWARE REV # 0			SOFTWARE REV # 3  *   SOFTWARE DATE  20 JAN 1994 	SOFTWARE DATE  Mar 13 2000  *   MODEL #	A11121P116		MODEL #    P143T12NR1  *   HDWR P/N # _			HWDR P/N # 1  *   SERIAL #	SSG0049809		SERIAL #   P003UD  *   MANUFACTUR DATE 417AMA199		MANUFACTUR DATE 0C27  *   OPTIONS LIST    AB  *  * --------------------------------------------------------------------------  * This code uses the two devices  *	/dev/oncore.serial.n  *	/dev/oncore.pps.n  * which may be linked to the same device.  * and can read initialization data from the file  *	/etc/ntp.oncoreN, /etc/ntp.oncore.N, or /etc/ntp.oncore, where  *	n or N are the unit number, viz 127.127.30.N.  * --------------------------------------------------------------------------  * Reg.Clemens<reg@dwf.com> Sep98.  *  Original code written for FreeBSD.  *  With these mods it works on FreeBSD, SunOS, Solaris and Linux  *    (SunOS 4.1.3 + ppsclock)  *    (Solaris7 + MU4)  *    (RedHat 5.1 2.0.35 + PPSKit, 2.1.126 + or later).  *  *  Lat,Long,Ht, cable-delay, offset, and the ReceiverID (along with the  *  state machine state) are printed to CLOCKSTATS if that file is enabled  *  in /etc/ntp.conf.  *  * --------------------------------------------------------------------------  *  * According to the ONCORE manual (TRM0003, Rev 3.2, June 1998, page 3.13)  * doing an average of 10000 valid 2D and 3D fixes is what the automatic  * site survey mode does.  Looking at the output from the receiver  * it seems like it is only using 3D fixes.  * When we do it ourselves, take 10000 3D fixes.  */
end_comment

begin_define
define|#
directive|define
name|POS_HOLD_AVERAGE
value|10000
end_define

begin_comment
comment|/* nb, 10000s ~= 2h45m */
end_comment

begin_comment
comment|/*  * ONCORE_SHMEM_STATUS will create a mmap(2)'ed file named according to a  * "STATUS" line in the oncore config file, which contains the most recent  * copy of all types of messages we recognize.	This file can be mmap(2)'ed  * by monitoring and statistics programs.  *  * See separate HTML documentation for this option.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_ONCORE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ONCORE_SHMEM_STATUS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MMAN_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|((u_char *) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MAP_FAILED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_MMAN_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ONCORE_SHMEM_STATUS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<timepps.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/sio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TERMIOS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PPSCLOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRUCT_PPSCLOCKEV
end_ifndef

begin_struct
struct|struct
name|ppsclockev
block|{
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|struct
name|timespec
name|tv
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
name|tv
decl_stmt|;
endif|#
directive|endif
name|u_int
name|serial
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_STRUCT_PPSCLOCKEV */
end_comment

begin_enum
enum|enum
name|receive_state
block|{
name|ONCORE_NO_IDEA
block|,
name|ONCORE_CHECK_ID
block|,
name|ONCORE_CHECK_CHAN
block|,
name|ONCORE_HAVE_CHAN
block|,
name|ONCORE_RESET_SENT
block|,
name|ONCORE_TEST_SENT
block|,
name|ONCORE_INIT
block|,
name|ONCORE_ALMANAC
block|,
name|ONCORE_RUN
block|}
enum|;
end_enum

begin_enum
enum|enum
name|site_survey_state
block|{
name|ONCORE_SS_UNKNOWN
block|,
name|ONCORE_SS_TESTING
block|,
name|ONCORE_SS_HW
block|,
name|ONCORE_SS_SW
block|,
name|ONCORE_SS_DONE
block|}
enum|;
end_enum

begin_enum
enum|enum
name|antenna_state
block|{
name|ONCORE_ANTENNA_UNKNOWN
init|=
operator|-
literal|1
block|,
name|ONCORE_ANTENNA_OK
init|=
literal|0
block|,
name|ONCORE_ANTENNA_OC
init|=
literal|1
block|,
name|ONCORE_ANTENNA_UC
init|=
literal|2
block|,
name|ONCORE_ANTENNA_NV
init|=
literal|3
block|}
enum|;
end_enum

begin_comment
comment|/* Model Name, derived from the @@Cj message.  * Used to initialize some variables.  */
end_comment

begin_enum
enum|enum
name|oncore_model
block|{
name|ONCORE_BASIC
block|,
name|ONCORE_PVT6
block|,
name|ONCORE_VP
block|,
name|ONCORE_UT
block|,
name|ONCORE_UTPLUS
block|,
name|ONCORE_GT
block|,
name|ONCORE_GTPLUS
block|,
name|ONCORE_SL
block|,
name|ONCORE_M12
block|,
name|ONCORE_UNKNOWN
block|}
enum|;
end_enum

begin_comment
comment|/* the bits that describe these properties are in the same place  * on the VP/UT, but have moved on the M12.  As such we extract  * them, and use them from this struct.  *  */
end_comment

begin_struct
struct|struct
name|RSM
block|{
name|u_char
name|posn0D
decl_stmt|;
name|u_char
name|posn2D
decl_stmt|;
name|u_char
name|posn3D
decl_stmt|;
name|u_char
name|bad_almanac
decl_stmt|;
name|u_char
name|bad_fix
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* It is possible to test the VP/UT each cycle (@@Ea or equivalent) to  * see what mode it is in.  The bits on the M12 are multiplexed with  * other messages, so we have to 'keep' the last known mode here.  */
end_comment

begin_enum
enum|enum
name|posn_mode
block|{
name|MODE_UNKNOWN
block|,
name|MODE_0D
block|,
name|MODE_2D
block|,
name|MODE_3D
block|}
enum|;
end_enum

begin_struct
struct|struct
name|instance
block|{
name|int
name|unit
decl_stmt|;
comment|/* 127.127.30.unit */
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|ttyfd
decl_stmt|;
comment|/* TTY file descriptor */
name|int
name|ppsfd
decl_stmt|;
comment|/* PPS file descriptor */
name|int
name|shmemfd
decl_stmt|;
comment|/* Status shm descriptor */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|pps_handle_t
name|pps_h
decl_stmt|;
name|pps_params_t
name|pps_p
decl_stmt|;
endif|#
directive|endif
name|enum
name|receive_state
name|o_state
decl_stmt|;
comment|/* Receive state */
name|enum
name|posn_mode
name|mode
decl_stmt|;
comment|/* 0D, 2D, 3D */
name|enum
name|site_survey_state
name|site_survey
decl_stmt|;
comment|/* Site Survey state */
name|enum
name|antenna_state
name|ant_state
decl_stmt|;
comment|/* antenna state */
name|int
name|Bj_day
decl_stmt|;
name|u_long
name|delay
decl_stmt|;
comment|/* ns */
name|long
name|offset
decl_stmt|;
comment|/* ns */
name|u_char
modifier|*
name|shmem
decl_stmt|;
name|char
modifier|*
name|shmem_fname
decl_stmt|;
name|u_int
name|shmem_Cb
decl_stmt|;
name|u_int
name|shmem_Ba
decl_stmt|;
name|u_int
name|shmem_Ea
decl_stmt|;
name|u_int
name|shmem_Ha
decl_stmt|;
name|u_char
name|shmem_reset
decl_stmt|;
name|u_char
name|shmem_Posn
decl_stmt|;
name|u_char
name|shmem_bad_Ea
decl_stmt|;
name|u_char
name|almanac_from_shmem
decl_stmt|;
name|double
name|ss_lat
decl_stmt|;
name|double
name|ss_long
decl_stmt|;
name|double
name|ss_ht
decl_stmt|;
name|double
name|dH
decl_stmt|;
name|int
name|ss_count
decl_stmt|;
name|u_char
name|posn_set
decl_stmt|;
name|enum
name|oncore_model
name|model
decl_stmt|;
name|u_int
name|version
decl_stmt|;
name|u_int
name|revision
decl_stmt|;
name|u_char
name|chan
decl_stmt|;
comment|/* 6 for PVT6 or BASIC, 8 for UT/VP, 12 for m12, 0 if unknown */
name|s_char
name|traim
decl_stmt|;
comment|/* do we have traim? yes UT/VP, no BASIC, GT, M12+T, -1 unknown, 0 no, +1 yes */
comment|/* the following 7 are all timing counters */
name|u_char
name|traim_delay
decl_stmt|;
comment|/* seconds counter, waiting for reply */
name|u_char
name|count
decl_stmt|;
comment|/* cycles thru Ea before starting */
name|u_char
name|count1
decl_stmt|;
comment|/* cycles thru Ea after SS_TESTING, waiting for SS_HW */
name|u_char
name|count2
decl_stmt|;
comment|/* cycles thru Ea after count, to check for @@Ea */
name|u_char
name|count3
decl_stmt|;
comment|/* cycles thru Ea checking for # channels */
name|u_char
name|count4
decl_stmt|;
comment|/* cycles thru leap after Gj to issue Bj */
name|u_char
name|pollcnt
decl_stmt|;
name|u_char
name|timeout
decl_stmt|;
comment|/* count to retry Cj after Fa self-test */
name|struct
name|RSM
name|rsm
decl_stmt|;
comment|/* bits extracted from Receiver Status Msg in @@Ea */
name|u_char
name|printed
decl_stmt|;
name|u_char
name|polled
decl_stmt|;
name|u_long
name|ev_serial
decl_stmt|;
name|int
name|Rcvptr
decl_stmt|;
name|u_char
name|Rcvbuf
index|[
literal|500
index|]
decl_stmt|;
name|u_char
name|BEHa
index|[
literal|160
index|]
decl_stmt|;
comment|/* Ba, Ea or Ha */
name|u_char
name|BEHn
index|[
literal|80
index|]
decl_stmt|;
comment|/* Bn , En , or Hn */
name|u_char
name|Cj
index|[
literal|300
index|]
decl_stmt|;
name|u_char
name|Ag
decl_stmt|;
comment|/* Satellite mask angle */
name|u_char
name|saw_At
decl_stmt|;
name|u_char
name|saw_Ay
decl_stmt|;
name|u_char
name|saw_Az
decl_stmt|;
name|s_char
name|saw_Gj
decl_stmt|;
name|u_char
name|have_dH
decl_stmt|;
name|u_char
name|init_type
decl_stmt|;
name|s_char
name|saw_tooth
decl_stmt|;
name|s_char
name|chan_in
decl_stmt|;
comment|/* chan number from INPUT, will always use it */
name|u_char
name|chan_id
decl_stmt|;
comment|/* chan number determined from part number */
name|u_char
name|chan_ck
decl_stmt|;
comment|/* chan number determined by sending commands to hardware */
name|s_char
name|traim_in
decl_stmt|;
comment|/* TRAIM from INPUT, will always use it */
name|s_char
name|traim_id
decl_stmt|;
comment|/* TRAIM determined from part number */
name|u_char
name|traim_ck
decl_stmt|;
comment|/* TRAIM determined by sending commands to hardware */
name|u_char
name|once
decl_stmt|;
comment|/* one pass code at top of BaEaHa */
name|s_char
name|assert
decl_stmt|;
name|u_char
name|hardpps
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|rcvbuf
value|instance->Rcvbuf
end_define

begin_define
define|#
directive|define
name|rcvptr
value|instance->Rcvptr
end_define

begin_decl_stmt
specifier|static
name|int
name|oncore_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_control
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_consume
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_read_config
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oncore_ppsapi
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_get_timestamp
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|long
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_init_shmem
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_antenna_report
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
expr|enum
name|antenna_state
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_chan_test
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_check_almanac
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_check_antenna
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_check_leap_sec
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oncore_checksum_ok
name|P
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_compute_dH
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_load_almanac
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_print_Cb
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static  void    oncore_print_array	 P((u_char *, int));	*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|oncore_print_posn
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_sendmsg
name|P
argument_list|(
operator|(
name|int
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_set_posn
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_set_traim
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_shmem_get_3D
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_ss
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oncore_wait_almanac
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_any
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Adef
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Ag
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_As
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_At
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Ay
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Az
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_BaEaHa
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Bd
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Bj
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_BnEnHn
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_CaFaIa
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cb
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cf
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cj
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cj_id
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cj_init
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Ga
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Gb
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Gd
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Gj
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Sz
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|refclock
name|refclock_oncore
init|=
block|{
name|oncore_start
block|,
comment|/* start up driver */
name|oncore_shutdown
block|,
comment|/* shut down driver */
name|oncore_poll
block|,
comment|/* transmit poll message */
name|oncore_control
block|,
comment|/* fudge (flag) control messages */
name|noentry
block|,
comment|/* not used */
name|noentry
block|,
comment|/* not used */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Understanding the next bit here is not easy unless you have a manual  * for the the various Oncore Models.  */
end_comment

begin_struct
specifier|static
struct|struct
name|msg_desc
block|{
specifier|const
name|char
name|flag
index|[
literal|3
index|]
decl_stmt|;
specifier|const
name|int
name|len
decl_stmt|;
name|void
argument_list|(
argument|*handler
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|shmem
decl_stmt|;
block|}
name|oncore_messages
index|[]
init|=
block|{
comment|/* Ea and En first since they're most common */
block|{
literal|"Ea"
block|,
literal|76
block|,
name|oncore_msg_BaEaHa
block|,
literal|"mdyyhmsffffaaaaoooohhhhmmmmvvhhddtntimsdimsdimsdimsdimsdimsdimsdimsdsC"
block|}
block|,
block|{
literal|"Ba"
block|,
literal|68
block|,
name|oncore_msg_BaEaHa
block|,
literal|"mdyyhmsffffaaaaoooohhhhmmmmvvhhddtntimsdimsdimsdimsdimsdimsdsC"
block|}
block|,
block|{
literal|"Ha"
block|,
literal|154
block|,
name|oncore_msg_BaEaHa
block|,
literal|"mdyyhmsffffaaaaoooohhhhmmmmaaaaoooohhhhmmmmVVvvhhddntimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddssrrccooooTTushmvvvvvvC"
block|}
block|,
block|{
literal|"Bn"
block|,
literal|59
block|,
name|oncore_msg_BnEnHn
block|,
literal|"otaapxxxxxxxxxxpysreensffffsffffsffffsffffsffffsffffC"
block|}
block|,
block|{
literal|"En"
block|,
literal|69
block|,
name|oncore_msg_BnEnHn
block|,
literal|"otaapxxxxxxxxxxpysreensffffsffffsffffsffffsffffsffffsffffsffffC"
block|}
block|,
block|{
literal|"Hn"
block|,
literal|78
block|,
name|oncore_msg_BnEnHn
block|,
literal|""
block|}
block|,
block|{
literal|"Ab"
block|,
literal|10
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ac"
block|,
literal|11
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ad"
block|,
literal|11
block|,
name|oncore_msg_Adef
block|,
literal|""
block|}
block|,
block|{
literal|"Ae"
block|,
literal|11
block|,
name|oncore_msg_Adef
block|,
literal|""
block|}
block|,
block|{
literal|"Af"
block|,
literal|15
block|,
name|oncore_msg_Adef
block|,
literal|""
block|}
block|,
block|{
literal|"Ag"
block|,
literal|8
block|,
name|oncore_msg_Ag
block|,
literal|""
block|}
block|,
comment|/* Satellite mask angle */
block|{
literal|"As"
block|,
literal|20
block|,
name|oncore_msg_As
block|,
literal|""
block|}
block|,
block|{
literal|"At"
block|,
literal|8
block|,
name|oncore_msg_At
block|,
literal|""
block|}
block|,
block|{
literal|"Au"
block|,
literal|12
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Av"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Aw"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ay"
block|,
literal|11
block|,
name|oncore_msg_Ay
block|,
literal|""
block|}
block|,
block|{
literal|"Az"
block|,
literal|11
block|,
name|oncore_msg_Az
block|,
literal|""
block|}
block|,
block|{
literal|"AB"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Bb"
block|,
literal|92
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Bd"
block|,
literal|23
block|,
name|oncore_msg_Bd
block|,
literal|""
block|}
block|,
block|{
literal|"Bj"
block|,
literal|8
block|,
name|oncore_msg_Bj
block|,
literal|""
block|}
block|,
block|{
literal|"Ca"
block|,
literal|9
block|,
name|oncore_msg_CaFaIa
block|,
literal|""
block|}
block|,
block|{
literal|"Cb"
block|,
literal|33
block|,
name|oncore_msg_Cb
block|,
literal|""
block|}
block|,
block|{
literal|"Cf"
block|,
literal|7
block|,
name|oncore_msg_Cf
block|,
literal|""
block|}
block|,
block|{
literal|"Cg"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ch"
block|,
literal|9
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Cj"
block|,
literal|294
block|,
name|oncore_msg_Cj
block|,
literal|""
block|}
block|,
block|{
literal|"Ek"
block|,
literal|71
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Fa"
block|,
literal|9
block|,
name|oncore_msg_CaFaIa
block|,
literal|""
block|}
block|,
block|{
literal|"Ga"
block|,
literal|20
block|,
name|oncore_msg_Ga
block|,
literal|""
block|}
block|,
block|{
literal|"Gb"
block|,
literal|17
block|,
name|oncore_msg_Gb
block|,
literal|""
block|}
block|,
block|{
literal|"Gc"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Gd"
block|,
literal|8
block|,
name|oncore_msg_Gd
block|,
literal|""
block|}
block|,
block|{
literal|"Ge"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Gj"
block|,
literal|21
block|,
name|oncore_msg_Gj
block|,
literal|""
block|}
block|,
block|{
literal|"Ia"
block|,
literal|10
block|,
name|oncore_msg_CaFaIa
block|,
literal|""
block|}
block|,
block|{
literal|"Sz"
block|,
literal|8
block|,
name|oncore_msg_Sz
block|,
literal|""
block|}
block|,
block|{
block|{
literal|0
block|}
block|,
literal|7
block|,
literal|0
block|,
literal|""
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Aa
index|[]
init|=
block|{
literal|'A'
block|,
literal|'a'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Time of Day				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ab
index|[]
init|=
block|{
literal|'A'
block|,
literal|'b'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	GMT Correction				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_AB
index|[]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VP	Application Type: Static		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ac
index|[]
init|=
block|{
literal|'A'
block|,
literal|'c'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Date					*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ad
index|[]
init|=
block|{
literal|'A'
block|,
literal|'d'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Latitude				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ae
index|[]
init|=
block|{
literal|'A'
block|,
literal|'e'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Longitude				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Af
index|[]
init|=
block|{
literal|'A'
block|,
literal|'f'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Height					*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ag
index|[]
init|=
block|{
literal|'A'
block|,
literal|'g'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Satellite Mask Angle			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Agx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'g'
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Satellite Mask Angle: read		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_As
index|[]
init|=
block|{
literal|'A'
block|,
literal|'s'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Posn Hold Parameters			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Asx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'s'
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* 6/8/12	Posn Hold Readback			*/
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/*		 on UT+ this doesnt work with 0xff	*/
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*		 but does work with 0x7f (sigh).	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_At0
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Posn Hold: off				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_At1
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Posn Hold: on				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_At2
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Posn Hold: Start Site Survey		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Atx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Posn Hold: Read Back			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Au
index|[]
init|=
block|{
literal|'A'
block|,
literal|'u'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GT/M12	Altitude Hold Ht.			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Av0
index|[]
init|=
block|{
literal|'A'
block|,
literal|'v'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VP/GT	Altitude Hold: off			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Av1
index|[]
init|=
block|{
literal|'A'
block|,
literal|'v'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VP/GT	Altitude Hold: on			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Aw
index|[]
init|=
block|{
literal|'A'
block|,
literal|'w'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	UTC/GPS time selection			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ay
index|[]
init|=
block|{
literal|'A'
block|,
literal|'y'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timing	1PPS time offset: set			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ayx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'y'
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timing	1PPS time offset: Read			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Az
index|[]
init|=
block|{
literal|'A'
block|,
literal|'z'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8UT/12 1PPS Cable Delay: set			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Azx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'z'
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8UT/12 1PPS Cable Delay: Read			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ba0
index|[]
init|=
block|{
literal|'B'
block|,
literal|'a'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	Position/Data/Status: off		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ba
index|[]
init|=
block|{
literal|'B'
block|,
literal|'a'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	Position/Data/Status: on		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bb
index|[]
init|=
block|{
literal|'B'
block|,
literal|'b'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Visible Satellites			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bd
index|[]
init|=
block|{
literal|'B'
block|,
literal|'d'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12?	Almanac Status Msg.			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Be
index|[]
init|=
block|{
literal|'B'
block|,
literal|'e'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Request Almanac Data			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bj
index|[]
init|=
block|{
literal|'B'
block|,
literal|'j'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Leap Second Pending			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bn0
index|[]
init|=
block|{
literal|'B'
block|,
literal|'n'
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	TRAIM setup/status: msg off, traim on	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bn
index|[]
init|=
block|{
literal|'B'
block|,
literal|'n'
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	TRAIM setup/status: msg on traim on	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bnx
index|[]
init|=
block|{
literal|'B'
block|,
literal|'n'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	TRAIM setup/status: msg on traim off	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ca
index|[]
init|=
block|{
literal|'C'
block|,
literal|'a'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	Self Test				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Cf
index|[]
init|=
block|{
literal|'C'
block|,
literal|'f'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Set to Defaults 			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Cg
index|[]
init|=
block|{
literal|'C'
block|,
literal|'g'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VP	Posn Fix/Idle Mode			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Cj
index|[]
init|=
block|{
literal|'C'
block|,
literal|'j'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Receiver ID				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ea0
index|[]
init|=
block|{
literal|'E'
block|,
literal|'a'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8	Position/Data/Status: off		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ea
index|[]
init|=
block|{
literal|'E'
block|,
literal|'a'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8	Position/Data/Status: on		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ek
index|[]
init|=
block|{
literal|'E'
block|,
literal|'k'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* just turn off */
end_comment

begin_comment
comment|/* 8	Posn/Status/Data - extension		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_En0
index|[]
init|=
block|{
literal|'E'
block|,
literal|'n'
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8/GT	TRAIM setup/status: msg off, traim on	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_En
index|[]
init|=
block|{
literal|'E'
block|,
literal|'n'
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8/GT	TRAIM setup/status: msg on traim on	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Enx
index|[]
init|=
block|{
literal|'E'
block|,
literal|'n'
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8/GT	TRAIM setup/status: msg on traim off	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Fa
index|[]
init|=
block|{
literal|'F'
block|,
literal|'a'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8	Self Test				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ga
index|[]
init|=
block|{
literal|'G'
block|,
literal|'a'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position Set				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gax
index|[]
init|=
block|{
literal|'G'
block|,
literal|'a'
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* 12	Position Set: Read			*/
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/*							*/
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*							*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gb
index|[]
init|=
block|{
literal|'G'
block|,
literal|'b'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	set Date/Time				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gc
index|[]
init|=
block|{
literal|'G'
block|,
literal|'c'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	PPS Control: On Cont			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gd0
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position Control: 3D (no hold)		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gd1
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position Control: 0D (3D hold)		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gd2
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position Control: 2D (Alt Hold) 	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gd3
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position Coltrol: Start Site Survey	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ge0
index|[]
init|=
block|{
literal|'G'
block|,
literal|'e'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* M12+T	TRAIM: off				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ge
index|[]
init|=
block|{
literal|'G'
block|,
literal|'e'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* M12+T	TRAIM: on				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gj
index|[]
init|=
block|{
literal|'G'
block|,
literal|'j'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8?/12	Leap Second Pending			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ha0
index|[]
init|=
block|{
literal|'H'
block|,
literal|'a'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position/Data/Status: off		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ha
index|[]
init|=
block|{
literal|'H'
block|,
literal|'a'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position/Data/Status: on		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Hn0
index|[]
init|=
block|{
literal|'H'
block|,
literal|'n'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	TRAIM Status: off			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Hn
index|[]
init|=
block|{
literal|'H'
block|,
literal|'n'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	TRAIM Status: on			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ia
index|[]
init|=
block|{
literal|'I'
block|,
literal|'a'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Self Test				*/
end_comment

begin_comment
comment|/* it appears that as of 1997/1998, the UT had As,At, but not Au,Av  *				    the GT had Au,Av, but not As,At  * This was as of v2.0 of both firmware sets. possibly 1.3 for UT.  * Bj in UT at v1.3  * dont see Bd in UT/GT thru 1999  * Gj in UT as of 3.0, 1999 , Bj as of 1.3  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Month
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jly"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEVICE1
value|"/dev/oncore.serial.%d"
end_define

begin_comment
comment|/* name of serial device */
end_comment

begin_define
define|#
directive|define
name|DEVICE2
value|"/dev/oncore.pps.%d"
end_define

begin_comment
comment|/* name of pps device */
end_comment

begin_define
define|#
directive|define
name|INIT_FILE
value|"/etc/ntp.oncore"
end_define

begin_comment
comment|/* optional init file */
end_comment

begin_define
define|#
directive|define
name|SPEED
value|B9600
end_define

begin_comment
comment|/* Oncore Binary speed (9600 bps) */
end_comment

begin_comment
comment|/*  * Assemble and disassemble 32bit signed quantities from a buffer.  *  */
end_comment

begin_comment
comment|/* to buffer, int w, u_char *buf */
end_comment

begin_define
define|#
directive|define
name|w32_buf
parameter_list|(
name|buf
parameter_list|,
name|w
parameter_list|)
value|{ u_int i_tmp;			   \ 			  i_tmp = (w<0) ? (~(-w)+1) : (w); \ 			  (buf)[0] = (i_tmp>> 24)& 0xff; \ 			  (buf)[1] = (i_tmp>> 16)& 0xff; \ 			  (buf)[2] = (i_tmp>>	8)& 0xff; \ 			  (buf)[3] = (i_tmp	 )& 0xff; \ 			}
end_define

begin_define
define|#
directive|define
name|w32
parameter_list|(
name|buf
parameter_list|)
value|(((buf)[0]&0xff)<< 24 | \ 		       ((buf)[1]&0xff)<< 16 | \ 		       ((buf)[2]&0xff)<<  8 | \ 		       ((buf)[3]&0xff) )
end_define

begin_comment
comment|/* from buffer, char *buf, result to an int */
end_comment

begin_define
define|#
directive|define
name|buf_w32
parameter_list|(
name|buf
parameter_list|)
value|(((buf)[0]&0200) ? (-(~w32(buf)+1)) : w32(buf))
end_define

begin_comment
comment|/*  * oncore_start - initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|oncore_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|char
name|device1
index|[
literal|30
index|]
decl_stmt|,
name|device2
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|stat
name|stat1
decl_stmt|,
name|stat2
decl_stmt|;
comment|/* OPEN DEVICES */
comment|/* opening different devices for fd1 and fd2 presents no problems */
comment|/* opening the SAME device twice, seems to be OS dependent. 		(a) on Linux (no streams) no problem 		(b) on SunOS (and possibly Solaris, untested), (streams) 			never see the line discipline. 	   Since things ALWAYS work if we only open the device once, we check 	     to see if the two devices are in fact the same, then proceed to 	     do one open or two. 	*/
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device1
argument_list|,
name|DEVICE1
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device2
argument_list|,
name|DEVICE2
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|device1
argument_list|,
operator|&
name|stat1
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: stat fd1"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|device2
argument_list|,
operator|&
name|stat2
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: stat fd2"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* create instance structure for this unit */
if|if
condition|(
operator|!
operator|(
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|instance
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|instance
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat1
operator|.
name|st_dev
operator|==
name|stat2
operator|.
name|st_dev
operator|)
operator|&&
operator|(
name|stat1
operator|.
name|st_ino
operator|==
name|stat2
operator|.
name|st_ino
operator|)
condition|)
block|{
comment|/* same device here */
if|if
condition|(
operator|!
operator|(
name|fd1
operator|=
name|refclock_open
argument_list|(
name|device1
argument_list|,
name|SPEED
argument_list|,
name|LDISC_RAW
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCDCDTIMESTAMP
argument_list|)
operator||
name|LDISC_PPS
endif|#
directive|endif
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: fd1"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fd2
operator|=
name|fd1
expr_stmt|;
block|}
else|else
block|{
comment|/* different devices here */
if|if
condition|(
operator|!
operator|(
name|fd1
operator|=
name|refclock_open
argument_list|(
name|device1
argument_list|,
name|SPEED
argument_list|,
name|LDISC_RAW
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: fd1"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd2
operator|=
name|open
argument_list|(
name|device2
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: fd2"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* initialize miscellaneous variables */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|instance
expr_stmt|;
name|instance
operator|->
name|pp
operator|=
name|pp
expr_stmt|;
name|instance
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|instance
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|instance
operator|->
name|assert
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|once
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
literal|"ONCORE DRIVER -- CONFIGURING"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_NO_IDEA
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_NO_IDEA"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ttyfd
operator|=
name|fd1
expr_stmt|;
name|instance
operator|->
name|ppsfd
operator|=
name|fd2
expr_stmt|;
name|instance
operator|->
name|Bj_day
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|traim
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|traim_in
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|chan_in
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UNKNOWN
expr_stmt|;
name|instance
operator|->
name|mode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_UNKNOWN
expr_stmt|;
name|instance
operator|->
name|Ag
operator|=
literal|0xff
expr_stmt|;
comment|/* Satellite mask angle, unset by user */
name|instance
operator|->
name|ant_state
operator|=
name|ONCORE_ANTENNA_UNKNOWN
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
operator|-
literal|26
expr_stmt|;
name|peer
operator|->
name|minpoll
operator|=
literal|4
expr_stmt|;
name|peer
operator|->
name|maxpoll
operator|=
literal|4
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
literal|"Motorola Oncore GPS Receiver"
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
literal|"GPS\0"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
comment|/* go read any input data in /etc/ntp.oncoreX or /etc/ntp/oncore.X */
name|oncore_read_config
argument_list|(
name|instance
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
if|if
condition|(
name|time_pps_create
argument_list|(
name|fd2
argument_list|,
operator|&
name|instance
operator|->
name|pps_h
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"time_pps_create"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|cp
operator|=
literal|"Initializing timing to Assert."
expr_stmt|;
else|else
name|cp
operator|=
literal|"Initializing timing to Clear."
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|hardpps
condition|)
block|{
name|cp
operator|=
literal|"HARDPPS Set."
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oncore_ppsapi
argument_list|(
name|instance
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|oncore_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd1
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"io_addclock"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|instance
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ONCORE_SHMEM_STATUS
comment|/* 	 * Before starting ONCORE, lets setup SHMEM 	 * This will include merging an old SHMEM into the new one if 	 * an old one is found. 	 */
name|oncore_init_shmem
argument_list|(
name|instance
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This will return the Model of the Oncore receiver. 	 * and start the Initialization loop in oncore_msg_Cj. 	 */
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_CHECK_ID
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_CHECK_ID"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|4
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cg
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set Posn Fix mode (not Idle (VP)) */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
name|instance
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fudge control (get Flag2 and Flag3, not available at oncore_start time.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_control
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* unit (not used) */
name|struct
name|refclockstat
modifier|*
name|in
parameter_list|,
comment|/* input parameters  (not used) */
name|struct
name|refclockstat
modifier|*
name|out
parameter_list|,
comment|/* output parameters (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|instance
operator|->
name|assert
operator|=
operator|!
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
operator|)
expr_stmt|;
name|instance
operator|->
name|hardpps
operator|=
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|cp
operator|=
literal|"Resetting timing to Assert."
expr_stmt|;
else|else
name|cp
operator|=
literal|"Resetting timing to Clear."
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|hardpps
condition|)
block|{
name|cp
operator|=
literal|"HARDPPS Set."
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|oncore_ppsapi
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * oncore_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|oncore_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|instance
operator|->
name|ppsfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmemfd
condition|)
name|close
argument_list|(
name|instance
operator|->
name|shmemfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * oncore_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|oncore_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|timeout
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|instance
operator|->
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
literal|"Oncore: No response from @@Cj, shutting down driver"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_shutdown
argument_list|(
name|unit
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
literal|"Oncore: Resend @@Cj"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|instance
operator|->
name|pollcnt
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|instance
operator|->
name|pollcnt
operator|--
expr_stmt|;
name|peer
operator|->
name|procptr
operator|->
name|polls
operator|++
expr_stmt|;
name|instance
operator|->
name|polled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize PPSAPI  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_function
specifier|static
name|int
name|oncore_ppsapi
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|time_pps_getcap
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getcap failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|time_pps_getparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|instance
operator|->
name|pps_p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getparams failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* nb. only turn things on, if someone else has turned something 	 *	on before we get here, leave it alone! 	 */
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
block|{
comment|/* nb, default or ON */
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator|=
name|PPS_CAPTUREASSERT
operator||
name|PPS_OFFSETASSERT
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|assert_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|assert_offset
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator|=
name|PPS_CAPTURECLEAR
operator||
name|PPS_OFFSETCLEAR
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|clear_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|clear_offset
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator||=
name|PPS_TSFMT_TSPEC
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator|&=
name|mode
expr_stmt|;
comment|/* only set what is legal */
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|instance
operator|->
name|pps_p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"time_pps_setparams"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If HARDPPS is on, we tell kernel */
if|if
condition|(
name|instance
operator|->
name|hardpps
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|i
operator|=
name|PPS_CAPTUREASSERT
expr_stmt|;
else|else
name|i
operator|=
name|PPS_CAPTURECLEAR
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|mode
condition|)
block|{
if|if
condition|(
name|time_pps_kcbind
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
name|PPS_KC_HARDPPS
argument_list|,
name|i
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_kcbind failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pps_enable
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ONCORE_SHMEM_STATUS
end_ifdef

begin_function
specifier|static
name|void
name|oncore_init_shmem
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|n
decl_stmt|,
name|fd
decl_stmt|,
name|shmem_old_size
decl_stmt|,
name|n1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|shmem_old
decl_stmt|;
name|struct
name|msg_desc
modifier|*
name|mp
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|size_t
name|shmem_length
decl_stmt|;
comment|/* 	* The first thing we do is see if there is an instance->shmem_fname file (still) 	* out there from a previous run.  If so, we copy it in and use it to initialize 	* shmem (so we won't lose our almanac if we need it). 	*/
name|shmem_old
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"LOAD:SHMEM"
argument_list|)
expr_stmt|;
else|else
block|{
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|shmem_old_size
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
name|shmem_old
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|sbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmem_old
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|read
argument_list|(
name|fd
argument_list|,
name|shmem_old
argument_list|,
name|shmem_old_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* OK, we now create the NEW SHMEM. */
if|if
condition|(
operator|(
name|instance
operator|->
name|shmemfd
operator|=
name|open
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* see how big it needs to be */
name|n
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|oncore_messages
init|;
name|mp
operator|->
name|flag
index|[
literal|0
index|]
condition|;
name|mp
operator|++
control|)
block|{
name|mp
operator|->
name|shmem
operator|=
name|n
expr_stmt|;
comment|/* Allocate space for multiplexed almanac, and 0D/2D/3D @@Ea records */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Cb
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|34
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ba"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Ba
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ea"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Ea
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ha"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Ha
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|3
expr_stmt|;
block|}
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
expr_stmt|;
block|}
name|shmem_length
operator|=
name|n
operator|+
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ONCORE: SHMEM length: %d bytes\n"
argument_list|,
operator|(
name|int
operator|)
name|shmem_length
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|shmem_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|instance
operator|->
name|shmemfd
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|shmem_length
argument_list|)
expr_stmt|;
comment|/* next build the new SHMEM buffer in memory */
for|for
control|(
name|mp
operator|=
name|oncore_messages
init|;
name|mp
operator|->
name|flag
index|[
literal|0
index|]
condition|;
name|mp
operator|++
control|)
block|{
name|l
operator|=
name|mp
operator|->
name|shmem
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|0
index|]
operator|=
name|mp
operator|->
name|len
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|1
index|]
operator|=
name|mp
operator|->
name|len
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|3
index|]
operator|=
literal|'@'
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|4
index|]
operator|=
literal|'@'
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|5
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|0
index|]
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|6
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ba"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ea"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ha"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
condition|)
name|n
operator|=
literal|35
expr_stmt|;
else|else
name|n
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|0
index|]
operator|=
name|mp
operator|->
name|len
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|1
index|]
operator|=
name|mp
operator|->
name|len
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|3
index|]
operator|=
literal|'@'
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|4
index|]
operator|=
literal|'@'
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|5
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|0
index|]
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|6
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* we now walk thru the two buffers (shmem_old and buf, soon to become shmem) 	 * copying the data in shmem_old to buf.  When we are done we write it out 	 * and free both buffers. 	 * If the structures change (an addition or deletion) I will stop copying. 	 * The two will be the same unless we add/subtract from the oncore_messages list 	 * so this should work most of the time, and takes a lot less code than doing it right. 	 */
if|if
condition|(
name|shmem_old
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|buf
operator|+
literal|4
operator|,
name|cp1
operator|=
name|shmem_old
operator|+
literal|4
init|;
operator|(
name|n
operator|=
literal|256
operator|*
operator|(
operator|*
operator|(
name|cp
operator|-
literal|3
operator|)
operator|)
operator|+
operator|*
operator|(
name|cp
operator|-
literal|2
operator|)
operator|)
condition|;
name|cp
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
operator|,
name|cp1
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
control|)
block|{
name|n1
operator|=
literal|256
operator|*
operator|(
operator|*
operator|(
name|cp1
operator|-
literal|3
operator|)
operator|)
operator|+
operator|*
operator|(
name|cp1
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|n1
operator|!=
name|n
operator|||
name|strncmp
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
literal|4
argument_list|)
condition|)
break|break;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
operator|(
name|size_t
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|shmem_old
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|write
argument_list|(
name|instance
operator|->
name|shmemfd
argument_list|,
name|buf
argument_list|,
name|shmem_length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|shmem_length
condition|)
block|{
name|perror
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|instance
operator|->
name|shmemfd
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|shmem
operator|=
operator|(
name|u_char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|shmem_length
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
ifdef|#
directive|ifdef
name|MAP_HASSEMAPHORE
name|MAP_HASSEMAPHORE
operator||
endif|#
directive|endif
name|MAP_SHARED
argument_list|,
name|instance
operator|->
name|shmemfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem
operator|==
operator|(
name|u_char
operator|*
operator|)
name|MAP_FAILED
condition|)
block|{
name|instance
operator|->
name|shmem
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|instance
operator|->
name|shmemfd
argument_list|)
expr_stmt|;
return|return;
block|}
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"SHMEM (size = %d) is CONFIGURED and available as %s"
argument_list|,
name|shmem_length
argument_list|,
name|instance
operator|->
name|shmem_fname
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ONCORE_SHMEM_STATUS */
end_comment

begin_comment
comment|/*  * Read Input file if it exists.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_read_config
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
comment|/*  * First we try to open the configuration file  *    /etc/oncoreN  * where N is the unit number viz 127.127.30.N.  * If we don't find it we try  *    /etc/ntp.oncore.N  * and then  *    /etc/ntp.oncore  *  * If we don't find any then we don't have the cable delay or PPS offset  * and we choose MODE (4) below.  *  * Five Choices for MODE  *    (0) ONCORE is preinitialized, don't do anything to change it.  *	    nb, DON'T set 0D mode, DON'T set Delay, position...  *    (1) NO RESET, Read Position, delays from data file, lock it in, go to 0D mode.  *    (2) NO RESET, Read Delays from data file, do SITE SURVEY to get position,  *		    lock this in, go to 0D mode.  *    (3) HARD RESET, Read Position, delays from data file, lock it in, go to 0D mode.  *    (4) HARD RESET, Read Delays from data file, do SITE SURVEY to get position,  *		    lock this in, go to 0D mode.  *     NB. If a POSITION is specified in the config file with mode=(2,4) [SITE SURVEY]  *	   then this position is set as the INITIAL position of the ONCORE.  *	   This can reduce the time to first fix.  * -------------------------------------------------------------------------------  * Note that an Oncore UT without a battery backup retains NO information if it is  *   power cycled, with a Battery Backup it remembers the almanac, etc.  * For an Oncore VP, there is an eeprom that will contain this data, along with the  *   option of Battery Backup.  * So a UT without Battery Backup is equivalent to doing a HARD RESET on each  *   power cycle, since there is nowhere to store the data.  * -------------------------------------------------------------------------------  *  * If we open one or the other of the files, we read it looking for  *   MODE, LAT, LON, (HT, HTGPS, HTMSL), DELAY, OFFSET, ASSERT, CLEAR, HARDPPS,  *   STATUS, POSN3D, POSN2D, CHAN, TRAIM  * then initialize using method MODE.  For Mode = (1,3) all of (LAT, LON, HT) must  *   be present or mode reverts to (2,4).  *  * Read input file.  *  *	# is comment to end of line  *	= allowed between 1st and 2nd fields.  *  *	Expect to see one line with 'MODE' as first field, followed by an integer  *	   in the range 0-4 (default = 4).  *  *	Expect to see two lines with 'LONG', 'LAT' followed by 1-3 fields.  *	All numbers are floating point.  *		DDD.ddd  *		DDD  MMM.mmm  *		DDD  MMM  SSS.sss  *  *	Expect to see one line with 'HT' as first field,  *	   followed by 1-2 fields.  First is a number, the second is 'FT' or 'M'  *	   for feet or meters.	HT is the height above the GPS ellipsoid.  *	   If the receiver reports height in both GPS and MSL, then we will report  *	   the difference GPS-MSL on the clockstats file.  *  *	There is an optional line, starting with DELAY, followed  *	   by 1 or two fields.	The first is a number (a time) the second is  *	   'MS', 'US' or 'NS' for miliseconds, microseconds or nanoseconds.  *	    DELAY  is cable delay, typically a few tens of ns.  *  *	There is an optional line, starting with OFFSET, followed  *	   by 1 or two fields.	The first is a number (a time) the second is  *	   'MS', 'US' or 'NS' for miliseconds, microseconds or nanoseconds.  *	   OFFSET is the offset of the PPS pulse from 0. (only fully implemented  *		with the PPSAPI, we need to be able to tell the Kernel about this  *		offset if the Kernel PLL is in use, but can only do this presently  *		when using the PPSAPI interface.  If not using the Kernel PLL,  *		then there is no problem.  *  *	There is an optional line, with either ASSERT or CLEAR on it, which  *	   determine which transition of the PPS signal is used for timing by the  *	   PPSAPI.  If neither is present, then ASSERT is assumed.  *	   ASSERT/CLEAR can also be set with FLAG2 of the ntp.conf input.  *	   For Flag2, ASSERT=0, and hence is default.  *  *	There is an optional line, with HARDPPS on it.	Including this line causes  *	   the PPS signal to control the kernel PLL.  *	   HARDPPS can also be set with FLAG3 of the ntp.conf input.  *	   For Flag3, 0 is disabled, and the default.  *  *	There are three options that have to do with using the shared memory option.  *	   First, to enable the option there must be a SHMEM line with a file name.  *	   The file name is the file associated with the shared memory.  *  *	In shared memory, there is one 'record' for each returned variable.  *	For the @@Ea data there are three 'records' containing position data.  *	   There will always be data in the record corresponding to the '0D' @@Ea record,  *	   and the user has a choice of filling the '3D' record by specifying POSN3D,  *	   or the '2D' record by specifying POSN2D.  In either case the '2D' or '3D'  *	   record is filled once every 15s.  *  *	Two additional variables that can be set are CHAN and TRAIM.  These should be  *	   set correctly by the code examining the @@Cj record, but we bring them out here  *	   to allow the user to override either the # of channels, or the existence of TRAIM.  *	   CHAN expects to be followed by in integer: 6, 8, or 12. TRAIM expects to be  *	   followed by YES or NO.  *  *	There is an optional line with MASK on it followed by one integer field in the  *	   range 0 to 89. This sets the satellite mask angle and will determine the minimum  *	   elevation angle for satellites to be tracked by the receiver. The default value  *	   is 10 deg for the VP and 0 deg for all other receivers.  *  * So acceptable input would be  *	# these are my coordinates (RWC)  *	LON  -106 34.610  *	LAT    35 08.999  *	HT	1589	# could equally well say HT 5215 FT  *	DELAY  60 ns  */
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cc
decl_stmt|,
modifier|*
name|ca
decl_stmt|,
name|line
index|[
literal|100
index|]
decl_stmt|,
name|units
index|[
literal|2
index|]
decl_stmt|,
name|device
index|[
literal|20
index|]
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sign
decl_stmt|,
name|lat_flg
decl_stmt|,
name|long_flg
decl_stmt|,
name|ht_flg
decl_stmt|,
name|mode
decl_stmt|,
name|mask
decl_stmt|;
name|double
name|f1
decl_stmt|,
name|f2
decl_stmt|,
name|f3
decl_stmt|;
name|sprintf
argument_list|(
name|device
argument_list|,
literal|"%s%d"
argument_list|,
name|INIT_FILE
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* try "ntp.oncore0" first */
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|device
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/*   it was in the original documentation */
name|sprintf
argument_list|(
name|device
argument_list|,
literal|"%s.%d"
argument_list|,
name|INIT_FILE
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* then try "ntp.oncore.0 */
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|device
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|INIT_FILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* and finally "ntp.oncore" */
name|instance
operator|->
name|init_type
operator|=
literal|4
expr_stmt|;
return|return;
block|}
block|}
block|}
name|mode
operator|=
name|mask
operator|=
literal|0
expr_stmt|;
name|lat_flg
operator|=
name|long_flg
operator|=
name|ht_flg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|100
argument_list|,
name|fd
argument_list|)
condition|)
block|{
comment|/* Remove comments */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'#'
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove trailing space */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
init|;
name|i
operator|>
literal|0
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
name|line
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|line
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|;
control|)
name|line
index|[
operator|--
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove leading space */
for|for
control|(
name|cc
operator|=
name|line
init|;
operator|*
name|cc
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|)
condition|;
name|cc
operator|++
control|)
continue|continue;
comment|/* Stop if nothing left */
if|if
condition|(
operator|!
operator|*
name|cc
condition|)
continue|continue;
comment|/* Uppercase the command and find the arg */
for|for
control|(
name|ca
operator|=
name|cc
init|;
operator|*
name|ca
condition|;
name|ca
operator|++
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
condition|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
condition|)
block|{
operator|*
name|ca
operator|=
name|toupper
argument_list|(
operator|*
name|ca
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|||
operator|(
operator|*
name|ca
operator|==
literal|'='
operator|)
condition|)
break|break;
block|}
block|}
comment|/* Remove space (and possible =) leading the arg */
for|for
control|(
init|;
operator|*
name|ca
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|&&
operator|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|||
operator|(
operator|*
name|ca
operator|==
literal|'='
operator|)
operator|)
condition|;
name|ca
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"STATUS"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"SHMEM"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|ca
argument_list|)
expr_stmt|;
name|instance
operator|->
name|shmem_fname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|,
name|ca
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Uppercase argument as well */
for|for
control|(
name|cp
operator|=
name|ca
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|&&
name|islower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"LAT"
argument_list|,
operator|(
name|size_t
operator|)
literal|3
argument_list|)
condition|)
block|{
name|f1
operator|=
name|f2
operator|=
name|f3
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %lf %lf"
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|,
operator|&
name|f3
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
condition|)
block|{
name|f1
operator|=
operator|-
name|f1
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|instance
operator|->
name|ss_lat
operator|=
name|sign
operator|*
literal|1000
operator|*
operator|(
name|fabs
argument_list|(
name|f3
argument_list|)
operator|+
literal|60
operator|*
operator|(
name|fabs
argument_list|(
name|f2
argument_list|)
operator|+
literal|60
operator|*
name|f1
operator|)
operator|)
expr_stmt|;
comment|/*miliseconds*/
name|lat_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"LON"
argument_list|,
operator|(
name|size_t
operator|)
literal|3
argument_list|)
condition|)
block|{
name|f1
operator|=
name|f2
operator|=
name|f3
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %lf %lf"
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|,
operator|&
name|f3
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
condition|)
block|{
name|f1
operator|=
operator|-
name|f1
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|instance
operator|->
name|ss_long
operator|=
name|sign
operator|*
literal|1000
operator|*
operator|(
name|fabs
argument_list|(
name|f3
argument_list|)
operator|+
literal|60
operator|*
operator|(
name|fabs
argument_list|(
name|f2
argument_list|)
operator|+
literal|60
operator|*
name|f1
operator|)
operator|)
expr_stmt|;
comment|/*miliseconds*/
name|long_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"HT"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'F'
condition|)
name|f1
operator|=
literal|0.3048
operator|*
name|f1
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
literal|100
operator|*
name|f1
expr_stmt|;
comment|/* cm */
name|ht_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"DELAY"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'U'
condition|)
name|f1
operator|=
literal|1000
operator|*
name|f1
expr_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
name|f1
operator|=
literal|1000000
operator|*
name|f1
expr_stmt|;
else|else
name|f1
operator|=
literal|1000000000
operator|*
name|f1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|1.e9
condition|)
name|f1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|999999
condition|)
block|{
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"PPS Cable delay of %fns out of Range, ignored"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
else|else
name|instance
operator|->
name|delay
operator|=
name|f1
expr_stmt|;
comment|/* delay in ns */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"OFFSET"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'U'
condition|)
name|f1
operator|=
literal|1000
operator|*
name|f1
expr_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
name|f1
operator|=
literal|1000000
operator|*
name|f1
expr_stmt|;
else|else
name|f1
operator|=
literal|1000000000
operator|*
name|f1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|1.e9
condition|)
name|f1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|999999999.
condition|)
block|{
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"PPS Offset of %fns out of Range, ignored"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
else|else
name|instance
operator|->
name|offset
operator|=
name|f1
expr_stmt|;
comment|/* offset in ns */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"MODE"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
literal|0
operator|||
name|mode
operator|>
literal|4
condition|)
name|mode
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"ASSERT"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|instance
operator|->
name|assert
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"CLEAR"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|instance
operator|->
name|assert
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"HARDPPS"
argument_list|,
operator|(
name|size_t
operator|)
literal|7
argument_list|)
condition|)
block|{
name|instance
operator|->
name|hardpps
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"POSN2D"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Posn
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"POSN3D"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Posn
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"CHAN"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|6
operator|)
operator|||
operator|(
name|i
operator|==
literal|8
operator|)
operator|||
operator|(
name|i
operator|==
literal|12
operator|)
condition|)
name|instance
operator|->
name|chan_in
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"TRAIM"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|instance
operator|->
name|traim_in
operator|=
literal|1
expr_stmt|;
comment|/* so TRAIM alone is YES */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ca
argument_list|,
literal|"NO"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ca
argument_list|,
literal|"OFF"
argument_list|)
condition|)
comment|/* Yes/No, On/Off */
name|instance
operator|->
name|traim_in
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"MASK"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|>
operator|-
literal|1
operator|&&
name|mask
operator|<
literal|90
condition|)
name|instance
operator|->
name|Ag
operator|=
name|mask
expr_stmt|;
comment|/* Satellite mask angle */
block|}
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 *    OK, have read all of data file, and extracted the good stuff. 	 *    If lat/long/ht specified they ALL must be specified for mode = (1,3). 	 */
name|instance
operator|->
name|posn_set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lat_flg
operator|&&
name|long_flg
operator|&&
name|ht_flg
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: incomplete data on %s\n"
argument_list|,
name|INIT_FILE
argument_list|)
expr_stmt|;
name|instance
operator|->
name|posn_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|1
operator|||
name|mode
operator|==
literal|3
condition|)
block|{
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Input Mode = %d, but no/incomplete position, mode set to %d"
argument_list|,
name|mode
argument_list|,
name|mode
operator|+
literal|1
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|mode
operator|++
expr_stmt|;
block|}
block|}
name|instance
operator|->
name|init_type
operator|=
name|mode
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Input mode = %d"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * move data from NTP to buffer (toss the extra in the unlikely case it won't fit)  */
end_comment

begin_function
specifier|static
name|void
name|oncore_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
if|#
directive|if
literal|0
block|if (debug> 4) { 		int i; 		printf("ONCORE:>>>"); 		for(i=0; i<rbufp->recv_length; i++) 			printf("%02x ", p[i]); 		printf("\n"); 		printf("ONCORE:>>>"); 		for(i=0; i<rbufp->recv_length; i++) 			printf("%03o ", p[i]); 		printf("\n"); 	}
endif|#
directive|endif
name|i
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|rcvbuf
operator|+
name|rcvptr
operator|+
name|i
operator|>
operator|&
name|rcvbuf
index|[
sizeof|sizeof
name|rcvbuf
index|]
condition|)
name|i
operator|=
sizeof|sizeof
argument_list|(
name|rcvbuf
argument_list|)
operator|-
name|rcvptr
expr_stmt|;
comment|/* and some char will be lost */
name|memcpy
argument_list|(
name|rcvbuf
operator|+
name|rcvptr
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rcvptr
operator|+=
name|i
expr_stmt|;
name|oncore_consume
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deal with any complete messages  */
end_comment

begin_function
specifier|static
name|void
name|oncore_consume
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
name|unsigned
name|l
decl_stmt|;
while|while
condition|(
name|rcvptr
operator|>=
literal|7
condition|)
block|{
if|if
condition|(
name|rcvbuf
index|[
literal|0
index|]
operator|!=
literal|'@'
operator|||
name|rcvbuf
index|[
literal|1
index|]
operator|!=
literal|'@'
condition|)
block|{
comment|/* We're not in sync, lets try to get there */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rcvptr
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rcvbuf
index|[
name|i
index|]
operator|==
literal|'@'
operator|&&
name|rcvbuf
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'@'
condition|)
break|break;
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"ONCORE[%d]:>>> skipping %d chars\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|rcvptr
condition|)
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
name|i
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|rcvptr
operator|-
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* Ok, we have a header now */
name|l
operator|=
sizeof|sizeof
argument_list|(
name|oncore_messages
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|oncore_messages
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|l
condition|;
name|m
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|oncore_messages
index|[
name|m
index|]
operator|.
name|flag
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|rcvbuf
operator|+
literal|2
operator|)
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|l
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"ONCORE[%d]:>>> Unknown MSG, skipping 4 (%c%c)\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|rcvbuf
index|[
literal|2
index|]
argument_list|,
name|rcvbuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
literal|4
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
literal|4
expr_stmt|;
continue|continue;
block|}
name|l
operator|=
name|oncore_messages
index|[
name|m
index|]
operator|.
name|len
expr_stmt|;
if|#
directive|if
literal|0
block|if (debug> 3) 			printf("ONCORE[%d]: GOT: %c%c  %d of %d entry %d\n", instance->unit, rcvbuf[2], rcvbuf[3], rcvptr, l, m);
endif|#
directive|endif
comment|/* Got the entire message ? */
if|if
condition|(
name|rcvptr
operator|<
name|l
condition|)
return|return;
comment|/* are we at the end of message? should be<Cksum><CR><LF> */
if|if
condition|(
name|rcvbuf
index|[
name|l
operator|-
literal|2
index|]
operator|!=
literal|'\r'
operator|||
name|rcvbuf
index|[
name|l
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ONCORE[%d]: NO<CR><LF> at end of message\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* check the CheckSum */
if|if
condition|(
name|oncore_checksum_ok
argument_list|(
name|rcvbuf
argument_list|,
name|l
argument_list|)
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|shmem
operator|!=
name|NULL
condition|)
block|{
name|instance
operator|->
name|shmem
index|[
name|oncore_messages
index|[
name|m
index|]
operator|.
name|shmem
operator|+
literal|2
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|instance
operator|->
name|shmem
operator|+
name|oncore_messages
index|[
name|m
index|]
operator|.
name|shmem
operator|+
literal|3
argument_list|,
name|rcvbuf
argument_list|,
operator|(
name|size_t
operator|)
name|l
argument_list|)
expr_stmt|;
block|}
name|oncore_msg_any
argument_list|(
name|instance
argument_list|,
name|rcvbuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|l
operator|-
literal|3
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|oncore_messages
index|[
name|m
index|]
operator|.
name|handler
condition|)
name|oncore_messages
index|[
name|m
index|]
operator|.
name|handler
argument_list|(
name|instance
argument_list|,
name|rcvbuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|l
operator|-
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE[%d]: Checksum mismatch!\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ONCORE[%d]: @@%c%c "
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|rcvbuf
index|[
literal|2
index|]
argument_list|,
name|rcvbuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%03o "
argument_list|,
name|rcvbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l
operator|!=
name|rcvptr
condition|)
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
name|l
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|rcvptr
operator|-
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
name|l
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_get_timestamp
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|long
name|dt1
parameter_list|,
comment|/* tick offset THIS time step */
name|long
name|dt2
comment|/* tick offset NEXT time step */
parameter_list|)
block|{
name|int
name|Rsm
decl_stmt|;
name|u_long
name|i
decl_stmt|,
name|j
decl_stmt|;
name|l_fp
name|ts
decl_stmt|,
name|ts_tmp
decl_stmt|;
name|double
name|dmy
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|struct
name|timespec
modifier|*
name|tsp
init|=
literal|0
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
modifier|*
name|tsp
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|int
name|current_mode
decl_stmt|;
name|pps_params_t
name|current_params
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|pps_info_t
name|pps_i
decl_stmt|;
else|#
directive|else
comment|/* ! HAVE_PPSAPI */
ifdef|#
directive|ifdef
name|HAVE_CIOGETEV
name|struct
name|ppsclockev
name|ev
decl_stmt|;
name|int
name|r
init|=
name|CIOGETEV
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIOCGPPSEV
name|struct
name|ppsclockev
name|ev
decl_stmt|;
name|int
name|r
init|=
name|TIOCGPPSEV
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TIOCDCDTIMESTAMP
name|struct
name|timeval
name|tv
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ! HAVE_PPS_API */
if|#
directive|if
literal|1
comment|/* If we are in SiteSurvey mode, then we are in 3D mode, and we fall thru. 	 * If we have Finished the SiteSurvey, then we fall thru for the 14/15 	 *  times we get here in 0D mode (the 1/15 is in 3D for SHMEM). 	 * This gives good time, which gets better when the SS is done. 	 */
if|if
condition|(
operator|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_DONE
operator|)
operator|&&
operator|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_0D
operator|)
condition|)
else|#
directive|else
comment|/* old check, only fall thru for SS_DONE and 0D mode, 2h45m wait for ticks */
if|if
condition|(
operator|(
name|instance
operator|->
name|site_survey
operator|!=
name|ONCORE_SS_DONE
operator|)
operator|||
operator|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_0D
operator|)
condition|)
endif|#
directive|endif
return|return;
comment|/* Don't do anything without an almanac to define the GPS->UTC delta */
if|if
condition|(
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
condition|)
return|return;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|j
operator|=
name|instance
operator|->
name|ev_serial
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|time_pps_fetch
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|pps_i
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: time_pps_fetch failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
block|{
name|tsp
operator|=
operator|&
name|pps_i
operator|.
name|assert_timestamp
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|i
operator|=
operator|(
name|u_long
operator|)
name|pps_i
operator|.
name|assert_sequence
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|printf
argument_list|(
literal|"ONCORE[%d]: serial/j (%lu, %lu) %ld.%09ld\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"ONCORE[%d]: serial/j (%lu, %lu) %ld.%06ld\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pps_i
operator|.
name|assert_sequence
operator|==
name|j
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: oncore_get_timestamp, error serial pps\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|pps_i
operator|.
name|assert_sequence
expr_stmt|;
block|}
else|else
block|{
name|tsp
operator|=
operator|&
name|pps_i
operator|.
name|clear_timestamp
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|i
operator|=
operator|(
name|u_long
operator|)
name|pps_i
operator|.
name|clear_sequence
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|printf
argument_list|(
literal|"ONCORE[%d]: serial/j (%lu, %lu) %ld.%09ld\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"ONCORE[%d]: serial/j (%lu, %lu) %ld.%06ld\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pps_i
operator|.
name|clear_sequence
operator|==
name|j
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: oncore_get_timestamp, error serial pps\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|pps_i
operator|.
name|clear_sequence
expr_stmt|;
block|}
comment|/* convert timespec -> ntp l_fp */
name|dmy
operator|=
name|tsp
operator|->
name|tv_nsec
expr_stmt|;
name|dmy
operator|/=
literal|1e9
expr_stmt|;
name|ts
operator|.
name|l_uf
operator|=
name|dmy
operator|*
literal|4294967296.0
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|=
name|tsp
operator|->
name|tv_sec
expr_stmt|;
if|#
directive|if
literal|0
block|alternate code for previous 4 lines is 	dmy = 1.0e-9*tsp->tv_nsec;
comment|/* fractional part */
block|DTOLFP(dmy,&ts); 	dmy = tsp->tv_sec;
comment|/* integer part */
block|DTOLFP(dmy,&ts_tmp); 	L_ADD(&ts,&ts_tmp);      or more simply 	dmy = 1.0e-9*tsp->tv_nsec;
comment|/* fractional part */
block|DTOLFP(dmy,&ts); 	ts.l_ui = tsp->tv_sec;
endif|#
directive|endif
comment|/* 0 */
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TIOCGPPSEV
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_CIOGETEV
argument_list|)
name|j
operator|=
name|instance
operator|->
name|ev_serial
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|instance
operator|->
name|ppsfd
argument_list|,
name|r
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: IOCTL:"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tsp
operator|=
operator|&
name|ev
operator|.
name|tv
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|printf
argument_list|(
literal|"ONCORE: serial/j (%d, %d) %ld.%09ld\n"
argument_list|,
name|ev
operator|.
name|serial
argument_list|,
name|j
argument_list|,
name|tsp
operator|->
name|tv_sec
argument_list|,
name|tsp
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"ONCORE: serial/j (%d, %d) %ld.%06ld\n"
argument_list|,
name|ev
operator|.
name|serial
argument_list|,
name|j
argument_list|,
name|tsp
operator|->
name|tv_sec
argument_list|,
name|tsp
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ev
operator|.
name|serial
operator|==
name|j
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: oncore_get_timestamp, error serial pps\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|ev
operator|.
name|serial
expr_stmt|;
comment|/* convert timeval -> ntp l_fp */
name|TVTOTS
argument_list|(
name|tsp
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|TIOCDCDTIMESTAMP
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|instance
operator|->
name|ppsfd
argument_list|,
name|TIOCDCDTIMESTAMP
argument_list|,
operator|&
name|tv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: ioctl(TIOCDCDTIMESTAMP)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tsp
operator|=
operator|&
name|tv
expr_stmt|;
name|TVTOTS
argument_list|(
name|tsp
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"Cannot compile -- no PPS mechanism configured!"
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* now have timestamp in ts */
comment|/* add in saw_tooth and offset, these will be ZERO if no TRAIM */
comment|/* saw_tooth not really necessary if using TIMEVAL */
comment|/* since its only precise to us, but do it anyway. */
comment|/* offset in ns, and is positive (late), we subtract */
comment|/* to put the PPS time transition back where it belongs */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
comment|/* must hand the offset for the NEXT sec off to the Kernel to do */
comment|/* the addition, so that the Kernel PLL sees the offset too */
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|instance
operator|->
name|pps_p
operator|.
name|assert_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
else|else
name|instance
operator|->
name|pps_p
operator|.
name|clear_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
comment|/* The following code is necessary, and not just a time_pps_setparams, 	 * using the saved instance->pps_p, since some other process on the 	 * machine may have diddled with the mode bits (say adding something 	 * that it needs).  We take what is there and ADD what we need. 	 * [[ The results from the time_pps_getcap is unlikely to change so 	 *    we could probably just save it, but I choose to do the call ]] 	 * Unfortunately, there is only ONE set of mode bits in the kernel per 	 * interface, and not one set for each open handle. 	 * 	 * There is still a race condition here where we might mess up someone 	 * elses mode, but if he is being careful too, he should survive. 	 */
if|if
condition|(
name|time_pps_getcap
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|current_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getcap failed: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|time_pps_getparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|current_params
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getparams failed: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* or current and mine */
name|current_params
operator|.
name|mode
operator||=
name|instance
operator|->
name|pps_p
operator|.
name|mode
expr_stmt|;
comment|/* but only set whats legal */
name|current_params
operator|.
name|mode
operator|&=
name|current_mode
expr_stmt|;
name|current_params
operator|.
name|assert_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|current_params
operator|.
name|assert_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
name|current_params
operator|.
name|clear_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|current_params
operator|.
name|clear_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|current_params
argument_list|)
condition|)
name|perror
argument_list|(
literal|"time_pps_setparams"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* if not PPSAPI, no way to inform kernel of OFFSET, just add the */
comment|/* offset for THIS second */
name|dmy
operator|=
operator|-
literal|1.0e-9
operator|*
name|dt1
expr_stmt|;
name|DTOLFP
argument_list|(
name|dmy
argument_list|,
operator|&
name|ts_tmp
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|ts_tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* have time from UNIX origin, convert to NTP origin. */
name|ts
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|lastrec
operator|=
name|ts
expr_stmt|;
comment|/* print out information about this timestamp (long line) */
name|ts_tmp
operator|=
name|ts
expr_stmt|;
name|ts_tmp
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
comment|/* zero integer part */
name|LFPTOD
argument_list|(
operator|&
name|ts_tmp
argument_list|,
name|dmy
argument_list|)
expr_stmt|;
comment|/* convert fractional part to a double */
name|j
operator|=
literal|1.0e9
operator|*
name|dmy
expr_stmt|;
comment|/* then to integer ns */
name|Rsm
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|Rsm
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|Rsm
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|Rsm
operator|=
operator|(
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|129
index|]
operator|<<
literal|8
operator|)
operator||
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
operator|||
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
name|sprintf
argument_list|(
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|,
comment|/* MAX length 128, currently at 117 */
literal|"%u.%09lu %d %d %2d %2d %2d %2ld rstat   %02x dop %4.1f nsat %2d,%d traim %d sigma %2d neg-sawtooth %3d sat %d%d%d%d%d%d%d%d"
argument_list|,
name|ts
operator|.
name|l_ui
argument_list|,
name|j
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|year
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|day
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|hour
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|minute
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|second
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
operator|%
literal|60
argument_list|,
name|Rsm
argument_list|,
literal|0.1
operator|*
operator|(
literal|256
operator|*
name|instance
operator|->
name|BEHa
index|[
literal|35
index|]
operator|+
name|instance
operator|->
name|BEHa
index|[
literal|36
index|]
operator|)
argument_list|,
comment|/*rsat	dop */
name|instance
operator|->
name|BEHa
index|[
literal|38
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|39
index|]
argument_list|,
name|instance
operator|->
name|BEHn
index|[
literal|21
index|]
argument_list|,
comment|/*	nsat visible,	  nsat tracked,     traim */
name|instance
operator|->
name|BEHn
index|[
literal|23
index|]
operator|*
literal|256
operator|+
name|instance
operator|->
name|BEHn
index|[
literal|24
index|]
argument_list|,
operator|(
name|s_char
operator|)
name|instance
operator|->
name|BEHn
index|[
literal|25
index|]
argument_list|,
comment|/* sigma				   neg-sawtooth */
comment|/*sat*/
name|instance
operator|->
name|BEHa
index|[
literal|41
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|45
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|49
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|53
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|57
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|61
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|65
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|69
index|]
argument_list|)
expr_stmt|;
comment|/* will be 0 for 6 chan */
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|sprintf
argument_list|(
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%u.%09lu %d %d %2d %2d %2d %2ld rstat %02x dop %4.1f nsat %2d,%d traim %d sigma %d neg-sawtooth %3d sat %d%d%d%d%d%d%d%d%d%d%d%d"
argument_list|,
name|ts
operator|.
name|l_ui
argument_list|,
name|j
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|year
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|day
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|hour
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|minute
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|second
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
operator|%
literal|60
argument_list|,
name|Rsm
argument_list|,
literal|0.1
operator|*
operator|(
literal|256
operator|*
name|instance
operator|->
name|BEHa
index|[
literal|53
index|]
operator|+
name|instance
operator|->
name|BEHa
index|[
literal|54
index|]
operator|)
argument_list|,
comment|/*rsat	dop */
name|instance
operator|->
name|BEHa
index|[
literal|55
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|56
index|]
argument_list|,
name|instance
operator|->
name|BEHn
index|[
literal|6
index|]
argument_list|,
comment|/*	nsat visible,	  nsat tracked	 traim */
name|instance
operator|->
name|BEHn
index|[
literal|12
index|]
operator|*
literal|256
operator|+
name|instance
operator|->
name|BEHn
index|[
literal|13
index|]
argument_list|,
operator|(
name|s_char
operator|)
name|instance
operator|->
name|BEHn
index|[
literal|14
index|]
argument_list|,
comment|/* sigma				   neg-sawtooth */
comment|/*sat*/
name|instance
operator|->
name|BEHa
index|[
literal|58
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|70
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|76
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|82
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|88
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|94
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|100
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|106
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|112
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|118
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|124
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ONCORE[%d]: len = %d %s\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|n
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
block|}
comment|/* and some things I dont understnd (magic ntp things) */
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|instance
operator|->
name|pp
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|instance
operator|->
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|instance
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|polled
condition|)
block|{
name|instance
operator|->
name|polled
operator|=
literal|0
expr_stmt|;
comment|/* 		instance->pp->dispersion = instance->pp->skew = 0; */
name|instance
operator|->
name|pp
operator|->
name|lastref
operator|=
name|instance
operator|->
name|pp
operator|->
name|lastrec
expr_stmt|;
name|refclock_receive
argument_list|(
name|instance
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*************** oncore_msg_XX routines start here *******************/
end_comment

begin_comment
comment|/*  * print Oncore response message.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_any
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|oncore_messages
index|[
name|idx
index|]
operator|.
name|fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
name|struct
name|timespec
name|ts
decl_stmt|;
endif|#
directive|endif
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
operator|(
name|void
operator|)
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"ONCORE[%d]: %ld.%06ld\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|fmt
condition|)
block|{
name|printf
argument_list|(
literal|">>@@%c%c "
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|len
operator|&&
name|i
operator|<
literal|2400
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"##"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fmt
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%c%c"
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fmt
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Latitude, Longitude, Height */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Adef
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Mask Angle */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Ag
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
literal|"set to"
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_RUN
condition|)
name|cp
operator|=
literal|"is"
expr_stmt|;
name|instance
operator|->
name|Ag
operator|=
name|buf
index|[
literal|4
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Satellite mask angle %s %d degrees"
argument_list|,
name|cp
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|Ag
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get Position hold position  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_As
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|instance
operator|->
name|ss_lat
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
comment|/* Print out Position */
name|oncore_print_posn
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to use Oncore UT+ Auto Survey Feature  *	If its not there (VP), set flag to do it ourselves.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_At
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|instance
operator|->
name|saw_At
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_TESTING
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|2
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Initiating hardware 3D site survey"
argument_list|)
expr_stmt|;
name|cp
operator|=
literal|"SSstate = ONCORE_SS_HW"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_HW
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * get PPS Offset  * Nb. @@Ay is not supported for early UT (no plus) model  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Ay
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|saw_Ay
condition|)
return|return;
name|instance
operator|->
name|saw_Ay
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|offset
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"PPS Offset is set to %ld ns"
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get Cable Delay  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Az
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|saw_Az
condition|)
return|return;
name|instance
operator|->
name|saw_Az
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|delay
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Cable delay is set to %ld ns"
argument_list|,
name|instance
operator|->
name|delay
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ba, Ea and Ha come here, these contain Position */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_BaEaHa
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* OK, we are close to the RUN state now. 	 * But we have a few more items to initialize first. 	 * 	 * At the beginning of this routine there are several 'timers'. 	 * We enter this routine 1/sec, and since the upper levels of NTP have usurped 	 * the use of timers, we use the 1/sec entry to do things that 	 * we would normally do with timers... 	 */
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_CHECK_CHAN
condition|)
block|{
comment|/* here while checking for the # chan */
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'B'
condition|)
block|{
comment|/* 6chan */
if|if
condition|(
name|instance
operator|->
name|chan_ck
operator|<
literal|6
condition|)
name|instance
operator|->
name|chan_ck
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* 8chan */
if|if
condition|(
name|instance
operator|->
name|chan_ck
operator|<
literal|8
condition|)
name|instance
operator|->
name|chan_ck
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'H'
condition|)
block|{
comment|/* 12chan */
if|if
condition|(
name|instance
operator|->
name|chan_ck
operator|<
literal|12
condition|)
name|instance
operator|->
name|chan_ck
operator|=
literal|12
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|->
name|count3
operator|++
operator|<
literal|5
condition|)
return|return;
name|instance
operator|->
name|count3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan_in
operator|!=
operator|-
literal|1
condition|)
comment|/* set in Input */
name|instance
operator|->
name|chan
operator|=
name|instance
operator|->
name|chan_in
expr_stmt|;
else|else
comment|/* set from test */
name|instance
operator|->
name|chan
operator|=
name|instance
operator|->
name|chan_ck
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Input   says chan = %d"
argument_list|,
name|instance
operator|->
name|chan_in
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Model # says chan = %d"
argument_list|,
name|instance
operator|->
name|chan_id
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Testing says chan = %d"
argument_list|,
name|instance
operator|->
name|chan_ck
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Using        chan = %d"
argument_list|,
name|instance
operator|->
name|chan
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_HAVE_CHAN
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_HAVE_CHAN"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|4
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_ALMANAC
operator|&&
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_RUN
condition|)
return|return;
comment|/* PAUSE 5sec */
if|if
condition|(
name|instance
operator|->
name|count
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|count
operator|++
operator|<
literal|5
condition|)
comment|/* make sure results are stable, using position */
return|return;
name|instance
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|instance
operator|->
name|BEHa
argument_list|,
name|buf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|len
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ba, Ea or Ha */
comment|/* check the antenna and almanac for changes (did it get unplugged, is it ready?) */
name|oncore_check_almanac
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|oncore_check_antenna
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* Almanac mode, waiting for Almanac, we can't do anything till we have it */
comment|/* When we have an almanac, we will start the Bn/En/@@Hn messages */
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_ALMANAC
condition|)
if|if
condition|(
name|oncore_wait_almanac
argument_list|(
name|instance
argument_list|)
condition|)
return|return;
comment|/* do some things once when we get this far in BaEaHa */
if|if
condition|(
name|instance
operator|->
name|once
condition|)
block|{
name|instance
operator|->
name|once
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|count2
operator|=
literal|1
expr_stmt|;
comment|/* Have we seen an @@At (position hold) command response */
comment|/* if not, message out */
if|if
condition|(
name|instance
operator|->
name|chan
operator|!=
literal|12
operator|&&
operator|!
name|instance
operator|->
name|saw_At
condition|)
block|{
name|cp
operator|=
literal|"Not Good, no @@At command (no Position Hold), must be a GT/GT+"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* have an Almanac, can start the SiteSurvey 		 * (actually only need to get past the almanac_load where we diddle with At 		 *  command,- we can't change it after we start the HW_SS below 		 */
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* NO initialization, don't change anything */
case|case
literal|1
case|:
comment|/* Use given Position */
case|case
literal|3
case|:
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
name|cp
operator|=
literal|"SSstate = ONCORE_SS_DONE"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|4
case|:
comment|/* Site Survey */
name|cp
operator|=
literal|"SSstate = ONCORE_SS_TESTING"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_TESTING
expr_stmt|;
name|instance
operator|->
name|count1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd3
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* M12+T */
else|else
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At2
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* not GT, arg not VP */
break|break;
block|}
comment|/* Read back PPS Offset for Output */
comment|/* Nb. This will fail silently for early UT (no plus) and M12 models */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ayx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ayx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read back Cable Delay for Output */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Azx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Azx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read back Satellite Mask Angle for Output */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Agx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Agx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|->
name|count1
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|count1
operator|++
operator|>
literal|5
operator|||
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_HW
condition|)
block|{
name|instance
operator|->
name|count1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_TESTING
condition|)
block|{
comment|/* 				 * For instance->site_survey to still be ONCORE_SS_TESTING, then after a 5sec 				 * wait after the @@At2/@@Gd3 command we have not changed the state to 				 * ONCORE_SS_HW.  If the Hardware is capable of doing a Site Survey, then 				 * the variable would have been changed by now. 				 * There are three possibilities: 				 * 6/8chan 				 *   (a) We did not get a response to the @@At0 or @@At2 commands, 				 *	   and it must be a GT/GT+/SL with no position hold mode. 				 *	   We will have to do it ourselves. 				 *   (b) We saw the @@At0, @@At2 commands, but @@At2 failed, 				 *	   must be a VP or older UT which doesn't have Site Survey mode. 				 *	   We will have to do it ourselves. 				 * 12chan 				 *   (c) We saw the @@Gd command, but @@Gd3 failed, 				 *	   We will have to do it ourselves. 				 */
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Initiating software 3D site survey (%d samples)"
argument_list|,
name|POS_HOLD_AVERAGE
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"SSstate = ONCORE_SS_SW"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_SW
expr_stmt|;
name|instance
operator|->
name|ss_lat
operator|=
name|instance
operator|->
name|ss_long
operator|=
name|instance
operator|->
name|ss_ht
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disable */
else|else
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disable */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disable */
block|}
block|}
block|}
block|}
comment|/* check the mode we are in 0/2/3D */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
operator|&
literal|0x8
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_0D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
operator|&
literal|0x10
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_2D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
operator|&
literal|0x20
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_3D
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
operator|&
literal|0x8
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_0D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
operator|&
literal|0x10
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_2D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
operator|&
literal|0x20
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_3D
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|int
name|bits
decl_stmt|;
name|bits
operator|=
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|129
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
expr_stmt|;
comment|/* actually Ha */
if|if
condition|(
name|bits
operator|==
literal|0x4
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_0D
expr_stmt|;
elseif|else
if|if
condition|(
name|bits
operator|==
literal|0x6
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_2D
expr_stmt|;
elseif|else
if|if
condition|(
name|bits
operator|==
literal|0x7
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_3D
expr_stmt|;
block|}
comment|/* copy the record to the (extra) location in SHMEM */
if|if
condition|(
name|instance
operator|->
name|shmem
condition|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|smp
decl_stmt|;
comment|/* pointer to start of shared mem for Ba/Ea/Ha */
switch|switch
condition|(
name|instance
operator|->
name|chan
condition|)
block|{
case|case
literal|6
case|:
name|smp
operator|=
operator|&
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Ba
index|]
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|smp
operator|=
operator|&
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Ea
index|]
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|smp
operator|=
operator|&
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Ha
index|]
expr_stmt|;
break|break;
default|default:
name|smp
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|instance
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_0D
case|:
name|i
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 0D, Position Hold */
case|case
name|MODE_2D
case|:
name|i
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* 2D, Altitude Hold */
case|case
name|MODE_3D
case|:
name|i
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* 3D fix */
default|default:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
condition|)
block|{
name|i
operator|*=
operator|(
name|len
operator|+
literal|6
operator|)
expr_stmt|;
name|smp
index|[
name|i
operator|+
literal|2
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|smp
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|buf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|len
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * check if timer active 	 * if it hasn't been cleared, then @@Bn/@@En/@@Hn did not respond 	 */
if|if
condition|(
name|instance
operator|->
name|traim_delay
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|traim_delay
operator|++
operator|>
literal|5
condition|)
block|{
name|instance
operator|->
name|traim
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|traim_delay
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
literal|"ONCORE: Did not detect TRAIM response, TRAIM = OFF"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_set_traim
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
block|}
comment|/* by now should have a @@Ba/@@Ea/@@Ha with good data in it */
if|if
condition|(
operator|!
name|instance
operator|->
name|have_dH
operator|&&
operator|!
name|instance
operator|->
name|traim_delay
condition|)
name|oncore_compute_dH
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* 	 * must be ONCORE_RUN if we are here. 	 * Have # chan and TRAIM by now. 	 */
name|instance
operator|->
name|pp
operator|->
name|year
operator|=
name|buf
index|[
literal|6
index|]
operator|*
literal|256
operator|+
name|buf
index|[
literal|7
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|day
operator|=
name|ymd2yd
argument_list|(
name|buf
index|[
literal|6
index|]
operator|*
literal|256
operator|+
name|buf
index|[
literal|7
index|]
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|hour
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|minute
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|second
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
comment|/* 	 * Are we doing a Hardware or Software Site Survey? 	 */
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_HW
operator|||
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_SW
condition|)
name|oncore_ss
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* see if we ever saw a response from the @@Ayx above */
if|if
condition|(
name|instance
operator|->
name|count2
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|count2
operator|++
operator|>
literal|5
condition|)
block|{
comment|/* this delay to check on @@Ay command */
name|instance
operator|->
name|count2
operator|=
literal|0
expr_stmt|;
comment|/* Have we seen an Ay (1PPS time offset) command response */
comment|/* if not, and non-zero offset, zero the offset, and send message */
if|if
condition|(
operator|!
name|instance
operator|->
name|saw_Ay
operator|&&
name|instance
operator|->
name|offset
condition|)
block|{
name|cp
operator|=
literal|"No @@Ay command, PPS OFFSET ignored"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Check the leap second status once per day. 	 */
name|oncore_check_leap_sec
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* 	 * if SHMEM active, every 15s, steal one 'tick' to get 2D or 3D posn. 	 */
if|if
condition|(
name|instance
operator|->
name|shmem
operator|&&
operator|!
name|instance
operator|->
name|shmem_bad_Ea
operator|&&
name|instance
operator|->
name|shmem_Posn
operator|&&
operator|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_DONE
operator|)
condition|)
name|oncore_shmem_get_3D
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance
operator|->
name|traim
condition|)
comment|/* NO traim, no BnEnHn, go get tick */
name|oncore_get_timestamp
argument_list|(
name|instance
argument_list|,
name|instance
operator|->
name|offset
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Almanac Status */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Bd
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Bd: Almanac %s, week = %d, t = %d, %d SVs: %x"
argument_list|,
operator|(
operator|(
name|buf
index|[
literal|4
index|]
operator|)
condition|?
literal|"LOADED"
else|:
literal|"(NONE)"
operator|)
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|,
name|buf
index|[
literal|6
index|]
argument_list|,
name|buf
index|[
literal|7
index|]
argument_list|,
name|w32
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get leap-second warning message */
end_comment

begin_comment
comment|/*  * @@Bj does NOT behave as documented in current Oncore firmware.  * It turns on the LEAP indicator when the data is set, and does not,  * as documented, wait until the beginning of the month when the  * leap second will occur.  * Since this firmware bug will never be fixed in all the outstanding Oncore receivers  * @@Bj is only called in June/December.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Bj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|4
index|]
condition|)
block|{
case|case
literal|1
case|:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_ADDSECOND"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_DELSECOND"
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_NOWARNING"
expr_stmt|;
break|break;
block|}
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_msg_BnEnHn
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|long
name|dt1
decl_stmt|,
name|dt2
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_RUN
condition|)
return|return;
if|if
condition|(
name|instance
operator|->
name|traim_delay
condition|)
block|{
comment|/* flag that @@Bn/@@En/Hn returned */
name|instance
operator|->
name|traim_ck
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|traim_delay
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
literal|"ONCORE: Detected TRAIM, TRAIM = ON"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_set_traim
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|instance
operator|->
name|BEHn
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
comment|/* Bn or En or Hn */
comment|/* If Time RAIM doesn't like it, don't trust it */
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'H'
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|BEHn
index|[
literal|6
index|]
condition|)
comment|/* bad TRAIM */
return|return;
name|dt1
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
comment|/* dt this time step */
name|instance
operator|->
name|saw_tooth
operator|=
operator|(
name|s_char
operator|)
name|instance
operator|->
name|BEHn
index|[
literal|10
index|]
expr_stmt|;
comment|/* update for next time Hn[10] */
name|dt2
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
comment|/* dt next time step */
block|}
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|BEHn
index|[
literal|21
index|]
condition|)
comment|/* bad TRAIM */
return|return;
name|dt1
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
comment|/* dt this time step */
name|instance
operator|->
name|saw_tooth
operator|=
operator|(
name|s_char
operator|)
name|instance
operator|->
name|BEHn
index|[
literal|25
index|]
expr_stmt|;
comment|/* update for next time */
name|dt2
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
comment|/* dt next time step */
block|}
name|oncore_get_timestamp
argument_list|(
name|instance
argument_list|,
name|dt1
argument_list|,
name|dt2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here for @@Ca, @@Fa and @@Ia messages */
end_comment

begin_comment
comment|/* These are Self test Commands for 6, 8, and 12 chan receivers.  * There are good reasons NOT to do a @@Ca, @@Fa or @@Ia command with the ONCORE.  * It was found that under some circumstances the following  * command would fail if issued immediately after the return from the  * @@Fa, but a 2sec delay seemed to fix things.  Since simply calling  * sleep(2) is wasteful, and may cause trouble for some OS's, repeating  * itimer, we set a flag, and test it at the next POLL.  If it hasn't  * been cleared, we reissue the @@Cj that is issued below.  * Note that we do a @@Cj at the beginning, and again here.  * The first is to get the info, the 2nd is just used as a safe command  * after the @@Fa for all Oncores (and it was in this posn in the  * original code).  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_CaFaIa
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_TEST_SENT
condition|)
block|{
name|enum
name|antenna_state
name|antenna
decl_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'I'
condition|)
name|printf
argument_list|(
literal|"ONCORE[%d]:>>@@%ca %x %x %x\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|,
name|buf
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ONCORE[%d]:>>@@%ca %x %x\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|antenna
operator|=
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|&=
operator|~
literal|0xc0
expr_stmt|;
name|i
operator|=
name|buf
index|[
literal|4
index|]
operator|||
name|buf
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'I'
condition|)
name|i
operator|=
name|i
operator|||
name|buf
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'I'
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ONCORE[%d]: self test failed: result %02x %02x %02x"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|,
name|buf
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ONCORE[%d]: self test failed: result %02x %02x"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
literal|"ONCORE: self test failed, shutting down driver"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|instance
operator|->
name|peer
operator|->
name|srcadr
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|instance
operator|->
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
name|oncore_shutdown
argument_list|(
name|instance
operator|->
name|unit
argument_list|,
name|instance
operator|->
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* report the current antenna state */
name|oncore_antenna_report
argument_list|(
name|instance
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_INIT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_INIT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|4
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Demultiplex the almanac into shmem  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cb
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|5
operator|&&
name|buf
index|[
literal|5
index|]
operator|>
literal|0
operator|&&
name|buf
index|[
literal|5
index|]
operator|<
literal|26
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|4
operator|&&
name|buf
index|[
literal|5
index|]
operator|<=
literal|5
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
operator|+
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|4
operator|&&
name|buf
index|[
literal|5
index|]
operator|<=
literal|10
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
operator|+
literal|23
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|4
operator|&&
name|buf
index|[
literal|5
index|]
operator|==
literal|25
condition|)
name|i
operator|=
literal|34
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
literal|"Cb: Response is NO ALMANAC"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|*=
literal|36
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Cb
operator|+
name|i
operator|+
literal|2
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|instance
operator|->
name|shmem
operator|+
name|instance
operator|->
name|shmem_Cb
operator|+
name|i
operator|+
literal|3
argument_list|,
name|buf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|len
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"See Cb [%d,%d]"
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Set to Factory Defaults (Reasonable for UT w/ no Battery Backup  *	not so for VP (eeprom) or any unit with a battery  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cf
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_RESET_SENT
condition|)
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cg
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return to  Posn Fix mode */
comment|/* Reset set VP to IDLE */
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_TEST_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_TEST_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the Grand Central Station for the Preliminary Initialization.  * Once done here we move on to oncore_msg_BaEaHa for final Initialization and Running.  *  * We do an @@Cj whenever we need a safe command for all Oncores.  * The @@Cj gets us back here where we can switch to the next phase of setup.  *  * o Once at the very beginning (in start) to get the Model number.  *   This info is printed, but no longer used.  * o Again after we have determined the number of Channels in the receiver.  * o And once later after we have done a reset and test, (which may hang),  *   as we are about to initialize the Oncore and start it running.  * o We have one routine below for each case.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|memcpy
argument_list|(
name|instance
operator|->
name|Cj
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_CHECK_ID
condition|)
block|{
name|oncore_msg_Cj_id
argument_list|(
name|instance
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|oncore_chan_test
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_HAVE_CHAN
condition|)
block|{
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|3
operator|||
name|mode
operator|==
literal|4
condition|)
block|{
comment|/* Cf will return here to check for TEST */
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_RESET_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_RESET_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cf
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_TEST_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_TEST_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_TEST_SENT
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ca
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ca
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Fa
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Fa
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ia
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ia
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_INIT
condition|)
name|oncore_msg_Cj_init
argument_list|(
name|instance
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The information on determining a Oncore 'Model', viz VP, UT, etc, from  *	the Model Number comes from "Richard M. Hambly"<rick@cnssys.com>  *	and from Motorola.  Until recently Rick was the only source of  *	this information as Motorola didn't give the information out.  *  * Determine the Type from the Model #, this determines #chan and if TRAIM is  *   available.  *  * The Information from this routine is NO LONGER USED.  * The RESULTS are PRINTED, BUT NOT USED, and the routine COULD BE DELETED  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cj_id
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
name|Model
index|[
literal|21
index|]
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
comment|/* Write Receiver ID message to clockstats file */
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|instance
operator|->
name|Cj
init|;
name|cp
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
condition|;
control|)
block|{
name|cp1
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp1
condition|)
name|cp1
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
expr_stmt|;
operator|*
name|cp1
operator|=
literal|'\0'
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|=
literal|'\r'
expr_stmt|;
name|cp
operator|=
name|cp1
operator|+
literal|2
expr_stmt|;
block|}
comment|/* next, the Firmware Version and Revision numbers */
name|instance
operator|->
name|version
operator|=
name|atoi
argument_list|(
operator|&
name|instance
operator|->
name|Cj
index|[
literal|83
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|revision
operator|=
name|atoi
argument_list|(
operator|&
name|instance
operator|->
name|Cj
index|[
literal|111
index|]
argument_list|)
expr_stmt|;
comment|/* from model number decide which Oncore this is, 		and then the number of channels */
for|for
control|(
name|cp
operator|=
operator|&
name|instance
operator|->
name|Cj
index|[
literal|160
index|]
init|;
operator|*
name|cp
operator|==
literal|' '
condition|;
name|cp
operator|++
control|)
comment|/* start right after 'Model #' */
empty_stmt|;
name|cp1
operator|=
name|cp
expr_stmt|;
name|cp2
operator|=
name|Model
expr_stmt|;
for|for
control|(
init|;
operator|!
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|&&
name|cp
operator|-
name|cp1
operator|<
literal|20
condition|;
name|cp
operator|++
operator|,
name|cp2
operator|++
control|)
operator|*
name|cp2
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|Model
argument_list|,
literal|"PVT6"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|cp
operator|=
literal|"PVT6"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_PVT6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'A'
condition|)
block|{
name|cp
operator|=
literal|"Basic"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_BASIC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'B'
operator|||
operator|!
name|strncmp
argument_list|(
name|Model
argument_list|,
literal|"T8"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
condition|)
block|{
name|cp
operator|=
literal|"VP"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_VP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
block|{
name|cp
operator|=
literal|"M12"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_M12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'R'
operator|||
name|Model
index|[
literal|0
index|]
operator|==
literal|'D'
operator|||
name|Model
index|[
literal|0
index|]
operator|==
literal|'S'
condition|)
block|{
if|if
condition|(
name|Model
index|[
literal|5
index|]
operator|==
literal|'N'
condition|)
block|{
name|cp
operator|=
literal|"GT"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_GT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'3'
operator|||
name|Model
index|[
literal|1
index|]
operator|==
literal|'4'
operator|)
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'G'
condition|)
block|{
name|cp
operator|=
literal|"GT+"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_GTPLUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'5'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'U'
operator|)
operator|||
operator|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'1'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'A'
operator|)
condition|)
block|{
name|cp
operator|=
literal|"UT"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'5'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'G'
condition|)
block|{
name|cp
operator|=
literal|"UT+"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UTPLUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'6'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'G'
condition|)
block|{
name|cp
operator|=
literal|"SL"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_SL
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
literal|"Unknown"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UNKNOWN
expr_stmt|;
block|}
block|}
else|else
block|{
name|cp
operator|=
literal|"Unknown"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UNKNOWN
expr_stmt|;
block|}
comment|/* use MODEL to set CHAN and TRAIM and possibly zero SHMEM */
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"This looks like an Oncore %s with version %d.%d firmware."
argument_list|,
name|cp
argument_list|,
name|instance
operator|->
name|version
argument_list|,
name|instance
operator|->
name|revision
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|instance
operator|->
name|chan_id
operator|=
literal|8
expr_stmt|;
comment|/* default */
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_BASIC
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_PVT6
condition|)
name|instance
operator|->
name|chan_id
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_VP
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UT
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UTPLUS
condition|)
name|instance
operator|->
name|chan_id
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_M12
condition|)
name|instance
operator|->
name|chan_id
operator|=
literal|12
expr_stmt|;
name|instance
operator|->
name|traim_id
operator|=
literal|0
expr_stmt|;
comment|/* default */
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_BASIC
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_PVT6
condition|)
name|instance
operator|->
name|traim_id
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_VP
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UT
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UTPLUS
condition|)
name|instance
operator|->
name|traim_id
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_M12
condition|)
name|instance
operator|->
name|traim_id
operator|=
operator|-
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Channels = %d, TRAIM = %s"
argument_list|,
name|instance
operator|->
name|chan_id
argument_list|,
operator|(
operator|(
name|instance
operator|->
name|traim_id
operator|<
literal|0
operator|)
condition|?
literal|"UNKNOWN"
else|:
operator|(
operator|(
name|instance
operator|->
name|traim_id
operator|>
literal|0
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* OK, know type of Oncore, have possibly reset it, and have tested it.  * We know the number of channels.  * We will determine whether we have TRAIM before we actually start.  * Now initialize.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cj_init
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|Cmd
index|[
literal|20
index|]
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* The M12 with 1.3 or 2.0 Firmware, loses track of all Satellites and has to 	 * start again if we go from 0D -> 3D, then loses them again when we 	 * go from 3D -> 0D.  We do this to get a @@Ea message for SHMEM. 	 * For NOW we will turn this aspect of filling SHMEM off for the M12 	 */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|instance
operator|->
name|shmem_bad_Ea
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"*** SHMEM partially enabled for ONCORE M12 s/w v%d.%d ***"
argument_list|,
name|instance
operator|->
name|version
argument_list|,
name|instance
operator|->
name|revision
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cg
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return to  Posn Fix mode */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bb
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* turn on for shmem (6/8/12) */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ek
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ek
argument_list|)
argument_list|)
expr_stmt|;
comment|/* turn off (VP) */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Aw
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Aw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* UTC time (6/8/12) */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_AB
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_AB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Appl type static (VP) */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Be
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Be
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell us the Almanac for shmem (6/8/12) */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell us when Almanac changes */
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
comment|/* If there is Position input in the Config file 	 * and mode = (1,3) set it as posn hold posn, goto 0D mode. 	 *  or mode = (2,4) set it as INITIAL position, and do Site Survey. 	 */
if|if
condition|(
name|instance
operator|->
name|posn_set
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Setting Posn from input data"
argument_list|)
expr_stmt|;
name|oncore_set_posn
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* this should print posn indirectly thru the As cmd */
block|}
elseif|else
comment|/* must issue an @@At here to check on 6/8 Position Hold, set_posn would have */
if|if
condition|(
name|instance
operator|->
name|chan
operator|!=
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Atx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Atx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|0
condition|)
block|{
comment|/* cable delay in ns */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Az
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Az
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
name|instance
operator|->
name|delay
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Az
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 6,8,12 */
comment|/* PPS offset in ns */
if|if
condition|(
name|instance
operator|->
name|offset
condition|)
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ay
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ay
argument_list|)
argument_list|)
expr_stmt|;
comment|/* some have it, some don't */
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
comment|/* will check for hw response */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ay
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Satellite mask angle */
if|if
condition|(
name|instance
operator|->
name|Ag
operator|!=
literal|0xff
condition|)
block|{
comment|/* will have 0xff in it if not set by user */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ag
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ag
argument_list|)
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
operator|=
name|instance
operator|->
name|Ag
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ag
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 6, 8 12 chan - Position/Status/Data Output Message, 1/s 	 * now we're really running 	 * these were ALL started in the chan test, 	 * However, if we had mode=3,4 then commands got turned off, so we turn 	 * them on again here just in case 	 */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
block|{
comment|/* start 6chan, kill 8,12chan commands, possibly testing VP in 6chan mode */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ea0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ea0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_En0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_En0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ha0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ha0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Hn0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Hn0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ba
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ba
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
comment|/* start 8chan, kill 6,12chan commands */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ba0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ba0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bn0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bn0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ha0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ha0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Hn0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Hn0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ea
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ea
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
comment|/* start 12chan, kill 6,12chan commands */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ba0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ba0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bn0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bn0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ea0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ea0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_En0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_En0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ha
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ha
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|instance
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_ALMANAC
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_ALMANAC"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 12chan position */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Ga
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|long
name|lat
decl_stmt|,
name|lon
decl_stmt|,
name|ht
decl_stmt|;
name|double
name|Lat
decl_stmt|,
name|Lon
decl_stmt|,
name|Ht
decl_stmt|;
name|lat
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|lon
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|ht
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
comment|/* GPS ellipsoid */
name|Lat
operator|=
name|lat
expr_stmt|;
name|Lon
operator|=
name|lon
expr_stmt|;
name|Ht
operator|=
name|ht
expr_stmt|;
name|Lat
operator|/=
literal|3600000
expr_stmt|;
name|Lon
operator|/=
literal|3600000
expr_stmt|;
name|Ht
operator|/=
literal|100
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Ga Posn Lat = %.7f, Lon = %.7f, Ht  = %.2f"
argument_list|,
name|Lat
argument_list|,
name|Lon
argument_list|,
name|Ht
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_lat
operator|=
name|lat
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|=
name|lon
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
name|ht
expr_stmt|;
name|oncore_print_posn
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 12 chan time/date */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Gb
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|,
modifier|*
name|gmts
decl_stmt|;
name|int
name|mo
decl_stmt|,
name|d
decl_stmt|,
name|y
decl_stmt|,
name|h
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|,
name|gmth
decl_stmt|,
name|gmtm
decl_stmt|;
name|mo
operator|=
name|buf
index|[
literal|4
index|]
expr_stmt|;
name|d
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
name|y
operator|=
literal|256
operator|*
name|buf
index|[
literal|6
index|]
operator|+
name|buf
index|[
literal|7
index|]
expr_stmt|;
name|h
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|m
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|s
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
name|gmts
operator|=
operator|(
operator|(
name|buf
index|[
literal|11
index|]
operator|==
literal|0
operator|)
condition|?
literal|"+"
else|:
literal|"-"
operator|)
expr_stmt|;
name|gmth
operator|=
name|buf
index|[
literal|12
index|]
expr_stmt|;
name|gmtm
operator|=
name|buf
index|[
literal|13
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Date/Time set to: %d%s%d %2d:%02d:%02d GMT (GMT offset is %s%02d:%02d)"
argument_list|,
name|d
argument_list|,
name|Month
index|[
name|mo
operator|+
literal|1
index|]
argument_list|,
name|y
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|gmts
argument_list|,
name|gmth
argument_list|,
name|gmtm
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to use Oncore M12+Timing Auto Survey Feature  *	If its not there (M12), set flag to do it ourselves.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Gd
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_TESTING
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|3
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Initiating hardware 3D site survey"
argument_list|)
expr_stmt|;
name|cp
operator|=
literal|"SSstate = ONCORE_SS_HW"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_HW
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Leap Second for M12, gives all info from satellite message */
end_comment

begin_comment
comment|/* also in UT v3.0 */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Gj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|dt
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|instance
operator|->
name|saw_Gj
operator|=
literal|1
expr_stmt|;
comment|/* flag, saw_Gj, dont need to try Bj in check_leap */
comment|/* print the message to verify whats there */
name|dt
operator|=
name|buf
index|[
literal|5
index|]
operator|-
name|buf
index|[
literal|4
index|]
expr_stmt|;
if|#
directive|if
literal|1
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"ONCORE[%d]: Leap Sec Msg: %d %d %d %d %d %d %d %d %d %d"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|,
literal|256
operator|*
name|buf
index|[
literal|6
index|]
operator|+
name|buf
index|[
literal|7
index|]
argument_list|,
name|buf
index|[
literal|8
index|]
argument_list|,
name|buf
index|[
literal|9
index|]
argument_list|,
name|buf
index|[
literal|10
index|]
argument_list|,
operator|(
name|buf
index|[
literal|14
index|]
operator|+
literal|256
operator|*
operator|(
name|buf
index|[
literal|13
index|]
operator|+
literal|256
operator|*
operator|(
name|buf
index|[
literal|12
index|]
operator|+
literal|256
operator|*
name|buf
index|[
literal|11
index|]
operator|)
operator|)
operator|)
argument_list|,
name|buf
index|[
literal|15
index|]
argument_list|,
name|buf
index|[
literal|16
index|]
argument_list|,
name|buf
index|[
literal|17
index|]
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dt
condition|)
block|{
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"ONCORE[%d]: Leap second (%d) scheduled for %d%s%d at %d:%d:%d"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|dt
argument_list|,
name|buf
index|[
literal|9
index|]
argument_list|,
name|Month
index|[
name|buf
index|[
literal|8
index|]
index|]
argument_list|,
literal|256
operator|*
name|buf
index|[
literal|6
index|]
operator|+
name|buf
index|[
literal|7
index|]
argument_list|,
name|buf
index|[
literal|15
index|]
argument_list|,
name|buf
index|[
literal|16
index|]
argument_list|,
name|buf
index|[
literal|17
index|]
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/* Only raise warning within a month of the leap second */
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_NOWARNING"
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|6
index|]
operator|==
name|instance
operator|->
name|BEHa
index|[
literal|6
index|]
operator|&&
name|buf
index|[
literal|7
index|]
operator|==
name|instance
operator|->
name|BEHa
index|[
literal|7
index|]
operator|&&
comment|/* year */
name|buf
index|[
literal|8
index|]
operator|==
name|instance
operator|->
name|BEHa
index|[
literal|4
index|]
condition|)
block|{
comment|/* month */
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
name|dt
operator|<
literal|0
condition|)
block|{
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_DELSECOND"
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_ADDSECOND"
expr_stmt|;
block|}
block|}
block|}
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Power on failure */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Sz
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
literal|"Oncore: System Failure at Power On"
expr_stmt|;
if|if
condition|(
name|instance
operator|&&
name|instance
operator|->
name|peer
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_shutdown
argument_list|(
name|instance
operator|->
name|unit
argument_list|,
name|instance
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************** Small Subroutines ***************/
end_comment

begin_function
specifier|static
name|void
name|oncore_antenna_report
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|enum
name|antenna_state
name|new_state
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|ant_state
operator|==
name|new_state
condition|)
return|return;
switch|switch
condition|(
name|new_state
condition|)
block|{
case|case
name|ONCORE_ANTENNA_OK
case|:
name|cp
operator|=
literal|"GPS antenna: OK"
expr_stmt|;
break|break;
case|case
name|ONCORE_ANTENNA_OC
case|:
name|cp
operator|=
literal|"GPS antenna: short (overcurrent)"
expr_stmt|;
break|break;
case|case
name|ONCORE_ANTENNA_UC
case|:
name|cp
operator|=
literal|"GPS antenna: open (not connected)"
expr_stmt|;
break|break;
case|case
name|ONCORE_ANTENNA_NV
case|:
name|cp
operator|=
literal|"GPS antenna: short (no voltage)"
expr_stmt|;
break|break;
default|default:
name|cp
operator|=
literal|"GPS antenna: ?"
expr_stmt|;
break|break;
block|}
name|instance
operator|->
name|ant_state
operator|=
name|new_state
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|instance
operator|->
name|peer
operator|->
name|srcadr
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_chan_test
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* subroutine oncore_Cj_id has determined the number of channels from the 	 * model number of the attached oncore.  This is not always correct since 	 * the oncore could have non-standard firmware.  Here we check (independently) by 	 * trying a 6, 8, and 12 chan command, and see which responds. 	 * Caution: more than one CAN respond. 	 * 	 * This #chan is used by the code rather than that calculated from the model number. 	 */
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_CHECK_CHAN
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_CHECK_CHAN"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|count3
operator|=
literal|1
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ba
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ba
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ea
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ea
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ha
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ha
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check for a GOOD Almanac, have we got one yet? */
end_comment

begin_function
specifier|static
name|void
name|oncore_check_almanac
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
block|{
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
operator|&
literal|0x1
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
operator|&
literal|0x52
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
operator|&
literal|0x1
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
operator|&
literal|0x52
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|int
name|bits1
decl_stmt|,
name|bits2
decl_stmt|;
name|bits1
operator|=
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|129
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
expr_stmt|;
comment|/* actually Ha */
name|bits2
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
operator|=
operator|(
name|bits2
operator|&
literal|0x80
operator|)
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
operator|=
operator|(
name|bits2
operator|&
literal|0x8
operator|)
operator|||
operator|(
name|bits1
operator|==
literal|0x2
operator|)
expr_stmt|;
comment|/* too few sat     Bad Geom	  */
if|#
directive|if
literal|0
block|fprintf(stderr, "ONCORE[%d]: DEBUG BITS: (%x %x), (%x %x),  %x %x %x %x %x\n", 		instance->unit, 		instance->BEHa[129], instance->BEHa[130], bits1, bits2, instance->mode == MODE_0D, 		instance->mode == MODE_2D, instance->mode == MODE_3D, 		instance->rsm.bad_almanac, instance->rsm.bad_fix);
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* check the antenna for changes (did it get unplugged?) */
end_comment

begin_function
specifier|static
name|void
name|oncore_check_antenna
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|enum
name|antenna_state
name|antenna
decl_stmt|;
comment|/* antenna state */
name|antenna
operator|=
name|instance
operator|->
name|ant_state
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|antenna
operator|=
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
operator|&
literal|0x6
operator|)
operator|>>
literal|1
expr_stmt|;
else|else
name|antenna
operator|=
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|37
index|]
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
expr_stmt|;
comment|/* prob unset 6, set GT, UT unset VP */
name|oncore_antenna_report
argument_list|(
name|instance
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check the leap second status once per day.  *  * Note that the ONCORE firmware for the Bj command is wrong at  * least in the VP.  * It starts advertising a LEAP SECOND as soon as the GPS satellite  * data message (page 18, subframe 4) is updated to a date in the  * future, and does not wait for the month that it will occur.  * The event will usually be advertised several months in advance.  * Since there is a one bit flag, there is no way to tell if it is  * this month, or when...  *  * As such, we have the workaround below, of only checking for leap  * seconds with the Bj command in June/December.  *  * The Gj command gives more information, and we can tell in which  * month to apply the correction.  *  * Note that with the VP we COULD read the raw data message, and  * interpret it ourselves, but since this is specific to this receiver  * only, and the above workaround is adequate, we don't bother.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_check_leap_sec
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
if|if
condition|(
name|instance
operator|->
name|Bj_day
operator|!=
name|instance
operator|->
name|BEHa
index|[
literal|5
index|]
condition|)
block|{
comment|/* do this 1/day */
name|instance
operator|->
name|Bj_day
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|saw_Gj
operator|<
literal|0
condition|)
block|{
comment|/* -1 DONT have Gj use Bj */
if|if
condition|(
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|4
index|]
operator|==
literal|6
operator|)
operator|||
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|4
index|]
operator|==
literal|12
operator|)
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bj
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|instance
operator|->
name|saw_Gj
operator|==
literal|0
condition|)
comment|/* 0 is dont know if we have Gj */
name|instance
operator|->
name|count4
operator|=
literal|1
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gj
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Gj works for some 6/8 chan UT and the M12	  */
comment|/* if no response from Gj in 5 sec, we try Bj	  */
comment|/* which isnt implemented in all the GT/UT either */
if|if
condition|(
name|instance
operator|->
name|count4
condition|)
block|{
comment|/* delay, waiting for Gj response */
if|if
condition|(
name|instance
operator|->
name|saw_Gj
operator|==
literal|1
condition|)
name|instance
operator|->
name|count4
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|count4
operator|++
operator|>
literal|5
condition|)
block|{
comment|/* delay, waiting for Gj response */
name|instance
operator|->
name|saw_Gj
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* didnt see it, will use Bj */
name|instance
operator|->
name|count4
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|4
index|]
operator|==
literal|6
operator|)
operator|||
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|4
index|]
operator|==
literal|12
operator|)
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* check the message checksum,  *  buf points to START of message ( @@ )  *  len is length WITH CR/LF.  */
end_comment

begin_function
specifier|static
name|int
name|oncore_checksum_ok
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|len
operator|-
literal|3
condition|;
name|i
operator|++
control|)
name|j
operator|^=
name|buf
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|j
operator|==
name|buf
index|[
name|len
operator|-
literal|3
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_compute_dH
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|GPS
decl_stmt|,
name|MSL
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
comment|/* Here calculate dH = GPS - MSL for output message */
comment|/* also set Altitude Hold mode if GT */
name|instance
operator|->
name|have_dH
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|GPS
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|39
index|]
argument_list|)
expr_stmt|;
name|MSL
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|43
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GPS
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|23
index|]
argument_list|)
expr_stmt|;
name|MSL
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|27
index|]
argument_list|)
expr_stmt|;
block|}
name|instance
operator|->
name|dH
operator|=
name|GPS
operator|-
name|MSL
expr_stmt|;
name|instance
operator|->
name|dH
operator|/=
literal|100.
expr_stmt|;
comment|/* if MSL is not set, the calculation is meaningless */
if|if
condition|(
name|MSL
condition|)
block|{
comment|/* not set ! */
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"dH = (GPS - MSL) = %.2fm"
argument_list|,
name|instance
operator|->
name|dH
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * try loading Almanac from shmem (where it was copied from shmem_old  */
end_comment

begin_function
specifier|static
name|void
name|oncore_load_almanac
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|,
name|Cmd
index|[
literal|20
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
if|if
condition|(
operator|!
name|instance
operator|->
name|shmem
condition|)
return|return;
if|#
directive|if
literal|1
for|for
control|(
name|cp
operator|=
name|instance
operator|->
name|shmem
operator|+
literal|4
init|;
operator|(
name|n
operator|=
literal|256
operator|*
operator|(
operator|*
operator|(
name|cp
operator|-
literal|3
operator|)
operator|)
operator|+
operator|*
operator|(
name|cp
operator|-
literal|2
operator|)
operator|)
condition|;
name|cp
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"@@Cb"
argument_list|,
literal|4
argument_list|)
operator|&&
name|oncore_checksum_ok
argument_list|(
name|cp
argument_list|,
literal|33
argument_list|)
operator|&&
operator|(
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
operator|==
literal|4
operator|||
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
operator|==
literal|5
operator|)
condition|)
block|{
name|write
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|oncore_print_Cb
argument_list|(
name|instance
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|#
directive|else
comment|/************DEBUG************/
for|for
control|(
name|cp
operator|=
name|instance
operator|->
name|shmem
operator|+
literal|4
init|;
operator|(
name|n
operator|=
literal|256
operator|*
operator|(
operator|*
operator|(
name|cp
operator|-
literal|3
operator|)
operator|)
operator|+
operator|*
operator|(
name|cp
operator|-
literal|2
operator|)
operator|)
condition|;
name|cp
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
control|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"See %c%c%c%c %d"
argument_list|,
operator|*
operator|(
name|cp
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|3
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"@@Cb"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|oncore_print_Cb
argument_list|(
name|instance
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oncore_checksum_ok
argument_list|(
name|cp
argument_list|,
literal|33
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
operator|==
literal|4
operator|||
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
operator|==
literal|5
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"GOOD SF"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"BAD SF"
argument_list|)
expr_stmt|;
block|}
else|else
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"BAD CHECKSUM"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/************DEBUG************/
endif|#
directive|endif
comment|/* Must load position and time or the Almanac doesn't do us any good */
if|if
condition|(
operator|!
name|instance
operator|->
name|posn_set
condition|)
block|{
comment|/* if we input a posn use it, else from SHMEM */
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Loading Posn from SHMEM"
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|instance
operator|->
name|shmem
operator|+
literal|4
init|;
operator|(
name|n
operator|=
literal|256
operator|*
operator|(
operator|*
operator|(
name|cp
operator|-
literal|3
operator|)
operator|)
operator|+
operator|*
operator|(
name|cp
operator|-
literal|2
operator|)
operator|)
condition|;
name|cp
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
control|)
block|{
if|if
condition|(
operator|(
name|instance
operator|->
name|chan
operator|==
literal|6
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"@@Ba"
argument_list|,
literal|4
argument_list|)
operator|&&
name|oncore_checksum_ok
argument_list|(
name|cp
argument_list|,
literal|68
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|instance
operator|->
name|chan
operator|==
literal|8
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"@@Ea"
argument_list|,
literal|4
argument_list|)
operator|&&
name|oncore_checksum_ok
argument_list|(
name|cp
argument_list|,
literal|76
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|instance
operator|->
name|chan
operator|==
literal|12
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"@@Ha"
argument_list|,
literal|4
argument_list|)
operator|&&
name|oncore_checksum_ok
argument_list|(
name|cp
argument_list|,
literal|154
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|kk
decl_stmt|;
name|instance
operator|->
name|posn_set
operator|=
literal|1
expr_stmt|;
name|ii
operator|=
name|buf_w32
argument_list|(
name|cp
operator|+
literal|15
argument_list|)
expr_stmt|;
name|jj
operator|=
name|buf_w32
argument_list|(
name|cp
operator|+
literal|19
argument_list|)
expr_stmt|;
name|kk
operator|=
name|buf_w32
argument_list|(
name|cp
operator|+
literal|23
argument_list|)
expr_stmt|;
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"SHMEM posn = %d (%d, %d, %d)"
argument_list|,
name|cp
operator|-
name|instance
operator|->
name|shmem
argument_list|,
name|ii
argument_list|,
name|jj
argument_list|,
name|kk
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ii
operator|!=
literal|0
operator|||
name|jj
operator|!=
literal|0
operator|||
name|kk
operator|!=
literal|0
condition|)
block|{
comment|/* phk asked for this test */
name|instance
operator|->
name|ss_lat
operator|=
name|ii
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|=
name|jj
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
name|kk
expr_stmt|;
block|}
block|}
block|}
block|}
name|oncore_set_posn
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* and set time to time from Computer clock */
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|(
specifier|const
name|time_t
operator|*
operator|)
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"DATE %d %d %d, %d %d %d"
argument_list|,
literal|1900
operator|+
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_mon
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Gb
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gb
argument_list|)
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
operator|=
name|tm
operator|->
name|tm_mon
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|5
index|]
operator|=
name|tm
operator|->
name|tm_mday
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|6
index|]
operator|=
operator|(
literal|1900
operator|+
name|tm
operator|->
name|tm_year
operator|)
operator|/
literal|256
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|7
index|]
operator|=
operator|(
literal|1900
operator|+
name|tm
operator|->
name|tm_year
operator|)
operator|%
literal|256
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|8
index|]
operator|=
name|tm
operator|->
name|tm_hour
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|9
index|]
operator|=
name|tm
operator|->
name|tm_min
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|10
index|]
operator|=
name|tm
operator|->
name|tm_sec
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|11
index|]
operator|=
literal|0
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|12
index|]
operator|=
literal|0
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|13
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gb
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First set GMT offset to zero */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ab
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ab
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ac
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ac
argument_list|)
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
operator|=
name|tm
operator|->
name|tm_mon
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|5
index|]
operator|=
name|tm
operator|->
name|tm_mday
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|6
index|]
operator|=
operator|(
literal|1900
operator|+
name|tm
operator|->
name|tm_year
operator|)
operator|/
literal|256
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|7
index|]
operator|=
operator|(
literal|1900
operator|+
name|tm
operator|->
name|tm_year
operator|)
operator|%
literal|256
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ac
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Aa
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Aa
argument_list|)
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
operator|=
name|tm
operator|->
name|tm_hour
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|5
index|]
operator|=
name|tm
operator|->
name|tm_min
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|6
index|]
operator|=
name|tm
operator|->
name|tm_sec
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Aa
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Setting Posn and Time after Loading Almanac"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Almanac data input */
end_comment

begin_function
specifier|static
name|void
name|oncore_print_Cb
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int	ii; 	char	Msg[160];  	printf("DEBUG: See: %c%c%c%c\n", *(cp), *(cp+1), *(cp+2), *(cp+3)); 	printf("DEBUG: Cb: [%d,%d]", *(cp+4), *(cp+5)); 	for(ii=0; ii<33; ii++) 		printf(" %d", *(cp+ii)); 	printf("\n");  	sprintf(Msg, "Debug: Cb: [%d,%d]", *(cp+4), *(cp+5)); 	record_clock_stats(&(instance->peer->srcadr), Msg);
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void oncore_print_array( 	u_char *cp, 	int	n 	) { 	int	jj, i, j, nn;  	nn = 0; 	printf("\nTOP\n"); 	jj = n/16; 	for (j=0; j<jj; j++) { 		printf("%4d: ", nn); 		nn += 16; 		for (i=0; i<16; i++) 			printf(" %o", *cp++); 		printf("\n"); 	} }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|oncore_print_posn
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|,
name|ew
decl_stmt|,
name|ns
decl_stmt|;
name|double
name|xd
decl_stmt|,
name|xm
decl_stmt|,
name|xs
decl_stmt|,
name|yd
decl_stmt|,
name|ym
decl_stmt|,
name|ys
decl_stmt|,
name|hm
decl_stmt|,
name|hft
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|idy
decl_stmt|,
name|is
decl_stmt|,
name|imx
decl_stmt|,
name|imy
decl_stmt|;
name|long
name|lat
decl_stmt|,
name|lon
decl_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Posn:"
argument_list|)
expr_stmt|;
name|ew
operator|=
literal|'E'
expr_stmt|;
name|lon
operator|=
name|instance
operator|->
name|ss_long
expr_stmt|;
if|if
condition|(
name|lon
operator|<
literal|0
condition|)
block|{
name|ew
operator|=
literal|'W'
expr_stmt|;
name|lon
operator|=
operator|-
name|lon
expr_stmt|;
block|}
name|ns
operator|=
literal|'N'
expr_stmt|;
name|lat
operator|=
name|instance
operator|->
name|ss_lat
expr_stmt|;
if|if
condition|(
name|lat
operator|<
literal|0
condition|)
block|{
name|ns
operator|=
literal|'S'
expr_stmt|;
name|lat
operator|=
operator|-
name|lat
expr_stmt|;
block|}
name|hm
operator|=
name|instance
operator|->
name|ss_ht
operator|/
literal|100.
expr_stmt|;
name|hft
operator|=
name|hm
operator|/
literal|0.3048
expr_stmt|;
name|xd
operator|=
name|lat
operator|/
literal|3600000.
expr_stmt|;
comment|/* lat, lon in int msec arc, ht in cm. */
name|yd
operator|=
name|lon
operator|/
literal|3600000.
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Lat = %c %11.7fdeg,    Long = %c %11.7fdeg,    Alt = %5.2fm (%5.2fft) GPS"
argument_list|,
name|ns
argument_list|,
name|xd
argument_list|,
name|ew
argument_list|,
name|yd
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|idx
operator|=
name|xd
expr_stmt|;
name|idy
operator|=
name|yd
expr_stmt|;
name|imx
operator|=
name|lat
operator|%
literal|3600000
expr_stmt|;
name|imy
operator|=
name|lon
operator|%
literal|3600000
expr_stmt|;
name|xm
operator|=
name|imx
operator|/
literal|60000.
expr_stmt|;
name|ym
operator|=
name|imy
operator|/
literal|60000.
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Lat = %c %3ddeg %7.4fm,   Long = %c %3ddeg %8.5fm,  Alt = %7.2fm (%7.2fft) GPS"
argument_list|,
name|ns
argument_list|,
name|idx
argument_list|,
name|xm
argument_list|,
name|ew
argument_list|,
name|idy
argument_list|,
name|ym
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|imx
operator|=
name|xm
expr_stmt|;
name|imy
operator|=
name|ym
expr_stmt|;
name|is
operator|=
name|lat
operator|%
literal|60000
expr_stmt|;
name|xs
operator|=
name|is
operator|/
literal|1000.
expr_stmt|;
name|is
operator|=
name|lon
operator|%
literal|60000
expr_stmt|;
name|ys
operator|=
name|is
operator|/
literal|1000.
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Lat = %c %3ddeg %2dm %5.2fs, Long = %c %3ddeg %2dm %5.2fs, Alt = %7.2fm (%7.2fft) GPS"
argument_list|,
name|ns
argument_list|,
name|idx
argument_list|,
name|imx
argument_list|,
name|xs
argument_list|,
name|ew
argument_list|,
name|idy
argument_list|,
name|imy
argument_list|,
name|ys
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * write message to Oncore.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_sendmsg
parameter_list|(
name|int
name|fd
parameter_list|,
name|u_char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u_char
name|cs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"ONCORE: Send @@%c%c %d\n"
argument_list|,
name|ptr
index|[
literal|0
index|]
argument_list|,
name|ptr
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
literal|"@@"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|cs
operator|^=
operator|*
name|ptr
operator|++
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|cs
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
literal|"\r\n"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_set_posn
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|char
name|Cmd
index|[
literal|20
index|]
decl_stmt|;
comment|/* Turn OFF position hold, it needs to be off to set position (for some units), 	   will get set ON in @@Ea later */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (12) */
else|else
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (6/8) */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (6/8) */
block|}
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|0
condition|)
block|{
comment|/* first set posn hold position */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_As
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_As
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't modify static variables */
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|8
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|12
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_As
argument_list|)
argument_list|)
expr_stmt|;
comment|/* posn hold 3D posn (6/8/12) */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Au
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Au
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Au
argument_list|)
argument_list|)
expr_stmt|;
comment|/* altitude hold (6/8/12 not UT, M12T) */
comment|/* next set current position */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ga
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ga
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|8
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|12
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ga
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 3d posn (12) */
block|}
else|else
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ad
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ad
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lat (6/8) */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ae
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ae
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ae
argument_list|)
argument_list|)
expr_stmt|;
comment|/* long (6/8) */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Af
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Af
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Af
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ht (6/8) */
block|}
comment|/* Finally, turn on position hold */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_set_traim
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|traim_in
operator|!=
operator|-
literal|1
condition|)
comment|/* set in Input */
name|instance
operator|->
name|traim
operator|=
name|instance
operator|->
name|traim_in
expr_stmt|;
else|else
name|instance
operator|->
name|traim
operator|=
name|instance
operator|->
name|traim_ck
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Input   says TRAIM = %d"
argument_list|,
name|instance
operator|->
name|traim_in
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Model # says TRAIM = %d"
argument_list|,
name|instance
operator|->
name|traim_id
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Testing says TRAIM = %d"
argument_list|,
name|instance
operator|->
name|traim_ck
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Using        TRAIM = %d"
argument_list|,
name|instance
operator|->
name|traim
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|traim_ck
operator|==
literal|1
operator|&&
name|instance
operator|->
name|traim
operator|==
literal|0
condition|)
block|{
comment|/* if it should be off, and I turned it on during testing, 		   then turn it off again */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bnx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bnx
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Enx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Enx
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* chan == 12 */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ge0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ge0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * if SHMEM active, every 15s, steal one 'tick' to get 2D or 3D posn.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_shmem_get_3D
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
if|if
condition|(
name|instance
operator|->
name|pp
operator|->
name|second
operator|%
literal|15
operator|==
literal|3
condition|)
block|{
comment|/* start the sequence */
comment|/* by changing mode */
name|instance
operator|->
name|shmem_reset
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|shmem_Posn
operator|==
literal|2
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd2
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 2D */
else|else
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 3D */
block|}
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|saw_At
condition|)
block|{
comment|/* out of 0D -> 3D mode */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem_Posn
operator|==
literal|2
condition|)
comment|/* 3D -> 2D mode */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|shmem_reset
operator|||
operator|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_0D
operator|)
condition|)
block|{
name|instance
operator|->
name|shmem_reset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gd1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 0D */
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|saw_At
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|mode
operator|==
name|MODE_2D
condition|)
comment|/* 2D -> 3D or 0D mode */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* to 0D mode */
block|}
else|else
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Av1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Here we do the Software SiteSurvey.  * We have to average our own position for the Position Hold Mode  *   We use Heights from the GPS ellipsoid.  * We check for the END of either HW or SW SiteSurvey.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_ss
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|double
name|lat
decl_stmt|,
name|lon
decl_stmt|,
name|ht
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_HW
condition|)
block|{
comment|/* 		 * Check to see if Hardware SiteSurvey has Finished. 		 */
if|if
condition|(
operator|(
name|instance
operator|->
name|chan
operator|==
literal|8
operator|&&
operator|!
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|37
index|]
operator|&
literal|0x20
operator|)
operator|)
operator|||
operator|(
name|instance
operator|->
name|chan
operator|==
literal|12
operator|&&
operator|!
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
operator|&
literal|0x10
operator|)
operator|)
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Now in 0D mode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gax
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gax
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Asx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Asx
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
literal|"SSstate = ONCORE_SS_DONE"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Must be a Software Site Survey. 		 */
if|if
condition|(
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
condition|)
comment|/* Not if poor geometry or less than 3 sats */
return|return;
if|if
condition|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_3D
condition|)
comment|/* Use only 3D Fixes */
return|return;
name|instance
operator|->
name|ss_lat
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|19
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|23
index|]
argument_list|)
expr_stmt|;
comment|/* GPS ellipsoid */
name|instance
operator|->
name|ss_count
operator|++
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|ss_count
operator|!=
name|POS_HOLD_AVERAGE
condition|)
return|return;
name|instance
operator|->
name|ss_lat
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Surveyed posn: lat %.3f (mas) long %.3f (mas) ht %.3f (cm)"
argument_list|,
name|instance
operator|->
name|ss_lat
argument_list|,
name|instance
operator|->
name|ss_long
argument_list|,
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|lat
operator|=
name|instance
operator|->
name|ss_lat
operator|/
literal|3600000.
expr_stmt|;
name|lon
operator|=
name|instance
operator|->
name|ss_long
operator|/
literal|3600000.
expr_stmt|;
name|ht
operator|=
name|instance
operator|->
name|ss_ht
operator|/
literal|100
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Surveyed posn: lat %.7f (deg) long %.7f (deg) ht %.2f (m)"
argument_list|,
name|lat
argument_list|,
name|lon
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|oncore_set_posn
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Now in 0D mode"
argument_list|)
expr_stmt|;
name|cp
operator|=
literal|"SSstate = ONCORE_SS_DONE"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|oncore_wait_almanac
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
if|if
condition|(
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ONCORE[%d]: waiting for almanac\n"
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* 		 * If we get here (first time) then we don't have an almanac in memory. 		 * Check if we have a SHMEM, and if so try to load whatever is there. 		 */
if|if
condition|(
operator|!
name|instance
operator|->
name|almanac_from_shmem
condition|)
block|{
name|instance
operator|->
name|almanac_from_shmem
operator|=
literal|1
expr_stmt|;
name|oncore_load_almanac
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* Here we have the Almanac, we will be starting the @@Bn/@@En/@@Hn 		     commands, and can finally check for TRAIM.  Again, we set a delay 		     (5sec) and wait for things to settle down */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bn
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_En
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_En
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Gc
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1PPS on, continuous */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ge
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ge
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TRAIM on */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Hn
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Hn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TRAIM status 1/s */
block|}
name|instance
operator|->
name|traim_delay
operator|=
literal|1
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Have now loaded an ALMANAC"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_RUN
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"state = ONCORE_RUN"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_oncore_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

