begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * refclock_oncore.c  *  * Driver for some of the various the Motorola Oncore GPS receivers.  *  * Tested with:  *  *		(UT)				   (VP)  *   COPYRIGHT 1991-1997 MOTOROLA INC.	COPYRIGHT 1991-1996 MOTOROLA INC.  *   SFTW P/N #     98-P36848P		SFTW P/N # 98-P36830P  *   SOFTWARE VER # 2			SOFTWARE VER # 8  *   SOFTWARE REV # 2			SOFTWARE REV # 8  *   SOFTWARE DATE  APR 24 1998 	SOFTWARE DATE  06 Aug 1996  *   MODEL #	R1121N1114		MODEL #    B4121P1155  *   HWDR P/N # 1			HDWR P/N # _  *   SERIAL #	R0010A			SERIAL #   SSG0226478  *   MANUFACTUR DATE 6H07		MANUFACTUR DATE 7E02  *					OPTIONS LIST	IB  *  * --------------------------------------------------------------------------  * This code uses the two devices  *      /dev/oncore.serial.n  *      /dev/oncore.pps.n  * which may be linked to the same device.  * and can read initialization data from the file  *      /etc/ntp.oncoreN (where n and N are the unit number, viz 127.127.30.N)  *  or	/etc/ntp.oncore  * --------------------------------------------------------------------------  * Reg.Clemens<reg@dwf.com> Sep98.  *  Original code written for FreeBSD.  *  With these mods it works on SunOS, Solaris (untested) and Linux  *    (RedHat 5.1 2.0.35 + PPSKit, 2.1.126 + changes).  *  *  Lat,Long,Ht, cable-delay, offset, and the ReceiverID (along with the  *  state machine state) are printed to CLOCKSTATS if that file is enabled  *  in /etc/ntp.conf.  *  * --------------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * According to the ONCORE manual (TRM0003, Rev 3.2, June 1998, page 3.13)  * doing an average of 10000 valid 2D and 3D fixes is what the automatic  * site survey mode does.  Looking at the output from the receiver  * it seems like it is only using 3D fixes.  * When we do it ourselves, take 10000 3D fixes.  */
end_comment

begin_define
define|#
directive|define
name|POS_HOLD_AVERAGE
value|10000
end_define

begin_comment
comment|/* nb, 10000s ~= 2h45m */
end_comment

begin_comment
comment|/*  * ONCORE_SHMEM_STATUS will create a mmap(2)'ed file named according to a  * "STATUS" line in the oncore config file, which contains the most recent  * copy of all types of messages we recognize.  This file can be mmap(2)'ed  * by monitoring and statistics programs.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_ONCORE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ONCORE_SHMEM_STATUS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MMAN_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|((u_char *) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MAP_FAILED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_MMAN_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ONCORE_SHMEM_STATUS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<timepps.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/sio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TERMIOS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PPSCLOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRUCT_PPSCLOCKEV
end_ifndef

begin_struct
struct|struct
name|ppsclockev
block|{
ifdef|#
directive|ifdef
name|HAVE_TIMESPEC
name|struct
name|timespec
name|tv
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
name|tv
decl_stmt|;
endif|#
directive|endif
name|u_int
name|serial
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_STRUCT_PPSCLOCKEV */
end_comment

begin_enum
enum|enum
name|receive_state
block|{
name|ONCORE_NO_IDEA
block|,
name|ONCORE_RESET_SENT
block|,
name|ONCORE_TEST_SENT
block|,
name|ONCORE_ID_SENT
block|,
name|ONCORE_ALMANAC
block|,
name|ONCORE_RUN
block|}
enum|;
end_enum

begin_enum
enum|enum
name|site_survey_state
block|{
name|ONCORE_SS_UNKNOWN
block|,
name|ONCORE_SS_HW
block|,
name|ONCORE_SS_SW
block|,
name|ONCORE_SS_DONE
block|}
enum|;
end_enum

begin_struct
struct|struct
name|instance
block|{
name|int
name|unit
decl_stmt|;
comment|/* 127.127.30.unit */
name|int
name|ttyfd
decl_stmt|;
comment|/* TTY file descriptor */
name|int
name|ppsfd
decl_stmt|;
comment|/* PPS file descriptor */
name|int
name|statusfd
decl_stmt|;
comment|/* Status shm descriptor */
name|u_char
modifier|*
name|shmem
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|pps_handle_t
name|pps_h
decl_stmt|;
name|pps_params_t
name|pps_p
decl_stmt|;
endif|#
directive|endif
name|enum
name|receive_state
name|o_state
decl_stmt|;
comment|/* Receive state */
name|enum
name|site_survey_state
name|site_survey
decl_stmt|;
comment|/* Site Survey state */
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|Bj_day
decl_stmt|;
name|long
name|delay
decl_stmt|;
comment|/* ns */
name|long
name|offset
decl_stmt|;
comment|/* ns */
name|double
name|ss_lat
decl_stmt|;
name|double
name|ss_long
decl_stmt|;
name|double
name|ss_ht
decl_stmt|;
name|int
name|ss_count
decl_stmt|;
name|u_char
name|ss_ht_type
decl_stmt|;
name|u_char
name|posn_set
decl_stmt|;
name|u_char
name|printed
decl_stmt|;
name|u_char
name|polled
decl_stmt|;
name|int
name|pollcnt
decl_stmt|;
name|u_int
name|ev_serial
decl_stmt|;
name|int
name|Rcvptr
decl_stmt|;
name|u_char
name|Rcvbuf
index|[
literal|500
index|]
decl_stmt|;
name|u_char
name|Ea
index|[
literal|77
index|]
decl_stmt|;
name|u_char
name|En
index|[
literal|70
index|]
decl_stmt|;
name|u_char
name|Cj
index|[
literal|300
index|]
decl_stmt|;
name|u_char
name|As
decl_stmt|;
name|u_char
name|Ay
decl_stmt|;
name|u_char
name|Az
decl_stmt|;
name|u_char
name|init_type
decl_stmt|;
name|s_char
name|saw_tooth
decl_stmt|;
name|u_char
name|timeout
decl_stmt|;
comment|/* flag to retry Cj after Fa reset */
name|s_char
name|assert
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|rcvbuf
value|instance->Rcvbuf
end_define

begin_define
define|#
directive|define
name|rcvptr
value|instance->Rcvptr
end_define

begin_decl_stmt
specifier|static
name|void
name|oncore_consume
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_read_config
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_sendmsg
name|P
argument_list|(
operator|(
name|int
name|fd
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oncore_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_any
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_As
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_At
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Ay
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Az
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Bj
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cb
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cf
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Cj
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Ea
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_En
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|oncore_msg_Fa
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|refclock
name|refclock_oncore
init|=
block|{
name|oncore_start
block|,
comment|/* start up driver */
name|oncore_shutdown
block|,
comment|/* shut down driver */
name|oncore_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used */
name|noentry
block|,
comment|/* not used */
name|noentry
block|,
comment|/* not used */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Understanding the next bit here is not easy unless you have a manual  * for the the UT or VP Oncore.  */
end_comment

begin_struct
specifier|static
struct|struct
name|msg_desc
block|{
specifier|const
name|char
name|flag
index|[
literal|3
index|]
decl_stmt|;
specifier|const
name|int
name|len
decl_stmt|;
name|void
argument_list|(
argument|*handler
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|instance
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|shmem
decl_stmt|;
block|}
name|oncore_messages
index|[]
init|=
block|{
comment|/* Ea and En first since they're most common */
block|{
literal|"Ea"
block|,
literal|76
block|,
name|oncore_msg_Ea
block|,
literal|"mdyyhmsffffaaaaoooohhhhmmmmvvhhddtntimsdimsdimsdimsdimsdimsdimsdimsdsC"
block|}
block|,
block|{
literal|"En"
block|,
literal|69
block|,
name|oncore_msg_En
block|,
literal|"otaapxxxxxxxxxxpysreensffffsffffsffffsffffsffffsffffsffffsffffC"
block|}
block|,
block|{
literal|"Ab"
block|,
literal|10
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ac"
block|,
literal|11
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ad"
block|,
literal|11
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ae"
block|,
literal|11
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Af"
block|,
literal|15
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"As"
block|,
literal|20
block|,
name|oncore_msg_As
block|,
literal|""
block|}
block|,
block|{
literal|"At"
block|,
literal|8
block|,
name|oncore_msg_At
block|,
literal|""
block|}
block|,
block|{
literal|"Aw"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ay"
block|,
literal|11
block|,
name|oncore_msg_Ay
block|,
literal|""
block|}
block|,
block|{
literal|"Az"
block|,
literal|11
block|,
name|oncore_msg_Az
block|,
literal|""
block|}
block|,
block|{
literal|"AB"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Bb"
block|,
literal|92
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Bj"
block|,
literal|8
block|,
name|oncore_msg_Bj
block|,
literal|""
block|}
block|,
block|{
literal|"Cb"
block|,
literal|33
block|,
name|oncore_msg_Cb
block|,
literal|""
block|}
block|,
block|{
literal|"Cf"
block|,
literal|7
block|,
name|oncore_msg_Cf
block|,
literal|""
block|}
block|,
block|{
literal|"Cg"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ch"
block|,
literal|9
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Cj"
block|,
literal|294
block|,
name|oncore_msg_Cj
block|,
literal|""
block|}
block|,
block|{
literal|"Ek"
block|,
literal|71
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Fa"
block|,
literal|9
block|,
name|oncore_msg_Fa
block|,
literal|""
block|}
block|,
block|{
literal|"Sz"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
block|{
literal|0
block|}
block|,
literal|7
block|,
literal|0
block|,
literal|""
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|oncore_shmem_Cb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Position Set.  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Ad
index|[]
init|=
block|{
literal|'A'
block|,
literal|'d'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Ae
index|[]
init|=
block|{
literal|'A'
block|,
literal|'e'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Af
index|[]
init|=
block|{
literal|'A'
block|,
literal|'f'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Position-Hold Mode  *    Start automatic site survey  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_At
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Position-Hold Position  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_As
index|[]
init|=
block|{
literal|'A'
block|,
literal|'s'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Asx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'s'
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set to UTC time (not GPS).  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Aw
index|[]
init|=
block|{
literal|'A'
block|,
literal|'w'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Output Almanac when it changes  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Be
index|[]
init|=
block|{
literal|'B'
block|,
literal|'e'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read back PPS Offset for Output  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Ay
index|[]
init|=
block|{
literal|'A'
block|,
literal|'y'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Ayx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'y'
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read back Cable Delay for Output  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Az
index|[]
init|=
block|{
literal|'A'
block|,
literal|'z'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|oncore_cmd_Azx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'z'
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Application type = static.  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_AB
index|[]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Visible Satellite Status Msg.  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Bb
index|[]
init|=
block|{
literal|'B'
block|,
literal|'b'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Leap Second Pending Message  *    Request message once  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Bj
index|[]
init|=
block|{
literal|'B'
block|,
literal|'j'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set to Defaults  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Cf
index|[]
init|=
block|{
literal|'C'
block|,
literal|'f'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set to Position Fix mode (only needed on VP).  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Cg
index|[]
init|=
block|{
literal|'C'
block|,
literal|'g'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Receiver Id  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Cj
index|[]
init|=
block|{
literal|'C'
block|,
literal|'j'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Position/Status/Data message  *    Send once per second  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ea
index|[]
init|=
block|{
literal|'E'
block|,
literal|'a'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Position/Status Extension Msg  */
end_comment

begin_decl_stmt
name|u_char
name|oncore_cmd_Ek
index|[]
init|=
block|{
literal|'E'
block|,
literal|'k'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* just turn off */
end_comment

begin_comment
comment|/*  * Time Raim Setup& Status Message  *    Send once per second  *    Time-RAIM on  *    Alarm limit 1us  *    PPS on when we have the first sat  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_En
index|[]
init|=
block|{
literal|'E'
block|,
literal|'n'
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Self-test  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Fa
index|[]
init|=
block|{
literal|'F'
block|,
literal|'a'
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEVICE1
value|"/dev/oncore.serial.%d"
end_define

begin_comment
comment|/* name of serial device */
end_comment

begin_define
define|#
directive|define
name|DEVICE2
value|"/dev/oncore.pps.%d"
end_define

begin_comment
comment|/* name of pps device */
end_comment

begin_define
define|#
directive|define
name|INIT_FILE
value|"/etc/ntp.oncore"
end_define

begin_comment
comment|/* optional init file */
end_comment

begin_define
define|#
directive|define
name|SPEED
value|B9600
end_define

begin_comment
comment|/* Oncore Binary speed (9600 bps) */
end_comment

begin_comment
comment|/*  * Assemble and disassemble 32bit signed quantities from a buffer.  *  */
end_comment

begin_comment
comment|/* to buffer, int w, u_char *buf */
end_comment

begin_define
define|#
directive|define
name|w32_buf
parameter_list|(
name|buf
parameter_list|,
name|w
parameter_list|)
value|{ unsigned int i_tmp;		   \ 			  i_tmp = (w<0) ? (~(-w)+1) : (w); \ 			  (buf)[0] = (i_tmp>> 24)& 0xff; \ 			  (buf)[1] = (i_tmp>> 16)& 0xff; \ 			  (buf)[2] = (i_tmp>>	8)& 0xff; \ 			  (buf)[3] = (i_tmp	 )& 0xff; \ 			}
end_define

begin_define
define|#
directive|define
name|w32
parameter_list|(
name|buf
parameter_list|)
value|(((buf)[0]&0xff)<< 24 | \ 		       ((buf)[1]&0xff)<< 16 | \ 		       ((buf)[2]&0xff)<<  8 | \ 		       ((buf)[3]&0xff) )
end_define

begin_comment
comment|/* from buffer, char *buf, result to an int */
end_comment

begin_define
define|#
directive|define
name|buf_w32
parameter_list|(
name|buf
parameter_list|)
value|(((buf)[0]&0200) ? (-(~w32(buf)+1)) : w32(buf))
end_define

begin_decl_stmt
specifier|extern
name|int
name|pps_assert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pps_hardpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * oncore_start - initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|oncore_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|,
name|mode
decl_stmt|;
name|char
name|device1
index|[
literal|30
index|]
decl_stmt|,
name|device2
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|stat
name|stat1
decl_stmt|,
name|stat2
decl_stmt|;
comment|/* OPEN DEVICES */
comment|/* opening different devices for fd1 and fd2 presents no problems */
comment|/* opening the SAME device twice, seems to be OS dependent. 		(a) on Linux (no streams) no problem 		(b) on SunOS (and possibly Solaris, untested), (streams) 			never see the line discipline. 	   Since things ALWAYS work if we only open the device once, we check 	     to see if the two devices are in fact the same, then proceed to 	     do one open or two. 	*/
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device1
argument_list|,
name|DEVICE1
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device2
argument_list|,
name|DEVICE2
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|device1
argument_list|,
operator|&
name|stat1
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: stat fd1"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|device2
argument_list|,
operator|&
name|stat2
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: stat fd2"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat1
operator|.
name|st_dev
operator|==
name|stat2
operator|.
name|st_dev
operator|)
operator|&&
operator|(
name|stat1
operator|.
name|st_ino
operator|==
name|stat2
operator|.
name|st_ino
operator|)
condition|)
block|{
comment|/* same device here */
if|if
condition|(
operator|!
operator|(
name|fd1
operator|=
name|refclock_open
argument_list|(
name|device1
argument_list|,
name|SPEED
argument_list|,
name|LDISC_RAW
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCDCDTIMESTAMP
argument_list|)
operator||
name|LDISC_PPS
endif|#
directive|endif
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: fd1"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fd2
operator|=
name|fd1
expr_stmt|;
block|}
else|else
block|{
comment|/* different devices here */
if|if
condition|(
operator|!
operator|(
name|fd1
operator|=
name|refclock_open
argument_list|(
name|device1
argument_list|,
name|SPEED
argument_list|,
name|LDISC_RAW
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: fd1"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd2
operator|=
name|open
argument_list|(
name|device2
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: fd2"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Devices now open, initialize instance structure */
if|if
condition|(
operator|!
operator|(
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|instance
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|instance
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|instance
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|instance
expr_stmt|;
name|instance
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|instance
operator|->
name|ttyfd
operator|=
name|fd1
expr_stmt|;
name|instance
operator|->
name|ppsfd
operator|=
name|fd2
expr_stmt|;
name|instance
operator|->
name|Bj_day
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|assert
operator|=
name|pps_assert
expr_stmt|;
comment|/* go read any input data in /etc/ntp.oncoreX */
name|oncore_read_config
argument_list|(
name|instance
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
if|if
condition|(
name|time_pps_create
argument_list|(
name|fd2
argument_list|,
operator|&
name|instance
operator|->
name|pps_h
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"time_pps_create"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|time_pps_getcap
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getcap failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|time_pps_getparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|instance
operator|->
name|pps_p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getparams failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* nb. only turn things on, if someone else has turned something 	 *      on before we get here, leave it alone! 	 */
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
block|{
comment|/* nb, default or ON */
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator|=
name|PPS_CAPTUREASSERT
operator||
name|PPS_OFFSETASSERT
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|assert_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|assert_offset
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator|=
name|PPS_CAPTURECLEAR
operator||
name|PPS_OFFSETCLEAR
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|clear_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|clear_offset
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator||=
name|PPS_TSFMT_TSPEC
expr_stmt|;
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator|&=
name|mode
expr_stmt|;
comment|/* only do it if it is legal */
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|instance
operator|->
name|pps_p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"time_pps_setparams"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pps_device
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|pps_device
argument_list|,
operator|&
name|stat1
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: stat pps_device"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* must have hardpps ON, and fd2 must be the same device as on the pps line */
if|if
condition|(
name|pps_hardpps
operator|&&
operator|(
operator|(
name|stat1
operator|.
name|st_dev
operator|==
name|stat2
operator|.
name|st_dev
operator|)
operator|&&
operator|(
name|stat1
operator|.
name|st_ino
operator|==
name|stat2
operator|.
name|st_ino
operator|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|i
operator|=
name|PPS_CAPTUREASSERT
expr_stmt|;
else|else
name|i
operator|=
name|PPS_CAPTURECLEAR
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|mode
condition|)
block|{
if|if
condition|(
name|time_pps_kcbind
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
name|PPS_KC_HARDPPS
argument_list|,
name|i
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_kcbind failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
name|instance
operator|->
name|pp
operator|=
name|pp
expr_stmt|;
name|instance
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_NO_IDEA
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_NO_IDEA"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
operator|-
literal|26
expr_stmt|;
name|peer
operator|->
name|minpoll
operator|=
literal|4
expr_stmt|;
name|peer
operator|->
name|maxpoll
operator|=
literal|4
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
literal|"Motorola UT/VP Oncore GPS Receiver"
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
literal|"GPS\0"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|oncore_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd1
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"io_addclock"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|instance
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|instance
expr_stmt|;
comment|/* 	 * This will start the Oncore receiver. 	 * We send info from config to Oncore later. 	 */
name|instance
operator|->
name|timeout
operator|=
literal|1
expr_stmt|;
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|3
operator|||
name|mode
operator|==
literal|4
condition|)
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cf
argument_list|,
sizeof|sizeof
name|oncore_cmd_Cf
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_RESET_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_RESET_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Fa
argument_list|,
sizeof|sizeof
name|oncore_cmd_Fa
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_TEST_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_TEST_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|instance
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_init_shmem
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ONCORE_SHMEM_STATUS
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|msg_desc
modifier|*
name|mp
decl_stmt|;
specifier|static
name|unsigned
name|int
name|oncore_shmem_length
decl_stmt|;
if|if
condition|(
name|oncore_messages
index|[
literal|0
index|]
operator|.
name|shmem
operator|==
literal|0
condition|)
block|{
name|n
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|oncore_messages
init|;
name|mp
operator|->
name|flag
index|[
literal|0
index|]
condition|;
name|mp
operator|++
control|)
block|{
name|mp
operator|->
name|shmem
operator|=
name|n
expr_stmt|;
comment|/* Allocate space for multiplexed almanac */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
condition|)
block|{
name|oncore_shmem_Cb
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|2
operator|)
operator|*
literal|34
expr_stmt|;
block|}
name|n
operator|+=
name|mp
operator|->
name|len
operator|+
literal|2
expr_stmt|;
block|}
name|oncore_shmem_length
operator|=
name|n
operator|+
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ONCORE: SHMEM length: %d bytes\n"
argument_list|,
name|oncore_shmem_length
argument_list|)
expr_stmt|;
block|}
name|instance
operator|->
name|statusfd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|statusfd
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|oncore_shmem_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|write
argument_list|(
name|instance
operator|->
name|statusfd
argument_list|,
name|buf
argument_list|,
name|oncore_shmem_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|oncore_shmem_length
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|instance
operator|->
name|shmem
operator|=
operator|(
name|u_char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|oncore_shmem_length
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
ifdef|#
directive|ifdef
name|MAP_HASSEMAPHORE
name|MAP_HASSEMAPHORE
operator||
endif|#
directive|endif
name|MAP_SHARED
argument_list|,
name|instance
operator|->
name|statusfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem
operator|==
name|MAP_FAILED
condition|)
block|{
name|instance
operator|->
name|shmem
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|instance
operator|->
name|statusfd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|mp
operator|=
name|oncore_messages
init|;
name|mp
operator|->
name|flag
index|[
literal|0
index|]
condition|;
name|mp
operator|++
control|)
block|{
name|l
operator|=
name|mp
operator|->
name|shmem
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|0
index|]
operator|=
name|mp
operator|->
name|len
operator|>>
literal|8
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|1
index|]
operator|=
name|mp
operator|->
name|len
operator|&
literal|0xff
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|2
index|]
operator|=
literal|'@'
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|3
index|]
operator|=
literal|'@'
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|4
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|0
index|]
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
literal|5
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|35
condition|;
name|i
operator|++
control|)
block|{
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
literal|35
operator|+
literal|0
index|]
operator|=
name|mp
operator|->
name|len
operator|>>
literal|8
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
literal|35
operator|+
literal|1
index|]
operator|=
name|mp
operator|->
name|len
operator|&
literal|0xff
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
literal|35
operator|+
literal|2
index|]
operator|=
literal|'@'
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
literal|35
operator|+
literal|3
index|]
operator|=
literal|'@'
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
literal|35
operator|+
literal|4
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|0
index|]
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|l
operator|+
name|i
operator|*
literal|35
operator|+
literal|5
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* ONCORE_SHMEM_STATUS */
block|}
end_function

begin_comment
comment|/*  * Read Input file if it exists.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_read_config
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
comment|/*  * First we try to open the configuration file /etc/ntp.oncoreN, where  * N is the unit number viz 127.127.30.N.  * If we don't find it, then we try the file /etc/ntp.oncore.  *  * If we find NEITHER then we don't have the cable delay or PPS offset  * and we choose MODE (4) below.  *  * Five Choices for MODE  *    (0) ONCORE is preinitialized, don't do anything to change it.  *	    nb, DON'T set 0D mode, DON'T set Delay, position...  *    (1) NO RESET, Read Position, delays from data file, lock it in, go to 0D mode.  *    (2) NO RESET, Read Delays from data file, do SITE SURVEY to get position,  *		    lock this in, go to 0D mode.  *    (3) HARD RESET, Read Position, delays from data file, lock it in, go to 0D mode.  *    (4) HARD RESET, Read Delays from data file, do SITE SURVEY to get position,  *		    lock this in, go to 0D mode.  *     NB. If a POSITION is specified in the config file with mode=(2,4) [SITE SURVEY]  *	   then this position is set as the INITIAL position of the ONCORE.  *	   This can reduce the time to first fix.  * -------------------------------------------------------------------------------  * Note that an Oncore UT without a battery backup retains NO information if it is  *   power cycled, with a Battery Backup it remembers the almanac, etc.  * For an Oncore VP, there is an eeprom that will contain this data, along with the  *   option of Battery Backup.  * So a UT without Battery Backup is equivalent to doing a HARD RESET on each  *   power cycle, since there is nowhere to store the data.  * -------------------------------------------------------------------------------  *  * If we open one or the other of the files, we read it looking for  *   MODE, LAT, LON, (HT, HTGPS, HTMSL), DELAY, OFFSET  * then initialize using method MODE.  For Mode = (1,3) all of (LAT, LON, HT) must  *   be present or mode reverts to (2,4).  *  * Read input file.  *  *	# is comment to end of line  *	= allowed between 1st and 2nd fields.  *  *	Expect to see one line with 'MODE' as first field, followed by an integer  *	   in the range 0-4 (default = 4).  *  *	Expect to see two lines with 'LONG', 'LAT' followed by 1-3 fields.  *	All numbers are floating point.  *		DDD.ddd  *		DDD  MMM.mmm  *		DDD  MMM  SSS.sss  *  *	Expect to see one line with 'HT' (or 'HTMSL' or 'HTGPS') as first field.  *	   followed by 1-2 fields.  First is a number, the second is 'FT' or 'M'.  *	   for feet or meters.	HT is the same as HTGPS.  *	     HTMSL = HT above mean_sea_level,  *	     HTGPS = HT above GPS ellipse.  *  *	There are two optional lines, starting with DELAY and OFFSET, followed  *	   by 1 or two fields.	The first is a number (a time) the second is  *	   'MS', 'US' or 'NS' for miliseconds, microseconds or nanoseconds.  *	     DELAY  is cable delay, typically a few tens of ns.  *	     OFFSET is the offset of the PPS pulse from 0. (only fully implemented  *		with the PPSAPI, we need to be able to tell the Kernel about this  *		offset if the Kernel PLL is in use, but can only do this presently  *		when using the PPSAPI interface.  If not using the Kernel PLL,  *		then there is no problem.  *  *	There is another optional line, with either ASSERT or CLEAR on it, which  *	   determine which transition of the PPS signal is used for timing by the  *	   PPSAPI.  If neither is present, then ASSERT is assumed.  *  * So acceptable input would be  *	# these are my coordinates (RWC)  *	LON  -106 34.610  *	LAT    35 08.999  *	HT	1589	# could equally well say HT 5215 FT  *	DELAY  60 ns  */
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cc
decl_stmt|,
modifier|*
name|ca
decl_stmt|,
name|line
index|[
literal|100
index|]
decl_stmt|,
name|units
index|[
literal|2
index|]
decl_stmt|,
name|device
index|[
literal|20
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sign
decl_stmt|,
name|lat_flg
decl_stmt|,
name|long_flg
decl_stmt|,
name|ht_flg
decl_stmt|,
name|mode
decl_stmt|;
name|double
name|f1
decl_stmt|,
name|f2
decl_stmt|,
name|f3
decl_stmt|;
name|sprintf
argument_list|(
name|device
argument_list|,
literal|"%s%d"
argument_list|,
name|INIT_FILE
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|device
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|INIT_FILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|instance
operator|->
name|init_type
operator|=
literal|4
expr_stmt|;
return|return;
block|}
name|mode
operator|=
literal|0
expr_stmt|;
name|lat_flg
operator|=
name|long_flg
operator|=
name|ht_flg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|100
argument_list|,
name|fd
argument_list|)
condition|)
block|{
comment|/* Remove comments */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'#'
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove trailing space */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
init|;
name|i
operator|>
literal|0
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
name|line
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|line
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|;
control|)
name|line
index|[
operator|--
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove leading space */
for|for
control|(
name|cc
operator|=
name|line
init|;
operator|*
name|cc
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|)
condition|;
name|cc
operator|++
control|)
continue|continue;
comment|/* Stop if nothing left */
if|if
condition|(
operator|!
operator|*
name|cc
condition|)
continue|continue;
comment|/* Lowercase the command and find the arg */
for|for
control|(
name|ca
operator|=
name|cc
init|;
operator|*
name|ca
condition|;
name|ca
operator|++
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|&&
name|islower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
condition|)
block|{
operator|*
name|ca
operator|=
name|toupper
argument_list|(
operator|*
name|ca
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|ca
operator|==
literal|'='
condition|)
block|{
operator|*
name|ca
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
block|}
comment|/* Remove space leading the arg */
for|for
control|(
init|;
operator|*
name|ca
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
condition|;
name|ca
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"STATUS"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|oncore_init_shmem
argument_list|(
name|instance
argument_list|,
name|ca
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Uppercase argument as well */
for|for
control|(
name|cp
operator|=
name|ca
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|&&
name|islower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"LAT"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|f1
operator|=
name|f2
operator|=
name|f3
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %lf %lf"
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|,
operator|&
name|f3
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
condition|)
block|{
name|f1
operator|=
operator|-
name|f1
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|instance
operator|->
name|ss_lat
operator|=
name|sign
operator|*
literal|1000
operator|*
operator|(
name|fabs
argument_list|(
name|f3
argument_list|)
operator|+
literal|60
operator|*
operator|(
name|fabs
argument_list|(
name|f2
argument_list|)
operator|+
literal|60
operator|*
name|f1
operator|)
operator|)
expr_stmt|;
comment|/*miliseconds*/
name|lat_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"LON"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|f1
operator|=
name|f2
operator|=
name|f3
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %lf %lf"
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|,
operator|&
name|f3
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
condition|)
block|{
name|f1
operator|=
operator|-
name|f1
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|instance
operator|->
name|ss_long
operator|=
name|sign
operator|*
literal|1000
operator|*
operator|(
name|fabs
argument_list|(
name|f3
argument_list|)
operator|+
literal|60
operator|*
operator|(
name|fabs
argument_list|(
name|f2
argument_list|)
operator|+
literal|60
operator|*
name|f1
operator|)
operator|)
expr_stmt|;
comment|/*miliseconds*/
name|long_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"HT"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"HTGPS"
argument_list|,
literal|5
argument_list|)
condition|)
name|instance
operator|->
name|ss_ht_type
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"HTMSL"
argument_list|,
literal|5
argument_list|)
condition|)
name|instance
operator|->
name|ss_ht_type
operator|=
literal|1
expr_stmt|;
else|else
name|instance
operator|->
name|ss_ht_type
operator|=
literal|0
expr_stmt|;
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'F'
condition|)
name|f1
operator|=
literal|0.3048
operator|*
name|f1
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
literal|100
operator|*
name|f1
expr_stmt|;
comment|/* cm */
name|ht_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"DELAY"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'U'
condition|)
name|f1
operator|=
literal|1000
operator|*
name|f1
expr_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
name|f1
operator|=
literal|1000000
operator|*
name|f1
expr_stmt|;
else|else
name|f1
operator|=
literal|1000000000
operator|*
name|f1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|1.e9
condition|)
name|f1
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|delay
operator|=
name|f1
expr_stmt|;
comment|/* delay in ns */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"OFFSET"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'U'
condition|)
name|f1
operator|=
literal|1000
operator|*
name|f1
expr_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
name|f1
operator|=
literal|1000000
operator|*
name|f1
expr_stmt|;
else|else
name|f1
operator|=
literal|1000000000
operator|*
name|f1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|1.e9
condition|)
name|f1
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|offset
operator|=
name|f1
expr_stmt|;
comment|/* offset in ns */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"MODE"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
literal|0
operator|||
name|mode
operator|>
literal|4
condition|)
name|mode
operator|=
literal|4
expr_stmt|;
name|instance
operator|->
name|init_type
operator|=
name|mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"ASSERT"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|instance
operator|->
name|assert
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"CLEAR"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|instance
operator|->
name|assert
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 *    OK, have read all of data file, and extracted the good stuff. 	 *    If lat/long/ht specified they ALL must be specified for mode = (1,3). 	 */
name|instance
operator|->
name|posn_set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|lat_flg
operator|||
name|long_flg
operator|||
name|ht_flg
operator|)
operator|&&
operator|!
operator|(
name|lat_flg
operator|*
name|long_flg
operator|*
name|ht_flg
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: incomplete data on %s\n"
argument_list|,
name|INIT_FILE
argument_list|)
expr_stmt|;
name|instance
operator|->
name|posn_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|1
operator|||
name|mode
operator|==
literal|3
condition|)
name|instance
operator|->
name|init_type
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * oncore_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|oncore_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|free
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * oncore_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|oncore_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|timeout
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
name|oncore_cmd_Cj
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_ID_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_ID_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|instance
operator|->
name|pollcnt
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|instance
operator|->
name|pollcnt
operator|--
expr_stmt|;
name|peer
operator|->
name|procptr
operator|->
name|polls
operator|++
expr_stmt|;
name|instance
operator|->
name|polled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * move dta from NTP to buffer (toss in unlikely case it wont fit)  */
end_comment

begin_function
specifier|static
name|void
name|oncore_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
if|#
directive|if
literal|0
block|if (debug> 4) { 		int i; 		printf("ONCORE:>>>"); 		for(i=0; i<rbufp->recv_length; i++) 			printf("%02x ", p[i]); 		printf("\n"); 		printf("ONCORE:>>>"); 		for(i=0; i<rbufp->recv_length; i++) 			printf("%03o ", p[i]); 		printf("\n"); 	}
endif|#
directive|endif
name|i
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|rcvbuf
operator|+
name|rcvptr
operator|+
name|i
operator|>
operator|&
name|rcvbuf
index|[
sizeof|sizeof
name|rcvbuf
index|]
condition|)
name|i
operator|=
sizeof|sizeof
argument_list|(
name|rcvbuf
argument_list|)
operator|-
name|rcvptr
expr_stmt|;
comment|/* and some char will be lost */
name|memcpy
argument_list|(
name|rcvbuf
operator|+
name|rcvptr
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rcvptr
operator|+=
name|i
expr_stmt|;
name|oncore_consume
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deal with any complete messages  */
end_comment

begin_function
specifier|static
name|void
name|oncore_consume
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|m
decl_stmt|;
name|unsigned
name|l
decl_stmt|;
while|while
condition|(
name|rcvptr
operator|>=
literal|7
condition|)
block|{
if|if
condition|(
name|rcvbuf
index|[
literal|0
index|]
operator|!=
literal|'@'
operator|||
name|rcvbuf
index|[
literal|1
index|]
operator|!=
literal|'@'
condition|)
block|{
comment|/* We're not in sync, lets try to get there */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rcvptr
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rcvbuf
index|[
name|i
index|]
operator|==
literal|'@'
operator|&&
name|rcvbuf
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'@'
condition|)
break|break;
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"ONCORE:>>> skipping %d chars\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|rcvptr
condition|)
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
name|i
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|rcvptr
operator|-
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
name|i
expr_stmt|;
block|}
comment|/* Ok, we have a header now */
name|l
operator|=
sizeof|sizeof
argument_list|(
name|oncore_messages
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|oncore_messages
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|l
condition|;
name|m
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|oncore_messages
index|[
name|m
index|]
operator|.
name|flag
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|rcvbuf
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
condition|)
break|break;
name|l
operator|=
name|oncore_messages
index|[
name|m
index|]
operator|.
name|len
expr_stmt|;
if|#
directive|if
literal|0
block|if (debug> 3) 			printf("ONCORE: GOT: %c%c  %d of %d entry %d\n", rcvbuf[2], rcvbuf[3], rcvptr, l, m);
endif|#
directive|endif
comment|/* Got the entire message ? */
if|if
condition|(
name|rcvptr
operator|<
name|l
condition|)
return|return;
comment|/* Check the checksum */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|l
operator|-
literal|3
condition|;
name|i
operator|++
control|)
name|j
operator|^=
name|rcvbuf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|rcvbuf
index|[
name|l
operator|-
literal|3
index|]
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|shmem
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|instance
operator|->
name|shmem
operator|+
name|oncore_messages
index|[
name|m
index|]
operator|.
name|shmem
operator|+
literal|2
argument_list|,
name|rcvbuf
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|oncore_msg_any
argument_list|(
name|instance
argument_list|,
name|rcvbuf
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|l
operator|-
literal|3
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|oncore_messages
index|[
name|m
index|]
operator|.
name|handler
condition|)
name|oncore_messages
index|[
name|m
index|]
operator|.
name|handler
argument_list|(
name|instance
argument_list|,
name|rcvbuf
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|l
operator|-
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: Checksum mismatch! calc %o is %o\n"
argument_list|,
name|j
argument_list|,
name|rcvbuf
index|[
name|l
operator|-
literal|3
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ONCORE: @@%c%c "
argument_list|,
name|rcvbuf
index|[
literal|2
index|]
argument_list|,
name|rcvbuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%03o "
argument_list|,
name|rcvbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|!=
name|rcvptr
condition|)
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
name|l
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|rcvptr
operator|-
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
name|l
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * write message to Oncore.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_sendmsg
parameter_list|(
name|int
name|fd
parameter_list|,
name|u_char
modifier|*
name|ptr
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|u_char
name|cs
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"ONCORE: Send @@%c%c %d\n"
argument_list|,
name|ptr
index|[
literal|0
index|]
argument_list|,
name|ptr
index|[
literal|1
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
literal|"@@"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|cs
operator|^=
operator|*
name|ptr
operator|++
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|cs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_msg_any
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|oncore_messages
index|[
name|idx
index|]
operator|.
name|fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ONCORE: %ld.%06ld\n"
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|fmt
condition|)
block|{
name|printf
argument_list|(
literal|">>@@%c%c "
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|len
operator|&&
name|i
operator|<
literal|2400
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"##"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fmt
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%c%c"
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fmt
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Demultiplex the almanac into shmem  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cb
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|5
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|4
operator|&&
name|buf
index|[
literal|5
index|]
operator|<=
literal|5
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
operator|+
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|4
operator|&&
name|buf
index|[
literal|5
index|]
operator|<=
literal|10
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
operator|+
literal|23
expr_stmt|;
else|else
name|i
operator|=
literal|34
expr_stmt|;
name|i
operator|*=
literal|35
expr_stmt|;
name|memcpy
argument_list|(
name|instance
operator|->
name|shmem
operator|+
name|oncore_shmem_Cb
operator|+
name|i
operator|+
literal|2
argument_list|,
name|buf
argument_list|,
name|len
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set to Factory Defaults (Reasonable for UT w/ no Battery Backup  *	not so for VP (eeprom) or UT with battery  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cf
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_RESET_SENT
condition|)
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Fa
argument_list|,
sizeof|sizeof
name|oncore_cmd_Fa
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_TEST_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_TEST_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* there are good reasons NOT to do a @@Fa command with the ONCORE.  * Doing it, it was found that under some circumstances the following  * command would fail if issued immediately after the return from the  * @@Fa, but a 2sec delay seemed to fix things.  Since simply calling  * sleep(2) is wastefull, and may cause trouble for some OS's, repeating  * itimer, we set a flag, and test it at the next POLL.  If it hasnt  * been cleared, we reissue the @@Ca that is issued below.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Fa
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_TEST_SENT
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"ONCORE:>>@@Fa %x %x\n"
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|||
name|buf
index|[
literal|5
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: SELF TEST FAILED\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
name|oncore_cmd_Cj
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_ID_SENT
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_ID_SENT"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * preliminaries out of the way, this is the REAL start of initialization  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Cj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_ID_SENT
condition|)
return|return;
name|memcpy
argument_list|(
name|instance
operator|->
name|Cj
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write Receiver ID to clockstats file */
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|instance
operator|->
name|Cj
init|;
name|cp
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
condition|;
control|)
block|{
name|cp1
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp1
condition|)
name|cp1
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
expr_stmt|;
operator|*
name|cp1
operator|=
literal|'\0'
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|=
literal|'\r'
expr_stmt|;
name|cp
operator|=
name|cp1
operator|+
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|cp
operator|=
literal|"Timing on Assert."
expr_stmt|;
else|else
name|cp
operator|=
literal|"Timing on Clear."
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Cg
argument_list|,
sizeof|sizeof
name|oncore_cmd_Cg
argument_list|)
expr_stmt|;
comment|/* Set Posn Fix mode (not Idle (VP)) */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bb
argument_list|,
sizeof|sizeof
name|oncore_cmd_Bb
argument_list|)
expr_stmt|;
comment|/* turn off */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ek
argument_list|,
sizeof|sizeof
name|oncore_cmd_Ek
argument_list|)
expr_stmt|;
comment|/* turn off */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Aw
argument_list|,
sizeof|sizeof
name|oncore_cmd_Aw
argument_list|)
expr_stmt|;
comment|/* UTC time */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_AB
argument_list|,
sizeof|sizeof
name|oncore_cmd_AB
argument_list|)
expr_stmt|;
comment|/* Appl type static */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Be
argument_list|,
sizeof|sizeof
name|oncore_cmd_Be
argument_list|)
expr_stmt|;
comment|/* Tell us the Almanac */
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ONCORE: INIT mode = %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* If there is Position input in the Config file 	 * and mode = (1,3) set it as posn hold posn, goto 0D mode. 	 *  or mode = (2,4) set it as INITIAL position, and Site Survey. 	 */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* NO initialization, don't change anything */
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|3
case|:
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_As
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_As
index|[
literal|6
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_As
index|[
literal|10
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|oncore_cmd_As
index|[
literal|14
index|]
operator|=
name|instance
operator|->
name|ss_ht_type
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_As
argument_list|,
sizeof|sizeof
name|oncore_cmd_As
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
name|oncore_cmd_At
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At
argument_list|,
sizeof|sizeof
name|oncore_cmd_At
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Now in 0D mode"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|4
case|:
if|if
condition|(
name|instance
operator|->
name|posn_set
condition|)
block|{
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_Ad
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_Ae
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_Af
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|oncore_cmd_Af
index|[
literal|6
index|]
operator|=
name|instance
operator|->
name|ss_ht_type
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ad
argument_list|,
sizeof|sizeof
name|oncore_cmd_Ad
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ae
argument_list|,
sizeof|sizeof
name|oncore_cmd_Ae
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Af
argument_list|,
sizeof|sizeof
name|oncore_cmd_Af
argument_list|)
expr_stmt|;
block|}
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_UNKNOWN
expr_stmt|;
name|oncore_cmd_At
index|[
literal|2
index|]
operator|=
literal|2
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At
argument_list|,
sizeof|sizeof
name|oncore_cmd_At
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mode
operator|!=
literal|0
condition|)
block|{
comment|/* cable delay in ns */
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_Az
index|[
literal|2
index|]
argument_list|,
name|instance
operator|->
name|delay
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Az
argument_list|,
sizeof|sizeof
name|oncore_cmd_Az
argument_list|)
expr_stmt|;
comment|/* PPS offset in ns */
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_Ay
index|[
literal|2
index|]
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ay
argument_list|,
sizeof|sizeof
name|oncore_cmd_Ay
argument_list|)
expr_stmt|;
block|}
comment|/* 8chan - Position/Status/Data Output Message, 1/s */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ea
argument_list|,
sizeof|sizeof
name|oncore_cmd_Ea
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_ALMANAC
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_ALMANAC"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_msg_Ea
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_ALMANAC
operator|&&
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_RUN
condition|)
return|return;
name|memcpy
argument_list|(
name|instance
operator|->
name|Ea
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* When we have an almanac, start the En messages */
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_ALMANAC
condition|)
block|{
if|if
condition|(
operator|(
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
operator|&
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ONCORE: waiting for almanac\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_En
argument_list|,
sizeof|sizeof
name|oncore_cmd_En
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_RUN
expr_stmt|;
name|cp
operator|=
literal|"state = ONCORE_RUN"
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* must be ONCORE_RUN if we are here */
comment|/* First check if Hardware SiteSurvey has Finished */
if|if
condition|(
operator|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_HW
operator|)
operator|&&
operator|!
operator|(
name|instance
operator|->
name|Ea
index|[
literal|37
index|]
operator|&
literal|0x20
operator|)
condition|)
block|{
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Now in 0D mode"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|instance
operator|->
name|printed
operator|&&
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_DONE
condition|)
block|{
comment|/* will print to clockstat when all */
name|instance
operator|->
name|printed
operator|=
literal|1
expr_stmt|;
comment|/* three messages respond */
comment|/* Read back Position Hold Params */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Asx
argument_list|,
sizeof|sizeof
name|oncore_cmd_Asx
argument_list|)
expr_stmt|;
comment|/* Read back PPS Offset for Output */
comment|/* Nb. This will fail silently for early UT (no plus) model */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Ayx
argument_list|,
sizeof|sizeof
name|oncore_cmd_Ayx
argument_list|)
expr_stmt|;
comment|/* Read back Cable Delay for Output */
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Azx
argument_list|,
sizeof|sizeof
name|oncore_cmd_Azx
argument_list|)
expr_stmt|;
block|}
comment|/* Check the leap second status once per day */
comment|/* 	 * The following additional check, checking for June/December, is a 	 * workaround for incorrect ONCORE firmware.  The oncore starts 	 * reporting the leap second when the GPS satellite data message 	 * (page 18, subframe 4) is updated to a date in the future, which 	 * which can be several months before the leap second.	WWV and other 	 * services seem to wait until the month of the event to turn 	 * on their indicators (which are usually a single bit). 	 */
if|if
condition|(
operator|(
name|buf
index|[
literal|4
index|]
operator|==
literal|6
operator|)
operator|||
operator|(
name|buf
index|[
literal|4
index|]
operator|==
literal|12
operator|)
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|Bj_day
operator|!=
name|buf
index|[
literal|5
index|]
condition|)
block|{
comment|/* do this 1/day */
name|instance
operator|->
name|Bj_day
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_Bj
argument_list|,
sizeof|sizeof
name|oncore_cmd_Bj
argument_list|)
expr_stmt|;
block|}
block|}
name|instance
operator|->
name|pp
operator|->
name|year
operator|=
name|buf
index|[
literal|6
index|]
operator|*
literal|256
operator|+
name|buf
index|[
literal|7
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|day
operator|=
name|ymd2yd
argument_list|(
name|buf
index|[
literal|6
index|]
operator|*
literal|256
operator|+
name|buf
index|[
literal|7
index|]
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|hour
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|minute
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|second
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|!=
name|ONCORE_SS_SW
condition|)
return|return;
comment|/* 	 * We have to average our own position for the Position Hold Mode 	 */
comment|/* We only take PDOP/3D fixes */
if|if
condition|(
name|instance
operator|->
name|Ea
index|[
literal|37
index|]
operator|&
literal|1
condition|)
return|return;
comment|/* Not if poor geometry or less than 3 sats */
if|if
condition|(
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
operator|&
literal|0x52
condition|)
return|return;
comment|/* Only 3D fix */
if|if
condition|(
operator|!
operator|(
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
operator|&
literal|0x20
operator|)
condition|)
return|return;
name|instance
operator|->
name|ss_lat
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|Ea
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|Ea
index|[
literal|19
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|Ea
index|[
literal|23
index|]
argument_list|)
expr_stmt|;
comment|/* GPS ellipse */
name|instance
operator|->
name|ss_count
operator|++
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|ss_count
operator|!=
name|POS_HOLD_AVERAGE
condition|)
return|return;
name|instance
operator|->
name|ss_lat
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Surveyed posn:  lat %.3f long %.3f ht %.3f"
argument_list|,
name|instance
operator|->
name|ss_lat
argument_list|,
name|instance
operator|->
name|ss_long
argument_list|,
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_As
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_As
index|[
literal|6
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|oncore_cmd_As
index|[
literal|10
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|oncore_cmd_As
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_As
argument_list|,
sizeof|sizeof
name|oncore_cmd_As
argument_list|)
expr_stmt|;
name|oncore_cmd_At
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At
argument_list|,
sizeof|sizeof
name|oncore_cmd_At
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Now in 0D mode"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_msg_En
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|l_fp
name|ts
decl_stmt|,
name|ts_tmp
decl_stmt|;
name|double
name|dmy
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMESPEC
name|struct
name|timespec
modifier|*
name|tsp
init|=
literal|0
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
modifier|*
name|tsp
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|struct
name|timespec
name|timeout
decl_stmt|;
name|pps_info_t
name|pps_i
decl_stmt|;
else|#
directive|else
comment|/* ! HAVE_PPSAPI */
ifdef|#
directive|ifdef
name|HAVE_CIOGETEV
name|struct
name|ppsclockev
name|ev
decl_stmt|;
name|int
name|r
init|=
name|CIOGETEV
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIOCGPPSEV
name|struct
name|ppsclockev
name|ev
decl_stmt|;
name|int
name|r
init|=
name|TIOCGPPSEV
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TIOCDCDTIMESTAMP
name|struct
name|timeval
name|tv
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ! HAVE_PPS_API */
if|if
condition|(
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_RUN
condition|)
return|return;
name|memcpy
argument_list|(
name|instance
operator|->
name|En
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Don't do anything without an almanac to define the GPS->UTC delta */
if|if
condition|(
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
operator|&
literal|1
condition|)
return|return;
comment|/* If Time RAIM doesn't like it, don't trust it */
if|if
condition|(
name|instance
operator|->
name|En
index|[
literal|21
index|]
condition|)
return|return;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|j
operator|=
name|instance
operator|->
name|ev_serial
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|time_pps_fetch
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|pps_i
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: time_pps_fetch failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
block|{
name|tsp
operator|=
operator|&
name|pps_i
operator|.
name|assert_timestamp
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"ONCORE: serial/j (%d, %d) %ld.%09ld\n"
argument_list|,
name|pps_i
operator|.
name|assert_sequence
argument_list|,
name|j
argument_list|,
name|tsp
operator|->
name|tv_sec
argument_list|,
name|tsp
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|pps_i
operator|.
name|assert_sequence
operator|==
name|j
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: oncore_msg_En, error serial pps\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|pps_i
operator|.
name|assert_sequence
expr_stmt|;
block|}
else|else
block|{
name|tsp
operator|=
operator|&
name|pps_i
operator|.
name|clear_timestamp
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"ONCORE: serial/j (%d, %d) %ld.%09ld\n"
argument_list|,
name|pps_i
operator|.
name|clear_sequence
argument_list|,
name|j
argument_list|,
name|tsp
operator|->
name|tv_sec
argument_list|,
name|tsp
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|pps_i
operator|.
name|clear_sequence
operator|==
name|j
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: oncore_msg_En, error serial pps\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|pps_i
operator|.
name|clear_sequence
expr_stmt|;
block|}
comment|/* convert timespec -> ntp l_fp */
name|dmy
operator|=
name|tsp
operator|->
name|tv_nsec
expr_stmt|;
name|dmy
operator|/=
literal|1e9
expr_stmt|;
name|ts
operator|.
name|l_uf
operator|=
name|dmy
operator|*
literal|4294967296.0
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|=
name|tsp
operator|->
name|tv_sec
expr_stmt|;
if|#
directive|if
literal|0
block|alternate code for previous 4 lines is 	dmy = 1.0e-9*tsp->tv_nsec;
comment|/* fractional part */
block|DTOLFP(dmy,&ts); 	dmy = tsp->tv_sec;
comment|/* integer part */
block|DTOLFP(dmy,&ts_tmp); 	L_ADD(&ts,&ts_tmp);      or more simply 	dmy = 1.0e-9*tsp->tv_nsec;
comment|/* fractional part */
block|DTOLFP(dmy,&ts); 	ts.l_ui = tsp->tv_sec;
endif|#
directive|endif
comment|/* 0 */
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TIOCGPPSEV
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_CIOGETEV
argument_list|)
name|j
operator|=
name|instance
operator|->
name|ev_serial
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|instance
operator|->
name|ppsfd
argument_list|,
name|r
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: IOCTL:"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tsp
operator|=
operator|&
name|ev
operator|.
name|tv
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"ONCORE: serial/j (%d, %d) %ld.%06ld\n"
argument_list|,
name|ev
operator|.
name|serial
argument_list|,
name|j
argument_list|,
name|tsp
operator|->
name|tv_sec
argument_list|,
name|tsp
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|serial
operator|==
name|j
condition|)
block|{
name|printf
argument_list|(
literal|"ONCORE: oncore_msg_En, error serial pps\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|ev
operator|.
name|serial
expr_stmt|;
comment|/* convert timeval -> ntp l_fp */
name|TVTOTS
argument_list|(
name|tsp
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|TIOCDCDTIMESTAMP
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|instance
operator|->
name|ppsfd
argument_list|,
name|TIOCDCDTIMESTAMP
argument_list|,
operator|&
name|tv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ONCORE: ioctl(TIOCDCDTIMESTAMP)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tsp
operator|=
operator|&
name|tv
expr_stmt|;
name|TVTOTS
argument_list|(
name|tsp
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"Cannot compile -- no PPS mechanism configured!"
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* now have timestamp in ts */
comment|/* add in saw_tooth and offset */
comment|/* saw_tooth not really necessary if using TIMEVAL */
comment|/* since its only precise to us, but do it anyway. */
comment|/* offset in ns, and is positive (late), we subtract */
comment|/* to put the PPS time transition back where it belongs */
name|j
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
name|instance
operator|->
name|saw_tooth
operator|=
operator|(
name|s_char
operator|)
name|buf
index|[
literal|25
index|]
expr_stmt|;
comment|/* update for next time */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
comment|/* must hand this offset off to the Kernel to do the addition */
comment|/* so that the Kernel PLL sees the offset too */
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
block|{
name|instance
operator|->
name|pps_p
operator|.
name|assert_offset
operator|.
name|tv_nsec
operator|=
operator|-
operator|(
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|->
name|pps_p
operator|.
name|clear_offset
operator|.
name|tv_nsec
operator|=
operator|-
operator|(
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|instance
operator|->
name|pps_p
argument_list|)
condition|)
name|perror
argument_list|(
literal|"time_pps_setparams"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* if not PPSAPI, no way to inform kernel of OFFSET, just do it */
name|dmy
operator|=
operator|-
literal|1.0e-9
operator|*
name|j
expr_stmt|;
name|DTOLFP
argument_list|(
name|dmy
argument_list|,
operator|&
name|ts_tmp
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|ts_tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* have time from UNIX origin, convert to NTP origin. */
name|ts
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|lastrec
operator|=
name|ts
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|msec
operator|=
literal|0
expr_stmt|;
name|ts_tmp
operator|=
name|ts
expr_stmt|;
name|ts_tmp
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
comment|/* zero integer part */
name|LFPTOD
argument_list|(
operator|&
name|ts_tmp
argument_list|,
name|dmy
argument_list|)
expr_stmt|;
comment|/* convert fractional part to a double */
name|j
operator|=
literal|1.0e9
operator|*
name|dmy
expr_stmt|;
comment|/* then to integer ns */
name|sprintf
argument_list|(
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%u.%09u %d %d %2d %2d %2d %2ld rstat %02x dop %d nsat %2d,%d raim %d sigma %d neg-sawtooth %3d sat %d%d%d%d%d%d%d%d"
argument_list|,
name|ts
operator|.
name|l_ui
argument_list|,
name|j
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|year
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|day
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|hour
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|minute
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|second
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
operator|%
literal|60
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|72
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|37
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|38
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|39
index|]
argument_list|,
name|instance
operator|->
name|En
index|[
literal|21
index|]
argument_list|,
comment|/*rstat           dop               nsat visible,     nsat tracked,     raim */
name|instance
operator|->
name|En
index|[
literal|23
index|]
operator|*
literal|256
operator|+
name|instance
operator|->
name|En
index|[
literal|24
index|]
argument_list|,
operator|(
name|s_char
operator|)
name|buf
index|[
literal|25
index|]
argument_list|,
comment|/* sigma				   neg-sawtooth */
comment|/*sat*/
name|instance
operator|->
name|Ea
index|[
literal|41
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|45
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|49
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|53
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|57
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|61
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|65
index|]
argument_list|,
name|instance
operator|->
name|Ea
index|[
literal|69
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ONCORE: len = %d %s\n"
argument_list|,
name|i
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|instance
operator|->
name|pp
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|instance
operator|->
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|instance
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|polled
condition|)
block|{
name|instance
operator|->
name|polled
operator|=
literal|0
expr_stmt|;
comment|/* 		instance->pp->dispersion = instance->pp->skew = 0; */
name|refclock_receive
argument_list|(
name|instance
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Try to use Oncore UT+ Auto Survey Feature  *	If its not there (VP), set flag to do it ourselves.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_At
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|!=
name|ONCORE_SS_UNKNOWN
condition|)
return|return;
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|2
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Initiating hardware 3D site survey"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_HW
expr_stmt|;
block|}
else|else
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
comment|/* 		 * Probably a VP or an older UT which can't do site-survey. 		 * We will have to do it ourselves 		 */
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Initiating software 3D site survey (%d samples)"
argument_list|,
name|POS_HOLD_AVERAGE
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_SW
expr_stmt|;
name|oncore_cmd_At
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|ss_lat
operator|=
name|instance
operator|->
name|ss_long
operator|=
name|instance
operator|->
name|ss_ht
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|oncore_cmd_At
argument_list|,
sizeof|sizeof
name|oncore_cmd_At
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get leap-second warning message */
end_comment

begin_comment
comment|/*  * @@Bj does NOT behave as documented in current Oncore firmware.  * It turns on the LEAP indicator when the data is set, and does not,  * as documented, wait until the beginning of the month when the  * leap second will occur.  * Until this firmware bug is fixed, @@Bj is only called in June/December.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Bj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|4
index|]
condition|)
block|{
case|case
literal|1
case|:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_ADDSECOND"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_DELSECOND"
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_NOWARNING"
expr_stmt|;
break|break;
block|}
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get Position hold position  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_As
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|,
name|ew
decl_stmt|,
name|ns
decl_stmt|;
specifier|const
name|char
modifier|*
name|Ht
decl_stmt|;
name|double
name|xd
decl_stmt|,
name|xm
decl_stmt|,
name|xs
decl_stmt|,
name|yd
decl_stmt|,
name|ym
decl_stmt|,
name|ys
decl_stmt|,
name|hm
decl_stmt|,
name|hft
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|idy
decl_stmt|,
name|is
decl_stmt|,
name|imx
decl_stmt|,
name|imy
decl_stmt|;
name|long
name|lat
decl_stmt|,
name|lon
decl_stmt|,
name|ht
decl_stmt|;
if|if
condition|(
operator|!
name|instance
operator|->
name|printed
operator|||
name|instance
operator|->
name|As
condition|)
return|return;
name|instance
operator|->
name|As
operator|=
literal|1
expr_stmt|;
name|lat
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_lat
operator|=
name|lat
expr_stmt|;
name|lon
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|=
name|lon
expr_stmt|;
name|ht
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
name|ht
expr_stmt|;
name|instance
operator|->
name|ss_ht_type
operator|=
name|buf
index|[
literal|16
index|]
expr_stmt|;
comment|/* Print out Position */
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Posn:"
argument_list|)
expr_stmt|;
name|ew
operator|=
literal|'E'
expr_stmt|;
name|lon
operator|=
name|instance
operator|->
name|ss_long
expr_stmt|;
if|if
condition|(
name|lon
operator|<
literal|0
condition|)
block|{
name|ew
operator|=
literal|'W'
expr_stmt|;
name|lon
operator|=
operator|-
name|lon
expr_stmt|;
block|}
name|ns
operator|=
literal|'N'
expr_stmt|;
name|lat
operator|=
name|instance
operator|->
name|ss_lat
expr_stmt|;
if|if
condition|(
name|lat
operator|<
literal|0
condition|)
block|{
name|ns
operator|=
literal|'S'
expr_stmt|;
name|lat
operator|=
operator|-
name|lat
expr_stmt|;
block|}
name|hm
operator|=
name|instance
operator|->
name|ss_ht
operator|/
literal|100.
expr_stmt|;
name|hft
operator|=
name|hm
operator|/
literal|0.3048
expr_stmt|;
name|Ht
operator|=
name|instance
operator|->
name|ss_ht_type
condition|?
literal|"MSL"
else|:
literal|"GPS"
expr_stmt|;
name|xd
operator|=
name|lat
operator|/
literal|3600000.
expr_stmt|;
comment|/* lat, lon in int msec arc, ht in cm. */
name|yd
operator|=
name|lon
operator|/
literal|3600000.
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Lat = %c %11.7fdeg,    Long = %c %11.7fdeg,    Alt = %5.2fm (%5.2fft) %s"
argument_list|,
name|ns
argument_list|,
name|xd
argument_list|,
name|ew
argument_list|,
name|yd
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|,
name|Ht
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|idx
operator|=
name|xd
expr_stmt|;
name|idy
operator|=
name|yd
expr_stmt|;
name|imx
operator|=
name|lat
operator|%
literal|3600000
expr_stmt|;
name|imy
operator|=
name|lon
operator|%
literal|3600000
expr_stmt|;
name|xm
operator|=
name|imx
operator|/
literal|60000.
expr_stmt|;
name|ym
operator|=
name|imy
operator|/
literal|60000.
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Lat = %c %3ddeg %7.4fm,   Long = %c %3ddeg %8.5fm,  Alt = %5.2fm (%5.2fft) %s"
argument_list|,
name|ns
argument_list|,
name|idx
argument_list|,
name|xm
argument_list|,
name|ew
argument_list|,
name|idy
argument_list|,
name|ym
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|,
name|Ht
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|imx
operator|=
name|xm
expr_stmt|;
name|imy
operator|=
name|ym
expr_stmt|;
name|is
operator|=
name|lat
operator|%
literal|60000
expr_stmt|;
name|xs
operator|=
name|is
operator|/
literal|1000.
expr_stmt|;
name|is
operator|=
name|lon
operator|%
literal|60000
expr_stmt|;
name|ys
operator|=
name|is
operator|/
literal|1000.
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Lat = %c %3ddeg %2dm %5.2fs, Long = %c %3ddeg %2dm %5.2fs, Alt = %5.2fm (%5.2fft) %s"
argument_list|,
name|ns
argument_list|,
name|idx
argument_list|,
name|imx
argument_list|,
name|xs
argument_list|,
name|ew
argument_list|,
name|idy
argument_list|,
name|imy
argument_list|,
name|ys
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|,
name|Ht
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get PPS Offset  * Nb. @@Ay is not supported for early UT (no plus) model  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Ay
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|instance
operator|->
name|printed
operator|||
name|instance
operator|->
name|Ay
condition|)
return|return;
name|instance
operator|->
name|Ay
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|offset
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"PPS Offset  is set to %ld ns"
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get Cable Delay  */
end_comment

begin_function
specifier|static
name|void
name|oncore_msg_Az
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|instance
operator|->
name|printed
operator|||
name|instance
operator|->
name|Az
condition|)
return|return;
name|instance
operator|->
name|Az
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|delay
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Msg
argument_list|,
literal|"Cable delay is set to %ld ns"
argument_list|,
name|instance
operator|->
name|delay
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_oncore_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

