begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_gpsdjson.c - clock driver as GPSD JSON client  *	Juergen Perlinger (perlinger@ntp.org)  *	Feb 11, 2014 for the NTP project.  *      The contents of 'html/copyright.html' apply.  *  *	Heavily inspired by refclock_nmea.c  *  * Special thanks to Gary Miller and Hal Murray for their comments and  * ideas.  *  * Note: This will currently NOT work with Windows due to some  * limitations:  *  *  - There is no GPSD for Windows. (There is an unofficial port to  *    cygwin, but Windows is not officially supported.)  *  *  - To work properly, this driver needs PPS and TPV/TOFF sentences  *    from GPSD. I don't see how the cygwin port should deal with the  *    PPS signal.  *  *  - The device name matching must be done in a different way for  *    Windows. (Can be done with COMxx matching, as done for NMEA.)  *  * Apart from those minor hickups, once GPSD has been fully ported to  * Windows, there's no reason why this should not work there ;-) If this  * is ever to happen at all is a different question.  *  * ---------------------------------------------------------------------  *  * This driver works slightly different from most others, as the PPS  * information (if available) is also coming from GPSD via the data  * connection. This makes using both the PPS data and the serial data  * easier, but OTOH it's not possible to use the ATOM driver to feed a  * raw PPS stream to the core of NTPD.  *  * To go around this, the driver can use a secondary clock unit  * (units>=128) that operate in tandem with the primary clock unit  * (unit%128). The primary clock unit does all the IO stuff and data  * decoding; if a a secondary unit is attached to a primary unit, this  * secondary unit is feed with the PPS samples only and can act as a PPS  * source to the clock selection.  *  * The drawback is that the primary unit must be present for the  * secondary unit to work.  *  * This design is a compromise to reduce the IO load for both NTPD and  * GPSD; it also ensures that data is transmitted and evaluated only  * once on the side of NTPD.  *  * ---------------------------------------------------------------------  *  * trouble shooting hints:  *  *   Enable and check the clock stats. Check if there are bad replies;  *   there should be none. If there are actually bad replies, then the  *   driver cannot parse all JSON records from GPSD, and some record  *   types are vital for the operation of the driver. This indicates a  *   problem on the protocol level.  *  *   When started on the command line with a debug level>= 2, the  *   driver dumps the raw received data and the parser input to  *   stdout. Since the debug level is global, NTPD starts to create a  *   *lot* of output. It makes sense to pipe it through '(f)grep  *   GPSD_JSON' before writing the result to disk.  *  *   A bit less intrusive is using netcat or telnet to connect to GPSD  *   and snoop what NTPD would get. If you try this, you have to send a  *   WATCH command to GPSD:  *  * ?WATCH={"device":"/dev/gps0","enable":true,"json":true,"pps":true};<CRLF>  *  *   should show you what GPSD has to say to NTPD. Replace "/dev/gps0"  *   with the device link used by GPSD, if necessary.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_GPSDJSON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_comment
comment|/* =====================================================================  * Get the little JSMN library directly into our guts. Use the 'parent  * link' feature for maximum speed.  */
end_comment

begin_define
define|#
directive|define
name|JSMN_PARENT_LINKS
end_define

begin_include
include|#
directive|include
file|"../libjsmn/jsmn.c"
end_include

begin_comment
comment|/* =====================================================================  * JSON parsing stuff  */
end_comment

begin_define
define|#
directive|define
name|JSMN_MAXTOK
value|350
end_define

begin_define
define|#
directive|define
name|INVALID_TOKEN
value|(-1)
end_define

begin_typedef
typedef|typedef
struct|struct
name|json_ctx
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|ntok
decl_stmt|;
name|jsmntok_t
name|tok
index|[
name|JSMN_MAXTOK
index|]
decl_stmt|;
block|}
name|json_ctx
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|tok_ref
typedef|;
end_typedef

begin_comment
comment|/* Not all targets have 'long long', and not all of them have 'strtoll'.  * Sigh. We roll our own integer number parser.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LONG_LONG
end_ifdef

begin_typedef
typedef|typedef
name|signed
name|long
name|long
name|int
name|json_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|int
name|json_uint
typedef|;
end_typedef

begin_define
define|#
directive|define
name|JSON_INT_MAX
value|LLONG_MAX
end_define

begin_define
define|#
directive|define
name|JSON_INT_MIN
value|LLONG_MIN
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|signed
name|long
name|int
name|json_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|int
name|json_uint
typedef|;
end_typedef

begin_define
define|#
directive|define
name|JSON_INT_MAX
value|LONG_MAX
end_define

begin_define
define|#
directive|define
name|JSON_INT_MIN
value|LONG_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* =====================================================================  * header stuff we need  */
end_comment

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_POLL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYS_SELECT_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|need poll() or select()
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"timespecops.h"
end_include

begin_comment
comment|/* get operation modes from mode word.   * + SERIAL (default) evaluates only serial time information ('STI') as  *   provided by TPV and TOFF records. TPV evaluation suffers from a  *   bigger jitter than TOFF, sine it does not contain the receive time  *   from GPSD and therefore the receive time of NTPD must be  *   substituted for it. The network latency makes this a second rate  *   guess.  *  *   If TOFF records are detected in the data stream, the timing  *   information is gleaned from this record -- it contains the local  *   receive time stamp from GPSD and therefore eliminates the  *   transmission latency between GPSD and NTPD. The timing information  *   from TPV is ignored once a TOFF is detected or expected.  *  *   TPV is still used to check the fix status, so the driver can stop  *   feeding samples when GPSD says that the time information is  *   effectively unreliable.  *  * + STRICT means only feed clock samples when a valid STI/PPS pair is  *   available. Combines the reference time from STI with the pulse time  *   from PPS. Masks the serial data jitter as long PPS is available,  *   but can rapidly deteriorate once PPS drops out.  *  * + AUTO tries to use STI/PPS pairs if available for some time, and if  *   this fails for too long switches back to STI only until the PPS  *   signal becomes available again. See the HTML docs for this driver  *   about the gotchas and why this is not the default.  */
end_comment

begin_define
define|#
directive|define
name|MODE_OP_MASK
value|0x03
end_define

begin_define
define|#
directive|define
name|MODE_OP_STI
value|0
end_define

begin_define
define|#
directive|define
name|MODE_OP_STRICT
value|1
end_define

begin_define
define|#
directive|define
name|MODE_OP_AUTO
value|2
end_define

begin_define
define|#
directive|define
name|MODE_OP_MAXVAL
value|2
end_define

begin_define
define|#
directive|define
name|MODE_OP_MODE
parameter_list|(
name|x
parameter_list|)
value|((x)& MODE_OP_MASK)
end_define

begin_define
define|#
directive|define
name|PRECISION
value|(-9)
end_define

begin_comment
comment|/* precision assumed (about 2 ms) */
end_comment

begin_define
define|#
directive|define
name|PPS_PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (about 1 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"GPSD"
end_define

begin_comment
comment|/* reference id */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"GPSD JSON client clock"
end_define

begin_comment
comment|/* who we are */
end_comment

begin_define
define|#
directive|define
name|MAX_PDU_LEN
value|1600
end_define

begin_define
define|#
directive|define
name|TICKOVER_LOW
value|10
end_define

begin_define
define|#
directive|define
name|TICKOVER_HIGH
value|120
end_define

begin_define
define|#
directive|define
name|LOGTHROTTLE
value|3600
end_define

begin_comment
comment|/* Primary channel PPS avilability dance:  * Every good PPS sample gets us a credit of PPS_INCCOUNT points, every  * bad/missing PPS sample costs us a debit of PPS_DECCOUNT points. When  * the account reaches the upper limit we change to a mode where only  * PPS-augmented samples are fed to the core; when the account drops to  * zero we switch to a mode where TPV-only timestamps are fed to the  * core.  * This reduces the chance of rapid alternation between raw and  * PPS-augmented time stamps.  */
end_comment

begin_define
define|#
directive|define
name|PPS_MAXCOUNT
value|60
end_define

begin_comment
comment|/* upper limit of account  */
end_comment

begin_define
define|#
directive|define
name|PPS_INCCOUNT
value|3
end_define

begin_comment
comment|/* credit for good samples */
end_comment

begin_define
define|#
directive|define
name|PPS_DECCOUNT
value|1
end_define

begin_comment
comment|/* debit for bad samples   */
end_comment

begin_comment
comment|/* The secondary (PPS) channel uses a different strategy to avoid old  * PPS samples in the median filter.  */
end_comment

begin_define
define|#
directive|define
name|PPS2_MAXCOUNT
value|10
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|BOOL
end_ifndef

begin_define
define|#
directive|define
name|BOOL
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PROTO_VERSION
parameter_list|(
name|hi
parameter_list|,
name|lo
parameter_list|)
define|\
value|((((uint32_t)(hi)<< 16)& 0xFFFF0000u) | \ 	     ((uint32_t)(lo)& 0x0FFFFu))
end_define

begin_comment
comment|/* some local typedefs: The NTPD formatting style cries for short type  * names, and we provide them locally. Note:the suffix '_t' is reserved  * for the standard; I use a capital T instead.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|peer
name|peerT
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|refclockproc
name|clockprocT
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|addrinfo
name|addrinfoT
typedef|;
end_typedef

begin_comment
comment|/* =====================================================================  * We use the same device name scheme as does the NMEA driver; since  * GPSD supports the same links, we can select devices by a fixed name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s_dev_stem
init|=
literal|"/dev/gps"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* =====================================================================  * forward declarations for transfer vector and the vector itself  */
end_comment

begin_function_decl
specifier|static
name|void
name|gpsd_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gpsd_start
parameter_list|(
name|int
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_shutdown
parameter_list|(
name|int
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_poll
parameter_list|(
name|int
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_control
parameter_list|(
name|int
parameter_list|,
specifier|const
name|struct
name|refclockstat
modifier|*
parameter_list|,
name|struct
name|refclockstat
modifier|*
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_timer
parameter_list|(
name|int
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|myasprintf
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|NTP_PRINTF
parameter_list|(
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|enter_opmode
parameter_list|(
name|peerT
modifier|*
name|peer
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|leave_opmode
parameter_list|(
name|peerT
modifier|*
name|peer
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|refclock
name|refclock_gpsdjson
init|=
block|{
name|gpsd_start
block|,
comment|/* start up driver */
name|gpsd_shutdown
block|,
comment|/* shut down driver */
name|gpsd_poll
block|,
comment|/* transmit poll message */
name|gpsd_control
block|,
comment|/* fudge control */
name|gpsd_init
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* buginfo */
name|gpsd_timer
comment|/* called once per second */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* =====================================================================  * our local clock unit and data  */
end_comment

begin_struct_decl
struct_decl|struct
name|gpsd_unit
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|gpsd_unit
name|gpsd_unitT
typedef|;
end_typedef

begin_struct
struct|struct
name|gpsd_unit
block|{
comment|/* links for sharing between master/slave units */
name|gpsd_unitT
modifier|*
name|next_unit
decl_stmt|;
name|size_t
name|refcount
decl_stmt|;
comment|/* data for the secondary PPS channel */
name|peerT
modifier|*
name|pps_peer
decl_stmt|;
comment|/* unit and operation modes */
name|int
name|unit
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|char
modifier|*
name|logname
decl_stmt|;
comment|/* cached name for log/print */
name|char
modifier|*
name|device
decl_stmt|;
comment|/* device name of unit */
comment|/* current line protocol version */
name|uint32_t
name|proto_version
decl_stmt|;
comment|/* PPS time stamps primary + secondary channel */
name|l_fp
name|pps_local
decl_stmt|;
comment|/* when we received the PPS message */
name|l_fp
name|pps_stamp
decl_stmt|;
comment|/* related reference time */
name|l_fp
name|pps_recvt
decl_stmt|;
comment|/* when GPSD detected the pulse */
name|l_fp
name|pps_stamp2
decl_stmt|;
comment|/* related reference time (secondary) */
name|l_fp
name|pps_recvt2
decl_stmt|;
comment|/* when GPSD detected the pulse (secondary)*/
name|int
name|ppscount
decl_stmt|;
comment|/* PPS counter (primary unit) */
name|int
name|ppscount2
decl_stmt|;
comment|/* PPS counter (secondary unit) */
comment|/* TPV or TOFF serial time information */
name|l_fp
name|sti_local
decl_stmt|;
comment|/* when we received the TPV/TOFF message */
name|l_fp
name|sti_stamp
decl_stmt|;
comment|/* effective GPS time stamp */
name|l_fp
name|sti_recvt
decl_stmt|;
comment|/* when GPSD got the fix */
comment|/* precision estimates */
name|int16_t
name|sti_prec
decl_stmt|;
comment|/* serial precision based on EPT */
name|int16_t
name|pps_prec
decl_stmt|;
comment|/* PPS precision from GPSD or above */
comment|/* fudge values for correction, mirrored as 'l_fp' */
name|l_fp
name|pps_fudge
decl_stmt|;
comment|/* PPS fudge primary channel */
name|l_fp
name|pps_fudge2
decl_stmt|;
comment|/* PPS fudge secondary channel */
name|l_fp
name|sti_fudge
decl_stmt|;
comment|/* TPV/TOFF serial data fudge */
comment|/* Flags to indicate available data */
name|int
name|fl_nosync
range|:
literal|1
decl_stmt|;
comment|/* GPSD signals bad quality */
name|int
name|fl_sti
range|:
literal|1
decl_stmt|;
comment|/* valid TPV/TOFF seen (have time) */
name|int
name|fl_pps
range|:
literal|1
decl_stmt|;
comment|/* valid pulse seen */
name|int
name|fl_pps2
range|:
literal|1
decl_stmt|;
comment|/* valid pulse seen for PPS channel */
name|int
name|fl_rawsti
range|:
literal|1
decl_stmt|;
comment|/* permit raw TPV/TOFF time stamps */
name|int
name|fl_vers
range|:
literal|1
decl_stmt|;
comment|/* have protocol version */
name|int
name|fl_watch
range|:
literal|1
decl_stmt|;
comment|/* watch reply seen */
comment|/* protocol flags */
name|int
name|pf_nsec
range|:
literal|1
decl_stmt|;
comment|/* have nanosec PPS info */
name|int
name|pf_toff
range|:
literal|1
decl_stmt|;
comment|/* have TOFF record for timing */
comment|/* admin stuff for sockets and device selection */
name|int
name|fdt
decl_stmt|;
comment|/* current connecting socket */
name|addrinfoT
modifier|*
name|addr
decl_stmt|;
comment|/* next address to try */
name|u_int
name|tickover
decl_stmt|;
comment|/* timeout countdown */
name|u_int
name|tickpres
decl_stmt|;
comment|/* timeout preset */
comment|/* tallies for the various events */
name|u_int
name|tc_recv
decl_stmt|;
comment|/* received known records */
name|u_int
name|tc_breply
decl_stmt|;
comment|/* bad replies / parsing errors */
name|u_int
name|tc_nosync
decl_stmt|;
comment|/* TPV / sample cycles w/o fix */
name|u_int
name|tc_sti_recv
decl_stmt|;
comment|/* received serial time info records */
name|u_int
name|tc_sti_used
decl_stmt|;
comment|/* used        --^-- */
name|u_int
name|tc_pps_recv
decl_stmt|;
comment|/* received PPS timing info records */
name|u_int
name|tc_pps_used
decl_stmt|;
comment|/* used        --^-- */
comment|/* log bloat throttle */
name|u_int
name|logthrottle
decl_stmt|;
comment|/* seconds to next log slot */
comment|/* The parse context for the current record */
name|json_ctx
name|json_parse
decl_stmt|;
comment|/* record assemby buffer and saved length */
name|int
name|buflen
decl_stmt|;
name|char
name|buffer
index|[
name|MAX_PDU_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* =====================================================================  * static local helpers forward decls  */
end_comment

begin_function_decl
specifier|static
name|void
name|gpsd_init_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_test_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_stop_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_parse
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|convert_ascii_time
parameter_list|(
name|l_fp
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|gps_time
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_ltc
parameter_list|(
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|tc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|syslogok
parameter_list|(
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|log_data
parameter_list|(
name|peerT
modifier|*
name|peer
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int16_t
name|clamped_precision
parameter_list|(
name|int
name|rawprec
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* =====================================================================  * local / static stuff  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|s_req_version
init|=
literal|"?VERSION;\r\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We keep a static list of network addresses for 'localhost:gpsd' or a  * fallback alias of it, and we try to connect to them in round-robin  * fashion. The service lookup is done during the driver init  * function to minmise the impact of 'getaddrinfo()'.  *  * Alas, the init function is called even if there are no clocks  * configured for this driver. So it makes sense to defer the logging of  * any errors or other notifications until the first clock unit is  * started -- otherwise there might be syslog entries from a driver that  * is not used at all.  */
end_comment

begin_decl_stmt
specifier|static
name|addrinfoT
modifier|*
name|s_gpsd_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gpsd_unitT
modifier|*
name|s_clock_units
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of service/socket names we want to resolve against */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|s_svctab
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|"localhost"
block|,
literal|"gpsd"
block|}
block|,
block|{
literal|"localhost"
block|,
literal|"2947"
block|}
block|,
block|{
literal|"127.0.0.1"
block|,
literal|"2947"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of address resolution errors and index of service entry that  * finally worked.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|s_svcerr
index|[
sizeof|sizeof
argument_list|(
name|s_svctab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|s_svctab
index|[
literal|0
index|]
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s_svcidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* =====================================================================  * log throttling  */
end_comment

begin_function
specifier|static
name|int
comment|/*BOOL*/
name|syslogok
parameter_list|(
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
block|{
name|int
name|res
init|=
operator|(
literal|0
operator|!=
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
operator|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|up
operator|->
name|logthrottle
operator|)
operator|||
operator|(
name|LOGTHROTTLE
operator|==
name|up
operator|->
name|logthrottle
operator|)
decl_stmt|;
if|if
condition|(
name|res
condition|)
name|up
operator|->
name|logthrottle
operator|=
name|LOGTHROTTLE
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * the clock functions  */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------  * Init: This currently just gets the socket address for the GPS daemon  */
end_comment

begin_function
specifier|static
name|void
name|gpsd_init
parameter_list|(
name|void
parameter_list|)
block|{
name|addrinfoT
name|hints
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|idx
decl_stmt|;
name|memset
argument_list|(
name|s_svcerr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s_svcerr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|s_svctab
index|[
name|idx
index|]
index|[
literal|0
index|]
operator|&&
operator|!
name|s_gpsd_addr
condition|;
name|idx
operator|++
control|)
block|{
name|rc
operator|=
name|getaddrinfo
argument_list|(
name|s_svctab
index|[
name|idx
index|]
index|[
literal|0
index|]
argument_list|,
name|s_svctab
index|[
name|idx
index|]
index|[
literal|1
index|]
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|s_gpsd_addr
argument_list|)
expr_stmt|;
name|s_svcerr
index|[
name|idx
index|]
operator|=
name|rc
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|rc
condition|)
break|break;
name|s_gpsd_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|s_svcidx
operator|=
name|idx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------  * Init Check: flush pending log messages and check if we can proceed  */
end_comment

begin_function
specifier|static
name|int
comment|/*BOOL*/
name|gpsd_init_check
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
comment|/* Check if there is something to log */
if|if
condition|(
name|s_svcidx
operator|==
literal|0
condition|)
return|return
operator|(
name|s_gpsd_addr
operator|!=
name|NULL
operator|)
return|;
comment|/* spool out the resolver errors */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|s_svcidx
condition|;
operator|++
name|idx
control|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"GPSD_JSON: failed to resolve '%s:%s', rc=%d (%s)"
argument_list|,
name|s_svctab
index|[
name|idx
index|]
index|[
literal|0
index|]
argument_list|,
name|s_svctab
index|[
name|idx
index|]
index|[
literal|1
index|]
argument_list|,
name|s_svcerr
index|[
name|idx
index|]
argument_list|,
name|gai_strerror
argument_list|(
name|s_svcerr
index|[
name|idx
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* check if it was fatal, or if we can proceed */
if|if
condition|(
name|s_gpsd_addr
operator|==
name|NULL
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
literal|"GPSD_JSON: failed to get socket address, giving up."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|!=
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"GPSD_JSON: using '%s:%s' instead of '%s:%s'"
argument_list|,
name|s_svctab
index|[
name|idx
index|]
index|[
literal|0
index|]
argument_list|,
name|s_svctab
index|[
name|idx
index|]
index|[
literal|1
index|]
argument_list|,
name|s_svctab
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|s_svctab
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* make sure this gets logged only once and tell if we can 	 * proceed or not 	 */
name|s_svcidx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|s_gpsd_addr
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------  * Start: allocate a unit pointer and set up the runtime data  */
end_comment

begin_function
specifier|static
name|int
name|gpsd_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|peerT
modifier|*
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
name|up
decl_stmt|;
name|gpsd_unitT
modifier|*
modifier|*
name|uscan
init|=
operator|&
name|s_clock_units
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* check if we can proceed at all or if init failed */
if|if
condition|(
operator|!
name|gpsd_init_check
argument_list|()
condition|)
return|return
name|FALSE
return|;
comment|/* search for matching unit */
while|while
condition|(
operator|(
name|up
operator|=
operator|*
name|uscan
operator|)
operator|!=
name|NULL
operator|&&
name|up
operator|->
name|unit
operator|!=
operator|(
name|unit
operator|&
literal|0x7F
operator|)
condition|)
name|uscan
operator|=
operator|&
name|up
operator|->
name|next_unit
expr_stmt|;
if|if
condition|(
name|up
operator|==
name|NULL
condition|)
block|{
comment|/* alloc unit, add to list and increment use count ASAP. */
name|up
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|uscan
operator|=
name|up
expr_stmt|;
operator|++
name|up
operator|->
name|refcount
expr_stmt|;
comment|/* initialize the unit structure */
name|up
operator|->
name|logname
operator|=
name|estrdup
argument_list|(
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|unit
operator|=
name|unit
operator|&
literal|0x7F
expr_stmt|;
name|up
operator|->
name|fdt
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|addr
operator|=
name|s_gpsd_addr
expr_stmt|;
name|up
operator|->
name|tickpres
operator|=
name|TICKOVER_LOW
expr_stmt|;
comment|/* Create the device name and check for a Character 		 * Device. It's assumed that GPSD was started with the 		 * same link, so the names match. (If this is not 		 * practicable, we will have to read the symlink, if 		 * any, so we can get the true device file.) 		 */
if|if
condition|(
operator|-
literal|1
operator|==
name|myasprintf
argument_list|(
operator|&
name|up
operator|->
name|device
argument_list|,
literal|"%s%u"
argument_list|,
name|s_dev_stem
argument_list|,
name|up
operator|->
name|unit
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: clock device name too long"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
goto|goto
name|dev_fail
goto|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|stat
argument_list|(
name|up
operator|->
name|device
argument_list|,
operator|&
name|sb
argument_list|)
operator|||
operator|!
name|S_ISCHR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: '%s' is not a character device"
argument_list|,
name|up
operator|->
name|logname
argument_list|,
name|up
operator|->
name|device
argument_list|)
expr_stmt|;
goto|goto
name|dev_fail
goto|;
block|}
block|}
else|else
block|{
comment|/* All set up, just increment use count. */
operator|++
name|up
operator|->
name|refcount
expr_stmt|;
block|}
comment|/* setup refclock processing */
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|gpsd_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|a_lastcode
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Initialize miscellaneous variables */
if|if
condition|(
name|unit
operator|>=
literal|128
condition|)
name|peer
operator|->
name|precision
operator|=
name|PPS_PRECISION
expr_stmt|;
else|else
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
comment|/* If the daemon name lookup failed, just give up now. */
if|if
condition|(
name|NULL
operator|==
name|up
operator|->
name|addr
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: no GPSD socket address, giving up"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
goto|goto
name|dev_fail
goto|;
block|}
name|LOGIF
argument_list|(
name|CLOCKINFO
argument_list|,
operator|(
name|LOG_NOTICE
operator|,
literal|"%s: startup, device is '%s'"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|up
operator|->
name|device
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|mode
operator|=
name|MODE_OP_MODE
argument_list|(
name|peer
operator|->
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|mode
operator|>
name|MODE_OP_MAXVAL
condition|)
name|up
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|128
condition|)
name|up
operator|->
name|pps_peer
operator|=
name|peer
expr_stmt|;
else|else
name|enter_opmode
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|mode
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|dev_fail
label|:
comment|/* On failure, remove all UNIT ressources and declare defeat. */
name|INSIST
argument_list|(
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|up
operator|->
name|refcount
condition|)
block|{
operator|*
name|uscan
operator|=
name|up
operator|->
name|next_unit
expr_stmt|;
name|free
argument_list|(
name|up
operator|->
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|peerT
modifier|*
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|gpsd_unitT
modifier|*
modifier|*
name|uscan
init|=
operator|&
name|s_clock_units
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* The unit pointer might have been removed already. */
if|if
condition|(
name|up
operator|==
name|NULL
condition|)
return|return;
comment|/* now check if we must close IO resources */
if|if
condition|(
name|peer
operator|!=
name|up
operator|->
name|pps_peer
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: closing clock, fd=%d\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|pp
operator|->
name|io
operator|.
name|fd
operator|)
argument_list|)
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|fdt
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|up
operator|->
name|fdt
argument_list|)
expr_stmt|;
block|}
comment|/* decrement use count and eventually remove this unit. */
if|if
condition|(
operator|!
operator|--
name|up
operator|->
name|refcount
condition|)
block|{
comment|/* unlink this unit */
while|while
condition|(
operator|*
name|uscan
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|*
name|uscan
operator|==
name|up
condition|)
operator|*
name|uscan
operator|=
name|up
operator|->
name|next_unit
expr_stmt|;
else|else
name|uscan
operator|=
operator|&
operator|(
operator|*
name|uscan
operator|)
operator|->
name|next_unit
expr_stmt|;
name|free
argument_list|(
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
operator|->
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
name|LOGIF
argument_list|(
name|CLOCKINFO
argument_list|,
operator|(
name|LOG_NOTICE
operator|,
literal|"%s: shutdown"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
comment|/* declare& init control structure ptrs */
name|peerT
modifier|*
specifier|const
name|peer
init|=
name|rbufp
operator|->
name|recv_peer
decl_stmt|;
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|psrc
decl_stmt|,
modifier|*
name|esrc
decl_stmt|;
name|char
modifier|*
name|pdst
decl_stmt|,
modifier|*
name|edst
decl_stmt|,
name|ch
decl_stmt|;
comment|/* log the data stream, if this is enabled */
name|log_data
argument_list|(
name|peer
argument_list|,
literal|"recv"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|rbufp
operator|->
name|recv_buffer
argument_list|,
operator|(
name|size_t
operator|)
name|rbufp
operator|->
name|recv_length
argument_list|)
expr_stmt|;
comment|/* Since we're getting a raw stream data, we must assemble lines 	 * in our receive buffer. We can't use neither 'refclock_gtraw' 	 * not 'refclock_gtlin' here...  We process chars until we reach 	 * an EoL (that is, line feed) but we truncate the message if it 	 * does not fit the buffer.  GPSD might truncate messages, too, 	 * so dealing with truncated buffers is necessary anyway. 	 */
name|psrc
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
name|esrc
operator|=
name|psrc
operator|+
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|pdst
operator|=
name|up
operator|->
name|buffer
operator|+
name|up
operator|->
name|buflen
expr_stmt|;
name|edst
operator|=
name|pdst
operator|+
sizeof|sizeof
argument_list|(
name|up
operator|->
name|buffer
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* for trailing NUL */
while|while
condition|(
name|psrc
operator|!=
name|esrc
condition|)
block|{
name|ch
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
comment|/* trim trailing whitespace& terminate buffer */
while|while
condition|(
name|pdst
operator|!=
name|up
operator|->
name|buffer
operator|&&
name|pdst
index|[
operator|-
literal|1
index|]
operator|<=
literal|' '
condition|)
operator|--
name|pdst
expr_stmt|;
operator|*
name|pdst
operator|=
literal|'\0'
expr_stmt|;
comment|/* process data and reset buffer */
name|up
operator|->
name|buflen
operator|=
name|pdst
operator|-
name|up
operator|->
name|buffer
expr_stmt|;
name|gpsd_parse
argument_list|(
name|peer
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|)
expr_stmt|;
name|pdst
operator|=
name|up
operator|->
name|buffer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pdst
operator|!=
name|edst
condition|)
block|{
comment|/* add next char, ignoring leading whitespace */
if|if
condition|(
name|ch
operator|>
literal|' '
operator|||
name|pdst
operator|!=
name|up
operator|->
name|buffer
condition|)
operator|*
name|pdst
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
name|up
operator|->
name|buflen
operator|=
name|pdst
operator|-
name|up
operator|->
name|buffer
expr_stmt|;
name|up
operator|->
name|tickover
operator|=
name|TICKOVER_LOW
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|poll_primary
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
block|{
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|!=
name|pp
operator|->
name|codeproc
condition|)
block|{
comment|/* all is well */
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not working properly, admit to it. If we have no 		 * connection to GPSD, declare the clock as faulty. If 		 * there were bad replies, this is handled as the major 		 * cause, and everything else is just a timeout. 		 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|!=
name|up
operator|->
name|tc_breply
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
else|else
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|mprintf_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
literal|"%u %u %u %u %u %u %u"
argument_list|,
name|up
operator|->
name|tc_recv
argument_list|,
name|up
operator|->
name|tc_breply
argument_list|,
name|up
operator|->
name|tc_nosync
argument_list|,
name|up
operator|->
name|tc_sti_recv
argument_list|,
name|up
operator|->
name|tc_sti_used
argument_list|,
name|up
operator|->
name|tc_pps_recv
argument_list|,
name|up
operator|->
name|tc_pps_used
argument_list|)
expr_stmt|;
comment|/* clear tallies for next round */
name|up
operator|->
name|tc_breply
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|tc_recv
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|tc_nosync
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|tc_sti_recv
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|tc_sti_used
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|tc_pps_recv
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|tc_pps_used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|poll_secondary
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
block|{
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|!=
name|pp
operator|->
name|codeproc
condition|)
block|{
comment|/* all is well */
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|precision
operator|=
name|PPS_PRECISION
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gpsd_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|peerT
modifier|*
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
operator|++
name|pp
operator|->
name|polls
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|up
operator|->
name|pps_peer
condition|)
name|poll_secondary
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
argument_list|)
expr_stmt|;
else|else
name|poll_primary
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_control
parameter_list|(
name|int
name|unit
parameter_list|,
specifier|const
name|struct
name|refclockstat
modifier|*
name|in_st
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out_st
parameter_list|,
name|peerT
modifier|*
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
if|if
condition|(
name|peer
operator|==
name|up
operator|->
name|pps_peer
condition|)
block|{
name|DTOLFP
argument_list|(
name|pp
operator|->
name|fudgetime1
argument_list|,
operator|&
name|up
operator|->
name|pps_fudge2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG1
operator|)
condition|)
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
block|}
else|else
block|{
comment|/* save preprocessed fudge times */
name|DTOLFP
argument_list|(
name|pp
operator|->
name|fudgetime1
argument_list|,
operator|&
name|up
operator|->
name|pps_fudge
argument_list|)
expr_stmt|;
name|DTOLFP
argument_list|(
name|pp
operator|->
name|fudgetime2
argument_list|,
operator|&
name|up
operator|->
name|sti_fudge
argument_list|)
expr_stmt|;
if|if
condition|(
name|MODE_OP_MODE
argument_list|(
name|up
operator|->
name|mode
operator|^
name|peer
operator|->
name|ttl
argument_list|)
condition|)
block|{
name|leave_opmode
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|mode
argument_list|)
expr_stmt|;
name|up
operator|->
name|mode
operator|=
name|MODE_OP_MODE
argument_list|(
name|peer
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|enter_opmode
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|timer_primary
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
comment|/* This is used for timeout handling. Nothing that needs 	 * sub-second precison happens here, so receive/connect/retry 	 * timeouts are simply handled by a count down, and then we 	 * decide what to do by the socket values. 	 * 	 * Note that the timer stays at zero here, unless some of the 	 * functions set it to another value. 	 */
if|if
condition|(
name|up
operator|->
name|logthrottle
condition|)
operator|--
name|up
operator|->
name|logthrottle
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|tickover
condition|)
operator|--
name|up
operator|->
name|tickover
expr_stmt|;
switch|switch
condition|(
name|up
operator|->
name|tickover
condition|)
block|{
case|case
literal|4
case|:
comment|/* If we are connected to GPSD, try to get a live signal 		 * by querying the version. Otherwise just check the 		 * socket to become ready. 		 */
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
block|{
name|size_t
name|rlen
init|=
name|strlen
argument_list|(
name|s_req_version
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: timer livecheck: '%s'\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|s_req_version
operator|)
argument_list|)
expr_stmt|;
name|log_data
argument_list|(
name|peer
argument_list|,
literal|"send"
argument_list|,
name|s_req_version
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|rc
operator|=
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|s_req_version
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|-
literal|1
operator|!=
name|up
operator|->
name|fdt
condition|)
block|{
name|gpsd_test_socket
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|gpsd_stop_socket
argument_list|(
name|peer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|-
literal|1
operator|!=
name|up
operator|->
name|fdt
condition|)
name|gpsd_test_socket
argument_list|(
name|peer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
operator|!=
name|s_gpsd_addr
condition|)
name|gpsd_init_socket
argument_list|(
name|peer
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|-
literal|1
operator|==
name|pp
operator|->
name|io
operator|.
name|fd
operator|&&
operator|-
literal|1
operator|!=
name|up
operator|->
name|fdt
condition|)
name|gpsd_test_socket
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|timer_secondary
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
block|{
comment|/* Reduce the count by one. Flush sample buffer and clear PPS 	 * flag when this happens. 	 */
name|up
operator|->
name|ppscount2
operator|=
name|max
argument_list|(
literal|0
argument_list|,
operator|(
name|up
operator|->
name|ppscount2
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|up
operator|->
name|ppscount2
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|!=
name|pp
operator|->
name|codeproc
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
name|pp
operator|->
name|coderecv
operator|=
name|pp
operator|->
name|codeproc
expr_stmt|;
block|}
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gpsd_timer
parameter_list|(
name|int
name|unit
parameter_list|,
name|peerT
modifier|*
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
if|if
condition|(
name|peer
operator|==
name|up
operator|->
name|pps_peer
condition|)
name|timer_secondary
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
argument_list|)
expr_stmt|;
else|else
name|timer_primary
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * handle opmode switches  */
end_comment

begin_function
specifier|static
name|void
name|enter_opmode
parameter_list|(
name|peerT
modifier|*
name|peer
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: enter operation mode %d\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|MODE_OP_MODE
argument_list|(
name|mode
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MODE_OP_MODE
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_OP_AUTO
condition|)
block|{
name|up
operator|->
name|fl_rawsti
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|ppscount
operator|=
name|PPS_MAXCOUNT
operator|/
literal|2
expr_stmt|;
block|}
name|up
operator|->
name|fl_pps
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_sti
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|leave_opmode
parameter_list|(
name|peerT
modifier|*
name|peer
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: leaving operation mode %d\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|MODE_OP_MODE
argument_list|(
name|mode
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MODE_OP_MODE
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_OP_AUTO
condition|)
block|{
name|up
operator|->
name|fl_rawsti
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|ppscount
operator|=
literal|0
expr_stmt|;
block|}
name|up
operator|->
name|fl_pps
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_sti
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * operation mode specific evaluation  */
end_comment

begin_function
specifier|static
name|void
name|add_clock_sample
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|l_fp
name|stamp
parameter_list|,
name|l_fp
name|recvt
parameter_list|)
block|{
name|pp
operator|->
name|lastref
operator|=
name|stamp
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|stamp
argument_list|,
name|recvt
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|eval_strict
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
block|{
if|if
condition|(
name|up
operator|->
name|fl_sti
operator|&&
name|up
operator|->
name|fl_pps
condition|)
block|{
comment|/* use TPV reference time + PPS receive time */
name|add_clock_sample
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
operator|->
name|sti_stamp
argument_list|,
name|up
operator|->
name|pps_recvt
argument_list|)
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|up
operator|->
name|pps_prec
expr_stmt|;
comment|/* both packets consumed now... */
name|up
operator|->
name|fl_pps
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_sti
operator|=
literal|0
expr_stmt|;
operator|++
name|up
operator|->
name|tc_sti_used
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* PPS processing for the secondary channel. GPSD provides us with full  * timing information, so there's no danger of PLL-locking to the wrong  * second. The belts and suspenders needed for the raw ATOM clock are  * unnecessary here.  */
end_comment

begin_function
specifier|static
name|void
name|eval_pps_secondary
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
block|{
if|if
condition|(
name|up
operator|->
name|fl_pps2
condition|)
block|{
comment|/* feed data */
name|add_clock_sample
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
operator|->
name|pps_stamp2
argument_list|,
name|up
operator|->
name|pps_recvt2
argument_list|)
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|up
operator|->
name|pps_prec
expr_stmt|;
comment|/* PPS peer flag logic */
name|up
operator|->
name|ppscount2
operator|=
name|min
argument_list|(
name|PPS2_MAXCOUNT
argument_list|,
operator|(
name|up
operator|->
name|ppscount2
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PPS2_MAXCOUNT
operator|==
name|up
operator|->
name|ppscount2
operator|)
operator|&&
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG1
operator|)
condition|)
name|peer
operator|->
name|flags
operator||=
name|FLAG_PPS
expr_stmt|;
comment|/* mark time stamp as burned... */
name|up
operator|->
name|fl_pps2
operator|=
literal|0
expr_stmt|;
operator|++
name|up
operator|->
name|tc_pps_used
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|eval_serial
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
block|{
if|if
condition|(
name|up
operator|->
name|fl_sti
condition|)
block|{
name|add_clock_sample
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
operator|->
name|sti_stamp
argument_list|,
name|up
operator|->
name|sti_recvt
argument_list|)
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|up
operator|->
name|sti_prec
expr_stmt|;
comment|/* mark time stamp as burned... */
name|up
operator|->
name|fl_sti
operator|=
literal|0
expr_stmt|;
operator|++
name|up
operator|->
name|tc_sti_used
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|eval_auto
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
block|{
comment|/* If there's no TPV available, stop working here... */
if|if
condition|(
operator|!
name|up
operator|->
name|fl_sti
condition|)
return|return;
comment|/* check how to handle STI+PPS: Can PPS be used to augment STI 	 * (or vice versae), do we drop the sample because there is a 	 * temporary missing PPS signal, or do we feed on STI time 	 * stamps alone? 	 * 	 * Do a counter/threshold dance to decide how to proceed. 	 */
if|if
condition|(
name|up
operator|->
name|fl_pps
condition|)
block|{
name|up
operator|->
name|ppscount
operator|=
name|min
argument_list|(
name|PPS_MAXCOUNT
argument_list|,
operator|(
name|up
operator|->
name|ppscount
operator|+
name|PPS_INCCOUNT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PPS_MAXCOUNT
operator|==
name|up
operator|->
name|ppscount
operator|)
operator|&&
name|up
operator|->
name|fl_rawsti
condition|)
block|{
name|up
operator|->
name|fl_rawsti
operator|=
literal|0
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: expect valid PPS from now"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|up
operator|->
name|ppscount
operator|=
name|max
argument_list|(
literal|0
argument_list|,
operator|(
name|up
operator|->
name|ppscount
operator|-
name|PPS_DECCOUNT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|==
name|up
operator|->
name|ppscount
operator|)
operator|&&
operator|!
name|up
operator|->
name|fl_rawsti
condition|)
block|{
name|up
operator|->
name|fl_rawsti
operator|=
operator|-
literal|1
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: use TPV alone from now"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now eventually feed the sample */
if|if
condition|(
name|up
operator|->
name|fl_rawsti
condition|)
name|eval_serial
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
argument_list|)
expr_stmt|;
else|else
name|eval_strict
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * JSON parsing stuff  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Parse a decimal integer with a possible sign. Works like 'strtoll()'  * or 'strtol()', but with a fixed base of 10 and without eating away  * leading whitespace. For the error codes, the handling of the end  * pointer and the return values see 'strtol()'.  */
end_comment

begin_function
specifier|static
name|json_int
name|strtojint
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
modifier|*
name|ep
parameter_list|)
block|{
name|json_uint
name|accu
decl_stmt|,
name|limit_lo
decl_stmt|,
name|limit_hi
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* bit 0: overflow; bit 1: sign */
specifier|const
name|char
modifier|*
name|hold
decl_stmt|;
comment|/* pointer union to circumvent a tricky/sticky const issue */
union|union
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
block|}
name|vep
union|;
comment|/* store initial value of 'cp' -- see 'strtol()' */
name|vep
operator|.
name|c
operator|=
name|cp
expr_stmt|;
comment|/* Eat away an optional sign and set the limits accordingly: The 	 * high limit is the maximum absolute value that can be returned, 	 * and the low limit is the biggest value that does not cause an 	 * overflow when multiplied with 10. Avoid negation overflows. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|cp
operator|+=
literal|1
expr_stmt|;
name|flags
operator|=
literal|2
expr_stmt|;
name|limit_hi
operator|=
operator|(
name|json_uint
operator|)
operator|-
operator|(
name|JSON_INT_MIN
operator|+
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|+=
operator|(
operator|*
name|cp
operator|==
literal|'+'
operator|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|limit_hi
operator|=
operator|(
name|json_uint
operator|)
name|JSON_INT_MAX
expr_stmt|;
block|}
name|limit_lo
operator|=
name|limit_hi
operator|/
literal|10
expr_stmt|;
comment|/* Now try to convert a sequence of digits. */
name|hold
operator|=
name|cp
expr_stmt|;
name|accu
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|cp
argument_list|)
condition|)
block|{
name|flags
operator||=
operator|(
name|accu
operator|>
name|limit_lo
operator|)
expr_stmt|;
name|accu
operator|=
name|accu
operator|*
literal|10
operator|+
operator|(
operator|*
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|flags
operator||=
operator|(
name|accu
operator|>
name|limit_hi
operator|)
expr_stmt|;
block|}
comment|/* Check for empty conversion (no digits seen). */
if|if
condition|(
name|hold
operator|!=
name|cp
condition|)
name|vep
operator|.
name|c
operator|=
name|cp
expr_stmt|;
else|else
name|errno
operator|=
name|EINVAL
expr_stmt|;
comment|/* accu is still zero */
comment|/* Check for range overflow */
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
name|accu
operator|=
name|limit_hi
expr_stmt|;
block|}
comment|/* If possible, store back the end-of-conversion pointer */
if|if
condition|(
name|ep
condition|)
operator|*
name|ep
operator|=
name|vep
operator|.
name|v
expr_stmt|;
comment|/* If negative, return the negated result if the accu is not 	 * zero. Avoid negation overflows. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
literal|2
operator|)
operator|&&
name|accu
condition|)
return|return
operator|-
call|(
name|json_int
call|)
argument_list|(
name|accu
operator|-
literal|1
argument_list|)
operator|-
literal|1
return|;
else|else
return|return
operator|(
name|json_int
operator|)
name|accu
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|tok_ref
name|json_token_skip
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|)
block|{
if|if
condition|(
name|tid
operator|>=
literal|0
operator|&&
operator|(
name|u_int
operator|)
name|tid
operator|<
name|ctx
operator|->
name|ntok
condition|)
block|{
name|int
name|len
init|=
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|size
decl_stmt|;
comment|/* For arrays and objects, the size is the number of 		 * ITEMS in the compound. Thats the number of objects in 		 * the array, and the number of key/value pairs for 		 * objects. In theory, the key must be a string, and we 		 * could simply skip one token before skipping the 		 * value, which can be anything. We're a bit paranoid 		 * and lazy at the same time: We simply double the 		 * number of tokens to skip and fall through into the 		 * array processing when encountering an object. 		 */
switch|switch
condition|(
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|type
condition|)
block|{
case|case
name|JSMN_OBJECT
case|:
name|len
operator|*=
literal|2
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|JSMN_ARRAY
case|:
for|for
control|(
operator|++
name|tid
init|;
name|len
condition|;
operator|--
name|len
control|)
name|tid
operator|=
name|json_token_skip
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|++
name|tid
expr_stmt|;
break|break;
block|}
comment|/* The next condition should never be true, but paranoia 		 * prevails... 		 */
if|if
condition|(
name|tid
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|tid
operator|>
name|ctx
operator|->
name|ntok
condition|)
name|tid
operator|=
name|ctx
operator|->
name|ntok
expr_stmt|;
block|}
return|return
name|tid
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|json_object_lookup
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|tid
operator|<
literal|0
operator|||
name|tid
operator|>=
name|ctx
operator|->
name|ntok
operator|||
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|type
operator|!=
name|JSMN_OBJECT
condition|)
return|return
name|INVALID_TOKEN
return|;
name|len
operator|=
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|size
expr_stmt|;
for|for
control|(
operator|++
name|tid
init|;
name|len
operator|&&
name|tid
operator|+
literal|1
operator|<
name|ctx
operator|->
name|ntok
condition|;
operator|--
name|len
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|type
operator|!=
name|JSMN_STRING
condition|)
block|{
comment|/* Blooper! */
name|tid
operator|=
name|json_token_skip
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* skip key */
name|tid
operator|=
name|json_token_skip
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* skip val */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|buf
operator|+
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|start
argument_list|)
condition|)
block|{
name|tid
operator|=
name|json_token_skip
argument_list|(
name|ctx
argument_list|,
name|tid
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* skip key+val */
block|}
elseif|else
if|if
condition|(
name|what
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|what
operator|==
name|ctx
operator|->
name|tok
index|[
name|tid
operator|+
literal|1
index|]
operator|.
name|type
condition|)
block|{
return|return
name|tid
operator|+
literal|1
return|;
block|}
else|else
block|{
break|break;
block|}
comment|/* if skipping ahead returned an error, bail out here. */
if|if
condition|(
name|tid
operator|<
literal|0
condition|)
break|break;
block|}
return|return
name|INVALID_TOKEN
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|json_object_lookup_primitive
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|tid
operator|=
name|json_object_lookup
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|,
name|JSMN_PRIMITIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_TOKEN
operator|!=
name|tid
condition|)
return|return
name|ctx
operator|->
name|buf
operator|+
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|start
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* look up a boolean value. This essentially returns a tribool:  * 0->false, 1->true, (-1)->error/undefined  */
end_comment

begin_function
specifier|static
name|int
name|json_object_lookup_bool
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|json_object_lookup_primitive
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
condition|?
operator|*
name|cp
else|:
literal|'\0'
condition|)
block|{
case|case
literal|'t'
case|:
return|return
literal|1
return|;
case|case
literal|'f'
case|:
return|return
literal|0
return|;
default|default :
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|json_object_lookup_string
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|tid
operator|=
name|json_object_lookup
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|,
name|JSMN_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_TOKEN
operator|!=
name|tid
condition|)
return|return
name|ctx
operator|->
name|buf
operator|+
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|start
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|json_object_lookup_string_default
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|)
block|{
name|tid
operator|=
name|json_object_lookup
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|,
name|JSMN_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_TOKEN
operator|!=
name|tid
condition|)
return|return
name|ctx
operator|->
name|buf
operator|+
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|start
return|;
return|return
name|def
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|json_int
name|json_object_lookup_int
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|json_int
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|cp
operator|=
name|json_object_lookup_primitive
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|cp
condition|)
block|{
name|ret
operator|=
name|strtojint
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|ep
operator|&&
literal|'\0'
operator|==
operator|*
name|ep
condition|)
return|return
name|ret
return|;
block|}
else|else
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|json_int
name|json_object_lookup_int_default
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|json_int
name|def
parameter_list|)
block|{
name|json_int
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|cp
operator|=
name|json_object_lookup_primitive
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|cp
condition|)
block|{
name|ret
operator|=
name|strtojint
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|ep
operator|&&
literal|'\0'
operator|==
operator|*
name|ep
condition|)
return|return
name|ret
return|;
block|}
return|return
name|def
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* currently unused */
end_comment

begin_endif
unit|static double json_object_lookup_float( 	const json_ctx * ctx, 	tok_ref          tid, 	const char     * key) { 	double       ret; 	const char * cp; 	char       * ep;  	cp = json_object_lookup_primitive(ctx, tid, key); 	if (NULL != cp) { 		ret = strtod(cp,&ep); 		if (cp != ep&& '\0' == *ep) 			return ret; 	} else { 		errno = EINVAL; 	} 	return 0.0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|double
name|json_object_lookup_float_default
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|double
name|def
parameter_list|)
block|{
name|double
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|cp
operator|=
name|json_object_lookup_primitive
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|cp
condition|)
block|{
name|ret
operator|=
name|strtod
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|ep
operator|&&
literal|'\0'
operator|==
operator|*
name|ep
condition|)
return|return
name|ret
return|;
block|}
return|return
name|def
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|BOOL
name|json_parse_record
parameter_list|(
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|jsmn_parser
name|jsm
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rc
decl_stmt|;
name|jsmn_init
argument_list|(
operator|&
name|jsm
argument_list|)
expr_stmt|;
name|rc
operator|=
name|jsmn_parse
argument_list|(
operator|&
name|jsm
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|ctx
operator|->
name|tok
argument_list|,
name|JSMN_MAXTOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<=
literal|0
condition|)
return|return
name|FALSE
return|;
name|ctx
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|ctx
operator|->
name|ntok
operator|=
name|rc
expr_stmt|;
if|if
condition|(
name|JSMN_OBJECT
operator|!=
name|ctx
operator|->
name|tok
index|[
literal|0
index|]
operator|.
name|type
condition|)
return|return
name|FALSE
return|;
comment|/* not object!?! */
comment|/* Make all tokens NUL terminated by overwriting the 	 * terminator symbol. Makes string compares and number parsing a 	 * lot easier! 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|ctx
operator|->
name|ntok
condition|;
operator|++
name|idx
control|)
if|if
condition|(
name|ctx
operator|->
name|tok
index|[
name|idx
index|]
operator|.
name|end
operator|>
name|ctx
operator|->
name|tok
index|[
name|idx
index|]
operator|.
name|start
condition|)
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|tok
index|[
name|idx
index|]
operator|.
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * static local helpers  */
end_comment

begin_function
specifier|static
name|BOOL
name|get_binary_time
parameter_list|(
name|l_fp
modifier|*
specifier|const
name|dest
parameter_list|,
name|json_ctx
modifier|*
specifier|const
name|jctx
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|time_name
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|frac_name
parameter_list|,
name|long
name|fscale
parameter_list|)
block|{
name|BOOL
name|retv
init|=
name|FALSE
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|json_object_lookup_int
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
name|time_name
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
operator|(
name|long
operator|)
name|json_object_lookup_int
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
name|frac_name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|errno
condition|)
block|{
name|ts
operator|.
name|tv_nsec
operator|*=
name|fscale
expr_stmt|;
operator|*
name|dest
operator|=
name|tspec_stamp_to_lfp
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|retv
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|retv
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Process a WATCH record  *  * Currently this is only used to recognise that the device is present  * and that we're listed subscribers.  */
end_comment

begin_function
specifier|static
name|void
name|process_watch
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|json_ctx
modifier|*
specifier|const
name|jctx
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|json_object_lookup_string
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"device"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|path
operator|||
name|strcmp
argument_list|(
name|path
argument_list|,
name|up
operator|->
name|device
argument_list|)
condition|)
return|return;
if|if
condition|(
name|json_object_lookup_bool
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"enable"
argument_list|)
operator|>
literal|0
operator|&&
name|json_object_lookup_bool
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"json"
argument_list|)
operator|>
literal|0
condition|)
name|up
operator|->
name|fl_watch
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|up
operator|->
name|fl_watch
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: process_watch, enabled=%d\n"
operator|,
name|up
operator|->
name|logname
operator|,
operator|(
name|up
operator|->
name|fl_watch
operator|&
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|process_version
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|json_ctx
modifier|*
specifier|const
name|jctx
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|release
decl_stmt|;
name|uint16_t
name|pvhi
decl_stmt|,
name|pvlo
decl_stmt|;
comment|/* get protocol version number */
name|revision
operator|=
name|json_object_lookup_string_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"rev"
argument_list|,
literal|"(unknown)"
argument_list|)
expr_stmt|;
name|release
operator|=
name|json_object_lookup_string_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"release"
argument_list|,
literal|"(unknown)"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|pvhi
operator|=
operator|(
name|uint16_t
operator|)
name|json_object_lookup_int
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"proto_major"
argument_list|)
expr_stmt|;
name|pvlo
operator|=
operator|(
name|uint16_t
operator|)
name|json_object_lookup_int
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"proto_minor"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|errno
condition|)
block|{
if|if
condition|(
operator|!
name|up
operator|->
name|fl_vers
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: GPSD revision=%s release=%s protocol=%u.%u"
argument_list|,
name|up
operator|->
name|logname
argument_list|,
name|revision
argument_list|,
name|release
argument_list|,
name|pvhi
argument_list|,
name|pvlo
argument_list|)
expr_stmt|;
name|up
operator|->
name|proto_version
operator|=
name|PROTO_VERSION
argument_list|(
name|pvhi
argument_list|,
name|pvlo
argument_list|)
expr_stmt|;
name|up
operator|->
name|fl_vers
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: could not evaluate version data"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* With the 3.9 GPSD protocol, '*_musec' vanished from the PPS 	 * record and was replace by '*_nsec'. 	 */
name|up
operator|->
name|pf_nsec
operator|=
operator|-
operator|(
name|up
operator|->
name|proto_version
operator|>=
name|PROTO_VERSION
argument_list|(
literal|3
argument_list|,
literal|9
argument_list|)
operator|)
expr_stmt|;
comment|/* With the 3.10 protocol we can get TOFF records for better 	 * timing information. 	 */
name|up
operator|->
name|pf_toff
operator|=
operator|-
operator|(
name|up
operator|->
name|proto_version
operator|>=
name|PROTO_VERSION
argument_list|(
literal|3
argument_list|,
literal|10
argument_list|)
operator|)
expr_stmt|;
comment|/* request watch for our GPS device if not yet watched. 	 * 	 * The version string is also sent as a life signal, if we have 	 * seen useable data. So if we're already watching the device, 	 * skip the request. 	 * 	 * Reuse the input buffer, which is no longer needed in the 	 * current cycle. Also assume that we can write the watch 	 * request in one sweep into the socket; since we do not do 	 * output otherwise, this should always work.  (Unless the 	 * TCP/IP window size gets lower than the length of the 	 * request. We handle that when it happens.) 	 */
if|if
condition|(
name|up
operator|->
name|fl_watch
condition|)
return|return;
comment|/* The logon string is actually the ?WATCH command of GPSD, 	 * using JSON data and selecting the GPS device name we created 	 * from our unit number. We have an old a newer version that 	 * request PPS (and TOFF) transmission. 	 */
name|snprintf
argument_list|(
name|up
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|buffer
argument_list|)
argument_list|,
literal|"?WATCH={\"device\":\"%s\",\"enable\":true,\"json\":true%s};\r\n"
argument_list|,
name|up
operator|->
name|device
argument_list|,
operator|(
name|up
operator|->
name|pf_toff
condition|?
literal|",\"pps\":true"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|up
operator|->
name|buffer
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|log_data
argument_list|(
name|peer
argument_list|,
literal|"send"
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
operator|)
condition|)
block|{
comment|/* Note: if the server fails to read our request, the 		 * resulting data timeout will take care of the 		 * connection! 		 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: failed to write watch request (%m)"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|process_tpv
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|json_ctx
modifier|*
specifier|const
name|jctx
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|gps_time
decl_stmt|;
name|int
name|gps_mode
decl_stmt|;
name|double
name|ept
decl_stmt|;
name|int
name|xlog2
decl_stmt|;
name|gps_mode
operator|=
operator|(
name|int
operator|)
name|json_object_lookup_int_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"mode"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gps_time
operator|=
name|json_object_lookup_string
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"time"
argument_list|)
expr_stmt|;
comment|/* accept time stamps only in 2d or 3d fix */
if|if
condition|(
name|gps_mode
operator|<
literal|2
operator|||
name|NULL
operator|==
name|gps_time
condition|)
block|{
comment|/* receiver has no fix; tell about and avoid stale data */
if|if
condition|(
operator|!
name|up
operator|->
name|pf_toff
condition|)
operator|++
name|up
operator|->
name|tc_sti_recv
expr_stmt|;
operator|++
name|up
operator|->
name|tc_nosync
expr_stmt|;
name|up
operator|->
name|fl_sti
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_pps
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_nosync
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|fl_nosync
operator|=
literal|0
expr_stmt|;
comment|/* convert clock and set resulting ref time, but only if the 	 * TOFF sentence is *not* available 	 */
if|if
condition|(
operator|!
name|up
operator|->
name|pf_toff
condition|)
block|{
operator|++
name|up
operator|->
name|tc_sti_recv
expr_stmt|;
comment|/* save last time code to clock data */
name|save_ltc
argument_list|(
name|pp
argument_list|,
name|gps_time
argument_list|)
expr_stmt|;
comment|/* now parse the time string */
if|if
condition|(
name|convert_ascii_time
argument_list|(
operator|&
name|up
operator|->
name|sti_stamp
argument_list|,
name|gps_time
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: process_tpv, stamp='%s',"
literal|" recvt='%s' mode=%u\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|sti_stamp
argument_list|)
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|sti_recvt
argument_list|)
operator|,
name|gps_mode
operator|)
argument_list|)
expr_stmt|;
comment|/* have to use local receive time as substitute 			 * for the real receive time: TPV does not tell 			 * us. 			 */
name|up
operator|->
name|sti_local
operator|=
operator|*
name|rtime
expr_stmt|;
name|up
operator|->
name|sti_recvt
operator|=
operator|*
name|rtime
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|sti_recvt
argument_list|,
operator|&
name|up
operator|->
name|sti_fudge
argument_list|)
expr_stmt|;
name|up
operator|->
name|fl_sti
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|++
name|up
operator|->
name|tc_breply
expr_stmt|;
name|up
operator|->
name|fl_sti
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Set the precision from the GPSD data 	 * Use the ETP field for an estimation of the precision of the 	 * serial data. If ETP is not available, use the default serial 	 * data presion instead. (Note: The PPS branch has a different 	 * precision estimation, since it gets the proper value directly 	 * from GPSD!) 	 */
name|ept
operator|=
name|json_object_lookup_float_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"ept"
argument_list|,
literal|2.0e-3
argument_list|)
expr_stmt|;
name|ept
operator|=
name|frexp
argument_list|(
name|fabs
argument_list|(
name|ept
argument_list|)
operator|*
literal|0.70710678
argument_list|,
operator|&
name|xlog2
argument_list|)
expr_stmt|;
comment|/* ~ sqrt(0.5) */
if|if
condition|(
name|ept
operator|<
literal|0.25
condition|)
name|xlog2
operator|=
name|INT_MIN
expr_stmt|;
if|if
condition|(
name|ept
operator|>
literal|2.0
condition|)
name|xlog2
operator|=
name|INT_MAX
expr_stmt|;
name|up
operator|->
name|sti_prec
operator|=
name|clamped_precision
argument_list|(
name|xlog2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|process_pps
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|json_ctx
modifier|*
specifier|const
name|jctx
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|int
name|xlog2
decl_stmt|;
operator|++
name|up
operator|->
name|tc_pps_recv
expr_stmt|;
comment|/* Bail out if there's indication that time sync is bad or 	 * if we're explicitely requested to ignore PPS data. 	 */
if|if
condition|(
name|up
operator|->
name|fl_nosync
condition|)
return|return;
name|up
operator|->
name|pps_local
operator|=
operator|*
name|rtime
expr_stmt|;
comment|/* Now grab the time values. 'clock_*' is the event time of the 	 * pulse measured on the local system clock; 'real_*' is the GPS 	 * reference time GPSD associated with the pulse. 	 */
if|if
condition|(
name|up
operator|->
name|pf_nsec
condition|)
block|{
if|if
condition|(
operator|!
name|get_binary_time
argument_list|(
operator|&
name|up
operator|->
name|pps_recvt2
argument_list|,
name|jctx
argument_list|,
literal|"clock_sec"
argument_list|,
literal|"clock_nsec"
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|get_binary_time
argument_list|(
operator|&
name|up
operator|->
name|pps_stamp2
argument_list|,
name|jctx
argument_list|,
literal|"real_sec"
argument_list|,
literal|"real_nsec"
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|get_binary_time
argument_list|(
operator|&
name|up
operator|->
name|pps_recvt2
argument_list|,
name|jctx
argument_list|,
literal|"clock_sec"
argument_list|,
literal|"clock_musec"
argument_list|,
literal|1000
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|get_binary_time
argument_list|(
operator|&
name|up
operator|->
name|pps_stamp2
argument_list|,
name|jctx
argument_list|,
literal|"real_sec"
argument_list|,
literal|"real_musec"
argument_list|,
literal|1000
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* Try to read the precision field from the PPS record. If it's 	 * not there, take the precision from the serial data. 	 */
name|xlog2
operator|=
name|json_object_lookup_int_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"precision"
argument_list|,
name|up
operator|->
name|sti_prec
argument_list|)
expr_stmt|;
name|up
operator|->
name|pps_prec
operator|=
name|clamped_precision
argument_list|(
name|xlog2
argument_list|)
expr_stmt|;
comment|/* Get fudged receive times for primary& secondary unit */
name|up
operator|->
name|pps_recvt
operator|=
name|up
operator|->
name|pps_recvt2
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|pps_recvt
argument_list|,
operator|&
name|up
operator|->
name|pps_fudge
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|pps_recvt2
argument_list|,
operator|&
name|up
operator|->
name|pps_fudge2
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|pps_recvt
expr_stmt|;
comment|/* Map to nearest full second as reference time stamp for the 	 * primary channel. Sanity checks are done in evaluation step. 	 */
name|up
operator|->
name|pps_stamp
operator|=
name|up
operator|->
name|pps_recvt
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|up
operator|->
name|pps_stamp
argument_list|,
literal|0x80000000u
argument_list|)
expr_stmt|;
name|up
operator|->
name|pps_stamp
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|up
operator|->
name|pps_peer
condition|)
name|save_ltc
argument_list|(
name|up
operator|->
name|pps_peer
operator|->
name|procptr
argument_list|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|pps_stamp2
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: PPS record processed,"
literal|" stamp='%s', recvt='%s'\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|pps_stamp2
argument_list|)
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|pps_recvt2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|fl_pps
operator|=
operator|(
literal|0
operator|!=
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|fl_pps2
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
name|fail
label|:
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: PPS record processing FAILED\n"
operator|,
name|up
operator|->
name|logname
operator|)
argument_list|)
expr_stmt|;
operator|++
name|up
operator|->
name|tc_breply
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|process_toff
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|json_ctx
modifier|*
specifier|const
name|jctx
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
operator|++
name|up
operator|->
name|tc_sti_recv
expr_stmt|;
comment|/* remember this! */
name|up
operator|->
name|pf_toff
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* bail out if there's indication that time sync is bad */
if|if
condition|(
name|up
operator|->
name|fl_nosync
condition|)
return|return;
if|if
condition|(
operator|!
name|get_binary_time
argument_list|(
operator|&
name|up
operator|->
name|sti_recvt
argument_list|,
name|jctx
argument_list|,
literal|"clock_sec"
argument_list|,
literal|"clock_nsec"
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|get_binary_time
argument_list|(
operator|&
name|up
operator|->
name|sti_stamp
argument_list|,
name|jctx
argument_list|,
literal|"real_sec"
argument_list|,
literal|"real_nsec"
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|sti_recvt
argument_list|,
operator|&
name|up
operator|->
name|sti_fudge
argument_list|)
expr_stmt|;
name|up
operator|->
name|sti_local
operator|=
operator|*
name|rtime
expr_stmt|;
name|up
operator|->
name|fl_sti
operator|=
operator|-
literal|1
expr_stmt|;
name|save_ltc
argument_list|(
name|pp
argument_list|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|sti_stamp
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: TOFF record processed,"
literal|" stamp='%s', recvt='%s'\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|sti_stamp
argument_list|)
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|sti_recvt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: TOFF record processing FAILED\n"
operator|,
name|up
operator|->
name|logname
operator|)
argument_list|)
expr_stmt|;
operator|++
name|up
operator|->
name|tc_breply
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_parse
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|clsid
decl_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: gpsd_parse: time %s '%.*s'\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|ulfptoa
argument_list|(
name|rtime
argument_list|,
literal|6
argument_list|)
operator|,
name|up
operator|->
name|buflen
operator|,
name|up
operator|->
name|buffer
operator|)
argument_list|)
expr_stmt|;
comment|/* See if we can grab anything potentially useful. JSMN does not 	 * need a trailing NUL, but it needs the number of bytes to 	 * process. */
if|if
condition|(
operator|!
name|json_parse_record
argument_list|(
operator|&
name|up
operator|->
name|json_parse
argument_list|,
name|up
operator|->
name|buffer
argument_list|,
name|up
operator|->
name|buflen
argument_list|)
condition|)
block|{
operator|++
name|up
operator|->
name|tc_breply
expr_stmt|;
return|return;
block|}
comment|/* Now dispatch over the objects we know */
name|clsid
operator|=
name|json_object_lookup_string
argument_list|(
operator|&
name|up
operator|->
name|json_parse
argument_list|,
literal|0
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|clsid
condition|)
block|{
operator|++
name|up
operator|->
name|tc_breply
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"TPV"
argument_list|,
name|clsid
argument_list|)
condition|)
name|process_tpv
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|json_parse
argument_list|,
name|rtime
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"PPS"
argument_list|,
name|clsid
argument_list|)
condition|)
name|process_pps
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|json_parse
argument_list|,
name|rtime
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"TOFF"
argument_list|,
name|clsid
argument_list|)
condition|)
name|process_toff
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|json_parse
argument_list|,
name|rtime
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"VERSION"
argument_list|,
name|clsid
argument_list|)
condition|)
name|process_version
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|json_parse
argument_list|,
name|rtime
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"WATCH"
argument_list|,
name|clsid
argument_list|)
condition|)
name|process_watch
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|json_parse
argument_list|,
name|rtime
argument_list|)
expr_stmt|;
else|else
return|return;
comment|/* nothing we know about... */
operator|++
name|up
operator|->
name|tc_recv
expr_stmt|;
comment|/* if possible, feed the PPS side channel */
if|if
condition|(
name|up
operator|->
name|pps_peer
condition|)
name|eval_pps_secondary
argument_list|(
name|up
operator|->
name|pps_peer
argument_list|,
name|up
operator|->
name|pps_peer
operator|->
name|procptr
argument_list|,
name|up
argument_list|)
expr_stmt|;
comment|/* check PPS vs. STI receive times: 	 * If STI is before PPS, then clearly the STI is too old. If PPS 	 * is before STI by more than one second, then PPS is too old. 	 * Weed out stale time stamps& flags. 	 */
if|if
condition|(
name|up
operator|->
name|fl_pps
operator|&&
name|up
operator|->
name|fl_sti
condition|)
block|{
name|l_fp
name|diff
decl_stmt|;
name|diff
operator|=
name|up
operator|->
name|sti_local
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|up
operator|->
name|pps_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|.
name|l_i
operator|>
literal|0
condition|)
name|up
operator|->
name|fl_pps
operator|=
literal|0
expr_stmt|;
comment|/* pps too old */
elseif|else
if|if
condition|(
name|diff
operator|.
name|l_i
operator|<
literal|0
condition|)
name|up
operator|->
name|fl_sti
operator|=
literal|0
expr_stmt|;
comment|/* serial data too old */
block|}
comment|/* dispatch to the mode-dependent processing functions */
switch|switch
condition|(
name|up
operator|->
name|mode
condition|)
block|{
default|default:
case|case
name|MODE_OP_STI
case|:
name|eval_serial
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_OP_STRICT
case|:
name|eval_strict
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_OP_AUTO
case|:
name|eval_auto
argument_list|(
name|peer
argument_list|,
name|pp
argument_list|,
name|up
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_stop_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: closing socket to GPSD, fd=%d"
argument_list|,
name|up
operator|->
name|logname
argument_list|,
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: closing socket to GPSD, fd=%d\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|pp
operator|->
name|io
operator|.
name|fd
operator|)
argument_list|)
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|up
operator|->
name|tickover
operator|=
name|up
operator|->
name|tickpres
expr_stmt|;
name|up
operator|->
name|tickpres
operator|=
name|min
argument_list|(
name|up
operator|->
name|tickpres
operator|+
literal|5
argument_list|,
name|TICKOVER_HIGH
argument_list|)
expr_stmt|;
name|up
operator|->
name|fl_vers
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_sti
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_pps
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_watch
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_init_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|addrinfoT
modifier|*
name|ai
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|ov
decl_stmt|;
comment|/* draw next address to try */
if|if
condition|(
name|NULL
operator|==
name|up
operator|->
name|addr
condition|)
name|up
operator|->
name|addr
operator|=
name|s_gpsd_addr
expr_stmt|;
name|ai
operator|=
name|up
operator|->
name|addr
expr_stmt|;
name|up
operator|->
name|addr
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
comment|/* try to create a matching socket */
name|up
operator|->
name|fdt
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|up
operator|->
name|fdt
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: cannot create GPSD socket: %m"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
comment|/* Make sure the socket is non-blocking. Connect/reconnect and 	 * IO happen in an event-driven environment, and synchronous 	 * operations wreak havoc on that. 	 */
name|rc
operator|=
name|fcntl
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: cannot set GPSD socket to non-blocking: %m"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
comment|/* Disable nagling. The way both GPSD and NTPD handle the 	 * protocol makes it record-oriented, and in most cases 	 * complete records (JSON serialised objects) will be sent in 	 * one sweep. Nagling gives not much advantage but adds another 	 * delay, which can worsen the situation for some packets. 	 */
name|ov
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|setsockopt
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_NODELAY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ov
argument_list|,
sizeof|sizeof
argument_list|(
name|ov
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: cannot disable TCP nagle: %m"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
block|}
comment|/* Start a non-blocking connect. There might be a synchronous 	 * connection result we have to handle. 	 */
name|rc
operator|=
name|connect
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINPROGRESS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: async connect pending, fd=%d\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|up
operator|->
name|fdt
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: cannot connect GPSD socket: %m"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
comment|/* We had a successful synchronous connect, so we add the 	 * refclock processing ASAP. We still have to wait for the 	 * version string and apply the watch command later on, but we 	 * might as well get the show on the road now. 	 */
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: new socket connection, fd=%d\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|up
operator|->
name|fdt
operator|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|up
operator|->
name|fdt
expr_stmt|;
name|up
operator|->
name|fdt
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: failed to register with I/O engine"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
return|return;
name|no_socket
label|:
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|close
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|up
operator|->
name|fdt
condition|)
name|close
argument_list|(
name|up
operator|->
name|fdt
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|fdt
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|tickover
operator|=
name|up
operator|->
name|tickpres
expr_stmt|;
name|up
operator|->
name|tickpres
operator|=
name|min
argument_list|(
name|up
operator|->
name|tickpres
operator|+
literal|5
argument_list|,
name|TICKOVER_HIGH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_test_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|int
name|ec
decl_stmt|,
name|rc
decl_stmt|;
name|socklen_t
name|lc
decl_stmt|;
comment|/* Check if the non-blocking connect was finished by testing the 	 * socket for writeability. Use the 'poll()' API if available 	 * and 'select()' otherwise. 	 */
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: check connect, fd=%d\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|up
operator|->
name|fdt
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_POLL_H
argument_list|)
block|{
name|struct
name|pollfd
name|pfd
decl_stmt|;
name|pfd
operator|.
name|events
operator|=
name|POLLOUT
expr_stmt|;
name|pfd
operator|.
name|fd
operator|=
name|up
operator|->
name|fdt
expr_stmt|;
name|rc
operator|=
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|!=
name|rc
operator|||
operator|!
operator|(
name|pfd
operator|.
name|revents
operator|&
name|POLLOUT
operator|)
condition|)
return|return;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYS_SELECT_H
argument_list|)
block|{
name|struct
name|timeval
name|tout
decl_stmt|;
name|fd_set
name|wset
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tout
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tout
argument_list|)
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|wset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
operator|&
name|wset
argument_list|)
expr_stmt|;
name|rc
operator|=
name|select
argument_list|(
name|up
operator|->
name|fdt
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|wset
argument_list|,
name|NULL
argument_list|,
operator|&
name|tout
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|rc
operator|||
operator|!
operator|(
name|FD_ISSET
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
operator|&
name|wset
argument_list|)
operator|)
condition|)
return|return;
block|}
else|#
directive|else
error|#
directive|error
error|Blooper! That should have been found earlier!
endif|#
directive|endif
comment|/* next timeout is a full one... */
name|up
operator|->
name|tickover
operator|=
name|TICKOVER_LOW
expr_stmt|;
comment|/* check for socket error */
name|ec
operator|=
literal|0
expr_stmt|;
name|lc
operator|=
sizeof|sizeof
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|rc
operator|=
name|getsockopt
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|&
name|ec
argument_list|,
operator|&
name|lc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
operator|||
literal|0
operator|!=
name|ec
condition|)
block|{
specifier|const
name|char
modifier|*
name|errtxt
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|ec
condition|)
name|ec
operator|=
name|errno
expr_stmt|;
name|errtxt
operator|=
name|strerror
argument_list|(
name|ec
argument_list|)
expr_stmt|;
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: async connect to GPSD failed,"
literal|" fd=%d, ec=%d(%s)"
argument_list|,
name|up
operator|->
name|logname
argument_list|,
name|up
operator|->
name|fdt
argument_list|,
name|ec
argument_list|,
name|errtxt
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: async connect to GPSD failed,"
literal|" fd=%d, ec=%d(%s)\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|up
operator|->
name|fdt
operator|,
name|ec
operator|,
name|errtxt
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: async connect to GPSD succeeded, fd=%d\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|up
operator|->
name|fdt
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* swap socket FDs, and make sure the clock was added */
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|up
operator|->
name|fdt
expr_stmt|;
name|up
operator|->
name|fdt
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: failed to register with I/O engine"
argument_list|,
name|up
operator|->
name|logname
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
return|return;
name|no_socket
label|:
if|if
condition|(
operator|-
literal|1
operator|!=
name|up
operator|->
name|fdt
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: closing socket, fd=%d\n"
operator|,
name|up
operator|->
name|logname
operator|,
name|up
operator|->
name|fdt
operator|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|up
operator|->
name|fdt
argument_list|)
expr_stmt|;
block|}
name|up
operator|->
name|fdt
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|tickover
operator|=
name|up
operator|->
name|tickpres
expr_stmt|;
name|up
operator|->
name|tickpres
operator|=
name|min
argument_list|(
name|up
operator|->
name|tickpres
operator|+
literal|5
argument_list|,
name|TICKOVER_HIGH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * helper stuff  */
end_comment

begin_comment
comment|/* -------------------------------------------------------------------  * store a properly clamped precision value  */
end_comment

begin_function
specifier|static
name|int16_t
name|clamped_precision
parameter_list|(
name|int
name|rawprec
parameter_list|)
block|{
if|if
condition|(
name|rawprec
operator|>
literal|0
condition|)
name|rawprec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rawprec
operator|<
operator|-
literal|32
condition|)
name|rawprec
operator|=
operator|-
literal|32
expr_stmt|;
return|return
operator|(
name|int16_t
operator|)
name|rawprec
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * Convert a GPSD timestamp (ISO8601 Format) to an l_fp  */
end_comment

begin_function
specifier|static
name|BOOL
name|convert_ascii_time
parameter_list|(
name|l_fp
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|gps_time
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|struct
name|tm
name|gd
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|uint32_t
name|dw
decl_stmt|;
comment|/* Use 'strptime' to take the brunt of the work, then parse 	 * the fractional part manually, starting with a digit weight of 	 * 10^8 nanoseconds. 	 */
name|ts
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|ep
operator|=
name|strptime
argument_list|(
name|gps_time
argument_list|,
literal|"%Y-%m-%dT%H:%M:%S"
argument_list|,
operator|&
name|gd
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ep
condition|)
return|return
name|FALSE
return|;
comment|/* could not parse the mandatory stuff! */
if|if
condition|(
operator|*
name|ep
operator|==
literal|'.'
condition|)
block|{
name|dw
operator|=
literal|100000000u
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|++
name|ep
argument_list|)
condition|)
block|{
name|ts
operator|.
name|tv_nsec
operator|+=
operator|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|ep
operator|-
literal|'0'
operator|)
operator|*
name|dw
expr_stmt|;
name|dw
operator|/=
literal|10u
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ep
index|[
literal|0
index|]
operator|!=
literal|'Z'
operator|||
name|ep
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
comment|/* trailing garbage */
comment|/* Now convert the whole thing into a 'l_fp'. We do not use 	 * 'mkgmtime()' since its not standard and going through the 	 * calendar routines is not much effort, either. 	 */
name|ts
operator|.
name|tv_sec
operator|=
operator|(
name|ntpcal_tm_to_rd
argument_list|(
operator|&
name|gd
argument_list|)
operator|-
name|DAY_NTP_STARTS
operator|)
operator|*
name|SECSPERDAY
operator|+
name|ntpcal_tm_to_daysec
argument_list|(
operator|&
name|gd
argument_list|)
expr_stmt|;
operator|*
name|fp
operator|=
name|tspec_intv_to_lfp
argument_list|(
name|ts
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * Save the last timecode string, making sure it's properly truncated  * if necessary and NUL terminated in any case.  */
end_comment

begin_function
specifier|static
name|void
name|save_ltc
parameter_list|(
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|tc
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
operator|(
name|tc
operator|)
condition|?
name|strlen
argument_list|(
name|tc
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
operator|(
name|u_short
operator|)
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
name|tc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pp
operator|->
name|a_lastcode
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * asprintf replacement... it's not available everywhere...  */
end_comment

begin_function
specifier|static
name|int
name|myasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|spp
parameter_list|,
name|char
specifier|const
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|size_t
name|alen
decl_stmt|,
name|plen
decl_stmt|;
name|alen
operator|=
literal|32
expr_stmt|;
operator|*
name|spp
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|va_list
name|va
decl_stmt|;
name|alen
operator|+=
name|alen
expr_stmt|;
name|free
argument_list|(
operator|*
name|spp
argument_list|)
expr_stmt|;
operator|*
name|spp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|alen
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|*
name|spp
condition|)
return|return
operator|-
literal|1
return|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|plen
operator|=
operator|(
name|size_t
operator|)
name|vsnprintf
argument_list|(
operator|*
name|spp
argument_list|,
name|alen
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|plen
operator|>=
name|alen
condition|)
do|;
return|return
operator|(
name|int
operator|)
name|plen
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * dump a raw data buffer  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|add_string
parameter_list|(
name|char
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|ep
parameter_list|,
specifier|const
name|char
modifier|*
name|sp
parameter_list|)
block|{
while|while
condition|(
name|dp
operator|!=
name|ep
operator|&&
operator|*
name|sp
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_data
parameter_list|(
name|peerT
modifier|*
name|peer
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* we're running single threaded with regards to the clocks. */
specifier|static
name|char
name|s_lbuf
index|[
literal|2048
index|]
decl_stmt|;
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|sptr
init|=
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|stop
init|=
name|buf
operator|+
name|len
decl_stmt|;
name|char
modifier|*
name|dptr
init|=
name|s_lbuf
decl_stmt|;
name|char
modifier|*
name|dtop
init|=
name|s_lbuf
operator|+
sizeof|sizeof
argument_list|(
name|s_lbuf
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* for NUL */
while|while
condition|(
name|sptr
operator|!=
name|stop
operator|&&
name|dptr
operator|!=
name|dtop
condition|)
block|{
name|u_char
name|uch
init|=
operator|(
name|u_char
operator|)
operator|*
name|sptr
operator|++
decl_stmt|;
if|if
condition|(
name|uch
operator|==
literal|'\\'
condition|)
block|{
name|dptr
operator|=
name|add_string
argument_list|(
name|dptr
argument_list|,
name|dtop
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isprint
argument_list|(
name|uch
argument_list|)
condition|)
block|{
operator|*
name|dptr
operator|++
operator|=
operator|(
name|char
operator|)
name|uch
expr_stmt|;
block|}
else|else
block|{
name|char
name|fbuf
index|[
literal|6
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|fbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|fbuf
argument_list|)
argument_list|,
literal|"\\%03o"
argument_list|,
name|uch
argument_list|)
expr_stmt|;
name|dptr
operator|=
name|add_string
argument_list|(
name|dptr
argument_list|,
name|dtop
argument_list|,
name|fbuf
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|dptr
operator|=
literal|'\0'
expr_stmt|;
name|mprintf
argument_list|(
literal|"%s[%s]: '%s'\n"
argument_list|,
name|up
operator|->
name|logname
argument_list|,
name|what
argument_list|,
name|s_lbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_macro
name|NONEMPTY_TRANSLATION_UNIT
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK&& CLOCK_GPSDJSON */
end_comment

end_unit

