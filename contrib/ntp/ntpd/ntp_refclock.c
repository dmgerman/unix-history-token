begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_refclock - processing support for reference clocks  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_IOCTL_H */
end_comment

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|TTYCLK
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_CLKDEFS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/clkdefs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/sio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TTYCLK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSCLOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSCLOCK_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<timepps.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMEPPS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * Reference clock support is provided here by maintaining the fiction  * that the clock is actually a peer. As no packets are exchanged with a  * reference clock, however, we replace the transmit, receive and packet  * procedures with separate code to simulate them. Routines  * refclock_transmit() and refclock_receive() maintain the peer  * variables in a state analogous to an actual peer and pass reference  * clock data on through the filters. Routines refclock_peer() and  * refclock_unpeer() are called to initialize and terminate reference  * clock associations. A set of utility routines is included to open  * serial devices, process sample data, edit input lines to extract  * embedded timestamps and to peform various debugging functions.  *  * The main interface used by these routines is the refclockproc  * structure, which contains for most drivers the decimal equivalants of  * the year, day, month, hour, second and millisecond/microsecond  * decoded from the ASCII timecode. Additional information includes the  * receive timestamp, exception report, statistics tallies, etc. In  * addition, there may be a driver-specific unit structure used for  * local control of the device.  *  * The support routines are passed a pointer to the peer structure,  * which is used for all peer-specific processing and contains a pointer  * to the refclockproc structure, which in turn containes a pointer to  * the unit structure, if used. The peer structure is identified by an  * interface address in the dotted quad form 127.127.t.u, where t is the  * clock type and u the unit. Some legacy drivers derive the  * refclockproc structure pointer from the table typeunit[type][unit].  * This interface is strongly discouraged and may be abandoned in  * future.  *  * The routines include support for the 1-pps signal provided by some  * radios and connected via a level converted described in the gadget  * directory. The signal is captured using a serial port and one of  * three STREAMS modules described in the refclock_atom.c file. For the  * highest precision, the signal is captured using the carrier-detect  * line of a serial port and either the ppsclock or ppsapi streams  * module or some devilish ioctl() folks keep slipping in as a patch. Be  * advised ALL support for other than the duly standardized ppsapi  * interface will eventually be withdrawn.  */
end_comment

begin_define
define|#
directive|define
name|MAXUNIT
value|4
end_define

begin_comment
comment|/* max units */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
end_if

begin_decl_stmt
name|int
name|fdpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps file descriptor */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS HAVE_PPSAPI */
end_comment

begin_define
define|#
directive|define
name|FUDGEFAC
value|.1
end_define

begin_comment
comment|/* fudge correction factor */
end_comment

begin_comment
comment|/*  * Type/unit peer index. Used to find the peer structure for control and  * debugging. When all clock drivers have been converted to new style,  * this dissapears.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|peer
modifier|*
name|typeunit
index|[
name|REFCLK_MAX
operator|+
literal|1
index|]
index|[
name|MAXUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forward declarations  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|QSORT_USES_VOID_P
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|refclock_cmpl_fp
name|P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|refclock_cmpl_fp
name|P
argument_list|(
operator|(
specifier|const
name|double
operator|*
operator|,
specifier|const
name|double
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QSORT_USES_VOID_P */
end_comment

begin_decl_stmt
specifier|static
name|int
name|refclock_sample
name|P
argument_list|(
operator|(
expr|struct
name|refclockproc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|pps_assert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* capture edge 1:assert, 0:clear */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|pps_hardpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PPS kernel 1:on, 0:off */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * refclock_report - note the occurance of an event  *  * This routine presently just remembers the report and logs it, but  * does nothing heroic for the trap handler. It tries to be a good  * citizen and bothers the system log only if things change.  */
end_comment

begin_function
name|void
name|refclock_report
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pp
operator|=
name|peer
operator|->
name|procptr
operator|)
condition|)
return|return;
if|if
condition|(
name|code
operator|==
name|CEVNT_BADREPLY
condition|)
name|pp
operator|->
name|badformat
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CEVNT_BADTIME
condition|)
name|pp
operator|->
name|baddata
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CEVNT_TIMEOUT
condition|)
name|pp
operator|->
name|noreply
operator|++
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|currentstatus
operator|!=
name|code
condition|)
block|{
name|pp
operator|->
name|currentstatus
operator|=
name|code
expr_stmt|;
name|pp
operator|->
name|lastevent
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CEVNT_FAULT
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"clock %s event '%s' (0x%02x)"
argument_list|,
name|refnumtoa
argument_list|(
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ceventstr
argument_list|(
name|code
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"clock %s event '%s' (0x%02x)"
argument_list|,
name|refnumtoa
argument_list|(
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ceventstr
argument_list|(
name|code
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock %s event '%s' (0x%02x)\n"
argument_list|,
name|refnumtoa
argument_list|(
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ceventstr
argument_list|(
name|code
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * init_refclock - initialize the reference clock drivers  *  * This routine calls each of the drivers in turn to initialize internal  * variables, if necessary. Most drivers have nothing to say at this  * point.  */
end_comment

begin_function
name|void
name|init_refclock
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|num_refclock_conf
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|refclock_conf
index|[
name|i
index|]
operator|->
name|clock_init
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|i
index|]
operator|->
name|clock_init
operator|)
operator|(
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXUNIT
condition|;
name|j
operator|++
control|)
name|typeunit
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * refclock_newpeer - initialize and start a reference clock  *  * This routine allocates and initializes the interface structure which  * supports a reference clock in the form of an ordinary NTP peer. A  * driver-specific support routine completes the initialization, if  * used. Default peer variables which identify the clock and establish  * its reference ID and stratum are set here. It returns one if success  * and zero if the clock address is invalid or already running,  * insufficient resources are available or the driver declares a bum  * rap.  */
end_comment

begin_function
name|int
name|refclock_newpeer
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Check for valid clock address. If already running, shut it 	 * down first. 	 */
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_newpeer: clock address %s invalid"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|clktype
operator|=
operator|(
name|u_char
operator|)
name|REFCLOCKTYPE
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|unit
operator|=
name|REFCLOCKUNIT
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|clktype
operator|>=
name|num_refclock_conf
operator|||
name|unit
operator|>=
name|MAXUNIT
operator|||
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_start
operator|==
name|noentry
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_newpeer: clock type %d invalid\n"
argument_list|,
name|clktype
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|refclock_unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize interface structure 	 */
if|if
condition|(
operator|!
operator|(
name|pp
operator|=
operator|(
expr|struct
name|refclockproc
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|refclockproc
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refclockproc
argument_list|)
argument_list|)
expr_stmt|;
name|typeunit
index|[
name|clktype
index|]
index|[
name|unit
index|]
operator|=
name|peer
expr_stmt|;
name|peer
operator|->
name|procptr
operator|=
name|pp
expr_stmt|;
comment|/* 	 * Initialize structures 	 */
name|peer
operator|->
name|refclktype
operator|=
name|clktype
expr_stmt|;
name|peer
operator|->
name|refclkunit
operator|=
name|unit
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_REFCLOCK
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_REFCLOCK
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|peer
operator|->
name|maxpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|pp
operator|->
name|type
operator|=
name|clktype
expr_stmt|;
name|pp
operator|->
name|timestarted
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * If the interface has been set to any_interface, set it to the 	 * loopback address if we have one. This is so that peers which 	 * are unreachable are easy to see in the peer display. 	 */
if|if
condition|(
name|peer
operator|->
name|dstadr
operator|==
name|any_interface
operator|&&
name|loopback_interface
operator|!=
literal|0
condition|)
name|peer
operator|->
name|dstadr
operator|=
name|loopback_interface
expr_stmt|;
comment|/* 	 * Set peer.pmode based on the hmode. For appearances only. 	 */
switch|switch
condition|(
name|peer
operator|->
name|hmode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
name|peer
operator|->
name|pmode
operator|=
name|MODE_PASSIVE
expr_stmt|;
break|break;
default|default:
name|peer
operator|->
name|pmode
operator|=
name|MODE_SERVER
expr_stmt|;
break|break;
block|}
comment|/* 	 * Do driver dependent initialization. The above defaults 	 * can be wiggled, then finish up for consistency. 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_start
operator|)
operator|(
name|unit
operator|,
name|peer
operator|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
literal|1
condition|)
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
else|else
name|peer
operator|->
name|refid
operator|=
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_unpeer - shut down a clock  */
end_comment

begin_function
name|void
name|refclock_unpeer
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Wiggle the driver to release its resources, then give back 	 * the interface structure. 	 */
if|if
condition|(
operator|!
name|peer
operator|->
name|procptr
condition|)
return|return;
name|clktype
operator|=
name|peer
operator|->
name|refclktype
expr_stmt|;
name|unit
operator|=
name|peer
operator|->
name|refclkunit
expr_stmt|;
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_shutdown
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_shutdown
operator|)
operator|(
name|unit
operator|,
name|peer
operator|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|procptr
argument_list|)
expr_stmt|;
name|peer
operator|->
name|procptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_transmit - simulate the transmit procedure  *  * This routine implements the NTP transmit procedure for a reference  * clock. This provides a mechanism to call the driver at the NTP poll  * interval, as well as provides a reachability mechanism to detect a  * broken radio or other madness.  */
end_comment

begin_function
name|void
name|refclock_transmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|hpoll
decl_stmt|;
name|u_long
name|next
decl_stmt|;
name|clktype
operator|=
name|peer
operator|->
name|refclktype
expr_stmt|;
name|unit
operator|=
name|peer
operator|->
name|refclkunit
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
comment|/* 	 * This is a ripoff of the peer transmit routine, but 	 * specialized for reference clocks. We do a little less 	 * protocol here and call the driver-specific transmit routine. 	 */
name|hpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
name|next
operator|=
name|peer
operator|->
name|outdate
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
name|u_char
name|oreach
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_transmit: at %ld %s\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Update reachability and poll variables like the 		 * network code. 		 */
name|oreach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
if|if
condition|(
name|oreach
operator|&
literal|0x01
condition|)
name|peer
operator|->
name|valid
operator|++
expr_stmt|;
if|if
condition|(
name|oreach
operator|&
literal|0x80
condition|)
name|peer
operator|->
name|valid
operator|--
expr_stmt|;
name|peer
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|oreach
operator|!=
literal|0
condition|)
block|{
name|report_event
argument_list|(
name|EVNT_UNREACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|oreach
operator|&
literal|0x03
operator|)
operator|==
literal|0
condition|)
block|{
name|clock_filter
argument_list|(
name|peer
argument_list|,
literal|0.
argument_list|,
literal|0.
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|valid
operator|<=
literal|2
condition|)
block|{
name|hpoll
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|valid
operator|>
name|NTP_SHIFT
operator|-
literal|2
condition|)
name|hpoll
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_BURST
condition|)
name|peer
operator|->
name|burst
operator|=
name|NSTAGE
expr_stmt|;
block|}
name|next
operator|=
name|current_time
expr_stmt|;
block|}
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_poll
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_poll
operator|)
operator|(
name|unit
operator|,
name|peer
operator|)
expr_stmt|;
name|peer
operator|->
name|outdate
operator|=
name|next
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
name|peer
operator|->
name|burst
operator|--
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|hpoll
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compare two doubles - used with qsort()  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|QSORT_USES_VOID_P
end_ifdef

begin_function
specifier|static
name|int
name|refclock_cmpl_fp
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|double
modifier|*
name|dp1
init|=
operator|(
specifier|const
name|double
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|double
modifier|*
name|dp2
init|=
operator|(
specifier|const
name|double
operator|*
operator|)
name|p2
decl_stmt|;
if|if
condition|(
operator|*
name|dp1
operator|<
operator|*
name|dp2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|dp1
operator|>
operator|*
name|dp2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|refclock_cmpl_fp
parameter_list|(
specifier|const
name|double
modifier|*
name|dp1
parameter_list|,
specifier|const
name|double
modifier|*
name|dp2
parameter_list|)
block|{
if|if
condition|(
operator|*
name|dp1
operator|<
operator|*
name|dp2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|dp1
operator|>
operator|*
name|dp2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QSORT_USES_VOID_P */
end_comment

begin_comment
comment|/*  * refclock_process_offset - update median filter  *  * This routine uses the given offset and timestamps to construct a new entry in the median filter circular buffer. Samples that overflow the filter are quietly discarded.  */
end_comment

begin_function
name|void
name|refclock_process_offset
parameter_list|(
name|struct
name|refclockproc
modifier|*
name|pp
parameter_list|,
name|l_fp
name|offset
parameter_list|,
name|l_fp
name|lastrec
parameter_list|,
name|double
name|fudge
parameter_list|)
block|{
name|double
name|doffset
decl_stmt|;
name|pp
operator|->
name|lastref
operator|=
name|offset
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|=
name|lastrec
expr_stmt|;
name|pp
operator|->
name|variance
operator|=
literal|0
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|lastrec
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|offset
argument_list|,
name|doffset
argument_list|)
expr_stmt|;
name|SAMPLE
argument_list|(
name|doffset
operator|+
name|fudge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_process - process a sample from the clock  *  * This routine converts the timecode in the form days, hours, minutes,  * seconds and milliseconds/microseconds to internal timestamp format,  * then constructs a new entry in the median filter circular buffer.  * Return success (1) if the data are correct and consistent with the  * converntional calendar. */
end_comment

begin_function
name|int
name|refclock_process
parameter_list|(
name|struct
name|refclockproc
modifier|*
name|pp
parameter_list|)
block|{
name|l_fp
name|offset
decl_stmt|;
comment|/* 	 * Compute the timecode timestamp from the days, hours, minutes, 	 * seconds and milliseconds/microseconds of the timecode. Use 	 * clocktime() for the aggregate seconds and the msec/usec for 	 * the fraction, when present. Note that this code relies on the 	 * filesystem time for the years and does not use the years of 	 * the timecode. 	 */
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|GMT
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|&
name|offset
operator|.
name|l_ui
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pp
operator|->
name|usec
condition|)
block|{
name|TVUTOTSF
argument_list|(
name|pp
operator|->
name|usec
argument_list|,
name|offset
operator|.
name|l_uf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MSUTOTSF
argument_list|(
name|pp
operator|->
name|msec
argument_list|,
name|offset
operator|.
name|l_uf
argument_list|)
expr_stmt|;
block|}
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|offset
argument_list|,
name|pp
operator|->
name|lastrec
argument_list|,
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_sample - process a pile of samples from the clock  *  * This routine implements a recursive median filter to suppress spikes  * in the data, as well as determine a performance statistic. It  * calculates the mean offset and mean-square variance. A time  * adjustment fudgetime1 can be added to the final offset to compensate  * for various systematic errors. The routine returns the number of  * samples processed, which could be 0.  */
end_comment

begin_function
specifier|static
name|int
name|refclock_sample
parameter_list|(
name|struct
name|refclockproc
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|double
name|offset
decl_stmt|,
name|disp
decl_stmt|;
name|double
name|off
index|[
name|MAXSTAGE
index|]
decl_stmt|;
comment|/* 	 * Copy the raw offsets and sort into ascending order. Don't do 	 * anything if the buffer is empty. 	 */
if|if
condition|(
name|pp
operator|->
name|codeproc
operator|==
name|pp
operator|->
name|coderecv
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pp
operator|->
name|codeproc
operator|!=
name|pp
operator|->
name|coderecv
condition|)
name|off
index|[
name|n
operator|++
index|]
operator|=
name|pp
operator|->
name|filter
index|[
name|pp
operator|->
name|codeproc
operator|++
operator|%
name|MAXSTAGE
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|off
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|,
name|refclock_cmpl_fp
argument_list|)
expr_stmt|;
comment|/* 	 * Reject the furthest from the median of the samples until 	 * approximately 60 percent of the samples remain. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|n
expr_stmt|;
name|k
operator|=
name|n
operator|-
operator|(
name|n
operator|*
literal|2
operator|)
operator|/
name|NSTAGE
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|-
name|i
operator|)
operator|>
name|k
condition|)
block|{
name|offset
operator|=
name|off
index|[
operator|(
name|j
operator|+
name|i
operator|)
operator|/
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|off
index|[
name|j
operator|-
literal|1
index|]
operator|-
name|offset
operator|<
name|offset
operator|-
name|off
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* reject low end */
else|else
name|j
operator|--
expr_stmt|;
comment|/* reject high end */
block|}
comment|/* 	 * Determine the offset and variance. 	 */
name|offset
operator|=
name|disp
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|+=
name|off
index|[
name|i
index|]
expr_stmt|;
name|disp
operator|+=
name|SQUARE
argument_list|(
name|off
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|offset
operator|/=
name|k
expr_stmt|;
name|pp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|pp
operator|->
name|variance
operator|+=
name|disp
operator|/
name|k
operator|-
name|SQUARE
argument_list|(
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_sample: n %d offset %.6f disp %.6f std %.6f\n"
argument_list|,
name|n
argument_list|,
name|pp
operator|->
name|offset
argument_list|,
name|pp
operator|->
name|disp
argument_list|,
name|SQRT
argument_list|(
name|pp
operator|->
name|variance
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_receive - simulate the receive and packet procedures  *  * This routine simulates the NTP receive and packet procedures for a  * reference clock. This provides a mechanism in which the ordinary NTP  * filter, selection and combining algorithms can be used to suppress  * misbehaving radios and to mitigate between them when more than one is  * available for backup.  */
end_comment

begin_function
name|void
name|refclock_receive
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_receive: at %lu %s\n"
argument_list|,
name|current_time
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Do a little sanity dance and update the peer structure. Groom 	 * the median filter samples and give the data to the clock 	 * filter. 	 */
name|peer
operator|->
name|received
operator|++
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|peer
operator|->
name|processed
operator|++
expr_stmt|;
name|peer
operator|->
name|timereceived
operator|=
name|current_time
expr_stmt|;
name|peer
operator|->
name|leap
operator|=
name|pp
operator|->
name|leap
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
name|report_event
argument_list|(
name|EVNT_REACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|peer
operator|->
name|reftime
operator|=
name|peer
operator|->
name|org
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
name|pp
operator|->
name|disp
operator|+
name|SQRT
argument_list|(
name|pp
operator|->
name|variance
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refclock_sample
argument_list|(
name|pp
argument_list|)
condition|)
return|return;
name|clock_filter
argument_list|(
name|peer
argument_list|,
name|pp
operator|->
name|offset
argument_list|,
literal|0.
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
name|record_peer_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|,
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|CLOCK_PHI
operator|*
operator|(
name|current_time
operator|-
name|peer
operator|->
name|epoch
operator|)
argument_list|,
name|SQRT
argument_list|(
name|peer
operator|->
name|variance
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pps_control
operator|&&
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG1
condition|)
name|pp
operator|->
name|fudgetime1
operator|-=
name|pp
operator|->
name|offset
operator|*
name|FUDGEFAC
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_gtlin - groom next input line and extract timestamp  *  * This routine processes the timecode received from the clock and  * removes the parity bit and control characters. If a timestamp is  * present in the timecode, as produced by the tty_clk STREAMS module,  * it returns that as the timestamp; otherwise, it returns the buffer  *  timestamp. The routine return code is the number of characters in  * the line.  */
end_comment

begin_function
name|int
name|refclock_gtlin
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
comment|/* receive buffer pointer */
name|char
modifier|*
name|lineptr
parameter_list|,
comment|/* current line pointer */
name|int
name|bmax
parameter_list|,
comment|/* remaining characters in line */
name|l_fp
modifier|*
name|tsptr
comment|/* pointer to timestamp returned */
parameter_list|)
block|{
name|char
modifier|*
name|dpt
decl_stmt|,
modifier|*
name|dpend
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|l_fp
name|trtmp
decl_stmt|,
name|tstmp
decl_stmt|;
name|char
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCDCDTIMESTAMP
name|struct
name|timeval
name|dcd_time
decl_stmt|;
endif|#
directive|endif
comment|/* TIOCDCDTIMESTAMP */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|pps_info_t
name|pi
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|double
name|a
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
comment|/* 	 * Check for the presence of a timestamp left by the tty_clock 	 * module and, if present, use that instead of the buffer 	 * timestamp captured by the I/O routines. We recognize a 	 * timestamp by noting its value is earlier than the buffer 	 * timestamp, but not more than one second earlier. 	 */
name|dpt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
name|dpend
operator|=
name|dpt
operator|+
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|trtmp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rbufp
operator|->
name|fd
operator|==
name|fdpps
operator|)
operator|&&
operator|(
name|time_pps_fetch
argument_list|(
name|fdpps
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|pi
argument_list|,
operator|&
name|timeout
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|pps_assert
condition|)
name|tsp
operator|=
operator|&
name|pi
operator|.
name|assert_timestamp
expr_stmt|;
else|else
name|tsp
operator|=
operator|&
name|pi
operator|.
name|clear_timestamp
expr_stmt|;
name|a
operator|=
name|tsp
operator|->
name|tv_nsec
expr_stmt|;
name|a
operator|/=
literal|1e9
expr_stmt|;
name|tstmp
operator|.
name|l_uf
operator|=
name|a
operator|*
literal|4294967296.0
expr_stmt|;
name|tstmp
operator|.
name|l_ui
operator|=
name|tsp
operator|->
name|tv_sec
expr_stmt|;
name|tstmp
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|trtmp
argument_list|,
operator|&
name|tstmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|trtmp
operator|.
name|l_ui
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"refclock_gtlin: fd %d time_pps_fetch %s"
argument_list|,
name|fdpps
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|tstmp
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" sigio %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|trtmp
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|trtmp
operator|=
name|tstmp
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
else|else
name|trtmp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
ifdef|#
directive|ifdef
name|TIOCDCDTIMESTAMP
if|if
condition|(
name|ioctl
argument_list|(
name|rbufp
operator|->
name|fd
argument_list|,
name|TIOCDCDTIMESTAMP
argument_list|,
operator|&
name|dcd_time
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|TVTOTS
argument_list|(
operator|&
name|dcd_time
argument_list|,
operator|&
name|tstmp
argument_list|)
expr_stmt|;
name|tstmp
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|trtmp
argument_list|,
operator|&
name|tstmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|trtmp
operator|.
name|l_ui
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"refclock_gtlin: fd %d DCDTIMESTAMP %s"
argument_list|,
name|rbufp
operator|->
name|fd
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|tstmp
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" sigio %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|trtmp
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|trtmp
operator|=
name|tstmp
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
else|else
name|trtmp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
block|}
elseif|else
comment|/* XXX fallback to old method if kernel refuses TIOCDCDTIMESTAMP */
endif|#
directive|endif
comment|/* TIOCDCDTIMESTAMP */
if|if
condition|(
name|dpend
operator|>=
name|dpt
operator|+
literal|8
condition|)
block|{
if|if
condition|(
name|buftvtots
argument_list|(
name|dpend
operator|-
literal|8
argument_list|,
operator|&
name|tstmp
argument_list|)
condition|)
block|{
name|L_SUB
argument_list|(
operator|&
name|trtmp
argument_list|,
operator|&
name|tstmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|trtmp
operator|.
name|l_ui
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"refclock_gtlin: fd %d ldisc %s"
argument_list|,
name|rbufp
operator|->
name|fd
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|trtmp
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|trtmp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|trtmp
argument_list|,
operator|&
name|tstmp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" sigio %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|trtmp
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dpend
operator|-=
literal|8
expr_stmt|;
name|trtmp
operator|=
name|tstmp
expr_stmt|;
block|}
else|else
name|trtmp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
operator|||
name|defined
argument_list|(
name|TIOCDCDTIMESTAMP
argument_list|)
name|gotit
label|:
endif|#
directive|endif
comment|/* 	 * Edit timecode to remove control chars. Don't monkey with the 	 * line buffer if the input buffer contains no ASCII printing 	 * characters. 	 */
if|if
condition|(
name|dpend
operator|-
name|dpt
operator|>
name|bmax
operator|-
literal|1
condition|)
name|dpend
operator|=
name|dpt
operator|+
name|bmax
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|lineptr
init|;
name|dpt
operator|<
name|dpend
condition|;
name|dpt
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|dpt
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
condition|)
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|i
operator|=
name|dp
operator|-
name|lineptr
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
operator|&&
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"refclock_gtlin: fd %d time %s timecode %d %s\n"
argument_list|,
name|rbufp
operator|->
name|fd
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|trtmp
argument_list|,
literal|6
argument_list|)
argument_list|,
name|i
argument_list|,
name|lineptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|tsptr
operator|=
name|trtmp
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following code does not apply to WINNT& VMS ...  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|SYS_VXWORKS
operator|&&
operator|!
name|defined
name|SYS_WINNT
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
end_if

begin_comment
comment|/*  * refclock_open - open serial port for reference clock  *  * This routine opens a serial port for I/O and sets default options. It  * returns the file descriptor if success and zero if failure.  */
end_comment

begin_function
name|int
name|refclock_open
parameter_list|(
name|char
modifier|*
name|dev
parameter_list|,
comment|/* device name pointer */
name|int
name|speed
parameter_list|,
comment|/* serial port speed (code) */
name|int
name|lflags
comment|/* line discipline flags */
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|;
name|int
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
name|struct
name|termio
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
ifdef|#
directive|ifdef
name|HAVE_BSD_TTYS
name|struct
name|sgttyb
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
ifdef|#
directive|ifdef
name|TIOCMGET
name|u_long
name|ltemp
decl_stmt|;
endif|#
directive|endif
comment|/* TIOCMGET */
comment|/* 	 * Open serial port and set default options 	 */
name|flags
operator|=
name|lflags
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dev
argument_list|,
name|pps_device
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|LDISC_PPS
expr_stmt|;
ifdef|#
directive|ifdef
name|O_NONBLOCK
name|fd
operator|=
name|open
argument_list|(
name|dev
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
else|#
directive|else
name|fd
operator|=
name|open
argument_list|(
name|dev
argument_list|,
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* O_NONBLOCK */
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: %s: %m"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * The following sections initialize the serial line port in 	 * canonical (line-oriented) mode and set the specified line 	 * speed, 8 bits and no parity. The modem control, break, erase 	 * and kill functions are normally disabled. There is a 	 * different section for each terminal interface, as selected at 	 * compile time. 	 */
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
comment|/* 	 * POSIX serial line parameters (termios interface) 	 */
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d tcgetattr: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set canonical mode and local connection; set specified speed, 	 * 8 bits and no parity; map CR to NL; ignore break. 	 */
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
operator|(
name|void
operator|)
name|cfsetispeed
argument_list|(
operator|&
name|ttyb
argument_list|,
operator|(
name|u_int
operator|)
name|speed
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfsetospeed
argument_list|(
operator|&
name|ttyb
argument_list|,
operator|(
name|u_int
operator|)
name|speed
argument_list|)
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCCS
condition|;
operator|++
name|i
control|)
block|{
name|ttyp
operator|->
name|c_cc
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * Some special cases 	 */
if|if
condition|(
name|flags
operator|&
name|LDISC_RAW
condition|)
block|{
name|ttyp
operator|->
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TIOCMGET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCO5_CLOCK
argument_list|)
comment|/* 	 * If we have modem control, check to see if modem leads are 	 * active; if so, set remote connection. This is necessary for 	 * the kernel pps mods to work. 	 */
name|ltemp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ltemp
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TIOCMGET failed: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_open: fd %d modem status 0x%lx\n"
argument_list|,
name|fd
argument_list|,
name|ltemp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ltemp
operator|&
name|TIOCM_DSR
condition|)
name|ttyp
operator|->
name|c_cflag
operator|&=
operator|~
name|CLOCAL
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCMGET */
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TCSANOW failed: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tcflush
argument_list|(
name|fd
argument_list|,
name|TCIOFLUSH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TCIOFLUSH failed: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
comment|/* 	 * System V serial line parameters (termio interface) 	 * 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCGETA
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TCGETA failed: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set canonical mode and local connection; set specified speed, 	 * 8 bits and no parity; map CR to NL; ignore break. 	 */
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|speed
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Some special cases 	 */
if|if
condition|(
name|flags
operator|&
name|LDISC_RAW
condition|)
block|{
name|ttyp
operator|->
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TIOCMGET
comment|/* 	 * If we have modem control, check to see if modem leads are 	 * active; if so, set remote connection. This is necessary for 	 * the kernel pps mods to work. 	 */
name|ltemp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ltemp
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TIOCMGET failed: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_open: fd %d modem status %lx\n"
argument_list|,
name|fd
argument_list|,
name|ltemp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ltemp
operator|&
name|TIOCM_DSR
condition|)
name|ttyp
operator|->
name|c_cflag
operator|&=
operator|~
name|CLOCAL
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCMGET */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCSETA
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TCSETA failed: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
ifdef|#
directive|ifdef
name|HAVE_BSD_TTYS
comment|/* 	 * 4.3bsd serial line parameters (sgttyb interface) 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TIOCGETP %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ttyp
operator|->
name|sg_ispeed
operator|=
name|ttyp
operator|->
name|sg_ospeed
operator|=
name|speed
expr_stmt|;
name|ttyp
operator|->
name|sg_flags
operator|=
name|EVENP
operator||
name|ODDP
operator||
name|CRMOD
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: TIOCSETP failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
if|if
condition|(
operator|!
name|refclock_ioctl
argument_list|(
name|fd
argument_list|,
name|flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d ioctl failed: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TERMIOS || HAVE_SYSV_TTYS || HAVE_BSD_TTYS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_VXWORKS SYS_WINNT */
end_comment

begin_comment
comment|/*  * refclock_ioctl - set serial port control functions  *  * This routine attempts to hide the internal, system-specific details  * of serial ports. It can handle POSIX (termios), SYSV (termio) and BSD  * (sgtty) interfaces with varying degrees of success. The routine sets  * up optional features such as tty_clk, ppsclock and ppsapi, as well as  * their many other variants. The routine returns 1 if success and 0 if  * failure.  */
end_comment

begin_function
name|int
name|refclock_ioctl
parameter_list|(
name|int
name|fd
parameter_list|,
comment|/* file descriptor */
name|int
name|flags
comment|/* line discipline flags */
parameter_list|)
block|{
comment|/* simply return 1 if no UNIX line discipline is supported */
if|#
directive|if
operator|!
name|defined
name|SYS_VXWORKS
operator|&&
operator|!
name|defined
name|SYS_WINNT
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
ifdef|#
directive|ifdef
name|TTYCLK
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
name|struct
name|termio
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
ifdef|#
directive|ifdef
name|HAVE_BSD_TTYS
name|struct
name|sgttyb
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
endif|#
directive|endif
comment|/* TTYCLK */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_ioctl: fd %d flags 0x%x\n"
argument_list|,
name|fd
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The following sections select optional features, such as 	 * modem control, PPS capture and so forth. Some require 	 * specific operating system support in the form of STREAMS 	 * modules, which can be loaded and unloaded at run time without 	 * rebooting the kernel. The STREAMS modules require System 	 * V STREAMS support. The checking frenzy is attenuated here, 	 * since the device is already open. 	 * 	 * Note that the tty_clk and ppsclock modules are optional; if 	 * configured and unavailable, the dang thing still works, but 	 * the accuracy improvement using them will not be available. 	 * The only known implmentations of these moldules are specific 	 * to SunOS 4.x. Use the ppsclock module ONLY with Sun baseboard 	 * ttya or ttyb. Using it with the SPIF multipexor crashes the 	 * kernel. 	 * 	 * The preferred way to capture PPS timestamps is using the 	 * ppsapi interface, which is machine independent. The SunOS 4.x 	 * and Digital Unix 4.x interfaces use STREAMS modules and 	 * support both the ppsapi specification and ppsclock 	 * functionality, but other systems may vary widely. 	 */
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
operator|)
if|if
condition|(
name|flags
operator|&
operator|(
name|LDISC_CLK
operator||
name|LDISC_PPS
operator||
name|LDISC_ACTS
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: unsupported terminal interface"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS HAVE_BSD_TTYS */
ifdef|#
directive|ifdef
name|TTYCLK
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
endif|#
directive|endif
comment|/* TTYCLK */
comment|/* 	 * The following features may or may not require System V 	 * STREAMS support, depending on the particular implementation. 	 */
if|#
directive|if
name|defined
argument_list|(
name|TTYCLK
argument_list|)
comment|/* 	 * The TTYCLK option provides timestamping at the driver level. 	 * It requires the tty_clk streams module and System V STREAMS 	 * support. If not available, don't complain. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|LDISC_CLK
operator||
name|LDISC_CLKPPS
operator||
name|LDISC_ACTS
operator|)
condition|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_PUSH
argument_list|,
literal|"clk"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_ioctl: I_PUSH clk failed: %m"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|LDISC_CLKPPS
condition|)
name|str
operator|=
literal|"\377"
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|LDISC_ACTS
condition|)
name|str
operator|=
literal|"*"
expr_stmt|;
else|else
name|str
operator|=
literal|"\n"
expr_stmt|;
ifdef|#
directive|ifdef
name|CLK_SETSTR
if|if
condition|(
operator|(
name|rval
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CLK_SETSTR
argument_list|,
name|str
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: CLK_SETSTR failed: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_ioctl: fd %d CLK_SETSTR %d str %s\n"
argument_list|,
name|fd
argument_list|,
name|rval
argument_list|,
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* TTYCLK */
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_PPSAPI
argument_list|)
comment|/* 	 * The PPS option provides timestamping at the driver level. 	 * It uses a 1-pps signal and level converter (gadget box) and 	 * requires the ppsclock streams module and System V STREAMS 	 * support. This option has been superseded by the ppsapi 	 * option and may be withdrawn in future. 	 */
if|if
condition|(
name|flags
operator|&
name|LDISC_PPS
condition|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIOCSPPS
comment|/* Solaris */
name|int
name|one
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TIOCSPPS */
if|if
condition|(
name|fdpps
operator|>
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: PPS already configured"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_TIOCSPPS
comment|/* Solaris */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSPPS
argument_list|,
operator|&
name|one
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_ioctl: TIOCSPPS failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_ioctl: fd %d TIOCSPPS %d\n"
argument_list|,
name|fd
argument_list|,
name|rval
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_PUSH
argument_list|,
literal|"ppsclock"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_ioctl: I_PUSH ppsclock failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_ioctl: fd %d ppsclock %d\n"
argument_list|,
name|fd
argument_list|,
name|rval
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TIOCSPPS */
name|fdpps
operator|=
name|fd
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PPS HAVE_PPSAPI */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
comment|/* 	 * The PPSAPI option provides timestamping at the driver level. 	 * It uses a 1-pps signal and level converter (gadget box) and 	 * requires ppsapi compiled into the kernel on non STREAMS 	 * systems. This is the preferred way to capture PPS timestamps 	 * and is expected to become an IETF cross-platform standard. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|LDISC_PPS
operator||
name|LDISC_CLKPPS
operator|)
condition|)
block|{
name|pps_params_t
name|pp
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|temp
decl_stmt|;
name|pps_handle_t
name|handle
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdpps
operator|>
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: ppsapi already configured"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|time_pps_create
argument_list|(
name|fd
argument_list|,
operator|&
name|handle
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_create failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|time_pps_getcap
argument_list|(
name|handle
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_getcap failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|.
name|mode
operator|=
name|mode
operator|&
name|PPS_CAPTUREBOTH
expr_stmt|;
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|handle
argument_list|,
operator|&
name|pp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_setparams failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|pps_hardpps
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pps_assert
condition|)
name|temp
operator|=
name|mode
operator|&
name|PPS_CAPTUREASSERT
expr_stmt|;
else|else
name|temp
operator|=
name|mode
operator|&
name|PPS_CAPTURECLEAR
expr_stmt|;
if|if
condition|(
name|time_pps_kcbind
argument_list|(
name|handle
argument_list|,
name|PPS_KC_HARDPPS
argument_list|,
name|temp
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: time_pps_kcbind failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|time_pps_getparams
argument_list|(
name|handle
argument_list|,
operator|&
name|pp
argument_list|)
expr_stmt|;
name|fdpps
operator|=
operator|(
name|int
operator|)
name|handle
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_ioctl: fd %d ppsapi vers %d mode 0x%x cap 0x%x\n"
argument_list|,
name|fdpps
argument_list|,
name|pp
operator|.
name|api_version
argument_list|,
name|pp
operator|.
name|mode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
endif|#
directive|endif
comment|/* HAVE_TERMIOS || HAVE_SYSV_TTYS || HAVE_BSD_TTYS */
endif|#
directive|endif
comment|/* SYS_VXWORKS SYS_WINNT */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_control - set and/or return clock values  *  * This routine is used mainly for debugging. It returns designated  * values from the interface structure that can be displayed using  * ntpdc and the clockstat command. It can also be used to initialize  * configuration variables, such as fudgetimes, fudgevalues, reference  * ID and stratum.  */
end_comment

begin_function
name|void
name|refclock_control
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|srcadr
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|in
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Check for valid address and running peer 	 */
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
name|srcadr
argument_list|)
condition|)
return|return;
name|clktype
operator|=
operator|(
name|u_char
operator|)
name|REFCLOCKTYPE
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
name|unit
operator|=
name|REFCLOCKUNIT
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|clktype
operator|>=
name|num_refclock_conf
operator|||
name|unit
operator|>=
name|MAXUNIT
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|peer
operator|=
name|typeunit
index|[
name|clktype
index|]
index|[
name|unit
index|]
operator|)
condition|)
return|return;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
comment|/* 	 * Initialize requested data 	 */
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
condition|)
name|pp
operator|->
name|fudgetime1
operator|=
name|in
operator|->
name|fudgetime1
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME2
condition|)
name|pp
operator|->
name|fudgetime2
operator|=
name|in
operator|->
name|fudgetime2
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
condition|)
name|peer
operator|->
name|stratum
operator|=
operator|(
name|u_char
operator|)
name|in
operator|->
name|fudgeval1
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL2
condition|)
name|pp
operator|->
name|refid
operator|=
name|in
operator|->
name|fudgeval2
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
literal|1
condition|)
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
else|else
name|peer
operator|->
name|refid
operator|=
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG1
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG1
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG1
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG2
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG2
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG2
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG3
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG3
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG3
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG4
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG4
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG4
expr_stmt|;
block|}
block|}
comment|/* 	 * Readback requested data 	 */
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
block|{
name|out
operator|->
name|haveflags
operator|=
name|CLK_HAVETIME1
operator||
name|CLK_HAVEVAL1
operator||
name|CLK_HAVEVAL2
operator||
name|CLK_HAVEFLAG4
expr_stmt|;
name|out
operator|->
name|fudgetime1
operator|=
name|pp
operator|->
name|fudgetime1
expr_stmt|;
name|out
operator|->
name|fudgetime2
operator|=
name|pp
operator|->
name|fudgetime2
expr_stmt|;
name|out
operator|->
name|fudgeval1
operator|=
name|peer
operator|->
name|stratum
expr_stmt|;
name|out
operator|->
name|fudgeval2
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
name|out
operator|->
name|flags
operator|=
operator|(
name|u_char
operator|)
name|pp
operator|->
name|sloppyclockflag
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
name|current_time
operator|-
name|pp
operator|->
name|timestarted
expr_stmt|;
name|out
operator|->
name|polls
operator|=
name|pp
operator|->
name|polls
expr_stmt|;
name|out
operator|->
name|noresponse
operator|=
name|pp
operator|->
name|noreply
expr_stmt|;
name|out
operator|->
name|badformat
operator|=
name|pp
operator|->
name|badformat
expr_stmt|;
name|out
operator|->
name|baddata
operator|=
name|pp
operator|->
name|baddata
expr_stmt|;
name|out
operator|->
name|lastevent
operator|=
name|pp
operator|->
name|lastevent
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|pp
operator|->
name|currentstatus
expr_stmt|;
name|out
operator|->
name|type
operator|=
name|pp
operator|->
name|type
expr_stmt|;
name|out
operator|->
name|clockdesc
operator|=
name|pp
operator|->
name|clockdesc
expr_stmt|;
name|out
operator|->
name|lencode
operator|=
name|pp
operator|->
name|lencode
expr_stmt|;
name|out
operator|->
name|p_lastcode
operator|=
name|pp
operator|->
name|a_lastcode
expr_stmt|;
block|}
comment|/* 	 * Give the stuff to the clock 	 */
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_control
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_control
operator|)
operator|(
name|unit
operator|,
name|in
operator|,
name|out
operator|,
name|peer
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_buginfo - return debugging info  *  * This routine is used mainly for debugging. It returns designated  * values from the interface structure that can be displayed using  * ntpdc and the clkbug command.  */
end_comment

begin_function
name|void
name|refclock_buginfo
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|srcadr
parameter_list|,
comment|/* clock address */
name|struct
name|refclockbug
modifier|*
name|bug
comment|/* output structure */
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Check for valid address and peer structure 	 */
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
name|srcadr
argument_list|)
condition|)
return|return;
name|clktype
operator|=
operator|(
name|u_char
operator|)
name|REFCLOCKTYPE
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
name|unit
operator|=
name|REFCLOCKUNIT
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|clktype
operator|>=
name|num_refclock_conf
operator|||
name|unit
operator|>=
name|MAXUNIT
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|peer
operator|=
name|typeunit
index|[
name|clktype
index|]
index|[
name|unit
index|]
operator|)
condition|)
return|return;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
comment|/* 	 * Copy structure values 	 */
name|bug
operator|->
name|nvalues
operator|=
literal|8
expr_stmt|;
name|bug
operator|->
name|svalues
operator|=
literal|0x0000003f
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|0
index|]
operator|=
name|pp
operator|->
name|year
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|1
index|]
operator|=
name|pp
operator|->
name|day
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|2
index|]
operator|=
name|pp
operator|->
name|hour
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|3
index|]
operator|=
name|pp
operator|->
name|minute
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|4
index|]
operator|=
name|pp
operator|->
name|second
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|5
index|]
operator|=
name|pp
operator|->
name|msec
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|6
index|]
operator|=
name|pp
operator|->
name|yearstart
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|7
index|]
operator|=
name|pp
operator|->
name|coderecv
expr_stmt|;
name|bug
operator|->
name|stimes
operator|=
literal|0xfffffffc
expr_stmt|;
name|bug
operator|->
name|times
index|[
literal|0
index|]
operator|=
name|pp
operator|->
name|lastref
expr_stmt|;
name|bug
operator|->
name|times
index|[
literal|1
index|]
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|bug
operator|->
name|ntimes
condition|;
name|i
operator|++
control|)
name|DTOLFP
argument_list|(
name|pp
operator|->
name|filter
index|[
name|i
operator|-
literal|2
index|]
argument_list|,
operator|&
name|bug
operator|->
name|times
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Give the stuff to the clock 	 */
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_buginfo
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_buginfo
operator|)
operator|(
name|unit
operator|,
name|bug
operator|,
name|peer
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

