begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_refclock - processing support for reference clocks  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_tty.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_IOCTL_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL_PLL
end_ifdef

begin_include
include|#
directive|include
file|"ntp_syscall.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_include
include|#
directive|include
file|"ppsapi_timepps.h"
end_include

begin_include
include|#
directive|include
file|"refclock_atom.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * Reference clock support is provided here by maintaining the fiction  * that the clock is actually a peer.  As no packets are exchanged with  * a reference clock, however, we replace the transmit, receive and  * packet procedures with separate code to simulate them.  Routines  * refclock_transmit() and refclock_receive() maintain the peer  * variables in a state analogous to an actual peer and pass reference  * clock data on through the filters.  Routines refclock_peer() and  * refclock_unpeer() are called to initialize and terminate reference  * clock associations.  A set of utility routines is included to open  * serial devices, process sample data, and to perform various debugging  * functions.  *  * The main interface used by these routines is the refclockproc  * structure, which contains for most drivers the decimal equivalants  * of the year, day, month, hour, second and millisecond/microsecond  * decoded from the ASCII timecode.  Additional information includes  * the receive timestamp, exception report, statistics tallies, etc.   * In addition, there may be a driver-specific unit structure used for  * local control of the device.  *  * The support routines are passed a pointer to the peer structure,  * which is used for all peer-specific processing and contains a  * pointer to the refclockproc structure, which in turn contains a  * pointer to the unit structure, if used.  The peer structure is   * identified by an interface address in the dotted quad form   * 127.127.t.u, where t is the clock type and u the unit.  */
end_comment

begin_define
define|#
directive|define
name|FUDGEFAC
value|.1
end_define

begin_comment
comment|/* fudge correction factor */
end_comment

begin_define
define|#
directive|define
name|LF
value|0x0a
end_define

begin_comment
comment|/* ASCII LF */
end_comment

begin_decl_stmt
name|int
name|cal_enable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable refclock calibrate */
end_comment

begin_comment
comment|/*  * Forward declarations  */
end_comment

begin_function_decl
specifier|static
name|int
name|refclock_cmpl_fp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|refclock_sample
parameter_list|(
name|struct
name|refclockproc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|refclock_ioctl
parameter_list|(
name|int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * refclock_report - note the occurance of an event  *  * This routine presently just remembers the report and logs it, but  * does nothing heroic for the trap handler. It tries to be a good  * citizen and bothers the system log only if things change.  */
end_comment

begin_function
name|void
name|refclock_report
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CEVNT_TIMEOUT
case|:
name|pp
operator|->
name|noreply
operator|++
expr_stmt|;
break|break;
case|case
name|CEVNT_BADREPLY
case|:
name|pp
operator|->
name|badformat
operator|++
expr_stmt|;
break|break;
case|case
name|CEVNT_FAULT
case|:
break|break;
case|case
name|CEVNT_BADDATE
case|:
case|case
name|CEVNT_BADTIME
case|:
name|pp
operator|->
name|baddata
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* ignore others */
break|break;
block|}
if|if
condition|(
name|pp
operator|->
name|lastevent
operator|<
literal|15
condition|)
name|pp
operator|->
name|lastevent
operator|++
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|currentstatus
operator|!=
name|code
condition|)
block|{
name|pp
operator|->
name|currentstatus
operator|=
operator|(
name|u_char
operator|)
name|code
expr_stmt|;
name|report_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
name|ceventstr
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * init_refclock - initialize the reference clock drivers  *  * This routine calls each of the drivers in turn to initialize internal  * variables, if necessary. Most drivers have nothing to say at this  * point.  */
end_comment

begin_function
name|void
name|init_refclock
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|num_refclock_conf
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|refclock_conf
index|[
name|i
index|]
operator|->
name|clock_init
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|i
index|]
operator|->
name|clock_init
operator|)
operator|(
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_newpeer - initialize and start a reference clock  *  * This routine allocates and initializes the interface structure which  * supports a reference clock in the form of an ordinary NTP peer. A  * driver-specific support routine completes the initialization, if  * used. Default peer variables which identify the clock and establish  * its reference ID and stratum are set here. It returns one if success  * and zero if the clock address is invalid or already running,  * insufficient resources are available or the driver declares a bum  * rap.  */
end_comment

begin_function
name|int
name|refclock_newpeer
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Check for valid clock address. If already running, shut it 	 * down first. 	 */
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_newpeer: clock address %s invalid"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|clktype
operator|=
operator|(
name|u_char
operator|)
name|REFCLOCKTYPE
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|unit
operator|=
name|REFCLOCKUNIT
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|clktype
operator|>=
name|num_refclock_conf
operator|||
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_start
operator|==
name|noentry
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_newpeer: clock type %d invalid\n"
argument_list|,
name|clktype
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate and initialize interface structure 	 */
name|pp
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
expr_stmt|;
name|peer
operator|->
name|procptr
operator|=
name|pp
expr_stmt|;
comment|/* 	 * Initialize structures 	 */
name|peer
operator|->
name|refclktype
operator|=
name|clktype
expr_stmt|;
name|peer
operator|->
name|refclkunit
operator|=
operator|(
name|u_char
operator|)
name|unit
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_REFCLOCK
expr_stmt|;
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_REFCLOCK
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
name|pp
operator|->
name|type
operator|=
name|clktype
expr_stmt|;
name|pp
operator|->
name|conf
operator|=
name|refclock_conf
index|[
name|clktype
index|]
expr_stmt|;
name|pp
operator|->
name|timestarted
operator|=
name|current_time
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Set peer.pmode based on the hmode. For appearances only. 	 */
switch|switch
condition|(
name|peer
operator|->
name|hmode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
name|peer
operator|->
name|pmode
operator|=
name|MODE_PASSIVE
expr_stmt|;
break|break;
default|default:
name|peer
operator|->
name|pmode
operator|=
name|MODE_SERVER
expr_stmt|;
break|break;
block|}
comment|/* 	 * Do driver dependent initialization. The above defaults 	 * can be wiggled, then finish up for consistency. 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_start
operator|)
operator|(
name|unit
operator|,
name|peer
operator|)
operator|)
condition|)
block|{
name|refclock_unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_unpeer - shut down a clock  */
end_comment

begin_function
name|void
name|refclock_unpeer
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Wiggle the driver to release its resources, then give back 	 * the interface structure. 	 */
if|if
condition|(
name|NULL
operator|==
name|peer
operator|->
name|procptr
condition|)
return|return;
name|clktype
operator|=
name|peer
operator|->
name|refclktype
expr_stmt|;
name|unit
operator|=
name|peer
operator|->
name|refclkunit
expr_stmt|;
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_shutdown
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_shutdown
operator|)
operator|(
name|unit
operator|,
name|peer
operator|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|procptr
argument_list|)
expr_stmt|;
name|peer
operator|->
name|procptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_timer - called once per second for housekeeping.  */
end_comment

begin_function
name|void
name|refclock_timer
parameter_list|(
name|struct
name|peer
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|p
operator|->
name|refclkunit
expr_stmt|;
name|pp
operator|=
name|p
operator|->
name|procptr
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|conf
operator|->
name|clock_timer
operator|!=
name|noentry
condition|)
call|(
modifier|*
name|pp
operator|->
name|conf
operator|->
name|clock_timer
call|)
argument_list|(
name|unit
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|action
operator|!=
name|NULL
operator|&&
name|pp
operator|->
name|nextaction
operator|<=
name|current_time
condition|)
call|(
modifier|*
name|pp
operator|->
name|action
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_transmit - simulate the transmit procedure  *  * This routine implements the NTP transmit procedure for a reference  * clock. This provides a mechanism to call the driver at the NTP poll  * interval, as well as provides a reachability mechanism to detect a  * broken radio or other madness.  */
end_comment

begin_function
name|void
name|refclock_transmit
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|clktype
operator|=
name|peer
operator|->
name|refclktype
expr_stmt|;
name|unit
operator|=
name|peer
operator|->
name|refclkunit
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
comment|/* 	 * This is a ripoff of the peer transmit routine, but 	 * specialized for reference clocks. We do a little less 	 * protocol here and call the driver-specific transmit routine. 	 */
if|if
condition|(
name|peer
operator|->
name|burst
operator|==
literal|0
condition|)
block|{
name|u_char
name|oreach
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_transmit: at %ld %s\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Update reachability and poll variables like the 		 * network code. 		 */
name|oreach
operator|=
name|peer
operator|->
name|reach
operator|&
literal|0xfe
expr_stmt|;
name|peer
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|reach
operator|&
literal|0x0f
operator|)
condition|)
name|clock_filter
argument_list|(
name|peer
argument_list|,
literal|0.
argument_list|,
literal|0.
argument_list|,
name|MAXDISPERSE
argument_list|)
expr_stmt|;
name|peer
operator|->
name|outdate
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|reach
condition|)
block|{
if|if
condition|(
name|oreach
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_UNREACH
argument_list|,
name|peer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_BURST
condition|)
name|peer
operator|->
name|burst
operator|=
name|NSTAGE
expr_stmt|;
block|}
block|}
else|else
block|{
name|peer
operator|->
name|burst
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_poll
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_poll
operator|)
operator|(
name|unit
operator|,
name|peer
operator|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compare two doubles - used with qsort()  */
end_comment

begin_function
specifier|static
name|int
name|refclock_cmpl_fp
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|double
modifier|*
name|dp1
init|=
operator|(
specifier|const
name|double
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|double
modifier|*
name|dp2
init|=
operator|(
specifier|const
name|double
operator|*
operator|)
name|p2
decl_stmt|;
if|if
condition|(
operator|*
name|dp1
operator|<
operator|*
name|dp2
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|dp1
operator|>
operator|*
name|dp2
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_process_offset - update median filter  *  * This routine uses the given offset and timestamps to construct a new  * entry in the median filter circular buffer. Samples that overflow the  * filter are quietly discarded.  */
end_comment

begin_function
name|void
name|refclock_process_offset
parameter_list|(
name|struct
name|refclockproc
modifier|*
name|pp
parameter_list|,
comment|/* refclock structure pointer */
name|l_fp
name|lasttim
parameter_list|,
comment|/* last timecode timestamp */
name|l_fp
name|lastrec
parameter_list|,
comment|/* last receive timestamp */
name|double
name|fudge
parameter_list|)
block|{
name|l_fp
name|lftemp
decl_stmt|;
name|double
name|doffset
decl_stmt|;
name|pp
operator|->
name|lastrec
operator|=
name|lastrec
expr_stmt|;
name|lftemp
operator|=
name|lasttim
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|lftemp
argument_list|,
operator|&
name|lastrec
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|lftemp
argument_list|,
name|doffset
argument_list|)
expr_stmt|;
name|SAMPLE
argument_list|(
name|doffset
operator|+
name|fudge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_process - process a sample from the clock  * refclock_process_f - refclock_process with other than time1 fudge  *  * This routine converts the timecode in the form days, hours, minutes,  * seconds and milliseconds/microseconds to internal timestamp format,  * then constructs a new entry in the median filter circular buffer.  * Return success (1) if the data are correct and consistent with the  * converntional calendar.  *  * Important for PPS users: Normally, the pp->lastrec is set to the  * system time when the on-time character is received and the pp->year,  * ..., pp->second decoded and the seconds fraction pp->nsec in  * nanoseconds). When a PPS offset is available, pp->nsec is forced to  * zero and the fraction for pp->lastrec is set to the PPS offset.  */
end_comment

begin_function
name|int
name|refclock_process_f
parameter_list|(
name|struct
name|refclockproc
modifier|*
name|pp
parameter_list|,
comment|/* refclock structure pointer */
name|double
name|fudge
parameter_list|)
block|{
name|l_fp
name|offset
decl_stmt|,
name|ltemp
decl_stmt|;
comment|/* 	 * Compute the timecode timestamp from the days, hours, minutes, 	 * seconds and milliseconds/microseconds of the timecode. Use 	 * clocktime() for the aggregate seconds and the msec/usec for 	 * the fraction, when present. Note that this code relies on the 	 * filesystem time for the years and does not use the years of 	 * the timecode. 	 */
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|GMT
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|&
name|offset
operator|.
name|l_ui
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|offset
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
name|DTOLFP
argument_list|(
name|pp
operator|->
name|nsec
operator|/
literal|1e9
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|offset
argument_list|,
name|pp
operator|->
name|lastrec
argument_list|,
name|fudge
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|refclock_process
parameter_list|(
name|struct
name|refclockproc
modifier|*
name|pp
comment|/* refclock structure pointer */
parameter_list|)
block|{
return|return
name|refclock_process_f
argument_list|(
name|pp
argument_list|,
name|pp
operator|->
name|fudgetime1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_sample - process a pile of samples from the clock  *  * This routine implements a recursive median filter to suppress spikes  * in the data, as well as determine a performance statistic. It  * calculates the mean offset and RMS jitter. A time adjustment  * fudgetime1 can be added to the final offset to compensate for various  * systematic errors. The routine returns the number of samples  * processed, which could be zero.  */
end_comment

begin_function
specifier|static
name|int
name|refclock_sample
parameter_list|(
name|struct
name|refclockproc
modifier|*
name|pp
comment|/* refclock structure pointer */
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|;
name|double
name|off
index|[
name|MAXSTAGE
index|]
decl_stmt|;
name|double
name|offset
decl_stmt|;
comment|/* 	 * Copy the raw offsets and sort into ascending order. Don't do 	 * anything if the buffer is empty. 	 */
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pp
operator|->
name|codeproc
operator|!=
name|pp
operator|->
name|coderecv
condition|)
block|{
name|pp
operator|->
name|codeproc
operator|=
operator|(
name|pp
operator|->
name|codeproc
operator|+
literal|1
operator|)
operator|%
name|MAXSTAGE
expr_stmt|;
name|off
index|[
name|n
index|]
operator|=
name|pp
operator|->
name|filter
index|[
name|pp
operator|->
name|codeproc
index|]
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|off
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|off
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|refclock_cmpl_fp
argument_list|)
expr_stmt|;
comment|/* 	 * Reject the furthest from the median of the samples until 	 * approximately 60 percent of the samples remain. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|n
expr_stmt|;
name|m
operator|=
name|n
operator|-
operator|(
name|n
operator|*
literal|4
operator|)
operator|/
literal|10
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|-
name|i
operator|)
operator|>
name|m
condition|)
block|{
name|offset
operator|=
name|off
index|[
operator|(
name|j
operator|+
name|i
operator|)
operator|/
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|off
index|[
name|j
operator|-
literal|1
index|]
operator|-
name|offset
operator|<
name|offset
operator|-
name|off
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* reject low end */
else|else
name|j
operator|--
expr_stmt|;
comment|/* reject high end */
block|}
comment|/* 	 * Determine the offset and jitter. 	 */
name|pp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|jitter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
name|pp
operator|->
name|offset
operator|+=
name|off
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|i
condition|)
name|pp
operator|->
name|jitter
operator|+=
name|SQUARE
argument_list|(
name|off
index|[
name|k
index|]
operator|-
name|off
index|[
name|k
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|pp
operator|->
name|offset
operator|/=
name|m
expr_stmt|;
name|pp
operator|->
name|jitter
operator|=
name|max
argument_list|(
name|SQRT
argument_list|(
name|pp
operator|->
name|jitter
operator|/
name|m
argument_list|)
argument_list|,
name|LOGTOD
argument_list|(
name|sys_precision
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_sample: n %d offset %.6f disp %.6f jitter %.6f\n"
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|pp
operator|->
name|offset
argument_list|,
name|pp
operator|->
name|disp
argument_list|,
name|pp
operator|->
name|jitter
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|int
operator|)
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_receive - simulate the receive and packet procedures  *  * This routine simulates the NTP receive and packet procedures for a  * reference clock. This provides a mechanism in which the ordinary NTP  * filter, selection and combining algorithms can be used to suppress  * misbehaving radios and to mitigate between them when more than one is  * available for backup.  */
end_comment

begin_function
name|void
name|refclock_receive
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_receive: at %lu %s\n"
argument_list|,
name|current_time
argument_list|,
name|stoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Do a little sanity dance and update the peer structure. Groom 	 * the median filter samples and give the data to the clock 	 * filter. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|peer
operator|->
name|leap
operator|=
name|pp
operator|->
name|leap
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
return|return;
name|peer
operator|->
name|received
operator|++
expr_stmt|;
name|peer
operator|->
name|timereceived
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|reach
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_REACH
argument_list|,
name|peer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
block|}
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|peer
operator|->
name|reftime
operator|=
name|pp
operator|->
name|lastref
expr_stmt|;
name|peer
operator|->
name|aorg
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|peer
operator|->
name|rootdisp
operator|=
name|pp
operator|->
name|disp
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refclock_sample
argument_list|(
name|pp
argument_list|)
condition|)
return|return;
name|clock_filter
argument_list|(
name|peer
argument_list|,
name|pp
operator|->
name|offset
argument_list|,
literal|0.
argument_list|,
name|pp
operator|->
name|jitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cal_enable
operator|&&
name|fabs
argument_list|(
name|last_offset
argument_list|)
operator|<
name|sys_mindisp
operator|&&
name|sys_peer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sys_peer
operator|->
name|refclktype
operator|==
name|REFCLK_ATOM_PPS
operator|&&
name|peer
operator|->
name|refclktype
operator|!=
name|REFCLK_ATOM_PPS
condition|)
name|pp
operator|->
name|fudgetime1
operator|-=
name|pp
operator|->
name|offset
operator|*
name|FUDGEFAC
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * refclock_gtlin - groom next input line and extract timestamp  *  * This routine processes the timecode received from the clock and  * strips the parity bit and control characters. It returns the number  * of characters in the line followed by a NULL character ('\0'), which  * is not included in the count. In case of an empty line, the previous  * line is preserved.  */
end_comment

begin_function
name|int
name|refclock_gtlin
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
comment|/* receive buffer pointer */
name|char
modifier|*
name|lineptr
parameter_list|,
comment|/* current line pointer */
name|int
name|bmax
parameter_list|,
comment|/* remaining characters in line */
name|l_fp
modifier|*
name|tsptr
comment|/* pointer to timestamp returned */
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|spend
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dpend
decl_stmt|;
name|int
name|dlen
decl_stmt|;
if|if
condition|(
name|bmax
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dp
operator|=
name|lineptr
expr_stmt|;
name|dpend
operator|=
name|dp
operator|+
name|bmax
operator|-
literal|1
expr_stmt|;
comment|/* leave room for NUL pad */
name|sp
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
name|spend
operator|=
name|sp
operator|+
name|rbufp
operator|->
name|recv_length
expr_stmt|;
while|while
condition|(
name|sp
operator|!=
name|spend
operator|&&
name|dp
operator|!=
name|dpend
condition|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|sp
operator|++
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0x20
operator|&&
name|c
operator|<
literal|0x7f
condition|)
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* Get length of data written to the destination buffer. If 	 * zero, do *not* place a NUL byte to preserve the previous 	 * buffer content. 	 */
name|dlen
operator|=
name|dp
operator|-
name|lineptr
expr_stmt|;
if|if
condition|(
name|dlen
condition|)
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|tsptr
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"refclock_gtlin: fd %d time %s timecode %d %s\n"
operator|,
name|rbufp
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
literal|6
argument_list|)
operator|,
name|dlen
operator|,
operator|(
name|dlen
operator|!=
literal|0
operator|)
condition|?
name|lineptr
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_gtraw - get next line/chunk of data  *  * This routine returns the raw data received from the clock in both  * canonical or raw modes. The terminal interface routines map CR to LF.  * In canonical mode this results in two lines, one containing data  * followed by LF and another containing only LF. In raw mode the  * interface routines can deliver arbitraty chunks of data from one  * character to a maximum specified by the calling routine. In either  * mode the routine returns the number of characters in the line  * followed by a NULL character ('\0'), which is not included in the  * count.  *  * *tsptr receives a copy of the buffer timestamp.  */
end_comment

begin_function
name|int
name|refclock_gtraw
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
comment|/* receive buffer pointer */
name|char
modifier|*
name|lineptr
parameter_list|,
comment|/* current line pointer */
name|int
name|bmax
parameter_list|,
comment|/* remaining characters in line */
name|l_fp
modifier|*
name|tsptr
comment|/* pointer to timestamp returned */
parameter_list|)
block|{
if|if
condition|(
name|bmax
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bmax
operator|-=
literal|1
expr_stmt|;
comment|/* leave room for trailing NUL */
if|if
condition|(
name|bmax
operator|>
name|rbufp
operator|->
name|recv_length
condition|)
name|bmax
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|memcpy
argument_list|(
name|lineptr
argument_list|,
name|rbufp
operator|->
name|recv_buffer
argument_list|,
name|bmax
argument_list|)
expr_stmt|;
name|lineptr
index|[
name|bmax
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|tsptr
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"refclock_gtraw: fd %d time %s timecode %d %s\n"
operator|,
name|rbufp
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
literal|6
argument_list|)
operator|,
name|bmax
operator|,
name|lineptr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bmax
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * indicate_refclock_packet()  *  * Passes a fragment of refclock input read from the device to the  * driver direct input routine, which may consume it (batch it for  * queuing once a logical unit is assembled).  If it is not so  * consumed, queue it for the driver's receive entrypoint.  *  * The return value is TRUE if the data has been consumed as a fragment  * and should not be counted as a received packet.  */
end_comment

begin_function
name|int
name|indicate_refclock_packet
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|,
name|struct
name|recvbuf
modifier|*
name|rb
parameter_list|)
block|{
comment|/* Does this refclock use direct input routine? */
if|if
condition|(
name|rio
operator|->
name|io_input
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|rio
operator|->
name|io_input
call|)
argument_list|(
name|rb
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * data was consumed - nothing to pass up 		 * into block input machine 		 */
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|add_full_recv_buffer
argument_list|(
name|rb
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * process_refclock_packet()  *  * Used for deferred processing of 'io_input' on systems where threading  * is used (notably Windows). This is acting as a trampoline to make the  * real calls to the refclock functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IO_COMPLETION_PORT
end_ifdef

begin_function
name|void
name|process_refclock_packet
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rb
parameter_list|)
block|{
name|struct
name|refclockio
modifier|*
name|rio
decl_stmt|;
comment|/* get the refclockio structure from the receive buffer */
name|rio
operator|=
operator|&
name|rb
operator|->
name|recv_peer
operator|->
name|procptr
operator|->
name|io
expr_stmt|;
comment|/* call 'clock_recv' if either there is no input function or the 	 * raw input function tells us to feed the packet to the 	 * receiver. 	 */
if|if
condition|(
name|rio
operator|->
name|io_input
operator|==
name|NULL
operator|||
call|(
modifier|*
name|rio
operator|->
name|io_input
call|)
argument_list|(
name|rb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rio
operator|->
name|recvcount
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
name|handler_pkts
operator|++
expr_stmt|;
call|(
modifier|*
name|rio
operator|->
name|clock_recv
call|)
argument_list|(
name|rb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_IO_COMPLETION_PORT */
end_comment

begin_comment
comment|/*  * The following code does not apply to WINNT& VMS ...  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
end_if

begin_comment
comment|/*  * refclock_open - open serial port for reference clock  *  * This routine opens a serial port for I/O and sets default options. It  * returns the file descriptor if successful, or logs an error and  * returns -1.  */
end_comment

begin_function
name|int
name|refclock_open
parameter_list|(
name|char
modifier|*
name|dev
parameter_list|,
comment|/* device name pointer */
name|u_int
name|speed
parameter_list|,
comment|/* serial port speed (code) */
name|u_int
name|lflags
comment|/* line discipline flags */
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|int
name|omode
decl_stmt|;
ifdef|#
directive|ifdef
name|O_NONBLOCK
name|char
name|trash
index|[
literal|128
index|]
decl_stmt|;
comment|/* litter bin for old input data */
endif|#
directive|endif
comment|/* 	 * Open serial port and set default options 	 */
name|omode
operator|=
name|O_RDWR
expr_stmt|;
ifdef|#
directive|ifdef
name|O_NONBLOCK
name|omode
operator||=
name|O_NONBLOCK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NOCTTY
name|omode
operator||=
name|O_NOCTTY
expr_stmt|;
endif|#
directive|endif
name|fd
operator|=
name|open
argument_list|(
name|dev
argument_list|,
name|omode
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
comment|/* refclock_open() long returned 0 on failure, avoid it. */
if|if
condition|(
literal|0
operator|==
name|fd
condition|)
block|{
name|fd
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SAVE_ERRNO
argument_list|(
argument|close(
literal|0
argument|);
argument_list|)
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"refclock_open %s: %m"
argument|, dev);
argument_list|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|refclock_setup
argument_list|(
name|fd
argument_list|,
name|speed
argument_list|,
name|lflags
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|refclock_ioctl
argument_list|(
name|fd
argument_list|,
name|lflags
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|O_NONBLOCK
comment|/* 	 * We want to make sure there is no pending trash in the input 	 * buffer. Since we have non-blocking IO available, this is a 	 * good moment to read and dump all available outdated stuff 	 * that might have become toxic for the driver. 	 */
while|while
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|trash
argument_list|,
sizeof|sizeof
argument_list|(
name|trash
argument_list|)
argument_list|)
operator|>
literal|0
operator|||
name|errno
operator|==
name|EINTR
condition|)
comment|/*NOP*/
empty_stmt|;
endif|#
directive|endif
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_setup - initialize terminal interface structure  */
end_comment

begin_function
name|int
name|refclock_setup
parameter_list|(
name|int
name|fd
parameter_list|,
comment|/* file descriptor */
name|u_int
name|speed
parameter_list|,
comment|/* serial port speed (code) */
name|u_int
name|lflags
comment|/* line discipline flags */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|TTY
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
comment|/* 	 * By default, the serial line port is initialized in canonical 	 * (line-oriented) mode at specified line speed, 8 bits and no 	 * parity. LF ends the line and CR is mapped to LF. The break, 	 * erase and kill functions are disabled. There is a different 	 * section for each terminal interface, as selected at compile 	 * time. The flag bits can be used to set raw mode and echo. 	 */
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
comment|/* 	 * POSIX serial line parameters (termios interface) 	 */
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"refclock_setup fd %d tcgetattr: %m"
argument|, 				fd);
argument_list|)
return|return
name|FALSE
return|;
block|}
comment|/* 	 * Set canonical mode and local connection; set specified speed, 	 * 8 bits and no parity; map CR to NL; ignore break. 	 */
if|if
condition|(
name|speed
condition|)
block|{
name|u_int
name|ltemp
init|=
literal|0
decl_stmt|;
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
if|if
condition|(
name|lflags
operator|&
name|LDISC_7O1
condition|)
block|{
comment|/* HP Z3801A needs 7-bit, odd parity */
name|ttyp
operator|->
name|c_cflag
operator|=
name|CS7
operator||
name|PARENB
operator||
name|PARODD
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
block|}
name|cfsetispeed
argument_list|(
operator|&
name|ttyb
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|ttyb
argument_list|,
name|speed
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCCS
condition|;
operator|++
name|i
control|)
name|ttyp
operator|->
name|c_cc
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCMGET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCO5_CLOCK
argument_list|)
comment|/* 		 * If we have modem control, check to see if modem leads 		 * are active; if so, set remote connection. This is 		 * necessary for the kernel pps mods to work. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ltemp
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_setup fd %d TIOCMGET: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_setup fd %d modem status: 0x%x\n"
argument_list|,
name|fd
argument_list|,
name|ltemp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ltemp
operator|&
name|TIOCM_DSR
operator|&&
name|lflags
operator|&
name|LDISC_REMOTE
condition|)
name|ttyp
operator|->
name|c_cflag
operator|&=
operator|~
name|CLOCAL
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCMGET */
block|}
comment|/* 	 * Set raw and echo modes. These can be changed on-fly. 	 */
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
if|if
condition|(
name|lflags
operator|&
name|LDISC_RAW
condition|)
block|{
name|ttyp
operator|->
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lflags
operator|&
name|LDISC_ECHO
condition|)
name|ttyp
operator|->
name|c_lflag
operator||=
name|ECHO
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"refclock_setup fd %d TCSANOW: %m"
argument|, 				fd);
argument_list|)
return|return
name|FALSE
return|;
block|}
comment|/* 	 * flush input and output buffers to discard any outdated stuff 	 * that might have become toxic for the driver. Failing to do so 	 * is logged, but we keep our fingers crossed otherwise. 	 */
if|if
condition|(
name|tcflush
argument_list|(
name|fd
argument_list|,
name|TCIOFLUSH
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_setup fd %d tcflush(): %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
comment|/* 	 * System V serial line parameters (termio interface) 	 * 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCGETA
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"refclock_setup fd %d TCGETA: %m"
argument|, 				fd);
argument_list|)
return|return
name|FALSE
return|;
block|}
comment|/* 	 * Set canonical mode and local connection; set specified speed, 	 * 8 bits and no parity; map CR to NL; ignore break. 	 */
if|if
condition|(
name|speed
condition|)
block|{
name|u_int
name|ltemp
init|=
literal|0
decl_stmt|;
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|speed
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCCS
condition|;
operator|++
name|i
control|)
name|ttyp
operator|->
name|c_cc
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCMGET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCO5_CLOCK
argument_list|)
comment|/* 		 * If we have modem control, check to see if modem leads 		 * are active; if so, set remote connection. This is 		 * necessary for the kernel pps mods to work. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ltemp
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_setup fd %d TIOCMGET: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_setup fd %d modem status: %x\n"
argument_list|,
name|fd
argument_list|,
name|ltemp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ltemp
operator|&
name|TIOCM_DSR
condition|)
name|ttyp
operator|->
name|c_cflag
operator|&=
operator|~
name|CLOCAL
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCMGET */
block|}
comment|/* 	 * Set raw and echo modes. These can be changed on-fly. 	 */
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
if|if
condition|(
name|lflags
operator|&
name|LDISC_RAW
condition|)
block|{
name|ttyp
operator|->
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCSETA
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"refclock_setup fd %d TCSETA: %m"
argument|, fd);
argument_list|)
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
ifdef|#
directive|ifdef
name|HAVE_BSD_TTYS
comment|/* 	 * 4.3bsd serial line parameters (sgttyb interface) 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"refclock_setup fd %d TIOCGETP: %m"
argument|, 				fd);
argument_list|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|speed
condition|)
name|ttyp
operator|->
name|sg_ispeed
operator|=
name|ttyp
operator|->
name|sg_ospeed
operator|=
name|speed
expr_stmt|;
name|ttyp
operator|->
name|sg_flags
operator|=
name|EVENP
operator||
name|ODDP
operator||
name|CRMOD
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"refclock_setup TIOCSETP: %m"
argument|);
argument_list|)
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TERMIOS || HAVE_SYSV_TTYS || HAVE_BSD_TTYS */
end_comment

begin_comment
comment|/*  * refclock_ioctl - set serial port control functions  *  * This routine attempts to hide the internal, system-specific details  * of serial ports. It can handle POSIX (termios), SYSV (termio) and BSD  * (sgtty) interfaces with varying degrees of success. The routine sets  * up optional features such as tty_clk. The routine returns TRUE if  * successful.  */
end_comment

begin_function
name|int
name|refclock_ioctl
parameter_list|(
name|int
name|fd
parameter_list|,
comment|/* file descriptor */
name|u_int
name|lflags
comment|/* line discipline flags */
parameter_list|)
block|{
comment|/* 	 * simply return TRUE if no UNIX line discipline is supported 	 */
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"refclock_ioctl: fd %d flags 0x%x\n"
operator|,
name|fd
operator|,
name|lflags
operator|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(SYS_VXWORKS)&& !defined(SYS_WINNT) */
end_comment

begin_comment
comment|/*  * refclock_control - set and/or return clock values  *  * This routine is used mainly for debugging. It returns designated  * values from the interface structure that can be displayed using  * ntpdc and the clockstat command. It can also be used to initialize  * configuration variables, such as fudgetimes, fudgevalues, reference  * ID and stratum.  */
end_comment

begin_function
name|void
name|refclock_control
parameter_list|(
name|sockaddr_u
modifier|*
name|srcadr
parameter_list|,
specifier|const
name|struct
name|refclockstat
modifier|*
name|in
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Check for valid address and running peer 	 */
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
name|srcadr
argument_list|)
condition|)
return|return;
name|clktype
operator|=
operator|(
name|u_char
operator|)
name|REFCLOCKTYPE
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
name|unit
operator|=
name|REFCLOCKUNIT
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
name|peer
operator|=
name|findexistingpeer
argument_list|(
name|srcadr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|peer
condition|)
return|return;
name|NTP_INSIST
argument_list|(
name|peer
operator|->
name|procptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
comment|/* 	 * Initialize requested data 	 */
if|if
condition|(
name|in
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
condition|)
name|pp
operator|->
name|fudgetime1
operator|=
name|in
operator|->
name|fudgetime1
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME2
condition|)
name|pp
operator|->
name|fudgetime2
operator|=
name|in
operator|->
name|fudgetime2
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
condition|)
name|peer
operator|->
name|stratum
operator|=
name|pp
operator|->
name|stratum
operator|=
operator|(
name|u_char
operator|)
name|in
operator|->
name|fudgeval1
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL2
condition|)
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
operator|=
name|in
operator|->
name|fudgeval2
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG1
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG1
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG1
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG2
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG2
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG2
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG3
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG3
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG3
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG4
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG4
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG4
expr_stmt|;
block|}
block|}
comment|/* 	 * Readback requested data 	 */
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
block|{
name|out
operator|->
name|fudgeval1
operator|=
name|pp
operator|->
name|stratum
expr_stmt|;
name|out
operator|->
name|fudgeval2
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
name|out
operator|->
name|haveflags
operator|=
name|CLK_HAVEVAL1
operator||
name|CLK_HAVEVAL2
expr_stmt|;
name|out
operator|->
name|fudgetime1
operator|=
name|pp
operator|->
name|fudgetime1
expr_stmt|;
if|if
condition|(
literal|0.0
operator|!=
name|out
operator|->
name|fudgetime1
condition|)
name|out
operator|->
name|haveflags
operator||=
name|CLK_HAVETIME1
expr_stmt|;
name|out
operator|->
name|fudgetime2
operator|=
name|pp
operator|->
name|fudgetime2
expr_stmt|;
if|if
condition|(
literal|0.0
operator|!=
name|out
operator|->
name|fudgetime2
condition|)
name|out
operator|->
name|haveflags
operator||=
name|CLK_HAVETIME2
expr_stmt|;
name|out
operator|->
name|flags
operator|=
operator|(
name|u_char
operator|)
name|pp
operator|->
name|sloppyclockflag
expr_stmt|;
if|if
condition|(
name|CLK_FLAG1
operator|&
name|out
operator|->
name|flags
condition|)
name|out
operator|->
name|haveflags
operator||=
name|CLK_HAVEFLAG1
expr_stmt|;
if|if
condition|(
name|CLK_FLAG2
operator|&
name|out
operator|->
name|flags
condition|)
name|out
operator|->
name|haveflags
operator||=
name|CLK_HAVEFLAG2
expr_stmt|;
if|if
condition|(
name|CLK_FLAG3
operator|&
name|out
operator|->
name|flags
condition|)
name|out
operator|->
name|haveflags
operator||=
name|CLK_HAVEFLAG3
expr_stmt|;
if|if
condition|(
name|CLK_FLAG4
operator|&
name|out
operator|->
name|flags
condition|)
name|out
operator|->
name|haveflags
operator||=
name|CLK_HAVEFLAG4
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
name|current_time
operator|-
name|pp
operator|->
name|timestarted
expr_stmt|;
name|out
operator|->
name|polls
operator|=
name|pp
operator|->
name|polls
expr_stmt|;
name|out
operator|->
name|noresponse
operator|=
name|pp
operator|->
name|noreply
expr_stmt|;
name|out
operator|->
name|badformat
operator|=
name|pp
operator|->
name|badformat
expr_stmt|;
name|out
operator|->
name|baddata
operator|=
name|pp
operator|->
name|baddata
expr_stmt|;
name|out
operator|->
name|lastevent
operator|=
name|pp
operator|->
name|lastevent
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|pp
operator|->
name|currentstatus
expr_stmt|;
name|out
operator|->
name|type
operator|=
name|pp
operator|->
name|type
expr_stmt|;
name|out
operator|->
name|clockdesc
operator|=
name|pp
operator|->
name|clockdesc
expr_stmt|;
name|out
operator|->
name|lencode
operator|=
operator|(
name|u_short
operator|)
name|pp
operator|->
name|lencode
expr_stmt|;
name|out
operator|->
name|p_lastcode
operator|=
name|pp
operator|->
name|a_lastcode
expr_stmt|;
block|}
comment|/* 	 * Give the stuff to the clock 	 */
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_control
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_control
operator|)
operator|(
name|unit
operator|,
name|in
operator|,
name|out
operator|,
name|peer
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_buginfo - return debugging info  *  * This routine is used mainly for debugging. It returns designated  * values from the interface structure that can be displayed using  * ntpdc and the clkbug command.  */
end_comment

begin_function
name|void
name|refclock_buginfo
parameter_list|(
name|sockaddr_u
modifier|*
name|srcadr
parameter_list|,
comment|/* clock address */
name|struct
name|refclockbug
modifier|*
name|bug
comment|/* output structure */
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unsigned
name|u
decl_stmt|;
comment|/* 	 * Check for valid address and peer structure 	 */
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
name|srcadr
argument_list|)
condition|)
return|return;
name|clktype
operator|=
operator|(
name|u_char
operator|)
name|REFCLOCKTYPE
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
name|unit
operator|=
name|REFCLOCKUNIT
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
name|peer
operator|=
name|findexistingpeer
argument_list|(
name|srcadr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|peer
operator|||
name|NULL
operator|==
name|peer
operator|->
name|procptr
condition|)
return|return;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
comment|/* 	 * Copy structure values 	 */
name|bug
operator|->
name|nvalues
operator|=
literal|8
expr_stmt|;
name|bug
operator|->
name|svalues
operator|=
literal|0x0000003f
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|0
index|]
operator|=
name|pp
operator|->
name|year
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|1
index|]
operator|=
name|pp
operator|->
name|day
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|2
index|]
operator|=
name|pp
operator|->
name|hour
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|3
index|]
operator|=
name|pp
operator|->
name|minute
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|4
index|]
operator|=
name|pp
operator|->
name|second
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|5
index|]
operator|=
name|pp
operator|->
name|nsec
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|6
index|]
operator|=
name|pp
operator|->
name|yearstart
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|7
index|]
operator|=
name|pp
operator|->
name|coderecv
expr_stmt|;
name|bug
operator|->
name|stimes
operator|=
literal|0xfffffffc
expr_stmt|;
name|bug
operator|->
name|times
index|[
literal|0
index|]
operator|=
name|pp
operator|->
name|lastref
expr_stmt|;
name|bug
operator|->
name|times
index|[
literal|1
index|]
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|2
init|;
name|u
operator|<
name|bug
operator|->
name|ntimes
condition|;
name|u
operator|++
control|)
name|DTOLFP
argument_list|(
name|pp
operator|->
name|filter
index|[
name|u
operator|-
literal|2
index|]
argument_list|,
operator|&
name|bug
operator|->
name|times
index|[
name|u
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Give the stuff to the clock 	 */
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_buginfo
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_buginfo
operator|)
operator|(
name|unit
operator|,
name|bug
operator|,
name|peer
operator|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_comment
comment|/*  * refclock_ppsapi - initialize/update ppsapi  *  * This routine is called after the fudge command to open the PPSAPI  * interface for later parameter setting after the fudge command.  */
end_comment

begin_function
name|int
name|refclock_ppsapi
parameter_list|(
name|int
name|fddev
parameter_list|,
comment|/* fd device */
name|struct
name|refclock_atom
modifier|*
name|ap
comment|/* atom structure pointer */
parameter_list|)
block|{
if|if
condition|(
name|ap
operator|->
name|handle
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|time_pps_create
argument_list|(
name|fddev
argument_list|,
operator|&
name|ap
operator|->
name|handle
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ppsapi: time_pps_create: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_params - set ppsapi parameters  *  * This routine is called to set the PPSAPI parameters after the fudge  * command.  */
end_comment

begin_function
name|int
name|refclock_params
parameter_list|(
name|int
name|mode
parameter_list|,
comment|/* mode bits */
name|struct
name|refclock_atom
modifier|*
name|ap
comment|/* atom structure pointer */
parameter_list|)
block|{
name|ZERO
argument_list|(
name|ap
operator|->
name|pps_params
argument_list|)
expr_stmt|;
name|ap
operator|->
name|pps_params
operator|.
name|api_version
operator|=
name|PPS_API_VERS_1
expr_stmt|;
comment|/* 	 * Solaris serial ports provide PPS pulse capture only on the 	 * assert edge. FreeBSD serial ports provide capture on the 	 * clear edge, while FreeBSD parallel ports provide capture 	 * on the assert edge. Your mileage may vary. 	 */
if|if
condition|(
name|mode
operator|&
name|CLK_FLAG2
condition|)
name|ap
operator|->
name|pps_params
operator|.
name|mode
operator|=
name|PPS_TSFMT_TSPEC
operator||
name|PPS_CAPTURECLEAR
expr_stmt|;
else|else
name|ap
operator|->
name|pps_params
operator|.
name|mode
operator|=
name|PPS_TSFMT_TSPEC
operator||
name|PPS_CAPTUREASSERT
expr_stmt|;
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|ap
operator|->
name|handle
argument_list|,
operator|&
name|ap
operator|->
name|pps_params
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_params: time_pps_setparams: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If flag3 is lit, select the kernel PPS if we can. 	 */
if|if
condition|(
name|mode
operator|&
name|CLK_FLAG3
condition|)
block|{
if|if
condition|(
name|time_pps_kcbind
argument_list|(
name|ap
operator|->
name|handle
argument_list|,
name|PPS_KC_HARDPPS
argument_list|,
name|ap
operator|->
name|pps_params
operator|.
name|mode
operator|&
operator|~
name|PPS_TSFMT_TSPEC
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_params: time_pps_kcbind: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hardpps_enable
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_pps - called once per second  *  * This routine is called once per second. It snatches the PPS  * timestamp from the kernel and saves the sign-extended fraction in  * a circular buffer for processing at the next poll event.  */
end_comment

begin_function
name|int
name|refclock_pps
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|struct
name|refclock_atom
modifier|*
name|ap
parameter_list|,
comment|/* atom structure pointer */
name|int
name|mode
comment|/* mode bits */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pps_info_t
name|pps_info
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
comment|/* 	 * We require the clock to be synchronized before setting the 	 * parameters. When the parameters have been set, fetch the 	 * most recent PPS timestamp. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|handle
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|pps_params
operator|.
name|mode
operator|==
literal|0
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
block|{
if|if
condition|(
name|refclock_params
argument_list|(
name|pp
operator|->
name|sloppyclockflag
argument_list|,
name|ap
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|ZERO
argument_list|(
name|pps_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_pps_fetch
argument_list|(
name|ap
operator|->
name|handle
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|pps_info
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|timeout
operator|=
name|ap
operator|->
name|ts
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|pps_params
operator|.
name|mode
operator|&
name|PPS_CAPTUREASSERT
condition|)
name|ap
operator|->
name|ts
operator|=
name|pps_info
operator|.
name|assert_timestamp
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|pps_params
operator|.
name|mode
operator|&
name|PPS_CAPTURECLEAR
condition|)
name|ap
operator|->
name|ts
operator|=
name|pps_info
operator|.
name|clear_timestamp
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
literal|0
operator|==
name|memcmp
argument_list|(
operator|&
name|timeout
argument_list|,
operator|&
name|ap
operator|->
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|timeout
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Convert to signed fraction offset and stuff in median filter. 	 */
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
operator|=
operator|(
name|u_int32
operator|)
name|ap
operator|->
name|ts
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|dtemp
operator|=
name|ap
operator|->
name|ts
operator|.
name|tv_nsec
operator|/
literal|1e9
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|.
name|l_uf
operator|=
call|(
name|u_int32
call|)
argument_list|(
name|dtemp
operator|*
name|FRAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
literal|.5
condition|)
name|dtemp
operator|-=
literal|1.
expr_stmt|;
name|SAMPLE
argument_list|(
operator|-
name|dtemp
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"refclock_pps: %lu %f %f\n"
argument_list|,
name|current_time
argument_list|,
name|dtemp
argument_list|,
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

