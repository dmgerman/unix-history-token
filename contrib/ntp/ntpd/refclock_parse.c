begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/ntp-4/ntpd/refclock_parse.c,v 4.36 1999/11/28 17:18:20 kardel RELEASE_19991128_A  *  * refclock_parse.c,v 4.36 1999/11/28 17:18:20 kardel RELEASE_19991128_A  *  * generic reference clock driver for receivers  *  * optionally make use of a STREAMS module for input processing where  * available and configured. Currently the STREAMS module  * is only available for Suns running SunOS 4.x and SunOS5.x  *  * the STREAMS module is not required for operation and may be omitted  * at the cost of reduced accuracy. As new kernel interfaces emerger this  * restriction may be lifted in future.  *  * Copyright (c) 1995-1999 by Frank Kardel<kardel@acm.org>  * Copyright (c) 1989-1994 by Frank Kardel, Friedrich-Alexander Universität Erlangen-Nürnberg, Germany  *  * This software may not be sold for profit without a written consent  * from the author.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_PARSE
argument_list|)
end_if

begin_comment
comment|/*  * This driver currently provides the support for  *   - Meinberg receiver DCF77 PZF 535 (TCXO version)       (DCF)  *   - Meinberg receiver DCF77 PZF 535 (OCXO version)       (DCF)  *   - Meinberg receiver DCF77 PZF 509                      (DCF)  *   - Meinberg receiver DCF77 AM receivers (e.g. C51)      (DCF)  *   - IGEL CLOCK                                           (DCF)  *   - ELV DCF7000                                          (DCF)  *   - Schmid clock                                         (DCF)  *   - Conrad DCF77 receiver module                         (DCF)  *   - FAU DCF77 NTP receiver (TimeBrick)                   (DCF)  *  *   - Meinberg GPS166/GPS167                               (GPS)  *   - Trimble (TSIP and TAIP protocol)                     (GPS)  *  *   - RCC8000 MSF Receiver                                 (MSF)  *   - WHARTON 400A Series clock			    (DCF)  *   - VARITEXT clock					    (MSF)  */
end_comment

begin_comment
comment|/*  * Meinberg receivers are usually connected via a  * 9600 baud serial line  *  * The Meinberg GPS receivers also have a special NTP time stamp  * format. The firmware release is Uni-Erlangen.  *  * Meinberg generic receiver setup:  *	output time code every second  *	Baud rate 9600 7E2S  *  * Meinberg GPS16x setup:  *      output time code every second  *      Baudrate 19200 8N1  *  * This software supports the standard data formats used  * in Meinberg receivers.  *  * Special software versions are only sensible for the  * GPS 16x family of receivers.  *  * Meinberg can be reached via: http://www.meinberg.de/  */
end_comment

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_comment
comment|/* includes<sys/time.h> */
end_comment

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TM_IN_SYS_TIME
end_ifndef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STREAM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"Bletch:  Define one of {STREAM,HAVE_SYSV_TTYS,HAVE_TERMIOS}"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STREAM
end_ifdef

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
end_ifdef

begin_define
define|#
directive|define
name|TTY_GETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|tcgetattr((_FD_), (_ARG_))
end_define

begin_define
define|#
directive|define
name|TTY_SETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|tcsetattr((_FD_), TCSANOW, (_ARG_))
end_define

begin_undef
undef|#
directive|undef
name|HAVE_SYSV_TTYS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
end_ifdef

begin_define
define|#
directive|define
name|TTY_GETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|ioctl((_FD_), TCGETA, (_ARG_))
end_define

begin_define
define|#
directive|define
name|TTY_SETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|ioctl((_FD_), TCSETAW, (_ARG_))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_BSD_TTYS
end_ifdef

begin_comment
comment|/* #error CURRENTLY NO BSD TTY SUPPORT */
end_comment

begin_include
include|#
directive|include
file|"Bletch: BSD TTY not currently supported"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PPS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PPSCLOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIO_SERIAL_STUFF
end_ifdef

begin_include
include|#
directive|include
file|<linux/serial.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"mbg_gps166.h"
end_include

begin_include
include|#
directive|include
file|"trimble.h"
end_include

begin_include
include|#
directive|include
file|"binio.h"
end_include

begin_include
include|#
directive|include
file|"ascii.h"
end_include

begin_include
include|#
directive|include
file|"ieee754io.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"refclock_parse.c,v 4.36 1999/11/28 17:18:20 kardel RELEASE_19991128_A"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**===========================================================================  ** external interface to ntp mechanism  **/
end_comment

begin_decl_stmt
specifier|static
name|void
name|parse_init
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_control
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|parse_buginfo
value|noentry
end_define

begin_decl_stmt
name|struct
name|refclock
name|refclock_parse
init|=
block|{
name|parse_start
block|,
name|parse_shutdown
block|,
name|parse_poll
block|,
name|parse_control
block|,
name|parse_init
block|,
name|parse_buginfo
block|,
name|NOFLAGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definitions  */
end_comment

begin_define
define|#
directive|define
name|MAXUNITS
value|4
end_define

begin_comment
comment|/* maximum number of "PARSE" units permitted */
end_comment

begin_define
define|#
directive|define
name|PARSEDEVICE
value|"/dev/refclock-%d"
end_define

begin_comment
comment|/* device to open %d is unit number */
end_comment

begin_undef
undef|#
directive|undef
name|ABS
end_undef

begin_define
define|#
directive|define
name|ABS
parameter_list|(
name|_X_
parameter_list|)
value|(((_X_)< 0) ? -(_X_) : (_X_))
end_define

begin_comment
comment|/**===========================================================================  ** function vector for dynamically binding io handling mechanism  **/
end_comment

begin_struct_decl
struct_decl|struct
name|parseunit
struct_decl|;
end_struct_decl

begin_comment
comment|/* to keep inquiring minds happy */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|bind
block|{
specifier|const
name|char
modifier|*
name|bd_description
decl_stmt|;
comment|/* name of type of binding */
name|int
argument_list|(
argument|*bd_init
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* initialize */
name|void
argument_list|(
argument|*bd_end
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* end */
name|int
argument_list|(
argument|*bd_setcs
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* set character size */
name|int
argument_list|(
argument|*bd_disable
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* disable */
name|int
argument_list|(
argument|*bd_enable
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* enable */
name|int
argument_list|(
argument|*bd_getfmt
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* get format */
name|int
argument_list|(
argument|*bd_setfmt
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* setfmt */
name|int
argument_list|(
argument|*bd_timecode
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* get time code */
name|void
argument_list|(
argument|*bd_receive
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* receive operation */
name|int
argument_list|(
argument|*bd_io_input
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* input operation */
block|}
name|bind_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|PARSE_END
parameter_list|(
name|_X_
parameter_list|)
value|(*(_X_)->binding->bd_end)(_X_)
end_define

begin_define
define|#
directive|define
name|PARSE_SETCS
parameter_list|(
name|_X_
parameter_list|,
name|_CS_
parameter_list|)
value|(*(_X_)->binding->bd_setcs)(_X_, _CS_)
end_define

begin_define
define|#
directive|define
name|PARSE_ENABLE
parameter_list|(
name|_X_
parameter_list|)
value|(*(_X_)->binding->bd_enable)(_X_)
end_define

begin_define
define|#
directive|define
name|PARSE_DISABLE
parameter_list|(
name|_X_
parameter_list|)
value|(*(_X_)->binding->bd_disable)(_X_)
end_define

begin_define
define|#
directive|define
name|PARSE_GETFMT
parameter_list|(
name|_X_
parameter_list|,
name|_DCT_
parameter_list|)
value|(*(_X_)->binding->bd_getfmt)(_X_, _DCT_)
end_define

begin_define
define|#
directive|define
name|PARSE_SETFMT
parameter_list|(
name|_X_
parameter_list|,
name|_DCT_
parameter_list|)
value|(*(_X_)->binding->bd_setfmt)(_X_, _DCT_)
end_define

begin_define
define|#
directive|define
name|PARSE_GETTIMECODE
parameter_list|(
name|_X_
parameter_list|,
name|_DCT_
parameter_list|)
value|(*(_X_)->binding->bd_timecode)(_X_, _DCT_)
end_define

begin_comment
comment|/*  * io modes  */
end_comment

begin_define
define|#
directive|define
name|PARSE_F_PPSPPS
value|0x0001
end_define

begin_comment
comment|/* use loopfilter PPS code (CIOGETEV) */
end_comment

begin_define
define|#
directive|define
name|PARSE_F_PPSONSECOND
value|0x0002
end_define

begin_comment
comment|/* PPS pulses are on second */
end_comment

begin_comment
comment|/**===========================================================================  ** error message regression handling  **  ** there are quite a few errors that can occur in rapid succession such as  ** noisy input data or no data at all. in order to reduce the amount of  ** syslog messages in such case, we are using a backoff algorithm. We limit  ** the number of error messages of a certain class to 1 per time unit. if a  ** configurable number of messages is displayed that way, we move on to the  ** next time unit / count for that class. a count of messages that have been  ** suppressed is held and displayed whenever a corresponding message is  ** displayed. the time units for a message class will also be displayed.  ** whenever an error condition clears we reset the error message state,  ** thus we would still generate much output on pathological conditions  ** where the system oscillates between OK and NOT OK states. coping  ** with that condition is currently considered too complicated.  **/
end_comment

begin_define
define|#
directive|define
name|ERR_ALL
value|(unsigned)~0
end_define

begin_comment
comment|/* "all" errors */
end_comment

begin_define
define|#
directive|define
name|ERR_BADDATA
value|(unsigned)0
end_define

begin_comment
comment|/* unusable input data/conversion errors */
end_comment

begin_define
define|#
directive|define
name|ERR_NODATA
value|(unsigned)1
end_define

begin_comment
comment|/* no input data */
end_comment

begin_define
define|#
directive|define
name|ERR_BADIO
value|(unsigned)2
end_define

begin_comment
comment|/* read/write/select errors */
end_comment

begin_define
define|#
directive|define
name|ERR_BADSTATUS
value|(unsigned)3
end_define

begin_comment
comment|/* unsync states */
end_comment

begin_define
define|#
directive|define
name|ERR_BADEVENT
value|(unsigned)4
end_define

begin_comment
comment|/* non nominal events */
end_comment

begin_define
define|#
directive|define
name|ERR_INTERNAL
value|(unsigned)5
end_define

begin_comment
comment|/* internal error */
end_comment

begin_define
define|#
directive|define
name|ERR_CNT
value|(unsigned)(ERR_INTERNAL+1)
end_define

begin_define
define|#
directive|define
name|ERR
parameter_list|(
name|_X_
parameter_list|)
value|if (list_err(parse, (_X_)))
end_define

begin_struct
struct|struct
name|errorregression
block|{
name|u_long
name|err_count
decl_stmt|;
comment|/* number of repititions per class */
name|u_long
name|err_delay
decl_stmt|;
comment|/* minimum delay between messages */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|errorregression
name|err_baddata
index|[]
init|=
comment|/* error messages for bad input data */
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
comment|/* output first message immediately */
block|{
literal|5
block|,
literal|60
block|}
block|,
comment|/* output next five messages in 60 second intervals */
block|{
literal|3
block|,
literal|3600
block|}
block|,
comment|/* output next 3 messages in hour intervals */
block|{
literal|0
block|,
literal|12
operator|*
literal|3600
block|}
comment|/* repeat messages only every 12 hours */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|errorregression
name|err_nodata
index|[]
init|=
comment|/* error messages for missing input data */
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
comment|/* output first message immediately */
block|{
literal|5
block|,
literal|60
block|}
block|,
comment|/* output next five messages in 60 second intervals */
block|{
literal|3
block|,
literal|3600
block|}
block|,
comment|/* output next 3 messages in hour intervals */
block|{
literal|0
block|,
literal|12
operator|*
literal|3600
block|}
comment|/* repeat messages only every 12 hours */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|errorregression
name|err_badstatus
index|[]
init|=
comment|/* unsynchronized state messages */
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
comment|/* output first message immediately */
block|{
literal|5
block|,
literal|60
block|}
block|,
comment|/* output next five messages in 60 second intervals */
block|{
literal|3
block|,
literal|3600
block|}
block|,
comment|/* output next 3 messages in hour intervals */
block|{
literal|0
block|,
literal|12
operator|*
literal|3600
block|}
comment|/* repeat messages only every 12 hours */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|errorregression
name|err_badio
index|[]
init|=
comment|/* io failures (bad reads, selects, ...) */
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
comment|/* output first message immediately */
block|{
literal|5
block|,
literal|60
block|}
block|,
comment|/* output next five messages in 60 second intervals */
block|{
literal|5
block|,
literal|3600
block|}
block|,
comment|/* output next 3 messages in hour intervals */
block|{
literal|0
block|,
literal|12
operator|*
literal|3600
block|}
comment|/* repeat messages only every 12 hours */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|errorregression
name|err_badevent
index|[]
init|=
comment|/* non nominal events */
block|{
block|{
literal|20
block|,
literal|0
block|}
block|,
comment|/* output first message immediately */
block|{
literal|6
block|,
literal|60
block|}
block|,
comment|/* output next five messages in 60 second intervals */
block|{
literal|5
block|,
literal|3600
block|}
block|,
comment|/* output next 3 messages in hour intervals */
block|{
literal|0
block|,
literal|12
operator|*
literal|3600
block|}
comment|/* repeat messages only every 12 hours */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|errorregression
name|err_internal
index|[]
init|=
comment|/* really bad things - basically coding/OS errors */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* output all messages immediately */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|errorregression
modifier|*
name|err_tbl
index|[]
init|=
block|{
name|err_baddata
block|,
name|err_nodata
block|,
name|err_badio
block|,
name|err_badstatus
block|,
name|err_badevent
block|,
name|err_internal
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|errorinfo
block|{
name|u_long
name|err_started
decl_stmt|;
comment|/* begin time (ntp) of error condition */
name|u_long
name|err_last
decl_stmt|;
comment|/* last time (ntp) error occurred */
name|u_long
name|err_cnt
decl_stmt|;
comment|/* number of error repititions */
name|u_long
name|err_suppressed
decl_stmt|;
comment|/* number of suppressed messages */
name|struct
name|errorregression
modifier|*
name|err_stage
decl_stmt|;
comment|/* current error stage */
block|}
struct|;
end_struct

begin_comment
comment|/**===========================================================================  ** refclock instance data  **/
end_comment

begin_struct
struct|struct
name|parseunit
block|{
comment|/* 	 * NTP management 	 */
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* backlink to peer structure - refclock inactive if 0  */
name|struct
name|refclockproc
modifier|*
name|generic
decl_stmt|;
comment|/* backlink to refclockproc structure */
comment|/* 	 * PARSE io 	 */
name|bind_t
modifier|*
name|binding
decl_stmt|;
comment|/* io handling binding */
comment|/* 	 * parse state 	 */
name|parse_t
name|parseio
decl_stmt|;
comment|/* io handling structure (user level parsing) */
comment|/* 	 * type specific parameters 	 */
name|struct
name|parse_clockinfo
modifier|*
name|parse_type
decl_stmt|;
comment|/* link to clock description */
comment|/* 	 * clock state handling/reporting 	 */
name|u_char
name|flags
decl_stmt|;
comment|/* flags (leap_control) */
name|u_long
name|lastchange
decl_stmt|;
comment|/* time (ntp) when last state change accured */
name|u_long
name|statetime
index|[
name|CEVNT_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* accumulated time of clock states */
name|u_long
name|pollneeddata
decl_stmt|;
comment|/* current_time(!=0) for receive sample expected in PPS mode */
name|u_short
name|lastformat
decl_stmt|;
comment|/* last format used */
name|u_long
name|lastsync
decl_stmt|;
comment|/* time (ntp) when clock was last seen fully synchronized */
name|u_long
name|lastmissed
decl_stmt|;
comment|/* time (ntp) when poll didn't get data (powerup heuristic) */
name|u_long
name|ppsserial
decl_stmt|;
comment|/* magic cookie for ppsclock serials (avoids stale ppsclock data) */
name|parsetime_t
name|time
decl_stmt|;
comment|/* last (parse module) data */
name|void
modifier|*
name|localdata
decl_stmt|;
comment|/* optional local, receiver-specific data */
name|unsigned
name|long
name|localstate
decl_stmt|;
comment|/* private local state */
name|struct
name|errorinfo
name|errors
index|[
name|ERR_CNT
index|]
decl_stmt|;
comment|/* error state table for suppressing excessive error messages */
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
comment|/* additional pseudo variables */
name|u_long
name|laststatistic
decl_stmt|;
comment|/* time when staticstics where output */
block|}
struct|;
end_struct

begin_comment
comment|/**===========================================================================  ** Clockinfo section all parameter for specific clock types  ** includes NTP parameters, TTY parameters and IO handling parameters  **/
end_comment

begin_decl_stmt
specifier|static
name|void
name|poll_dpoll
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|poll_poll
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|poll_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|poll_info
block|{
name|u_long
name|rate
decl_stmt|;
comment|/* poll rate - once every "rate" seconds - 0 off */
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
comment|/* string to send for polling */
name|u_long
name|count
decl_stmt|;
comment|/* number of characters in string */
block|}
name|poll_info_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NO_CL_FLAGS
value|0
end_define

begin_define
define|#
directive|define
name|NO_POLL
value|0
end_define

begin_define
define|#
directive|define
name|NO_INIT
value|0
end_define

begin_define
define|#
directive|define
name|NO_END
value|0
end_define

begin_define
define|#
directive|define
name|NO_EVENT
value|0
end_define

begin_define
define|#
directive|define
name|NO_DATA
value|0
end_define

begin_define
define|#
directive|define
name|NO_MESSAGE
value|0
end_define

begin_define
define|#
directive|define
name|NO_PPSDELAY
value|0
end_define

begin_define
define|#
directive|define
name|DCF_ID
value|"DCF"
end_define

begin_comment
comment|/* generic DCF */
end_comment

begin_define
define|#
directive|define
name|DCF_A_ID
value|"DCFa"
end_define

begin_comment
comment|/* AM demodulation */
end_comment

begin_define
define|#
directive|define
name|DCF_P_ID
value|"DCFp"
end_define

begin_comment
comment|/* psuedo random phase shift */
end_comment

begin_define
define|#
directive|define
name|GPS_ID
value|"GPS"
end_define

begin_comment
comment|/* GPS receiver */
end_comment

begin_define
define|#
directive|define
name|NOCLOCK_ROOTDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_BASEDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_DESCRIPTION
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_MAXUNSYNC
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_CFLAG
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_IFLAG
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_LFLAG
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_ID
value|"TILT"
end_define

begin_define
define|#
directive|define
name|NOCLOCK_POLL
value|NO_POLL
end_define

begin_define
define|#
directive|define
name|NOCLOCK_INIT
value|NO_INIT
end_define

begin_define
define|#
directive|define
name|NOCLOCK_END
value|NO_END
end_define

begin_define
define|#
directive|define
name|NOCLOCK_DATA
value|NO_DATA
end_define

begin_define
define|#
directive|define
name|NOCLOCK_FORMAT
value|""
end_define

begin_define
define|#
directive|define
name|NOCLOCK_TYPE
value|CTL_SST_TS_UNSPEC
end_define

begin_define
define|#
directive|define
name|NOCLOCK_SAMPLES
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_KEEP
value|0
end_define

begin_define
define|#
directive|define
name|DCF_TYPE
value|CTL_SST_TS_LF
end_define

begin_define
define|#
directive|define
name|GPS_TYPE
value|CTL_SST_TS_UHF
end_define

begin_comment
comment|/*  * receiver specific constants  */
end_comment

begin_define
define|#
directive|define
name|MBG_SPEED
value|(B9600)
end_define

begin_define
define|#
directive|define
name|MBG_CFLAG
value|(CS7|PARENB|CREAD|CLOCAL|HUPCL)
end_define

begin_define
define|#
directive|define
name|MBG_IFLAG
value|(IGNBRK|IGNPAR|ISTRIP)
end_define

begin_define
define|#
directive|define
name|MBG_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|MBG_LFLAG
value|0
end_define

begin_define
define|#
directive|define
name|MBG_FLAGS
value|PARSE_F_PPSONSECOND
end_define

begin_comment
comment|/*  * Meinberg DCF77 receivers  */
end_comment

begin_define
define|#
directive|define
name|DCFUA31_ROOTDELAY
value|0.0
end_define

begin_comment
comment|/* 0 */
end_comment

begin_define
define|#
directive|define
name|DCFUA31_BASEDELAY
value|0.010
end_define

begin_comment
comment|/* 10.7421875ms: 10 ms (+/- 3 ms) */
end_comment

begin_define
define|#
directive|define
name|DCFUA31_DESCRIPTION
value|"Meinberg DCF77 C51 or compatible"
end_define

begin_define
define|#
directive|define
name|DCFUA31_MAXUNSYNC
value|60*30
end_define

begin_comment
comment|/* only trust clock for 1/2 hour */
end_comment

begin_define
define|#
directive|define
name|DCFUA31_SPEED
value|MBG_SPEED
end_define

begin_define
define|#
directive|define
name|DCFUA31_CFLAG
value|MBG_CFLAG
end_define

begin_define
define|#
directive|define
name|DCFUA31_IFLAG
value|MBG_IFLAG
end_define

begin_define
define|#
directive|define
name|DCFUA31_OFLAG
value|MBG_OFLAG
end_define

begin_define
define|#
directive|define
name|DCFUA31_LFLAG
value|MBG_LFLAG
end_define

begin_define
define|#
directive|define
name|DCFUA31_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|DCFUA31_KEEP
value|3
end_define

begin_define
define|#
directive|define
name|DCFUA31_FORMAT
value|"Meinberg Standard"
end_define

begin_comment
comment|/*  * Meinberg DCF PZF535/TCXO (FM/PZF) receiver  */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535_ROOTDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|DCFPZF535_BASEDELAY
value|0.001968
end_define

begin_comment
comment|/* 1.968ms +- 104us (oscilloscope) - relative to start (end of STX) */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535_DESCRIPTION
value|"Meinberg DCF PZF 535/509 / TCXO"
end_define

begin_define
define|#
directive|define
name|DCFPZF535_MAXUNSYNC
value|60*60*12
end_define

begin_comment
comment|/* only trust clock for 12 hours 						    * @ 5e-8df/f we have accumulated 						    * at most 2.16 ms (thus we move to 						    * NTP synchronisation */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535_SPEED
value|MBG_SPEED
end_define

begin_define
define|#
directive|define
name|DCFPZF535_CFLAG
value|MBG_CFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535_IFLAG
value|MBG_IFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535_OFLAG
value|MBG_OFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535_LFLAG
value|MBG_LFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|DCFPZF535_KEEP
value|3
end_define

begin_define
define|#
directive|define
name|DCFPZF535_FORMAT
value|"Meinberg Standard"
end_define

begin_comment
comment|/*  * Meinberg DCF PZF535/OCXO receiver  */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535OCXO_ROOTDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_BASEDELAY
value|0.001968
end_define

begin_comment
comment|/* 1.968ms +- 104us (oscilloscope) - relative to start (end of STX) */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535OCXO_DESCRIPTION
value|"Meinberg DCF PZF 535/509 / OCXO"
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_MAXUNSYNC
value|60*60*96
end_define

begin_comment
comment|/* only trust clock for 4 days 						    * @ 5e-9df/f we have accumulated 						    * at most an error of 1.73 ms 						    * (thus we move to NTP synchronisation) */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535OCXO_SPEED
value|MBG_SPEED
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_CFLAG
value|MBG_CFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_IFLAG
value|MBG_IFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_OFLAG
value|MBG_OFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_LFLAG
value|MBG_LFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_KEEP
value|3
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_FORMAT
value|"Meinberg Standard"
end_define

begin_comment
comment|/*  * Meinberg GPS16X receiver  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|gps16x_message
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsetime_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gps16x_poll_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GPS16X_ROOTDELAY
value|0.0
end_define

begin_comment
comment|/* nothing here */
end_comment

begin_define
define|#
directive|define
name|GPS16X_BASEDELAY
value|0.001968
end_define

begin_comment
comment|/* XXX to be fixed ! 1.968ms +- 104us (oscilloscope) - relative to start (end of STX) */
end_comment

begin_define
define|#
directive|define
name|GPS16X_DESCRIPTION
value|"Meinberg GPS16x receiver"
end_define

begin_define
define|#
directive|define
name|GPS16X_MAXUNSYNC
value|60*60*96
end_define

begin_comment
comment|/* only trust clock for 4 days 						* @ 5e-9df/f we have accumulated 						* at most an error of 1.73 ms 						* (thus we move to NTP synchronisation) */
end_comment

begin_define
define|#
directive|define
name|GPS16X_SPEED
value|B19200
end_define

begin_define
define|#
directive|define
name|GPS16X_CFLAG
value|(CS8|CREAD|CLOCAL|HUPCL)
end_define

begin_define
define|#
directive|define
name|GPS16X_IFLAG
value|(IGNBRK|IGNPAR)
end_define

begin_define
define|#
directive|define
name|GPS16X_OFLAG
value|MBG_OFLAG
end_define

begin_define
define|#
directive|define
name|GPS16X_LFLAG
value|MBG_LFLAG
end_define

begin_define
define|#
directive|define
name|GPS16X_POLLRATE
value|6
end_define

begin_define
define|#
directive|define
name|GPS16X_POLLCMD
value|""
end_define

begin_define
define|#
directive|define
name|GPS16X_CMDSIZE
value|0
end_define

begin_decl_stmt
specifier|static
name|poll_info_t
name|gps16x_pollinfo
init|=
block|{
name|GPS16X_POLLRATE
block|,
name|GPS16X_POLLCMD
block|,
name|GPS16X_CMDSIZE
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GPS16X_INIT
value|gps16x_poll_init
end_define

begin_define
define|#
directive|define
name|GPS16X_POLL
value|0
end_define

begin_define
define|#
directive|define
name|GPS16X_END
value|0
end_define

begin_define
define|#
directive|define
name|GPS16X_DATA
value|((void *)(&gps16x_pollinfo))
end_define

begin_define
define|#
directive|define
name|GPS16X_MESSAGE
value|gps16x_message
end_define

begin_define
define|#
directive|define
name|GPS16X_ID
value|GPS_ID
end_define

begin_define
define|#
directive|define
name|GPS16X_FORMAT
value|"Meinberg GPS Extended"
end_define

begin_define
define|#
directive|define
name|GPS16X_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|GPS16X_KEEP
value|3
end_define

begin_comment
comment|/*  * ELV DCF7000 Wallclock-Receiver/Switching Clock (Kit)  *  * This is really not the hottest clock - but before you have nothing ...  */
end_comment

begin_define
define|#
directive|define
name|DCF7000_ROOTDELAY
value|0.0
end_define

begin_comment
comment|/* 0 */
end_comment

begin_define
define|#
directive|define
name|DCF7000_BASEDELAY
value|0.405
end_define

begin_comment
comment|/* slow blow */
end_comment

begin_define
define|#
directive|define
name|DCF7000_DESCRIPTION
value|"ELV DCF7000"
end_define

begin_define
define|#
directive|define
name|DCF7000_MAXUNSYNC
value|(60*5)
end_define

begin_comment
comment|/* sorry - but it just was not build as a clock */
end_comment

begin_define
define|#
directive|define
name|DCF7000_SPEED
value|(B9600)
end_define

begin_define
define|#
directive|define
name|DCF7000_CFLAG
value|(CS8|CREAD|PARENB|PARODD|CLOCAL|HUPCL)
end_define

begin_define
define|#
directive|define
name|DCF7000_IFLAG
value|(IGNBRK)
end_define

begin_define
define|#
directive|define
name|DCF7000_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|DCF7000_LFLAG
value|0
end_define

begin_define
define|#
directive|define
name|DCF7000_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|DCF7000_KEEP
value|3
end_define

begin_define
define|#
directive|define
name|DCF7000_FORMAT
value|"ELV DCF7000"
end_define

begin_comment
comment|/*  * Schmid DCF Receiver Kit  *  * When the WSDCF clock is operating optimally we want the primary clock  * distance to come out at 300 ms.  Thus, peer.distance in the WSDCF peer  * structure is set to 290 ms and we compute delays which are at least  * 10 ms long.  The following are 290 ms and 10 ms expressed in u_fp format  */
end_comment

begin_define
define|#
directive|define
name|WS_POLLRATE
value|1
end_define

begin_comment
comment|/* every second - watch interdependency with poll routine */
end_comment

begin_define
define|#
directive|define
name|WS_POLLCMD
value|"\163"
end_define

begin_define
define|#
directive|define
name|WS_CMDSIZE
value|1
end_define

begin_decl_stmt
specifier|static
name|poll_info_t
name|wsdcf_pollinfo
init|=
block|{
name|WS_POLLRATE
block|,
name|WS_POLLCMD
block|,
name|WS_CMDSIZE
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WSDCF_INIT
value|poll_init
end_define

begin_define
define|#
directive|define
name|WSDCF_POLL
value|poll_dpoll
end_define

begin_define
define|#
directive|define
name|WSDCF_END
value|0
end_define

begin_define
define|#
directive|define
name|WSDCF_DATA
value|((void *)(&wsdcf_pollinfo))
end_define

begin_define
define|#
directive|define
name|WSDCF_ROOTDELAY
value|0.0
end_define

begin_comment
comment|/* 0 */
end_comment

begin_define
define|#
directive|define
name|WSDCF_BASEDELAY
value|0.010
end_define

begin_comment
comment|/*  ~  10ms */
end_comment

begin_define
define|#
directive|define
name|WSDCF_DESCRIPTION
value|"WS/DCF Receiver"
end_define

begin_define
define|#
directive|define
name|WSDCF_FORMAT
value|"Schmid"
end_define

begin_define
define|#
directive|define
name|WSDCF_MAXUNSYNC
value|(60*60)
end_define

begin_comment
comment|/* assume this beast hold at 1 h better than 2 ms XXX-must verify */
end_comment

begin_define
define|#
directive|define
name|WSDCF_SPEED
value|(B1200)
end_define

begin_define
define|#
directive|define
name|WSDCF_CFLAG
value|(CS8|CREAD|CLOCAL)
end_define

begin_define
define|#
directive|define
name|WSDCF_IFLAG
value|0
end_define

begin_define
define|#
directive|define
name|WSDCF_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|WSDCF_LFLAG
value|0
end_define

begin_define
define|#
directive|define
name|WSDCF_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|WSDCF_KEEP
value|3
end_define

begin_comment
comment|/*  * RAW DCF77 - input of DCF marks via RS232 - many variants  */
end_comment

begin_define
define|#
directive|define
name|RAWDCF_FLAGS
value|0
end_define

begin_define
define|#
directive|define
name|RAWDCF_ROOTDELAY
value|0.0
end_define

begin_comment
comment|/* 0 */
end_comment

begin_define
define|#
directive|define
name|RAWDCF_BASEDELAY
value|0.258
end_define

begin_define
define|#
directive|define
name|RAWDCF_FORMAT
value|"RAW DCF77 Timecode"
end_define

begin_define
define|#
directive|define
name|RAWDCF_MAXUNSYNC
value|(0)
end_define

begin_comment
comment|/* sorry - its a true receiver - no signal - no time */
end_comment

begin_define
define|#
directive|define
name|RAWDCF_SPEED
value|(B50)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NO_PARENB_IGNPAR
end_ifdef

begin_comment
comment|/* Was: defined(SYS_IRIX4) || defined(SYS_IRIX5) */
end_comment

begin_comment
comment|/* somehow doesn't grok PARENB& IGNPAR (mj) */
end_comment

begin_define
define|#
directive|define
name|RAWDCF_CFLAG
value|(CS8|CREAD|CLOCAL)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAWDCF_CFLAG
value|(CS8|CREAD|CLOCAL|PARENB)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RAWDCF_NO_IGNPAR
end_ifdef

begin_comment
comment|/* Was: defined(SYS_LINUX)&& defined(CLOCK_RAWDCF) */
end_comment

begin_define
define|#
directive|define
name|RAWDCF_IFLAG
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAWDCF_IFLAG
value|(IGNPAR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAWDCF_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|RAWDCF_LFLAG
value|0
end_define

begin_define
define|#
directive|define
name|RAWDCF_SAMPLES
value|20
end_define

begin_define
define|#
directive|define
name|RAWDCF_KEEP
value|12
end_define

begin_define
define|#
directive|define
name|RAWDCF_INIT
value|0
end_define

begin_comment
comment|/*  * RAW DCF variants  */
end_comment

begin_comment
comment|/*  * Conrad receiver  *  * simplest (cheapest) DCF clock - e. g. DCF77 receiver by Conrad  * (~40DM - roughly $30 ) followed by a level converter for RS232  */
end_comment

begin_define
define|#
directive|define
name|CONRAD_BASEDELAY
value|0.292
end_define

begin_comment
comment|/* Conrad receiver @ 50 Baud on a Sun */
end_comment

begin_define
define|#
directive|define
name|CONRAD_DESCRIPTION
value|"RAW DCF77 CODE (Conrad DCF77 receiver module)"
end_define

begin_comment
comment|/*  * TimeBrick receiver  */
end_comment

begin_define
define|#
directive|define
name|TIMEBRICK_BASEDELAY
value|0.210
end_define

begin_comment
comment|/* TimeBrick @ 50 Baud on a Sun */
end_comment

begin_define
define|#
directive|define
name|TIMEBRICK_DESCRIPTION
value|"RAW DCF77 CODE (TimeBrick)"
end_define

begin_comment
comment|/*  * IGEL:clock receiver  */
end_comment

begin_define
define|#
directive|define
name|IGELCLOCK_BASEDELAY
value|0.258
end_define

begin_comment
comment|/* IGEL:clock receiver */
end_comment

begin_define
define|#
directive|define
name|IGELCLOCK_DESCRIPTION
value|"RAW DCF77 CODE (IGEL:clock)"
end_define

begin_define
define|#
directive|define
name|IGELCLOCK_SPEED
value|(B1200)
end_define

begin_define
define|#
directive|define
name|IGELCLOCK_CFLAG
value|(CS8|CREAD|HUPCL|CLOCAL)
end_define

begin_comment
comment|/*  * RAWDCF receivers that need to be powered from DTR  * (like Expert mouse clock)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rawdcf_init_1
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RAWDCFDTRSET_DESCRIPTION
value|"RAW DCF77 CODE (DTR SET/RTS CLR)"
end_define

begin_define
define|#
directive|define
name|RAWDCFDTRSET_INIT
value|rawdcf_init_1
end_define

begin_comment
comment|/*  * RAWDCF receivers that need to be powered from  * DTR CLR and RTS SET  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rawdcf_init_2
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RAWDCFDTRCLRRTSSET_DESCRIPTION
value|"RAW DCF77 CODE (DTR CLR/RTS SET)"
end_define

begin_define
define|#
directive|define
name|RAWDCFDTRCLRRTSSET_INIT
value|rawdcf_init_2
end_define

begin_comment
comment|/*  * Trimble GPS receivers (TAIP and TSIP protocols)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRIM_POLLRATE
end_ifndef

begin_define
define|#
directive|define
name|TRIM_POLLRATE
value|0
end_define

begin_comment
comment|/* only true direct polling */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TRIM_TAIPPOLLCMD
value|">SRM;FR_FLAG=F;EC_FLAG=F<>QTM<"
end_define

begin_define
define|#
directive|define
name|TRIM_TAIPCMDSIZE
value|(sizeof(TRIM_TAIPPOLLCMD)-1)
end_define

begin_decl_stmt
specifier|static
name|poll_info_t
name|trimbletaip_pollinfo
init|=
block|{
name|TRIM_POLLRATE
block|,
name|TRIM_TAIPPOLLCMD
block|,
name|TRIM_TAIPCMDSIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|trimbletaip_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trimbletaip_event
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* query time& UTC correction data */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tsipquery
index|[]
init|=
block|{
name|DLE
block|,
literal|0x21
block|,
name|DLE
block|,
name|ETX
block|,
name|DLE
block|,
literal|0x2F
block|,
name|DLE
block|,
name|ETX
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|poll_info_t
name|trimbletsip_pollinfo
init|=
block|{
name|TRIM_POLLRATE
block|,
name|tsipquery
block|,
expr|sizeof
operator|(
name|tsipquery
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|trimbletsip_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trimbletsip_end
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trimbletsip_message
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsetime_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trimbletsip_event
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRIMBLETSIP_IDLE_TIME
value|(300)
end_define

begin_comment
comment|/* 5 minutes silence at most */
end_comment

begin_define
define|#
directive|define
name|TRIMBLETAIP_SPEED
value|(B4800)
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_CFLAG
value|(CS8|CREAD|CLOCAL)
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_IFLAG
value|(BRKINT|IGNPAR|ISTRIP|ICRNL|IXON)
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_OFLAG
value|(OPOST|ONLCR)
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_LFLAG
value|(0)
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_SPEED
value|(B9600)
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_CFLAG
value|(CS8|CLOCAL|CREAD|PARENB|PARODD)
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_IFLAG
value|(IGNBRK)
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_OFLAG
value|(0)
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_LFLAG
value|(ICANON)
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_KEEP
value|3
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_KEEP
value|3
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_FLAGS
value|(PARSE_F_PPSONSECOND)
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_FLAGS
value|(TRIMBLETAIP_FLAGS)
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_POLL
value|poll_dpoll
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_POLL
value|poll_dpoll
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_INIT
value|trimbletaip_init
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_INIT
value|trimbletsip_init
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_EVENT
value|trimbletaip_event
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_EVENT
value|trimbletsip_event
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_MESSAGE
value|trimbletsip_message
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_END
value|0
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_END
value|trimbletsip_end
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_DATA
value|((void *)(&trimbletaip_pollinfo))
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_DATA
value|((void *)(&trimbletsip_pollinfo))
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_ID
value|GPS_ID
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_ID
value|GPS_ID
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_FORMAT
value|"Trimble TAIP"
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_FORMAT
value|"Trimble TSIP"
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_ROOTDELAY
value|0x0
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_ROOTDELAY
value|0x0
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_BASEDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_BASEDELAY
value|0.020
end_define

begin_comment
comment|/* GPS time message latency */
end_comment

begin_define
define|#
directive|define
name|TRIMBLETAIP_DESCRIPTION
value|"Trimble GPS (TAIP) receiver"
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_DESCRIPTION
value|"Trimble GPS (TSIP) receiver"
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_MAXUNSYNC
value|0
end_define

begin_define
define|#
directive|define
name|TRIMBLETSIP_MAXUNSYNC
value|0
end_define

begin_define
define|#
directive|define
name|TRIMBLETAIP_EOL
value|'<'
end_define

begin_comment
comment|/*  * RadioCode Clocks RCC 800 receiver  */
end_comment

begin_define
define|#
directive|define
name|RCC_POLLRATE
value|0
end_define

begin_comment
comment|/* only true direct polling */
end_comment

begin_define
define|#
directive|define
name|RCC_POLLCMD
value|"\r"
end_define

begin_define
define|#
directive|define
name|RCC_CMDSIZE
value|1
end_define

begin_decl_stmt
specifier|static
name|poll_info_t
name|rcc8000_pollinfo
init|=
block|{
name|RCC_POLLRATE
block|,
name|RCC_POLLCMD
block|,
name|RCC_CMDSIZE
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RCC8000_FLAGS
value|0
end_define

begin_define
define|#
directive|define
name|RCC8000_POLL
value|poll_dpoll
end_define

begin_define
define|#
directive|define
name|RCC8000_INIT
value|poll_init
end_define

begin_define
define|#
directive|define
name|RCC8000_END
value|0
end_define

begin_define
define|#
directive|define
name|RCC8000_DATA
value|((void *)(&rcc8000_pollinfo))
end_define

begin_define
define|#
directive|define
name|RCC8000_ROOTDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|RCC8000_BASEDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|RCC8000_ID
value|"MSF"
end_define

begin_define
define|#
directive|define
name|RCC8000_DESCRIPTION
value|"RCC 8000 MSF Receiver"
end_define

begin_define
define|#
directive|define
name|RCC8000_FORMAT
value|"Radiocode RCC8000"
end_define

begin_define
define|#
directive|define
name|RCC8000_MAXUNSYNC
value|(60*60)
end_define

begin_comment
comment|/* should be ok for an hour */
end_comment

begin_define
define|#
directive|define
name|RCC8000_SPEED
value|(B2400)
end_define

begin_define
define|#
directive|define
name|RCC8000_CFLAG
value|(CS8|CREAD|CLOCAL)
end_define

begin_define
define|#
directive|define
name|RCC8000_IFLAG
value|(IGNBRK|IGNPAR)
end_define

begin_define
define|#
directive|define
name|RCC8000_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|RCC8000_LFLAG
value|0
end_define

begin_define
define|#
directive|define
name|RCC8000_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|RCC8000_KEEP
value|3
end_define

begin_comment
comment|/*  * Hopf Radio clock 6021 Format   *  */
end_comment

begin_define
define|#
directive|define
name|HOPF6021_ROOTDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|HOPF6021_BASEDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|HOPF6021_DESCRIPTION
value|"HOPF 6021"
end_define

begin_define
define|#
directive|define
name|HOPF6021_FORMAT
value|"hopf Funkuhr 6021"
end_define

begin_define
define|#
directive|define
name|HOPF6021_MAXUNSYNC
value|(60*60)
end_define

begin_comment
comment|/* should be ok for an hour */
end_comment

begin_define
define|#
directive|define
name|HOPF6021_SPEED
value|(B9600)
end_define

begin_define
define|#
directive|define
name|HOPF6021_CFLAG
value|(CS8|CREAD|CLOCAL)
end_define

begin_define
define|#
directive|define
name|HOPF6021_IFLAG
value|(IGNBRK|ISTRIP)
end_define

begin_define
define|#
directive|define
name|HOPF6021_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|HOPF6021_LFLAG
value|0
end_define

begin_define
define|#
directive|define
name|HOPF6021_FLAGS
value|0
end_define

begin_define
define|#
directive|define
name|HOPF6021_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|HOPF6021_KEEP
value|3
end_define

begin_comment
comment|/*  * Diem's Computime Radio Clock Receiver  */
end_comment

begin_define
define|#
directive|define
name|COMPUTIME_FLAGS
value|0
end_define

begin_define
define|#
directive|define
name|COMPUTIME_ROOTDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|COMPUTIME_BASEDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|COMPUTIME_ID
value|DCF_ID
end_define

begin_define
define|#
directive|define
name|COMPUTIME_DESCRIPTION
value|"Diem's Computime receiver"
end_define

begin_define
define|#
directive|define
name|COMPUTIME_FORMAT
value|"Diem's Computime Radio Clock"
end_define

begin_define
define|#
directive|define
name|COMPUTIME_TYPE
value|DCF_TYPE
end_define

begin_define
define|#
directive|define
name|COMPUTIME_MAXUNSYNC
value|(60*60)
end_define

begin_comment
comment|/* only trust clock for 1 hour */
end_comment

begin_define
define|#
directive|define
name|COMPUTIME_SPEED
value|(B9600)
end_define

begin_define
define|#
directive|define
name|COMPUTIME_CFLAG
value|(CSTOPB|CS7|CREAD|CLOCAL)
end_define

begin_define
define|#
directive|define
name|COMPUTIME_IFLAG
value|(IGNBRK|IGNPAR|ISTRIP)
end_define

begin_define
define|#
directive|define
name|COMPUTIME_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|COMPUTIME_LFLAG
value|0
end_define

begin_define
define|#
directive|define
name|COMPUTIME_SAMPLES
value|5
end_define

begin_define
define|#
directive|define
name|COMPUTIME_KEEP
value|3
end_define

begin_decl_stmt
specifier|static
name|poll_info_t
name|we400a_pollinfo
init|=
block|{
literal|60
block|,
literal|"T"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Varitext Radio Clock Receiver  */
end_comment

begin_define
define|#
directive|define
name|VARITEXT_FLAGS
value|0
end_define

begin_define
define|#
directive|define
name|VARITEXT_ROOTDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|VARITEXT_BASEDELAY
value|0.0
end_define

begin_define
define|#
directive|define
name|VARITEXT_ID
value|"MSF"
end_define

begin_define
define|#
directive|define
name|VARITEXT_DESCRIPTION
value|"Varitext receiver"
end_define

begin_define
define|#
directive|define
name|VARITEXT_FORMAT
value|"Varitext Radio Clock"
end_define

begin_define
define|#
directive|define
name|VARITEXT_TYPE
value|DCF_TYPE
end_define

begin_define
define|#
directive|define
name|VARITEXT_MAXUNSYNC
value|(60*60)
end_define

begin_comment
comment|/* only trust clock for 1 hour */
end_comment

begin_define
define|#
directive|define
name|VARITEXT_SPEED
value|(B9600)
end_define

begin_define
define|#
directive|define
name|VARITEXT_CFLAG
value|(CS7|CREAD|CLOCAL|PARENB|PARODD)
end_define

begin_define
define|#
directive|define
name|VARITEXT_IFLAG
value|(IGNPAR|IGNBRK|INPCK)
end_define

begin_comment
comment|/*|ISTRIP)*/
end_comment

begin_define
define|#
directive|define
name|VARITEXT_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|VARITEXT_LFLAG
value|0
end_define

begin_define
define|#
directive|define
name|VARITEXT_SAMPLES
value|32
end_define

begin_define
define|#
directive|define
name|VARITEXT_KEEP
value|20
end_define

begin_struct
specifier|static
struct|struct
name|parse_clockinfo
block|{
name|u_long
name|cl_flags
decl_stmt|;
comment|/* operation flags (io modes) */
name|void
argument_list|(
argument|*cl_poll
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* active poll routine */
name|int
argument_list|(
argument|*cl_init
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* active poll init routine */
name|void
argument_list|(
argument|*cl_event
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* special event handling (e.g. reset clock) */
name|void
argument_list|(
argument|*cl_end
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* active poll end routine */
name|void
argument_list|(
argument|*cl_message
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsetime_t
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* process a lower layer message */
name|void
modifier|*
name|cl_data
decl_stmt|;
comment|/* local data area for "poll" mechanism */
name|double
name|cl_rootdelay
decl_stmt|;
comment|/* rootdelay */
name|double
name|cl_basedelay
decl_stmt|;
comment|/* current offset by which the RS232 				time code is delayed from the actual time */
specifier|const
name|char
modifier|*
name|cl_id
decl_stmt|;
comment|/* ID code */
specifier|const
name|char
modifier|*
name|cl_description
decl_stmt|;
comment|/* device name */
specifier|const
name|char
modifier|*
name|cl_format
decl_stmt|;
comment|/* fixed format */
name|u_char
name|cl_type
decl_stmt|;
comment|/* clock type (ntp control) */
name|u_long
name|cl_maxunsync
decl_stmt|;
comment|/* time to trust oscillator after loosing synch */
name|u_long
name|cl_speed
decl_stmt|;
comment|/* terminal input& output baudrate */
name|u_long
name|cl_cflag
decl_stmt|;
comment|/* terminal control flags */
name|u_long
name|cl_iflag
decl_stmt|;
comment|/* terminal input flags */
name|u_long
name|cl_oflag
decl_stmt|;
comment|/* terminal output flags */
name|u_long
name|cl_lflag
decl_stmt|;
comment|/* terminal local flags */
name|u_long
name|cl_samples
decl_stmt|;
comment|/* samples for median filter */
name|u_long
name|cl_keep
decl_stmt|;
comment|/* samples for median filter to keep */
block|}
name|parse_clockinfo
index|[]
init|=
block|{
block|{
comment|/* mode 0 */
name|MBG_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|DCFPZF535_ROOTDELAY
block|,
name|DCFPZF535_BASEDELAY
block|,
name|DCF_P_ID
block|,
name|DCFPZF535_DESCRIPTION
block|,
name|DCFPZF535_FORMAT
block|,
name|DCF_TYPE
block|,
name|DCFPZF535_MAXUNSYNC
block|,
name|DCFPZF535_SPEED
block|,
name|DCFPZF535_CFLAG
block|,
name|DCFPZF535_IFLAG
block|,
name|DCFPZF535_OFLAG
block|,
name|DCFPZF535_LFLAG
block|,
name|DCFPZF535_SAMPLES
block|,
name|DCFPZF535_KEEP
block|}
block|,
block|{
comment|/* mode 1 */
name|MBG_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|DCFPZF535OCXO_ROOTDELAY
block|,
name|DCFPZF535OCXO_BASEDELAY
block|,
name|DCF_P_ID
block|,
name|DCFPZF535OCXO_DESCRIPTION
block|,
name|DCFPZF535OCXO_FORMAT
block|,
name|DCF_TYPE
block|,
name|DCFPZF535OCXO_MAXUNSYNC
block|,
name|DCFPZF535OCXO_SPEED
block|,
name|DCFPZF535OCXO_CFLAG
block|,
name|DCFPZF535OCXO_IFLAG
block|,
name|DCFPZF535OCXO_OFLAG
block|,
name|DCFPZF535OCXO_LFLAG
block|,
name|DCFPZF535OCXO_SAMPLES
block|,
name|DCFPZF535OCXO_KEEP
block|}
block|,
block|{
comment|/* mode 2 */
name|MBG_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|DCFUA31_ROOTDELAY
block|,
name|DCFUA31_BASEDELAY
block|,
name|DCF_A_ID
block|,
name|DCFUA31_DESCRIPTION
block|,
name|DCFUA31_FORMAT
block|,
name|DCF_TYPE
block|,
name|DCFUA31_MAXUNSYNC
block|,
name|DCFUA31_SPEED
block|,
name|DCFUA31_CFLAG
block|,
name|DCFUA31_IFLAG
block|,
name|DCFUA31_OFLAG
block|,
name|DCFUA31_LFLAG
block|,
name|DCFUA31_SAMPLES
block|,
name|DCFUA31_KEEP
block|}
block|,
block|{
comment|/* mode 3 */
name|MBG_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|DCF7000_ROOTDELAY
block|,
name|DCF7000_BASEDELAY
block|,
name|DCF_A_ID
block|,
name|DCF7000_DESCRIPTION
block|,
name|DCF7000_FORMAT
block|,
name|DCF_TYPE
block|,
name|DCF7000_MAXUNSYNC
block|,
name|DCF7000_SPEED
block|,
name|DCF7000_CFLAG
block|,
name|DCF7000_IFLAG
block|,
name|DCF7000_OFLAG
block|,
name|DCF7000_LFLAG
block|,
name|DCF7000_SAMPLES
block|,
name|DCF7000_KEEP
block|}
block|,
block|{
comment|/* mode 4 */
name|NO_CL_FLAGS
block|,
name|WSDCF_POLL
block|,
name|WSDCF_INIT
block|,
name|NO_EVENT
block|,
name|WSDCF_END
block|,
name|NO_MESSAGE
block|,
name|WSDCF_DATA
block|,
name|WSDCF_ROOTDELAY
block|,
name|WSDCF_BASEDELAY
block|,
name|DCF_A_ID
block|,
name|WSDCF_DESCRIPTION
block|,
name|WSDCF_FORMAT
block|,
name|DCF_TYPE
block|,
name|WSDCF_MAXUNSYNC
block|,
name|WSDCF_SPEED
block|,
name|WSDCF_CFLAG
block|,
name|WSDCF_IFLAG
block|,
name|WSDCF_OFLAG
block|,
name|WSDCF_LFLAG
block|,
name|WSDCF_SAMPLES
block|,
name|WSDCF_KEEP
block|}
block|,
block|{
comment|/* mode 5 */
name|RAWDCF_FLAGS
block|,
name|NO_POLL
block|,
name|RAWDCF_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|RAWDCF_ROOTDELAY
block|,
name|CONRAD_BASEDELAY
block|,
name|DCF_A_ID
block|,
name|CONRAD_DESCRIPTION
block|,
name|RAWDCF_FORMAT
block|,
name|DCF_TYPE
block|,
name|RAWDCF_MAXUNSYNC
block|,
name|RAWDCF_SPEED
block|,
name|RAWDCF_CFLAG
block|,
name|RAWDCF_IFLAG
block|,
name|RAWDCF_OFLAG
block|,
name|RAWDCF_LFLAG
block|,
name|RAWDCF_SAMPLES
block|,
name|RAWDCF_KEEP
block|}
block|,
block|{
comment|/* mode 6 */
name|RAWDCF_FLAGS
block|,
name|NO_POLL
block|,
name|RAWDCF_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|RAWDCF_ROOTDELAY
block|,
name|TIMEBRICK_BASEDELAY
block|,
name|DCF_A_ID
block|,
name|TIMEBRICK_DESCRIPTION
block|,
name|RAWDCF_FORMAT
block|,
name|DCF_TYPE
block|,
name|RAWDCF_MAXUNSYNC
block|,
name|RAWDCF_SPEED
block|,
name|RAWDCF_CFLAG
block|,
name|RAWDCF_IFLAG
block|,
name|RAWDCF_OFLAG
block|,
name|RAWDCF_LFLAG
block|,
name|RAWDCF_SAMPLES
block|,
name|RAWDCF_KEEP
block|}
block|,
block|{
comment|/* mode 7 */
name|MBG_FLAGS
block|,
name|GPS16X_POLL
block|,
name|GPS16X_INIT
block|,
name|NO_EVENT
block|,
name|GPS16X_END
block|,
name|GPS16X_MESSAGE
block|,
name|GPS16X_DATA
block|,
name|GPS16X_ROOTDELAY
block|,
name|GPS16X_BASEDELAY
block|,
name|GPS16X_ID
block|,
name|GPS16X_DESCRIPTION
block|,
name|GPS16X_FORMAT
block|,
name|GPS_TYPE
block|,
name|GPS16X_MAXUNSYNC
block|,
name|GPS16X_SPEED
block|,
name|GPS16X_CFLAG
block|,
name|GPS16X_IFLAG
block|,
name|GPS16X_OFLAG
block|,
name|GPS16X_LFLAG
block|,
name|GPS16X_SAMPLES
block|,
name|GPS16X_KEEP
block|}
block|,
block|{
comment|/* mode 8 */
name|RAWDCF_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|RAWDCF_ROOTDELAY
block|,
name|IGELCLOCK_BASEDELAY
block|,
name|DCF_A_ID
block|,
name|IGELCLOCK_DESCRIPTION
block|,
name|RAWDCF_FORMAT
block|,
name|DCF_TYPE
block|,
name|RAWDCF_MAXUNSYNC
block|,
name|IGELCLOCK_SPEED
block|,
name|IGELCLOCK_CFLAG
block|,
name|RAWDCF_IFLAG
block|,
name|RAWDCF_OFLAG
block|,
name|RAWDCF_LFLAG
block|,
name|RAWDCF_SAMPLES
block|,
name|RAWDCF_KEEP
block|}
block|,
block|{
comment|/* mode 9 */
name|TRIMBLETAIP_FLAGS
block|,
if|#
directive|if
name|TRIM_POLLRATE
comment|/* DHD940515: Allow user config */
name|NO_POLL
block|,
else|#
directive|else
name|TRIMBLETAIP_POLL
block|,
endif|#
directive|endif
name|TRIMBLETAIP_INIT
block|,
name|TRIMBLETAIP_EVENT
block|,
name|TRIMBLETAIP_END
block|,
name|NO_MESSAGE
block|,
name|TRIMBLETAIP_DATA
block|,
name|TRIMBLETAIP_ROOTDELAY
block|,
name|TRIMBLETAIP_BASEDELAY
block|,
name|TRIMBLETAIP_ID
block|,
name|TRIMBLETAIP_DESCRIPTION
block|,
name|TRIMBLETAIP_FORMAT
block|,
name|GPS_TYPE
block|,
name|TRIMBLETAIP_MAXUNSYNC
block|,
name|TRIMBLETAIP_SPEED
block|,
name|TRIMBLETAIP_CFLAG
block|,
name|TRIMBLETAIP_IFLAG
block|,
name|TRIMBLETAIP_OFLAG
block|,
name|TRIMBLETAIP_LFLAG
block|,
name|TRIMBLETAIP_SAMPLES
block|,
name|TRIMBLETAIP_KEEP
block|}
block|,
block|{
comment|/* mode 10 */
name|TRIMBLETSIP_FLAGS
block|,
if|#
directive|if
name|TRIM_POLLRATE
comment|/* DHD940515: Allow user config */
name|NO_POLL
block|,
else|#
directive|else
name|TRIMBLETSIP_POLL
block|,
endif|#
directive|endif
name|TRIMBLETSIP_INIT
block|,
name|TRIMBLETSIP_EVENT
block|,
name|TRIMBLETSIP_END
block|,
name|TRIMBLETSIP_MESSAGE
block|,
name|TRIMBLETSIP_DATA
block|,
name|TRIMBLETSIP_ROOTDELAY
block|,
name|TRIMBLETSIP_BASEDELAY
block|,
name|TRIMBLETSIP_ID
block|,
name|TRIMBLETSIP_DESCRIPTION
block|,
name|TRIMBLETSIP_FORMAT
block|,
name|GPS_TYPE
block|,
name|TRIMBLETSIP_MAXUNSYNC
block|,
name|TRIMBLETSIP_SPEED
block|,
name|TRIMBLETSIP_CFLAG
block|,
name|TRIMBLETSIP_IFLAG
block|,
name|TRIMBLETSIP_OFLAG
block|,
name|TRIMBLETSIP_LFLAG
block|,
name|TRIMBLETSIP_SAMPLES
block|,
name|TRIMBLETSIP_KEEP
block|}
block|,
block|{
comment|/* mode 11 */
name|NO_CL_FLAGS
block|,
name|RCC8000_POLL
block|,
name|RCC8000_INIT
block|,
name|NO_EVENT
block|,
name|RCC8000_END
block|,
name|NO_MESSAGE
block|,
name|RCC8000_DATA
block|,
name|RCC8000_ROOTDELAY
block|,
name|RCC8000_BASEDELAY
block|,
name|RCC8000_ID
block|,
name|RCC8000_DESCRIPTION
block|,
name|RCC8000_FORMAT
block|,
name|DCF_TYPE
block|,
name|RCC8000_MAXUNSYNC
block|,
name|RCC8000_SPEED
block|,
name|RCC8000_CFLAG
block|,
name|RCC8000_IFLAG
block|,
name|RCC8000_OFLAG
block|,
name|RCC8000_LFLAG
block|,
name|RCC8000_SAMPLES
block|,
name|RCC8000_KEEP
block|}
block|,
block|{
comment|/* mode 12 */
name|HOPF6021_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|HOPF6021_ROOTDELAY
block|,
name|HOPF6021_BASEDELAY
block|,
name|DCF_ID
block|,
name|HOPF6021_DESCRIPTION
block|,
name|HOPF6021_FORMAT
block|,
name|DCF_TYPE
block|,
name|HOPF6021_MAXUNSYNC
block|,
name|HOPF6021_SPEED
block|,
name|HOPF6021_CFLAG
block|,
name|HOPF6021_IFLAG
block|,
name|HOPF6021_OFLAG
block|,
name|HOPF6021_LFLAG
block|,
name|HOPF6021_SAMPLES
block|,
name|HOPF6021_KEEP
block|}
block|,
block|{
comment|/* mode 13 */
name|COMPUTIME_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|COMPUTIME_ROOTDELAY
block|,
name|COMPUTIME_BASEDELAY
block|,
name|COMPUTIME_ID
block|,
name|COMPUTIME_DESCRIPTION
block|,
name|COMPUTIME_FORMAT
block|,
name|COMPUTIME_TYPE
block|,
name|COMPUTIME_MAXUNSYNC
block|,
name|COMPUTIME_SPEED
block|,
name|COMPUTIME_CFLAG
block|,
name|COMPUTIME_IFLAG
block|,
name|COMPUTIME_OFLAG
block|,
name|COMPUTIME_LFLAG
block|,
name|COMPUTIME_SAMPLES
block|,
name|COMPUTIME_KEEP
block|}
block|,
block|{
comment|/* mode 14 */
name|RAWDCF_FLAGS
block|,
name|NO_POLL
block|,
name|RAWDCFDTRSET_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|RAWDCF_ROOTDELAY
block|,
name|RAWDCF_BASEDELAY
block|,
name|DCF_A_ID
block|,
name|RAWDCFDTRSET_DESCRIPTION
block|,
name|RAWDCF_FORMAT
block|,
name|DCF_TYPE
block|,
name|RAWDCF_MAXUNSYNC
block|,
name|RAWDCF_SPEED
block|,
name|RAWDCF_CFLAG
block|,
name|RAWDCF_IFLAG
block|,
name|RAWDCF_OFLAG
block|,
name|RAWDCF_LFLAG
block|,
name|RAWDCF_SAMPLES
block|,
name|RAWDCF_KEEP
block|}
block|,
block|{
comment|/* mode 15 */
literal|0
block|,
comment|/* operation flags (io modes) */
name|poll_dpoll
block|,
comment|/* active poll routine */
name|poll_init
block|,
comment|/* active poll init routine */
name|NO_EVENT
block|,
comment|/* special event handling (e.g. reset clock) */
name|NO_END
block|,
comment|/* active poll end routine */
name|NO_MESSAGE
block|,
comment|/* process a lower layer message */
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|we400a_pollinfo
operator|)
operator|)
block|,
comment|/* local data area for "poll" mechanism */
literal|0
block|,
comment|/* rootdelay */
literal|1.0
operator|/
literal|960
block|,
comment|/* current offset by which the RS232 				           	time code is delayed from the actual time */
name|DCF_ID
block|,
comment|/* ID code */
literal|"WHARTON 400A Series clock"
block|,
comment|/* device name */
literal|"WHARTON 400A Series clock Output Format 5"
block|,
comment|/* fixed format */
comment|/* Must match a format-name in a libparse/clk_xxx.c file */
name|DCF_TYPE
block|,
comment|/* clock type (ntp control) */
operator|(
literal|1
operator|*
literal|60
operator|*
literal|60
operator|)
block|,
comment|/* time to trust oscillator after loosing synch */
name|B9600
block|,
comment|/* terminal input& output baudrate */
operator|(
name|CS8
operator||
name|CREAD
operator||
name|PARENB
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* terminal control flags */
literal|0
block|,
comment|/* terminal input flags */
literal|0
block|,
comment|/* terminal output flags */
literal|0
block|,
comment|/* terminal local flags */
literal|5
block|,
comment|/* samples for median filter */
literal|3
block|,
comment|/* samples for median filter to keep */
block|}
block|,
block|{
comment|/* mode 16 - RAWDCF RTS set, DTR clr */
name|RAWDCF_FLAGS
block|,
name|NO_POLL
block|,
name|RAWDCFDTRCLRRTSSET_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|RAWDCF_ROOTDELAY
block|,
name|RAWDCF_BASEDELAY
block|,
name|DCF_A_ID
block|,
name|RAWDCFDTRCLRRTSSET_DESCRIPTION
block|,
name|RAWDCF_FORMAT
block|,
name|DCF_TYPE
block|,
name|RAWDCF_MAXUNSYNC
block|,
name|RAWDCF_SPEED
block|,
name|RAWDCF_CFLAG
block|,
name|RAWDCF_IFLAG
block|,
name|RAWDCF_OFLAG
block|,
name|RAWDCF_LFLAG
block|,
name|RAWDCF_SAMPLES
block|,
name|RAWDCF_KEEP
block|}
block|,
block|{
comment|/* mode 17 */
name|VARITEXT_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_EVENT
block|,
name|NO_END
block|,
name|NO_MESSAGE
block|,
name|NO_DATA
block|,
name|VARITEXT_ROOTDELAY
block|,
name|VARITEXT_BASEDELAY
block|,
name|VARITEXT_ID
block|,
name|VARITEXT_DESCRIPTION
block|,
name|VARITEXT_FORMAT
block|,
name|VARITEXT_TYPE
block|,
name|VARITEXT_MAXUNSYNC
block|,
name|VARITEXT_SPEED
block|,
name|VARITEXT_CFLAG
block|,
name|VARITEXT_IFLAG
block|,
name|VARITEXT_OFLAG
block|,
name|VARITEXT_LFLAG
block|,
name|VARITEXT_SAMPLES
block|,
name|VARITEXT_KEEP
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ncltypes
init|=
sizeof|sizeof
argument_list|(
name|parse_clockinfo
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|parse_clockinfo
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CLK_REALTYPE
parameter_list|(
name|x
parameter_list|)
value|((int)(((x)->ttl)& 0x7F))
end_define

begin_define
define|#
directive|define
name|CLK_TYPE
parameter_list|(
name|x
parameter_list|)
value|((CLK_REALTYPE(x)>= ncltypes) ? ~0 : CLK_REALTYPE(x))
end_define

begin_define
define|#
directive|define
name|CLK_UNIT
parameter_list|(
name|x
parameter_list|)
value|((int)REFCLOCKUNIT(&(x)->srcadr))
end_define

begin_define
define|#
directive|define
name|CLK_PPS
parameter_list|(
name|x
parameter_list|)
value|(((x)->ttl)& 0x80)
end_define

begin_comment
comment|/*  * Other constant stuff  */
end_comment

begin_define
define|#
directive|define
name|PARSEHSREFID
value|0x7f7f08ff
end_define

begin_comment
comment|/* 127.127.8.255 refid for hi strata */
end_comment

begin_define
define|#
directive|define
name|PARSESTATISTICS
value|(60*60)
end_define

begin_comment
comment|/* output state statistics every hour */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|parseunit
modifier|*
name|parseunits
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|notice
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PARSE_STATETIME
parameter_list|(
name|parse
parameter_list|,
name|i
parameter_list|)
value|((parse->generic->currentstatus == i) ? parse->statetime[i] + current_time - parse->lastchange : parse->statetime[i])
end_define

begin_decl_stmt
specifier|static
name|void
name|parse_event
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_process
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsetime_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_err
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|list_err
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|l_mktime
name|P
argument_list|(
operator|(
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**===========================================================================  ** implementation error message regression module  **/
end_comment

begin_function
specifier|static
name|void
name|clear_err
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|u_long
name|lstate
parameter_list|)
block|{
if|if
condition|(
name|lstate
operator|==
name|ERR_ALL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ERR_CNT
condition|;
name|i
operator|++
control|)
block|{
name|parse
operator|->
name|errors
index|[
name|i
index|]
operator|.
name|err_stage
operator|=
name|err_tbl
index|[
name|i
index|]
expr_stmt|;
name|parse
operator|->
name|errors
index|[
name|i
index|]
operator|.
name|err_cnt
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|errors
index|[
name|i
index|]
operator|.
name|err_last
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|errors
index|[
name|i
index|]
operator|.
name|err_started
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|errors
index|[
name|i
index|]
operator|.
name|err_suppressed
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|parse
operator|->
name|errors
index|[
name|lstate
index|]
operator|.
name|err_stage
operator|=
name|err_tbl
index|[
name|lstate
index|]
expr_stmt|;
name|parse
operator|->
name|errors
index|[
name|lstate
index|]
operator|.
name|err_cnt
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|errors
index|[
name|lstate
index|]
operator|.
name|err_last
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|errors
index|[
name|lstate
index|]
operator|.
name|err_started
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|errors
index|[
name|lstate
index|]
operator|.
name|err_suppressed
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|list_err
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|u_long
name|lstate
parameter_list|)
block|{
name|int
name|do_it
decl_stmt|;
name|struct
name|errorinfo
modifier|*
name|err
init|=
operator|&
name|parse
operator|->
name|errors
index|[
name|lstate
index|]
decl_stmt|;
if|if
condition|(
name|err
operator|->
name|err_started
operator|==
literal|0
condition|)
block|{
name|err
operator|->
name|err_started
operator|=
name|current_time
expr_stmt|;
block|}
name|do_it
operator|=
operator|(
name|current_time
operator|-
name|err
operator|->
name|err_last
operator|)
operator|>=
name|err
operator|->
name|err_stage
operator|->
name|err_delay
expr_stmt|;
if|if
condition|(
name|do_it
condition|)
name|err
operator|->
name|err_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|err
operator|->
name|err_stage
operator|->
name|err_count
operator|&&
operator|(
name|err
operator|->
name|err_cnt
operator|>=
name|err
operator|->
name|err_stage
operator|->
name|err_count
operator|)
condition|)
block|{
name|err
operator|->
name|err_stage
operator|++
expr_stmt|;
name|err
operator|->
name|err_cnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
operator|->
name|err_cnt
operator|&&
name|do_it
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: interval for following error message class is at least %s"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|l_mktime
argument_list|(
name|err
operator|->
name|err_stage
operator|->
name|err_delay
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_it
condition|)
name|err
operator|->
name|err_suppressed
operator|++
expr_stmt|;
else|else
name|err
operator|->
name|err_last
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|do_it
operator|&&
name|err
operator|->
name|err_suppressed
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: %ld message%s suppressed, error condition class persists for %s"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|err
operator|->
name|err_suppressed
argument_list|,
operator|(
name|err
operator|->
name|err_suppressed
operator|==
literal|1
operator|)
condition|?
literal|" was"
else|:
literal|"s where"
argument_list|,
name|l_mktime
argument_list|(
name|current_time
operator|-
name|err
operator|->
name|err_started
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|->
name|err_suppressed
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|do_it
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * mkreadable - make a printable ascii string (without  * embedded quotes so that the ntpq protocol isn't  * fooled  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|isprint
end_ifndef

begin_define
define|#
directive|define
name|isprint
parameter_list|(
name|_X_
parameter_list|)
value|(((_X_)> 0x1F)&& ((_X_)< 0x7F))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|mkreadable
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|long
name|blen
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|u_long
name|srclen
parameter_list|,
name|int
name|hex
parameter_list|)
block|{
name|char
modifier|*
name|b
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|endb
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|blen
operator|<
literal|4
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
comment|/* don't bother with mini buffers */
name|endb
operator|=
name|buffer
operator|+
name|blen
operator|-
literal|4
expr_stmt|;
name|blen
operator|--
expr_stmt|;
comment|/* account for '\0' */
while|while
condition|(
name|blen
operator|&&
name|srclen
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|hex
operator|&&
comment|/* no binary only */
operator|(
operator|*
name|src
operator|!=
literal|'\\'
operator|)
operator|&&
comment|/* no plain \ */
operator|(
operator|*
name|src
operator|!=
literal|'"'
operator|)
operator|&&
comment|/* no " */
name|isprint
argument_list|(
operator|(
name|int
operator|)
operator|*
name|src
argument_list|)
condition|)
comment|/* only printables */
block|{
comment|/* they are easy... */
operator|*
name|buffer
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|blen
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|blen
operator|<
literal|4
condition|)
block|{
while|while
condition|(
name|blen
operator|--
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
return|return
name|b
return|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'\\'
condition|)
block|{
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
name|buffer
operator|+=
literal|2
expr_stmt|;
name|blen
operator|-=
literal|2
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\\x%02x"
argument_list|,
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
name|blen
operator|-=
literal|4
expr_stmt|;
name|buffer
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|srclen
operator|&&
operator|!
name|blen
operator|&&
name|endb
condition|)
comment|/* overflow - set last chars to ... */
name|strcpy
argument_list|(
name|endb
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * mkascii - make a printable ascii string  * assumes (unless defined better) 7-bit ASCII  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mkascii
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|long
name|blen
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|u_long
name|srclen
parameter_list|)
block|{
return|return
name|mkreadable
argument_list|(
name|buffer
argument_list|,
name|blen
argument_list|,
name|src
argument_list|,
name|srclen
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**===========================================================================  ** implementation of i/o handling methods  ** (all STREAM, partial STREAM, user level)  **/
end_comment

begin_comment
comment|/*  * define possible io handling methods  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STREAM
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ppsclock_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stream_end
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_enable
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_disable
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_setcs
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_getfmt
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_setfmt
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_timecode
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stream_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|local_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|local_end
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_nop
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_setcs
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_getfmt
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_setfmt
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_timecode
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|local_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_input
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bind_t
name|io_bindings
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|STREAM
block|{
literal|"parse STREAM"
block|,
name|stream_init
block|,
name|stream_end
block|,
name|stream_setcs
block|,
name|stream_disable
block|,
name|stream_enable
block|,
name|stream_getfmt
block|,
name|stream_setfmt
block|,
name|stream_timecode
block|,
name|stream_receive
block|,
literal|0
block|, 	}
block|,
block|{
literal|"ppsclock STREAM"
block|,
name|ppsclock_init
block|,
name|local_end
block|,
name|local_setcs
block|,
name|local_nop
block|,
name|local_nop
block|,
name|local_getfmt
block|,
name|local_setfmt
block|,
name|local_timecode
block|,
name|local_receive
block|,
name|local_input
block|, 	}
block|,
endif|#
directive|endif
block|{
literal|"normal"
block|,
name|local_init
block|,
name|local_end
block|,
name|local_setcs
block|,
name|local_nop
block|,
name|local_nop
block|,
name|local_getfmt
block|,
name|local_setfmt
block|,
name|local_timecode
block|,
name|local_receive
block|,
name|local_input
block|, 	}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|, 	}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STREAM
end_ifdef

begin_define
define|#
directive|define
name|fix_ts
parameter_list|(
name|_X_
parameter_list|)
define|\
value|if ((&(_X_))->tv.tv_usec>= 1000000)                \                           {                                                 \ 			    (&(_X_))->tv.tv_usec -= 1000000;                \ 			    (&(_X_))->tv.tv_sec  += 1;                      \ 			  }
end_define

begin_define
define|#
directive|define
name|cvt_ts
parameter_list|(
name|_X_
parameter_list|,
name|_Y_
parameter_list|)
define|\
value|{                                                   \ 			  l_fp ts;				            \ 			  fix_ts((_X_));                                    \ 			  if (!buftvtots((const char *)&(&(_X_))->tv,&ts)) \ 			    {                                               \                               ERR(ERR_BADDATA)	 		            \                                 msyslog(LOG_ERR,"parse: stream_receive: timestamp conversion error (buftvtots) (%s) (%ld.%06ld) ", (_Y_), (long)(&(_X_))->tv.tv_sec, (long)(&(_X_))->tv.tv_usec);\ 			      return;                                       \ 			    }                                               \ 			  else                                              \ 			    {                                               \ 			      (&(_X_))->fp = ts;                            \ 			    }                                               \ 		        }
end_define

begin_comment
comment|/*--------------------------------------------------  * ppsclock STREAM init  */
end_comment

begin_function
specifier|static
name|int
name|ppsclock_init
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
specifier|static
name|char
name|m1
index|[]
init|=
literal|"ppsclocd"
decl_stmt|;
specifier|static
name|char
name|m2
index|[]
init|=
literal|"ppsclock"
decl_stmt|;
comment|/* 	 * now push the parse streams module 	 * it will ensure exclusive access to the device 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_PUSH
argument_list|,
operator|(
name|caddr_t
operator|)
name|m1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_PUSH
argument_list|,
operator|(
name|caddr_t
operator|)
name|m2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: ppsclock_init: ioctl(fd, I_PUSH, \"ppsclock\"): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|local_init
argument_list|(
name|parse
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_POP
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|parse
operator|->
name|flags
operator||=
name|PARSE_PPSCLOCK
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse STREAM init  */
end_comment

begin_function
specifier|static
name|int
name|stream_init
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
specifier|static
name|char
name|m1
index|[]
init|=
literal|"parse"
decl_stmt|;
comment|/* 	 * now push the parse streams module 	 * to test whether it is there (neat interface 8-( ) 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_PUSH
argument_list|,
operator|(
name|caddr_t
operator|)
name|m1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
comment|/* accept non-existence */
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_init: ioctl(fd, I_PUSH, \"parse\"): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
while|while
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_POP
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
comment|/* empty loop */
empty_stmt|;
comment|/* 		 * now push it a second time after we have removed all 		 * module garbage 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_PUSH
argument_list|,
operator|(
name|caddr_t
operator|)
name|m1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_init: ioctl(fd, I_PUSH, \"parse\"): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse STREAM end  */
end_comment

begin_function
specifier|static
name|void
name|stream_end
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
while|while
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_POP
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
comment|/* empty loop */
empty_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM setcs  */
end_comment

begin_function
specifier|static
name|int
name|stream_setcs
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsectl_t
modifier|*
name|tcl
parameter_list|)
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_SETCS
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|tcl
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_setcs: ioctl(fd, I_STR, PARSEIOC_SETCS): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM enable  */
end_comment

begin_function
specifier|static
name|int
name|stream_enable
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_ENABLE
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_enable: ioctl(fd, I_STR, PARSEIOC_ENABLE): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|stream_receive
expr_stmt|;
comment|/* ok - parse input in kernel */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM disable  */
end_comment

begin_function
specifier|static
name|int
name|stream_disable
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_DISABLE
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_disable: ioctl(fd, I_STR, PARSEIOC_DISABLE): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|local_receive
expr_stmt|;
comment|/* ok - parse input in daemon */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM getfmt  */
end_comment

begin_function
specifier|static
name|int
name|stream_getfmt
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsectl_t
modifier|*
name|tcl
parameter_list|)
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_GETFMT
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|tcl
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: ioctl(fd, I_STR, PARSEIOC_GETFMT): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM setfmt  */
end_comment

begin_function
specifier|static
name|int
name|stream_setfmt
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsectl_t
modifier|*
name|tcl
parameter_list|)
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_SETFMT
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|tcl
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_setfmt: ioctl(fd, I_STR, PARSEIOC_SETFMT): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM timecode  */
end_comment

begin_function
specifier|static
name|int
name|stream_timecode
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsectl_t
modifier|*
name|tcl
parameter_list|)
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_TIMECODE
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|tcl
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_INTERNAL
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_timecode: ioctl(fd, I_STR, PARSEIOC_TIMECODE): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_INTERNAL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM receive  */
end_comment

begin_function
specifier|static
name|void
name|stream_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
operator|)
decl_stmt|;
name|parsetime_t
name|parsetime
decl_stmt|;
if|if
condition|(
operator|!
name|parse
operator|->
name|peer
condition|)
return|return;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|!=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_BADIO
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_receive: bad size (got %d expected %d)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|baddata
operator|++
expr_stmt|;
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_BADIO
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parsetime
argument_list|,
operator|(
name|caddr_t
operator|)
name|rbufp
operator|->
name|recv_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"PARSE receiver #%d: status %06x, state %08x, time %lx.%08lx, stime %lx.%08lx, ptime %lx.%08lx\n"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|parsetime
operator|.
name|parse_status
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|parsetime
operator|.
name|parse_state
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_usec
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_stime
operator|.
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_stime
operator|.
name|tv
operator|.
name|tv_usec
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_ptime
operator|.
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_ptime
operator|.
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * switch time stamp world - be sure to normalize small usec field 	 * errors. 	 */
name|cvt_ts
argument_list|(
name|parsetime
operator|.
name|parse_stime
argument_list|,
literal|"parse_stime"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PARSE_TIMECODE
argument_list|(
name|parsetime
operator|.
name|parse_state
argument_list|)
condition|)
block|{
name|cvt_ts
argument_list|(
name|parsetime
operator|.
name|parse_time
argument_list|,
literal|"parse_time"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PARSE_PPS
argument_list|(
name|parsetime
operator|.
name|parse_state
argument_list|)
condition|)
name|cvt_ts
argument_list|(
name|parsetime
operator|.
name|parse_ptime
argument_list|,
literal|"parse_ptime"
argument_list|)
expr_stmt|;
name|parse_process
argument_list|(
name|parse
argument_list|,
operator|&
name|parsetime
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*--------------------------------------------------  * local init  */
end_comment

begin_function
specifier|static
name|int
name|local_init
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
return|return
name|parse_ioinit
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local end  */
end_comment

begin_function
specifier|static
name|void
name|local_end
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
name|parse_ioend
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local nop  */
end_comment

begin_function
specifier|static
name|int
name|local_nop
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local setcs  */
end_comment

begin_function
specifier|static
name|int
name|local_setcs
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsectl_t
modifier|*
name|tcl
parameter_list|)
block|{
return|return
name|parse_setcs
argument_list|(
name|tcl
argument_list|,
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local getfmt  */
end_comment

begin_function
specifier|static
name|int
name|local_getfmt
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsectl_t
modifier|*
name|tcl
parameter_list|)
block|{
return|return
name|parse_getfmt
argument_list|(
name|tcl
argument_list|,
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local setfmt  */
end_comment

begin_function
specifier|static
name|int
name|local_setfmt
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsectl_t
modifier|*
name|tcl
parameter_list|)
block|{
return|return
name|parse_setfmt
argument_list|(
name|tcl
argument_list|,
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local timecode  */
end_comment

begin_function
specifier|static
name|int
name|local_timecode
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsectl_t
modifier|*
name|tcl
parameter_list|)
block|{
return|return
name|parse_timecode
argument_list|(
name|tcl
argument_list|,
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local input  */
end_comment

begin_function
specifier|static
name|int
name|local_input
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
operator|)
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|timestamp_t
name|ts
decl_stmt|;
if|if
condition|(
operator|!
name|parse
operator|->
name|peer
condition|)
return|return
literal|0
return|;
comment|/* 	 * eat all characters, parsing then and feeding complete samples 	 */
name|count
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
name|ts
operator|.
name|fp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
name|s
operator|++
argument_list|)
argument_list|,
operator|&
name|ts
argument_list|)
condition|)
block|{
name|struct
name|recvbuf
name|buf
decl_stmt|;
comment|/* 			 * got something good to eat 			 */
if|if
condition|(
operator|!
name|PARSE_PPS
argument_list|(
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
operator|.
name|parse_state
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCDCDTIMESTAMP
name|struct
name|timeval
name|dcd_time
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|rbufp
operator|->
name|fd
argument_list|,
name|TIOCDCDTIMESTAMP
argument_list|,
operator|&
name|dcd_time
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|l_fp
name|tstmp
decl_stmt|;
name|TVTOTS
argument_list|(
operator|&
name|dcd_time
argument_list|,
operator|&
name|tstmp
argument_list|)
expr_stmt|;
name|tstmp
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|ts
operator|.
name|fp
argument_list|,
operator|&
name|tstmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|fp
operator|.
name|l_ui
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"parse: local_receive: fd %d DCDTIMESTAMP %s\n"
argument_list|,
name|rbufp
operator|->
name|fd
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|tstmp
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" sigio %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|ts
operator|.
name|fp
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
operator|.
name|parse_ptime
operator|.
name|fp
operator|=
name|tstmp
expr_stmt|;
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
operator|.
name|parse_state
operator||=
name|PARSEB_PPS
operator||
name|PARSEB_S_PPS
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* TIOCDCDTIMESTAMP */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_PPSCLOCKEV
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|HAVE_CIOGETEV
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TIOCGPPSEV
argument_list|)
operator|)
if|if
condition|(
name|parse
operator|->
name|flags
operator|&
name|PARSE_PPSCLOCK
condition|)
block|{
name|l_fp
name|tts
decl_stmt|;
name|struct
name|ppsclockev
name|ev
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_CIOGETEV
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|CIOGETEV
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ev
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIOCGPPSEV
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCGPPSEV
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ev
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|ev
operator|.
name|serial
operator|!=
name|parse
operator|->
name|ppsserial
condition|)
block|{
comment|/* 							 * add PPS time stamp if available via ppsclock module 							 * and not supplied already. 							 */
if|if
condition|(
operator|!
name|buftvtots
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|ev
operator|.
name|tv
argument_list|,
operator|&
name|tts
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_BADDATA
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: local_receive: timestamp conversion error (buftvtots) (ppsclockev.tv)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
operator|.
name|parse_ptime
operator|.
name|fp
operator|=
name|tts
expr_stmt|;
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
operator|.
name|parse_state
operator||=
name|PARSEB_PPS
operator||
name|PARSEB_S_PPS
expr_stmt|;
block|}
block|}
name|parse
operator|->
name|ppsserial
operator|=
name|ev
operator|.
name|serial
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* TIOCDCDTIMESTAMP */
block|}
if|if
condition|(
name|count
condition|)
block|{
comment|/* simulate receive */
name|memmove
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
operator|.
name|recv_buffer
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|)
expr_stmt|;
name|buf
operator|.
name|recv_length
operator|=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|buf
operator|.
name|recv_time
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|buf
operator|.
name|srcadr
operator|=
name|rbufp
operator|->
name|srcadr
expr_stmt|;
name|buf
operator|.
name|dstadr
operator|=
name|rbufp
operator|->
name|dstadr
expr_stmt|;
name|buf
operator|.
name|fd
operator|=
name|rbufp
operator|->
name|fd
expr_stmt|;
name|buf
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|X_from_where
operator|=
name|rbufp
operator|->
name|X_from_where
expr_stmt|;
name|rbufp
operator|->
name|receiver
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memmove
argument_list|(
operator|(
name|caddr_t
operator|)
name|rbufp
operator|->
name|recv_buffer
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|)
expr_stmt|;
name|rbufp
operator|->
name|recv_length
operator|=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* got something& in place return */
block|}
block|}
block|}
return|return
literal|0
return|;
comment|/* nothing to pass up */
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local receive  */
end_comment

begin_function
specifier|static
name|void
name|local_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
operator|)
decl_stmt|;
name|parsetime_t
name|parsetime
decl_stmt|;
if|if
condition|(
operator|!
name|parse
operator|->
name|peer
condition|)
return|return;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|!=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_BADIO
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: local_receive: bad size (got %d expected %d)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|baddata
operator|++
expr_stmt|;
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_BADIO
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parsetime
argument_list|,
operator|(
name|caddr_t
operator|)
name|rbufp
operator|->
name|recv_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"PARSE receiver #%d: status %06x, state %08x, time %lx.%08lx, stime %lx.%08lx, ptime %lx.%08lx\n"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|parsetime
operator|.
name|parse_status
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|parsetime
operator|.
name|parse_state
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_usec
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_stime
operator|.
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_stime
operator|.
name|tv
operator|.
name|tv_usec
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_ptime
operator|.
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|parsetime
operator|.
name|parse_ptime
operator|.
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|parse_process
argument_list|(
name|parse
argument_list|,
operator|&
name|parsetime
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * init_iobinding - find and initialize lower layers  */
end_comment

begin_function
specifier|static
name|bind_t
modifier|*
name|init_iobinding
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
name|bind_t
modifier|*
name|b
init|=
name|io_bindings
decl_stmt|;
while|while
condition|(
name|b
operator|->
name|bd_description
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|b
operator|->
name|bd_init
call|)
argument_list|(
name|parse
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
name|b
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|bind_t
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/**===========================================================================  ** support routines  **/
end_comment

begin_comment
comment|/*--------------------------------------------------  * convert a flag field to a string  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parsestate
parameter_list|(
name|u_long
name|lstate
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
specifier|static
struct|struct
name|bits
block|{
name|u_long
name|bit
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|flagstrings
index|[]
init|=
block|{
block|{
name|PARSEB_ANNOUNCE
block|,
literal|"DST SWITCH WARNING"
block|}
block|,
block|{
name|PARSEB_POWERUP
block|,
literal|"NOT SYNCHRONIZED"
block|}
block|,
block|{
name|PARSEB_NOSYNC
block|,
literal|"TIME CODE NOT CONFIRMED"
block|}
block|,
block|{
name|PARSEB_DST
block|,
literal|"DST"
block|}
block|,
block|{
name|PARSEB_UTC
block|,
literal|"UTC DISPLAY"
block|}
block|,
block|{
name|PARSEB_LEAPADD
block|,
literal|"LEAP ADD WARNING"
block|}
block|,
block|{
name|PARSEB_LEAPDEL
block|,
literal|"LEAP DELETE WARNING"
block|}
block|,
block|{
name|PARSEB_LEAPSECOND
block|,
literal|"LEAP SECOND"
block|}
block|,
block|{
name|PARSEB_ALTERNATE
block|,
literal|"ALTERNATE ANTENNA"
block|}
block|,
block|{
name|PARSEB_TIMECODE
block|,
literal|"TIME CODE"
block|}
block|,
block|{
name|PARSEB_PPS
block|,
literal|"PPS"
block|}
block|,
block|{
name|PARSEB_POSITION
block|,
literal|"POSITION"
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
specifier|static
struct|struct
name|sbits
block|{
name|u_long
name|bit
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|sflagstrings
index|[]
init|=
block|{
block|{
name|PARSEB_S_LEAP
block|,
literal|"LEAP INDICATION"
block|}
block|,
block|{
name|PARSEB_S_PPS
block|,
literal|"PPS SIGNAL"
block|}
block|,
block|{
name|PARSEB_S_ANTENNA
block|,
literal|"ANTENNA"
block|}
block|,
block|{
name|PARSEB_S_POSITION
block|,
literal|"POSITION"
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|bit
operator|&
name|lstate
condition|)
block|{
if|if
condition|(
name|buffer
index|[
literal|0
index|]
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|flagstrings
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lstate
operator|&
operator|(
name|PARSEB_S_LEAP
operator||
name|PARSEB_S_ANTENNA
operator||
name|PARSEB_S_PPS
operator||
name|PARSEB_S_POSITION
operator|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sflagstrings
index|[
name|i
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
name|sflagstrings
index|[
name|i
index|]
operator|.
name|bit
operator|&
name|lstate
condition|)
block|{
if|if
condition|(
name|t
operator|!=
name|s
condition|)
block|{
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|t
operator|+=
literal|2
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|t
argument_list|,
name|sflagstrings
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|t
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * convert a status flag field to a string  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parsestatus
parameter_list|(
name|u_long
name|lstate
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
specifier|static
struct|struct
name|bits
block|{
name|u_long
name|bit
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|flagstrings
index|[]
init|=
block|{
block|{
name|CVT_OK
block|,
literal|"CONVERSION SUCCESSFUL"
block|}
block|,
block|{
name|CVT_NONE
block|,
literal|"NO CONVERSION"
block|}
block|,
block|{
name|CVT_FAIL
block|,
literal|"CONVERSION FAILED"
block|}
block|,
block|{
name|CVT_BADFMT
block|,
literal|"ILLEGAL FORMAT"
block|}
block|,
block|{
name|CVT_BADDATE
block|,
literal|"DATE ILLEGAL"
block|}
block|,
block|{
name|CVT_BADTIME
block|,
literal|"TIME ILLEGAL"
block|}
block|,
block|{
name|CVT_ADDITIONAL
block|,
literal|"ADDITIONAL DATA"
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|bit
operator|&
name|lstate
condition|)
block|{
if|if
condition|(
name|buffer
index|[
literal|0
index|]
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|flagstrings
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * convert a clock status flag field to a string  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|clockstatus
parameter_list|(
name|u_long
name|lstate
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
specifier|static
struct|struct
name|status
block|{
name|u_long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|flagstrings
index|[]
init|=
block|{
block|{
name|CEVNT_NOMINAL
block|,
literal|"NOMINAL"
block|}
block|,
block|{
name|CEVNT_TIMEOUT
block|,
literal|"NO RESPONSE"
block|}
block|,
block|{
name|CEVNT_BADREPLY
block|,
literal|"BAD FORMAT"
block|}
block|,
block|{
name|CEVNT_FAULT
block|,
literal|"FAULT"
block|}
block|,
block|{
name|CEVNT_PROP
block|,
literal|"PROPAGATION DELAY"
block|}
block|,
block|{
name|CEVNT_BADDATE
block|,
literal|"ILLEGAL DATE"
block|}
block|,
block|{
name|CEVNT_BADTIME
block|,
literal|"ILLEGAL TIME"
block|}
block|,
block|{
operator|(
name|unsigned
operator|)
operator|~
literal|0L
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|value
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|value
operator|==
name|lstate
condition|)
block|{
return|return
name|flagstrings
index|[
name|i
index|]
operator|.
name|name
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"unknown #%ld"
argument_list|,
operator|(
name|u_long
operator|)
name|lstate
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * l_mktime - make representation of a relative time  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|l_mktime
parameter_list|(
name|u_long
name|delta
parameter_list|)
block|{
name|u_long
name|tmp
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|delta
operator|/
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%ldd+"
argument_list|,
operator|(
name|u_long
operator|)
name|tmp
argument_list|)
expr_stmt|;
name|delta
operator|-=
name|tmp
operator|*
literal|60
operator|*
literal|60
operator|*
literal|24
expr_stmt|;
block|}
name|s
operator|=
name|delta
operator|%
literal|60
expr_stmt|;
name|delta
operator|/=
literal|60
expr_stmt|;
name|m
operator|=
name|delta
operator|%
literal|60
expr_stmt|;
name|delta
operator|/=
literal|60
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%02d:%02d:%02d"
argument_list|,
operator|(
name|int
operator|)
name|delta
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
operator|(
name|int
operator|)
name|s
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse_statistics - list summary of clock states  */
end_comment

begin_function
specifier|static
name|void
name|parse_statistics
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKSTATIST
argument_list|)
comment|/* conditional if clause for conditional syslog */
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: running time: %s"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|l_mktime
argument_list|(
name|current_time
operator|-
name|parse
operator|->
name|generic
operator|->
name|timestarted
argument_list|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: current status: %s"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|clockstatus
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|currentstatus
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|CEVNT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|u_long
name|s_time
decl_stmt|;
name|u_long
name|percent
decl_stmt|,
name|d
init|=
name|current_time
operator|-
name|parse
operator|->
name|generic
operator|->
name|timestarted
decl_stmt|;
name|percent
operator|=
name|s_time
operator|=
name|PARSE_STATETIME
argument_list|(
name|parse
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
call|(
name|u_long
call|)
argument_list|(
operator|~
literal|0
argument_list|)
operator|/
literal|10000
operator|)
operator|<
name|percent
condition|)
block|{
name|percent
operator|/=
literal|10
expr_stmt|;
name|d
operator|/=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|d
condition|)
name|percent
operator|=
operator|(
name|percent
operator|*
literal|10000
operator|)
operator|/
name|d
expr_stmt|;
else|else
name|percent
operator|=
literal|10000
expr_stmt|;
if|if
condition|(
name|s_time
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: state %18s: %13s (%3ld.%02ld%%)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|clockstatus
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
argument_list|,
name|l_mktime
argument_list|(
name|s_time
argument_list|)
argument_list|,
name|percent
operator|/
literal|100
argument_list|,
name|percent
operator|%
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * cparse_statistics - wrapper for statistics call  */
end_comment

begin_function
specifier|static
name|void
name|cparse_statistics
parameter_list|(
specifier|register
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
if|if
condition|(
name|parse
operator|->
name|laststatistic
operator|+
name|PARSESTATISTICS
operator|<
name|current_time
condition|)
name|parse_statistics
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|parse
operator|->
name|laststatistic
operator|=
name|current_time
expr_stmt|;
block|}
end_function

begin_comment
comment|/**===========================================================================  ** ntp interface routines  **/
end_comment

begin_comment
comment|/*--------------------------------------------------  * parse_init - initialize internal parse driver data  */
end_comment

begin_function
specifier|static
name|void
name|parse_init
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
operator|(
name|caddr_t
operator|)
name|parseunits
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|parseunits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse_shutdown - shut down a PARSE clock  */
end_comment

begin_function
specifier|static
name|void
name|parse_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
decl_stmt|;
if|if
condition|(
name|parse
operator|&&
operator|!
name|parse
operator|->
name|peer
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_shutdown: INTERNAL ERROR, unit not in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * print statistics a last time and 	 * stop statistics machine 	 */
name|parse_statistics
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_end
condition|)
block|{
name|parse
operator|->
name|parse_type
operator|->
name|cl_end
argument_list|(
name|parse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parse
operator|->
name|binding
condition|)
name|PARSE_END
argument_list|(
name|parse
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the I/O module to turn us off.  We're history. 	 */
name|io_closeclock
argument_list|(
operator|&
name|parse
operator|->
name|generic
operator|->
name|io
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|parse
operator|->
name|kv
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: reference clock \"%s\" removed"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_description
argument_list|)
expr_stmt|;
name|parse
operator|->
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* unused now */
name|free
argument_list|(
name|parse
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse_start - open the PARSE devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|parse_start
parameter_list|(
name|int
name|sysunit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|u_int
name|unit
decl_stmt|;
name|int
name|fd232
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|tio
decl_stmt|;
comment|/* NEEDED FOR A LONG TIME ! */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
name|struct
name|termio
name|tio
decl_stmt|;
comment|/* NEEDED FOR A LONG TIME ! */
endif|#
directive|endif
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|char
name|parsedev
index|[
sizeof|sizeof
argument_list|(
name|PARSEDEVICE
argument_list|)
operator|+
literal|20
index|]
decl_stmt|;
name|parsectl_t
name|tmp_ctl
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|type
operator|=
name|CLK_TYPE
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|unit
operator|=
name|CLK_UNIT
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
operator|~
literal|0
operator|)
operator|||
operator|(
name|parse_clockinfo
index|[
name|type
index|]
operator|.
name|cl_description
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: unsupported clock type %d (max %d)"
argument_list|,
name|unit
argument_list|,
name|CLK_REALTYPE
argument_list|(
name|peer
argument_list|)
argument_list|,
name|ncltypes
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Unit okay, attempt to open the device. 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|parsedev
argument_list|,
name|PARSEDEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|O_NOCTTY
define|#
directive|define
name|O_NOCTTY
value|0
endif|#
directive|endif
name|fd232
operator|=
name|open
argument_list|(
name|parsedev
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
ifdef|#
directive|ifdef
name|O_NONBLOCK
operator||
name|O_NONBLOCK
endif|#
directive|endif
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd232
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: open of %s failed: %m"
argument_list|,
name|unit
argument_list|,
name|parsedev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|parse
operator|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|parseunit
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parse
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|parseunit
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|generic
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
comment|/* link up */
name|parse
operator|->
name|generic
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|parse
expr_stmt|;
comment|/* link down */
comment|/* 	 * Set up the structures 	 */
name|parse
operator|->
name|generic
operator|->
name|timestarted
operator|=
name|current_time
expr_stmt|;
name|parse
operator|->
name|lastchange
operator|=
name|current_time
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|currentstatus
operator|=
name|CEVNT_TIMEOUT
expr_stmt|;
comment|/* expect the worst */
name|parse
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|pollneeddata
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|laststatistic
operator|=
name|current_time
expr_stmt|;
name|parse
operator|->
name|lastformat
operator|=
operator|(
name|unsigned
name|short
operator|)
operator|~
literal|0
expr_stmt|;
comment|/* assume no format known */
name|parse
operator|->
name|time
operator|.
name|parse_status
operator|=
operator|(
name|unsigned
name|short
operator|)
operator|~
literal|0
expr_stmt|;
comment|/* be sure to mark initial status change */
name|parse
operator|->
name|lastmissed
operator|=
literal|0
expr_stmt|;
comment|/* assume got everything */
name|parse
operator|->
name|ppsserial
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|localdata
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
name|parse
operator|->
name|localstate
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|kv
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_ALL
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_type
operator|=
operator|&
name|parse_clockinfo
index|[
name|type
index|]
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|fudgetime1
operator|=
name|parse
operator|->
name|parse_type
operator|->
name|cl_basedelay
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|fudgetime2
operator|=
literal|0.0
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|clockdesc
operator|=
name|parse
operator|->
name|parse_type
operator|->
name|cl_description
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
name|parse
operator|->
name|parse_type
operator|->
name|cl_rootdelay
expr_stmt|;
name|peer
operator|->
name|sstclktype
operator|=
name|parse
operator|->
name|parse_type
operator|->
name|cl_type
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_REFCLOCK
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
literal|1
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|parse
operator|->
name|generic
operator|->
name|refid
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_id
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|parse
operator|->
name|generic
operator|->
name|refid
operator|=
name|htonl
argument_list|(
name|PARSEHSREFID
argument_list|)
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
operator|=
name|fd232
expr_stmt|;
name|parse
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
comment|/* marks it also as busy */
comment|/* 	 * configure terminal line 	 */
if|if
condition|(
name|TTY_GETATTR
argument_list|(
name|fd232
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: tcgetattr(%d,&tio): %m"
argument_list|,
name|unit
argument_list|,
name|fd232
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|_PC_VDISABLE
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tio
operator|.
name|c_cc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tio
operator|.
name|c_cc
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|disablec
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* pathconf can deliver -1 without changing errno ! */
name|disablec
operator|=
name|fpathconf
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|_PC_VDISABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|disablec
operator|==
operator|-
literal|1
operator|&&
name|errno
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: fpathconf(fd, _PC_VDISABLE): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tio
operator|.
name|c_cc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tio
operator|.
name|c_cc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* best guess */
block|}
elseif|else
if|if
condition|(
name|disablec
operator|!=
operator|-
literal|1
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tio
operator|.
name|c_cc
argument_list|,
name|disablec
argument_list|,
sizeof|sizeof
argument_list|(
name|tio
operator|.
name|c_cc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|VMIN
argument_list|)
operator|||
name|defined
argument_list|(
name|VTIME
argument_list|)
if|if
condition|(
operator|(
name|parse_clockinfo
index|[
name|type
index|]
operator|.
name|cl_lflag
operator|&
name|ICANON
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|VMIN
name|tio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VTIME
name|tio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|tio
operator|.
name|c_cflag
operator|=
name|parse_clockinfo
index|[
name|type
index|]
operator|.
name|cl_cflag
expr_stmt|;
name|tio
operator|.
name|c_iflag
operator|=
name|parse_clockinfo
index|[
name|type
index|]
operator|.
name|cl_iflag
expr_stmt|;
name|tio
operator|.
name|c_oflag
operator|=
name|parse_clockinfo
index|[
name|type
index|]
operator|.
name|cl_oflag
expr_stmt|;
name|tio
operator|.
name|c_lflag
operator|=
name|parse_clockinfo
index|[
name|type
index|]
operator|.
name|cl_lflag
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
if|if
condition|(
operator|(
name|cfsetospeed
argument_list|(
operator|&
name|tio
argument_list|,
name|parse_clockinfo
index|[
name|type
index|]
operator|.
name|cl_speed
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|cfsetispeed
argument_list|(
operator|&
name|tio
argument_list|,
name|parse_clockinfo
index|[
name|type
index|]
operator|.
name|cl_speed
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: tcset{i,o}speed(&tio, speed): %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
block|}
else|#
directive|else
name|tio
operator|.
name|c_cflag
operator||=
name|parse_clockinfo
index|[
name|type
index|]
operator|.
name|cl_speed
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TIO_SERIAL_STUFF
argument_list|)
comment|/* Linux hack: define PPS interface */
block|{
name|struct
name|serial_struct
name|ss
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCGSERIAL
argument_list|,
operator|&
name|ss
argument_list|)
operator|<
literal|0
operator|||
operator|(
ifdef|#
directive|ifdef
name|ASYNC_LOW_LATENCY
name|ss
operator|.
name|flags
operator||=
name|ASYNC_LOW_LATENCY
operator|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASYNC_PPS_CD_NEG
name|ss
operator|.
name|flags
operator||=
name|ASYNC_PPS_CD_NEG
operator|,
endif|#
directive|endif
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSSERIAL
argument_list|,
operator|&
name|ss
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_parse: TIOCSSERIAL fd %d, %m"
argument_list|,
name|fd232
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_parse: optional PPS processing not available"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse
operator|->
name|flags
operator||=
name|PARSE_PPSCLOCK
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"refclock_parse: PPS detection on"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIOCSPPS
comment|/* SUN PPS support */
if|if
condition|(
name|CLK_PPS
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
condition|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSPPS
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|parse
operator|->
name|flags
operator||=
name|PARSE_PPSCLOCK
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|TTY_SETATTR
argument_list|(
name|fd232
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: tcsetattr(%d,&tio): %m"
argument_list|,
name|unit
argument_list|,
name|fd232
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * Insert in async io device list. 	 */
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|parse
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|parse
operator|->
name|generic
operator|->
name|io
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: addclock %s fails (ABORT - clock type requires async io)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parsedev
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
block|}
name|parse
operator|->
name|binding
operator|=
name|init_iobinding
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|parse
operator|->
name|binding
operator|->
name|bd_receive
expr_stmt|;
comment|/* pick correct receive routine */
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|io_input
operator|=
name|parse
operator|->
name|binding
operator|->
name|bd_io_input
expr_stmt|;
comment|/* pick correct input routine */
if|if
condition|(
name|parse
operator|->
name|binding
operator|==
operator|(
name|bind_t
operator|*
operator|)
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: io sub system initialisation failed."
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
comment|/* well, ok - special initialisation broke */
block|}
comment|/* 	 * as we always(?) get 8 bit chars we want to be 	 * sure, that the upper bits are zero for less 	 * than 8 bit I/O - so we pass that information on. 	 * note that there can be only one bit count format 	 * per file descriptor 	 */
switch|switch
condition|(
name|tio
operator|.
name|c_cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|tmp_ctl
operator|.
name|parsesetcs
operator|.
name|parse_cs
operator|=
name|PARSE_IO_CS5
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|tmp_ctl
operator|.
name|parsesetcs
operator|.
name|parse_cs
operator|=
name|PARSE_IO_CS6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|tmp_ctl
operator|.
name|parsesetcs
operator|.
name|parse_cs
operator|=
name|PARSE_IO_CS7
expr_stmt|;
break|break;
case|case
name|CS8
case|:
name|tmp_ctl
operator|.
name|parsesetcs
operator|.
name|parse_cs
operator|=
name|PARSE_IO_CS8
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|PARSE_SETCS
argument_list|(
name|parse
argument_list|,
operator|&
name|tmp_ctl
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: parse_setcs() FAILED."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
comment|/* well, ok - special initialisation broke */
block|}
name|strcpy
argument_list|(
name|tmp_ctl
operator|.
name|parseformat
operator|.
name|parse_buffer
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_format
argument_list|)
expr_stmt|;
name|tmp_ctl
operator|.
name|parseformat
operator|.
name|parse_count
operator|=
name|strlen
argument_list|(
name|tmp_ctl
operator|.
name|parseformat
operator|.
name|parse_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PARSE_SETFMT
argument_list|(
name|parse
argument_list|,
operator|&
name|tmp_ctl
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: parse_setfmt() FAILED."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
comment|/* well, ok - special initialisation broke */
block|}
comment|/* 	 * get rid of all IO accumulated so far 	 */
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
operator|(
name|void
operator|)
name|tcflush
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TCIOFLUSH
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TCFLSH
block|{
ifndef|#
directive|ifndef
name|TCIOFLUSH
define|#
directive|define
name|TCIOFLUSH
value|2
endif|#
directive|endif
name|int
name|flshcmd
init|=
name|TCIOFLUSH
decl_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TCFLSH
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|flshcmd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * try to do any special initializations 	 */
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_init
condition|)
block|{
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_init
argument_list|(
name|parse
argument_list|)
condition|)
block|{
name|parse_shutdown
argument_list|(
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
comment|/* well, ok - special initialisation broke */
block|}
block|}
comment|/* 	 * get out Copyright information once 	 */
if|if
condition|(
operator|!
name|notice
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NTP PARSE support: Copyright (c) 1989-1999, Frank Kardel"
argument_list|)
expr_stmt|;
name|notice
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * print out configuration 	 */
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
block|{
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: reference clock \"%s\" (device %s) added"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_description
argument_list|,
name|parsedev
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d:  Stratum %d, %sPPS support, trust time %s, precision %d"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parse
operator|->
name|peer
operator|->
name|stratum
argument_list|,
name|CLK_PPS
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
condition|?
literal|""
else|:
literal|"no "
argument_list|,
name|l_mktime
argument_list|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_maxunsync
argument_list|)
argument_list|,
name|parse
operator|->
name|peer
operator|->
name|precision
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d:  rootdelay %.6f s, phaseadjust %.6f s, %s IO handling"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_rootdelay
argument_list|,
name|parse
operator|->
name|generic
operator|->
name|fudgetime1
argument_list|,
name|parse
operator|->
name|binding
operator|->
name|bd_description
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d:  Format recognition: %s"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d:  %sPPS ioctl support"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
operator|(
name|parse
operator|->
name|flags
operator|&
name|PARSE_PPSCLOCK
operator|)
condition|?
literal|""
else|:
literal|"NO "
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|parse_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
decl_stmt|;
if|if
condition|(
name|peer
operator|!=
name|parse
operator|->
name|peer
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: poll: INTERNAL: peer incorrect"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Update clock stat counters 	 */
name|parse
operator|->
name|generic
operator|->
name|polls
operator|++
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|pollneeddata
operator|&&
operator|(
operator|(
name|current_time
operator|-
name|parse
operator|->
name|pollneeddata
operator|)
operator|>
operator|(
literal|1
operator|<<
operator|(
name|max
argument_list|(
name|min
argument_list|(
name|parse
operator|->
name|peer
operator|->
name|hpoll
argument_list|,
name|parse
operator|->
name|peer
operator|->
name|ppoll
argument_list|)
argument_list|,
name|parse
operator|->
name|peer
operator|->
name|minpoll
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* 		 * start worrying when exceeding a poll inteval 		 * bad news - didn't get a response last time 		 */
name|parse
operator|->
name|generic
operator|->
name|noreply
operator|++
expr_stmt|;
name|parse
operator|->
name|lastmissed
operator|=
name|current_time
expr_stmt|;
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
name|ERR
argument_list|(
argument|ERR_NODATA
argument_list|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: no data from device within poll interval (check receiver / cableling)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * we just mark that we want the next sample for the clock filter 	 */
name|parse
operator|->
name|pollneeddata
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
condition|)
block|{
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
argument_list|(
name|parse
argument_list|)
expr_stmt|;
block|}
name|cparse_statistics
argument_list|(
name|parse
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|LEN_STATES
value|300
end_define

begin_comment
comment|/* length of state string */
end_comment

begin_comment
comment|/*--------------------------------------------------  * parse_control - set fudge factors, return statistics  */
end_comment

begin_function
specifier|static
name|void
name|parse_control
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|in
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
decl_stmt|;
name|parsectl_t
name|tmpctl
decl_stmt|;
specifier|static
name|char
name|outstatus
index|[
literal|400
index|]
decl_stmt|;
comment|/* status output buffer */
if|if
condition|(
name|out
condition|)
block|{
name|out
operator|->
name|lencode
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|p_lastcode
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|kv_list
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parse
operator|||
operator|!
name|parse
operator|->
name|peer
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_control: unit invalid (UNIT INACTIVE)"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|unit
operator|=
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
operator|(
name|CLK_HAVEFLAG1
operator||
name|CLK_HAVEFLAG2
operator||
name|CLK_HAVEFLAG3
operator||
name|CLK_HAVEFLAG4
operator|)
condition|)
block|{
name|parse
operator|->
name|flags
operator|=
name|in
operator|->
name|flags
operator|&
operator|(
name|CLK_FLAG1
operator||
name|CLK_FLAG2
operator||
name|CLK_FLAG3
operator||
name|CLK_FLAG4
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
condition|)
block|{
name|u_long
name|sum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|tt
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|outstatus
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|out
operator|->
name|type
operator|=
name|REFCLK_PARSE
expr_stmt|;
name|out
operator|->
name|haveflags
operator||=
name|CLK_HAVETIME2
expr_stmt|;
comment|/* 		 * figure out skew between PPS and RS232 - just for informational 		 * purposes - returned in time2 value 		 */
if|if
condition|(
name|PARSE_SYNC
argument_list|(
name|parse
operator|->
name|time
operator|.
name|parse_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|PARSE_PPS
argument_list|(
name|parse
operator|->
name|time
operator|.
name|parse_state
argument_list|)
operator|&&
name|PARSE_TIMECODE
argument_list|(
name|parse
operator|->
name|time
operator|.
name|parse_state
argument_list|)
condition|)
block|{
name|l_fp
name|off
decl_stmt|;
comment|/* 				 * we have a PPS and RS232 signal - calculate the skew 				 * WARNING: assumes on TIMECODE == PULSE (timecode after pulse) 				 */
name|off
operator|=
name|parse
operator|->
name|time
operator|.
name|parse_stime
operator|.
name|fp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|parse
operator|->
name|time
operator|.
name|parse_ptime
operator|.
name|fp
argument_list|)
expr_stmt|;
comment|/* true offset */
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|80
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_ppsskew=%s"
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|off
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PARSE_PPS
argument_list|(
name|parse
operator|->
name|time
operator|.
name|parse_state
argument_list|)
condition|)
block|{
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|80
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_ppstime=\"%s\""
argument_list|,
name|gmprettydate
argument_list|(
operator|&
name|parse
operator|->
name|time
operator|.
name|parse_ptime
operator|.
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|128
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_time=\""
argument_list|)
expr_stmt|;
name|tt
operator|+=
name|strlen
argument_list|(
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|time
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_ui
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|tt
argument_list|,
literal|"<UNDEFINED>\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"%s\""
argument_list|,
name|gmprettydate
argument_list|(
operator|&
name|parse
operator|->
name|time
operator|.
name|parse_time
operator|.
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|tt
operator|+
name|strlen
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PARSE_GETTIMECODE
argument_list|(
name|parse
argument_list|,
operator|&
name|tmpctl
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_INTERNAL
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_control: parse_timecode() FAILED"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|512
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_status=\""
argument_list|)
expr_stmt|;
name|tt
operator|+=
name|strlen
argument_list|(
name|tt
argument_list|)
expr_stmt|;
comment|/* 			 * copy PPS flags from last read transaction (informational only) 			 */
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_state
operator||=
name|parse
operator|->
name|time
operator|.
name|parse_state
operator|&
operator|(
name|PARSEB_PPS
operator||
name|PARSEB_S_PPS
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|parsestate
argument_list|(
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_state
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tt
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_count
condition|)
name|mkascii
argument_list|(
name|outstatus
operator|+
name|strlen
argument_list|(
name|outstatus
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|outstatus
argument_list|)
operator|-
name|strlen
argument_list|(
name|outstatus
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_count
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|badformat
operator|+=
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_badformat
expr_stmt|;
block|}
name|tmpctl
operator|.
name|parseformat
operator|.
name|parse_format
operator|=
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_format
expr_stmt|;
if|if
condition|(
operator|!
name|PARSE_GETFMT
argument_list|(
name|parse
argument_list|,
operator|&
name|tmpctl
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_INTERNAL
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_control: parse_getfmt() FAILED"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|80
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_format=\""
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tt
argument_list|,
name|tmpctl
operator|.
name|parseformat
operator|.
name|parse_buffer
argument_list|,
name|tmpctl
operator|.
name|parseformat
operator|.
name|parse_count
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tt
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * gather state statistics 		 */
name|start
operator|=
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
name|LEN_STATES
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tt
argument_list|,
literal|"refclock_states=\""
argument_list|)
expr_stmt|;
name|tt
operator|+=
name|strlen
argument_list|(
name|tt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|CEVNT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|u_long
name|s_time
decl_stmt|;
name|u_long
name|d
init|=
name|current_time
operator|-
name|parse
operator|->
name|generic
operator|->
name|timestarted
decl_stmt|;
name|u_long
name|percent
decl_stmt|;
name|percent
operator|=
name|s_time
operator|=
name|PARSE_STATETIME
argument_list|(
name|parse
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
call|(
name|u_long
call|)
argument_list|(
operator|~
literal|0
argument_list|)
operator|/
literal|10000
operator|)
operator|<
name|percent
condition|)
block|{
name|percent
operator|/=
literal|10
expr_stmt|;
name|d
operator|/=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|d
condition|)
name|percent
operator|=
operator|(
name|percent
operator|*
literal|10000
operator|)
operator|/
name|d
expr_stmt|;
else|else
name|percent
operator|=
literal|10000
expr_stmt|;
if|if
condition|(
name|s_time
condition|)
block|{
name|char
name|item
index|[
literal|80
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|sprintf
argument_list|(
name|item
argument_list|,
literal|"%s%s%s: %s (%d.%02d%%)"
argument_list|,
name|sum
condition|?
literal|"; "
else|:
literal|""
argument_list|,
operator|(
name|parse
operator|->
name|generic
operator|->
name|currentstatus
operator|==
name|i
operator|)
condition|?
literal|"*"
else|:
literal|""
argument_list|,
name|clockstatus
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
argument_list|,
name|l_mktime
argument_list|(
name|s_time
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|percent
operator|/
literal|100
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|percent
operator|%
literal|100
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|=
name|strlen
argument_list|(
name|item
argument_list|)
operator|)
operator|<
operator|(
name|LEN_STATES
operator|-
literal|40
operator|-
operator|(
name|tt
operator|-
name|start
operator|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|tt
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|tt
operator|+=
name|count
expr_stmt|;
block|}
name|sum
operator|+=
name|s_time
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"; running time: %s\""
argument_list|,
name|l_mktime
argument_list|(
name|sum
argument_list|)
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|32
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_id=\"%s\""
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_id
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|80
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_iomode=\"%s\""
argument_list|,
name|parse
operator|->
name|binding
operator|->
name|bd_description
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|128
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_driver_version=\"%s\""
argument_list|,
name|rcsid
argument_list|)
expr_stmt|;
block|{
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|k
operator|=
name|parse
operator|->
name|kv
expr_stmt|;
while|while
condition|(
name|k
operator|&&
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|)
block|{
name|set_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
name|k
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
operator|+
literal|1
argument_list|,
name|k
operator|->
name|flags
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
name|out
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|outstatus
argument_list|)
expr_stmt|;
name|out
operator|->
name|p_lastcode
operator|=
name|outstatus
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**===========================================================================  ** processing routines  **/
end_comment

begin_comment
comment|/*--------------------------------------------------  * event handling - note that nominal events will also be posted  */
end_comment

begin_function
specifier|static
name|void
name|parse_event
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|int
name|event
parameter_list|)
block|{
if|if
condition|(
name|parse
operator|->
name|generic
operator|->
name|currentstatus
operator|!=
operator|(
name|u_char
operator|)
name|event
condition|)
block|{
name|parse
operator|->
name|statetime
index|[
name|parse
operator|->
name|generic
operator|->
name|currentstatus
index|]
operator|+=
name|current_time
operator|-
name|parse
operator|->
name|lastchange
expr_stmt|;
name|parse
operator|->
name|lastchange
operator|=
name|current_time
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|currentstatus
operator|=
operator|(
name|u_char
operator|)
name|event
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_event
condition|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_event
argument_list|(
name|parse
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|CEVNT_NOMINAL
condition|)
block|{
name|parse
operator|->
name|generic
operator|->
name|lastevent
operator|=
name|parse
operator|->
name|generic
operator|->
name|currentstatus
expr_stmt|;
block|}
else|else
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: SYNCHRONIZED"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|==
name|CEVNT_FAULT
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKEVENT
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|ERR
argument_list|(
argument|ERR_BADEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"clock %s fault '%s' (0x%02x)"
argument_list|,
name|refnumtoa
argument_list|(
name|parse
operator|->
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ceventstr
argument_list|(
name|event
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKEVENT
argument_list|)
comment|/* conditional if clause for conditional syslog */
if|if
condition|(
name|event
operator|==
name|CEVNT_NOMINAL
operator|||
name|list_err
argument_list|(
name|parse
argument_list|,
name|ERR_BADEVENT
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"clock %s event '%s' (0x%02x)"
argument_list|,
name|refnumtoa
argument_list|(
name|parse
operator|->
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ceventstr
argument_list|(
name|event
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
name|report_event
argument_list|(
name|EVNT_PEERCLOCK
argument_list|,
name|parse
operator|->
name|peer
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_CLOCKEXCPT
argument_list|,
name|parse
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * process a PARSE time sample  */
end_comment

begin_function
specifier|static
name|void
name|parse_process
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsetime_t
modifier|*
name|parsetime
parameter_list|)
block|{
name|l_fp
name|off
decl_stmt|,
name|rectime
decl_stmt|,
name|reftime
decl_stmt|;
name|double
name|fudge
decl_stmt|;
comment|/* 	 * check for changes in conversion status 	 * (only one for each new status !) 	 */
if|if
condition|(
operator|(
operator|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|!=
name|CVT_OK
operator|)
operator|&&
operator|(
operator|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|!=
name|CVT_NONE
operator|)
operator|&&
operator|(
name|parse
operator|->
name|time
operator|.
name|parse_status
operator|!=
name|parsetime
operator|->
name|parse_status
operator|)
condition|)
block|{
name|char
name|buffer
index|[
literal|400
index|]
decl_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: conversion status \"%s\""
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parsestatus
argument_list|(
name|parsetime
operator|->
name|parse_status
argument_list|,
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|==
name|CVT_FAIL
condition|)
block|{
comment|/* 			 * tell more about the story - list time code 			 * there is a slight change for a race condition and 			 * the time code might be overwritten by the next packet 			 */
name|parsectl_t
name|tmpctl
decl_stmt|;
if|if
condition|(
operator|!
name|PARSE_GETTIMECODE
argument_list|(
name|parse
argument_list|,
operator|&
name|tmpctl
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_INTERNAL
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_process: parse_timecode() FAILED"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ERR
argument_list|(
argument|ERR_BADDATA
argument_list|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: FAILED TIMECODE: \"%s\" (check receiver configuration / cableling)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|mkascii
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_count
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|generic
operator|->
name|badformat
operator|+=
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_badformat
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * examine status and post appropriate events 	 */
if|if
condition|(
operator|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|!=
name|CVT_OK
condition|)
block|{
comment|/* 		 * got bad data - tell the rest of the system 		 */
switch|switch
condition|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_MASK
condition|)
block|{
case|case
name|CVT_NONE
case|:
if|if
condition|(
operator|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_ADDITIONAL
operator|)
operator|&&
name|parse
operator|->
name|parse_type
operator|->
name|cl_message
condition|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_message
argument_list|(
name|parse
argument_list|,
name|parsetime
argument_list|)
expr_stmt|;
break|break;
comment|/* well, still waiting - timeout is handled at higher levels */
case|case
name|CVT_FAIL
case|:
name|parse
operator|->
name|generic
operator|->
name|badformat
operator|++
expr_stmt|;
if|if
condition|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_BADFMT
condition|)
block|{
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_BADDATE
condition|)
block|{
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_BADTIME
condition|)
block|{
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
comment|/* for the lack of something better */
block|}
block|}
return|return;
comment|/* skip the rest - useless */
block|}
comment|/* 	 * check for format changes 	 * (in case somebody has swapped clocks 8-) 	 */
if|if
condition|(
name|parse
operator|->
name|lastformat
operator|!=
name|parsetime
operator|->
name|parse_format
condition|)
block|{
name|parsectl_t
name|tmpctl
decl_stmt|;
name|tmpctl
operator|.
name|parseformat
operator|.
name|parse_format
operator|=
name|parsetime
operator|->
name|parse_format
expr_stmt|;
if|if
condition|(
operator|!
name|PARSE_GETFMT
argument_list|(
name|parse
argument_list|,
operator|&
name|tmpctl
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_INTERNAL
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_getfmt() FAILED"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: packet format \"%s\""
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|tmpctl
operator|.
name|parseformat
operator|.
name|parse_buffer
argument_list|)
expr_stmt|;
block|}
name|parse
operator|->
name|lastformat
operator|=
name|parsetime
operator|->
name|parse_format
expr_stmt|;
block|}
comment|/* 	 * now, any changes ? 	 */
if|if
condition|(
name|parse
operator|->
name|time
operator|.
name|parse_state
operator|!=
name|parsetime
operator|->
name|parse_state
condition|)
block|{
name|char
name|tmp1
index|[
literal|200
index|]
decl_stmt|;
name|char
name|tmp2
index|[
literal|200
index|]
decl_stmt|;
comment|/* 		 * something happend 		 */
operator|(
name|void
operator|)
name|parsestate
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parsestate
argument_list|(
name|parse
operator|->
name|time
operator|.
name|parse_state
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: STATE CHANGE: %s -> %s"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|tmp2
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * remember for future 	 */
name|parse
operator|->
name|time
operator|=
operator|*
name|parsetime
expr_stmt|;
comment|/* 	 * check to see, whether the clock did a complete powerup or lost PZF signal 	 * and post correct events for current condition 	 */
if|if
condition|(
name|PARSE_POWERUP
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
comment|/* 		 * this is bad, as we have completely lost synchronisation 		 * well this is a problem with the receiver here 		 * for PARSE Meinberg DCF77 receivers the lost synchronisation 		 * is true as it is the powerup state and the time is taken 		 * from a crude real time clock chip 		 * for the PZF series this is only partly true, as 		 * PARSE_POWERUP only means that the pseudo random 		 * phase shift sequence cannot be found. this is only 		 * bad, if we have never seen the clock in the SYNC 		 * state, where the PHASE and EPOCH are correct. 		 * for reporting events the above business does not 		 * really matter, but we can use the time code 		 * even in the POWERUP state after having seen 		 * the clock in the synchronized state (PZF class 		 * receivers) unless we have had a telegram disruption 		 * after having seen the clock in the SYNC state. we 		 * thus require having seen the clock in SYNC state 		 * *after* having missed telegrams (noresponse) from 		 * the clock. one problem remains: we might use erroneously 		 * POWERUP data if the disruption is shorter than 1 polling 		 * interval. fortunately powerdowns last usually longer than 64 		 * seconds and the receiver is at least 2 minutes in the 		 * POWERUP or NOSYNC state before switching to SYNC 		 */
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKSTATUS
argument_list|)
name|ERR
argument_list|(
argument|ERR_BADSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: NOT SYNCHRONIZED"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * we have two states left 		 * 		 * SYNC: 		 *  this state means that the EPOCH (timecode) and PHASE 		 *  information has be read correctly (at least two 		 *  successive PARSE timecodes were received correctly) 		 *  this is the best possible state - full trust 		 * 		 * NOSYNC: 		 *  The clock should be on phase with respect to the second 		 *  signal, but the timecode has not been received correctly within 		 *  at least the last two minutes. this is a sort of half baked state 		 *  for PARSE Meinberg DCF77 clocks this is bad news (clock running 		 *  without timecode confirmation) 		 *  PZF 535 has also no time confirmation, but the phase should be 		 *  very precise as the PZF signal can be decoded 		 */
if|if
condition|(
name|PARSE_SYNC
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
comment|/* 			 * currently completely synchronized - best possible state 			 */
name|parse
operator|->
name|lastsync
operator|=
name|current_time
expr_stmt|;
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_BADSTATUS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * we have had some problems receiving the time code 			 */
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_PROP
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKSTATUS
argument_list|)
name|ERR
argument_list|(
argument|ERR_BADSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: TIMECODE NOT CONFIRMED"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fudge
operator|=
name|parse
operator|->
name|generic
operator|->
name|fudgetime1
expr_stmt|;
comment|/* standard RS232 Fudgefactor */
if|if
condition|(
name|PARSE_TIMECODE
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
name|rectime
operator|=
name|parsetime
operator|->
name|parse_stime
operator|.
name|fp
expr_stmt|;
name|off
operator|=
name|reftime
operator|=
name|parsetime
operator|->
name|parse_time
operator|.
name|fp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|rectime
argument_list|)
expr_stmt|;
comment|/* prepare for PPS adjustments logic */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"PARSE receiver #%d: Reftime %s, Recvtime %s - initial offset %s\n"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|prettydate
argument_list|(
operator|&
name|reftime
argument_list|)
argument_list|,
name|prettydate
argument_list|(
operator|&
name|rectime
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|off
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|PARSE_PPS
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
operator|&&
name|CLK_PPS
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
condition|)
block|{
name|l_fp
name|offset
decl_stmt|;
comment|/* 		 * we have a PPS signal - much better than the RS232 stuff (we hope) 		 */
name|offset
operator|=
name|parsetime
operator|->
name|parse_ptime
operator|.
name|fp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"PARSE receiver #%d: PPStime %s\n"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|prettydate
argument_list|(
operator|&
name|offset
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PARSE_TIMECODE
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|M_ISGEQ
argument_list|(
name|off
operator|.
name|l_i
argument_list|,
name|off
operator|.
name|l_f
argument_list|,
operator|-
literal|1
argument_list|,
literal|0x80000000
argument_list|)
operator|&&
name|M_ISGEQ
argument_list|(
literal|0
argument_list|,
literal|0x7fffffff
argument_list|,
name|off
operator|.
name|l_i
argument_list|,
name|off
operator|.
name|l_f
argument_list|)
condition|)
block|{
name|fudge
operator|=
name|parse
operator|->
name|generic
operator|->
name|fudgetime2
expr_stmt|;
comment|/* pick PPS fudge factor */
comment|/* 				 * RS232 offsets within [-0.5..0.5[ - take PPS offsets 				 */
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_flags
operator|&
name|PARSE_F_PPSONSECOND
condition|)
block|{
name|reftime
operator|=
name|off
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|reftime
operator|.
name|l_uf
operator|&
operator|(
name|unsigned
operator|)
literal|0x80000000
condition|)
name|reftime
operator|.
name|l_ui
operator|++
expr_stmt|;
name|reftime
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
comment|/* 					 * implied on second offset 					 */
name|off
operator|.
name|l_uf
operator|=
operator|~
name|off
operator|.
name|l_uf
expr_stmt|;
comment|/* map [0.5..1[ -> [-0.5..0[ */
name|off
operator|.
name|l_ui
operator|=
operator|(
name|off
operator|.
name|l_f
operator|<
literal|0
operator|)
condition|?
operator|~
literal|0
else|:
literal|0
expr_stmt|;
comment|/* sign extend */
block|}
else|else
block|{
comment|/* 					 * time code describes pulse 					 */
name|reftime
operator|=
name|off
operator|=
name|parsetime
operator|->
name|parse_time
operator|.
name|fp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|/* true offset */
block|}
block|}
comment|/* 			 * take RS232 offset when PPS when out of bounds 			 */
block|}
else|else
block|{
name|fudge
operator|=
name|parse
operator|->
name|generic
operator|->
name|fudgetime2
expr_stmt|;
comment|/* pick PPS fudge factor */
comment|/* 			 * Well, no time code to guide us - assume on second pulse 			 * and pray, that we are within [-0.5..0.5[ 			 */
name|off
operator|=
name|offset
expr_stmt|;
name|reftime
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|reftime
operator|.
name|l_uf
operator|&
operator|(
name|unsigned
operator|)
literal|0x80000000
condition|)
name|reftime
operator|.
name|l_ui
operator|++
expr_stmt|;
name|reftime
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
comment|/* 			 * implied on second offset 			 */
name|off
operator|.
name|l_uf
operator|=
operator|~
name|off
operator|.
name|l_uf
expr_stmt|;
comment|/* map [0.5..1[ -> [-0.5..0[ */
name|off
operator|.
name|l_ui
operator|=
operator|(
name|off
operator|.
name|l_f
operator|<
literal|0
operator|)
condition|?
operator|~
literal|0
else|:
literal|0
expr_stmt|;
comment|/* sign extend */
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|PARSE_TIMECODE
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
comment|/* 			 * Well, no PPS, no TIMECODE, no more work ... 			 */
if|if
condition|(
operator|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_ADDITIONAL
operator|)
operator|&&
name|parse
operator|->
name|parse_type
operator|->
name|cl_message
condition|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_message
argument_list|(
name|parse
argument_list|,
name|parsetime
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"PARSE receiver #%d: Reftime %s, Recvtime %s - final offset %s\n"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|prettydate
argument_list|(
operator|&
name|reftime
argument_list|)
argument_list|,
name|prettydate
argument_list|(
operator|&
name|rectime
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|off
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rectime
operator|=
name|reftime
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|rectime
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
comment|/* just to keep the ntp interface happy */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"PARSE receiver #%d: calculated Reftime %s, Recvtime %s\n"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|prettydate
argument_list|(
operator|&
name|reftime
argument_list|)
argument_list|,
name|prettydate
argument_list|(
operator|&
name|rectime
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_ADDITIONAL
operator|)
operator|&&
name|parse
operator|->
name|parse_type
operator|->
name|cl_message
condition|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_message
argument_list|(
name|parse
argument_list|,
name|parsetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|PARSE_SYNC
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
comment|/* 		 * log OK status 		 */
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
block|}
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_BADIO
argument_list|)
expr_stmt|;
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_BADDATA
argument_list|)
expr_stmt|;
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_NODATA
argument_list|)
expr_stmt|;
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_INTERNAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"PARSE receiver #%d: refclock_process_offset(reftime=%s, rectime=%s, Fudge=%f)\n"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|prettydate
argument_list|(
operator|&
name|reftime
argument_list|)
argument_list|,
name|prettydate
argument_list|(
operator|&
name|rectime
argument_list|)
argument_list|,
name|fudge
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|refclock_process_offset
argument_list|(
name|parse
operator|->
name|generic
argument_list|,
name|reftime
argument_list|,
name|rectime
argument_list|,
name|fudge
argument_list|)
expr_stmt|;
if|if
condition|(
name|PARSE_PPS
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
operator|&&
name|CLK_PPS
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|pps_sample
argument_list|(
operator|&
name|parse
operator|->
name|time
operator|.
name|parse_ptime
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * and now stick it into the clock machine 	 * samples are only valid iff lastsync is not too old and 	 * we have seen the clock in sync at least once 	 * after the last time we didn't see an expected data telegram 	 * see the clock states section above for more reasoning 	 */
if|if
condition|(
operator|(
operator|(
name|current_time
operator|-
name|parse
operator|->
name|lastsync
operator|)
operator|>
name|parse
operator|->
name|parse_type
operator|->
name|cl_maxunsync
operator|)
operator|||
operator|(
name|parse
operator|->
name|lastsync
operator|<=
name|parse
operator|->
name|lastmissed
operator|)
condition|)
block|{
name|parse
operator|->
name|generic
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PARSE_LEAPADD
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
comment|/* 			 * we pick this state also for time code that pass leap warnings 			 * without direction information (as earth is currently slowing 			 * down). 			 */
name|parse
operator|->
name|generic
operator|->
name|leap
operator|=
operator|(
name|parse
operator|->
name|flags
operator|&
name|PARSE_LEAP_DELETE
operator|)
condition|?
name|LEAP_DELSECOND
else|:
name|LEAP_ADDSECOND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PARSE_LEAPDEL
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
name|parse
operator|->
name|generic
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
block|}
else|else
block|{
name|parse
operator|->
name|generic
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
block|}
block|}
comment|/* 	 * ready, unless the machine wants a sample 	 */
if|if
condition|(
operator|!
name|parse
operator|->
name|pollneeddata
condition|)
return|return;
name|parse
operator|->
name|pollneeddata
operator|=
literal|0
expr_stmt|;
name|refclock_receive
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/**===========================================================================  ** special code for special clocks  **/
end_comment

begin_function
specifier|static
name|void
name|mk_utcinfo
parameter_list|(
name|char
modifier|*
name|t
parameter_list|,
name|int
name|wnt
parameter_list|,
name|int
name|wnlsf
parameter_list|,
name|int
name|dn
parameter_list|,
name|int
name|dtls
parameter_list|,
name|int
name|dtlsf
parameter_list|)
block|{
name|l_fp
name|leapdate
decl_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"current correction %d sec"
argument_list|,
name|dtls
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|wnlsf
operator|<
literal|990
condition|)
name|wnlsf
operator|+=
literal|1024
expr_stmt|;
if|if
condition|(
name|wnt
operator|<
literal|990
condition|)
name|wnt
operator|+=
literal|1024
expr_stmt|;
name|gpstolfp
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|wnlsf
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|dn
argument_list|,
literal|0
argument_list|,
operator|&
name|leapdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dtlsf
operator|!=
name|dtls
operator|)
operator|&&
operator|(
operator|(
name|wnlsf
operator|-
name|wnt
operator|)
operator|<
literal|52
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|", next correction %d sec on %s, new GPS-UTC offset %d"
argument_list|,
name|dtlsf
operator|-
name|dtls
argument_list|,
name|gmprettydate
argument_list|(
operator|&
name|leapdate
argument_list|)
argument_list|,
name|dtlsf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|", last correction on %s"
argument_list|,
name|gmprettydate
argument_list|(
operator|&
name|leapdate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CLOCK_MEINBERG
end_ifdef

begin_comment
comment|/**===========================================================================  ** Meinberg GPS166/GPS167 support  **/
end_comment

begin_comment
comment|/*------------------------------------------------------------  * gps16x_message - process GPS16x messages  */
end_comment

begin_function
specifier|static
name|void
name|gps16x_message
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsetime_t
modifier|*
name|parsetime
parameter_list|)
block|{
if|if
condition|(
name|parse
operator|->
name|time
operator|.
name|parse_msglen
operator|&&
name|parsetime
operator|->
name|parse_msg
index|[
literal|0
index|]
operator|==
name|SOH
condition|)
block|{
name|GPS_MSG_HDR
name|header
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bufp
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|parsetime
operator|->
name|parse_msg
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|char
name|msgbuffer
index|[
literal|600
index|]
decl_stmt|;
name|mkreadable
argument_list|(
name|msgbuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuffer
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|parsetime
operator|->
name|parse_msg
argument_list|,
name|parsetime
operator|->
name|parse_msglen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PARSE receiver #%d: received message (%d bytes)>%s<\n"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parsetime
operator|->
name|parse_msglen
argument_list|,
name|msgbuffer
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|get_mbg_header
argument_list|(
operator|&
name|bufp
argument_list|,
operator|&
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|gps_hdr_csum
operator|==
name|mbg_csum
argument_list|(
name|parsetime
operator|->
name|parse_msg
operator|+
literal|1
argument_list|,
literal|6
argument_list|)
operator|&&
operator|(
name|header
operator|.
name|gps_len
operator|==
literal|0
operator|||
operator|(
name|header
operator|.
name|gps_len
operator|<
sizeof|sizeof
argument_list|(
name|parsetime
operator|->
name|parse_msg
argument_list|)
operator|&&
name|header
operator|.
name|gps_data_csum
operator|==
name|mbg_csum
argument_list|(
name|bufp
argument_list|,
name|header
operator|.
name|gps_len
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 			 * clean message 			 */
switch|switch
condition|(
name|header
operator|.
name|gps_cmd
condition|)
block|{
case|case
name|GPS_SW_REV
case|:
block|{
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
name|SW_REV
name|gps_sw_rev
decl_stmt|;
name|get_mbg_sw_rev
argument_list|(
operator|&
name|bufp
argument_list|,
operator|&
name|gps_sw_rev
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"meinberg_gps_version=\"%x.%02x%s%s\""
argument_list|,
operator|(
name|gps_sw_rev
operator|.
name|code
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|,
name|gps_sw_rev
operator|.
name|code
operator|&
literal|0xFF
argument_list|,
name|gps_sw_rev
operator|.
name|name
index|[
literal|0
index|]
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|gps_sw_rev
operator|.
name|name
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
literal|64
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GPS_STAT
case|:
block|{
specifier|static
struct|struct
name|state
block|{
name|unsigned
name|short
name|flag
decl_stmt|;
comment|/* status flag */
name|unsigned
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
comment|/* bit name */
block|}
name|states
index|[]
init|=
block|{
block|{
name|TM_ANT_DISCONN
block|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"ANTENNA FAULTY"
block|}
block|,
block|{
name|TM_SYN_FLAG
block|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"NO SYNC SIGNAL"
block|}
block|,
block|{
name|TM_NO_SYNC
block|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"NO SYNC POWERUP"
block|}
block|,
block|{
name|TM_NO_POS
block|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"NO POSITION"
block|}
block|,
block|{
literal|0
block|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|""
block|}
block|}
struct|;
name|unsigned
name|short
name|status
decl_stmt|;
name|struct
name|state
modifier|*
name|s
init|=
name|states
decl_stmt|;
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|status
operator|=
name|get_lsb_short
argument_list|(
operator|&
name|bufp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"meinberg_gps_status=\"[0x%04x] "
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|p
operator|=
name|b
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|flag
condition|)
block|{
if|if
condition|(
name|status
operator|&
name|s
operator|->
name|flag
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|b
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|strcat
argument_list|(
name|p
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|s
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"<OK>\""
argument_list|)
expr_stmt|;
block|}
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
literal|64
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GPS_POS_XYZ
case|:
block|{
name|XYZ
name|xyz
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|get_mbg_xyz
argument_list|(
operator|&
name|bufp
argument_list|,
name|xyz
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"gps_position(XYZ)=\"%s m, %s m, %s m\""
argument_list|,
name|mfptoa
argument_list|(
name|xyz
index|[
name|XP
index|]
operator|.
name|l_ui
argument_list|,
name|xyz
index|[
name|XP
index|]
operator|.
name|l_uf
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mfptoa
argument_list|(
name|xyz
index|[
name|YP
index|]
operator|.
name|l_ui
argument_list|,
name|xyz
index|[
name|YP
index|]
operator|.
name|l_uf
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mfptoa
argument_list|(
name|xyz
index|[
name|ZP
index|]
operator|.
name|l_ui
argument_list|,
name|xyz
index|[
name|ZP
index|]
operator|.
name|l_uf
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GPS_POS_LLA
case|:
block|{
name|LLA
name|lla
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|get_mbg_lla
argument_list|(
operator|&
name|bufp
argument_list|,
name|lla
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"gps_position(LLA)=\"%s deg, %s deg, %s m\""
argument_list|,
name|mfptoa
argument_list|(
name|lla
index|[
name|LAT
index|]
operator|.
name|l_ui
argument_list|,
name|lla
index|[
name|LAT
index|]
operator|.
name|l_uf
argument_list|,
literal|4
argument_list|)
argument_list|,
name|mfptoa
argument_list|(
name|lla
index|[
name|LON
index|]
operator|.
name|l_ui
argument_list|,
name|lla
index|[
name|LON
index|]
operator|.
name|l_uf
argument_list|,
literal|4
argument_list|)
argument_list|,
name|mfptoa
argument_list|(
name|lla
index|[
name|ALT
index|]
operator|.
name|l_ui
argument_list|,
name|lla
index|[
name|ALT
index|]
operator|.
name|l_uf
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GPS_TZDL
case|:
break|break;
case|case
name|GPS_PORT_PARM
case|:
break|break;
case|case
name|GPS_SYNTH
case|:
break|break;
case|case
name|GPS_ANT_INFO
case|:
block|{
name|ANT_INFO
name|antinfo
decl_stmt|;
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|get_mbg_antinfo
argument_list|(
operator|&
name|bufp
argument_list|,
operator|&
name|antinfo
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
literal|"meinberg_antenna_status=\""
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|antinfo
operator|.
name|status
condition|)
block|{
case|case
name|ANT_INVALID
case|:
name|strcat
argument_list|(
name|p
argument_list|,
literal|"<OK>"
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANT_DISCONN
case|:
name|strcat
argument_list|(
name|p
argument_list|,
literal|"DISCONNECTED since "
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKSTATUS
argument_list|)
name|ERR
argument_list|(
argument|ERR_BADSTATUS
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: ANTENNA FAILURE: %s"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mbg_tm_str
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
operator|&
name|antinfo
operator|.
name|tm_disconn
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|ANT_RECONN
case|:
name|strcat
argument_list|(
name|p
argument_list|,
literal|"RECONNECTED on "
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mbg_tm_str
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
operator|&
name|antinfo
operator|.
name|tm_reconn
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|", reconnect clockoffset %c%ld.%07ld s, disconnect time "
argument_list|,
operator|(
name|antinfo
operator|.
name|delta_t
operator|<
literal|0
operator|)
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|ABS
argument_list|(
name|antinfo
operator|.
name|delta_t
argument_list|)
operator|/
literal|10000
argument_list|,
name|ABS
argument_list|(
name|antinfo
operator|.
name|delta_t
argument_list|)
operator|%
literal|10000
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mbg_tm_str
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
operator|&
name|antinfo
operator|.
name|tm_disconn
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"bad status 0x%04x"
argument_list|,
name|antinfo
operator|.
name|status
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GPS_UCAP
case|:
break|break;
case|case
name|GPS_CFGH
case|:
block|{
name|CFGH
name|cfgh
decl_stmt|;
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|get_mbg_cfgh
argument_list|(
operator|&
name|bufp
argument_list|,
operator|&
name|cfgh
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfgh
operator|.
name|valid
condition|)
block|{
name|int
name|i
decl_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"gps_tot_51=\""
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mbg_tgps_str
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
operator|&
name|cfgh
operator|.
name|tot_51
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"gps_tot_63=\""
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mbg_tgps_str
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
operator|&
name|cfgh
operator|.
name|tot_63
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"gps_t0a=\""
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mbg_tgps_str
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
operator|&
name|cfgh
operator|.
name|t0a
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|RO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_SVNO
init|;
name|i
operator|<=
name|MAX_SVNO
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|buffer
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"gps_cfg[%d]=\"[0x%x] "
argument_list|,
name|i
argument_list|,
name|cfgh
operator|.
name|cfg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cfgh
operator|.
name|cfg
index|[
name|i
index|]
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"BLOCK I"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"BLOCK II"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"bad CFG"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcat
argument_list|(
name|p
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"gps_health[%d]=\"[0x%x] "
argument_list|,
name|i
argument_list|,
name|cfgh
operator|.
name|health
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|cfgh
operator|.
name|health
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"OK;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"PARITY;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"TLM/HOW;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"Z-COUNT;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"SUBFRAME 1,2,3;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"SUBFRAME 4,5;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"UPLOAD BAD;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"DATA BAD;"
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cfgh
operator|.
name|health
index|[
name|i
index|]
operator|&
literal|0x1F
condition|)
block|{
case|case
literal|0
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"SIGNAL OK"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1C
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"SV TEMP OUT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1D
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"SV WILL BE TEMP OUT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1E
case|:
break|break;
case|case
literal|0x1F
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"MULTIPLE ERRS"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"TRANSMISSION PROBLEMS"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcat
argument_list|(
name|p
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|RO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|GPS_ALM
case|:
break|break;
case|case
name|GPS_EPH
case|:
break|break;
case|case
name|GPS_UTC
case|:
block|{
name|UTC
name|utc
decl_stmt|;
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|get_mbg_utc
argument_list|(
operator|&
name|bufp
argument_list|,
operator|&
name|utc
argument_list|)
expr_stmt|;
if|if
condition|(
name|utc
operator|.
name|valid
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"gps_utc_correction=\""
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mk_utcinfo
argument_list|(
name|p
argument_list|,
name|utc
operator|.
name|t0t
operator|.
name|wn
argument_list|,
name|utc
operator|.
name|WNlsf
argument_list|,
name|utc
operator|.
name|DNt
argument_list|,
name|utc
operator|.
name|delta_tls
argument_list|,
name|utc
operator|.
name|delta_tlsf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"gps_utc_correction=\"<NO UTC DATA>\""
argument_list|)
expr_stmt|;
block|}
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GPS_IONO
case|:
break|break;
case|case
name|GPS_ASCII_MSG
case|:
block|{
name|ASCII_MSG
name|gps_ascii_msg
decl_stmt|;
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|;
name|get_mbg_ascii_msg
argument_list|(
operator|&
name|bufp
argument_list|,
operator|&
name|gps_ascii_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|gps_ascii_msg
operator|.
name|valid
condition|)
block|{
name|char
name|buffer1
index|[
literal|128
index|]
decl_stmt|;
name|mkreadable
argument_list|(
name|buffer1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer1
argument_list|)
argument_list|,
name|gps_ascii_msg
operator|.
name|s
argument_list|,
name|strlen
argument_list|(
name|gps_ascii_msg
operator|.
name|s
argument_list|)
argument_list|,
operator|(
name|int
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"gps_message=\"%s\""
argument_list|,
name|buffer1
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"gps_message=<NONE>"
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|buffer
argument_list|,
literal|128
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"PARSE receiver #%d: gps16x_message: message checksum error: hdr_csum = 0x%x (expected 0x%lx), data_len = %d, data_csum = 0x%x (expected 0x%lx)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|header
operator|.
name|gps_hdr_csum
argument_list|,
name|mbg_csum
argument_list|(
name|parsetime
operator|->
name|parse_msg
operator|+
literal|1
argument_list|,
literal|6
argument_list|)
argument_list|,
name|header
operator|.
name|gps_len
argument_list|,
name|header
operator|.
name|gps_data_csum
argument_list|,
name|mbg_csum
argument_list|(
name|bufp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|header
operator|.
name|gps_len
operator|<
sizeof|sizeof
argument_list|(
name|parsetime
operator|->
name|parse_msg
argument_list|)
operator|)
condition|?
name|header
operator|.
name|gps_len
else|:
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------  * gps16x_poll - query the reciver peridically  */
end_comment

begin_function
specifier|static
name|void
name|gps16x_poll
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
decl_stmt|;
specifier|static
name|GPS_MSG_HDR
name|sequence
index|[]
init|=
block|{
block|{
name|GPS_SW_REV
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|GPS_STAT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|GPS_UTC
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|GPS_ASCII_MSG
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|GPS_ANT_INFO
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|GPS_CFGH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|GPS_POS_XYZ
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|GPS_POS_LLA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|(
name|unsigned
name|short
operator|)
operator|~
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|int
name|rtc
decl_stmt|;
name|unsigned
name|char
name|cmd_buffer
index|[
literal|64
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|outp
init|=
name|cmd_buffer
decl_stmt|;
name|GPS_MSG_HDR
modifier|*
name|header
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|rate
condition|)
block|{
name|parse
operator|->
name|peer
operator|->
name|nextaction
operator|=
name|current_time
operator|+
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|rate
expr_stmt|;
block|}
if|if
condition|(
name|sequence
index|[
name|parse
operator|->
name|localstate
index|]
operator|.
name|gps_cmd
operator|==
operator|(
name|unsigned
name|short
operator|)
operator|~
literal|0
condition|)
name|parse
operator|->
name|localstate
operator|=
literal|0
expr_stmt|;
name|header
operator|=
name|sequence
operator|+
name|parse
operator|->
name|localstate
operator|++
expr_stmt|;
operator|*
name|outp
operator|++
operator|=
name|SOH
expr_stmt|;
comment|/* start command */
name|put_mbg_header
argument_list|(
operator|&
name|outp
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|outp
operator|=
name|cmd_buffer
operator|+
literal|1
expr_stmt|;
name|header
operator|->
name|gps_hdr_csum
operator|=
operator|(
name|short
operator|)
name|mbg_csum
argument_list|(
name|outp
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|put_mbg_header
argument_list|(
operator|&
name|outp
argument_list|,
name|header
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|;
name|mkreadable
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cmd_buffer
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|outp
operator|-
name|cmd_buffer
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PARSE receiver #%d: transmitted message #%ld (%d bytes)>%s<\n"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parse
operator|->
name|localstate
operator|-
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|outp
operator|-
name|cmd_buffer
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|rtc
operator|=
name|write
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|cmd_buffer
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|outp
operator|-
name|cmd_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtc
operator|<
literal|0
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_BADIO
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: gps16x_poll: failed to send cmd to clock: %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtc
operator|!=
name|outp
operator|-
name|cmd_buffer
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_BADIO
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: gps16x_poll: failed to send cmd incomplete (%d of %d bytes sent)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|rtc
argument_list|,
call|(
name|int
call|)
argument_list|(
name|outp
operator|-
name|cmd_buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_BADIO
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * init routine - setup timer  */
end_comment

begin_function
specifier|static
name|int
name|gps16x_poll_init
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|rate
condition|)
block|{
name|parse
operator|->
name|peer
operator|->
name|action
operator|=
name|gps16x_poll
expr_stmt|;
name|gps16x_poll
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|gps16x_message
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsetime_t
modifier|*
name|parsetime
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|int
name|gps16x_poll_init
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLOCK_MEINBERG */
end_comment

begin_escape
end_escape

begin_comment
comment|/**===========================================================================  ** clock polling support  **/
end_comment

begin_comment
comment|/*--------------------------------------------------  * direct poll routine  */
end_comment

begin_function
specifier|static
name|void
name|poll_dpoll
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
name|int
name|rtc
decl_stmt|;
specifier|const
name|char
modifier|*
name|ps
init|=
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|string
decl_stmt|;
name|int
name|ct
init|=
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|count
decl_stmt|;
name|rtc
operator|=
name|write
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|ps
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtc
operator|<
literal|0
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_BADIO
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: poll_dpoll: failed to send cmd to clock: %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtc
operator|!=
name|ct
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_BADIO
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: poll_dpoll: failed to send cmd incomplete (%d of %d bytes sent)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|rtc
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_BADIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * periodic poll routine  */
end_comment

begin_function
specifier|static
name|void
name|poll_poll
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
decl_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
condition|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|rate
condition|)
block|{
name|parse
operator|->
name|peer
operator|->
name|nextaction
operator|=
name|current_time
operator|+
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|rate
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * init routine - setup timer  */
end_comment

begin_function
specifier|static
name|int
name|poll_init
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|rate
condition|)
block|{
name|parse
operator|->
name|peer
operator|->
name|action
operator|=
name|poll_poll
expr_stmt|;
name|poll_poll
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/**===========================================================================  ** Trimble support  **/
end_comment

begin_comment
comment|/*-------------------------------------------------------------  * trimble TAIP init routine - setup EOL and then do poll_init.  */
end_comment

begin_function
specifier|static
name|int
name|trimbletaip_init
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|tio
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
name|struct
name|termio
name|tio
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * configure terminal line for trimble receiver 	 */
if|if
condition|(
name|TTY_GETATTR
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: trimbletaip_init: tcgetattr(fd,&tio): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|tio
operator|.
name|c_cc
index|[
name|VEOL
index|]
operator|=
name|TRIMBLETAIP_EOL
expr_stmt|;
if|if
condition|(
name|TTY_SETATTR
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: trimbletaip_init: tcsetattr(fd,&tio): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|poll_init
argument_list|(
name|parse
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * trimble TAIP event routine - reset receiver upon data format trouble  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|taipinit
index|[]
init|=
block|{
literal|">FPV00000000<"
block|,
literal|">SRM;ID_FLAG=F;CS_FLAG=T;EC_FLAG=F;FR_FLAG=T;CR_FLAG=F<"
block|,
literal|">FTM00020001<"
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|trimbletaip_event
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|int
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|CEVNT_BADREPLY
case|:
comment|/* reset on garbled input */
case|case
name|CEVNT_TIMEOUT
case|:
comment|/* reset on no input */
block|{
specifier|const
name|char
modifier|*
modifier|*
name|iv
decl_stmt|;
name|iv
operator|=
name|taipinit
expr_stmt|;
while|while
condition|(
operator|*
name|iv
condition|)
block|{
name|int
name|rtc
init|=
name|write
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|*
name|iv
argument_list|,
name|strlen
argument_list|(
operator|*
name|iv
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtc
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: trimbletaip_event: failed to send cmd to clock: %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|rtc
operator|!=
name|strlen
argument_list|(
operator|*
name|iv
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: trimbletaip_event: failed to send cmd incomplete (%d of %d bytes sent)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|rtc
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|*
name|iv
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|iv
operator|++
expr_stmt|;
block|}
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|ERR
argument_list|(
argument|ERR_BADIO
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: trimbletaip_event: RECEIVER INITIALIZED"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* ignore */
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * This driver supports the Trimble SVee Six Plus GPS receiver module.  * It should support other Trimble receivers which use the Trimble Standard  * Interface Protocol (see below).  *  * The module has a serial I/O port for command/data and a 1 pulse-per-second  * output, about 1 microsecond wide. The leading edge of the pulse is  * coincident with the change of the GPS second. This is the same as  * the change of the UTC second +/- ~1 microsecond. Some other clocks  * specifically use a feature in the data message as a timing reference, but  * the SVee Six Plus does not do this. In fact there is considerable jitter  * on the timing of the messages, so this driver only supports the use  * of the PPS pulse for accurate timing. Where it is determined that  * the offset is way off, when first starting up ntpd for example,  * the timing of the data stream is used until the offset becomes low enough  * (|offset|< CLOCK_MAX), at which point the pps offset is used.  *  * It can use either option for receiving PPS information - the 'ppsclock'  * stream pushed onto the serial data interface to timestamp the Carrier  * Detect interrupts, where the 1PPS connects to the CD line. This only  * works on SunOS 4.1.x currently. To select this, define PPSPPS in  * Config.local. The other option is to use a pulse-stretcher/level-converter  * to convert the PPS pulse into a RS232 start pulse& feed this into another  * tty port. To use this option, define PPSCLK in Config.local. The pps input,  * by whichever method, is handled in ntp_loopfilter.c  *  * The receiver uses a serial message protocol called Trimble Standard  * Interface Protocol (it can support others but this driver only supports  * TSIP). Messages in this protocol have the following form:  *  *<DLE><id> ...<data> ...<DLE><ETX>  *  * Any bytes within the<data> portion of value 10 hex (<DLE>) are doubled  * on transmission and compressed back to one on reception. Otherwise  * the values of data bytes can be anything. The serial interface is RS-422  * asynchronous using 9600 baud, 8 data bits with odd party (**note** 9 bits  * in total!), and 1 stop bit. The protocol supports byte, integer, single,  * and double datatypes. Integers are two bytes, sent most significant first.  * Singles are IEEE754 single precision floating point numbers (4 byte) sent  * sign& exponent first. Doubles are IEEE754 double precision floating point  * numbers (8 byte) sent sign& exponent first.  * The receiver supports a large set of messages, only a small subset of  * which are used here. From driver to receiver the following are used:  *  *  ID    Description  *  *  21    Request current time  *  22    Mode Select  *  2C    Set/Request operating parameters  *  2F    Request UTC info  *  35    Set/Request I/O options   * From receiver to driver the following are recognised:  *  *  ID    Description  *  *  41    GPS Time  *  44    Satellite selection, PDOP, mode  *  46    Receiver health  *  4B    Machine code/status  *  4C    Report operating parameters (debug only)  *  4F    UTC correction data (used to get leap second warnings)  *  55    I/O options (debug only)  *  * All others are accepted but ignored.  *  */
end_comment

begin_define
define|#
directive|define
name|PI
value|3.1415926535898
end_define

begin_comment
comment|/* lots of sig figs */
end_comment

begin_define
define|#
directive|define
name|D2R
value|PI/180.0
end_define

begin_comment
comment|/*-------------------------------------------------------------------  * sendcmd, sendbyte, sendetx, sendflt, sendint implement the command  * interface to the receiver.  *  * CAVEAT: the sendflt, sendint routines are byte order dependend and  * float implementation dependend - these must be converted to portable  * versions !  *  * CURRENT LIMITATION: float implementation. This runs only on systems  * with IEEE754 floats as native floats  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|trimble
block|{
name|u_long
name|last_msg
decl_stmt|;
comment|/* last message received */
name|u_char
name|qtracking
decl_stmt|;
comment|/* query tracking status */
name|u_long
name|ctrack
decl_stmt|;
comment|/* current tracking set */
name|u_long
name|ltrack
decl_stmt|;
comment|/* last tracking set */
block|}
name|trimble_t
typedef|;
end_typedef

begin_union
union|union
name|uval
block|{
name|u_char
name|bd
index|[
literal|8
index|]
decl_stmt|;
name|int
name|iv
decl_stmt|;
name|float
name|fv
decl_stmt|;
name|double
name|dv
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|txbuf
block|{
name|short
name|idx
decl_stmt|;
comment|/* index to first unused byte */
name|u_char
modifier|*
name|txt
decl_stmt|;
comment|/* pointer to actual data buffer */
block|}
struct|;
end_struct

begin_decl_stmt
name|void
name|sendcmd
name|P
argument_list|(
operator|(
expr|struct
name|txbuf
operator|*
name|buf
operator|,
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sendbyte
name|P
argument_list|(
operator|(
expr|struct
name|txbuf
operator|*
name|buf
operator|,
name|int
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sendetx
name|P
argument_list|(
operator|(
expr|struct
name|txbuf
operator|*
name|buf
operator|,
expr|struct
name|parseunit
operator|*
name|parse
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sendint
name|P
argument_list|(
operator|(
expr|struct
name|txbuf
operator|*
name|buf
operator|,
name|int
name|a
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sendflt
name|P
argument_list|(
operator|(
expr|struct
name|txbuf
operator|*
name|buf
operator|,
name|double
name|a
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sendcmd
parameter_list|(
name|struct
name|txbuf
modifier|*
name|buf
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|buf
operator|->
name|txt
index|[
literal|0
index|]
operator|=
name|DLE
expr_stmt|;
name|buf
operator|->
name|txt
index|[
literal|1
index|]
operator|=
operator|(
name|u_char
operator|)
name|c
expr_stmt|;
name|buf
operator|->
name|idx
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sendbyte
parameter_list|(
name|struct
name|txbuf
modifier|*
name|buf
parameter_list|,
name|int
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
name|DLE
condition|)
name|buf
operator|->
name|txt
index|[
name|buf
operator|->
name|idx
operator|++
index|]
operator|=
name|DLE
expr_stmt|;
name|buf
operator|->
name|txt
index|[
name|buf
operator|->
name|idx
operator|++
index|]
operator|=
operator|(
name|u_char
operator|)
name|b
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sendetx
parameter_list|(
name|struct
name|txbuf
modifier|*
name|buf
parameter_list|,
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
name|buf
operator|->
name|txt
index|[
name|buf
operator|->
name|idx
operator|++
index|]
operator|=
name|DLE
expr_stmt|;
name|buf
operator|->
name|txt
index|[
name|buf
operator|->
name|idx
operator|++
index|]
operator|=
name|ETX
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|buf
operator|->
name|txt
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|buf
operator|->
name|idx
argument_list|)
operator|!=
name|buf
operator|->
name|idx
condition|)
block|{
name|ERR
argument_list|(
argument|ERR_BADIO
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: sendetx: failed to send cmd to clock: %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|mkreadable
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|->
name|txt
argument_list|,
operator|(
name|unsigned
operator|)
name|buf
operator|->
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PARSE receiver #%d: transmitted message (%d bytes)>%s<\n"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|buf
operator|->
name|idx
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|clear_err
argument_list|(
name|parse
argument_list|,
name|ERR_BADIO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendint
parameter_list|(
name|struct
name|txbuf
modifier|*
name|buf
parameter_list|,
name|int
name|a
parameter_list|)
block|{
comment|/* send 16bit int, msbyte first */
name|sendbyte
argument_list|(
name|buf
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|a
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|sendbyte
argument_list|(
name|buf
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|a
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sendflt
parameter_list|(
name|struct
name|txbuf
modifier|*
name|buf
parameter_list|,
name|double
name|a
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|union
name|uval
name|uval
decl_stmt|;
name|uval
operator|.
name|fv
operator|=
name|a
expr_stmt|;
ifdef|#
directive|ifdef
name|WORDS_BIGENDIAN
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|3
condition|;
name|i
operator|++
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
endif|#
directive|endif
name|sendbyte
argument_list|(
name|buf
argument_list|,
name|uval
operator|.
name|bd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|TRIM_POS_OPT
value|0x13
end_define

begin_comment
comment|/* output position with high precision */
end_comment

begin_define
define|#
directive|define
name|TRIM_TIME_OPT
value|0x03
end_define

begin_comment
comment|/* use UTC time stamps, on second */
end_comment

begin_comment
comment|/*--------------------------------------------------  * trimble TSIP setup routine  */
end_comment

begin_function
specifier|static
name|int
name|trimbletsip_setup
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|u_char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|txbuf
name|buf
decl_stmt|;
name|buf
operator|.
name|txt
operator|=
name|buffer
expr_stmt|;
name|sendcmd
argument_list|(
operator|&
name|buf
argument_list|,
name|CMD_CVERSION
argument_list|)
expr_stmt|;
comment|/* request software versions */
name|sendetx
argument_list|(
operator|&
name|buf
argument_list|,
name|parse
argument_list|)
expr_stmt|;
name|sendcmd
argument_list|(
operator|&
name|buf
argument_list|,
name|CMD_COPERPARAM
argument_list|)
expr_stmt|;
comment|/* set operating parameters */
name|sendbyte
argument_list|(
operator|&
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* static */
name|sendflt
argument_list|(
operator|&
name|buf
argument_list|,
literal|5.0
operator|*
name|D2R
argument_list|)
expr_stmt|;
comment|/* elevation angle mask = 10 deg XXX */
name|sendflt
argument_list|(
operator|&
name|buf
argument_list|,
literal|4.0
argument_list|)
expr_stmt|;
comment|/* s/n ratio mask = 6 XXX */
name|sendflt
argument_list|(
operator|&
name|buf
argument_list|,
literal|12.0
argument_list|)
expr_stmt|;
comment|/* PDOP mask = 12 */
name|sendflt
argument_list|(
operator|&
name|buf
argument_list|,
literal|8.0
argument_list|)
expr_stmt|;
comment|/* PDOP switch level = 8 */
name|sendetx
argument_list|(
operator|&
name|buf
argument_list|,
name|parse
argument_list|)
expr_stmt|;
name|sendcmd
argument_list|(
operator|&
name|buf
argument_list|,
name|CMD_CMODESEL
argument_list|)
expr_stmt|;
comment|/* fix mode select */
name|sendbyte
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* automatic */
name|sendetx
argument_list|(
operator|&
name|buf
argument_list|,
name|parse
argument_list|)
expr_stmt|;
name|sendcmd
argument_list|(
operator|&
name|buf
argument_list|,
name|CMD_CMESSAGE
argument_list|)
expr_stmt|;
comment|/* request system message */
name|sendetx
argument_list|(
operator|&
name|buf
argument_list|,
name|parse
argument_list|)
expr_stmt|;
name|sendcmd
argument_list|(
operator|&
name|buf
argument_list|,
name|CMD_CSUPER
argument_list|)
expr_stmt|;
comment|/* superpacket fix */
name|sendbyte
argument_list|(
operator|&
name|buf
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
comment|/* binary mode */
name|sendetx
argument_list|(
operator|&
name|buf
argument_list|,
name|parse
argument_list|)
expr_stmt|;
name|sendcmd
argument_list|(
operator|&
name|buf
argument_list|,
name|CMD_CIOOPTIONS
argument_list|)
expr_stmt|;
comment|/* set I/O options */
name|sendbyte
argument_list|(
operator|&
name|buf
argument_list|,
name|TRIM_POS_OPT
argument_list|)
expr_stmt|;
comment|/* position output */
name|sendbyte
argument_list|(
operator|&
name|buf
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* no velocity output */
name|sendbyte
argument_list|(
operator|&
name|buf
argument_list|,
name|TRIM_TIME_OPT
argument_list|)
expr_stmt|;
comment|/* UTC, compute on seconds */
name|sendbyte
argument_list|(
operator|&
name|buf
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* no raw measurements */
name|sendetx
argument_list|(
operator|&
name|buf
argument_list|,
name|parse
argument_list|)
expr_stmt|;
name|sendcmd
argument_list|(
operator|&
name|buf
argument_list|,
name|CMD_CUTCPARAM
argument_list|)
expr_stmt|;
comment|/* request UTC correction data */
name|sendetx
argument_list|(
operator|&
name|buf
argument_list|,
name|parse
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|ERR
argument_list|(
argument|ERR_BADIO
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: trimbletsip_setup: RECEIVER RE-INITIALIZED (%s)"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * TRIMBLE TSIP check routine  */
end_comment

begin_function
specifier|static
name|void
name|trimble_check
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
decl_stmt|;
name|trimble_t
modifier|*
name|t
init|=
name|parse
operator|->
name|localdata
decl_stmt|;
name|u_char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|txbuf
name|buf
decl_stmt|;
name|buf
operator|.
name|txt
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|current_time
operator|>
name|t
operator|->
name|last_msg
operator|+
name|TRIMBLETSIP_IDLE_TIME
condition|)
operator|(
name|void
operator|)
name|trimbletsip_setup
argument_list|(
name|parse
argument_list|,
literal|"message timeout"
argument_list|)
expr_stmt|;
block|}
name|poll_poll
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
expr_stmt|;
comment|/* emit query string and re-arm timer */
if|if
condition|(
name|t
operator|->
name|qtracking
condition|)
block|{
name|u_long
name|oldsats
init|=
name|t
operator|->
name|ltrack
operator|&
operator|~
name|t
operator|->
name|ctrack
decl_stmt|;
name|t
operator|->
name|qtracking
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|ltrack
operator|=
name|t
operator|->
name|ctrack
expr_stmt|;
if|if
condition|(
name|oldsats
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|oldsats
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|oldsats
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|sendcmd
argument_list|(
operator|&
name|buf
argument_list|,
name|CMD_CSTATTRACK
argument_list|)
expr_stmt|;
name|sendbyte
argument_list|(
operator|&
name|buf
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* old sat */
name|sendetx
argument_list|(
operator|&
name|buf
argument_list|,
name|parse
argument_list|)
expr_stmt|;
block|}
name|oldsats
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
name|sendcmd
argument_list|(
operator|&
name|buf
argument_list|,
name|CMD_CSTATTRACK
argument_list|)
expr_stmt|;
name|sendbyte
argument_list|(
operator|&
name|buf
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* current tracking set */
name|sendetx
argument_list|(
operator|&
name|buf
argument_list|,
name|parse
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * TRIMBLE TSIP end routine  */
end_comment

begin_function
specifier|static
name|void
name|trimbletsip_end
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
name|trimble_t
modifier|*
name|t
init|=
name|parse
operator|->
name|localdata
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|parse
operator|->
name|localdata
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|parse
operator|->
name|peer
operator|->
name|nextaction
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|peer
operator|->
name|action
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * TRIMBLE TSIP init routine  */
end_comment

begin_function
specifier|static
name|int
name|trimbletsip_init
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|VEOL
argument_list|)
operator|||
name|defined
argument_list|(
name|VEOL2
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|tio
decl_stmt|;
comment|/* NEEDED FOR A LONG TIME ! */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
name|struct
name|termio
name|tio
decl_stmt|;
comment|/* NEEDED FOR A LONG TIME ! */
endif|#
directive|endif
comment|/* 	 * allocate local data area 	 */
if|if
condition|(
operator|!
name|parse
operator|->
name|localdata
condition|)
block|{
name|trimble_t
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|(
name|trimble_t
operator|*
operator|)
operator|(
name|parse
operator|->
name|localdata
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|trimble_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|trimble_t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|last_msg
operator|=
name|current_time
expr_stmt|;
block|}
block|}
name|parse
operator|->
name|peer
operator|->
name|action
operator|=
name|trimble_check
expr_stmt|;
name|parse
operator|->
name|peer
operator|->
name|nextaction
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * configure terminal line for ICANON mode with VEOL characters 	 */
if|if
condition|(
name|TTY_GETATTR
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: trimbletsip_init: tcgetattr(%d,&tio): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|parse_clockinfo
index|[
name|CLK_TYPE
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
index|]
operator|.
name|cl_lflag
operator|&
name|ICANON
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VEOL
name|tio
operator|.
name|c_cc
index|[
name|VEOL
index|]
operator|=
name|ETX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VEOL2
name|tio
operator|.
name|c_cc
index|[
name|VEOL2
index|]
operator|=
name|DLE
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|TTY_SETATTR
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: trimbletsip_init: tcsetattr(%d,&tio): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|,
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
return|return
name|trimbletsip_setup
argument_list|(
name|parse
argument_list|,
literal|"initial startup"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------  * trimbletsip_event - handle Trimble events  * simple evente handler - attempt to re-initialize receiver  */
end_comment

begin_function
specifier|static
name|void
name|trimbletsip_event
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|int
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|CEVNT_BADREPLY
case|:
comment|/* reset on garbled input */
case|case
name|CEVNT_TIMEOUT
case|:
comment|/* reset on no input */
operator|(
name|void
operator|)
name|trimbletsip_setup
argument_list|(
name|parse
argument_list|,
literal|"event BAD_REPLY/TIMEOUT"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* ignore */
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * getflt, getint convert fields in the incoming data into the  * appropriate type of item  *  * CAVEAT: these routines are currently definitely byte order dependent  * and assume Representation(float) == IEEE754  * These functions MUST be converted to portable versions (especially  * converting the float representation into ntp_fp formats in order  * to avoid floating point operations at all!  */
end_comment

begin_function
specifier|static
name|float
name|getflt
parameter_list|(
name|u_char
modifier|*
name|bp
parameter_list|)
block|{
name|union
name|uval
name|uval
decl_stmt|;
ifdef|#
directive|ifdef
name|WORDS_BIGENDIAN
name|uval
operator|.
name|bd
index|[
literal|0
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|1
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|2
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|3
index|]
operator|=
operator|*
name|bp
expr_stmt|;
else|#
directive|else
comment|/* ! WORDS_BIGENDIAN */
name|uval
operator|.
name|bd
index|[
literal|3
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|2
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|1
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|0
index|]
operator|=
operator|*
name|bp
expr_stmt|;
endif|#
directive|endif
comment|/* ! WORDS_BIGENDIAN */
return|return
name|uval
operator|.
name|fv
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|getdbl
parameter_list|(
name|u_char
modifier|*
name|bp
parameter_list|)
block|{
name|union
name|uval
name|uval
decl_stmt|;
ifdef|#
directive|ifdef
name|WORDS_BIGENDIAN
name|uval
operator|.
name|bd
index|[
literal|0
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|1
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|2
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|3
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|4
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|5
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|6
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|7
index|]
operator|=
operator|*
name|bp
expr_stmt|;
else|#
directive|else
comment|/* ! WORDS_BIGENDIAN */
name|uval
operator|.
name|bd
index|[
literal|7
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|6
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|5
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|4
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|3
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|2
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|1
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|0
index|]
operator|=
operator|*
name|bp
expr_stmt|;
endif|#
directive|endif
comment|/* ! WORDS_BIGENDIAN */
return|return
name|uval
operator|.
name|dv
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getshort
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|get_msb_short
argument_list|(
operator|&
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * trimbletsip_message - process trimble messages  */
end_comment

begin_define
define|#
directive|define
name|RTOD
value|(180.0 / 3.1415926535898)
end_define

begin_define
define|#
directive|define
name|mb
parameter_list|(
name|_X_
parameter_list|)
value|(buffer[2+(_X_)])
end_define

begin_comment
comment|/* shortcut for buffer access */
end_comment

begin_function
specifier|static
name|void
name|trimbletsip_message
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|,
name|parsetime_t
modifier|*
name|parsetime
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
name|parsetime
operator|->
name|parse_msg
decl_stmt|;
name|unsigned
name|int
name|size
init|=
name|parsetime
operator|->
name|parse_msglen
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|<
literal|4
operator|)
operator|||
operator|(
name|buffer
index|[
literal|0
index|]
operator|!=
name|DLE
operator|)
operator|||
operator|(
name|buffer
index|[
name|size
operator|-
literal|1
index|]
operator|!=
name|ETX
operator|)
operator|||
operator|(
name|buffer
index|[
name|size
operator|-
literal|2
index|]
operator|!=
name|DLE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"TRIMBLE BAD packet, size %d:\n	"
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%2.2x, "
argument_list|,
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|15
condition|)
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
else|else
block|{
name|int
name|var_flag
decl_stmt|;
name|trimble_t
modifier|*
name|tr
init|=
name|parse
operator|->
name|localdata
decl_stmt|;
name|unsigned
name|int
name|cmd
init|=
name|buffer
index|[
literal|1
index|]
decl_stmt|;
name|char
name|pbuffer
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|t
init|=
name|pbuffer
decl_stmt|;
name|cmd_info_t
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"TRIMBLE packet 0x%02x, size %d:\n	"
argument_list|,
name|cmd
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%2.2x, "
argument_list|,
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|15
condition|)
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tr
condition|)
name|tr
operator|->
name|last_msg
operator|=
name|current_time
expr_stmt|;
name|s
operator|=
name|trimble_convert
argument_list|(
name|cmd
argument_list|,
name|trimble_rcmds
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%s=\""
argument_list|,
name|s
operator|->
name|varname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"TRIMBLE unknown command 0x%02x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|var_flag
operator|=
name|s
operator|->
name|varmode
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CMD_RCURTIME
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%f, %d, %f"
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|6
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_RBEST4
case|:
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"mode: "
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0xF
condition|)
block|{
default|default:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"0x%x"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0x7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|strcat
argument_list|(
name|t
argument_list|,
literal|"0D"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcat
argument_list|(
name|t
argument_list|,
literal|"2D"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|strcat
argument_list|(
name|t
argument_list|,
literal|"3D"
argument_list|)
expr_stmt|;
break|break;
block|}
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0x10
condition|)
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"-MANUAL, "
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"-AUTO, "
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"satellites %02d %02d %02d %02d, PDOP %.2f, HDOP %.2f, VDOP %.2f, TDOP %.2f"
argument_list|,
name|mb
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|2
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|3
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|5
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|9
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|13
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|17
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_RVERSION
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%d.%d (%d/%d/%d)"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0xff
argument_list|,
name|mb
argument_list|(
literal|1
argument_list|)
operator|&
literal|0xff
argument_list|,
literal|1900
operator|+
operator|(
name|mb
argument_list|(
literal|4
argument_list|)
operator|&
literal|0xff
operator|)
argument_list|,
name|mb
argument_list|(
literal|2
argument_list|)
operator|&
literal|0xff
argument_list|,
name|mb
argument_list|(
literal|3
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_RRECVHEALTH
case|:
block|{
specifier|static
specifier|const
name|char
modifier|*
name|msgs
index|[]
init|=
block|{
literal|"Battery backup failed"
block|,
literal|"Signal processor error"
block|,
literal|"Alignment error, channel or chip 1"
block|,
literal|"Alignment error, channel or chip 2"
block|,
literal|"Antenna feed line fault"
block|,
literal|"Excessive ref freq. error"
block|,
literal|"<BIT 6>"
block|,
literal|"<BIT 7>"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|;
switch|switch
condition|(
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0xFF
condition|)
block|{
default|default:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"illegal value 0x%02x"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x00
case|:
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"doing position fixes"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"no GPS time yet"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"PDOP too high"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"no usable satellites"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x09
case|:
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"only ONE usable satellite"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0A
case|:
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"only TWO usable satellites"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0B
case|:
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"only THREE usable satellites"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0C
case|:
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"the chosen satellite is unusable"
argument_list|)
expr_stmt|;
break|break;
block|}
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|bits
operator|=
name|mb
argument_list|(
literal|1
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bits
operator|&
operator|(
literal|0x1
operator|<<
name|i
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|", %s"
argument_list|,
name|msgs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CMD_RMESSAGE
case|:
name|mkreadable
argument_list|(
name|t
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|pbuffer
argument_list|)
operator|-
operator|(
name|t
operator|-
name|pbuffer
operator|)
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|size
operator|-
literal|2
operator|-
operator|(
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
operator|-
name|buffer
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_RMACHSTAT
case|:
block|{
specifier|static
specifier|const
name|char
modifier|*
name|msgs
index|[]
init|=
block|{
literal|"Synthesizer Fault"
block|,
literal|"Battery Powered Time Clock Fault"
block|,
literal|"A-to-D Converter Fault"
block|,
literal|"The almanac stored in the receiver is not complete and current"
block|,
literal|"<BIT 4>"
block|,
literal|"<BIT 5"
block|,
literal|"<BIT 6>"
block|,
literal|"<BIT 7>"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"machine id 0x%02x"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|bits
operator|=
name|mb
argument_list|(
literal|1
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bits
operator|&
operator|(
literal|0x1
operator|<<
name|i
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|", %s"
argument_list|,
name|msgs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|t
argument_list|,
literal|", Superpackets %ssupported"
argument_list|,
operator|(
name|mb
argument_list|(
literal|2
argument_list|)
operator|&
literal|0xFF
operator|)
condition|?
literal|""
else|:
literal|"un"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_ROPERPARAM
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%2x %.1f %.1f %.1f %.1f"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|5
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|9
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|13
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_RUTCPARAM
case|:
block|{
name|float
name|t0t
init|=
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|14
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|wnt
init|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|18
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|dtls
init|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|12
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|wnlsf
init|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|20
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|dn
init|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|22
argument_list|)
argument_list|)
decl_stmt|;
name|short
name|dtlsf
init|=
name|getshort
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|24
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|t0t
operator|!=
literal|0
condition|)
block|{
name|mk_utcinfo
argument_list|(
name|t
argument_list|,
name|wnt
argument_list|,
name|wnlsf
argument_list|,
name|dn
argument_list|,
name|dtls
argument_list|,
name|dtlsf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"<NO UTC DATA>"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CMD_RSAT1BIAS
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%.1fm %.2fm/s at %.1fs"
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_RIOOPTIONS
case|:
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%02x %02x %02x %02x"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|2
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
argument_list|(
literal|0
argument_list|)
operator|!=
name|TRIM_POS_OPT
operator|||
name|mb
argument_list|(
literal|2
argument_list|)
operator|!=
name|TRIM_TIME_OPT
condition|)
block|{
operator|(
name|void
operator|)
name|trimbletsip_setup
argument_list|(
name|parse
argument_list|,
literal|"bad io options"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CMD_RSPOSXYZ
case|:
block|{
name|double
name|x
init|=
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|y
init|=
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|z
init|=
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|8
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|f
init|=
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|12
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|>
literal|0.0
condition|)
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"x= %.1fm, y= %.1fm, z= %.1fm, time_of_fix= %f sec"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
break|break;
case|case
name|CMD_RSLLAPOS
case|:
block|{
name|double
name|lat
init|=
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|lng
init|=
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|f
init|=
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|12
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|>
literal|0.0
condition|)
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"lat %f %c, long %f %c, alt %.2fm"
argument_list|,
operator|(
operator|(
name|lat
operator|<
literal|0.0
operator|)
condition|?
operator|(
operator|-
name|lat
operator|)
else|:
operator|(
name|lat
operator|)
operator|)
operator|*
name|RTOD
argument_list|,
operator|(
name|lat
operator|<
literal|0.0
condition|?
literal|'S'
else|:
literal|'N'
operator|)
argument_list|,
operator|(
operator|(
name|lng
operator|<
literal|0.0
operator|)
condition|?
operator|(
operator|-
name|lng
operator|)
else|:
operator|(
name|lng
operator|)
operator|)
operator|*
name|RTOD
argument_list|,
operator|(
name|lng
operator|<
literal|0.0
condition|?
literal|'W'
else|:
literal|'E'
operator|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
break|break;
case|case
name|CMD_RDOUBLEXYZ
case|:
block|{
name|double
name|x
init|=
name|getdbl
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|y
init|=
name|getdbl
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|8
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|z
init|=
name|getdbl
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|16
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"x= %.1fm, y= %.1fm, z= %.1fm"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_RDOUBLELLA
case|:
block|{
name|double
name|lat
init|=
name|getdbl
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|lng
init|=
name|getdbl
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|8
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"lat %f %c, lon %f %c, alt %.2fm"
argument_list|,
operator|(
operator|(
name|lat
operator|<
literal|0.0
operator|)
condition|?
operator|(
operator|-
name|lat
operator|)
else|:
operator|(
name|lat
operator|)
operator|)
operator|*
name|RTOD
argument_list|,
operator|(
name|lat
operator|<
literal|0.0
condition|?
literal|'S'
else|:
literal|'N'
operator|)
argument_list|,
operator|(
operator|(
name|lng
operator|<
literal|0.0
operator|)
condition|?
operator|(
operator|-
name|lng
operator|)
else|:
operator|(
name|lng
operator|)
operator|)
operator|*
name|RTOD
argument_list|,
operator|(
name|lng
operator|<
literal|0.0
condition|?
literal|'W'
else|:
literal|'E'
operator|)
argument_list|,
name|getdbl
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_RALLINVIEW
case|:
block|{
name|int
name|i
decl_stmt|,
name|sats
decl_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"mode: "
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0x7
condition|)
block|{
default|default:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"0x%x"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0x7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcat
argument_list|(
name|t
argument_list|,
literal|"2D"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|strcat
argument_list|(
name|t
argument_list|,
literal|"3D"
argument_list|)
expr_stmt|;
break|break;
block|}
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0x8
condition|)
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"-MANUAL, "
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"-AUTO, "
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|sats
operator|=
operator|(
name|mb
argument_list|(
literal|0
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0xF
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"PDOP %.2f, HDOP %.2f, VDOP %.2f, TDOP %.2f, %d satellite%s in view: "
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|5
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|9
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|13
argument_list|)
argument_list|)
argument_list|,
name|sats
argument_list|,
operator|(
name|sats
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sats
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%s%02d"
argument_list|,
name|i
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|mb
argument_list|(
literal|17
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
condition|)
name|tr
operator|->
name|ctrack
operator||=
operator|(
literal|1
operator|<<
operator|(
name|mb
argument_list|(
literal|17
operator|+
name|i
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tr
condition|)
block|{
comment|/* mark for tracking status query */
name|tr
operator|->
name|qtracking
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CMD_RSTATTRACK
case|:
block|{
name|sprintf
argument_list|(
name|t
operator|-
literal|2
argument_list|,
literal|"[%02d]=\""
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add index to var name */
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|)
operator|<
literal|0.0
condition|)
block|{
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"<NO MEASUREMENTS>"
argument_list|)
expr_stmt|;
name|var_flag
operator|&=
operator|~
name|DEF
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"ch=%d, acq=%s, eph=%d, signal_level= %5.2f, elevation= %5.2f, azimuth= %6.2f"
argument_list|,
operator|(
name|mb
argument_list|(
literal|1
argument_list|)
operator|&
literal|0xFF
operator|)
operator|>>
literal|3
argument_list|,
name|mb
argument_list|(
literal|2
argument_list|)
condition|?
operator|(
operator|(
name|mb
argument_list|(
literal|2
argument_list|)
operator|==
literal|1
operator|)
condition|?
literal|"ACQ"
else|:
literal|"SRCH"
operator|)
else|:
literal|"NEVER"
argument_list|,
name|mb
argument_list|(
literal|3
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|12
argument_list|)
argument_list|)
operator|*
name|RTOD
argument_list|,
name|getflt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mb
argument_list|(
literal|16
argument_list|)
argument_list|)
operator|*
name|RTOD
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
argument_list|(
literal|20
argument_list|)
condition|)
block|{
name|var_flag
operator|&=
operator|~
name|DEF
expr_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
literal|", OLD"
argument_list|)
expr_stmt|;
block|}
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
argument_list|(
literal|22
argument_list|)
condition|)
block|{
if|if
condition|(
name|mb
argument_list|(
literal|22
argument_list|)
operator|==
literal|1
condition|)
name|strcpy
argument_list|(
name|t
argument_list|,
literal|", BAD PARITY"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mb
argument_list|(
literal|22
argument_list|)
operator|==
literal|2
condition|)
name|strcpy
argument_list|(
name|t
argument_list|,
literal|", BAD EPH HEALTH"
argument_list|)
expr_stmt|;
block|}
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
argument_list|(
literal|23
argument_list|)
condition|)
name|strcpy
argument_list|(
name|t
argument_list|,
literal|", collecting data"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"<UNDECODED>"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcat
argument_list|(
name|t
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|set_var
argument_list|(
operator|&
name|parse
operator|->
name|kv
argument_list|,
name|pbuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuffer
argument_list|)
argument_list|,
name|var_flag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/**============================================================  ** RAWDCF support  **/
end_comment

begin_comment
comment|/*--------------------------------------------------  * rawdcf_init_1 - set up modem lines for RAWDCF receivers  * SET DTR line  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCMSET
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TIOCM_DTR
argument_list|)
operator|||
name|defined
argument_list|(
name|CIOCM_DTR
argument_list|)
operator|)
end_if

begin_function
specifier|static
name|int
name|rawdcf_init_1
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
comment|/* 	 * You can use the RS232 to supply the power for a DCF77 receiver. 	 * Here a voltage between the DTR and the RTS line is used. Unfortunately 	 * the name has changed from CIOCM_DTR to TIOCM_DTR recently. 	 */
ifdef|#
directive|ifdef
name|TIOCM_DTR
name|int
name|sl232
init|=
name|TIOCM_DTR
decl_stmt|;
comment|/* turn on DTR for power supply */
else|#
directive|else
name|int
name|sl232
init|=
name|CIOCM_DTR
decl_stmt|;
comment|/* turn on DTR for power supply */
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sl232
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"PARSE receiver #%d: rawdcf_init_1: WARNING: ioctl(fd, TIOCMSET, [C|T]IOCM_DTR): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|rawdcfdtr_init
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"PARSE receiver #%d: rawdcf_init_1: WARNING: OS interface incapable of setting DTR to power DCF modules"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DTR initialisation type */
end_comment

begin_comment
comment|/*--------------------------------------------------  * rawdcf_init_2 - set up modem lines for RAWDCF receivers  * CLR DTR line, SET RTS line  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCMSET
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TIOCM_RTS
argument_list|)
operator|||
name|defined
argument_list|(
name|CIOCM_RTS
argument_list|)
operator|)
end_if

begin_function
specifier|static
name|int
name|rawdcf_init_2
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
comment|/* 	 * You can use the RS232 to supply the power for a DCF77 receiver. 	 * Here a voltage between the DTR and the RTS line is used. Unfortunately 	 * the name has changed from CIOCM_DTR to TIOCM_DTR recently. 	 */
ifdef|#
directive|ifdef
name|TIOCM_RTS
name|int
name|sl232
init|=
name|TIOCM_RTS
decl_stmt|;
comment|/* turn on RTS, clear DTR for power supply */
else|#
directive|else
name|int
name|sl232
init|=
name|CIOCM_RTS
decl_stmt|;
comment|/* turn on DTR for power supply */
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|generic
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sl232
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"PARSE receiver #%d: rawdcf_init_2: WARNING: ioctl(fd, TIOCMSET, [C|T]IOCM_RTS): %m"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|rawdcf_init_2
parameter_list|(
name|struct
name|parseunit
modifier|*
name|parse
parameter_list|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"PARSE receiver #%d: rawdcf_init_2: WARNING: OS interface incapable of setting RTS to power DCF modules"
argument_list|,
name|CLK_UNIT
argument_list|(
name|parse
operator|->
name|peer
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DTR initialisation type */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(REFCLOCK)&& defined(PARSE) */
end_comment

begin_decl_stmt
name|int
name|refclock_parse_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(REFCLOCK)&& defined(PARSE) */
end_comment

begin_comment
comment|/*  * History:  *  * refclock_parse.c,v  * Revision 4.36  1999/11/28 17:18:20  kardel  * disabled burst mode  *  * Revision 4.35  1999/11/28 09:14:14  kardel  * RECON_4_0_98F  *  * Revision 4.34  1999/05/14 06:08:05  kardel  * store current_time in a suitable container (u_long)  *  * Revision 4.33  1999/05/13 21:48:38  kardel  * double the no response timeout interval  *  * Revision 4.32  1999/05/13 20:09:13  kardel  * complain only about missing polls after a full poll interval  *  * Revision 4.31  1999/05/13 19:59:32  kardel  * add clock type 16 for RTS set DTR clr in RAWDCF  *  * Revision 4.30  1999/02/28 20:36:43  kardel  * fixed printf fmt  *  * Revision 4.29  1999/02/28 19:58:23  kardel  * updated copyright information  *  * Revision 4.28  1999/02/28 19:01:50  kardel  * improved debug out on sent Meinberg messages  *  * Revision 4.27  1999/02/28 18:05:55  kardel  * no linux/ppsclock.h stuff  *  * Revision 4.26  1999/02/28 15:27:27  kardel  * wharton clock integration  *  * Revision 4.25  1999/02/28 14:04:46  kardel  * added missing double quotes to UTC information string  *  * Revision 4.24  1999/02/28 12:06:50  kardel  * (parse_control): using gmprettydate instead of prettydate()  * (mk_utcinfo): new function for formatting GPS derived UTC information  * (gps16x_message): changed to use mk_utcinfo()  * (trimbletsip_message): changed to use mk_utcinfo()  * ignoring position information in unsynchronized mode  * (parse_start): augument linux support for optional ASYNC_LOW_LATENCY  *  * Revision 4.23  1999/02/23 19:47:53  kardel  * fixed #endifs  * (stream_receive): fixed formats  *  * Revision 4.22  1999/02/22 06:21:02  kardel  * use new autoconfig symbols  *  * Revision 4.21  1999/02/21 12:18:13  kardel  * 4.91f reconcilation  *  * Revision 4.20  1999/02/21 10:53:36  kardel  * initial Linux PPSkit version  *  * Revision 4.19  1999/02/07 09:10:45  kardel  * clarify STREAMS mitigation rules in comment  *  * Revision 4.18  1998/12/20 23:45:34  kardel  * fix types and warnings  *  * Revision 4.17  1998/11/15 21:24:51  kardel  * cannot access mbg_ routines when CLOCK_MEINBERG  * is not defined  *  * Revision 4.16  1998/11/15 20:28:17  kardel  * Release 4.0.73e13 reconcilation  *  * Revision 4.15  1998/08/22 21:56:08  kardel  * fixed IO handling for non-STREAM IO  *  * Revision 4.14  1998/08/16 19:00:48  kardel  * (gps16x_message): reduced UTC parameter information (dropped A0,A1)  * made uval a local variable (killed one of the last globals)  * (sendetx): added logging of messages when in debug mode  * (trimble_check): added periodic checks to facilitate re-initialization  * (trimbletsip_init): made use of EOL character if in non-kernel operation  * (trimbletsip_message): extended message interpretation  * (getdbl): fixed data conversion  *  * Revision 4.13  1998/08/09 22:29:13  kardel  * Trimble TSIP support  *  * Revision 4.12  1998/07/11 10:05:34  kardel  * Release 4.0.73d reconcilation  *  * Revision 4.11  1998/06/14 21:09:42  kardel  * Sun acc cleanup  *  * Revision 4.10  1998/06/13 12:36:45  kardel  * signed/unsigned, name clashes  *  * Revision 4.9  1998/06/12 15:30:00  kardel  * prototype fixes  *  * Revision 4.8  1998/06/12 11:19:42  kardel  * added direct input processing routine for refclocks in  * order to avaiod that single character io gobbles up all  * receive buffers and drops input data. (Problem started  * with fast machines so a character a buffer was possible  * one of the few cases where faster machines break existing  * allocation algorithms)  *  * Revision 4.7  1998/06/06 18:35:20  kardel  * (parse_start): added BURST mode initialisation  *  * Revision 4.6  1998/05/27 06:12:46  kardel  * RAWDCF_BASEDELAY default added  * old comment removed  * casts for ioctl()  *  * Revision 4.5  1998/05/25 22:05:09  kardel  * RAWDCF_SETDTR option removed  * clock type 14 attempts to set DTR for  * power supply of RAWDCF receivers  *  * Revision 4.4  1998/05/24 16:20:47  kardel  * updated comments referencing Meinberg clocks  * added RAWDCF clock with DTR set option as type 14  *  * Revision 4.3  1998/05/24 10:48:33  kardel  * calibrated CONRAD RAWDCF default fudge factor  *  * Revision 4.2  1998/05/24 09:59:35  kardel  * corrected version information (ntpq support)  *  * Revision 4.1  1998/05/24 09:52:31  kardel  * use fixed format only (new IO model)  * output debug to stdout instead of msyslog()  * don't include>"< in ASCII output in order not to confuse  * ntpq parsing  *  * Revision 4.0  1998/04/10 19:52:11  kardel  * Start 4.0 release version numbering  *  * Revision 1.2  1998/04/10 19:28:04  kardel  * initial NTP VERSION 4 integration of PARSE with GPS166 binary support  * derived from 3.105.1.2 from V3 tree  *  * Revision information 3.1 - 3.105 from log deleted 1998/04/10 kardel  *  */
end_comment

end_unit

