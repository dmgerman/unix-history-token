begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_wwv - clock driver for NIST WWV/H time/frequency station  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_WWV
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"audio.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_IOCTL_H */
end_comment

begin_define
define|#
directive|define
name|ICOM
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_include
include|#
directive|include
file|"icom.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * Audio WWV/H demodulator/decoder  *  * This driver synchronizes the computer time using data encoded in  * radio transmissions from NIST time/frequency stations WWV in Boulder,  * CO, and WWVH in Kauai, HI. Transmissions are made continuously on  * 2.5, 5, 10, 15 and 20 MHz in AM mode. An ordinary shortwave receiver  * can be tuned manually to one of these frequencies or, in the case of  * ICOM receivers, the receiver can be tuned automatically using this  * program as propagation conditions change throughout the day and  * night.  *  * The driver receives, demodulates and decodes the radio signals when  * connected to the audio codec of a workstation running Solaris, SunOS  * FreeBSD or Linux, and with a little help, other workstations with  * similar codecs or sound cards. In this implementation, only one audio  * driver and codec can be supported on a single machine.  *  * The demodulation and decoding algorithms used in this driver are  * based on those developed for the TAPR DSP93 development board and the  * TI 320C25 digital signal processor described in: Mills, D.L. A  * precision radio clock for WWV transmissions. Electrical Engineering  * Report 97-8-1, University of Delaware, August 1997, 25 pp., available  * from www.eecis.udel.edu/~mills/reports.htm. The algorithms described  * in this report have been modified somewhat to improve performance  * under weak signal conditions and to provide an automatic station  * identification feature.  *  * The ICOM code is normally compiled in the driver. It isn't used,  * unless the mode keyword on the server configuration command specifies  * a nonzero ICOM ID select code. The C-IV trace is turned on if the  * debug level is greater than one.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE_AUDIO
value|"/dev/audio"
end_define

begin_comment
comment|/* audio device name */
end_comment

begin_define
define|#
directive|define
name|AUDIO_BUFSIZ
value|320
end_define

begin_comment
comment|/* audio buffer size (50 ms) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"WWV/H Audio Demodulator/Decoder"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|SECOND
value|8000
end_define

begin_comment
comment|/* second epoch (sample rate) (Hz) */
end_comment

begin_define
define|#
directive|define
name|MINUTE
value|(SECOND * 60)
end_define

begin_comment
comment|/* minute epoch */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|128
end_define

begin_comment
comment|/* companded sample offset */
end_comment

begin_define
define|#
directive|define
name|SIZE
value|256
end_define

begin_comment
comment|/* decompanding table size */
end_comment

begin_define
define|#
directive|define
name|MAXSIG
value|6000.
end_define

begin_comment
comment|/* max signal level reference */
end_comment

begin_define
define|#
directive|define
name|MAXCLP
value|100
end_define

begin_comment
comment|/* max clips above reference per s */
end_comment

begin_define
define|#
directive|define
name|MAXSNR
value|30.
end_define

begin_comment
comment|/* max SNR reference */
end_comment

begin_define
define|#
directive|define
name|DGAIN
value|20.
end_define

begin_comment
comment|/* data channel gain reference */
end_comment

begin_define
define|#
directive|define
name|SGAIN
value|10.
end_define

begin_comment
comment|/* sync channel gain reference */
end_comment

begin_define
define|#
directive|define
name|MAXFREQ
value|1.
end_define

begin_comment
comment|/* max frequency tolerance (125 PPM) */
end_comment

begin_define
define|#
directive|define
name|PI
value|3.1415926535
end_define

begin_comment
comment|/* the real thing */
end_comment

begin_define
define|#
directive|define
name|DATSIZ
value|(170 * MS)
end_define

begin_comment
comment|/* data matched filter size */
end_comment

begin_define
define|#
directive|define
name|SYNSIZ
value|(800 * MS)
end_define

begin_comment
comment|/* minute sync matched filter size */
end_comment

begin_define
define|#
directive|define
name|MAXERR
value|30
end_define

begin_comment
comment|/* max data bit errors in minute */
end_comment

begin_define
define|#
directive|define
name|NCHAN
value|5
end_define

begin_comment
comment|/* number of radio channels */
end_comment

begin_define
define|#
directive|define
name|AUDIO_PHI
value|5e-6
end_define

begin_comment
comment|/* dispersion growth factor */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IRIG_SUCKS
end_ifdef

begin_define
define|#
directive|define
name|WIGGLE
value|11
end_define

begin_comment
comment|/* wiggle filter length */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IRIG_SUCKS */
end_comment

begin_comment
comment|/*  * General purpose status bits (status)  *  * SELV and/or SELH are set when WWV or WWVH has been heard and cleared  * on signal loss. SSYNC is set when the second sync pulse has been  * acquired and cleared by signal loss. MSYNC is set when the minute  * sync pulse has been acquired. DSYNC is set when a digit reaches the  * threshold and INSYNC is set when all nine digits have reached the  * threshold. The MSYNC, DSYNC and INSYNC bits are cleared only by  * timeout, upon which the driver starts over from scratch.  *  * DGATE is set if a data bit is invalid and BGATE is set if a BCD digit  * bit is invalid. SFLAG is set when during seconds 59, 0 and 1 while  * probing alternate frequencies. LEPDAY is set when SECWAR of the  * timecode is set on 30 June or 31 December. LEPSEC is set during the  * last minute of the day when LEPDAY is set. At the end of this minute  * the driver inserts second 60 in the seconds state machine and the  * minute sync slips a second. The SLOSS and SJITR bits are for monitor  * only.  */
end_comment

begin_define
define|#
directive|define
name|MSYNC
value|0x0001
end_define

begin_comment
comment|/* minute epoch sync */
end_comment

begin_define
define|#
directive|define
name|SSYNC
value|0x0002
end_define

begin_comment
comment|/* second epoch sync */
end_comment

begin_define
define|#
directive|define
name|DSYNC
value|0x0004
end_define

begin_comment
comment|/* minute units sync */
end_comment

begin_define
define|#
directive|define
name|INSYNC
value|0x0008
end_define

begin_comment
comment|/* clock synchronized */
end_comment

begin_define
define|#
directive|define
name|FGATE
value|0x0010
end_define

begin_comment
comment|/* frequency gate */
end_comment

begin_define
define|#
directive|define
name|DGATE
value|0x0020
end_define

begin_comment
comment|/* data bit error */
end_comment

begin_define
define|#
directive|define
name|BGATE
value|0x0040
end_define

begin_comment
comment|/* BCD digit bit error */
end_comment

begin_define
define|#
directive|define
name|SFLAG
value|0x1000
end_define

begin_comment
comment|/* probe flag */
end_comment

begin_define
define|#
directive|define
name|LEPDAY
value|0x2000
end_define

begin_comment
comment|/* leap second day */
end_comment

begin_define
define|#
directive|define
name|LEPSEC
value|0x4000
end_define

begin_comment
comment|/* leap second minute */
end_comment

begin_comment
comment|/*  * Station scoreboard bits  *  * These are used to establish the signal quality for each of the five  * frequencies and two stations.  */
end_comment

begin_define
define|#
directive|define
name|SYNCNG
value|0x0001
end_define

begin_comment
comment|/* sync or SNR below threshold */
end_comment

begin_define
define|#
directive|define
name|DATANG
value|0x0002
end_define

begin_comment
comment|/* data or SNR below threshold */
end_comment

begin_define
define|#
directive|define
name|ERRRNG
value|0x0004
end_define

begin_comment
comment|/* data error */
end_comment

begin_define
define|#
directive|define
name|SELV
value|0x0100
end_define

begin_comment
comment|/* WWV station select */
end_comment

begin_define
define|#
directive|define
name|SELH
value|0x0200
end_define

begin_comment
comment|/* WWVH station select */
end_comment

begin_comment
comment|/*  * Alarm status bits (alarm)  *  * These bits indicate various alarm conditions, which are decoded to  * form the quality character included in the timecode. If not tracking  * second sync, the SYNERR alarm is raised. The data error counter is  * incremented for each invalid data bit. If too many data bit errors  * are encountered in one minute, the MODERR alarm is raised. The DECERR  * alarm is raised if a maximum likelihood digit fails to compare with  * the current clock digit. If the probability of any miscellaneous bit  * or any digit falls below the threshold, the SYMERR alarm is raised.  */
end_comment

begin_define
define|#
directive|define
name|DECERR
value|1
end_define

begin_comment
comment|/* BCD digit compare error */
end_comment

begin_define
define|#
directive|define
name|SYMERR
value|2
end_define

begin_comment
comment|/* low bit or digit probability */
end_comment

begin_define
define|#
directive|define
name|MODERR
value|4
end_define

begin_comment
comment|/* too many data bit errors */
end_comment

begin_define
define|#
directive|define
name|SYNERR
value|8
end_define

begin_comment
comment|/* not synchronized to station */
end_comment

begin_comment
comment|/*  * Watchcat timeouts (watch)  *  * If these timeouts expire, the status bits are mashed to zero and the  * driver starts from scratch. Suitably more refined procedures may be  * developed in future. All these are in minutes.  */
end_comment

begin_define
define|#
directive|define
name|ACQSN
value|5
end_define

begin_comment
comment|/* station acquisition timeout */
end_comment

begin_define
define|#
directive|define
name|DIGIT
value|30
end_define

begin_comment
comment|/* minute unit digit timeout */
end_comment

begin_define
define|#
directive|define
name|HOLD
value|30
end_define

begin_comment
comment|/* reachable timeout */
end_comment

begin_define
define|#
directive|define
name|PANIC
value|(2 * 1440)
end_define

begin_comment
comment|/* panic timeout */
end_comment

begin_comment
comment|/*  * Thresholds. These establish the minimum signal level, minimum SNR and  * maximum jitter thresholds which establish the error and false alarm  * rates of the driver. The values defined here may be on the  * adventurous side in the interest of the highest sensitivity.  */
end_comment

begin_define
define|#
directive|define
name|MTHR
value|13.
end_define

begin_comment
comment|/* acquisition signal gate (percent) */
end_comment

begin_define
define|#
directive|define
name|TTHR
value|50.
end_define

begin_comment
comment|/* tracking signal gate (percent) */
end_comment

begin_define
define|#
directive|define
name|ATHR
value|2000.
end_define

begin_comment
comment|/* acquisition amplitude threshold */
end_comment

begin_define
define|#
directive|define
name|ASNR
value|6.
end_define

begin_comment
comment|/* acquisition SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|AWND
value|20.
end_define

begin_comment
comment|/* acquisition jitter threshold (ms) */
end_comment

begin_define
define|#
directive|define
name|AMIN
value|3
end_define

begin_comment
comment|/* min bit count */
end_comment

begin_define
define|#
directive|define
name|AMAX
value|6
end_define

begin_comment
comment|/* max bit count */
end_comment

begin_define
define|#
directive|define
name|QTHR
value|2000
end_define

begin_comment
comment|/* QSY sync threshold */
end_comment

begin_define
define|#
directive|define
name|QSNR
value|20.
end_define

begin_comment
comment|/* QSY sync SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|XTHR
value|1000.
end_define

begin_comment
comment|/* QSY data threshold */
end_comment

begin_define
define|#
directive|define
name|XSNR
value|10.
end_define

begin_comment
comment|/* QSY data SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|STHR
value|500
end_define

begin_comment
comment|/* second sync amplitude threshold */
end_comment

begin_define
define|#
directive|define
name|SSNR
value|10.
end_define

begin_comment
comment|/* second sync SNR threshold */
end_comment

begin_define
define|#
directive|define
name|SCMP
value|10
end_define

begin_comment
comment|/* second sync compare threshold */
end_comment

begin_define
define|#
directive|define
name|DTHR
value|1000
end_define

begin_comment
comment|/* bit amplitude threshold */
end_comment

begin_define
define|#
directive|define
name|DSNR
value|10.
end_define

begin_comment
comment|/* bit SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|BTHR
value|1000
end_define

begin_comment
comment|/* digit amplitude threshold */
end_comment

begin_define
define|#
directive|define
name|BSNR
value|3.
end_define

begin_comment
comment|/* digit likelihood threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|BCMP
value|5
end_define

begin_comment
comment|/* digit compare threshold */
end_comment

begin_comment
comment|/*  * Tone frequency definitions. The increments are for 4.5-deg sine  * table.  */
end_comment

begin_define
define|#
directive|define
name|MS
value|(SECOND / 1000)
end_define

begin_comment
comment|/* samples per millisecond */
end_comment

begin_define
define|#
directive|define
name|IN100
value|((100 * 80) / SECOND)
end_define

begin_comment
comment|/* 100 Hz increment */
end_comment

begin_define
define|#
directive|define
name|IN1000
value|((1000 * 80) / SECOND)
end_define

begin_comment
comment|/* 1000 Hz increment */
end_comment

begin_define
define|#
directive|define
name|IN1200
value|((1200 * 80) / SECOND)
end_define

begin_comment
comment|/* 1200 Hz increment */
end_comment

begin_comment
comment|/*  * Acquisition and tracking time constants. Usually powers of 2.  */
end_comment

begin_define
define|#
directive|define
name|MINAVG
value|8
end_define

begin_comment
comment|/* min time constant */
end_comment

begin_define
define|#
directive|define
name|MAXAVG
value|1024
end_define

begin_comment
comment|/* max time constant */
end_comment

begin_define
define|#
directive|define
name|TCONST
value|16
end_define

begin_comment
comment|/* data bit/digit time constant */
end_comment

begin_comment
comment|/*  * Miscellaneous status bits (misc)  *  * These bits correspond to designated bits in the WWV/H timecode. The  * bit probabilities are exponentially averaged over several minutes and  * processed by a integrator and threshold.  */
end_comment

begin_define
define|#
directive|define
name|DUT1
value|0x01
end_define

begin_comment
comment|/* 56 DUT .1 */
end_comment

begin_define
define|#
directive|define
name|DUT2
value|0x02
end_define

begin_comment
comment|/* 57 DUT .2 */
end_comment

begin_define
define|#
directive|define
name|DUT4
value|0x04
end_define

begin_comment
comment|/* 58 DUT .4 */
end_comment

begin_define
define|#
directive|define
name|DUTS
value|0x08
end_define

begin_comment
comment|/* 50 DUT sign */
end_comment

begin_define
define|#
directive|define
name|DST1
value|0x10
end_define

begin_comment
comment|/* 55 DST1 leap warning */
end_comment

begin_define
define|#
directive|define
name|DST2
value|0x20
end_define

begin_comment
comment|/* 2 DST2 DST1 delayed one day */
end_comment

begin_define
define|#
directive|define
name|SECWAR
value|0x40
end_define

begin_comment
comment|/* 3 leap second warning */
end_comment

begin_comment
comment|/*  * The on-time synchronization point for the driver is the second epoch  * sync pulse produced by the FIR matched filters. As the 5-ms delay of  * these filters is compensated, the program delay is 1.1 ms due to the  * 600-Hz IIR bandpass filter. The measured receiver delay is 4.7 ms and  * the codec delay less than 0.2 ms. The additional propagation delay  * specific to each receiver location can be programmed in the fudge  * time1 and time2 values for WWV and WWVH, respectively.  */
end_comment

begin_define
define|#
directive|define
name|PDELAY
value|(.0011 + .0047 + .0002)
end_define

begin_comment
comment|/* net system delay (s) */
end_comment

begin_comment
comment|/*  * Table of sine values at 4.5-degree increments. This is used by the  * synchronous matched filter demodulators. The integral of sine-squared  * over one complete cycle is PI, so the table is normallized by 1 / PI.  */
end_comment

begin_decl_stmt
name|double
name|sintab
index|[]
init|=
block|{
literal|0.000000e+00
block|,
literal|2.497431e-02
block|,
literal|4.979464e-02
block|,
literal|7.430797e-02
block|,
comment|/* 0-3 */
literal|9.836316e-02
block|,
literal|1.218119e-01
block|,
literal|1.445097e-01
block|,
literal|1.663165e-01
block|,
comment|/* 4-7 */
literal|1.870979e-01
block|,
literal|2.067257e-01
block|,
literal|2.250791e-01
block|,
literal|2.420447e-01
block|,
comment|/* 8-11 */
literal|2.575181e-01
block|,
literal|2.714038e-01
block|,
literal|2.836162e-01
block|,
literal|2.940800e-01
block|,
comment|/* 12-15 */
literal|3.027307e-01
block|,
literal|3.095150e-01
block|,
literal|3.143910e-01
block|,
literal|3.173286e-01
block|,
comment|/* 16-19 */
literal|3.183099e-01
block|,
literal|3.173286e-01
block|,
literal|3.143910e-01
block|,
literal|3.095150e-01
block|,
comment|/* 20-23 */
literal|3.027307e-01
block|,
literal|2.940800e-01
block|,
literal|2.836162e-01
block|,
literal|2.714038e-01
block|,
comment|/* 24-27 */
literal|2.575181e-01
block|,
literal|2.420447e-01
block|,
literal|2.250791e-01
block|,
literal|2.067257e-01
block|,
comment|/* 28-31 */
literal|1.870979e-01
block|,
literal|1.663165e-01
block|,
literal|1.445097e-01
block|,
literal|1.218119e-01
block|,
comment|/* 32-35 */
literal|9.836316e-02
block|,
literal|7.430797e-02
block|,
literal|4.979464e-02
block|,
literal|2.497431e-02
block|,
comment|/* 36-39 */
operator|-
literal|0.000000e+00
block|,
operator|-
literal|2.497431e-02
block|,
operator|-
literal|4.979464e-02
block|,
operator|-
literal|7.430797e-02
block|,
comment|/* 40-43 */
operator|-
literal|9.836316e-02
block|,
operator|-
literal|1.218119e-01
block|,
operator|-
literal|1.445097e-01
block|,
operator|-
literal|1.663165e-01
block|,
comment|/* 44-47 */
operator|-
literal|1.870979e-01
block|,
operator|-
literal|2.067257e-01
block|,
operator|-
literal|2.250791e-01
block|,
operator|-
literal|2.420447e-01
block|,
comment|/* 48-51 */
operator|-
literal|2.575181e-01
block|,
operator|-
literal|2.714038e-01
block|,
operator|-
literal|2.836162e-01
block|,
operator|-
literal|2.940800e-01
block|,
comment|/* 52-55 */
operator|-
literal|3.027307e-01
block|,
operator|-
literal|3.095150e-01
block|,
operator|-
literal|3.143910e-01
block|,
operator|-
literal|3.173286e-01
block|,
comment|/* 56-59 */
operator|-
literal|3.183099e-01
block|,
operator|-
literal|3.173286e-01
block|,
operator|-
literal|3.143910e-01
block|,
operator|-
literal|3.095150e-01
block|,
comment|/* 60-63 */
operator|-
literal|3.027307e-01
block|,
operator|-
literal|2.940800e-01
block|,
operator|-
literal|2.836162e-01
block|,
operator|-
literal|2.714038e-01
block|,
comment|/* 64-67 */
operator|-
literal|2.575181e-01
block|,
operator|-
literal|2.420447e-01
block|,
operator|-
literal|2.250791e-01
block|,
operator|-
literal|2.067257e-01
block|,
comment|/* 68-71 */
operator|-
literal|1.870979e-01
block|,
operator|-
literal|1.663165e-01
block|,
operator|-
literal|1.445097e-01
block|,
operator|-
literal|1.218119e-01
block|,
comment|/* 72-75 */
operator|-
literal|9.836316e-02
block|,
operator|-
literal|7.430797e-02
block|,
operator|-
literal|4.979464e-02
block|,
operator|-
literal|2.497431e-02
block|,
comment|/* 76-79 */
literal|0.000000e+00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 80 */
end_comment

begin_comment
comment|/*  * Decoder operations at the end of each second are driven by a state  * machine. The transition matrix consists of a dispatch table indexed  * by second number. Each entry in the table contains a case switch  * number and argument.  */
end_comment

begin_struct
struct|struct
name|progx
block|{
name|int
name|sw
decl_stmt|;
comment|/* case switch number */
name|int
name|arg
decl_stmt|;
comment|/* argument */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Case switch numbers  */
end_comment

begin_define
define|#
directive|define
name|IDLE
value|0
end_define

begin_comment
comment|/* no operation */
end_comment

begin_define
define|#
directive|define
name|COEF
value|1
end_define

begin_comment
comment|/* BCD bit */
end_comment

begin_define
define|#
directive|define
name|COEF2
value|2
end_define

begin_comment
comment|/* BCD bit ignored */
end_comment

begin_define
define|#
directive|define
name|DECIM9
value|3
end_define

begin_comment
comment|/* BCD digit 0-9 */
end_comment

begin_define
define|#
directive|define
name|DECIM6
value|4
end_define

begin_comment
comment|/* BCD digit 0-6 */
end_comment

begin_define
define|#
directive|define
name|DECIM3
value|5
end_define

begin_comment
comment|/* BCD digit 0-3 */
end_comment

begin_define
define|#
directive|define
name|DECIM2
value|6
end_define

begin_comment
comment|/* BCD digit 0-2 */
end_comment

begin_define
define|#
directive|define
name|MSCBIT
value|7
end_define

begin_comment
comment|/* miscellaneous bit */
end_comment

begin_define
define|#
directive|define
name|MSC20
value|8
end_define

begin_comment
comment|/* miscellaneous bit */
end_comment

begin_define
define|#
directive|define
name|MSC21
value|9
end_define

begin_comment
comment|/* QSY probe channel */
end_comment

begin_define
define|#
directive|define
name|MIN1
value|10
end_define

begin_comment
comment|/* minute */
end_comment

begin_define
define|#
directive|define
name|MIN2
value|11
end_define

begin_comment
comment|/* leap second */
end_comment

begin_define
define|#
directive|define
name|SYNC2
value|12
end_define

begin_comment
comment|/* QSY data channel */
end_comment

begin_define
define|#
directive|define
name|SYNC3
value|13
end_define

begin_comment
comment|/* QSY data channel */
end_comment

begin_comment
comment|/*  * Offsets in decoding matrix  */
end_comment

begin_define
define|#
directive|define
name|MN
value|0
end_define

begin_comment
comment|/* minute digits (2) */
end_comment

begin_define
define|#
directive|define
name|HR
value|2
end_define

begin_comment
comment|/* hour digits (2) */
end_comment

begin_define
define|#
directive|define
name|DA
value|4
end_define

begin_comment
comment|/* day digits (3) */
end_comment

begin_define
define|#
directive|define
name|YR
value|7
end_define

begin_comment
comment|/* year digits (2) */
end_comment

begin_decl_stmt
name|struct
name|progx
name|progx
index|[]
init|=
block|{
block|{
name|SYNC2
block|,
literal|0
block|}
block|,
comment|/* 0 latch sync max */
block|{
name|SYNC3
block|,
literal|0
block|}
block|,
comment|/* 1 QSY data channel */
block|{
name|MSCBIT
block|,
name|DST2
block|}
block|,
comment|/* 2 dst2 */
block|{
name|MSCBIT
block|,
name|SECWAR
block|}
block|,
comment|/* 3 lw */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 4 1 year units */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 5 2 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 6 4 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 7 8 */
block|{
name|DECIM9
block|,
name|YR
block|}
block|,
comment|/* 8 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 9 p1 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 10 1 minute units */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 11 2 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 12 4 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 13 8 */
block|{
name|DECIM9
block|,
name|MN
block|}
block|,
comment|/* 14 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 15 10 minute tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 16 20 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 17 40 */
block|{
name|COEF2
block|,
literal|3
block|}
block|,
comment|/* 18 80 (not used) */
block|{
name|DECIM6
block|,
name|MN
operator|+
literal|1
block|}
block|,
comment|/* 19 p2 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 20 1 hour units */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 21 2 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 22 4 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 23 8 */
block|{
name|DECIM9
block|,
name|HR
block|}
block|,
comment|/* 24 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 25 10 hour tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 26 20 */
block|{
name|COEF2
block|,
literal|2
block|}
block|,
comment|/* 27 40 (not used) */
block|{
name|COEF2
block|,
literal|3
block|}
block|,
comment|/* 28 80 (not used) */
block|{
name|DECIM2
block|,
name|HR
operator|+
literal|1
block|}
block|,
comment|/* 29 p3 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 30 1 day units */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 31 2 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 32 4 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 33 8 */
block|{
name|DECIM9
block|,
name|DA
block|}
block|,
comment|/* 34 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 35 10 day tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 36 20 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 37 40 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 38 80 */
block|{
name|DECIM9
block|,
name|DA
operator|+
literal|1
block|}
block|,
comment|/* 39 p4 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 40 100 day hundreds */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 41 200 */
block|{
name|COEF2
block|,
literal|2
block|}
block|,
comment|/* 42 400 (not used) */
block|{
name|COEF2
block|,
literal|3
block|}
block|,
comment|/* 43 800 (not used) */
block|{
name|DECIM3
block|,
name|DA
operator|+
literal|2
block|}
block|,
comment|/* 44 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 45 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 46 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 47 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 48 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 49 p5 */
block|{
name|MSCBIT
block|,
name|DUTS
block|}
block|,
comment|/* 50 dut+- */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 51 10 year tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 52 20 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 53 40 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 54 80 */
block|{
name|MSC20
block|,
name|DST1
block|}
block|,
comment|/* 55 dst1 */
block|{
name|MSCBIT
block|,
name|DUT1
block|}
block|,
comment|/* 56 0.1 dut */
block|{
name|MSCBIT
block|,
name|DUT2
block|}
block|,
comment|/* 57 0.2 */
block|{
name|MSC21
block|,
name|DUT4
block|}
block|,
comment|/* 58 0.4 QSY probe channel */
block|{
name|MIN1
block|,
literal|0
block|}
block|,
comment|/* 59 p6 latch sync min */
block|{
name|MIN2
block|,
literal|0
block|}
comment|/* 60 leap second */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * BCD coefficients for maximum likelihood digit decode  */
end_comment

begin_define
define|#
directive|define
name|P15
value|1.
end_define

begin_comment
comment|/* max positive number */
end_comment

begin_define
define|#
directive|define
name|N15
value|-1.
end_define

begin_comment
comment|/* max negative number */
end_comment

begin_comment
comment|/*  * Digits 0-9  */
end_comment

begin_define
define|#
directive|define
name|P9
value|(P15 / 4)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N9
value|(N15 / 4)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd9
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N9
block|,
name|N9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 0 */
block|{
name|P9
block|,
name|N9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 1 */
block|{
name|N9
block|,
name|P9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 2 */
block|{
name|P9
block|,
name|P9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 3 */
block|{
name|N9
block|,
name|N9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 4 */
block|{
name|P9
block|,
name|N9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 5 */
block|{
name|N9
block|,
name|P9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 6 */
block|{
name|P9
block|,
name|P9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 7 */
block|{
name|N9
block|,
name|N9
block|,
name|N9
block|,
name|P9
block|}
block|,
comment|/* 8 */
block|{
name|P9
block|,
name|N9
block|,
name|N9
block|,
name|P9
block|}
block|,
comment|/* 9 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Digits 0-6 (minute tens)  */
end_comment

begin_define
define|#
directive|define
name|P6
value|(P15 / 3)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N6
value|(N15 / 3)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd6
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N6
block|,
name|N6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|P6
block|,
name|N6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
name|N6
block|,
name|P6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
name|P6
block|,
name|P6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
name|N6
block|,
name|N6
block|,
name|P6
block|,
literal|0
block|}
block|,
comment|/* 4 */
block|{
name|P6
block|,
name|N6
block|,
name|P6
block|,
literal|0
block|}
block|,
comment|/* 5 */
block|{
name|N6
block|,
name|P6
block|,
name|P6
block|,
literal|0
block|}
block|,
comment|/* 6 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Digits 0-3 (day hundreds)  */
end_comment

begin_define
define|#
directive|define
name|P3
value|(P15 / 2)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N3
value|(N15 / 2)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd3
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N3
block|,
name|N3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|P3
block|,
name|N3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
name|N3
block|,
name|P3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
name|P3
block|,
name|P3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Digits 0-2 (hour tens)  */
end_comment

begin_define
define|#
directive|define
name|P2
value|(P15 / 2)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N2
value|(N15 / 2)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd2
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N2
block|,
name|N2
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|P2
block|,
name|N2
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
name|N2
block|,
name|P2
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * DST decode (DST2 DST1) for prettyprint  */
end_comment

begin_decl_stmt
name|char
name|dstcod
index|[]
init|=
block|{
literal|'S'
block|,
comment|/* 00 standard time */
literal|'I'
block|,
comment|/* 01 set clock ahead at 0200 local */
literal|'O'
block|,
comment|/* 10 set clock back at 0200 local */
literal|'D'
comment|/* 11 daylight time */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The decoding matrix consists of nine row vectors, one for each digit  * of the timecode. The digits are stored from least to most significant  * order. The maximum likelihood timecode is formed from the digits  * corresponding to the maximum likelihood values reading in the  * opposite order: yy ddd hh:mm.  */
end_comment

begin_struct
struct|struct
name|decvec
block|{
name|int
name|radix
decl_stmt|;
comment|/* radix (3, 4, 6, 10) */
name|int
name|digit
decl_stmt|;
comment|/* current clock digit */
name|int
name|mldigit
decl_stmt|;
comment|/* maximum likelihood digit */
name|int
name|phase
decl_stmt|;
comment|/* maximum likelihood digit phase */
name|int
name|count
decl_stmt|;
comment|/* match count */
name|double
name|digprb
decl_stmt|;
comment|/* max digit probability */
name|double
name|digsnr
decl_stmt|;
comment|/* likelihood function (dB) */
name|double
name|like
index|[
literal|10
index|]
decl_stmt|;
comment|/* likelihood integrator 0-9 */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The station structure is used to acquire the minute pulse from WWV  * and/or WWVH. These stations are distinguished by the frequency used  * for the second and minute sync pulses, 1000 Hz for WWV and 1200 Hz  * for WWVH. Other than frequency, the format is the same.  */
end_comment

begin_struct
struct|struct
name|sync
block|{
name|double
name|epoch
decl_stmt|;
comment|/* accumulated epoch differences */
name|double
name|maxamp
decl_stmt|;
comment|/* sync max envelope (square) */
name|double
name|noiamp
decl_stmt|;
comment|/* sync noise envelope (square) */
name|long
name|pos
decl_stmt|;
comment|/* max amplitude position */
name|long
name|lastpos
decl_stmt|;
comment|/* last max position */
name|long
name|mepoch
decl_stmt|;
comment|/* minute synch epoch */
name|double
name|amp
decl_stmt|;
comment|/* sync amplitude (I, Q squares) */
name|double
name|synamp
decl_stmt|;
comment|/* sync max envelope at 800 ms */
name|double
name|synmax
decl_stmt|;
comment|/* sync envelope at 0 s */
name|double
name|synmin
decl_stmt|;
comment|/* sync envelope at 59, 1 s */
name|double
name|synsnr
decl_stmt|;
comment|/* sync signal SNR */
name|int
name|count
decl_stmt|;
comment|/* bit counter */
name|char
name|refid
index|[
literal|5
index|]
decl_stmt|;
comment|/* reference identifier */
name|int
name|select
decl_stmt|;
comment|/* select bits */
name|int
name|reach
decl_stmt|;
comment|/* reachability register */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The channel structure is used to mitigate between channels.  */
end_comment

begin_struct
struct|struct
name|chan
block|{
name|int
name|gain
decl_stmt|;
comment|/* audio gain */
name|double
name|sigamp
decl_stmt|;
comment|/* data max envelope (square) */
name|double
name|noiamp
decl_stmt|;
comment|/* data noise envelope (square) */
name|double
name|datsnr
decl_stmt|;
comment|/* data signal SNR */
name|struct
name|sync
name|wwv
decl_stmt|;
comment|/* wwv station */
name|struct
name|sync
name|wwvh
decl_stmt|;
comment|/* wwvh station */
block|}
struct|;
end_struct

begin_comment
comment|/*  * WWV unit control structure  */
end_comment

begin_struct
struct|struct
name|wwvunit
block|{
name|l_fp
name|timestamp
decl_stmt|;
comment|/* audio sample timestamp */
name|l_fp
name|tick
decl_stmt|;
comment|/* audio sample increment */
name|double
name|phase
decl_stmt|,
name|freq
decl_stmt|;
comment|/* logical clock phase and frequency */
name|double
name|monitor
decl_stmt|;
comment|/* audio monitor point */
name|int
name|fd_icom
decl_stmt|;
comment|/* ICOM file descriptor */
name|int
name|errflg
decl_stmt|;
comment|/* error flags */
name|int
name|watch
decl_stmt|;
comment|/* watchcat */
comment|/* 	 * Audio codec variables 	 */
name|double
name|comp
index|[
name|SIZE
index|]
decl_stmt|;
comment|/* decompanding table */
name|int
name|port
decl_stmt|;
comment|/* codec port */
name|int
name|gain
decl_stmt|;
comment|/* codec gain */
name|int
name|mongain
decl_stmt|;
comment|/* codec monitor gain */
name|int
name|clipcnt
decl_stmt|;
comment|/* sample clipped count */
ifdef|#
directive|ifdef
name|IRIG_SUCKS
name|l_fp
name|wigwag
decl_stmt|;
comment|/* wiggle accumulator */
name|int
name|wp
decl_stmt|;
comment|/* wiggle filter pointer */
name|l_fp
name|wiggle
index|[
name|WIGGLE
index|]
decl_stmt|;
comment|/* wiggle filter */
name|l_fp
name|wigbot
index|[
name|WIGGLE
index|]
decl_stmt|;
comment|/* wiggle bottom fisher*/
endif|#
directive|endif
comment|/* IRIG_SUCKS */
comment|/* 	 * Variables used to establish basic system timing 	 */
name|int
name|avgint
decl_stmt|;
comment|/* master time constant */
name|int
name|tepoch
decl_stmt|;
comment|/* sync epoch median */
name|int
name|yepoch
decl_stmt|;
comment|/* sync epoch */
name|int
name|repoch
decl_stmt|;
comment|/* buffered sync epoch */
name|double
name|epomax
decl_stmt|;
comment|/* second sync amplitude */
name|double
name|eposnr
decl_stmt|;
comment|/* second sync SNR */
name|double
name|irig
decl_stmt|;
comment|/* data I channel amplitude */
name|double
name|qrig
decl_stmt|;
comment|/* data Q channel amplitude */
name|int
name|datapt
decl_stmt|;
comment|/* 100 Hz ramp */
name|double
name|datpha
decl_stmt|;
comment|/* 100 Hz VFO control */
name|int
name|rphase
decl_stmt|;
comment|/* second sample counter */
name|long
name|mphase
decl_stmt|;
comment|/* minute sample counter */
comment|/* 	 * Variables used to mitigate which channel to use 	 */
name|struct
name|chan
name|mitig
index|[
name|NCHAN
index|]
decl_stmt|;
comment|/* channel data */
name|struct
name|sync
modifier|*
name|sptr
decl_stmt|;
comment|/* station pointer */
name|int
name|dchan
decl_stmt|;
comment|/* data channel */
name|int
name|schan
decl_stmt|;
comment|/* probe channel */
name|int
name|achan
decl_stmt|;
comment|/* active channel */
comment|/* 	 * Variables used by the clock state machine 	 */
name|struct
name|decvec
name|decvec
index|[
literal|9
index|]
decl_stmt|;
comment|/* decoding matrix */
name|int
name|rsec
decl_stmt|;
comment|/* seconds counter */
name|int
name|digcnt
decl_stmt|;
comment|/* count of digits synchronized */
comment|/* 	 * Variables used to estimate signal levels and bit/digit 	 * probabilities 	 */
name|double
name|sigsig
decl_stmt|;
comment|/* data max signal */
name|double
name|sigamp
decl_stmt|;
comment|/* data max envelope (square) */
name|double
name|noiamp
decl_stmt|;
comment|/* data noise envelope (square) */
name|double
name|datsnr
decl_stmt|;
comment|/* data SNR (dB) */
comment|/* 	 * Variables used to establish status and alarm conditions 	 */
name|int
name|status
decl_stmt|;
comment|/* status bits */
name|int
name|alarm
decl_stmt|;
comment|/* alarm flashers */
name|int
name|misc
decl_stmt|;
comment|/* miscellaneous timecode bits */
name|int
name|errcnt
decl_stmt|;
comment|/* data bit error counter */
name|int
name|errbit
decl_stmt|;
comment|/* data bit errors in minute */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wwv_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * More function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|wwv_epoch
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_rf
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_endpoc
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_rsec
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_qrz
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
expr|struct
name|sync
operator|*
operator|,
name|double
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_corr4
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
expr|struct
name|decvec
operator|*
operator|,
name|double
index|[]
operator|,
name|double
index|[]
index|[
literal|4
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_gain
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_tsec
name|P
argument_list|(
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|wwv_data
name|P
argument_list|(
operator|(
expr|struct
name|wwvunit
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timecode
name|P
argument_list|(
operator|(
expr|struct
name|wwvunit
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|wwv_snr
name|P
argument_list|(
operator|(
name|double
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|carry
name|P
argument_list|(
operator|(
expr|struct
name|decvec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_newchan
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_newgame
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|wwv_metric
name|P
argument_list|(
operator|(
expr|struct
name|sync
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|wwv_qsy
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_decl_stmt
specifier|static
name|double
name|qsy
index|[
name|NCHAN
index|]
init|=
block|{
literal|2.5
block|,
literal|5
block|,
literal|10
block|,
literal|15
block|,
literal|20
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequencies (MHz) */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_wwv
init|=
block|{
name|wwv_start
block|,
comment|/* start up driver */
name|wwv_shutdown
block|,
comment|/* shut down driver */
name|wwv_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old wwv_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old wwv_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * wwv_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|wwv_start
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (used by PCM) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
ifdef|#
directive|ifdef
name|ICOM
name|int
name|temp
decl_stmt|;
endif|#
directive|endif
comment|/* ICOM */
comment|/* 	 * Local variables 	 */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|i
decl_stmt|;
comment|/* index */
name|double
name|step
decl_stmt|;
comment|/* codec adjustment */
comment|/* 	 * Open audio device 	 */
name|fd
operator|=
name|audio_init
argument_list|(
name|DEVICE_AUDIO
argument_list|,
name|AUDIO_BUFSIZ
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|audio_show
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wwvunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wwvunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|wwv_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
comment|/* 	 * The companded samples are encoded sign-magnitude. The table 	 * contains all the 256 values in the interest of speed. 	 */
name|up
operator|->
name|comp
index|[
literal|0
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|OFFSET
index|]
operator|=
literal|0.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|1
index|]
operator|=
operator|-
literal|1.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|2
index|]
operator|=
operator|-
literal|3.
expr_stmt|;
name|step
operator|=
literal|2.
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|OFFSET
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|comp
index|[
name|i
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|step
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
name|i
index|]
operator|=
operator|-
name|up
operator|->
name|comp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
name|step
operator|*=
literal|2.
expr_stmt|;
block|}
name|DTOLFP
argument_list|(
literal|1.
operator|/
name|SECOND
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the decoding matrix with the radix for each digit 	 * position. 	 */
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* minutes */
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|6
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* hours */
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|3
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* days */
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|radix
operator|=
literal|4
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* years */
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
name|wwv_newgame
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|schan
operator|=
name|up
operator|->
name|achan
operator|=
literal|3
expr_stmt|;
comment|/* 	 * Initialize autotune if available. Start out at 15 MHz. Note 	 * that the ICOM select code must be less than 128, so the high 	 * order bit can be used to select the line speed. 	 */
ifdef|#
directive|ifdef
name|ICOM
name|temp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|temp
operator|=
name|P_TRACE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|ttl
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|ttl
operator|&
literal|0x80
condition|)
name|up
operator|->
name|fd_icom
operator|=
name|icom_init
argument_list|(
literal|"/dev/icom"
argument_list|,
name|B1200
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|fd_icom
operator|=
name|icom_init
argument_list|(
literal|"/dev/icom"
argument_list|,
name|B9600
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|temp
operator|=
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|schan
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_SYNCEVENT | NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"icom: radio not found"
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator|=
name|CEVNT_FAULT
expr_stmt|;
name|close
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|)
expr_stmt|;
name|up
operator|->
name|fd_icom
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|NLOG
argument_list|(
argument|NLOG_SYNCEVENT | NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"icom: autotune enabled"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ICOM */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|wwv_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
name|close
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_receive - receive data from the audio device  *  * This routine reads input samples and adjusts the logical clock to  * track the A/D sample clock by dropping or duplicating codec samples.  * It also controls the A/D signal level with an AGC loop to mimimize  * quantization noise and avoid overload.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|sample
decl_stmt|;
comment|/* codec sample */
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* buffer pointer */
name|int
name|bufcnt
decl_stmt|;
comment|/* buffer counter */
name|l_fp
name|ltemp
decl_stmt|;
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Main loop - read until there ain't no more. Note codec 	 * samples are bit-inverted. 	 */
name|DTOLFP
argument_list|(
operator|(
name|double
operator|)
name|rbufp
operator|->
name|recv_length
operator|/
name|SECOND
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|up
operator|->
name|timestamp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|dpt
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
for|for
control|(
name|bufcnt
operator|=
literal|0
init|;
name|bufcnt
operator|<
name|rbufp
operator|->
name|recv_length
condition|;
name|bufcnt
operator|++
control|)
block|{
name|sample
operator|=
name|up
operator|->
name|comp
index|[
operator|~
operator|*
name|dpt
operator|++
operator|&
literal|0xff
index|]
expr_stmt|;
comment|/* 		 * Clip noise spikes greater than MAXSIG. If no clips, 		 * increase the gain a tad; if the clips are too high,  		 * decrease a tad. 		 */
if|if
condition|(
name|sample
operator|>
name|MAXSIG
condition|)
block|{
name|sample
operator|=
name|MAXSIG
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sample
operator|<
operator|-
name|MAXSIG
condition|)
block|{
name|sample
operator|=
operator|-
name|MAXSIG
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
comment|/* 		 * Variable frequency oscillator. The codec oscillator 		 * runs at the nominal rate of 8000 samples per second, 		 * or 125 us per sample. A frequency change of one unit 		 * results in either duplicating or deleting one sample 		 * per second, which results in a frequency change of 		 * 125 PPM. 		 */
name|up
operator|->
name|phase
operator|+=
name|up
operator|->
name|freq
operator|/
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|phase
operator|>=
literal|.5
condition|)
block|{
name|up
operator|->
name|phase
operator|-=
literal|1.
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|phase
operator|<
operator|-
literal|.5
condition|)
block|{
name|up
operator|->
name|phase
operator|+=
literal|1.
expr_stmt|;
name|wwv_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
name|wwv_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wwv_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
name|L_ADD
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the input port and monitor gain for the next buffer. 	 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
name|up
operator|->
name|port
operator|=
literal|2
expr_stmt|;
else|else
name|up
operator|->
name|port
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
condition|)
name|up
operator|->
name|mongain
operator|=
name|MONGAIN
expr_stmt|;
else|else
name|up
operator|->
name|mongain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_poll - called by the transmit procedure  *  * This routine keeps track of status. If no offset samples have been  * processed during a poll interval, a timeout event is declared. If  * errors have have occurred during the interval, they are reported as  * well. Once the clock is set, it always appears reachable, unless  * reset by watchdog timeout.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_poll
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
name|up
operator|->
name|errflg
operator|=
name|CEVNT_TIMEOUT
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errflg
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|errflg
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_rf - process signals and demodulate to baseband  *  * This routine grooms and filters decompanded raw audio samples. The  * output signals include the 100-Hz baseband data signal in quadrature  * form, plus the epoch index of the second sync signal and the second  * index of the minute sync signal.  *  * There are two 1-s ramps used by this program. Both count the 8000  * logical clock samples spanning exactly one second. The epoch ramp  * counts the samples starting at an arbitrary time. The rphase ramp  * counts the samples starting at the 5-ms second sync pulse found  * during the epoch ramp.  *  * There are two 1-m ramps used by this program. The mphase ramp counts  * the 480,000 logical clock samples spanning exactly one minute and  * starting at an arbitrary time. The rsec ramp counts the 60 seconds of  * the minute starting at the 800-ms minute sync pulse found during the  * mphase ramp. The rsec ramp drives the seconds state machine to  * determine the bits and digits of the timecode.   *  * Demodulation operations are based on three synthesized quadrature  * sinusoids: 100 Hz for the data signal, 1000 Hz for the WWV sync  * signal and 1200 Hz for the WWVH sync signal. These drive synchronous  * matched filters for the data signal (170 ms at 100 Hz), WWV minute  * sync signal (800 ms at 1000 Hz) and WWVH minute sync signal (800 ms  * at 1200 Hz). Two additional matched filters are switched in  * as required for the WWV second sync signal (5 ms at 1000 Hz) and  * WWVH second sync signal (5 ms at 1200 Hz).  */
end_comment

begin_function
specifier|static
name|void
name|wwv_rf
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peerstructure pointer */
name|double
name|isig
comment|/* input signal */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|sync
modifier|*
name|sp
decl_stmt|;
specifier|static
name|double
name|lpf
index|[
literal|5
index|]
decl_stmt|;
comment|/* 150-Hz lpf delay line */
name|double
name|data
decl_stmt|;
comment|/* lpf output */
specifier|static
name|double
name|bpf
index|[
literal|9
index|]
decl_stmt|;
comment|/* 1000/1200-Hz bpf delay line */
name|double
name|syncx
decl_stmt|;
comment|/* bpf output */
specifier|static
name|double
name|mf
index|[
literal|41
index|]
decl_stmt|;
comment|/* 1000/1200-Hz mf delay line */
name|double
name|mfsync
decl_stmt|;
comment|/* mf output */
specifier|static
name|int
name|iptr
decl_stmt|;
comment|/* data channel pointer */
specifier|static
name|double
name|ibuf
index|[
name|DATSIZ
index|]
decl_stmt|;
comment|/* data I channel delay line */
specifier|static
name|double
name|qbuf
index|[
name|DATSIZ
index|]
decl_stmt|;
comment|/* data Q channel delay line */
specifier|static
name|int
name|jptr
decl_stmt|;
comment|/* sync channel pointer */
specifier|static
name|double
name|cibuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwv I channel delay line */
specifier|static
name|double
name|cqbuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwv Q channel delay line */
specifier|static
name|double
name|ciamp
decl_stmt|;
comment|/* wwv I channel amplitude */
specifier|static
name|double
name|cqamp
decl_stmt|;
comment|/* wwv Q channel amplitude */
specifier|static
name|int
name|csinptr
decl_stmt|;
comment|/* wwv channel phase */
specifier|static
name|double
name|hibuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwvh I channel delay line */
specifier|static
name|double
name|hqbuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwvh Q channel delay line */
specifier|static
name|double
name|hiamp
decl_stmt|;
comment|/* wwvh I channel amplitude */
specifier|static
name|double
name|hqamp
decl_stmt|;
comment|/* wwvh Q channel amplitude */
specifier|static
name|int
name|hsinptr
decl_stmt|;
comment|/* wwvh channels phase */
specifier|static
name|double
name|epobuf
index|[
name|SECOND
index|]
decl_stmt|;
comment|/* epoch sync comb filter */
specifier|static
name|double
name|epomax
decl_stmt|;
comment|/* epoch sync amplitude buffer */
specifier|static
name|int
name|epopos
decl_stmt|;
comment|/* epoch sync position buffer */
specifier|static
name|int
name|iniflg
decl_stmt|;
comment|/* initialization flag */
name|int
name|epoch
decl_stmt|;
comment|/* comb filter index */
name|int
name|pdelay
decl_stmt|;
comment|/* propagation delay (samples) */
name|double
name|dtemp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
name|iniflg
condition|)
block|{
name|iniflg
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lpf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lpf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bpf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bpf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cqbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cqbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hqbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hqbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|epobuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|epobuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Baseband data demodulation. The 100-Hz subcarrier is 	 * extracted using a 150-Hz IIR lowpass filter. This attenuates 	 * the 1000/1200-Hz sync signals, as well as the 440-Hz and 	 * 600-Hz tones and most of the noise and voice modulation 	 * components. 	 * 	 * Matlab IIR 4th-order IIR elliptic, 150 Hz lowpass, 0.2 dB 	 * passband ripple, -50 dB stopband ripple. 	 */
name|data
operator|=
operator|(
name|lpf
index|[
literal|4
index|]
operator|=
name|lpf
index|[
literal|3
index|]
operator|)
operator|*
literal|8.360961e-01
expr_stmt|;
name|data
operator|+=
operator|(
name|lpf
index|[
literal|3
index|]
operator|=
name|lpf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|3.481740e+00
expr_stmt|;
name|data
operator|+=
operator|(
name|lpf
index|[
literal|2
index|]
operator|=
name|lpf
index|[
literal|1
index|]
operator|)
operator|*
literal|5.452988e+00
expr_stmt|;
name|data
operator|+=
operator|(
name|lpf
index|[
literal|1
index|]
operator|=
name|lpf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|3.807229e+00
expr_stmt|;
name|lpf
index|[
literal|0
index|]
operator|=
name|isig
operator|-
name|data
expr_stmt|;
name|data
operator|=
name|lpf
index|[
literal|0
index|]
operator|*
literal|3.281435e-03
operator|+
name|lpf
index|[
literal|1
index|]
operator|*
operator|-
literal|1.149947e-02
operator|+
name|lpf
index|[
literal|2
index|]
operator|*
literal|1.654858e-02
operator|+
name|lpf
index|[
literal|3
index|]
operator|*
operator|-
literal|1.149947e-02
operator|+
name|lpf
index|[
literal|4
index|]
operator|*
literal|3.281435e-03
expr_stmt|;
comment|/* 	 * The I and Q quadrature data signals are produced by 	 * multiplying the filtered signal by 100-Hz sine and cosine 	 * signals, respectively. The data signals are demodulated by 	 * 170-ms synchronous matched filters to produce the amplitude 	 * and phase signals used by the decoder. 	 */
name|i
operator|=
name|up
operator|->
name|datapt
expr_stmt|;
name|up
operator|->
name|datapt
operator|=
operator|(
name|up
operator|->
name|datapt
operator|+
name|IN100
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|data
operator|/
name|DATSIZ
operator|*
name|DGAIN
expr_stmt|;
name|up
operator|->
name|irig
operator|-=
name|ibuf
index|[
name|iptr
index|]
expr_stmt|;
name|ibuf
index|[
name|iptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|up
operator|->
name|irig
operator|+=
name|dtemp
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|20
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|data
operator|/
name|DATSIZ
operator|*
name|DGAIN
expr_stmt|;
name|up
operator|->
name|qrig
operator|-=
name|qbuf
index|[
name|iptr
index|]
expr_stmt|;
name|qbuf
index|[
name|iptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|up
operator|->
name|qrig
operator|+=
name|dtemp
expr_stmt|;
name|iptr
operator|=
operator|(
name|iptr
operator|+
literal|1
operator|)
operator|%
name|DATSIZ
expr_stmt|;
comment|/* 	 * Baseband sync demodulation. The 1000/1200 sync signals are 	 * extracted using a 600-Hz IIR bandpass filter. This removes 	 * the 100-Hz data subcarrier, as well as the 440-Hz and 600-Hz 	 * tones and most of the noise and voice modulation components. 	 * 	 * Matlab 4th-order IIR elliptic, 800-1400 Hz bandpass, 0.2 dB 	 * passband ripple, -50 dB stopband ripple. 	 */
name|syncx
operator|=
operator|(
name|bpf
index|[
literal|8
index|]
operator|=
name|bpf
index|[
literal|7
index|]
operator|)
operator|*
literal|4.897278e-01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|7
index|]
operator|=
name|bpf
index|[
literal|6
index|]
operator|)
operator|*
operator|-
literal|2.765914e+00
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|6
index|]
operator|=
name|bpf
index|[
literal|5
index|]
operator|)
operator|*
literal|8.110921e+00
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|5
index|]
operator|=
name|bpf
index|[
literal|4
index|]
operator|)
operator|*
operator|-
literal|1.517732e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|4
index|]
operator|=
name|bpf
index|[
literal|3
index|]
operator|)
operator|*
literal|1.975197e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|3
index|]
operator|=
name|bpf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|1.814365e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|2
index|]
operator|=
name|bpf
index|[
literal|1
index|]
operator|)
operator|*
literal|1.159783e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|1
index|]
operator|=
name|bpf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|4.735040e+00
expr_stmt|;
name|bpf
index|[
literal|0
index|]
operator|=
name|isig
operator|-
name|syncx
expr_stmt|;
name|syncx
operator|=
name|bpf
index|[
literal|0
index|]
operator|*
literal|8.203628e-03
operator|+
name|bpf
index|[
literal|1
index|]
operator|*
operator|-
literal|2.375732e-02
operator|+
name|bpf
index|[
literal|2
index|]
operator|*
literal|3.353214e-02
operator|+
name|bpf
index|[
literal|3
index|]
operator|*
operator|-
literal|4.080258e-02
operator|+
name|bpf
index|[
literal|4
index|]
operator|*
literal|4.605479e-02
operator|+
name|bpf
index|[
literal|5
index|]
operator|*
operator|-
literal|4.080258e-02
operator|+
name|bpf
index|[
literal|6
index|]
operator|*
literal|3.353214e-02
operator|+
name|bpf
index|[
literal|7
index|]
operator|*
operator|-
literal|2.375732e-02
operator|+
name|bpf
index|[
literal|8
index|]
operator|*
literal|8.203628e-03
expr_stmt|;
comment|/* 	 * The I and Q quadrature minute sync signals are produced by 	 * multiplying the filtered signal by 1000-Hz (WWV) and 1200-Hz 	 * (WWVH) sine and cosine signals, respectively. The resulting 	 * signals are demodulated by 800-ms synchronous matched filters 	 * to synchronize the second and minute and to detect which one 	 * (or both) the WWV or WWVH signal is present. 	 * 	 * Note the master timing ramps, which run continuously. The 	 * minute counter (mphase) counts the samples in the minute, 	 * while the second counter (epoch) counts the samples in the 	 * second. 	 */
name|up
operator|->
name|mphase
operator|=
operator|(
name|up
operator|->
name|mphase
operator|+
literal|1
operator|)
operator|%
name|MINUTE
expr_stmt|;
name|epoch
operator|=
name|up
operator|->
name|mphase
operator|%
name|SECOND
expr_stmt|;
name|i
operator|=
name|csinptr
expr_stmt|;
name|csinptr
operator|=
operator|(
name|csinptr
operator|+
name|IN1000
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
name|SYNSIZ
operator|*
name|SGAIN
expr_stmt|;
name|ciamp
operator|=
name|ciamp
operator|-
name|cibuf
index|[
name|jptr
index|]
operator|+
name|dtemp
expr_stmt|;
name|cibuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|20
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
name|SYNSIZ
operator|*
name|SGAIN
expr_stmt|;
name|cqamp
operator|=
name|cqamp
operator|-
name|cqbuf
index|[
name|jptr
index|]
operator|+
name|dtemp
expr_stmt|;
name|cqbuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|sp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|schan
index|]
operator|.
name|wwv
expr_stmt|;
name|dtemp
operator|=
name|ciamp
operator|*
name|ciamp
operator|+
name|cqamp
operator|*
name|cqamp
expr_stmt|;
name|sp
operator|->
name|amp
operator|=
name|dtemp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
name|wwv_qrz
argument_list|(
name|peer
argument_list|,
name|sp
argument_list|,
name|dtemp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|fudgetime1
operator|*
name|SECOND
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|hsinptr
expr_stmt|;
name|hsinptr
operator|=
operator|(
name|hsinptr
operator|+
name|IN1200
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
name|SYNSIZ
operator|*
name|SGAIN
expr_stmt|;
name|hiamp
operator|=
name|hiamp
operator|-
name|hibuf
index|[
name|jptr
index|]
operator|+
name|dtemp
expr_stmt|;
name|hibuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|20
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
name|SYNSIZ
operator|*
name|SGAIN
expr_stmt|;
name|hqamp
operator|=
name|hqamp
operator|-
name|hqbuf
index|[
name|jptr
index|]
operator|+
name|dtemp
expr_stmt|;
name|hqbuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|sp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|schan
index|]
operator|.
name|wwvh
expr_stmt|;
name|dtemp
operator|=
name|hiamp
operator|*
name|hiamp
operator|+
name|hqamp
operator|*
name|hqamp
expr_stmt|;
name|sp
operator|->
name|amp
operator|=
name|dtemp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
name|wwv_qrz
argument_list|(
name|peer
argument_list|,
name|sp
argument_list|,
name|dtemp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|fudgetime2
operator|*
name|SECOND
argument_list|)
argument_list|)
expr_stmt|;
name|jptr
operator|=
operator|(
name|jptr
operator|+
literal|1
operator|)
operator|%
name|SYNSIZ
expr_stmt|;
comment|/* 	 * The following section is called once per minute. It does 	 * housekeeping and timeout functions and empties the dustbins. 	 */
if|if
condition|(
name|up
operator|->
name|mphase
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|watch
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
block|{
comment|/* 			 * If minute sync has not been acquired before 			 * timeout, or if no signal is heard, the 			 * program cycles to the next frequency and 			 * tries again. 			 */
name|wwv_newchan
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
operator|(
name|SELV
operator||
name|SELH
operator|)
operator|)
operator|||
name|up
operator|->
name|watch
operator|>
name|ACQSN
condition|)
block|{
name|wwv_newgame
argument_list|(
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICOM
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|schan
operator|=
operator|(
name|up
operator|->
name|schan
operator|+
literal|1
operator|)
operator|%
name|NCHAN
expr_stmt|;
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|schan
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ICOM */
block|}
block|}
else|else
block|{
comment|/* 			 * If the leap bit is set, set the minute epoch 			 * back one second so the station processes 			 * don't miss a beat. 			 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|LEPSEC
condition|)
block|{
name|up
operator|->
name|mphase
operator|-=
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|mphase
operator|<
literal|0
condition|)
name|up
operator|->
name|mphase
operator|+=
name|MINUTE
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * When the channel metric reaches threshold and the second 	 * counter matches the minute epoch within the second, the 	 * driver has synchronized to the station. The second number is 	 * the remaining seconds until the next minute epoch, while the 	 * sync epoch is zero. Watch out for the first second; if 	 * already synchronized to the second, the buffered sync epoch 	 * must be set.  	 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|MSYNC
condition|)
block|{
name|wwv_epoch
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sp
operator|=
name|up
operator|->
name|sptr
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|count
operator|>=
name|AMIN
operator|&&
name|epoch
operator|==
name|sp
operator|->
name|mepoch
operator|%
name|SECOND
condition|)
block|{
name|up
operator|->
name|rsec
operator|=
literal|60
operator|-
name|sp
operator|->
name|mepoch
operator|/
name|SECOND
expr_stmt|;
name|up
operator|->
name|rphase
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|status
operator||=
name|MSYNC
expr_stmt|;
name|up
operator|->
name|watch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SSYNC
operator|)
condition|)
name|up
operator|->
name|repoch
operator|=
name|up
operator|->
name|yepoch
operator|=
name|epoch
expr_stmt|;
else|else
name|up
operator|->
name|repoch
operator|=
name|up
operator|->
name|yepoch
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|i
index|]
expr_stmt|;
name|cp
operator|->
name|wwv
operator|.
name|count
operator|=
name|cp
operator|->
name|wwv
operator|.
name|reach
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|wwvh
operator|.
name|count
operator|=
name|cp
operator|->
name|wwvh
operator|.
name|reach
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * The second sync pulse is extracted using 5-ms (40 sample) FIR 	 * matched filters at 1000 Hz for WWV or 1200 Hz for WWVH. This 	 * pulse is used for the most precise synchronization, since if 	 * provides a resolution of one sample (125 us). The filters run 	 * only if the station has been reliably determined. 	 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|SELV
condition|)
block|{
name|pdelay
operator|=
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|fudgetime1
operator|*
name|SECOND
argument_list|)
expr_stmt|;
comment|/* 		 * WWV FIR matched filter, five cycles of 1000-Hz 		 * sinewave. 		 */
name|mf
index|[
literal|40
index|]
operator|=
name|mf
index|[
literal|39
index|]
expr_stmt|;
name|mfsync
operator|=
operator|(
name|mf
index|[
literal|39
index|]
operator|=
name|mf
index|[
literal|38
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|38
index|]
operator|=
name|mf
index|[
literal|37
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|37
index|]
operator|=
name|mf
index|[
literal|36
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|36
index|]
operator|=
name|mf
index|[
literal|35
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|35
index|]
operator|=
name|mf
index|[
literal|34
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|34
index|]
operator|=
name|mf
index|[
literal|33
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|33
index|]
operator|=
name|mf
index|[
literal|32
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|32
index|]
operator|=
name|mf
index|[
literal|31
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|31
index|]
operator|=
name|mf
index|[
literal|30
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|30
index|]
operator|=
name|mf
index|[
literal|29
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|29
index|]
operator|=
name|mf
index|[
literal|28
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|28
index|]
operator|=
name|mf
index|[
literal|27
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|27
index|]
operator|=
name|mf
index|[
literal|26
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|26
index|]
operator|=
name|mf
index|[
literal|25
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|25
index|]
operator|=
name|mf
index|[
literal|24
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|24
index|]
operator|=
name|mf
index|[
literal|23
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|23
index|]
operator|=
name|mf
index|[
literal|22
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|22
index|]
operator|=
name|mf
index|[
literal|21
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|21
index|]
operator|=
name|mf
index|[
literal|20
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|20
index|]
operator|=
name|mf
index|[
literal|19
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|19
index|]
operator|=
name|mf
index|[
literal|18
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|18
index|]
operator|=
name|mf
index|[
literal|17
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|17
index|]
operator|=
name|mf
index|[
literal|16
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|16
index|]
operator|=
name|mf
index|[
literal|15
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|15
index|]
operator|=
name|mf
index|[
literal|14
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|14
index|]
operator|=
name|mf
index|[
literal|13
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|13
index|]
operator|=
name|mf
index|[
literal|12
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|12
index|]
operator|=
name|mf
index|[
literal|11
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|11
index|]
operator|=
name|mf
index|[
literal|10
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|10
index|]
operator|=
name|mf
index|[
literal|9
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|9
index|]
operator|=
name|mf
index|[
literal|8
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|8
index|]
operator|=
name|mf
index|[
literal|7
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|7
index|]
operator|=
name|mf
index|[
literal|6
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|6
index|]
operator|=
name|mf
index|[
literal|5
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|5
index|]
operator|=
name|mf
index|[
literal|4
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|4
index|]
operator|=
name|mf
index|[
literal|3
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|3
index|]
operator|=
name|mf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|2
index|]
operator|=
name|mf
index|[
literal|1
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|1
index|]
operator|=
name|mf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|0
index|]
operator|=
name|syncx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|SELH
condition|)
block|{
name|pdelay
operator|=
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|fudgetime2
operator|*
name|SECOND
argument_list|)
expr_stmt|;
comment|/* 		 * WWVH FIR matched filter, six cycles of 1200-Hz 		 * sinewave. 		 */
name|mf
index|[
literal|40
index|]
operator|=
name|mf
index|[
literal|39
index|]
expr_stmt|;
name|mfsync
operator|=
operator|(
name|mf
index|[
literal|39
index|]
operator|=
name|mf
index|[
literal|38
index|]
operator|)
operator|*
literal|4.833363e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|38
index|]
operator|=
name|mf
index|[
literal|37
index|]
operator|)
operator|*
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|37
index|]
operator|=
name|mf
index|[
literal|36
index|]
operator|)
operator|*
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|36
index|]
operator|=
name|mf
index|[
literal|35
index|]
operator|)
operator|*
operator|-
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|35
index|]
operator|=
name|mf
index|[
literal|34
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|34
index|]
operator|=
name|mf
index|[
literal|33
index|]
operator|)
operator|*
operator|-
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|33
index|]
operator|=
name|mf
index|[
literal|32
index|]
operator|)
operator|*
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|32
index|]
operator|=
name|mf
index|[
literal|31
index|]
operator|)
operator|*
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|31
index|]
operator|=
name|mf
index|[
literal|30
index|]
operator|)
operator|*
literal|4.833363e-02
expr_stmt|;
name|mf
index|[
literal|30
index|]
operator|=
name|mf
index|[
literal|29
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|29
index|]
operator|=
name|mf
index|[
literal|28
index|]
operator|)
operator|*
operator|-
literal|4.833363e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|28
index|]
operator|=
name|mf
index|[
literal|27
index|]
operator|)
operator|*
operator|-
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|27
index|]
operator|=
name|mf
index|[
literal|26
index|]
operator|)
operator|*
operator|-
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|26
index|]
operator|=
name|mf
index|[
literal|25
index|]
operator|)
operator|*
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|25
index|]
operator|=
name|mf
index|[
literal|24
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|24
index|]
operator|=
name|mf
index|[
literal|23
index|]
operator|)
operator|*
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|23
index|]
operator|=
name|mf
index|[
literal|22
index|]
operator|)
operator|*
operator|-
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|22
index|]
operator|=
name|mf
index|[
literal|21
index|]
operator|)
operator|*
operator|-
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|21
index|]
operator|=
name|mf
index|[
literal|20
index|]
operator|)
operator|*
operator|-
literal|4.833363e-02
expr_stmt|;
name|mf
index|[
literal|20
index|]
operator|=
name|mf
index|[
literal|19
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|19
index|]
operator|=
name|mf
index|[
literal|18
index|]
operator|)
operator|*
literal|4.833363e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|18
index|]
operator|=
name|mf
index|[
literal|17
index|]
operator|)
operator|*
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|17
index|]
operator|=
name|mf
index|[
literal|16
index|]
operator|)
operator|*
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|16
index|]
operator|=
name|mf
index|[
literal|15
index|]
operator|)
operator|*
operator|-
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|15
index|]
operator|=
name|mf
index|[
literal|14
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|14
index|]
operator|=
name|mf
index|[
literal|13
index|]
operator|)
operator|*
operator|-
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|13
index|]
operator|=
name|mf
index|[
literal|12
index|]
operator|)
operator|*
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|12
index|]
operator|=
name|mf
index|[
literal|11
index|]
operator|)
operator|*
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|11
index|]
operator|=
name|mf
index|[
literal|10
index|]
operator|)
operator|*
literal|4.833363e-02
expr_stmt|;
name|mf
index|[
literal|10
index|]
operator|=
name|mf
index|[
literal|9
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|9
index|]
operator|=
name|mf
index|[
literal|8
index|]
operator|)
operator|*
operator|-
literal|4.833363e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|8
index|]
operator|=
name|mf
index|[
literal|7
index|]
operator|)
operator|*
operator|-
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|7
index|]
operator|=
name|mf
index|[
literal|6
index|]
operator|)
operator|*
operator|-
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|6
index|]
operator|=
name|mf
index|[
literal|5
index|]
operator|)
operator|*
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|5
index|]
operator|=
name|mf
index|[
literal|4
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|4
index|]
operator|=
name|mf
index|[
literal|3
index|]
operator|)
operator|*
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|3
index|]
operator|=
name|mf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|2
index|]
operator|=
name|mf
index|[
literal|1
index|]
operator|)
operator|*
operator|-
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|1
index|]
operator|=
name|mf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|4.833363e-02
expr_stmt|;
name|mf
index|[
literal|0
index|]
operator|=
name|syncx
expr_stmt|;
block|}
else|else
block|{
name|mfsync
operator|=
literal|0
expr_stmt|;
name|pdelay
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Enhance the seconds sync pulse using a 1-s (8000-sample) comb 	 * filter. Correct for the FIR matched filter delay, which is 5 	 * ms for both the WWV and WWVH filters, and also for the 	 * propagation delay. Once each second look for second sync. If 	 * not in minute sync, fiddle the codec gain. Note the SNR is 	 * computed from the maximum sample and the two samples 6 ms 	 * before and 6 ms after it, so if we slip more than a cycle the 	 * SNR should plummet. 	 */
name|dtemp
operator|=
operator|(
name|epobuf
index|[
name|epoch
index|]
operator|+=
operator|(
name|mfsync
operator|-
name|epobuf
index|[
name|epoch
index|]
operator|)
operator|/
name|up
operator|->
name|avgint
operator|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
name|epomax
condition|)
block|{
name|epomax
operator|=
name|dtemp
expr_stmt|;
name|epopos
operator|=
name|epoch
expr_stmt|;
block|}
if|if
condition|(
name|epoch
operator|==
literal|0
condition|)
block|{
name|int
name|k
decl_stmt|,
name|j
decl_stmt|;
name|up
operator|->
name|epomax
operator|=
name|epomax
expr_stmt|;
name|k
operator|=
name|epopos
operator|-
literal|6
operator|*
name|MS
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|k
operator|+=
name|SECOND
expr_stmt|;
name|j
operator|=
name|epopos
operator|+
literal|6
operator|*
name|MS
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|SECOND
condition|)
name|i
operator|-=
name|SECOND
expr_stmt|;
name|up
operator|->
name|eposnr
operator|=
name|wwv_snr
argument_list|(
name|epomax
argument_list|,
name|max
argument_list|(
name|abs
argument_list|(
name|epobuf
index|[
name|k
index|]
argument_list|)
argument_list|,
name|abs
argument_list|(
name|epobuf
index|[
name|j
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|epopos
operator|-=
name|pdelay
operator|+
literal|5
operator|*
name|MS
expr_stmt|;
if|if
condition|(
name|epopos
operator|<
literal|0
condition|)
name|epopos
operator|+=
name|SECOND
expr_stmt|;
name|wwv_endpoc
argument_list|(
name|peer
argument_list|,
name|epopos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SSYNC
operator|)
condition|)
name|up
operator|->
name|alarm
operator||=
name|SYNERR
expr_stmt|;
name|epomax
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
name|wwv_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_qrz - identify and acquire WWV/WWVH minute sync pulse  *  * This routine implements a virtual station process used to acquire  * minute sync and to mitigate among the ten frequency and station  * combinations. During minute sync acquisition the process probes each  * frequency in turn for the minute pulse from either station, which  * involves searching through the entire minute of samples. After  * finding a candidate, the process searches only the seconds before and  * after the candidate for the signal and all other seconds for the  * noise.  *  * Students of radar receiver technology will discover this algorithm  * amounts to a range gate discriminator. The discriminator requires  * that the peak minute pulse amplitude be at least 2000 and the SNR be  * at least 6 dB. In addition after finding a candidate, The peak second  * pulse amplitude must be at least 2000, the SNR at least 6 dB and the  * difference between the current and previous epoch must be less than  * 7.5 ms, which corresponds to a frequency error of 125 PPM.. A compare  * counter keeps track of the number of successive intervals which  * satisfy these criteria.  *  * Note that, while the minute pulse is found by by the discriminator,  * the actual value is determined from the second epoch. The assumption  * is that the discriminator peak occurs about 800 ms into the second,  * so the timing is retarted to the previous second epoch.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_qrz
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|struct
name|sync
modifier|*
name|sp
parameter_list|,
comment|/* sync channel structure */
name|double
name|syncx
parameter_list|,
comment|/* bandpass filtered sync signal */
name|int
name|pdelay
comment|/* propagation delay (samples) */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* monitor buffer */
name|double
name|snr
decl_stmt|;
comment|/* on-pulse/off-pulse ratio (dB) */
name|long
name|epoch
decl_stmt|,
name|fpoch
decl_stmt|;
name|int
name|isgood
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Find the sample with peak energy, which defines the minute 	 * epoch. If a sample has been found with good amplitude, 	 * accumulate the noise squares for all except the second before 	 * and after that position. 	 */
name|isgood
operator|=
name|up
operator|->
name|epomax
operator|>
name|STHR
operator|&&
name|up
operator|->
name|eposnr
operator|>
name|SSNR
expr_stmt|;
if|if
condition|(
name|isgood
condition|)
block|{
name|fpoch
operator|=
name|up
operator|->
name|mphase
operator|%
name|SECOND
operator|-
name|up
operator|->
name|tepoch
expr_stmt|;
if|if
condition|(
name|fpoch
operator|<
literal|0
condition|)
name|fpoch
operator|+=
name|SECOND
expr_stmt|;
block|}
else|else
block|{
name|fpoch
operator|=
name|pdelay
operator|+
name|SYNSIZ
expr_stmt|;
block|}
name|epoch
operator|=
name|up
operator|->
name|mphase
operator|-
name|fpoch
expr_stmt|;
if|if
condition|(
name|epoch
operator|<
literal|0
condition|)
name|epoch
operator|+=
name|MINUTE
expr_stmt|;
if|if
condition|(
name|syncx
operator|>
name|sp
operator|->
name|maxamp
condition|)
block|{
name|sp
operator|->
name|maxamp
operator|=
name|syncx
expr_stmt|;
name|sp
operator|->
name|pos
operator|=
name|epoch
expr_stmt|;
block|}
if|if
condition|(
name|abs
argument_list|(
operator|(
name|epoch
operator|-
name|sp
operator|->
name|lastpos
operator|)
operator|%
name|MINUTE
argument_list|)
operator|>
name|SECOND
condition|)
name|sp
operator|->
name|noiamp
operator|+=
name|syncx
expr_stmt|;
comment|/* 	 * At the end of the minute, determine the epoch of the 	 * sync pulse, as well as the SNR and difference between 	 * the current and previous epoch, which represents the 	 * intrinsic frequency error plus jitter. 	 */
if|if
condition|(
name|up
operator|->
name|mphase
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|synmax
operator|=
name|sqrt
argument_list|(
name|sp
operator|->
name|maxamp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|synmin
operator|=
name|sqrt
argument_list|(
name|sp
operator|->
name|noiamp
operator|/
operator|(
name|MINUTE
operator|-
literal|2
operator|*
name|SECOND
operator|)
argument_list|)
expr_stmt|;
name|epoch
operator|=
operator|(
name|sp
operator|->
name|pos
operator|-
name|sp
operator|->
name|lastpos
operator|)
operator|%
name|MINUTE
expr_stmt|;
comment|/* 		 * If not yet in minute sync, we have to do a little 		 * dance to find a valid minute sync pulse, emphasis 		 * valid. 		 */
name|snr
operator|=
name|wwv_snr
argument_list|(
name|sp
operator|->
name|synmax
argument_list|,
name|sp
operator|->
name|synmin
argument_list|)
expr_stmt|;
name|isgood
operator|=
name|isgood
operator|&&
name|sp
operator|->
name|synmax
operator|>
name|ATHR
operator|&&
name|snr
operator|>
name|ASNR
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|count
condition|)
block|{
comment|/* 		 * In state 0 the station was not heard during the 		 * previous probe. Look for the biggest blip greater 		 * than the amplitude threshold in the minute and assume 		 * that the minute sync pulse. We're fishing here, since 		 * the range gate has not yet been determined. If found, 		 * bump to state 1. 		 */
case|case
literal|0
case|:
if|if
condition|(
name|sp
operator|->
name|synmax
operator|>=
name|ATHR
condition|)
name|sp
operator|->
name|count
operator|++
expr_stmt|;
break|break;
comment|/* 		 * In state 1 a candidate blip has been found and the 		 * next minute has been searched for another blip. If 		 * none are found acceptable, drop back to state 0 and 		 * hunt some more. Otherwise, a legitimate minute pulse 		 * may have been found, so bump to state 2. 		 */
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|isgood
condition|)
block|{
name|sp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|sp
operator|->
name|count
operator|++
expr_stmt|;
break|break;
comment|/* 		 * In states 2 and above, continue to groom samples as 		 * before and drop back to state 0 if the groom fails. 		 * If it succeeds, set the epoch and bump to the next 		 * state until reaching the threshold, if ever. 		 */
default|default:
if|if
condition|(
operator|!
name|isgood
operator|||
name|abs
argument_list|(
name|epoch
argument_list|)
operator|>
name|AWND
operator|*
name|MS
condition|)
block|{
name|sp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|sp
operator|->
name|mepoch
operator|=
name|sp
operator|->
name|pos
expr_stmt|;
name|sp
operator|->
name|count
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv8 %d %3d %s %d %5.0f %5.1f %5ld %5d %ld"
argument_list|,
name|up
operator|->
name|port
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|sp
operator|->
name|refid
argument_list|,
name|sp
operator|->
name|count
argument_list|,
name|sp
operator|->
name|synmax
argument_list|,
name|snr
argument_list|,
name|sp
operator|->
name|pos
argument_list|,
name|up
operator|->
name|tepoch
argument_list|,
name|epoch
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sp
operator|->
name|lastpos
operator|=
name|sp
operator|->
name|pos
expr_stmt|;
name|sp
operator|->
name|maxamp
operator|=
name|sp
operator|->
name|noiamp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_endpoc - identify and acquire second sync pulse  *  * This routine is called at the end of the second sync interval. It  * determines the second sync epoch position within the interval and  * disciplines the sample clock using a frequency-lock loop (FLL).  *  * Second sync is determined in the RF input routine as the maximum  * over all 8000 samples in the second comb filter. To assure accurate  * and reliable time and frequency discipline, this routine performs a  * great deal of heavy-handed heuristic data filtering and grooming.  *  * Note that, since the minute sync pulse is very wide (800 ms), precise  * minute sync epoch acquisition requires at least a rough estimate of  * the second sync pulse (5 ms). This becomes more important in choppy  * conditions at the lower frequencies at night, since sferics and  * cochannel crude can badly distort the minute pulse.   */
end_comment

begin_function
specifier|static
name|void
name|wwv_endpoc
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|epopos
comment|/* epoch max position */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
specifier|static
name|int
name|epoch_mf
index|[
literal|3
index|]
decl_stmt|;
comment|/* epoch median filter */
specifier|static
name|int
name|xepoch
decl_stmt|;
comment|/* last second epoch */
specifier|static
name|int
name|zepoch
decl_stmt|;
comment|/* last averaging interval epoch */
specifier|static
name|int
name|syncnt
decl_stmt|;
comment|/* run length counter */
specifier|static
name|int
name|maxrun
decl_stmt|;
comment|/* longest run length */
specifier|static
name|int
name|mepoch
decl_stmt|;
comment|/* longest run epoch */
specifier|static
name|int
name|avgcnt
decl_stmt|;
comment|/* averaging interval counter */
specifier|static
name|int
name|avginc
decl_stmt|;
comment|/* averaging ratchet */
specifier|static
name|int
name|iniflg
decl_stmt|;
comment|/* initialization flag */
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* monitor buffer */
name|double
name|dtemp
decl_stmt|;
name|int
name|tmp2
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
name|iniflg
condition|)
block|{
name|iniflg
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|epoch_mf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|epoch_mf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * A three-stage median filter is used to help denoise the 	 * second sync pulse. The median sample becomes the candidate 	 * epoch. 	 */
name|epoch_mf
index|[
literal|2
index|]
operator|=
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
name|epoch_mf
index|[
literal|1
index|]
operator|=
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
name|epoch_mf
index|[
literal|0
index|]
operator|=
name|epopos
expr_stmt|;
if|if
condition|(
name|epoch_mf
index|[
literal|0
index|]
operator|>
name|epoch_mf
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|epoch_mf
index|[
literal|1
index|]
operator|>
name|epoch_mf
index|[
literal|2
index|]
condition|)
name|up
operator|->
name|tepoch
operator|=
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
comment|/* 0 1 2 */
elseif|else
if|if
condition|(
name|epoch_mf
index|[
literal|2
index|]
operator|>
name|epoch_mf
index|[
literal|0
index|]
condition|)
name|up
operator|->
name|tepoch
operator|=
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
comment|/* 2 0 1 */
else|else
name|up
operator|->
name|tepoch
operator|=
name|epoch_mf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 0 2 1 */
block|}
else|else
block|{
if|if
condition|(
name|epoch_mf
index|[
literal|1
index|]
operator|<
name|epoch_mf
index|[
literal|2
index|]
condition|)
name|up
operator|->
name|tepoch
operator|=
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
comment|/* 2 1 0 */
elseif|else
if|if
condition|(
name|epoch_mf
index|[
literal|2
index|]
operator|<
name|epoch_mf
index|[
literal|0
index|]
condition|)
name|up
operator|->
name|tepoch
operator|=
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
comment|/* 1 0 2 */
else|else
name|up
operator|->
name|tepoch
operator|=
name|epoch_mf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 1 2 0 */
block|}
comment|/* 	 * If the signal amplitude or SNR fall below thresholds or if no 	 * stations are heard, dim the second sync lamp and start over. 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
operator|(
name|SELV
operator||
name|SELH
operator|)
operator|)
operator|||
name|up
operator|->
name|epomax
operator|<
name|STHR
operator|||
name|up
operator|->
name|eposnr
operator|<
name|SSNR
condition|)
block|{
name|up
operator|->
name|status
operator|&=
operator|~
operator|(
name|SSYNC
operator||
name|FGATE
operator|)
expr_stmt|;
name|avgcnt
operator|=
name|syncnt
operator|=
name|maxrun
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|avgcnt
operator|++
expr_stmt|;
comment|/* 	 * If the epoch candidate is the same as the last one, increment 	 * the compare counter. If not, save the length and epoch of the 	 * current run for use later and reset the counter. 	 */
name|tmp2
operator|=
operator|(
name|up
operator|->
name|tepoch
operator|-
name|xepoch
operator|)
operator|%
name|SECOND
expr_stmt|;
if|if
condition|(
name|tmp2
operator|==
literal|0
condition|)
block|{
name|syncnt
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|maxrun
operator|>
literal|0
operator|&&
name|mepoch
operator|==
name|xepoch
condition|)
block|{
name|maxrun
operator|+=
name|syncnt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|syncnt
operator|>
name|maxrun
condition|)
block|{
name|maxrun
operator|=
name|syncnt
expr_stmt|;
name|mepoch
operator|=
name|xepoch
expr_stmt|;
block|}
name|syncnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
operator|)
operator|&&
operator|!
operator|(
name|up
operator|->
name|status
operator|&
operator|(
name|SSYNC
operator||
name|MSYNC
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv1 %04x %5.0f %5.1f %5d %5d %4d %4d"
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|up
operator|->
name|eposnr
argument_list|,
name|up
operator|->
name|tepoch
argument_list|,
name|tmp2
argument_list|,
name|avgcnt
argument_list|,
name|syncnt
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
comment|/* 	 * The sample clock frequency is disciplined using a first order 	 * feedback loop with time constant consistent with the Allan 	 * intercept of typical computer clocks. 	 * 	 * The frequency update is calculated from the epoch change in 	 * 125-us units divided by the averaging interval in seconds. 	 * The averaging interval affects other receiver functions, 	 * including the the 1000/1200-Hz comb filter and codec clock 	 * loop. It also affects the 100-Hz subcarrier loop and the bit 	 * and digit comparison counter thresholds. 	 */
if|if
condition|(
name|avgcnt
operator|<
name|up
operator|->
name|avgint
condition|)
block|{
name|xepoch
operator|=
name|up
operator|->
name|tepoch
expr_stmt|;
return|return;
block|}
comment|/* 	 * During the averaging interval the longest run of identical 	 * epoches is determined. If the longest run is at least 10 	 * seconds, the SSYNC bit is lit and the value becomes the 	 * reference epoch for the next interval. If not, the second 	 * synd lamp is dark and flashers set. 	 */
if|if
condition|(
name|maxrun
operator|>
literal|0
operator|&&
name|mepoch
operator|==
name|xepoch
condition|)
block|{
name|maxrun
operator|+=
name|syncnt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|syncnt
operator|>
name|maxrun
condition|)
block|{
name|maxrun
operator|=
name|syncnt
expr_stmt|;
name|mepoch
operator|=
name|xepoch
expr_stmt|;
block|}
name|xepoch
operator|=
name|up
operator|->
name|tepoch
expr_stmt|;
if|if
condition|(
name|maxrun
operator|>
name|SCMP
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|SSYNC
expr_stmt|;
name|up
operator|->
name|yepoch
operator|=
name|mepoch
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|status
operator|&=
operator|~
name|SSYNC
expr_stmt|;
block|}
comment|/* 	 * If the epoch change over the averaging interval is less than 	 * 1 ms, the frequency is adjusted, but clamped at +-125 PPM. If 	 * greater than 1 ms, the counter is decremented. If the epoch 	 * change is less than 0.5 ms, the counter is incremented. If 	 * the counter increments to +3, the averaging interval is 	 * doubled and the counter set to zero; if it increments to -3, 	 * the interval is halved and the counter set to zero. 	 * 	 * Here be spooks. From careful observations, the epoch 	 * sometimes makes a long run of identical samples, then takes a 	 * lurch due apparently to lost interrupts or spooks. If this 	 * happens, the epoch change times the maximum run length will 	 * be greater than the averaging interval, so the lurch should 	 * be believed but the frequency left alone. Really intricate 	 * here. 	 */
if|if
condition|(
name|maxrun
operator|==
literal|0
condition|)
name|mepoch
operator|=
name|up
operator|->
name|tepoch
expr_stmt|;
name|dtemp
operator|=
operator|(
name|mepoch
operator|-
name|zepoch
operator|)
operator|%
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|FGATE
condition|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|dtemp
argument_list|)
operator|<
name|MAXFREQ
operator|*
name|MINAVG
condition|)
block|{
if|if
condition|(
name|maxrun
operator|*
name|abs
argument_list|(
name|mepoch
operator|-
name|zepoch
argument_list|)
operator|<
name|avgcnt
condition|)
block|{
name|up
operator|->
name|freq
operator|+=
name|dtemp
operator|/
name|avgcnt
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|freq
operator|>
name|MAXFREQ
condition|)
name|up
operator|->
name|freq
operator|=
name|MAXFREQ
expr_stmt|;
elseif|else
if|if
condition|(
name|up
operator|->
name|freq
operator|<
operator|-
name|MAXFREQ
condition|)
name|up
operator|->
name|freq
operator|=
operator|-
name|MAXFREQ
expr_stmt|;
block|}
if|if
condition|(
name|abs
argument_list|(
name|dtemp
argument_list|)
operator|<
name|MAXFREQ
operator|*
name|MINAVG
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|avginc
operator|<
literal|3
condition|)
block|{
name|avginc
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|up
operator|->
name|avgint
operator|<
name|MAXAVG
condition|)
block|{
name|up
operator|->
name|avgint
operator|<<=
literal|1
expr_stmt|;
name|avginc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|avginc
operator|>
operator|-
literal|3
condition|)
block|{
name|avginc
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|up
operator|->
name|avgint
operator|>
name|MINAVG
condition|)
block|{
name|up
operator|->
name|avgint
operator|>>=
literal|1
expr_stmt|;
name|avginc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv2 %04x %4.0f %4d %4d %2d %4d %4.0f %6.1f"
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|mepoch
argument_list|,
name|maxrun
argument_list|,
name|avginc
argument_list|,
name|avgcnt
argument_list|,
name|dtemp
argument_list|,
name|up
operator|->
name|freq
operator|*
literal|1e6
operator|/
name|SECOND
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|up
operator|->
name|status
operator||=
name|FGATE
expr_stmt|;
name|zepoch
operator|=
name|mepoch
expr_stmt|;
name|avgcnt
operator|=
name|syncnt
operator|=
name|maxrun
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_epoch - epoch scanner  *  * This routine scans the receiver second epoch to determine the signal  * amplitudes and pulse timings. Receiver synchronization is determined  * by the minute sync pulse detected in the wwv_rf() routine and the  * second sync pulse detected in the wwv_epoch() routine. A pulse width  * discriminator extracts data signals from the 100-Hz subcarrier. The  * transmitted signals are delayed by the propagation delay, receiver  * delay and filter delay of this program. Delay corrections are  * introduced separately for WWV and WWVH.   *  * Most communications radios use a highpass filter in the audio stages,  * which can do nasty things to the subcarrier phase relative to the  * sync pulses. Therefore, the data subcarrier reference phase is  * disciplined using the hardlimited quadrature-phase signal sampled at  * the same time as the in-phase signal. The phase tracking loop uses  * phase adjustments of plus-minus one sample (125 us).  */
end_comment

begin_function
specifier|static
name|void
name|wwv_epoch
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
specifier|static
name|double
name|dpulse
decl_stmt|;
comment|/* data pulse length */
name|double
name|dtemp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Sample the minute sync pulse envelopes at epoch 800 for both 	 * the WWV and WWVH stations. This will be used later for 	 * channel and station mitigation. Note that the seconds epoch 	 * is set here well before the end of the second to make sure we 	 * never seet the epoch backwards. 	 */
if|if
condition|(
name|up
operator|->
name|rphase
operator|==
literal|800
operator|*
name|MS
condition|)
block|{
name|up
operator|->
name|repoch
operator|=
name|up
operator|->
name|yepoch
expr_stmt|;
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
name|cp
operator|->
name|wwv
operator|.
name|synamp
operator|=
name|cp
operator|->
name|wwv
operator|.
name|amp
expr_stmt|;
name|cp
operator|->
name|wwvh
operator|.
name|synamp
operator|=
name|cp
operator|->
name|wwvh
operator|.
name|amp
expr_stmt|;
block|}
comment|/* 	 * Sample the data subcarrier at epoch 15 ms, giving a guard 	 * time of +-15 ms from the beginning of the second until the 	 * pulse rises at 30 ms. The I-channel amplitude is used to 	 * calculate the slice level. The envelope amplitude is used 	 * during the probe seconds to determine the SNR. There is a 	 * compromise here; we want to delay the sample as long as 	 * possible to give the radio time to change frequency and the 	 * AGC to stabilize, but as early as possible if the second 	 * epoch is not exact. 	 */
if|if
condition|(
name|up
operator|->
name|rphase
operator|==
literal|15
operator|*
name|MS
condition|)
block|{
name|up
operator|->
name|noiamp
operator|=
name|up
operator|->
name|irig
operator|*
name|up
operator|->
name|irig
operator|+
name|up
operator|->
name|qrig
operator|*
name|up
operator|->
name|qrig
expr_stmt|;
comment|/* 	 * Sample the data subcarrier at epoch 215 ms, giving a guard 	 * time of +-15 ms from the earliest the pulse peak can be 	 * reached to the earliest it can begin to fall. For the data 	 * channel latch the I-channel amplitude for all except the 	 * probe seconds and adjust the 100-Hz reference oscillator 	 * phase using the Q-channel amplitude at this epoch. For the 	 * probe channel latch the envelope amplitude. 	 */
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|rphase
operator|==
literal|215
operator|*
name|MS
condition|)
block|{
name|up
operator|->
name|sigsig
operator|=
name|up
operator|->
name|irig
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|sigsig
operator|<
literal|0
condition|)
name|up
operator|->
name|sigsig
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|datpha
operator|=
name|up
operator|->
name|qrig
operator|/
name|up
operator|->
name|avgint
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|datpha
operator|>=
literal|0
condition|)
block|{
name|up
operator|->
name|datapt
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|datapt
operator|>=
literal|80
condition|)
name|up
operator|->
name|datapt
operator|-=
literal|80
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|datapt
operator|--
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|datapt
operator|<
literal|0
condition|)
name|up
operator|->
name|datapt
operator|+=
literal|80
expr_stmt|;
block|}
name|up
operator|->
name|sigamp
operator|=
name|up
operator|->
name|irig
operator|*
name|up
operator|->
name|irig
operator|+
name|up
operator|->
name|qrig
operator|*
name|up
operator|->
name|qrig
expr_stmt|;
comment|/* 	 * The slice level is set half way between the peak signal and 	 * noise levels. Sample the negative zero crossing after epoch 	 * 200 ms and record the epoch at that time. This defines the 	 * length of the data pulse, which will later be converted into 	 * scaled bit probabilities. 	 */
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|rphase
operator|>
literal|200
operator|*
name|MS
condition|)
block|{
name|dtemp
operator|=
operator|(
name|up
operator|->
name|sigsig
operator|+
name|sqrt
argument_list|(
name|up
operator|->
name|noiamp
argument_list|)
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|irig
operator|<
name|dtemp
operator|&&
name|dpulse
operator|==
literal|0
condition|)
name|dpulse
operator|=
name|up
operator|->
name|rphase
expr_stmt|;
block|}
comment|/* 	 * At the end of the second crank the clock state machine and 	 * adjust the codec gain. Note the epoch is buffered from the 	 * center of the second in order to avoid jitter while the 	 * seconds synch is diddling the epoch. Then, determine the true 	 * offset and update the median filter in the driver interface. 	 * 	 * Sample the data subcarrier envelope at the end of the second 	 * to determine the SNR for the pulse. This gives a guard time 	 * of +-30 ms from the decay of the longest pulse to the rise of 	 * the next pulse. 	 */
name|up
operator|->
name|rphase
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|mphase
operator|%
name|SECOND
operator|==
name|up
operator|->
name|repoch
condition|)
block|{
name|up
operator|->
name|datsnr
operator|=
name|wwv_snr
argument_list|(
name|up
operator|->
name|sigsig
argument_list|,
name|sqrt
argument_list|(
name|up
operator|->
name|noiamp
argument_list|)
argument_list|)
expr_stmt|;
name|wwv_rsec
argument_list|(
name|peer
argument_list|,
name|dpulse
argument_list|)
expr_stmt|;
name|wwv_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|rphase
operator|=
name|dpulse
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_rsec - process receiver second  *  * This routine is called at the end of each receiver second to  * implement the per-second state machine. The machine assembles BCD  * digit bits, decodes miscellaneous bits and dances the leap seconds.  *  * Normally, the minute has 60 seconds numbered 0-59. If the leap  * warning bit is set, the last minute (1439) of 30 June (day 181 or 182  * for leap years) or 31 December (day 365 or 366 for leap years) is  * augmented by one second numbered 60. This is accomplished by  * extending the minute interval by one second and teaching the state  * machine to ignore it.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_rsec
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|dpulse
parameter_list|)
block|{
specifier|static
name|int
name|iniflg
decl_stmt|;
comment|/* initialization flag */
specifier|static
name|double
name|bcddld
index|[
literal|4
index|]
decl_stmt|;
comment|/* BCD data bits */
specifier|static
name|double
name|bitvec
index|[
literal|61
index|]
decl_stmt|;
comment|/* bit integrator for misc bits */
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
name|struct
name|sync
modifier|*
name|sp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|l_fp
name|offset
decl_stmt|;
comment|/* offset in NTP seconds */
name|double
name|bit
decl_stmt|;
comment|/* bit likelihood */
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* monitor buffer */
name|int
name|sw
decl_stmt|,
name|arg
decl_stmt|,
name|nsec
decl_stmt|;
ifdef|#
directive|ifdef
name|IRIG_SUCKS
name|int
name|i
decl_stmt|;
name|l_fp
name|ltemp
decl_stmt|;
endif|#
directive|endif
comment|/* IRIG_SUCKS */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
name|iniflg
condition|)
block|{
name|iniflg
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bitvec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bitvec
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The bit represents the probability of a hit on zero (negative 	 * values), a hit on one (positive values) or a miss (zero 	 * value). The likelihood vector is the exponential average of 	 * these probabilities. Only the bits of this vector 	 * corresponding to the miscellaneous bits of the timecode are 	 * used, but it's easier to do them all. After that, crank the 	 * seconds state machine. 	 */
name|nsec
operator|=
name|up
operator|->
name|rsec
operator|+
literal|1
expr_stmt|;
name|bit
operator|=
name|wwv_data
argument_list|(
name|up
argument_list|,
name|dpulse
argument_list|)
expr_stmt|;
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|+=
operator|(
name|bit
operator|-
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|)
operator|/
name|TCONST
expr_stmt|;
name|sw
operator|=
name|progx
index|[
name|up
operator|->
name|rsec
index|]
operator|.
name|sw
expr_stmt|;
name|arg
operator|=
name|progx
index|[
name|up
operator|->
name|rsec
index|]
operator|.
name|arg
expr_stmt|;
switch|switch
condition|(
name|sw
condition|)
block|{
comment|/* 	 * Ignore this second. 	 */
case|case
name|IDLE
case|:
comment|/* 9, 45-49 */
break|break;
comment|/* 	 * Probe channel stuff 	 * 	 * The WWV/H format contains data pulses in second 59 (position 	 * identifier), second 1 (not used) and the minute sync pulse in 	 * second 0. At the end of second 58, QSY to the probe channel, 	 * which rotates over all WWV/H frequencies. At the end of 	 * second 1 QSY back to the data channel. 	 * 	 * At the end of second 0 save the minute sync pulse peak value 	 * previously latched at 800 ms. 	 */
case|case
name|SYNC2
case|:
comment|/* 0 */
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
name|cp
operator|->
name|wwv
operator|.
name|synmax
operator|=
name|sqrt
argument_list|(
name|cp
operator|->
name|wwv
operator|.
name|synamp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|wwvh
operator|.
name|synmax
operator|=
name|sqrt
argument_list|(
name|cp
operator|->
name|wwvh
operator|.
name|synamp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * At the end of second 1 determine the minute sync pulse 	 * amplitude and SNR and set SYNCNG if these values are below 	 * thresholds. Determine the data pulse amplitude and SNR and 	 * set DATANG if these values are below thresholds. Set ERRRNG 	 * if data pulses in second 59 and second 1 are decoded in 	 * error. Shift a 1 into the reachability register if SYNCNG and 	 * DATANG are both lit; otherwise shift a 0. Ignore ERRRNG for 	 * the present. The number of 1 bits in the last six intervals 	 * represents the channel metric used by the mitigation routine. 	 * Finally, QSY back to the data channel. 	 */
case|case
name|SYNC3
case|:
comment|/* 1 */
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
name|cp
operator|->
name|sigamp
operator|=
name|sqrt
argument_list|(
name|up
operator|->
name|sigamp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|noiamp
operator|=
name|sqrt
argument_list|(
name|up
operator|->
name|noiamp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|datsnr
operator|=
name|wwv_snr
argument_list|(
name|cp
operator|->
name|sigamp
argument_list|,
name|cp
operator|->
name|noiamp
argument_list|)
expr_stmt|;
comment|/* 		 * WWV station 		 */
name|sp
operator|=
operator|&
name|cp
operator|->
name|wwv
expr_stmt|;
name|sp
operator|->
name|synmin
operator|=
name|sqrt
argument_list|(
operator|(
name|sp
operator|->
name|synmin
operator|+
name|sp
operator|->
name|synamp
operator|)
operator|/
literal|2.
argument_list|)
expr_stmt|;
name|sp
operator|->
name|synsnr
operator|=
name|wwv_snr
argument_list|(
name|sp
operator|->
name|synmax
argument_list|,
name|sp
operator|->
name|synmin
argument_list|)
expr_stmt|;
name|sp
operator|->
name|select
operator|&=
operator|~
operator|(
name|SYNCNG
operator||
name|DATANG
operator||
name|ERRRNG
operator|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|synmax
operator|<
name|QTHR
operator|||
name|sp
operator|->
name|synsnr
operator|<
name|QSNR
condition|)
name|sp
operator|->
name|select
operator||=
name|SYNCNG
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|sigamp
operator|<
name|XTHR
operator|||
name|cp
operator|->
name|datsnr
operator|<
name|XSNR
condition|)
name|sp
operator|->
name|select
operator||=
name|DATANG
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errcnt
operator|>
literal|2
condition|)
name|sp
operator|->
name|select
operator||=
name|ERRRNG
expr_stmt|;
name|sp
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|reach
operator|&
operator|(
literal|1
operator|<<
name|AMAX
operator|)
condition|)
name|sp
operator|->
name|count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|select
operator|&
operator|(
name|SYNCNG
operator||
name|DATANG
operator|)
operator|)
condition|)
block|{
name|sp
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|sp
operator|->
name|count
operator|++
expr_stmt|;
block|}
comment|/* 		 * WWVH station 		 */
name|rp
operator|=
operator|&
name|cp
operator|->
name|wwvh
expr_stmt|;
name|rp
operator|->
name|synmin
operator|=
name|sqrt
argument_list|(
operator|(
name|rp
operator|->
name|synmin
operator|+
name|rp
operator|->
name|synamp
operator|)
operator|/
literal|2.
argument_list|)
expr_stmt|;
name|rp
operator|->
name|synsnr
operator|=
name|wwv_snr
argument_list|(
name|rp
operator|->
name|synmax
argument_list|,
name|rp
operator|->
name|synmin
argument_list|)
expr_stmt|;
name|rp
operator|->
name|select
operator|&=
operator|~
operator|(
name|SYNCNG
operator||
name|DATANG
operator||
name|ERRRNG
operator|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|synmax
operator|<
name|QTHR
operator|||
name|rp
operator|->
name|synsnr
operator|<
name|QSNR
condition|)
name|rp
operator|->
name|select
operator||=
name|SYNCNG
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|sigamp
operator|<
name|XTHR
operator|||
name|cp
operator|->
name|datsnr
operator|<
name|XSNR
condition|)
name|rp
operator|->
name|select
operator||=
name|DATANG
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errcnt
operator|>
literal|2
condition|)
name|rp
operator|->
name|select
operator||=
name|ERRRNG
expr_stmt|;
name|rp
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|reach
operator|&
operator|(
literal|1
operator|<<
name|AMAX
operator|)
condition|)
name|rp
operator|->
name|count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|select
operator|&
operator|(
name|SYNCNG
operator||
name|DATANG
operator||
name|ERRRNG
operator|)
operator|)
condition|)
block|{
name|rp
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|rp
operator|->
name|count
operator|++
expr_stmt|;
block|}
comment|/* 		 * Set up for next minute. 		 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv5 %2d %04x %3d %4d %d %.0f/%.1f %s %04x %.0f %.0f/%.1f %s %04x %.0f %.0f/%.1f"
argument_list|,
name|up
operator|->
name|port
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|yepoch
argument_list|,
name|up
operator|->
name|errcnt
argument_list|,
name|cp
operator|->
name|sigamp
argument_list|,
name|cp
operator|->
name|datsnr
argument_list|,
name|sp
operator|->
name|refid
argument_list|,
name|sp
operator|->
name|reach
operator|&
literal|0xffff
argument_list|,
name|wwv_metric
argument_list|(
name|sp
argument_list|)
argument_list|,
name|sp
operator|->
name|synmax
argument_list|,
name|sp
operator|->
name|synsnr
argument_list|,
name|rp
operator|->
name|refid
argument_list|,
name|rp
operator|->
name|reach
operator|&
literal|0xffff
argument_list|,
name|wwv_metric
argument_list|(
name|rp
argument_list|)
argument_list|,
name|rp
operator|->
name|synmax
argument_list|,
name|rp
operator|->
name|synsnr
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
ifdef|#
directive|ifdef
name|ICOM
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|dchan
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ICOM */
name|up
operator|->
name|status
operator|&=
operator|~
name|SFLAG
expr_stmt|;
name|up
operator|->
name|errcnt
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|alarm
operator|=
literal|0
expr_stmt|;
name|wwv_newchan
argument_list|(
name|peer
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Save the bit probability in the BCD data vector at the index 	 * given by the argument. Note that all bits of the vector have 	 * to be above the data gate threshold for the digit to be 	 * considered valid. Bits not used in the digit are forced to 	 * zero and not checked for errors. 	 */
case|case
name|COEF
case|:
comment|/* 4-7, 10-13, 15-17, 20-23, 					   25-26, 30-33, 35-38, 40-41, 					   51-54 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|DGATE
condition|)
name|up
operator|->
name|status
operator||=
name|BGATE
expr_stmt|;
name|bcddld
index|[
name|arg
index|]
operator|=
name|bit
expr_stmt|;
break|break;
case|case
name|COEF2
case|:
comment|/* 18, 27-28, 42-43 */
name|bcddld
index|[
name|arg
index|]
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 	 * Correlate coefficient vector with each valid digit vector and 	 * save in decoding matrix. We step through the decoding matrix 	 * digits correlating each with the coefficients and saving the 	 * greatest and the next lower for later SNR calculation. 	 */
case|case
name|DECIM2
case|:
comment|/* 29 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIM3
case|:
comment|/* 44 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd3
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIM6
case|:
comment|/* 19 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd6
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIM9
case|:
comment|/* 8, 14, 24, 34, 39 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd9
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Miscellaneous bits. If above the positive threshold, declare 	 * 1; if below the negative threshold, declare 0; otherwise 	 * raise the SYMERR alarm. At the end of second 58, QSY to the 	 * probe channel. The design is intended to preserve the bits 	 * over periods of signal loss. 	 */
case|case
name|MSC20
case|:
comment|/* 55 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd9
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|MSCBIT
case|:
comment|/* 2-3, 50, 56-57 */
if|if
condition|(
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|>
name|BTHR
condition|)
name|up
operator|->
name|misc
operator||=
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|<
operator|-
name|BTHR
condition|)
name|up
operator|->
name|misc
operator|&=
operator|~
name|arg
expr_stmt|;
else|else
name|up
operator|->
name|alarm
operator||=
name|SYMERR
expr_stmt|;
break|break;
comment|/* 	 * Save the data channel gain, then QSY to the probe channel. 	 */
case|case
name|MSC21
case|:
comment|/* 58 */
if|if
condition|(
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|>
name|BTHR
condition|)
name|up
operator|->
name|misc
operator||=
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|<
operator|-
name|BTHR
condition|)
name|up
operator|->
name|misc
operator|&=
operator|~
name|arg
expr_stmt|;
else|else
name|up
operator|->
name|alarm
operator||=
name|SYMERR
expr_stmt|;
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|dchan
index|]
operator|.
name|gain
operator|=
name|up
operator|->
name|gain
expr_stmt|;
ifdef|#
directive|ifdef
name|ICOM
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|schan
operator|=
operator|(
name|up
operator|->
name|schan
operator|+
literal|1
operator|)
operator|%
name|NCHAN
expr_stmt|;
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|schan
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ICOM */
name|up
operator|->
name|status
operator||=
name|SFLAG
operator||
name|SELV
operator||
name|SELH
expr_stmt|;
name|up
operator|->
name|errbit
operator|=
name|up
operator|->
name|errcnt
expr_stmt|;
name|up
operator|->
name|errcnt
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 	 * The endgames 	 * 	 * During second 59 the receiver and codec AGC are settling 	 * down, so the data pulse is unusable. At the end of this 	 * second, latch the minute sync pulse noise floor. Then do the 	 * minute processing and update the system clock. If a leap 	 * second sail on to the next second (60); otherwise, set up for 	 * the next minute. 	 */
case|case
name|MIN1
case|:
comment|/* 59 */
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
name|cp
operator|->
name|wwv
operator|.
name|synmin
operator|=
name|cp
operator|->
name|wwv
operator|.
name|synamp
expr_stmt|;
name|cp
operator|->
name|wwvh
operator|.
name|synmin
operator|=
name|cp
operator|->
name|wwvh
operator|.
name|synamp
expr_stmt|;
comment|/* 		 * Dance the leap if necessary and the kernel has the 		 * right stuff. Then, wind up the clock and initialize 		 * for the following minute. If the leap dance, note the 		 * kernel is armed one second before the actual leap is 		 * scheduled. 		 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|SSYNC
operator|&&
name|up
operator|->
name|digcnt
operator|>=
literal|9
condition|)
name|up
operator|->
name|status
operator||=
name|INSYNC
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|LEPDAY
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|wwv_tsec
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|nsec
operator|=
name|up
operator|->
name|digcnt
operator|=
literal|0
expr_stmt|;
block|}
name|pp
operator|->
name|lencode
operator|=
name|timecode
argument_list|(
name|up
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"wwv: timecode %d %s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|&&
name|up
operator|->
name|watch
operator|<
name|HOLD
condition|)
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * If LEPDAY is set on the last minute of 30 June or 31 	 * December, the LEPSEC bit is set. At the end of the minute in 	 * which LEPSEC is set the transmitter and receiver insert an 	 * extra second (60) in the timescale and the minute sync skips 	 * a second. We only get to test this wrinkle at intervals of 	 * about 18 months; the actual mileage may vary. 	 */
case|case
name|MIN2
case|:
comment|/* 60 */
name|wwv_tsec
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|nsec
operator|=
name|up
operator|->
name|digcnt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 	 * If digit sync has not been acquired before timeout or if no 	 * station has been heard, game over and restart from scratch. 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|DSYNC
operator|)
operator|&&
operator|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
operator|(
name|SELV
operator||
name|SELH
operator|)
operator|)
operator|||
name|up
operator|->
name|watch
operator|>
name|DIGIT
operator|)
condition|)
block|{
name|wwv_newgame
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If no timestamps have been struck before timeout, game over 	 * and restart from scratch. 	 */
if|if
condition|(
name|up
operator|->
name|watch
operator|>
name|PANIC
condition|)
block|{
name|wwv_newgame
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|disp
operator|+=
name|AUDIO_PHI
expr_stmt|;
name|up
operator|->
name|rsec
operator|=
name|nsec
expr_stmt|;
ifdef|#
directive|ifdef
name|IRIG_SUCKS
comment|/* 	 * You really don't wanna know what comes down here. Leave it to 	 * say Solaris 2.8 broke the nice clean audio stream, apparently 	 * affected by a 5-ms sawtooth jitter. Sundown on Solaris. This 	 * leaves a little twilight. 	 * 	 * The scheme involves differentiation, forward learning and 	 * integration. The sawtooth has a period of 11 seconds. The 	 * timestamp differences are integrated and subtracted from the 	 * signal. 	 */
name|ltemp
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|ltemp
argument_list|,
operator|&
name|pp
operator|->
name|lastref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltemp
operator|.
name|l_f
operator|<
literal|0
condition|)
name|ltemp
operator|.
name|l_i
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|ltemp
operator|.
name|l_i
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
if|if
condition|(
operator|!
name|L_ISNEG
argument_list|(
operator|&
name|ltemp
argument_list|)
condition|)
name|L_CLR
argument_list|(
operator|&
name|up
operator|->
name|wigwag
argument_list|)
expr_stmt|;
else|else
name|L_ADD
argument_list|(
operator|&
name|up
operator|->
name|wigwag
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
operator|&
name|up
operator|->
name|wigwag
argument_list|)
expr_stmt|;
name|up
operator|->
name|wiggle
index|[
name|up
operator|->
name|wp
index|]
operator|=
name|ltemp
expr_stmt|;
comment|/* 	 * Bottom fisher. To understand this, you have to know about 	 * velocity microphones and AM transmitters. No further 	 * explanation is offered, as this is truly a black art. 	 */
name|up
operator|->
name|wigbot
index|[
name|up
operator|->
name|wp
index|]
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WIGGLE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|up
operator|->
name|wp
condition|)
name|up
operator|->
name|wigbot
index|[
name|i
index|]
operator|.
name|l_ui
operator|++
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
operator|&
name|up
operator|->
name|wigbot
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
condition|)
name|L_ADD
argument_list|(
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
operator|&
name|up
operator|->
name|wigbot
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|wigbot
index|[
name|i
index|]
expr_stmt|;
block|}
name|up
operator|->
name|wp
operator|++
expr_stmt|;
name|up
operator|->
name|wp
operator|%=
name|WIGGLE
expr_stmt|;
endif|#
directive|endif
comment|/* IRIG_SUCKS */
comment|/* 	 * If victory has been declared and seconds sync is lit, strike 	 * a timestamp. It should not be a surprise, especially if the 	 * radio is not tunable, that sometimes no stations are above 	 * the noise and the reference ID set to NONE. 	 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|&&
name|up
operator|->
name|status
operator|&
name|SSYNC
condition|)
block|{
name|pp
operator|->
name|second
operator|=
name|up
operator|->
name|rsec
expr_stmt|;
name|pp
operator|->
name|minute
operator|=
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|pp
operator|->
name|hour
operator|=
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|pp
operator|->
name|day
operator|=
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|digit
operator|*
literal|100
expr_stmt|;
name|pp
operator|->
name|year
operator|=
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|pp
operator|->
name|year
operator|+=
literal|2000
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|GMT
argument_list|,
name|up
operator|->
name|timestamp
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|&
name|offset
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|up
operator|->
name|errflg
operator|=
name|CEVNT_BADTIME
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|watch
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|disp
operator|=
literal|0
expr_stmt|;
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|offset
argument_list|,
name|up
operator|->
name|timestamp
argument_list|,
name|PDELAY
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
operator|)
operator|&&
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|DSYNC
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv3 %2d %04x %5.0f %5.1f %5.0f %5.1f %5.0f"
argument_list|,
name|up
operator|->
name|rsec
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|up
operator|->
name|eposnr
argument_list|,
name|up
operator|->
name|sigsig
argument_list|,
name|up
operator|->
name|datsnr
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_data - calculate bit probability  *  * This routine is called at the end of the receiver second to calculate  * the probabilities that the previous second contained a zero (P0), one  * (P1) or position indicator (P2) pulse. If not in sync or if the data  * bit is bad, a bit error is declared and the probabilities are forced  * to zero. Otherwise, the data gate is enabled and the probabilities  * are calculated. Note that the data matched filter contributes half  * the pulse width, or 85 ms.  *  * It's important to observe that there are three conditions to  * determine: average to +1 (hit), average to -1 (miss) or average to  * zero (erasure). The erasure condition results from insufficient  * signal (noise) and has no bias toward either a hit or miss.  */
end_comment

begin_function
specifier|static
name|double
name|wwv_data
parameter_list|(
name|struct
name|wwvunit
modifier|*
name|up
parameter_list|,
comment|/* driver unit pointer */
name|double
name|pulse
comment|/* pulse length (sample units) */
parameter_list|)
block|{
name|double
name|p0
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* probabilities */
name|double
name|dpulse
decl_stmt|;
comment|/* pulse length in ms */
name|p0
operator|=
name|p1
operator|=
name|p2
operator|=
literal|0
expr_stmt|;
name|dpulse
operator|=
name|pulse
operator|-
name|DATSIZ
operator|/
literal|2
expr_stmt|;
comment|/* 	 * If no station is being tracked, if either the data amplitude 	 * or SNR are below threshold or if the pulse length is less 	 * than 170 ms, declare an erasure. 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
operator|(
name|SELV
operator||
name|SELH
operator|)
operator|)
operator|||
name|up
operator|->
name|sigsig
operator|<
name|DTHR
operator|||
name|up
operator|->
name|datsnr
operator|<
name|DSNR
operator|||
name|dpulse
operator|<
name|DATSIZ
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|DGATE
expr_stmt|;
name|up
operator|->
name|errcnt
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errcnt
operator|>
name|MAXERR
condition|)
name|up
operator|->
name|alarm
operator||=
name|MODERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * The probability of P0 is one below 200 ms falling to zero at 	 * 500 ms. The probability of P1 is zero below 200 ms rising to 	 * one at 500 ms and falling to zero at 800 ms. The probability 	 * of P2 is zero below 500 ms, rising to one above 800 ms. 	 */
name|up
operator|->
name|status
operator|&=
operator|~
name|DGATE
expr_stmt|;
if|if
condition|(
name|dpulse
operator|<
operator|(
literal|200
operator|*
name|MS
operator|)
condition|)
block|{
name|p0
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dpulse
operator|<
literal|500
operator|*
name|MS
condition|)
block|{
name|dpulse
operator|-=
literal|200
operator|*
name|MS
expr_stmt|;
name|p1
operator|=
name|dpulse
operator|/
operator|(
literal|300
operator|*
name|MS
operator|)
expr_stmt|;
name|p0
operator|=
literal|1
operator|-
name|p1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dpulse
operator|<
literal|800
operator|*
name|MS
condition|)
block|{
name|dpulse
operator|-=
literal|500
operator|*
name|MS
expr_stmt|;
name|p2
operator|=
name|dpulse
operator|/
operator|(
literal|300
operator|*
name|MS
operator|)
expr_stmt|;
name|p1
operator|=
literal|1
operator|-
name|p2
expr_stmt|;
block|}
else|else
block|{
name|p2
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * The ouput is a metric that ranges from -1 (P0), to +1 (P1) 	 * scaled for convenience. An output of zero represents an 	 * erasure, either because of a data error or pulse length 	 * greater than 500 ms. At the moment, we don't use P2. 	 */
return|return
operator|(
operator|(
name|p1
operator|-
name|p0
operator|)
operator|*
name|MAXSIG
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_corr4 - determine maximum likelihood digit  *  * This routine correlates the received digit vector with the BCD  * coefficient vectors corresponding to all valid digits at the given  * position in the decoding matrix. The maximum value corresponds to the  * maximum likelihood digit, while the ratio of this value to the next  * lower value determines the likelihood function. Note that, if the  * digit is invalid, the likelihood vector is averaged toward a miss.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_corr4
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer unit pointer */
name|struct
name|decvec
modifier|*
name|vp
parameter_list|,
comment|/* decoding table pointer */
name|double
name|data
index|[]
parameter_list|,
comment|/* received data vector */
name|double
name|tab
index|[]
index|[
literal|4
index|]
comment|/* correlation vector array */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|double
name|topmax
decl_stmt|,
name|nxtmax
decl_stmt|;
comment|/* metrics */
name|double
name|acc
decl_stmt|;
comment|/* accumulator */
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* monitor buffer */
name|int
name|mldigit
decl_stmt|;
comment|/* max likelihood digit */
name|int
name|diff
decl_stmt|;
comment|/* decoding difference */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Correlate digit vector with each BCD coefficient vector. If 	 * any BCD digit bit is bad, consider all bits a miss. 	 */
name|mldigit
operator|=
literal|0
expr_stmt|;
name|topmax
operator|=
name|nxtmax
operator|=
operator|-
name|MAXSIG
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tab
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|acc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|BGATE
operator|)
condition|)
name|acc
operator|+=
name|data
index|[
name|j
index|]
operator|*
name|tab
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
name|acc
operator|=
operator|(
name|vp
operator|->
name|like
index|[
name|i
index|]
operator|+=
operator|(
name|acc
operator|-
name|vp
operator|->
name|like
index|[
name|i
index|]
operator|)
operator|/
name|TCONST
operator|)
expr_stmt|;
if|if
condition|(
name|acc
operator|>
name|topmax
condition|)
block|{
name|nxtmax
operator|=
name|topmax
expr_stmt|;
name|topmax
operator|=
name|acc
expr_stmt|;
name|mldigit
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acc
operator|>
name|nxtmax
condition|)
block|{
name|nxtmax
operator|=
name|acc
expr_stmt|;
block|}
block|}
name|vp
operator|->
name|mldigit
operator|=
name|mldigit
expr_stmt|;
name|vp
operator|->
name|digprb
operator|=
name|topmax
expr_stmt|;
name|vp
operator|->
name|digsnr
operator|=
name|wwv_snr
argument_list|(
name|topmax
argument_list|,
name|nxtmax
argument_list|)
expr_stmt|;
comment|/* 	 * The maximum likelihood digit is compared with the current 	 * clock digit. The difference represents the decoding phase 	 * error. If the clock is not yet synchronized, the phase error 	 * is corrected even of the digit probability and likelihood are 	 * below thresholds. This avoids lengthy averaging times should 	 * a carry mistake occur. However, the digit is not declared 	 * synchronized until these values are above thresholds and the 	 * last five decoded values are identical. If the clock is 	 * synchronized, the phase error is not corrected unless the 	 * last five digits are all above thresholds and identical. This 	 * avoids mistakes when the signal is coming out of the noise 	 * and the SNR is very marginal. 	 */
name|diff
operator|=
name|mldigit
operator|-
name|vp
operator|->
name|digit
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|+=
name|vp
operator|->
name|radix
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
name|vp
operator|->
name|phase
condition|)
block|{
name|vp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|phase
operator|=
name|diff
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|digsnr
operator|<
name|BSNR
condition|)
block|{
name|vp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|alarm
operator||=
name|SYMERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|digprb
operator|<
name|BTHR
condition|)
block|{
name|vp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|alarm
operator||=
name|SYMERR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|)
block|{
name|vp
operator|->
name|phase
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|digit
operator|=
name|mldigit
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|count
operator|<
name|BCMP
condition|)
block|{
name|vp
operator|->
name|count
operator|++
expr_stmt|;
name|up
operator|->
name|status
operator||=
name|DSYNC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|)
block|{
name|vp
operator|->
name|phase
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|digit
operator|=
name|mldigit
expr_stmt|;
block|}
block|}
else|else
block|{
name|vp
operator|->
name|phase
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|digit
operator|=
name|mldigit
expr_stmt|;
name|up
operator|->
name|digcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|digit
operator|!=
name|mldigit
condition|)
name|up
operator|->
name|alarm
operator||=
name|DECERR
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
operator|)
operator|&&
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv4 %2d %04x %5.0f %2d %d %d %d %d %5.0f %5.1f"
argument_list|,
name|up
operator|->
name|rsec
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|vp
operator|->
name|radix
argument_list|,
name|vp
operator|->
name|digit
argument_list|,
name|vp
operator|->
name|mldigit
argument_list|,
name|vp
operator|->
name|phase
argument_list|,
name|vp
operator|->
name|count
argument_list|,
name|vp
operator|->
name|digprb
argument_list|,
name|vp
operator|->
name|digsnr
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|up
operator|->
name|status
operator|&=
operator|~
name|BGATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_tsec - transmitter minute processing  *  * This routine is called at the end of the transmitter minute. It  * implements a state machine that advances the logical clock subject to  * the funny rules that govern the conventional clock and calendar.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_tsec
parameter_list|(
name|struct
name|wwvunit
modifier|*
name|up
comment|/* driver structure pointer */
parameter_list|)
block|{
name|int
name|minute
decl_stmt|,
name|day
decl_stmt|,
name|isleap
decl_stmt|;
name|int
name|temp
decl_stmt|;
comment|/* 	 * Advance minute unit of the day. 	 */
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|MN
index|]
argument_list|)
expr_stmt|;
comment|/* minute units */
comment|/* 	 * Propagate carries through the day. 	 */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
comment|/* carry minutes */
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
comment|/* carry hours */
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Decode the current minute and day. Set leap day if the 	 * timecode leap bit is set on 30 June or 31 December. Set leap 	 * minute if the last minute on leap day. This code fails in 	 * 2400 AD. 	 */
name|minute
operator|=
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|digit
operator|*
literal|60
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|600
expr_stmt|;
name|day
operator|=
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|digit
operator|*
literal|100
expr_stmt|;
name|isleap
operator|=
operator|(
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|digit
operator|&
literal|0x3
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|misc
operator|&
name|SECWAR
operator|&&
operator|(
name|day
operator|==
operator|(
name|isleap
condition|?
literal|182
else|:
literal|183
operator|)
operator|||
name|day
operator|==
operator|(
name|isleap
condition|?
literal|365
else|:
literal|366
operator|)
operator|)
operator|&&
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|&&
name|up
operator|->
name|status
operator|&
name|SSYNC
condition|)
name|up
operator|->
name|status
operator||=
name|LEPDAY
expr_stmt|;
else|else
name|up
operator|->
name|status
operator|&=
operator|~
name|LEPDAY
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|LEPDAY
operator|&&
name|minute
operator|==
literal|1439
condition|)
name|up
operator|->
name|status
operator||=
name|LEPSEC
expr_stmt|;
else|else
name|up
operator|->
name|status
operator|&=
operator|~
name|LEPSEC
expr_stmt|;
comment|/* 	 * Roll the day if this the first minute and propagate carries 	 * through the year. 	 */
if|if
condition|(
name|minute
operator|!=
literal|1440
condition|)
return|return;
name|minute
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/* advance to minute 0 */
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|day
operator|++
expr_stmt|;
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
index|]
argument_list|)
expr_stmt|;
comment|/* carry days */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Roll the year if this the first day and propagate carries 	 * through the century. 	 */
if|if
condition|(
name|day
operator|!=
operator|(
name|isleap
condition|?
literal|365
else|:
literal|366
operator|)
condition|)
return|return;
name|day
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
index|]
argument_list|)
operator|!=
literal|1
condition|)
empty_stmt|;
comment|/* advance to day 1 */
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|YR
index|]
argument_list|)
expr_stmt|;
comment|/* carry years */
if|if
condition|(
name|temp
condition|)
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * carry - process digit  *  * This routine rotates a likelihood vector one position and increments  * the clock digit modulo the radix. It returns the new clock digit or  * zero if a carry occurred. Once synchronized, the clock digit will  * match the maximum likelihood digit corresponding to that position.  */
end_comment

begin_function
specifier|static
name|int
name|carry
parameter_list|(
name|struct
name|decvec
modifier|*
name|dp
comment|/* decoding table pointer */
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
name|int
name|j
decl_stmt|;
name|dp
operator|->
name|digit
operator|++
expr_stmt|;
comment|/* advance clock digit */
if|if
condition|(
name|dp
operator|->
name|digit
operator|==
name|dp
operator|->
name|radix
condition|)
block|{
comment|/* modulo radix */
name|dp
operator|->
name|digit
operator|=
literal|0
expr_stmt|;
block|}
name|temp
operator|=
name|dp
operator|->
name|like
index|[
name|dp
operator|->
name|radix
operator|-
literal|1
index|]
expr_stmt|;
comment|/* rotate likelihood vector */
for|for
control|(
name|j
operator|=
name|dp
operator|->
name|radix
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|dp
operator|->
name|like
index|[
name|j
index|]
operator|=
name|dp
operator|->
name|like
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|dp
operator|->
name|like
index|[
literal|0
index|]
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|dp
operator|->
name|digit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_snr - compute SNR or likelihood function  */
end_comment

begin_function
specifier|static
name|double
name|wwv_snr
parameter_list|(
name|double
name|signal
parameter_list|,
comment|/* signal */
name|double
name|noise
comment|/* noise */
parameter_list|)
block|{
name|double
name|rval
decl_stmt|;
comment|/* 	 * This is a little tricky. Due to the way things are measured, 	 * either or both the signal or noise amplitude can be negative 	 * or zero. The intent is that, if the signal is negative or 	 * zero, the SNR must always be zero. This can happen with the 	 * subcarrier SNR before the phase has been aligned. On the 	 * other hand, in the likelihood function the "noise" is the 	 * next maximum down from the peak and this could be negative. 	 * However, in this case the SNR is truly stupendous, so we 	 * simply cap at MAXSNR dB. 	 */
if|if
condition|(
name|signal
operator|<=
literal|0
condition|)
block|{
name|rval
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noise
operator|<=
literal|0
condition|)
block|{
name|rval
operator|=
name|MAXSNR
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
literal|20
operator|*
name|log10
argument_list|(
name|signal
operator|/
name|noise
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|>
name|MAXSNR
condition|)
name|rval
operator|=
name|MAXSNR
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_newchan - change to new data channel  *  * The radio actually appears to have ten channels, one channel for each  * of five frequencies and each of two stations (WWV and WWVH), although  * if not tunable only the 15 MHz channels appear live. While the radio  * is tuned to the working data channel frequency and station for most  * of the minute, during seconds 59, 0 and 1 the radio is tuned to a  * probe frequency in order to search for minute sync pulse and data  * subcarrier from other transmitters.  *  * The search for WWV and WWVH operates simultaneously, with WWV minute  * sync pulse at 1000 Hz and WWVH at 1200 Hz. The probe frequency  * rotates each minute over 2.5, 5, 10, 15 and 20 MHz in order and yes,  * we all know WWVH is dark on 20 MHz, but few remember when WWV was lit  * on 25 MHz.  *  * This routine selects the best channel using a metric computed from  * the reachability register and minute pulse amplitude. Normally, the  * award goes to the the channel with the highest metric; but, in case  * of ties, the award goes to the channel with the highest minute sync  * pulse amplitude and then to the highest frequency.  *  * The routine performs an important squelch function to keep dirty data  * from polluting the integrators. During acquisition and until the  * clock is synchronized, the signal metric must be at least MTR (13);  * after that the metrict must be at least TTHR (50). If either of these  * is not true, the station select bits are cleared so the second sync  * is disabled and the data bit integrators averaged to a miss.   */
end_comment

begin_function
specifier|static
name|void
name|wwv_newchan
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|sync
modifier|*
name|sp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|double
name|rank
decl_stmt|,
name|dtemp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Search all five station pairs looking for the channel with 	 * maximum metric. If no station is found above thresholds, the 	 * reference ID is set to NONE and we wait for hotter ions. 	 */
name|j
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
name|rank
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
name|i
operator|++
control|)
block|{
name|rp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|i
index|]
operator|.
name|wwvh
expr_stmt|;
name|dtemp
operator|=
name|wwv_metric
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>=
name|rank
condition|)
block|{
name|rank
operator|=
name|dtemp
expr_stmt|;
name|sp
operator|=
name|rp
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
name|rp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|i
index|]
operator|.
name|wwv
expr_stmt|;
name|dtemp
operator|=
name|wwv_metric
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>=
name|rank
condition|)
block|{
name|rank
operator|=
name|dtemp
expr_stmt|;
name|sp
operator|=
name|rp
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
block|}
name|up
operator|->
name|dchan
operator|=
name|j
expr_stmt|;
name|up
operator|->
name|sptr
operator|=
name|sp
expr_stmt|;
name|up
operator|->
name|status
operator|&=
operator|~
operator|(
name|SELV
operator||
name|SELH
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
literal|"NONE"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
operator|&&
name|rank
operator|>=
name|MTHR
operator|)
operator|||
operator|(
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
operator|&&
name|rank
operator|>=
name|TTHR
operator|)
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|sp
operator|->
name|select
operator|&
operator|(
name|SELV
operator||
name|SELH
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|sp
operator|->
name|refid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
literal|1
condition|)
name|memcpy
argument_list|(
operator|&
name|peer
operator|->
name|refid
argument_list|,
operator|&
name|pp
operator|->
name|refid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * www_newgame - reset and start over  */
end_comment

begin_function
specifier|static
name|void
name|wwv_newgame
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Initialize strategic values. Note we set the leap bits 	 * NOTINSYNC and the refid "NONE". 	 */
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|up
operator|->
name|watch
operator|=
name|up
operator|->
name|status
operator|=
name|up
operator|->
name|alarm
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|avgint
operator|=
name|MINAVG
expr_stmt|;
name|up
operator|->
name|freq
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|sptr
operator|=
name|NULL
expr_stmt|;
name|up
operator|->
name|gain
operator|=
name|MAXGAIN
operator|/
literal|2
expr_stmt|;
comment|/* 	 * Initialize the station processes for audio gain, select bit, 	 * station/frequency identifier and reference identifier. 	 */
name|memset
argument_list|(
name|up
operator|->
name|mitig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|mitig
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|i
index|]
expr_stmt|;
name|cp
operator|->
name|gain
operator|=
name|up
operator|->
name|gain
expr_stmt|;
name|cp
operator|->
name|wwv
operator|.
name|select
operator|=
name|SELV
expr_stmt|;
name|sprintf
argument_list|(
name|cp
operator|->
name|wwv
operator|.
name|refid
argument_list|,
literal|"WV%.0f"
argument_list|,
name|floor
argument_list|(
name|qsy
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|wwvh
operator|.
name|select
operator|=
name|SELH
expr_stmt|;
name|sprintf
argument_list|(
name|cp
operator|->
name|wwvh
operator|.
name|refid
argument_list|,
literal|"WH%.0f"
argument_list|,
name|floor
argument_list|(
name|qsy
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|wwv_newchan
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_metric - compute station metric  *  * The most significant bits represent the number of ones in the  * reachability register. The least significant bits represent the  * minute sync pulse amplitude. The combined value is scaled 0-100.  */
end_comment

begin_function
name|double
name|wwv_metric
parameter_list|(
name|struct
name|sync
modifier|*
name|sp
comment|/* station pointer */
parameter_list|)
block|{
name|double
name|dtemp
decl_stmt|;
name|dtemp
operator|=
name|sp
operator|->
name|count
operator|*
name|MAXSIG
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|synmax
operator|<
name|MAXSIG
condition|)
name|dtemp
operator|+=
name|sp
operator|->
name|synmax
expr_stmt|;
else|else
name|dtemp
operator|+=
name|MAXSIG
operator|-
literal|1
expr_stmt|;
name|dtemp
operator|/=
operator|(
name|AMAX
operator|+
literal|1
operator|)
operator|*
name|MAXSIG
expr_stmt|;
return|return
operator|(
name|dtemp
operator|*
literal|100.
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_comment
comment|/*  * wwv_qsy - Tune ICOM receiver  *  * This routine saves the AGC for the current channel, switches to a new  * channel and restores the AGC for that channel. If a tunable receiver  * is not available, just fake it.  */
end_comment

begin_function
specifier|static
name|int
name|wwv_qsy
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|chan
comment|/* channel */
parameter_list|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|gain
operator|=
name|up
operator|->
name|gain
expr_stmt|;
name|rval
operator|=
name|icom_freq
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|,
name|peer
operator|->
name|ttl
operator|&
literal|0x7f
argument_list|,
name|qsy
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
name|up
operator|->
name|achan
operator|=
name|chan
expr_stmt|;
name|up
operator|->
name|gain
operator|=
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|gain
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * timecode - assemble timecode string and length  *  * Prettytime format - similar to Spectracom  *  * sq yy ddd hh:mm:ss ld dut lset agc iden sig errs freq avgt  *  * s	sync indicator ('?' or ' ')  * q	error bits (hex 0-F)  * yyyy	year of century  * ddd	day of year  * hh	hour of day  * mm	minute of hour  * ss	second of minute)  * l	leap second warning (' ' or 'L')  * d	DST state ('S', 'D', 'I', or 'O')  * dut	DUT sign and magnitude (0.1 s)  * lset	minutes since last clock update  * agc	audio gain (0-255)  * iden	reference identifier (station and frequency)  * sig	signal quality (0-100)  * errs	bit errors in last minute  * freq	frequency offset (PPM)  * avgt	averaging time (s)  */
end_comment

begin_function
specifier|static
name|int
name|timecode
parameter_list|(
name|struct
name|wwvunit
modifier|*
name|up
parameter_list|,
comment|/* driver structure pointer */
name|char
modifier|*
name|ptr
comment|/* target string */
parameter_list|)
block|{
name|struct
name|sync
modifier|*
name|sp
decl_stmt|;
name|int
name|year
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|dut
decl_stmt|;
name|char
name|synchar
decl_stmt|,
name|leapchar
decl_stmt|,
name|dst
decl_stmt|;
name|char
name|cptr
index|[
literal|50
index|]
decl_stmt|;
comment|/* 	 * Common fixed-format fields 	 */
name|synchar
operator|=
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|?
literal|' '
else|:
literal|'?'
expr_stmt|;
name|year
operator|=
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
literal|2000
expr_stmt|;
name|day
operator|=
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|digit
operator|*
literal|100
expr_stmt|;
name|hour
operator|=
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|minute
operator|=
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|second
operator|=
literal|0
expr_stmt|;
name|leapchar
operator|=
operator|(
name|up
operator|->
name|misc
operator|&
name|SECWAR
operator|)
condition|?
literal|'L'
else|:
literal|' '
expr_stmt|;
name|dst
operator|=
name|dstcod
index|[
operator|(
name|up
operator|->
name|misc
operator|>>
literal|4
operator|)
operator|&
literal|0x3
index|]
expr_stmt|;
name|dut
operator|=
name|up
operator|->
name|misc
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|misc
operator|&
name|DUTS
operator|)
condition|)
name|dut
operator|=
operator|-
name|dut
expr_stmt|;
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%c%1X"
argument_list|,
name|synchar
argument_list|,
name|up
operator|->
name|alarm
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cptr
argument_list|,
literal|" %4d %03d %02d:%02d:%02d %c%c %+d"
argument_list|,
name|year
argument_list|,
name|day
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|leapchar
argument_list|,
name|dst
argument_list|,
name|dut
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ptr
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
comment|/* 	 * Specific variable-format fields 	 */
name|sp
operator|=
name|up
operator|->
name|sptr
expr_stmt|;
name|sprintf
argument_list|(
name|cptr
argument_list|,
literal|" %d %d %s %.0f %d %.1f %d"
argument_list|,
name|up
operator|->
name|watch
argument_list|,
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|dchan
index|]
operator|.
name|gain
argument_list|,
name|sp
operator|->
name|refid
argument_list|,
name|wwv_metric
argument_list|(
name|sp
argument_list|)
argument_list|,
name|up
operator|->
name|errbit
argument_list|,
name|up
operator|->
name|freq
operator|/
name|SECOND
operator|*
literal|1e6
argument_list|,
name|up
operator|->
name|avgint
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ptr
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_gain - adjust codec gain  *  * This routine is called at the end of each second. It counts the  * number of signal clips above the MAXSIG threshold during the previous  * second. If there are no clips, the gain is bumped up; if too many  * clips, it is bumped down. The decoder is relatively insensitive to  * amplitude, so this crudity works just fine. The input port is set and  * the error flag is cleared, mostly to be ornery.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_gain
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Apparently, the codec uses only the high order bits of the 	 * gain control field. Thus, it may take awhile for changes to 	 * wiggle the hardware bits. 	 */
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|gain
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|>
name|MAXGAIN
condition|)
name|up
operator|->
name|gain
operator|=
name|MAXGAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|>
name|MAXCLP
condition|)
block|{
name|up
operator|->
name|gain
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|<
literal|0
condition|)
name|up
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
block|}
name|audio_gain
argument_list|(
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|mongain
argument_list|,
name|up
operator|->
name|port
argument_list|)
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|audio_show
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_wwv_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

