begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_wwv - clock driver for NIST WWV/H time/frequency station  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_WWV
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_IOCTL_H */
end_comment

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"audio.h"
end_include

begin_define
define|#
directive|define
name|ICOM
value|1
end_define

begin_comment
comment|/* undefine to suppress ICOM code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_include
include|#
directive|include
file|"icom.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * Audio WWV/H demodulator/decoder  *  * This driver synchronizes the computer time using data encoded in  * radio transmissions from NIST time/frequency stations WWV in Boulder,  * CO, and WWVH in Kauai, HI. Transmikssions are made continuously on  * 2.5, 5, 10, 15 and 20 MHz in AM mode. An ordinary shortwave receiver  * can be tuned manually to one of these frequencies or, in the case of  * ICOM receivers, the receiver can be tuned automatically using this  * program as propagation conditions change throughout the day and  * night.  *  * The driver receives, demodulates and decodes the radio signals when  * connected to the audio codec of a Sun workstation running SunOS or  * Solaris, and with a little help, other workstations with similar  * codecs or sound cards. In this implementation, only one audio driver  * and codec can be supported on a single machine.  *  * The demodulation and decoding algorithms used in this driver are  * based on those developed for the TAPR DSP93 development board and the  * TI 320C25 digital signal processor described in: Mills, D.L. A  * precision radio clock for WWV transmissions. Electrical Engineering  * Report 97-8-1, University of Delaware, August 1997, 25 pp. Available  * from www.eecis.udel.edu/~mills/reports.htm. The algorithms described  * in this report have been modified somewhat to improve performance  * under weak signal conditions and to provide an automatic station  * identification feature.  *  * The ICOM code is normally compiled in the driver. It isn't used,  * unless the mode keyword on the server configuration command specifies  * a nonzero ICOM ID select code. The C-IV trace is turned on if the  * debug level is greater than one.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"NONE"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"WWV/H Audio Demodulator/Decoder"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|SECOND
value|8000
end_define

begin_comment
comment|/* second epoch (sample rate) (Hz) */
end_comment

begin_define
define|#
directive|define
name|MINUTE
value|(SECOND * 60)
end_define

begin_comment
comment|/* minute epoch */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|128
end_define

begin_comment
comment|/* companded sample offset */
end_comment

begin_define
define|#
directive|define
name|SIZE
value|256
end_define

begin_comment
comment|/* decompanding table size */
end_comment

begin_define
define|#
directive|define
name|MAXSIG
value|6000.
end_define

begin_comment
comment|/* maximum signal level reference */
end_comment

begin_define
define|#
directive|define
name|MAXSNR
value|30.
end_define

begin_comment
comment|/* max SNR reference */
end_comment

begin_define
define|#
directive|define
name|DGAIN
value|20.
end_define

begin_comment
comment|/* data channel gain reference */
end_comment

begin_define
define|#
directive|define
name|SGAIN
value|10.
end_define

begin_comment
comment|/* sync channel gain reference */
end_comment

begin_define
define|#
directive|define
name|MAXFREQ
value|(125e-6 * SECOND)
end_define

begin_comment
comment|/* freq tolerance (.0125%) */
end_comment

begin_define
define|#
directive|define
name|PI
value|3.1415926535
end_define

begin_comment
comment|/* the real thing */
end_comment

begin_define
define|#
directive|define
name|DATSIZ
value|(170 * MS)
end_define

begin_comment
comment|/* data matched filter size */
end_comment

begin_define
define|#
directive|define
name|SYNSIZ
value|(800 * MS)
end_define

begin_comment
comment|/* minute sync matched filter size */
end_comment

begin_define
define|#
directive|define
name|UTCYEAR
value|72
end_define

begin_comment
comment|/* the first UTC year */
end_comment

begin_define
define|#
directive|define
name|MAXERR
value|30
end_define

begin_comment
comment|/* max data bit errors in minute */
end_comment

begin_define
define|#
directive|define
name|NCHAN
value|5
end_define

begin_comment
comment|/* number of channels */
end_comment

begin_comment
comment|/*  * Macroni  */
end_comment

begin_define
define|#
directive|define
name|MOD
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)< 0 ? -(-(x) % (y)) : (x) % (y))
end_define

begin_comment
comment|/*  * General purpose status bits (status)  *  * Notes: SELV and/or SELH are set when the minute sync pulse from  * either or both WWV and/or WWVH stations has been heard. MSYNC is set  * when the minute sync pulse has been acquired and never reset. SSYNC  * is set when the second sync pulse has been acquired and cleared by  * watchdog or signal loss. DSYNC is set when the minutes unit digit has  * reached the threshold and INSYNC is set when if all nine digits have  * reached the threshold and never cleared.  *  * DGATE is set if a data bit is invalid, BGATE is set if a BCD digit  * bit is invalid. SFLAG is set when during seconds 59, 0 and 1 while  * probing for alternate frequencies. LEPSEC is set when the SECWAR of  * the timecode is set on the last second of 30 June or 31 December. At  * the end of this minute both the receiver and transmitter insert  * second 60 in the minute and the minute sync slips a second.  */
end_comment

begin_define
define|#
directive|define
name|MSYNC
value|0x0001
end_define

begin_comment
comment|/* minute epoch sync */
end_comment

begin_define
define|#
directive|define
name|SSYNC
value|0x0002
end_define

begin_comment
comment|/* second epoch sync */
end_comment

begin_define
define|#
directive|define
name|DSYNC
value|0x0004
end_define

begin_comment
comment|/* minute units sync */
end_comment

begin_define
define|#
directive|define
name|INSYNC
value|0x0008
end_define

begin_comment
comment|/* clock synchronized */
end_comment

begin_define
define|#
directive|define
name|DGATE
value|0x0010
end_define

begin_comment
comment|/* data bit error */
end_comment

begin_define
define|#
directive|define
name|BGATE
value|0x0020
end_define

begin_comment
comment|/* BCD digit bit error */
end_comment

begin_define
define|#
directive|define
name|SFLAG
value|0x1000
end_define

begin_comment
comment|/* probe flag */
end_comment

begin_define
define|#
directive|define
name|LEPSEC
value|0x2000
end_define

begin_comment
comment|/* leap second in progress */
end_comment

begin_comment
comment|/*  * Station scoreboard bits (select)  *  * These are used to establish the signal quality for each of the five  * frequencies and two stations.  */
end_comment

begin_define
define|#
directive|define
name|JITRNG
value|0x0001
end_define

begin_comment
comment|/* jitter above threshold */
end_comment

begin_define
define|#
directive|define
name|SYNCNG
value|0x0002
end_define

begin_comment
comment|/* sync below threshold or SNR */
end_comment

begin_define
define|#
directive|define
name|DATANG
value|0x0004
end_define

begin_comment
comment|/* data below threshold or SNR */
end_comment

begin_define
define|#
directive|define
name|SELV
value|0x0100
end_define

begin_comment
comment|/* WWV station select */
end_comment

begin_define
define|#
directive|define
name|SELH
value|0x0200
end_define

begin_comment
comment|/* WWVH station select */
end_comment

begin_comment
comment|/*  * Alarm status bits (alarm)  *  * These bits indicate various alarm conditions, which are decoded to  * form the quality character included in the timecode. There are four  * four-bit nibble fields in the word, each corresponding to a specific  * alarm condition. At the end of each second, the word is shifted left  * one position and the least significant bit of each nibble cleared.  * This bit can be set during the next minute if the associated alarm  * condition is raised. This provides a way to remember alarm conditions  * up to four minutes.  *  * If not tracking both minute sync and second sync, the SYNERR alarm is  * raised. The data error counter is incremented for each invalid data  * bit. If too many data bit errors are encountered in one minute, the  * MODERR alarm is raised. The DECERR alarm is raised if a maximum  * likelihood digit fails to compare with the current clock digit. If  * the probability of any miscellaneous bit or any digit falls below the  * threshold, the SYMERR alarm is raised.  */
end_comment

begin_define
define|#
directive|define
name|DECERR
value|0
end_define

begin_comment
comment|/* BCD digit compare error */
end_comment

begin_define
define|#
directive|define
name|SYMERR
value|4
end_define

begin_comment
comment|/* low bit or digit probability */
end_comment

begin_define
define|#
directive|define
name|MODERR
value|8
end_define

begin_comment
comment|/* too many data bit errors */
end_comment

begin_define
define|#
directive|define
name|SYNERR
value|12
end_define

begin_comment
comment|/* not synchronized to station */
end_comment

begin_comment
comment|/*  * Watchdog timeouts (watch)  *  * If these timeouts expire, the status bits are mashed to zero and the  * driver starts from scratch. Suitably more refined procedures may be  * developed in future. All these are in minutes.  */
end_comment

begin_define
define|#
directive|define
name|ACQSN
value|5
end_define

begin_comment
comment|/* acquisition timeout */
end_comment

begin_define
define|#
directive|define
name|HSPEC
value|15
end_define

begin_comment
comment|/* second sync timeout */
end_comment

begin_define
define|#
directive|define
name|DIGIT
value|30
end_define

begin_comment
comment|/* minute unit digit timeout */
end_comment

begin_define
define|#
directive|define
name|PANIC
value|(4 * 1440)
end_define

begin_comment
comment|/* panic timeout */
end_comment

begin_comment
comment|/*  * Thresholds. These establish the minimum signal level, minimum SNR and  * maximum jitter thresholds which establish the error and false alarm  * rates of the receiver. The values defined here may be on the  * adventurous side in the interest of the highest sensitivity.  */
end_comment

begin_define
define|#
directive|define
name|ATHR
value|2000
end_define

begin_comment
comment|/* acquisition amplitude threshold */
end_comment

begin_define
define|#
directive|define
name|ASNR
value|6.0
end_define

begin_comment
comment|/* acquisition SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|AWND
value|50
end_define

begin_comment
comment|/* acquisition window threshold (ms) */
end_comment

begin_define
define|#
directive|define
name|AMIN
value|3
end_define

begin_comment
comment|/* acquisition min compare count */
end_comment

begin_define
define|#
directive|define
name|AMAX
value|6
end_define

begin_comment
comment|/* max compare count */
end_comment

begin_define
define|#
directive|define
name|QTHR
value|2000
end_define

begin_comment
comment|/* QSY amplitude threshold */
end_comment

begin_define
define|#
directive|define
name|QSNR
value|20.0
end_define

begin_comment
comment|/* QSY SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|STHR
value|500
end_define

begin_comment
comment|/* second sync amplitude threshold */
end_comment

begin_define
define|#
directive|define
name|SCMP
value|10
end_define

begin_comment
comment|/* second sync compare threshold */
end_comment

begin_define
define|#
directive|define
name|DTHR
value|1000
end_define

begin_comment
comment|/* bit amplitude threshold */
end_comment

begin_define
define|#
directive|define
name|DSNR
value|10.0
end_define

begin_comment
comment|/* bit SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|BTHR
value|1000
end_define

begin_comment
comment|/* digit probability threshold */
end_comment

begin_define
define|#
directive|define
name|BSNR
value|3.0
end_define

begin_comment
comment|/* digit likelihood threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|BCMP
value|5
end_define

begin_comment
comment|/* digit compare threshold (dB) */
end_comment

begin_comment
comment|/*  * Tone frequency definitions.  */
end_comment

begin_define
define|#
directive|define
name|MS
value|8
end_define

begin_comment
comment|/* samples per millisecond */
end_comment

begin_define
define|#
directive|define
name|IN100
value|1
end_define

begin_comment
comment|/* 100 Hz 4.5-deg sin table */
end_comment

begin_define
define|#
directive|define
name|IN1000
value|10
end_define

begin_comment
comment|/* 1000 Hz 4.5-deg sin table */
end_comment

begin_define
define|#
directive|define
name|IN1200
value|12
end_define

begin_comment
comment|/* 1200 Hz 4.5-deg sin table */
end_comment

begin_comment
comment|/*  * Acquisition and tracking time constants. Usually powers of 2.  */
end_comment

begin_define
define|#
directive|define
name|MINAVG
value|8
end_define

begin_comment
comment|/* min time constant (s) */
end_comment

begin_define
define|#
directive|define
name|MAXAVG
value|7
end_define

begin_comment
comment|/* max time constant (log2 s) */
end_comment

begin_define
define|#
directive|define
name|TCONST
value|16
end_define

begin_comment
comment|/* minute time constant (s) */
end_comment

begin_define
define|#
directive|define
name|SYNCTC
value|(1024 / (1<< MAXAVG))
end_define

begin_comment
comment|/* FLL constant (s) */
end_comment

begin_comment
comment|/*  * Miscellaneous status bits (misc)  *  * These bits correspond to designated bits in the WWV/H timecode. The  * bit probabilities are exponentially averaged over several minutes and  * processed by a integrator and threshold.  */
end_comment

begin_define
define|#
directive|define
name|DUT1
value|0x01
end_define

begin_comment
comment|/* 56 DUT .1 */
end_comment

begin_define
define|#
directive|define
name|DUT2
value|0x02
end_define

begin_comment
comment|/* 57 DUT .2 */
end_comment

begin_define
define|#
directive|define
name|DUT4
value|0x04
end_define

begin_comment
comment|/* 58 DUT .4 */
end_comment

begin_define
define|#
directive|define
name|DUTS
value|0x08
end_define

begin_comment
comment|/* 50 DUT sign */
end_comment

begin_define
define|#
directive|define
name|DST1
value|0x10
end_define

begin_comment
comment|/* 55 DST1 DST in progress */
end_comment

begin_define
define|#
directive|define
name|DST2
value|0x20
end_define

begin_comment
comment|/* 2 DST2 DST change warning */
end_comment

begin_define
define|#
directive|define
name|SECWAR
value|0x40
end_define

begin_comment
comment|/* 3 leap second warning */
end_comment

begin_comment
comment|/*  * The total system delay with the DSP93 program is at 22.5 ms,  * including the propagation delay from Ft. Collins, CO, to Newark, DE  * (8.9 ms), the communications receiver delay and the delay of the  * DSP93 program itself. The DSP93 program delay is due mainly to the  * 400-Hz FIR bandpass filter (5 ms) and second sync matched filter (5  * ms), leaving about 3.6 ms for the receiver delay and strays.  *  * The total system delay with this program is estimated at 27.1 ms by  * comparison with another PPS-synchronized NTP server over a 10-Mb/s  * Ethernet. The propagation and receiver delays are the same as with  * the DSP93 program. The program delay is due only to the 600-Hz  * IIR bandpass filter (1.1 ms), since other delays have been removed.  * Assuming 4.7 ms for the receiver, program and strays, this leaves  * 13.5 ms for the audio codec and operating system latencies for a  * total of 18.2 ms. as the systematic delay. The additional propagation  * delay specific to each receiver location can be programmed in the  * fudge time1 and time2 values for WWV and WWVH, respectively.  */
end_comment

begin_define
define|#
directive|define
name|PDELAY
value|(.0036 + .0011 + .0135)
end_define

begin_comment
comment|/* net system delay (s) */
end_comment

begin_comment
comment|/*  * Table of sine values at 4.5-degree increments. This is used by the  * synchronous matched filter demodulators. The integral of sine-squared  * over one complete cycle is PI, so the table is normallized by 1 / PI.  */
end_comment

begin_decl_stmt
name|double
name|sintab
index|[]
init|=
block|{
literal|0.000000e+00
block|,
literal|2.497431e-02
block|,
literal|4.979464e-02
block|,
literal|7.430797e-02
block|,
comment|/* 0-3 */
literal|9.836316e-02
block|,
literal|1.218119e-01
block|,
literal|1.445097e-01
block|,
literal|1.663165e-01
block|,
comment|/* 4-7 */
literal|1.870979e-01
block|,
literal|2.067257e-01
block|,
literal|2.250791e-01
block|,
literal|2.420447e-01
block|,
comment|/* 8-11 */
literal|2.575181e-01
block|,
literal|2.714038e-01
block|,
literal|2.836162e-01
block|,
literal|2.940800e-01
block|,
comment|/* 12-15 */
literal|3.027307e-01
block|,
literal|3.095150e-01
block|,
literal|3.143910e-01
block|,
literal|3.173286e-01
block|,
comment|/* 16-19 */
literal|3.183099e-01
block|,
literal|3.173286e-01
block|,
literal|3.143910e-01
block|,
literal|3.095150e-01
block|,
comment|/* 20-23 */
literal|3.027307e-01
block|,
literal|2.940800e-01
block|,
literal|2.836162e-01
block|,
literal|2.714038e-01
block|,
comment|/* 24-27 */
literal|2.575181e-01
block|,
literal|2.420447e-01
block|,
literal|2.250791e-01
block|,
literal|2.067257e-01
block|,
comment|/* 28-31 */
literal|1.870979e-01
block|,
literal|1.663165e-01
block|,
literal|1.445097e-01
block|,
literal|1.218119e-01
block|,
comment|/* 32-35 */
literal|9.836316e-02
block|,
literal|7.430797e-02
block|,
literal|4.979464e-02
block|,
literal|2.497431e-02
block|,
comment|/* 36-39 */
operator|-
literal|0.000000e+00
block|,
operator|-
literal|2.497431e-02
block|,
operator|-
literal|4.979464e-02
block|,
operator|-
literal|7.430797e-02
block|,
comment|/* 40-43 */
operator|-
literal|9.836316e-02
block|,
operator|-
literal|1.218119e-01
block|,
operator|-
literal|1.445097e-01
block|,
operator|-
literal|1.663165e-01
block|,
comment|/* 44-47 */
operator|-
literal|1.870979e-01
block|,
operator|-
literal|2.067257e-01
block|,
operator|-
literal|2.250791e-01
block|,
operator|-
literal|2.420447e-01
block|,
comment|/* 48-51 */
operator|-
literal|2.575181e-01
block|,
operator|-
literal|2.714038e-01
block|,
operator|-
literal|2.836162e-01
block|,
operator|-
literal|2.940800e-01
block|,
comment|/* 52-55 */
operator|-
literal|3.027307e-01
block|,
operator|-
literal|3.095150e-01
block|,
operator|-
literal|3.143910e-01
block|,
operator|-
literal|3.173286e-01
block|,
comment|/* 56-59 */
operator|-
literal|3.183099e-01
block|,
operator|-
literal|3.173286e-01
block|,
operator|-
literal|3.143910e-01
block|,
operator|-
literal|3.095150e-01
block|,
comment|/* 60-63 */
operator|-
literal|3.027307e-01
block|,
operator|-
literal|2.940800e-01
block|,
operator|-
literal|2.836162e-01
block|,
operator|-
literal|2.714038e-01
block|,
comment|/* 64-67 */
operator|-
literal|2.575181e-01
block|,
operator|-
literal|2.420447e-01
block|,
operator|-
literal|2.250791e-01
block|,
operator|-
literal|2.067257e-01
block|,
comment|/* 68-71 */
operator|-
literal|1.870979e-01
block|,
operator|-
literal|1.663165e-01
block|,
operator|-
literal|1.445097e-01
block|,
operator|-
literal|1.218119e-01
block|,
comment|/* 72-75 */
operator|-
literal|9.836316e-02
block|,
operator|-
literal|7.430797e-02
block|,
operator|-
literal|4.979464e-02
block|,
operator|-
literal|2.497431e-02
block|,
comment|/* 76-79 */
literal|0.000000e+00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 80 */
end_comment

begin_comment
comment|/*  * Decoder operations at the end of each second are driven by a state  * machine. The transition matrix consists of a dispatch table indexed  * by second number. Each entry in the table contains a case switch  * number and argument.  */
end_comment

begin_struct
struct|struct
name|progx
block|{
name|int
name|sw
decl_stmt|;
comment|/* case switch number */
name|int
name|arg
decl_stmt|;
comment|/* argument */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Case switch numbers  */
end_comment

begin_define
define|#
directive|define
name|IDLE
value|0
end_define

begin_comment
comment|/* no operation */
end_comment

begin_define
define|#
directive|define
name|COEF
value|1
end_define

begin_comment
comment|/* BCD bit conditioned on DSYNC */
end_comment

begin_define
define|#
directive|define
name|COEF1
value|2
end_define

begin_comment
comment|/* BCD bit */
end_comment

begin_define
define|#
directive|define
name|COEF2
value|3
end_define

begin_comment
comment|/* BCD bit ignored */
end_comment

begin_define
define|#
directive|define
name|DECIM9
value|4
end_define

begin_comment
comment|/* BCD digit 0-9 */
end_comment

begin_define
define|#
directive|define
name|DECIM6
value|5
end_define

begin_comment
comment|/* BCD digit 0-6 */
end_comment

begin_define
define|#
directive|define
name|DECIM3
value|6
end_define

begin_comment
comment|/* BCD digit 0-3 */
end_comment

begin_define
define|#
directive|define
name|DECIM2
value|7
end_define

begin_comment
comment|/* BCD digit 0-2 */
end_comment

begin_define
define|#
directive|define
name|MSCBIT
value|8
end_define

begin_comment
comment|/* miscellaneous bit */
end_comment

begin_define
define|#
directive|define
name|MSC20
value|9
end_define

begin_comment
comment|/* miscellaneous bit */
end_comment

begin_define
define|#
directive|define
name|MSC21
value|10
end_define

begin_comment
comment|/* QSY probe channel */
end_comment

begin_define
define|#
directive|define
name|MIN1
value|11
end_define

begin_comment
comment|/* minute */
end_comment

begin_define
define|#
directive|define
name|MIN2
value|12
end_define

begin_comment
comment|/* leap second */
end_comment

begin_define
define|#
directive|define
name|SYNC2
value|13
end_define

begin_comment
comment|/* QSY data channel */
end_comment

begin_define
define|#
directive|define
name|SYNC3
value|14
end_define

begin_comment
comment|/* QSY data channel */
end_comment

begin_comment
comment|/*  * Offsets in decoding matrix  */
end_comment

begin_define
define|#
directive|define
name|MN
value|0
end_define

begin_comment
comment|/* minute digits (2) */
end_comment

begin_define
define|#
directive|define
name|HR
value|2
end_define

begin_comment
comment|/* hour digits (2) */
end_comment

begin_define
define|#
directive|define
name|DA
value|4
end_define

begin_comment
comment|/* day digits (3) */
end_comment

begin_define
define|#
directive|define
name|YR
value|7
end_define

begin_comment
comment|/* year digits (2) */
end_comment

begin_decl_stmt
name|struct
name|progx
name|progx
index|[]
init|=
block|{
block|{
name|SYNC2
block|,
literal|0
block|}
block|,
comment|/* 0 latch sync max */
block|{
name|SYNC3
block|,
literal|0
block|}
block|,
comment|/* 1 QSY data channel */
block|{
name|MSCBIT
block|,
name|DST2
block|}
block|,
comment|/* 2 dst2 */
block|{
name|MSCBIT
block|,
name|SECWAR
block|}
block|,
comment|/* 3 lw */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 4 1 year units */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 5 2 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 6 4 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 7 8 */
block|{
name|DECIM9
block|,
name|YR
block|}
block|,
comment|/* 8 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 9 p1 */
block|{
name|COEF1
block|,
literal|0
block|}
block|,
comment|/* 10 1 minute units */
block|{
name|COEF1
block|,
literal|1
block|}
block|,
comment|/* 11 2 */
block|{
name|COEF1
block|,
literal|2
block|}
block|,
comment|/* 12 4 */
block|{
name|COEF1
block|,
literal|3
block|}
block|,
comment|/* 13 8 */
block|{
name|DECIM9
block|,
name|MN
block|}
block|,
comment|/* 14 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 15 10 minute tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 16 20 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 17 40 */
block|{
name|COEF2
block|,
literal|3
block|}
block|,
comment|/* 18 80 (not used) */
block|{
name|DECIM6
block|,
name|MN
operator|+
literal|1
block|}
block|,
comment|/* 19 p2 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 20 1 hour units */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 21 2 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 22 4 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 23 8 */
block|{
name|DECIM9
block|,
name|HR
block|}
block|,
comment|/* 24 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 25 10 hour tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 26 20 */
block|{
name|COEF2
block|,
literal|2
block|}
block|,
comment|/* 27 40 (not used) */
block|{
name|COEF2
block|,
literal|3
block|}
block|,
comment|/* 28 80 (not used) */
block|{
name|DECIM2
block|,
name|HR
operator|+
literal|1
block|}
block|,
comment|/* 29 p3 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 30 1 day units */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 31 2 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 32 4 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 33 8 */
block|{
name|DECIM9
block|,
name|DA
block|}
block|,
comment|/* 34 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 35 10 day tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 36 20 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 37 40 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 38 80 */
block|{
name|DECIM9
block|,
name|DA
operator|+
literal|1
block|}
block|,
comment|/* 39 p4 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 40 100 day hundreds */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 41 200 */
block|{
name|COEF2
block|,
literal|2
block|}
block|,
comment|/* 42 400 (not used) */
block|{
name|COEF2
block|,
literal|3
block|}
block|,
comment|/* 43 800 (not used) */
block|{
name|DECIM3
block|,
name|DA
operator|+
literal|2
block|}
block|,
comment|/* 44 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 45 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 46 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 47 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 48 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 49 p5 */
block|{
name|MSCBIT
block|,
name|DUTS
block|}
block|,
comment|/* 50 dut+- */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 51 10 year tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 52 20 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 53 40 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 54 80 */
block|{
name|MSC20
block|,
name|DST1
block|}
block|,
comment|/* 55 dst1 */
block|{
name|MSCBIT
block|,
name|DUT1
block|}
block|,
comment|/* 56 0.1 dut */
block|{
name|MSCBIT
block|,
name|DUT2
block|}
block|,
comment|/* 57 0.2 */
block|{
name|MSC21
block|,
name|DUT4
block|}
block|,
comment|/* 58 0.4 QSY probe channel */
block|{
name|MIN1
block|,
literal|0
block|}
block|,
comment|/* 59 p6 latch sync min */
block|{
name|MIN2
block|,
literal|0
block|}
comment|/* 60 leap second */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * BCD coefficients for maximum likelihood digit decode  */
end_comment

begin_define
define|#
directive|define
name|P15
value|1.
end_define

begin_comment
comment|/* max positive number */
end_comment

begin_define
define|#
directive|define
name|N15
value|-1.
end_define

begin_comment
comment|/* max negative number */
end_comment

begin_comment
comment|/*  * Digits 0-9  */
end_comment

begin_define
define|#
directive|define
name|P9
value|(P15 / 4)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N9
value|(N15 / 4)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd9
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N9
block|,
name|N9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 0 */
block|{
name|P9
block|,
name|N9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 1 */
block|{
name|N9
block|,
name|P9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 2 */
block|{
name|P9
block|,
name|P9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 3 */
block|{
name|N9
block|,
name|N9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 4 */
block|{
name|P9
block|,
name|N9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 5 */
block|{
name|N9
block|,
name|P9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 6 */
block|{
name|P9
block|,
name|P9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 7 */
block|{
name|N9
block|,
name|N9
block|,
name|N9
block|,
name|P9
block|}
block|,
comment|/* 8 */
block|{
name|P9
block|,
name|N9
block|,
name|N9
block|,
name|P9
block|}
block|,
comment|/* 9 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Digits 0-6 (minute tens)  */
end_comment

begin_define
define|#
directive|define
name|P6
value|(P15 / 3)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N6
value|(N15 / 3)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd6
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N6
block|,
name|N6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|P6
block|,
name|N6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
name|N6
block|,
name|P6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
name|P6
block|,
name|P6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
name|N6
block|,
name|N6
block|,
name|P6
block|,
literal|0
block|}
block|,
comment|/* 4 */
block|{
name|P6
block|,
name|N6
block|,
name|P6
block|,
literal|0
block|}
block|,
comment|/* 5 */
block|{
name|N6
block|,
name|P6
block|,
name|P6
block|,
literal|0
block|}
block|,
comment|/* 6 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Digits 0-3 (day hundreds)  */
end_comment

begin_define
define|#
directive|define
name|P3
value|(P15 / 2)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N3
value|(N15 / 2)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd3
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N3
block|,
name|N3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|P3
block|,
name|N3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
name|N3
block|,
name|P3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
name|P3
block|,
name|P3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Digits 0-2 (hour tens)  */
end_comment

begin_define
define|#
directive|define
name|P2
value|(P15 / 2)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N2
value|(N15 / 2)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd2
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N2
block|,
name|N2
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|P2
block|,
name|N2
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
name|N2
block|,
name|P2
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * DST decode (DST2 DST1) for prettyprint  */
end_comment

begin_decl_stmt
name|char
name|dstcod
index|[]
init|=
block|{
literal|'S'
block|,
comment|/* 00 standard time */
literal|'I'
block|,
comment|/* 01 daylight warning */
literal|'O'
block|,
comment|/* 10 standard warning */
literal|'D'
comment|/* 11 daylight time */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The decoding matrix consists of nine row vectors, one for each digit  * of the timecode. The digits are stored from least to most significant  * order. The maximum likelihood timecode is formed from the digits  * corresponding to the maximum likelihood values reading in the  * opposite order: yy ddd hh:mm.  */
end_comment

begin_struct
struct|struct
name|decvec
block|{
name|int
name|radix
decl_stmt|;
comment|/* radix (3, 4, 6, 10) */
name|int
name|digit
decl_stmt|;
comment|/* current clock digit */
name|int
name|mldigit
decl_stmt|;
comment|/* maximum likelihood digit */
name|int
name|phase
decl_stmt|;
comment|/* maximum likelihood digit phase */
name|int
name|count
decl_stmt|;
comment|/* match count */
name|double
name|digprb
decl_stmt|;
comment|/* max digit probability */
name|double
name|digsnr
decl_stmt|;
comment|/* likelihood function (dB) */
name|double
name|like
index|[
literal|10
index|]
decl_stmt|;
comment|/* likelihood integrator 0-9 */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The station structure is used to acquire the minute pulse from WWV  * and/or WWVH. These stations are distinguished by the frequency used  * for the second and minute sync pulses, 1000 Hz for WWV and 1200 Hz  * for WWVH. Other than frequency, the format is the same.  */
end_comment

begin_struct
struct|struct
name|sync
block|{
name|double
name|amp
decl_stmt|;
comment|/* sync amplitude (I, Q square) */
name|double
name|synamp
decl_stmt|;
comment|/* sync envelope at 800 ms */
name|double
name|synmax
decl_stmt|;
comment|/* sync envelope at 0 s */
name|double
name|synmin
decl_stmt|;
comment|/* avg sync envelope at 59 s, 1 s */
name|double
name|synsnr
decl_stmt|;
comment|/* sync signal SNR */
name|double
name|noise
decl_stmt|;
comment|/* max amplitude off pulse */
name|double
name|sigmax
decl_stmt|;
comment|/* max amplitude on pulse */
name|double
name|lastmax
decl_stmt|;
comment|/* last max amplitude on pulse */
name|long
name|pos
decl_stmt|;
comment|/* position at maximum amplitude */
name|long
name|lastpos
decl_stmt|;
comment|/* last position at maximum amplitude */
name|long
name|jitter
decl_stmt|;
comment|/* shake, wiggle and waggle */
name|long
name|mepoch
decl_stmt|;
comment|/* minute synch epoch */
name|int
name|count
decl_stmt|;
comment|/* compare counter */
name|char
name|refid
index|[
literal|5
index|]
decl_stmt|;
comment|/* reference identifier */
name|char
name|ident
index|[
literal|4
index|]
decl_stmt|;
comment|/* station identifier */
name|int
name|select
decl_stmt|;
comment|/* select bits */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The channel structure is used to mitigate between channels. At this  * point we have already decided which station to use.  */
end_comment

begin_struct
struct|struct
name|chan
block|{
name|int
name|gain
decl_stmt|;
comment|/* audio gain */
name|int
name|errcnt
decl_stmt|;
comment|/* data bit error counter */
name|double
name|noiamp
decl_stmt|;
comment|/* I-channel average noise amplitude */
name|struct
name|sync
name|wwv
decl_stmt|;
comment|/* wwv station */
name|struct
name|sync
name|wwvh
decl_stmt|;
comment|/* wwvh station */
block|}
struct|;
end_struct

begin_comment
comment|/*  * WWV unit control structure  */
end_comment

begin_struct
struct|struct
name|wwvunit
block|{
name|l_fp
name|timestamp
decl_stmt|;
comment|/* audio sample timestamp */
name|l_fp
name|tick
decl_stmt|;
comment|/* audio sample increment */
name|double
name|comp
index|[
name|SIZE
index|]
decl_stmt|;
comment|/* decompanding table */
name|double
name|phase
decl_stmt|,
name|freq
decl_stmt|;
comment|/* logical clock phase and frequency */
name|double
name|monitor
decl_stmt|;
comment|/* audio monitor point */
name|int
name|fd_icom
decl_stmt|;
comment|/* ICOM file descriptor */
name|int
name|errflg
decl_stmt|;
comment|/* error flags */
name|int
name|bufcnt
decl_stmt|;
comment|/* samples in buffer */
name|int
name|bufptr
decl_stmt|;
comment|/* buffer index pointer */
name|int
name|port
decl_stmt|;
comment|/* codec port */
name|int
name|gain
decl_stmt|;
comment|/* codec gain */
name|int
name|clipcnt
decl_stmt|;
comment|/* sample clipped count */
name|int
name|seccnt
decl_stmt|;
comment|/* second countdown */
name|int
name|minset
decl_stmt|;
comment|/* minutes since last clock set */
name|int
name|watch
decl_stmt|;
comment|/* watchcat */
name|int
name|swatch
decl_stmt|;
comment|/* second sync watchcat */
comment|/* 	 * Variables used to establish basic system timing 	 */
name|int
name|avgint
decl_stmt|;
comment|/* log2 master time constant (s) */
name|int
name|epoch
decl_stmt|;
comment|/* second epoch ramp */
name|int
name|repoch
decl_stmt|;
comment|/* receiver sync epoch */
name|int
name|yepoch
decl_stmt|;
comment|/* transmitter sync epoch */
name|double
name|epomax
decl_stmt|;
comment|/* second sync amplitude */
name|double
name|irig
decl_stmt|;
comment|/* data I channel amplitude */
name|double
name|qrig
decl_stmt|;
comment|/* data Q channel amplitude */
name|int
name|datapt
decl_stmt|;
comment|/* 100 Hz ramp */
name|double
name|datpha
decl_stmt|;
comment|/* 100 Hz VFO control */
name|int
name|rphase
decl_stmt|;
comment|/* receiver sample counter */
name|int
name|rsec
decl_stmt|;
comment|/* receiver seconds counter */
name|long
name|mphase
decl_stmt|;
comment|/* minute sample counter */
name|long
name|nepoch
decl_stmt|;
comment|/* minute epoch index */
comment|/* 	 * Variables used to mitigate which channel to use 	 */
name|struct
name|chan
name|mitig
index|[
name|NCHAN
index|]
decl_stmt|;
comment|/* channel data */
name|struct
name|sync
modifier|*
name|sptr
decl_stmt|;
comment|/* station pointer */
name|int
name|dchan
decl_stmt|;
comment|/* data channel */
name|int
name|schan
decl_stmt|;
comment|/* probe channel */
name|int
name|achan
decl_stmt|;
comment|/* active channel */
comment|/* 	 * Variables used by the clock state machine 	 */
name|struct
name|decvec
name|decvec
index|[
literal|9
index|]
decl_stmt|;
comment|/* decoding matrix */
name|int
name|cdelay
decl_stmt|;
comment|/* WWV propagation delay (samples) */
name|int
name|hdelay
decl_stmt|;
comment|/* WVVH propagation delay (samples) */
name|int
name|pdelay
decl_stmt|;
comment|/* propagation delay (samples) */
name|int
name|tphase
decl_stmt|;
comment|/* transmitter sample counter */
name|int
name|tsec
decl_stmt|;
comment|/* transmitter seconds counter */
name|int
name|digcnt
decl_stmt|;
comment|/* count of digits synchronized */
comment|/* 	 * Variables used to estimate signal levels and bit/digit 	 * probabilities 	 */
name|double
name|sigamp
decl_stmt|;
comment|/* I-channel peak signal amplitude */
name|double
name|noiamp
decl_stmt|;
comment|/* I-channel average noise amplitude */
name|double
name|datsnr
decl_stmt|;
comment|/* data SNR (dB) */
comment|/* 	 * Variables used to establish status and alarm conditions 	 */
name|int
name|status
decl_stmt|;
comment|/* status bits */
name|int
name|alarm
decl_stmt|;
comment|/* alarm flashers */
name|int
name|misc
decl_stmt|;
comment|/* miscellaneous timecode bits */
name|int
name|errcnt
decl_stmt|;
comment|/* data bit error counter */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wwv_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * More function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|wwv_epoch
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_rf
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_endpoc
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|double
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_rsec
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_qrz
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
expr|struct
name|sync
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_corr4
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
expr|struct
name|decvec
operator|*
operator|,
name|double
index|[]
operator|,
name|double
index|[]
index|[
literal|4
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_gain
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_tsec
name|P
argument_list|(
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|wwv_data
name|P
argument_list|(
operator|(
expr|struct
name|wwvunit
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timecode
name|P
argument_list|(
operator|(
expr|struct
name|wwvunit
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|wwv_snr
name|P
argument_list|(
operator|(
name|double
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|carry
name|P
argument_list|(
operator|(
expr|struct
name|decvec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wwv_newchan
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wwv_qsy
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qsy
index|[
name|NCHAN
index|]
init|=
block|{
literal|2.5
block|,
literal|5
block|,
literal|10
block|,
literal|15
block|,
literal|20
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequencies (MHz) */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_wwv
init|=
block|{
name|wwv_start
block|,
comment|/* start up driver */
name|wwv_shutdown
block|,
comment|/* shut down driver */
name|wwv_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old wwv_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old wwv_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * wwv_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|wwv_start
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|ICOM
name|int
name|temp
decl_stmt|;
endif|#
directive|endif
comment|/* ICOM */
comment|/* 	 * Local variables 	 */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|i
decl_stmt|;
comment|/* index */
name|double
name|step
decl_stmt|;
comment|/* codec adjustment */
comment|/* 	 * Open audio device 	 */
name|fd
operator|=
name|audio_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|audio_show
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wwvunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wwvunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|wwv_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DTOLFP
argument_list|(
literal|1.
operator|/
name|SECOND
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
comment|/* 	 * The companded samples are encoded sign-magnitude. The table 	 * contains all the 256 values in the interest of speed. 	 */
name|up
operator|->
name|comp
index|[
literal|0
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|OFFSET
index|]
operator|=
literal|0.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|1
index|]
operator|=
operator|-
literal|1.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|2
index|]
operator|=
operator|-
literal|3.
expr_stmt|;
name|step
operator|=
literal|2.
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|OFFSET
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|comp
index|[
name|i
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|step
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
name|i
index|]
operator|=
operator|-
name|up
operator|->
name|comp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
name|step
operator|*=
literal|2.
expr_stmt|;
block|}
comment|/* 	 * Initialize the decoding matrix with the radix for each digit 	 * position. 	 */
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* minutes */
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|6
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* hours */
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|3
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* days */
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|radix
operator|=
literal|4
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* years */
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* 	 * Initialize the station processes for audio gain, select bit, 	 * station/frequency identifier and reference identifier. 	 */
name|up
operator|->
name|gain
operator|=
literal|127
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|i
index|]
expr_stmt|;
name|cp
operator|->
name|gain
operator|=
name|up
operator|->
name|gain
expr_stmt|;
name|cp
operator|->
name|wwv
operator|.
name|select
operator|=
name|SELV
expr_stmt|;
name|strcpy
argument_list|(
name|cp
operator|->
name|wwv
operator|.
name|refid
argument_list|,
literal|"WWV "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cp
operator|->
name|wwv
operator|.
name|ident
argument_list|,
literal|"C%.0f"
argument_list|,
name|floor
argument_list|(
name|qsy
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|wwvh
operator|.
name|select
operator|=
name|SELH
expr_stmt|;
name|strcpy
argument_list|(
name|cp
operator|->
name|wwvh
operator|.
name|refid
argument_list|,
literal|"WWVH"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cp
operator|->
name|wwvh
operator|.
name|ident
argument_list|,
literal|"H%.0f"
argument_list|,
name|floor
argument_list|(
name|qsy
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize autotune if available. Start out at 15 MHz. Note 	 * that the ICOM select code must be less than 128, so the high 	 * order bit can be used to select the line speed. 	 */
ifdef|#
directive|ifdef
name|ICOM
name|temp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|temp
operator|=
name|P_TRACE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|ttl
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|ttl
operator|&
literal|0x80
condition|)
name|up
operator|->
name|fd_icom
operator|=
name|icom_init
argument_list|(
literal|"/dev/icom"
argument_list|,
name|B1200
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|fd_icom
operator|=
name|icom_init
argument_list|(
literal|"/dev/icom"
argument_list|,
name|B9600
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|schan
operator|=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|schan
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_SYNCEVENT | NLOG_SYSEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ICOM bus error; autotune disabled"
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator|=
name|CEVNT_FAULT
expr_stmt|;
name|close
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|)
expr_stmt|;
name|up
operator|->
name|fd_icom
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ICOM */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|wwv_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
name|close
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_receive - receive data from the audio device  *  * This routine reads input samples and adjusts the logical clock to  * track the A/D sample clock by dropping or duplicating codec samples.  * It also controls the A/D signal level with an AGC loop to mimimize  * quantization noise and avoid overload.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|sample
decl_stmt|;
comment|/* codec sample */
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* buffer pointer */
name|l_fp
name|ltemp
decl_stmt|;
name|int
name|isneg
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Main loop - read until there ain't no more. Note codec 	 * samples are bit-inverted. 	 */
name|up
operator|->
name|timestamp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|up
operator|->
name|bufcnt
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|DTOLFP
argument_list|(
operator|(
name|double
operator|)
name|up
operator|->
name|bufcnt
operator|/
name|SECOND
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|dpt
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
for|for
control|(
name|up
operator|->
name|bufptr
operator|=
literal|0
init|;
name|up
operator|->
name|bufptr
operator|<
name|up
operator|->
name|bufcnt
condition|;
name|up
operator|->
name|bufptr
operator|++
control|)
block|{
name|sample
operator|=
name|up
operator|->
name|comp
index|[
operator|~
operator|*
name|dpt
operator|&
literal|0xff
index|]
expr_stmt|;
comment|/* 		 * Clip noise spikes greater than MAXSIG. If no clips, 		 * increase the gain a tad; if the clips are too high,  		 * decrease a tad. 		 */
if|if
condition|(
name|sample
operator|>
name|MAXSIG
condition|)
block|{
name|sample
operator|=
name|MAXSIG
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sample
operator|<
operator|-
name|MAXSIG
condition|)
block|{
name|sample
operator|=
operator|-
name|MAXSIG
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
comment|/* 		 * Variable frequency oscillator. A phase change of one 		 * unit produces a change of 360 degrees; a frequency 		 * change of one unit produces a change of 1 Hz. 		 */
name|up
operator|->
name|phase
operator|+=
name|up
operator|->
name|freq
operator|/
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|phase
operator|>=
literal|.5
condition|)
block|{
name|up
operator|->
name|phase
operator|-=
literal|1.
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|phase
operator|<
operator|-
literal|.5
condition|)
block|{
name|up
operator|->
name|phase
operator|+=
literal|1.
expr_stmt|;
name|wwv_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
name|wwv_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wwv_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
name|L_ADD
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
comment|/* 		 * Once each second adjust the codec port and gain. 		 * While at it, initialize the propagation delay for 		 * both WWV and WWVH. Don't forget to correct for the 		 * receiver phase delay, mostly due to the 600-Hz 		 * IIR bandpass filter used for the sync signals. 		 */
name|up
operator|->
name|cdelay
operator|=
call|(
name|int
call|)
argument_list|(
name|SECOND
operator|*
operator|(
name|pp
operator|->
name|fudgetime1
operator|+
name|PDELAY
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|hdelay
operator|=
call|(
name|int
call|)
argument_list|(
name|SECOND
operator|*
operator|(
name|pp
operator|->
name|fudgetime2
operator|+
name|PDELAY
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|seccnt
operator|=
operator|(
name|up
operator|->
name|seccnt
operator|+
literal|1
operator|)
operator|%
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|seccnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
name|up
operator|->
name|port
operator|=
literal|2
expr_stmt|;
else|else
name|up
operator|->
name|port
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * During development, it is handy to have an audio 		 * monitor that can be switched to various signals. This 		 * code converts the linear signal left in up->monitor 		 * to codec format. 		 */
name|isneg
operator|=
literal|0
expr_stmt|;
name|dtemp
operator|=
name|up
operator|->
name|monitor
expr_stmt|;
if|if
condition|(
name|sample
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|dtemp
operator|-=
name|dtemp
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|OFFSET
operator|>>
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dtemp
operator|>
name|up
operator|->
name|comp
index|[
name|i
index|]
condition|)
name|i
operator|+=
name|j
expr_stmt|;
elseif|else
if|if
condition|(
name|dtemp
operator|<
name|up
operator|->
name|comp
index|[
name|i
index|]
condition|)
name|i
operator|-=
name|j
expr_stmt|;
else|else
break|break;
name|j
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isneg
condition|)
operator|*
name|dpt
operator|=
operator|~
operator|(
name|i
operator|+
name|OFFSET
operator|)
expr_stmt|;
else|else
operator|*
name|dpt
operator|=
operator|~
name|i
expr_stmt|;
name|dpt
operator|++
expr_stmt|;
block|}
comment|/* 	 * Squawk to the monitor speaker if enabled. 	 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
condition|)
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
argument_list|,
operator|(
name|u_int
operator|)
name|up
operator|->
name|bufcnt
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"wwv:"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_poll - called by the transmit procedure  *  * This routine keeps track of status. If nothing is heard for two  * successive poll intervals, a timeout event is declared and any  * orphaned timecode updates are sent to foster care. Once the clock is  * set, it always appears reachable, unless reset by watchdog timeout.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_poll
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
name|up
operator|->
name|errflg
operator|=
name|CEVNT_TIMEOUT
expr_stmt|;
else|else
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|INSYNC
condition|)
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errflg
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|errflg
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_rf - process signals and demodulate to baseband  *  * This routine grooms and filters decompanded raw audio samples. The  * output signals include the 100-Hz baseband data signal in quadrature  * form, plus the epoch index of the second sync signal and the second  * index of the minute sync signal.  *  * There are three 1-s ramps used by this program, all spanning the  * range 0-7999 logical samples for exactly one second, as determined by  * the logical clock. The first drives the second epoch and runs  * continuously. The second determines the receiver phase and the third  * the transmitter phase within the second. The receiver second begins  * upon arrival of the 5-ms second sync pulse which begins the second;  * while the transmitter second begins before it by the specified  * propagation delay.  *  * There are three 1-m ramps spanning the range 0-59 seconds. The first  * drives the minute epoch in samples and runs continuously. The second  * determines the receiver second and the third the transmitter second.  * The receiver second begins upon arrival of the 800-ms sync pulse sent  * during the first second of the minute; while the transmitter second  * begins before it by the specified propagation delay.  *  * The output signals include the epoch maximum and phase and second  * maximum and index. The epoch phase provides the master reference for  * all signal and timing functions, while the second index identifies  * the first second of the minute. The epoch and second maxima are used  * to calculate SNR for gating functions.  *  * Demodulation operations are based on three synthesized quadrature  * sinusoids: 100 Hz for the data subcarrier, 1000 Hz for the WWV sync  * signals and 1200 Hz for the WWVH sync signal. These drive synchronous  * matched filters for the data subcarrier (170 ms at 100 Hz), WWV  * minute sync signal (800 ms at 1000 Hz) and WWVH minute sync signal  * (800 ms at 1200 Hz). Two additional matched filters are switched in  * as required for the WWV seconds sync signal (5 ms at 1000 Hz) and  * WWVH seconds sync signal (5 ms at 1200 Hz).  */
end_comment

begin_function
specifier|static
name|void
name|wwv_rf
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peerstructure pointer */
name|double
name|isig
comment|/* input signal */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
specifier|static
name|double
name|lpf
index|[
literal|5
index|]
decl_stmt|;
comment|/* 150-Hz lpf delay line */
name|double
name|data
decl_stmt|;
comment|/* lpf output */
specifier|static
name|double
name|bpf
index|[
literal|9
index|]
decl_stmt|;
comment|/* 1000/1200-Hz bpf delay line */
name|double
name|syncx
decl_stmt|;
comment|/* bpf output */
specifier|static
name|double
name|mf
index|[
literal|41
index|]
decl_stmt|;
comment|/* 1000/1200-Hz mf delay line */
name|double
name|mfsync
decl_stmt|;
comment|/* mf output */
specifier|static
name|int
name|iptr
decl_stmt|;
comment|/* data channel pointer */
specifier|static
name|double
name|ibuf
index|[
name|DATSIZ
index|]
decl_stmt|;
comment|/* data I channel delay line */
specifier|static
name|double
name|qbuf
index|[
name|DATSIZ
index|]
decl_stmt|;
comment|/* data Q channel delay line */
specifier|static
name|int
name|jptr
decl_stmt|;
comment|/* sync channel pointer */
specifier|static
name|double
name|cibuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwv I channel delay line */
specifier|static
name|double
name|cqbuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwv Q channel delay line */
specifier|static
name|double
name|ciamp
decl_stmt|;
comment|/* wwv I channel amplitude */
specifier|static
name|double
name|cqamp
decl_stmt|;
comment|/* wwv Q channel amplitude */
specifier|static
name|int
name|csinptr
decl_stmt|;
comment|/* wwv channel phase */
specifier|static
name|double
name|hibuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwvh I channel delay line */
specifier|static
name|double
name|hqbuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwvh Q channel delay line */
specifier|static
name|double
name|hiamp
decl_stmt|;
comment|/* wwvh I channel amplitude */
specifier|static
name|double
name|hqamp
decl_stmt|;
comment|/* wwvh Q channel amplitude */
specifier|static
name|int
name|hsinptr
decl_stmt|;
comment|/* wwvh channels phase */
specifier|static
name|double
name|epobuf
index|[
name|SECOND
index|]
decl_stmt|;
comment|/* epoch sync comb filter */
specifier|static
name|double
name|epomax
decl_stmt|;
comment|/* epoch sync amplitude buffer */
specifier|static
name|int
name|epopos
decl_stmt|;
comment|/* epoch sync position buffer */
specifier|static
name|int
name|iniflg
decl_stmt|;
comment|/* initialization flag */
name|struct
name|sync
modifier|*
name|sp
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
name|long
name|ltemp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
name|iniflg
condition|)
block|{
name|iniflg
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lpf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lpf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bpf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bpf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cqbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cqbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hqbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hqbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|epobuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|epobuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|up
operator|->
name|monitor
operator|=
name|isig
expr_stmt|;
comment|/* change for debug */
comment|/* 	 * Baseband data demodulation. The 100-Hz subcarrier is 	 * extracted using a 150-Hz IIR lowpass filter. This attenuates 	 * the 1000/1200-Hz sync signals, as well as the 440-Hz and 	 * 600-Hz tones and most of the noise and voice modulation 	 * components. 	 * 	 * Matlab IIR 4th-order IIR elliptic, 150 Hz lowpass, 0.2 dB 	 * passband ripple, -50 dB stopband ripple. 	 */
name|data
operator|=
operator|(
name|lpf
index|[
literal|4
index|]
operator|=
name|lpf
index|[
literal|3
index|]
operator|)
operator|*
literal|8.360961e-01
expr_stmt|;
name|data
operator|+=
operator|(
name|lpf
index|[
literal|3
index|]
operator|=
name|lpf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|3.481740e+00
expr_stmt|;
name|data
operator|+=
operator|(
name|lpf
index|[
literal|2
index|]
operator|=
name|lpf
index|[
literal|1
index|]
operator|)
operator|*
literal|5.452988e+00
expr_stmt|;
name|data
operator|+=
operator|(
name|lpf
index|[
literal|1
index|]
operator|=
name|lpf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|3.807229e+00
expr_stmt|;
name|lpf
index|[
literal|0
index|]
operator|=
name|isig
operator|-
name|data
expr_stmt|;
name|data
operator|=
name|lpf
index|[
literal|0
index|]
operator|*
literal|3.281435e-03
operator|+
name|lpf
index|[
literal|1
index|]
operator|*
operator|-
literal|1.149947e-02
operator|+
name|lpf
index|[
literal|2
index|]
operator|*
literal|1.654858e-02
operator|+
name|lpf
index|[
literal|3
index|]
operator|*
operator|-
literal|1.149947e-02
operator|+
name|lpf
index|[
literal|4
index|]
operator|*
literal|3.281435e-03
expr_stmt|;
comment|/* 	 * The I and Q quadrature data signals are produced by 	 * multiplying the filtered signal by 100-Hz sine and cosine 	 * signals, respectively. The data signals are demodulated by 	 * 170-ms synchronous matched filters to produce the amplitude 	 * and phase signals used by the decoder. Note the correction 	 * due to the propagation delay is necessary for seamless 	 * handover between WWV and WWVH. 	 */
name|i
operator|=
name|up
operator|->
name|datapt
operator|-
name|up
operator|->
name|pdelay
operator|%
literal|80
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|+=
literal|80
expr_stmt|;
name|up
operator|->
name|datapt
operator|=
operator|(
name|up
operator|->
name|datapt
operator|+
name|IN100
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|data
operator|/
name|DATSIZ
operator|*
name|DGAIN
expr_stmt|;
name|up
operator|->
name|irig
operator|-=
name|ibuf
index|[
name|iptr
index|]
expr_stmt|;
name|ibuf
index|[
name|iptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|up
operator|->
name|irig
operator|+=
name|dtemp
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|20
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|data
operator|/
name|DATSIZ
operator|*
name|DGAIN
expr_stmt|;
name|up
operator|->
name|qrig
operator|-=
name|qbuf
index|[
name|iptr
index|]
expr_stmt|;
name|qbuf
index|[
name|iptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|up
operator|->
name|qrig
operator|+=
name|dtemp
expr_stmt|;
name|iptr
operator|=
operator|(
name|iptr
operator|+
literal|1
operator|)
operator|%
name|DATSIZ
expr_stmt|;
comment|/* 	 * Baseband sync demodulation. The 1000/1200 sync signals are 	 * extracted using a 600-Hz IIR bandpass filter. This removes 	 * the 100-Hz data subcarrier, as well as the 440-Hz and 600-Hz 	 * tones and most of the noise and voice modulation components. 	 * 	 * Matlab 4th-order IIR elliptic, 800-1400 Hz bandpass, 0.2 dB 	 * passband ripple, -50 dB stopband ripple. 	 */
name|syncx
operator|=
operator|(
name|bpf
index|[
literal|8
index|]
operator|=
name|bpf
index|[
literal|7
index|]
operator|)
operator|*
literal|4.897278e-01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|7
index|]
operator|=
name|bpf
index|[
literal|6
index|]
operator|)
operator|*
operator|-
literal|2.765914e+00
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|6
index|]
operator|=
name|bpf
index|[
literal|5
index|]
operator|)
operator|*
literal|8.110921e+00
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|5
index|]
operator|=
name|bpf
index|[
literal|4
index|]
operator|)
operator|*
operator|-
literal|1.517732e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|4
index|]
operator|=
name|bpf
index|[
literal|3
index|]
operator|)
operator|*
literal|1.975197e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|3
index|]
operator|=
name|bpf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|1.814365e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|2
index|]
operator|=
name|bpf
index|[
literal|1
index|]
operator|)
operator|*
literal|1.159783e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|1
index|]
operator|=
name|bpf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|4.735040e+00
expr_stmt|;
name|bpf
index|[
literal|0
index|]
operator|=
name|isig
operator|-
name|syncx
expr_stmt|;
name|syncx
operator|=
name|bpf
index|[
literal|0
index|]
operator|*
literal|8.203628e-03
operator|+
name|bpf
index|[
literal|1
index|]
operator|*
operator|-
literal|2.375732e-02
operator|+
name|bpf
index|[
literal|2
index|]
operator|*
literal|3.353214e-02
operator|+
name|bpf
index|[
literal|3
index|]
operator|*
operator|-
literal|4.080258e-02
operator|+
name|bpf
index|[
literal|4
index|]
operator|*
literal|4.605479e-02
operator|+
name|bpf
index|[
literal|5
index|]
operator|*
operator|-
literal|4.080258e-02
operator|+
name|bpf
index|[
literal|6
index|]
operator|*
literal|3.353214e-02
operator|+
name|bpf
index|[
literal|7
index|]
operator|*
operator|-
literal|2.375732e-02
operator|+
name|bpf
index|[
literal|8
index|]
operator|*
literal|8.203628e-03
expr_stmt|;
comment|/* 	 * The I and Q quadrature minute sync signals are produced by 	 * multiplying the filtered signal by 1000-Hz (WWV) and 1200-Hz 	 * (WWVH) sine and cosine signals, respectively. The resulting 	 * signals are demodulated by 800-ms synchronous matched filters 	 * to synchronize the second and minute and to detect which one 	 * (or both) the WWV or WWVH signal is present. 	 */
name|up
operator|->
name|mphase
operator|=
operator|(
name|up
operator|->
name|mphase
operator|+
literal|1
operator|)
operator|%
name|MINUTE
expr_stmt|;
name|i
operator|=
name|csinptr
expr_stmt|;
name|csinptr
operator|=
operator|(
name|csinptr
operator|+
name|IN1000
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
name|SYNSIZ
operator|*
name|SGAIN
expr_stmt|;
name|ciamp
operator|=
name|ciamp
operator|-
name|cibuf
index|[
name|jptr
index|]
operator|+
name|dtemp
expr_stmt|;
name|cibuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|20
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
name|SYNSIZ
operator|*
name|SGAIN
expr_stmt|;
name|cqamp
operator|=
name|cqamp
operator|-
name|cqbuf
index|[
name|jptr
index|]
operator|+
name|dtemp
expr_stmt|;
name|cqbuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|dtemp
operator|=
name|ciamp
operator|*
name|ciamp
operator|+
name|cqamp
operator|*
name|cqamp
expr_stmt|;
name|wwv_qrz
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|schan
index|]
operator|.
name|wwv
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
name|i
operator|=
name|hsinptr
expr_stmt|;
name|hsinptr
operator|=
operator|(
name|hsinptr
operator|+
name|IN1200
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
name|SYNSIZ
operator|*
name|SGAIN
expr_stmt|;
name|hiamp
operator|=
name|hiamp
operator|-
name|hibuf
index|[
name|jptr
index|]
operator|+
name|dtemp
expr_stmt|;
name|hibuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|20
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
name|SYNSIZ
operator|*
name|SGAIN
expr_stmt|;
name|hqamp
operator|=
name|hqamp
operator|-
name|hqbuf
index|[
name|jptr
index|]
operator|+
name|dtemp
expr_stmt|;
name|hqbuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|dtemp
operator|=
name|hiamp
operator|*
name|hiamp
operator|+
name|hqamp
operator|*
name|hqamp
expr_stmt|;
name|wwv_qrz
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|schan
index|]
operator|.
name|wwvh
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
name|jptr
operator|=
operator|(
name|jptr
operator|+
literal|1
operator|)
operator|%
name|SYNSIZ
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|mphase
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This section is called once per minute at the minute 		 * epoch independently of the transmitter or receiver 		 * minute. If the leap bit is set, set the minute epoch 		 * back one second so the station processes don't miss a 		 * beat. Then, increment the watchdog counter and test 		 * for two sets of conditions depending on whether 		 * minute sync has been acquired or not. 		 */
name|up
operator|->
name|watch
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|rsec
operator|==
literal|60
condition|)
block|{
name|up
operator|->
name|mphase
operator|-=
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|mphase
operator|<
literal|0
condition|)
name|up
operator|->
name|mphase
operator|+=
name|MINUTE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
block|{
comment|/* 			 * If minute sync has not been acquired, the 			 * program listens for minute sync pulses from 			 * both WWV and WWVH. The station with the 			 * greater compare count is selected, with ties 			 * broken by WWV, but only if the count is at 			 * least three. Once a station has been 			 * acquired, it is initialized and begins 			 * tracking the signal. 			 */
if|if
condition|(
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|wwv
operator|.
name|count
operator|>=
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|wwvh
operator|.
name|count
condition|)
name|sp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|wwv
expr_stmt|;
else|else
name|sp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|wwvh
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|count
operator|>=
name|AMIN
condition|)
block|{
name|up
operator|->
name|watch
operator|=
name|up
operator|->
name|swatch
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|status
operator||=
name|MSYNC
expr_stmt|;
name|ltemp
operator|=
name|sp
operator|->
name|mepoch
operator|-
name|SYNSIZ
expr_stmt|;
if|if
condition|(
name|ltemp
operator|<
literal|0
condition|)
name|ltemp
operator|+=
name|MINUTE
expr_stmt|;
name|up
operator|->
name|rsec
operator|=
operator|(
name|MINUTE
operator|-
name|ltemp
operator|)
operator|/
name|SECOND
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SSYNC
operator|)
condition|)
block|{
name|up
operator|->
name|repoch
operator|=
name|ltemp
operator|%
name|SECOND
expr_stmt|;
name|up
operator|->
name|yepoch
operator|=
name|up
operator|->
name|repoch
operator|-
name|up
operator|->
name|pdelay
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|yepoch
operator|<
literal|0
condition|)
name|up
operator|->
name|yepoch
operator|+=
name|SECOND
expr_stmt|;
block|}
name|wwv_newchan
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|count
operator|==
literal|0
operator|||
name|up
operator|->
name|watch
operator|>=
name|ACQSN
condition|)
block|{
name|up
operator|->
name|watch
operator|=
name|sp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|schan
operator|=
operator|(
name|up
operator|->
name|schan
operator|+
literal|1
operator|)
operator|%
name|NCHAN
expr_stmt|;
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|schan
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * If minute sync has been acquired, the program 			 * watches for timeout. The timeout is reset 			 * when the clock is set or verified. If a 			 * timeout occurs and the minute units digit has 			 * not synchronized, reset the program and start 			 * over. 			 */
if|if
condition|(
name|up
operator|->
name|watch
operator|>
name|DIGIT
operator|&&
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|DSYNC
operator|)
condition|)
name|up
operator|->
name|watch
operator|=
name|up
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If the second sync times out, dim the sync 			 * lamp and raise an alarm. 			 */
name|up
operator|->
name|swatch
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|swatch
operator|>
name|HSPEC
condition|)
name|up
operator|->
name|status
operator|&=
operator|~
name|SSYNC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SSYNC
operator|)
condition|)
name|up
operator|->
name|alarm
operator||=
literal|1
operator|<<
name|SYNERR
expr_stmt|;
block|}
block|}
comment|/* 	 * The second sync pulse is extracted using 5-ms FIR matched 	 * filters at 1000 Hz for WWV or 1200 Hz for WWVH. This pulse is 	 * used for the most precise synchronization, since if provides 	 * a resolution of one sample (125 us). 	 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|SELV
condition|)
block|{
name|up
operator|->
name|pdelay
operator|=
name|up
operator|->
name|cdelay
expr_stmt|;
comment|/* 		 * WWV FIR matched filter, five cycles of 1000-Hz 		 * sinewave. 		 */
name|mf
index|[
literal|40
index|]
operator|=
name|mf
index|[
literal|39
index|]
expr_stmt|;
name|mfsync
operator|=
operator|(
name|mf
index|[
literal|39
index|]
operator|=
name|mf
index|[
literal|38
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|38
index|]
operator|=
name|mf
index|[
literal|37
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|37
index|]
operator|=
name|mf
index|[
literal|36
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|36
index|]
operator|=
name|mf
index|[
literal|35
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|35
index|]
operator|=
name|mf
index|[
literal|34
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|34
index|]
operator|=
name|mf
index|[
literal|33
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|33
index|]
operator|=
name|mf
index|[
literal|32
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|32
index|]
operator|=
name|mf
index|[
literal|31
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|31
index|]
operator|=
name|mf
index|[
literal|30
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|30
index|]
operator|=
name|mf
index|[
literal|29
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|29
index|]
operator|=
name|mf
index|[
literal|28
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|28
index|]
operator|=
name|mf
index|[
literal|27
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|27
index|]
operator|=
name|mf
index|[
literal|26
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|26
index|]
operator|=
name|mf
index|[
literal|25
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|25
index|]
operator|=
name|mf
index|[
literal|24
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|24
index|]
operator|=
name|mf
index|[
literal|23
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|23
index|]
operator|=
name|mf
index|[
literal|22
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|22
index|]
operator|=
name|mf
index|[
literal|21
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|21
index|]
operator|=
name|mf
index|[
literal|20
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|20
index|]
operator|=
name|mf
index|[
literal|19
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|19
index|]
operator|=
name|mf
index|[
literal|18
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|18
index|]
operator|=
name|mf
index|[
literal|17
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|17
index|]
operator|=
name|mf
index|[
literal|16
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|16
index|]
operator|=
name|mf
index|[
literal|15
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|15
index|]
operator|=
name|mf
index|[
literal|14
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|14
index|]
operator|=
name|mf
index|[
literal|13
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|13
index|]
operator|=
name|mf
index|[
literal|12
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|12
index|]
operator|=
name|mf
index|[
literal|11
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|11
index|]
operator|=
name|mf
index|[
literal|10
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|10
index|]
operator|=
name|mf
index|[
literal|9
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|9
index|]
operator|=
name|mf
index|[
literal|8
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|8
index|]
operator|=
name|mf
index|[
literal|7
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|7
index|]
operator|=
name|mf
index|[
literal|6
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|6
index|]
operator|=
name|mf
index|[
literal|5
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|5
index|]
operator|=
name|mf
index|[
literal|4
index|]
operator|)
operator|*
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|4
index|]
operator|=
name|mf
index|[
literal|3
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|3
index|]
operator|=
name|mf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|2
index|]
operator|=
name|mf
index|[
literal|1
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|1
index|]
operator|=
name|mf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|4.224514e-02
expr_stmt|;
name|mf
index|[
literal|0
index|]
operator|=
name|syncx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|SELH
condition|)
block|{
name|up
operator|->
name|pdelay
operator|=
name|up
operator|->
name|hdelay
expr_stmt|;
comment|/* 		 * WWVH FIR matched filter, six cycles of 1200-Hz 		 * sinewave. 		 */
name|mf
index|[
literal|40
index|]
operator|=
name|mf
index|[
literal|39
index|]
expr_stmt|;
name|mfsync
operator|=
operator|(
name|mf
index|[
literal|39
index|]
operator|=
name|mf
index|[
literal|38
index|]
operator|)
operator|*
literal|4.833363e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|38
index|]
operator|=
name|mf
index|[
literal|37
index|]
operator|)
operator|*
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|37
index|]
operator|=
name|mf
index|[
literal|36
index|]
operator|)
operator|*
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|36
index|]
operator|=
name|mf
index|[
literal|35
index|]
operator|)
operator|*
operator|-
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|35
index|]
operator|=
name|mf
index|[
literal|34
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|34
index|]
operator|=
name|mf
index|[
literal|33
index|]
operator|)
operator|*
operator|-
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|33
index|]
operator|=
name|mf
index|[
literal|32
index|]
operator|)
operator|*
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|32
index|]
operator|=
name|mf
index|[
literal|31
index|]
operator|)
operator|*
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|31
index|]
operator|=
name|mf
index|[
literal|30
index|]
operator|)
operator|*
literal|4.833363e-02
expr_stmt|;
name|mf
index|[
literal|30
index|]
operator|=
name|mf
index|[
literal|29
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|29
index|]
operator|=
name|mf
index|[
literal|28
index|]
operator|)
operator|*
operator|-
literal|4.833363e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|28
index|]
operator|=
name|mf
index|[
literal|27
index|]
operator|)
operator|*
operator|-
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|27
index|]
operator|=
name|mf
index|[
literal|26
index|]
operator|)
operator|*
operator|-
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|26
index|]
operator|=
name|mf
index|[
literal|25
index|]
operator|)
operator|*
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|25
index|]
operator|=
name|mf
index|[
literal|24
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|24
index|]
operator|=
name|mf
index|[
literal|23
index|]
operator|)
operator|*
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|23
index|]
operator|=
name|mf
index|[
literal|22
index|]
operator|)
operator|*
operator|-
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|22
index|]
operator|=
name|mf
index|[
literal|21
index|]
operator|)
operator|*
operator|-
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|21
index|]
operator|=
name|mf
index|[
literal|20
index|]
operator|)
operator|*
operator|-
literal|4.833363e-02
expr_stmt|;
name|mf
index|[
literal|20
index|]
operator|=
name|mf
index|[
literal|19
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|19
index|]
operator|=
name|mf
index|[
literal|18
index|]
operator|)
operator|*
literal|4.833363e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|18
index|]
operator|=
name|mf
index|[
literal|17
index|]
operator|)
operator|*
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|17
index|]
operator|=
name|mf
index|[
literal|16
index|]
operator|)
operator|*
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|16
index|]
operator|=
name|mf
index|[
literal|15
index|]
operator|)
operator|*
operator|-
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|15
index|]
operator|=
name|mf
index|[
literal|14
index|]
operator|)
operator|*
operator|-
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|14
index|]
operator|=
name|mf
index|[
literal|13
index|]
operator|)
operator|*
operator|-
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|13
index|]
operator|=
name|mf
index|[
literal|12
index|]
operator|)
operator|*
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|12
index|]
operator|=
name|mf
index|[
literal|11
index|]
operator|)
operator|*
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|11
index|]
operator|=
name|mf
index|[
literal|10
index|]
operator|)
operator|*
literal|4.833363e-02
expr_stmt|;
name|mf
index|[
literal|10
index|]
operator|=
name|mf
index|[
literal|9
index|]
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|9
index|]
operator|=
name|mf
index|[
literal|8
index|]
operator|)
operator|*
operator|-
literal|4.833363e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|8
index|]
operator|=
name|mf
index|[
literal|7
index|]
operator|)
operator|*
operator|-
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|7
index|]
operator|=
name|mf
index|[
literal|6
index|]
operator|)
operator|*
operator|-
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|6
index|]
operator|=
name|mf
index|[
literal|5
index|]
operator|)
operator|*
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|5
index|]
operator|=
name|mf
index|[
literal|4
index|]
operator|)
operator|*
literal|5.974365e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|4
index|]
operator|=
name|mf
index|[
literal|3
index|]
operator|)
operator|*
literal|3.511644e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|3
index|]
operator|=
name|mf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|1.846180e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|2
index|]
operator|=
name|mf
index|[
literal|1
index|]
operator|)
operator|*
operator|-
literal|5.681959e-02
expr_stmt|;
name|mfsync
operator|+=
operator|(
name|mf
index|[
literal|1
index|]
operator|=
name|mf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|4.833363e-02
expr_stmt|;
name|mf
index|[
literal|0
index|]
operator|=
name|syncx
expr_stmt|;
block|}
else|else
block|{
name|mfsync
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Extract the seconds sync pulse using a 1-s comb filter at 	 * baseband. Correct for the FIR matched filter delay, which is 	 * 5 ms for both the WWV and WWVH filters. Blank the signal when 	 * probing. 	 */
name|up
operator|->
name|epoch
operator|=
operator|(
name|up
operator|->
name|epoch
operator|+
literal|1
operator|)
operator|%
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|epoch
operator|==
literal|0
condition|)
block|{
name|wwv_endpoc
argument_list|(
name|peer
argument_list|,
name|epomax
argument_list|,
name|epopos
argument_list|)
expr_stmt|;
name|up
operator|->
name|epomax
operator|=
name|epomax
expr_stmt|;
name|epomax
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
name|wwv_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|dtemp
operator|=
operator|(
name|epobuf
index|[
name|up
operator|->
name|epoch
index|]
operator|+=
operator|(
name|mfsync
operator|-
name|epobuf
index|[
name|up
operator|->
name|epoch
index|]
operator|)
operator|/
operator|(
name|MINAVG
operator|<<
name|up
operator|->
name|avgint
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
name|epomax
condition|)
block|{
name|epomax
operator|=
name|dtemp
expr_stmt|;
name|epopos
operator|=
name|up
operator|->
name|epoch
operator|-
name|up
operator|->
name|pdelay
operator|-
literal|5
operator|*
name|MS
expr_stmt|;
if|if
condition|(
name|epopos
operator|<
literal|0
condition|)
name|epopos
operator|+=
name|SECOND
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|MSYNC
condition|)
name|wwv_epoch
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_qrz - identify and acquire WWV/WWVH minute sync pulse  *  * This routine implements a virtual station process used to acquire  * minute sync and to mitigate among the ten frequency and station  * combinations. During minute sync acquisition, the process probes each  * frequency in turn for the minute pulse from either station, which  * involves searching through the entire epoch minute of samples. After  * minute sync acquisition, the process searches only during the probe  * window, which occupies seconds 59, 0 and 1, to construct a metric  * used to determine which frequency and station provides the best  * signal.  *  * The pulse discriminator requires that (a) the peak on-pulse sample  * amplitude must be above 2000, (b) the SNR relative to the peak  * off-pulse sample amplitude must be reduced 6 dB or more below the  * peak and (c) the maximum difference between the current and previous  * epoch indices must be less than 50 ms. A compare counter keeps track  * of the number of successive intervals which satisfy these criteria.  *  * Students of radar receiver technology will discover this algorithm  * amounts to a range gate discriminator. In practice, the performance  * of this gadget is amazing. Once setting teeth in a station, it hangs  * on until the minute beep can barely be heard and long after the  * second tick and comb filter have given up.   */
end_comment

begin_function
specifier|static
name|void
name|wwv_qrz
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peerstructure pointer */
name|struct
name|sync
modifier|*
name|sp
parameter_list|,
comment|/* sync channel structure */
name|double
name|syncx
comment|/* bandpass filtered sync signal */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* monitor buffer */
name|double
name|snr
decl_stmt|;
comment|/* on-pulse/off-pulse ratio (dB) */
name|long
name|epoch
decl_stmt|;
name|int
name|isgood
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Find the sample with peak energy, which defines the minute 	 * epoch. If minute sync has been acquired, search only the 	 * probe window; otherwise, search the entire minute. If a 	 * maximum has been found with good amplitude, search only the 	 * second before and after that position for the next maximum 	 * and the rest of the window for the noise. 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
operator|||
name|up
operator|->
name|status
operator|&
name|SFLAG
condition|)
block|{
name|sp
operator|->
name|amp
operator|=
name|syncx
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|MSYNC
condition|)
name|epoch
operator|=
name|up
operator|->
name|nepoch
expr_stmt|;
elseif|else
if|if
condition|(
name|sp
operator|->
name|count
operator|>
literal|1
condition|)
name|epoch
operator|=
name|sp
operator|->
name|mepoch
expr_stmt|;
else|else
name|epoch
operator|=
name|sp
operator|->
name|lastpos
expr_stmt|;
if|if
condition|(
name|syncx
operator|>
name|sp
operator|->
name|sigmax
condition|)
block|{
name|sp
operator|->
name|sigmax
operator|=
name|syncx
expr_stmt|;
name|sp
operator|->
name|pos
operator|=
name|up
operator|->
name|mphase
expr_stmt|;
block|}
if|if
condition|(
name|abs
argument_list|(
name|MOD
argument_list|(
name|up
operator|->
name|mphase
operator|-
name|epoch
argument_list|,
name|MINUTE
argument_list|)
argument_list|)
operator|>
name|SYNSIZ
operator|&&
name|syncx
operator|>
name|sp
operator|->
name|noise
condition|)
block|{
name|sp
operator|->
name|noise
operator|=
name|syncx
expr_stmt|;
block|}
block|}
if|if
condition|(
name|up
operator|->
name|mphase
operator|==
literal|0
condition|)
block|{
comment|/* 		 * At the end of the minute, determine the epoch of the 		 * sync pulse, as well as the SNR and difference between 		 * the current and previous epoch (jitter). 		 */
name|sp
operator|->
name|jitter
operator|=
name|MOD
argument_list|(
name|sp
operator|->
name|pos
operator|-
name|sp
operator|->
name|lastpos
argument_list|,
name|MINUTE
argument_list|)
expr_stmt|;
name|sp
operator|->
name|select
operator|&=
operator|~
name|JITRNG
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|sp
operator|->
name|jitter
argument_list|)
operator|>
name|AWND
operator|*
name|MS
condition|)
name|sp
operator|->
name|select
operator||=
name|JITRNG
expr_stmt|;
name|sp
operator|->
name|sigmax
operator|=
name|sqrt
argument_list|(
name|sp
operator|->
name|sigmax
argument_list|)
expr_stmt|;
name|sp
operator|->
name|noise
operator|=
name|sqrt
argument_list|(
name|sp
operator|->
name|noise
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|MSYNC
condition|)
block|{
comment|/* 			 * If in minute sync, just count the runs up and 			 * down. 			 */
if|if
condition|(
name|sp
operator|->
name|select
operator|&
operator|(
name|DATANG
operator||
name|SYNCNG
operator||
name|JITRNG
operator|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|count
operator|>
literal|0
condition|)
name|sp
operator|->
name|count
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|count
operator|<
name|AMAX
condition|)
name|sp
operator|->
name|count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * If not yet in minute sync, we have to do a 			 * little dance to find a valid minute sync 			 * pulse, emphasis valid. 			 */
name|snr
operator|=
name|wwv_snr
argument_list|(
name|sp
operator|->
name|sigmax
argument_list|,
name|sp
operator|->
name|noise
argument_list|)
expr_stmt|;
name|isgood
operator|=
name|sp
operator|->
name|sigmax
operator|>
name|ATHR
operator|&&
name|snr
operator|>
name|ASNR
operator|&&
operator|!
operator|(
name|sp
operator|->
name|select
operator|&
name|JITRNG
operator|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|count
condition|)
block|{
comment|/* 			 * In state 0 the station was not heard during 			 * the previous probe. Look for the biggest blip 			 * greater than the amplitude threshold in the 			 * minute and assume that the minute sync pulse. 			 * If found, bump to state 1. 			 */
case|case
literal|0
case|:
if|if
condition|(
name|sp
operator|->
name|sigmax
operator|>=
name|ATHR
condition|)
name|sp
operator|->
name|count
operator|++
expr_stmt|;
break|break;
comment|/* 			 * In state 1 a candidate blip has been found 			 * and the next minute has been searched for 			 * another blip. If none are found greater than 			 * the threshold, or if the biggest blip outside 			 * the candidate pulse is less than 6 dB below 			 * the biggest blip, drop back to state 0 and 			 * hunt some more. Otherwise, a legitimate 			 * minute pulse may have been found, so bump to 			 * state 2. 			 */
case|case
literal|1
case|:
if|if
condition|(
name|sp
operator|->
name|sigmax
operator|<
name|ATHR
condition|)
block|{
name|sp
operator|->
name|count
operator|--
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|isgood
condition|)
block|{
break|break;
block|}
comment|/* fall through */
comment|/* 			 * In states 2 and above, continue to groom 			 * samples as before and drop back to the 			 * previous state if the groom fails. If it 			 * succeeds, bump to the next state until 			 * reaching the clamp, if ever. 			 */
default|default:
if|if
condition|(
operator|!
name|isgood
condition|)
block|{
name|sp
operator|->
name|count
operator|--
expr_stmt|;
break|break;
block|}
name|sp
operator|->
name|mepoch
operator|=
name|sp
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|count
operator|<
name|AMAX
condition|)
name|sp
operator|->
name|count
operator|++
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv8 %d %3d %-3s %d %5.0f %5.1f %7ld %7ld %7ld"
argument_list|,
name|up
operator|->
name|port
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|sp
operator|->
name|ident
argument_list|,
name|sp
operator|->
name|count
argument_list|,
name|sp
operator|->
name|sigmax
argument_list|,
name|snr
argument_list|,
name|sp
operator|->
name|pos
argument_list|,
name|sp
operator|->
name|jitter
argument_list|,
name|MOD
argument_list|(
name|sp
operator|->
name|pos
operator|-
name|up
operator|->
name|nepoch
operator|-
name|SYNSIZ
argument_list|,
name|MINUTE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sp
operator|->
name|lastmax
operator|=
name|sp
operator|->
name|sigmax
expr_stmt|;
name|sp
operator|->
name|lastpos
operator|=
name|sp
operator|->
name|pos
expr_stmt|;
name|sp
operator|->
name|sigmax
operator|=
name|sp
operator|->
name|noise
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_endpoc - process receiver epoch  *  * This routine is called at the end of the receiver epoch. It  * determines the epoch position within the second and disciplines the  * sample clock using a frequency-lock loop (FLL).  *  * Seconds sync is determined in the RF input routine as the maximum  * over all 8000 samples in the second comb filter. To assure accurate  * and reliable time and frequency discipline, this routine performs a  * great deal of heavy-handed data filtering and grooming.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_endpoc
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|epomax
parameter_list|,
comment|/* epoch max */
name|int
name|epopos
comment|/* epoch max position */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
specifier|static
name|int
name|epoch_mf
index|[
literal|3
index|]
decl_stmt|;
comment|/* epoch median filter */
specifier|static
name|int
name|tepoch
decl_stmt|;
comment|/* median filter epoch */
specifier|static
name|int
name|tspan
decl_stmt|;
comment|/* median filter span */
specifier|static
name|int
name|xepoch
decl_stmt|;
comment|/* last second epoch */
specifier|static
name|int
name|zepoch
decl_stmt|;
comment|/* last averaging interval epoch */
specifier|static
name|int
name|syncnt
decl_stmt|;
comment|/* second epoch run length counter */
specifier|static
name|int
name|jitcnt
decl_stmt|;
comment|/* jitter holdoff counter */
specifier|static
name|int
name|avgcnt
decl_stmt|;
comment|/* averaging interval counter */
specifier|static
name|int
name|avginc
decl_stmt|;
comment|/* averaging ratchet */
specifier|static
name|int
name|iniflg
decl_stmt|;
comment|/* initialization flag */
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* monitor buffer */
name|double
name|dtemp
decl_stmt|;
name|int
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
name|iniflg
condition|)
block|{
name|iniflg
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|epoch_mf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|epoch_mf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * A three-stage median filter is used to help denoise the 	 * seconds sync pulse. The median sample becomes the candidate 	 * epoch; the difference between the other two samples becomes 	 * the span, which is used currently only for debugging. 	 */
name|epoch_mf
index|[
literal|2
index|]
operator|=
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
name|epoch_mf
index|[
literal|1
index|]
operator|=
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
name|epoch_mf
index|[
literal|0
index|]
operator|=
name|epopos
expr_stmt|;
if|if
condition|(
name|epoch_mf
index|[
literal|0
index|]
operator|>
name|epoch_mf
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|epoch_mf
index|[
literal|1
index|]
operator|>
name|epoch_mf
index|[
literal|2
index|]
condition|)
block|{
name|tepoch
operator|=
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
comment|/* 0 1 2 */
name|tspan
operator|=
name|epoch_mf
index|[
literal|0
index|]
operator|-
name|epoch_mf
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|epoch_mf
index|[
literal|2
index|]
operator|>
name|epoch_mf
index|[
literal|0
index|]
condition|)
block|{
name|tepoch
operator|=
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
comment|/* 2 0 1 */
name|tspan
operator|=
name|epoch_mf
index|[
literal|2
index|]
operator|-
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|tepoch
operator|=
name|epoch_mf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 0 2 1 */
name|tspan
operator|=
name|epoch_mf
index|[
literal|0
index|]
operator|-
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|epoch_mf
index|[
literal|1
index|]
operator|<
name|epoch_mf
index|[
literal|2
index|]
condition|)
block|{
name|tepoch
operator|=
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
comment|/* 2 1 0 */
name|tspan
operator|=
name|epoch_mf
index|[
literal|2
index|]
operator|-
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|epoch_mf
index|[
literal|2
index|]
operator|<
name|epoch_mf
index|[
literal|0
index|]
condition|)
block|{
name|tepoch
operator|=
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
comment|/* 1 0 2 */
name|tspan
operator|=
name|epoch_mf
index|[
literal|1
index|]
operator|-
name|epoch_mf
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|tepoch
operator|=
name|epoch_mf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 1 2 0 */
name|tspan
operator|=
name|epoch_mf
index|[
literal|1
index|]
operator|-
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
comment|/* 	 * If the epoch candidate is within 1 ms of the last one, the 	 * new candidate replaces the last one and the jitter counter is 	 * reset; otherwise, the candidate is ignored and the jitter 	 * counter is incremented. If the jitter counter exceeds the 	 * frequency averaging interval, the new candidate replaces the 	 * old one anyway. The compare counter is incremented if the new 	 * candidate is identical to the last one; otherwise, it is 	 * forced to zero. If the compare counter increments to 10, the 	 * epoch is reset and the receiver second epoch is set. 	 * 	 * Careful attention to detail here. If the signal amplitude 	 * falls below the threshold or if no stations are heard, we 	 * certainly cannot be in sync. 	 */
name|tmp2
operator|=
name|MOD
argument_list|(
name|tepoch
operator|-
name|xepoch
argument_list|,
name|SECOND
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|epomax
operator|<
name|STHR
operator|||
operator|!
operator|(
name|up
operator|->
name|status
operator|&
operator|(
name|SELV
operator||
name|SELH
operator|)
operator|)
condition|)
block|{
name|up
operator|->
name|status
operator|&=
operator|~
name|SSYNC
expr_stmt|;
name|jitcnt
operator|=
name|syncnt
operator|=
name|avgcnt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abs
argument_list|(
name|tmp2
argument_list|)
operator|<=
name|MS
operator|||
name|jitcnt
operator|>=
operator|(
name|MINAVG
operator|<<
name|up
operator|->
name|avgint
operator|)
condition|)
block|{
name|jitcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp2
operator|!=
literal|0
condition|)
block|{
name|xepoch
operator|=
name|tepoch
expr_stmt|;
name|syncnt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|syncnt
operator|<
name|SCMP
condition|)
block|{
name|syncnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|status
operator||=
name|SSYNC
expr_stmt|;
name|up
operator|->
name|swatch
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|repoch
operator|=
name|tepoch
expr_stmt|;
name|up
operator|->
name|yepoch
operator|=
name|up
operator|->
name|repoch
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|yepoch
operator|<
literal|0
condition|)
name|up
operator|->
name|yepoch
operator|+=
name|SECOND
expr_stmt|;
block|}
block|}
name|avgcnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|jitcnt
operator|++
expr_stmt|;
name|syncnt
operator|=
name|avgcnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SSYNC
operator|)
operator|&&
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv1 %2d %04x %5.0f %2d %5.0f %5d %5d %5d %2d %4d"
argument_list|,
name|up
operator|->
name|rsec
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|avgcnt
argument_list|,
name|epomax
argument_list|,
name|tepoch
argument_list|,
name|tspan
argument_list|,
name|tmp2
argument_list|,
name|syncnt
argument_list|,
name|jitcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
comment|/* 	 * The sample clock frequency is disciplined using a first-order 	 * feedback loop with time constant consistent with the Allan 	 * intercept of typical computer clocks. The loop update is 	 * calculated each averaging interval from the epoch change in 	 * 125-us units and interval length in seconds. The interval is 	 * doubled after four intervals where epoch change is not more 	 * than one sample. 	 * 	 * The averaging interval affects other receiver functions, 	 * including the the 1000/1200-Hz comb filter and sample clock 	 * loop. It also affects the 100-Hz subcarrier loop and the bit 	 * and digit comparison counter thresholds. 	 */
name|tmp3
operator|=
name|MOD
argument_list|(
name|tepoch
operator|-
name|zepoch
argument_list|,
name|SECOND
argument_list|)
expr_stmt|;
if|if
condition|(
name|avgcnt
operator|>=
operator|(
name|MINAVG
operator|<<
name|up
operator|->
name|avgint
operator|)
condition|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|tmp3
argument_list|)
operator|<
name|MS
condition|)
block|{
name|dtemp
operator|=
operator|(
name|double
operator|)
name|tmp3
operator|/
name|avgcnt
expr_stmt|;
name|up
operator|->
name|freq
operator|+=
name|dtemp
operator|/
name|SYNCTC
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|freq
operator|>
name|MAXFREQ
condition|)
name|up
operator|->
name|freq
operator|=
name|MAXFREQ
expr_stmt|;
elseif|else
if|if
condition|(
name|up
operator|->
name|freq
operator|<
operator|-
name|MAXFREQ
condition|)
name|up
operator|->
name|freq
operator|=
operator|-
name|MAXFREQ
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|tmp3
argument_list|)
operator|<=
literal|1
operator|&&
name|up
operator|->
name|avgint
operator|<
name|MAXAVG
condition|)
block|{
if|if
condition|(
name|avginc
operator|<
literal|4
condition|)
block|{
name|avginc
operator|++
expr_stmt|;
block|}
else|else
block|{
name|avginc
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|avgint
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|up
operator|->
name|avgint
operator|<
name|MAXAVG
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv2 %2d %04x %5.0f %5d %5d %2d %2d %6.1f %6.1f"
argument_list|,
name|up
operator|->
name|rsec
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|MINAVG
operator|<<
name|up
operator|->
name|avgint
argument_list|,
name|avgcnt
argument_list|,
name|avginc
argument_list|,
name|tmp3
argument_list|,
name|dtemp
operator|/
name|SECOND
operator|*
literal|1e6
argument_list|,
name|up
operator|->
name|freq
operator|/
name|SECOND
operator|*
literal|1e6
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
name|zepoch
operator|=
name|tepoch
expr_stmt|;
name|avgcnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_epoch -  main loop  *  * This routine establishes receiver and transmitter epoch  * synchronization and determines the data subcarrier pulse length.  * Receiver synchronization is determined by the minute sync pulse  * detected in the wwv_rf() routine and the second sync pulse detected  * in the wwv_epoch() routine. This establishes when to sample the data  * subcarrier in-phase signal for the maximum level and noise level and  * when to determine the pulse length. The transmitter second leads the  * receiver second by the propagation delay, receiver delay and filter  * delay of this program. It establishes the clock time and implements  * the sometimes idiosyncratic conventional clock time and civil  * calendar.   *  * Most communications radios use a highpass filter in the audio stages,  * which can do nasty things to the subcarrier phase relative to the  * sync pulses. Therefore, the data subcarrier reference phase is  * disciplined using the hardlimited quadrature-phase signal sampled at  * the same time as the in-phase signal. The phase tracking loop uses  * phase adjustments of plus-minus one sample (125 us).  */
end_comment

begin_function
specifier|static
name|void
name|wwv_epoch
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
specifier|static
name|double
name|dpulse
decl_stmt|;
comment|/* data pulse length */
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
name|struct
name|sync
modifier|*
name|sp
decl_stmt|;
name|l_fp
name|offset
decl_stmt|;
comment|/* NTP format offset */
name|double
name|dtemp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Sample the minute sync pulse amplitude at epoch 800 for both 	 * the WWV and WWVH stations. This will be used later for 	 * channel mitigation. 	 */
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|rphase
operator|==
literal|800
operator|*
name|MS
condition|)
block|{
name|sp
operator|=
operator|&
name|cp
operator|->
name|wwv
expr_stmt|;
name|sp
operator|->
name|synamp
operator|=
name|sqrt
argument_list|(
name|sp
operator|->
name|amp
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|&
name|cp
operator|->
name|wwvh
expr_stmt|;
name|sp
operator|->
name|synamp
operator|=
name|sqrt
argument_list|(
name|sp
operator|->
name|amp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|rsec
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|sigamp
operator|=
name|up
operator|->
name|datsnr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Estimate the noise level by integrating the I-channel 		 * energy at epoch 30 ms. 		 */
if|if
condition|(
name|up
operator|->
name|rphase
operator|==
literal|30
operator|*
name|MS
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SFLAG
operator|)
condition|)
name|up
operator|->
name|noiamp
operator|+=
operator|(
name|up
operator|->
name|irig
operator|-
name|up
operator|->
name|noiamp
operator|)
operator|/
operator|(
name|MINAVG
operator|<<
name|up
operator|->
name|avgint
operator|)
expr_stmt|;
else|else
name|cp
operator|->
name|noiamp
operator|+=
operator|(
name|sqrt
argument_list|(
name|up
operator|->
name|irig
operator|*
name|up
operator|->
name|irig
operator|+
name|up
operator|->
name|qrig
operator|*
name|up
operator|->
name|qrig
argument_list|)
operator|-
name|cp
operator|->
name|noiamp
operator|)
operator|/
literal|8
expr_stmt|;
comment|/* 		 * Strobe the peak I-channel data signal at epoch 200 		 * ms. Compute the SNR and adjust the 100-Hz reference 		 * oscillator phase using the Q-channel data signal at 		 * that epoch. Save the envelope amplitude for the probe 		 * channel. 		 */
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|rphase
operator|==
literal|200
operator|*
name|MS
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SFLAG
operator|)
condition|)
block|{
name|up
operator|->
name|sigamp
operator|=
name|up
operator|->
name|irig
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|sigamp
operator|<
literal|0
condition|)
name|up
operator|->
name|sigamp
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|datsnr
operator|=
name|wwv_snr
argument_list|(
name|up
operator|->
name|sigamp
argument_list|,
name|up
operator|->
name|noiamp
argument_list|)
expr_stmt|;
name|up
operator|->
name|datpha
operator|=
name|up
operator|->
name|qrig
operator|/
operator|(
name|MINAVG
operator|<<
name|up
operator|->
name|avgint
operator|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|datpha
operator|>=
literal|0
condition|)
block|{
name|up
operator|->
name|datapt
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|datapt
operator|>=
literal|80
condition|)
name|up
operator|->
name|datapt
operator|-=
literal|80
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|datapt
operator|--
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|datapt
operator|<
literal|0
condition|)
name|up
operator|->
name|datapt
operator|+=
literal|80
expr_stmt|;
block|}
block|}
else|else
block|{
name|up
operator|->
name|sigamp
operator|=
name|sqrt
argument_list|(
name|up
operator|->
name|irig
operator|*
name|up
operator|->
name|irig
operator|+
name|up
operator|->
name|qrig
operator|*
name|up
operator|->
name|qrig
argument_list|)
expr_stmt|;
name|up
operator|->
name|datsnr
operator|=
name|wwv_snr
argument_list|(
name|up
operator|->
name|sigamp
argument_list|,
name|cp
operator|->
name|noiamp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The slice level is set half way between the peak 		 * signal and noise levels. Strobe the negative zero 		 * crossing after epoch 200 ms and record the epoch at 		 * that time. This defines the length of the data pulse, 		 * which will later be converted into scaled bit 		 * probabilities. 		 */
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|rphase
operator|>
literal|200
operator|*
name|MS
condition|)
block|{
name|dtemp
operator|=
operator|(
name|up
operator|->
name|sigamp
operator|+
name|up
operator|->
name|noiamp
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|irig
operator|<
name|dtemp
operator|&&
name|dpulse
operator|==
literal|0
condition|)
name|dpulse
operator|=
name|up
operator|->
name|rphase
expr_stmt|;
block|}
block|}
comment|/* 	 * At the end of the transmitter second, crank the clock state 	 * machine. Note we have to be careful to set the transmitter 	 * epoch at the same time as the receiver epoch to be sure the 	 * right propagation delay is used. We don't bother the heavy 	 * machinery unless the clock is set. 	 */
name|up
operator|->
name|tphase
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|epoch
operator|==
name|up
operator|->
name|yepoch
condition|)
block|{
name|wwv_tsec
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|->
name|tphase
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Determine the current offset from the time of century 		 * and the sample timestamp, but only if the SYNERR 		 * alarm has not been raised in the present or previous 		 * minute. 		 */
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SFLAG
operator|)
operator|&&
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|&&
operator|(
name|up
operator|->
name|alarm
operator|&
operator|(
literal|3
operator|<<
name|SYNERR
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pp
operator|->
name|second
operator|=
name|up
operator|->
name|tsec
expr_stmt|;
name|pp
operator|->
name|minute
operator|=
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|pp
operator|->
name|hour
operator|=
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|pp
operator|->
name|day
operator|=
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|digit
operator|*
literal|100
expr_stmt|;
name|pp
operator|->
name|year
operator|=
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|year
operator|<
name|UTCYEAR
condition|)
name|pp
operator|->
name|year
operator|+=
literal|2000
expr_stmt|;
else|else
name|pp
operator|->
name|year
operator|+=
literal|1900
expr_stmt|;
comment|/* 			 * We have to simulate refclock_process() here, 			 * since the fudgetime gets added much earlier 			 * than this. 			 */
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|GMT
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|&
name|offset
operator|.
name|l_ui
argument_list|)
condition|)
name|up
operator|->
name|errflg
operator|=
name|CEVNT_BADTIME
expr_stmt|;
else|else
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|offset
argument_list|,
name|pp
operator|->
name|lastrec
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * At the end of the receiver second, process the data bit and 	 * update the decoding matrix probabilities. 	 */
name|up
operator|->
name|rphase
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|epoch
operator|==
name|up
operator|->
name|repoch
condition|)
block|{
name|wwv_rsec
argument_list|(
name|peer
argument_list|,
name|dpulse
argument_list|)
expr_stmt|;
name|wwv_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|rphase
operator|=
name|dpulse
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_rsec - process receiver second  *  * This routine is called at the end of each receiver second to  * implement the per-second state machine. The machine assembles BCD  * digit bits, decodes miscellaneous bits and dances the leap seconds.  *  * Normally, the minute has 60 seconds numbered 0-59. If the leap  * warning bit is set, the last minute (1439) of 30 June (day 181 or 182  * for leap years) or 31 December (day 365 or 366 for leap years) is  * augmented by one second numbered 60. This is accomplished by  * extending the minute interval by one second and teaching the state  * machine to ignore it. BTW, stations WWV/WWVH cowardly kill the  * transmitter carrier for a few seconds around the leap to avoid icky  * details of transmission format during the leap.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_rsec
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|dpulse
parameter_list|)
block|{
specifier|static
name|int
name|iniflg
decl_stmt|;
comment|/* initialization flag */
specifier|static
name|double
name|bcddld
index|[
literal|4
index|]
decl_stmt|;
comment|/* BCD data bits */
specifier|static
name|double
name|bitvec
index|[
literal|61
index|]
decl_stmt|;
comment|/* bit integrator for misc bits */
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
name|struct
name|sync
modifier|*
name|sp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|double
name|bit
decl_stmt|;
comment|/* bit likelihood */
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* monitor buffer */
name|int
name|sw
decl_stmt|,
name|arg
decl_stmt|,
name|nsec
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
name|iniflg
condition|)
block|{
name|iniflg
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bitvec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bitvec
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The bit represents the probability of a hit on zero (negative 	 * values), a hit on one (positive values) or a miss (zero 	 * value). The likelihood vector is the exponential average of 	 * these probabilities. Only the bits of this vector 	 * corresponding to the miscellaneous bits of the timecode are 	 * used, but it's easier to do them all. After that, crank the 	 * seconds state machine. 	 */
name|nsec
operator|=
name|up
operator|->
name|rsec
operator|+
literal|1
expr_stmt|;
name|bit
operator|=
name|wwv_data
argument_list|(
name|up
argument_list|,
name|dpulse
argument_list|)
expr_stmt|;
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|+=
operator|(
name|bit
operator|-
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|)
operator|/
name|TCONST
expr_stmt|;
name|sw
operator|=
name|progx
index|[
name|up
operator|->
name|rsec
index|]
operator|.
name|sw
expr_stmt|;
name|arg
operator|=
name|progx
index|[
name|up
operator|->
name|rsec
index|]
operator|.
name|arg
expr_stmt|;
switch|switch
condition|(
name|sw
condition|)
block|{
comment|/* 	 * Ignore this second. 	 */
case|case
name|IDLE
case|:
comment|/* 9, 45-49 */
break|break;
comment|/* 	 * Probe channel stuff 	 * 	 * The WWV/H format contains data pulses in second 59 (position 	 * identifier) and second 1 (not used), and the minute sync 	 * pulse in second 0. At the end of second 58, we QSYed to the 	 * probe channel, which rotates over all WWV/H frequencies. At 	 * the end of second 59, we latched the sync noise and tested 	 * for data bit error. At the end of second 0, we now latch the 	 * sync peak. 	 */
case|case
name|SYNC2
case|:
comment|/* 0 */
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
name|sp
operator|=
operator|&
name|cp
operator|->
name|wwv
expr_stmt|;
name|sp
operator|->
name|synmax
operator|=
name|sp
operator|->
name|synamp
expr_stmt|;
name|sp
operator|=
operator|&
name|cp
operator|->
name|wwvh
expr_stmt|;
name|sp
operator|->
name|synmax
operator|=
name|sp
operator|->
name|synamp
expr_stmt|;
break|break;
comment|/* 	 * At the end of second 1, latch and average the sync noise and 	 * test for data bit error. Set SYNCNG if the sync pulse 	 * amplitude and SNR are not above thresholds. Set DATANG if 	 * data error occured on both second 59 and second 1. Finally, 	 * QSY back to the data channel. 	 */
case|case
name|SYNC3
case|:
comment|/* 1 */
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|sigamp
operator|<
name|DTHR
operator|||
name|up
operator|->
name|datsnr
operator|<
name|DSNR
condition|)
name|cp
operator|->
name|errcnt
operator|++
expr_stmt|;
name|sp
operator|=
operator|&
name|cp
operator|->
name|wwv
expr_stmt|;
name|sp
operator|->
name|synmin
operator|=
operator|(
name|sp
operator|->
name|synmin
operator|+
name|sp
operator|->
name|synamp
operator|)
operator|/
literal|2
expr_stmt|;
name|sp
operator|->
name|synsnr
operator|=
name|wwv_snr
argument_list|(
name|sp
operator|->
name|synmax
argument_list|,
name|sp
operator|->
name|synmin
argument_list|)
expr_stmt|;
name|sp
operator|->
name|select
operator|&=
operator|~
operator|(
name|DATANG
operator||
name|SYNCNG
operator|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|synmax
operator|<
name|QTHR
operator|||
name|sp
operator|->
name|synsnr
operator|<
name|QSNR
condition|)
name|sp
operator|->
name|select
operator||=
name|SYNCNG
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|errcnt
operator|>
literal|1
condition|)
name|sp
operator|->
name|select
operator||=
name|DATANG
expr_stmt|;
name|rp
operator|=
operator|&
name|cp
operator|->
name|wwvh
expr_stmt|;
name|rp
operator|->
name|synmin
operator|=
operator|(
name|rp
operator|->
name|synmin
operator|+
name|rp
operator|->
name|synamp
operator|)
operator|/
literal|2
expr_stmt|;
name|rp
operator|->
name|synsnr
operator|=
name|wwv_snr
argument_list|(
name|rp
operator|->
name|synmax
argument_list|,
name|rp
operator|->
name|synmin
argument_list|)
expr_stmt|;
name|rp
operator|->
name|select
operator|&=
operator|~
operator|(
name|DATANG
operator||
name|SYNCNG
operator|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|synmax
operator|<
name|QTHR
operator|||
name|rp
operator|->
name|synsnr
operator|<
name|QSNR
condition|)
name|rp
operator|->
name|select
operator||=
name|SYNCNG
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|errcnt
operator|>
literal|1
condition|)
name|rp
operator|->
name|select
operator||=
name|DATANG
expr_stmt|;
name|cp
operator|->
name|errcnt
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv5 %d %3d %-3s %04x %d %.0f/%.1f/%ld %s %04x %d %.0f/%.1f/%ld"
argument_list|,
name|up
operator|->
name|port
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|sp
operator|->
name|ident
argument_list|,
name|sp
operator|->
name|select
argument_list|,
name|sp
operator|->
name|count
argument_list|,
name|sp
operator|->
name|synmax
argument_list|,
name|sp
operator|->
name|synsnr
argument_list|,
name|sp
operator|->
name|jitter
argument_list|,
name|rp
operator|->
name|ident
argument_list|,
name|rp
operator|->
name|select
argument_list|,
name|rp
operator|->
name|count
argument_list|,
name|rp
operator|->
name|synmax
argument_list|,
name|rp
operator|->
name|synsnr
argument_list|,
name|rp
operator|->
name|jitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|up
operator|->
name|status
operator|&=
operator|~
name|SFLAG
expr_stmt|;
name|wwv_newchan
argument_list|(
name|peer
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Save the bit probability in the BCD data vector at the index 	 * given by the argument. Note that all bits of the vector have 	 * to be above the data gate threshold for the digit to be 	 * considered valid. Bits not used in the digit are forced to 	 * zero and not checked for errors. 	 */
case|case
name|COEF1
case|:
comment|/* 10-13 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|DGATE
condition|)
name|up
operator|->
name|status
operator||=
name|BGATE
expr_stmt|;
name|bcddld
index|[
name|arg
index|]
operator|=
name|bit
expr_stmt|;
break|break;
case|case
name|COEF2
case|:
comment|/* 18, 27-28, 42-43 */
name|bcddld
index|[
name|arg
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|COEF
case|:
comment|/* 4-7, 15-17, 20-23, 25-26, 					   30-33, 35-38, 40-41, 51-54 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|DGATE
operator|||
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|DSYNC
operator|)
condition|)
name|up
operator|->
name|status
operator||=
name|BGATE
expr_stmt|;
name|bcddld
index|[
name|arg
index|]
operator|=
name|bit
expr_stmt|;
break|break;
comment|/* 	 * Correlate coefficient vector with each valid digit vector and 	 * save in decoding matrix. We step through the decoding matrix 	 * digits correlating each with the coefficients and saving the 	 * greatest and the next lower for later SNR calculation. 	 */
case|case
name|DECIM2
case|:
comment|/* 29 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIM3
case|:
comment|/* 44 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd3
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIM6
case|:
comment|/* 19 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd6
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIM9
case|:
comment|/* 8, 14, 24, 34, 39 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd9
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Miscellaneous bits. If above the positive threshold, declare 	 * 1; if below the negative threshold, declare 0; otherwise 	 * raise the SYMERR alarm. At the end of second 58, QSY to the 	 * probe channel. 	 */
case|case
name|MSC20
case|:
comment|/* 55 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd9
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|MSCBIT
case|:
comment|/* 2, 3, 50, 56-57 */
if|if
condition|(
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|>
name|BTHR
condition|)
name|up
operator|->
name|misc
operator||=
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|<
operator|-
name|BTHR
condition|)
name|up
operator|->
name|misc
operator|&=
operator|~
name|arg
expr_stmt|;
else|else
name|up
operator|->
name|alarm
operator||=
literal|1
operator|<<
name|SYMERR
expr_stmt|;
break|break;
case|case
name|MSC21
case|:
comment|/* 58 */
if|if
condition|(
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|>
name|BTHR
condition|)
name|up
operator|->
name|misc
operator||=
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
operator|<
operator|-
name|BTHR
condition|)
name|up
operator|->
name|misc
operator|&=
operator|~
name|arg
expr_stmt|;
else|else
name|up
operator|->
name|alarm
operator||=
literal|1
operator|<<
name|SYMERR
expr_stmt|;
name|up
operator|->
name|schan
operator|=
operator|(
name|up
operator|->
name|schan
operator|+
literal|1
operator|)
operator|%
name|NCHAN
expr_stmt|;
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|schan
argument_list|)
expr_stmt|;
name|up
operator|->
name|status
operator||=
name|SFLAG
expr_stmt|;
break|break;
comment|/* 	 * The endgames 	 * 	 * Second 59 contains the first data pulse of the probe 	 * sequence. Check it for validity and establish the noise floor 	 * for the minute sync SNR. 	 */
case|case
name|MIN1
case|:
comment|/* 59 */
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|sigamp
operator|<
name|DTHR
operator|||
name|up
operator|->
name|datsnr
operator|<
name|DSNR
condition|)
name|cp
operator|->
name|errcnt
operator|++
expr_stmt|;
name|sp
operator|=
operator|&
name|cp
operator|->
name|wwv
expr_stmt|;
name|sp
operator|->
name|synmin
operator|=
name|sp
operator|->
name|synamp
expr_stmt|;
name|sp
operator|=
operator|&
name|cp
operator|->
name|wwvh
expr_stmt|;
name|sp
operator|->
name|synmin
operator|=
name|sp
operator|->
name|synamp
expr_stmt|;
comment|/* 		 * If SECWARN is set on the last minute of 30 June or 31 		 * December, LEPSEC bit is set. At the end of the minute 		 * in which LEPSEC is set the transmitter and receiver 		 * insert an extra second (60) in the timescale and the 		 * minute sync skips a second. We only get to test this 		 * wrinkle at intervals of about 18 months, the actual 		 * mileage may vary. 		 */
if|if
condition|(
name|up
operator|->
name|tsec
operator|==
literal|60
condition|)
block|{
name|up
operator|->
name|status
operator|&=
operator|~
name|LEPSEC
expr_stmt|;
break|break;
block|}
comment|/* fall through */
comment|/* 	 * If all nine clock digits are valid and the SYNERR alarm is 	 * not raised in the current or previous second, the clock is 	 * set or validated. If at least one digit is set, which by 	 * design must be the minute units digit, the clock state 	 * machine begins to count the minutes. 	 */
case|case
name|MIN2
case|:
comment|/* 59/60 */
name|up
operator|->
name|minset
operator|=
operator|(
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
operator|+
literal|30
operator|)
operator|/
literal|60
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|digcnt
operator|>
literal|0
condition|)
name|up
operator|->
name|status
operator||=
name|DSYNC
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|digcnt
operator|>=
literal|9
operator|&&
operator|(
name|up
operator|->
name|alarm
operator|&
operator|(
literal|3
operator|<<
name|SYNERR
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|INSYNC
expr_stmt|;
name|up
operator|->
name|watch
operator|=
literal|0
expr_stmt|;
block|}
name|pp
operator|->
name|lencode
operator|=
name|timecode
argument_list|(
name|up
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|misc
operator|&
name|SECWAR
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
else|else
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"wwv: timecode %d %s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 		 * The ultimate watchdog is the interval since the 		 * reference clock interface code last received an 		 * update from this driver. If the interval is greater 		 * than a couple of days, manual intervention is 		 * probably required, so the program resets and tries to 		 * resynchronized from scratch. 		 */
if|if
condition|(
name|up
operator|->
name|minset
operator|>
name|PANIC
condition|)
name|up
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|alarm
operator|=
operator|(
name|up
operator|->
name|alarm
operator|&
operator|~
literal|0x8888
operator|)
operator|<<
literal|1
expr_stmt|;
name|up
operator|->
name|nepoch
operator|=
operator|(
name|up
operator|->
name|mphase
operator|+
name|SYNSIZ
operator|)
operator|%
name|MINUTE
expr_stmt|;
name|up
operator|->
name|errcnt
operator|=
name|up
operator|->
name|digcnt
operator|=
name|nsec
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|DSYNC
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv3 %2d %04x %5.0f %5.0f %5.0f %5.1f %5.0f %5.0f"
argument_list|,
name|up
operator|->
name|rsec
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|up
operator|->
name|sigamp
argument_list|,
name|up
operator|->
name|datpha
argument_list|,
name|up
operator|->
name|datsnr
argument_list|,
name|bit
argument_list|,
name|bitvec
index|[
name|up
operator|->
name|rsec
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|up
operator|->
name|rsec
operator|=
name|up
operator|->
name|tsec
operator|=
name|nsec
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * wwv_data - calculate bit probability  *  * This routine is called at the end of the receiver second to calculate  * the probabilities that the previous second contained a zero (P0), one  * (P1) or position indicator (P2) pulse. If not in sync or if the data  * bit is bad, a bit error is declared and the probabilities are forced  * to zero. Otherwise, the data gate is enabled and the probabilities  * are calculated. Note that the data matched filter contributes half  * the pulse width, or 85 ms..  */
end_comment

begin_function
specifier|static
name|double
name|wwv_data
parameter_list|(
name|struct
name|wwvunit
modifier|*
name|up
parameter_list|,
comment|/* driver unit pointer */
name|double
name|pulse
comment|/* pulse length (sample units) */
parameter_list|)
block|{
name|double
name|p0
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* probabilities */
name|double
name|dpulse
decl_stmt|;
comment|/* pulse length in ms */
name|p0
operator|=
name|p1
operator|=
name|p2
operator|=
literal|0
expr_stmt|;
name|dpulse
operator|=
name|pulse
operator|-
name|DATSIZ
operator|/
literal|2
expr_stmt|;
comment|/* 	 * If the data amplitude or SNR are below threshold or if the 	 * pulse length is less than 170 ms, declare an erasure. 	 */
if|if
condition|(
name|up
operator|->
name|sigamp
operator|<
name|DTHR
operator|||
name|up
operator|->
name|datsnr
operator|<
name|DSNR
operator|||
name|dpulse
operator|<
name|DATSIZ
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|DGATE
expr_stmt|;
name|up
operator|->
name|errcnt
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errcnt
operator|>
name|MAXERR
condition|)
name|up
operator|->
name|alarm
operator||=
literal|1
operator|<<
name|MODERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * The probability of P0 is one below 200 ms falling to zero at 	 * 500 ms. The probability of P1 is zero below 200 ms rising to 	 * one at 500 ms and falling to zero at 800 ms. The probability 	 * of P2 is zero below 500 ms, rising to one above 800 ms. 	 */
name|up
operator|->
name|status
operator|&=
operator|~
name|DGATE
expr_stmt|;
if|if
condition|(
name|dpulse
operator|<
operator|(
literal|200
operator|*
name|MS
operator|)
condition|)
block|{
name|p0
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dpulse
operator|<
literal|500
operator|*
name|MS
condition|)
block|{
name|dpulse
operator|-=
literal|200
operator|*
name|MS
expr_stmt|;
name|p1
operator|=
name|dpulse
operator|/
operator|(
literal|300
operator|*
name|MS
operator|)
expr_stmt|;
name|p0
operator|=
literal|1
operator|-
name|p1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dpulse
operator|<
literal|800
operator|*
name|MS
condition|)
block|{
name|dpulse
operator|-=
literal|500
operator|*
name|MS
expr_stmt|;
name|p2
operator|=
name|dpulse
operator|/
operator|(
literal|300
operator|*
name|MS
operator|)
expr_stmt|;
name|p1
operator|=
literal|1
operator|-
name|p2
expr_stmt|;
block|}
else|else
block|{
name|p2
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * The ouput is a metric that ranges from -1 (P0), to +1 (P1) 	 * scaled for convenience. An output of zero represents an 	 * erasure, either because of a data error or pulse length 	 * greater than 500 ms. At the moment, we don't use P2. 	 */
return|return
operator|(
operator|(
name|p1
operator|-
name|p0
operator|)
operator|*
name|MAXSIG
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_corr4 - determine maximum likelihood digit  *  * This routine correlates the received digit vector with the BCD  * coefficient vectors corresponding to all valid digits at the given  * position in the decoding matrix. The maximum value corresponds to the  * maximum likelihood digit, while the ratio of this value to the next  * lower value determines the likelihood function. Note that, if the  * digit is invalid, the likelihood vector is averaged toward a miss.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_corr4
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer unit pointer */
name|struct
name|decvec
modifier|*
name|vp
parameter_list|,
comment|/* decoding table pointer */
name|double
name|data
index|[]
parameter_list|,
comment|/* received data vector */
name|double
name|tab
index|[]
index|[
literal|4
index|]
comment|/* correlation vector array */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|double
name|topmax
decl_stmt|,
name|nxtmax
decl_stmt|;
comment|/* metrics */
name|double
name|acc
decl_stmt|;
comment|/* accumulator */
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* monitor buffer */
name|int
name|mldigit
decl_stmt|;
comment|/* max likelihood digit */
name|int
name|diff
decl_stmt|;
comment|/* decoding difference */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Correlate digit vector with each BCD coefficient vector. If 	 * any BCD digit bit is bad, consider all bits a miss. 	 */
name|mldigit
operator|=
literal|0
expr_stmt|;
name|topmax
operator|=
name|nxtmax
operator|=
operator|-
name|MAXSIG
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tab
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|acc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|BGATE
operator|)
condition|)
name|acc
operator|+=
name|data
index|[
name|j
index|]
operator|*
name|tab
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
name|acc
operator|=
operator|(
name|vp
operator|->
name|like
index|[
name|i
index|]
operator|+=
operator|(
name|acc
operator|-
name|vp
operator|->
name|like
index|[
name|i
index|]
operator|)
operator|/
name|TCONST
operator|)
expr_stmt|;
if|if
condition|(
name|acc
operator|>
name|topmax
condition|)
block|{
name|nxtmax
operator|=
name|topmax
expr_stmt|;
name|topmax
operator|=
name|acc
expr_stmt|;
name|mldigit
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acc
operator|>
name|nxtmax
condition|)
block|{
name|nxtmax
operator|=
name|acc
expr_stmt|;
block|}
block|}
name|vp
operator|->
name|mldigit
operator|=
name|mldigit
expr_stmt|;
name|vp
operator|->
name|digprb
operator|=
name|topmax
expr_stmt|;
name|vp
operator|->
name|digsnr
operator|=
name|wwv_snr
argument_list|(
name|topmax
argument_list|,
name|nxtmax
argument_list|)
expr_stmt|;
comment|/* 	 * The maximum likelihood digit is compared with the current 	 * clock digit. The difference represents the decoding phase 	 * error. If the digit probability and likelihood are good and 	 * the difference stays the same for a number of comparisons, 	 * the clock digit is reset to the maximum likelihood digit. 	 */
name|diff
operator|=
name|mldigit
operator|-
name|vp
operator|->
name|digit
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|+=
name|vp
operator|->
name|radix
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
name|vp
operator|->
name|phase
condition|)
block|{
name|vp
operator|->
name|phase
operator|=
name|diff
expr_stmt|;
name|vp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|digprb
operator|<
name|BTHR
operator|||
name|vp
operator|->
name|digsnr
operator|<
name|BSNR
condition|)
block|{
name|vp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|alarm
operator||=
literal|1
operator|<<
name|SYMERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|count
operator|<
name|BCMP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|)
block|{
name|vp
operator|->
name|phase
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|digit
operator|=
name|mldigit
expr_stmt|;
block|}
name|vp
operator|->
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|->
name|phase
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|digit
operator|=
name|mldigit
expr_stmt|;
name|up
operator|->
name|digcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|digit
operator|!=
name|mldigit
condition|)
name|up
operator|->
name|alarm
operator||=
literal|1
operator|<<
name|DECERR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"wwv4 %2d %04x %5.0f %2d %d %d %d %d %5.0f %5.1f"
argument_list|,
name|up
operator|->
name|rsec
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|vp
operator|->
name|radix
argument_list|,
name|vp
operator|->
name|digit
argument_list|,
name|vp
operator|->
name|mldigit
argument_list|,
name|vp
operator|->
name|phase
argument_list|,
name|vp
operator|->
name|count
argument_list|,
name|vp
operator|->
name|digprb
argument_list|,
name|vp
operator|->
name|digsnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|up
operator|->
name|status
operator|&=
operator|~
name|BGATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_tsec - transmitter second processing  *  * This routine is called at the end of the transmitter second. It  * implements a state machine that advances the logical clock subject to  * the funny rules that govern the conventional clock and calendar. Note  * that carries from the least significant (minutes) digit are inhibited  * until that digit is synchronized.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_tsec
parameter_list|(
name|struct
name|wwvunit
modifier|*
name|up
comment|/* driver structure pointer */
parameter_list|)
block|{
name|int
name|minute
decl_stmt|,
name|day
decl_stmt|,
name|isleap
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|up
operator|->
name|tsec
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|tsec
operator|<
literal|60
operator|||
name|up
operator|->
name|status
operator|&
name|LEPSEC
condition|)
return|return;
name|up
operator|->
name|tsec
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Advance minute unit of the day. If the minute unit is not 	 * synchronized, go no further. 	 */
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|MN
index|]
argument_list|)
expr_stmt|;
comment|/* minute units */
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|DSYNC
operator|)
condition|)
return|return;
comment|/* 	 * Propagate carries through the day. 	 */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
comment|/* carry minutes */
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
comment|/* carry hours */
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Decode the current minute and day. Set the leap second enable 	 * bit on the last minute of 30 June and 31 December. 	 */
name|minute
operator|=
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|digit
operator|*
literal|60
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|600
expr_stmt|;
name|day
operator|=
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|digit
operator|*
literal|100
expr_stmt|;
name|isleap
operator|=
operator|(
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|digit
operator|&
literal|0x3
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|minute
operator|==
literal|1439
operator|&&
operator|(
name|day
operator|==
operator|(
name|isleap
condition|?
literal|182
else|:
literal|183
operator|)
operator|||
name|day
operator|==
operator|(
name|isleap
condition|?
literal|365
else|:
literal|366
operator|)
operator|)
operator|&&
name|up
operator|->
name|misc
operator|&
name|SECWAR
condition|)
name|up
operator|->
name|status
operator||=
name|LEPSEC
expr_stmt|;
comment|/* 	 * Roll the day if this the first minute and propagate carries 	 * through the year. 	 */
if|if
condition|(
name|minute
operator|!=
literal|1440
condition|)
return|return;
name|minute
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/* advance to minute 0 */
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|day
operator|++
expr_stmt|;
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
index|]
argument_list|)
expr_stmt|;
comment|/* carry days */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Roll the year if this the first day and propagate carries 	 * through the century. 	 */
if|if
condition|(
name|day
operator|!=
operator|(
name|isleap
condition|?
literal|365
else|:
literal|366
operator|)
condition|)
return|return;
name|day
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
index|]
argument_list|)
operator|!=
literal|1
condition|)
empty_stmt|;
comment|/* advance to day 1 */
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|YR
index|]
argument_list|)
expr_stmt|;
comment|/* carry years */
if|if
condition|(
name|temp
condition|)
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * carry - process digit  *  * This routine rotates a likelihood vector one position and increments  * the clock digit modulo the radix. It returns the new clock digit -  * zero if a carry occured. Once synchronized, the clock digit will  * match the maximum likelihood digit corresponding to that position.  */
end_comment

begin_function
specifier|static
name|int
name|carry
parameter_list|(
name|struct
name|decvec
modifier|*
name|dp
comment|/* decoding table pointer */
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
name|int
name|j
decl_stmt|;
name|dp
operator|->
name|digit
operator|++
expr_stmt|;
comment|/* advance clock digit */
if|if
condition|(
name|dp
operator|->
name|digit
operator|==
name|dp
operator|->
name|radix
condition|)
block|{
comment|/* modulo radix */
name|dp
operator|->
name|digit
operator|=
literal|0
expr_stmt|;
block|}
name|temp
operator|=
name|dp
operator|->
name|like
index|[
name|dp
operator|->
name|radix
operator|-
literal|1
index|]
expr_stmt|;
comment|/* rotate likelihood vector */
for|for
control|(
name|j
operator|=
name|dp
operator|->
name|radix
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|dp
operator|->
name|like
index|[
name|j
index|]
operator|=
name|dp
operator|->
name|like
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|dp
operator|->
name|like
index|[
literal|0
index|]
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|dp
operator|->
name|digit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_snr - compute SNR or likelihood function  */
end_comment

begin_function
specifier|static
name|double
name|wwv_snr
parameter_list|(
name|double
name|signal
parameter_list|,
comment|/* signal */
name|double
name|noise
comment|/* noise */
parameter_list|)
block|{
name|double
name|rval
decl_stmt|;
comment|/* 	 * This is a little tricky. Due to the way things are measured, 	 * either or both the signal or noise amplitude can be negative 	 * or zero. The intent is that, if the signal is negative or 	 * zero, the SNR must always be zero. This can happen with the 	 * subcarrier SNR before the phase has been aligned. On the 	 * other hand, in the likelihood function the "noise" is the 	 * next maximum down from the peak and this could be negative. 	 * However, in this case the SNR is truly stupendous, so we 	 * simply cap at MAXSNR dB. 	 */
if|if
condition|(
name|signal
operator|<=
literal|0
condition|)
block|{
name|rval
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noise
operator|<=
literal|0
condition|)
block|{
name|rval
operator|=
name|MAXSNR
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
literal|20
operator|*
name|log10
argument_list|(
name|signal
operator|/
name|noise
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|>
name|MAXSNR
condition|)
name|rval
operator|=
name|MAXSNR
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_newchan - change to new data channel  *  * Assuming the radio can be tuned by this program, it actually appears  * as a 10-channel receiver, one channel for each of WWV and WWVH on  * each of five frequencies. While the radio is tuned to the working  * data channel (frequency and station) for most of the minute, during  * seconds 59, 0 and 1 the radio is tuned to a probe channel, in order  * to pick up minute sync and data pulses. The search for WWV and WWVH  * stations operates simultaneously, with WWV on 1000 Hz and WWVH on  * 1200 Hz. The probe channel rotates for each minute over the five  * frequencies. At the end of each rotation, this routine mitigates over  * all channels and chooses the best frequency and station.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_newchan
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
name|struct
name|sync
modifier|*
name|sp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|int
name|rank
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Reset the matched filter selector and station pointer to 	 * avoid fooling around should we lose this game. 	 */
name|up
operator|->
name|sptr
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|status
operator|&=
operator|~
operator|(
name|SELV
operator||
name|SELH
operator|)
expr_stmt|;
comment|/* 	 * Search all five station pairs looking for the station with 	 * the maximum compare counter. Ties go to the highest frequency 	 * and then to WWV. 	 */
name|j
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|sync
operator|*
operator|)
literal|0
expr_stmt|;
name|rank
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|i
index|]
expr_stmt|;
name|rp
operator|=
operator|&
name|cp
operator|->
name|wwvh
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|count
operator|>=
name|rank
condition|)
block|{
name|sp
operator|=
name|rp
expr_stmt|;
name|rank
operator|=
name|rp
operator|->
name|count
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
name|rp
operator|=
operator|&
name|cp
operator|->
name|wwv
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|count
operator|>=
name|rank
condition|)
block|{
name|sp
operator|=
name|rp
expr_stmt|;
name|rank
operator|=
name|rp
operator|->
name|count
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * If we find a station, continue to track it. If not, X marks 	 * the spot and we wait for better ions. 	 */
if|if
condition|(
name|rank
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|dchan
operator|=
name|j
expr_stmt|;
name|up
operator|->
name|sptr
operator|=
name|sp
expr_stmt|;
name|up
operator|->
name|status
operator||=
name|sp
operator|->
name|select
operator|&
operator|(
name|SELV
operator||
name|SELH
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|sp
operator|->
name|refid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|sp
operator|->
name|refid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|dchan
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_qsy - Tune ICOM receiver  *  * This routine saves the AGC for the current channel, switches to a new  * channel and restores the AGC for that channel. If a tunable receiver  * is not available, just fake it.  */
end_comment

begin_function
specifier|static
name|int
name|wwv_qsy
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|chan
comment|/* channel */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|gain
operator|=
name|up
operator|->
name|gain
expr_stmt|;
ifdef|#
directive|ifdef
name|ICOM
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
name|rval
operator|=
name|icom_freq
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|,
name|peer
operator|->
name|ttl
operator|&
literal|0x7f
argument_list|,
name|qsy
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ICOM */
name|up
operator|->
name|achan
operator|=
name|chan
expr_stmt|;
name|up
operator|->
name|gain
operator|=
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|gain
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * timecode - assemble timecode string and length  *  * Prettytime format - similar to Spectracom  *  * sq yy ddd hh:mm:ss.fff ld dut lset agc stn comp errs freq avgt  *  * s	sync indicator ('?' or ' ')  * q	quality character (hex 0-F)  * yyyy	year of century  * ddd	day of year  * hh	hour of day  * mm	minute of hour  * ss	minute of hour  * fff	millisecond of second  * l	leap second warning ' ' or 'L'  * d	DST state 'S', 'D', 'I', or 'O'  * dut	DUT sign and magnitude in deciseconds  * lset	minutes since last clock update  * agc	audio gain (0-255)  * iden	station identifier (station and frequency)  * comp	minute sync compare counter  * errs	bit errors in last minute
comment|* freq	frequency offset (PPM)
comment|* avgt	averaging time (s)
comment|*/
end_comment

begin_function
specifier|static
name|int
name|timecode
parameter_list|(
name|struct
name|wwvunit
modifier|*
name|up
parameter_list|,
comment|/* driver structure pointer */
name|char
modifier|*
name|ptr
comment|/* target string */
parameter_list|)
block|{
name|struct
name|sync
modifier|*
name|sp
decl_stmt|;
name|int
name|year
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|frac
decl_stmt|,
name|dut
decl_stmt|;
name|char
name|synchar
decl_stmt|,
name|qual
decl_stmt|,
name|leapchar
decl_stmt|,
name|dst
decl_stmt|;
name|char
name|cptr
index|[
literal|50
index|]
decl_stmt|;
comment|/* 	 * Common fixed-format fields 	 */
name|synchar
operator|=
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|?
literal|' '
else|:
literal|'?'
expr_stmt|;
name|qual
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|alarm
operator|&
operator|(
literal|3
operator|<<
name|DECERR
operator|)
condition|)
name|qual
operator||=
literal|0x1
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|alarm
operator|&
operator|(
literal|3
operator|<<
name|SYMERR
operator|)
condition|)
name|qual
operator||=
literal|0x2
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|alarm
operator|&
operator|(
literal|3
operator|<<
name|MODERR
operator|)
condition|)
name|qual
operator||=
literal|0x4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|alarm
operator|&
operator|(
literal|3
operator|<<
name|SYNERR
operator|)
condition|)
name|qual
operator||=
literal|0x8
expr_stmt|;
name|year
operator|=
name|up
operator|->
name|decvec
index|[
literal|7
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
literal|7
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|year
operator|<
name|UTCYEAR
condition|)
name|year
operator|+=
literal|2000
expr_stmt|;
else|else
name|year
operator|+=
literal|1900
expr_stmt|;
name|day
operator|=
name|up
operator|->
name|decvec
index|[
literal|4
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
literal|5
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
literal|6
index|]
operator|.
name|digit
operator|*
literal|100
expr_stmt|;
name|hour
operator|=
name|up
operator|->
name|decvec
index|[
literal|2
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
literal|3
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|minute
operator|=
name|up
operator|->
name|decvec
index|[
literal|0
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|second
operator|=
name|up
operator|->
name|tsec
expr_stmt|;
name|frac
operator|=
operator|(
name|up
operator|->
name|tphase
operator|*
literal|1000
operator|)
operator|/
name|SECOND
expr_stmt|;
name|leapchar
operator|=
operator|(
name|up
operator|->
name|misc
operator|&
name|SECWAR
operator|)
condition|?
literal|'L'
else|:
literal|' '
expr_stmt|;
name|dst
operator|=
name|dstcod
index|[
operator|(
name|up
operator|->
name|misc
operator|>>
literal|4
operator|)
operator|&
literal|0x3
index|]
expr_stmt|;
name|dut
operator|=
name|up
operator|->
name|misc
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|misc
operator|&
name|DUTS
operator|)
condition|)
name|dut
operator|=
operator|-
name|dut
expr_stmt|;
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%c%1X"
argument_list|,
name|synchar
argument_list|,
name|qual
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cptr
argument_list|,
literal|" %4d %03d %02d:%02d:%02d.%.03d %c%c %+d"
argument_list|,
name|year
argument_list|,
name|day
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|frac
argument_list|,
name|leapchar
argument_list|,
name|dst
argument_list|,
name|dut
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ptr
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
comment|/* 	 * Specific variable-format fields 	 */
name|sp
operator|=
name|up
operator|->
name|sptr
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|cptr
argument_list|,
literal|" %d %d %s %d %d %.1f %d"
argument_list|,
name|up
operator|->
name|minset
argument_list|,
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|dchan
index|]
operator|.
name|gain
argument_list|,
name|sp
operator|->
name|ident
argument_list|,
name|sp
operator|->
name|count
argument_list|,
name|up
operator|->
name|errcnt
argument_list|,
name|up
operator|->
name|freq
operator|/
name|SECOND
operator|*
literal|1e6
argument_list|,
name|MINAVG
operator|<<
name|up
operator|->
name|avgint
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|cptr
argument_list|,
literal|" %d %d X 0 %d %.1f %d"
argument_list|,
name|up
operator|->
name|minset
argument_list|,
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|dchan
index|]
operator|.
name|gain
argument_list|,
name|up
operator|->
name|errcnt
argument_list|,
name|up
operator|->
name|freq
operator|/
name|SECOND
operator|*
literal|1e6
argument_list|,
name|MINAVG
operator|<<
name|up
operator|->
name|avgint
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ptr
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_gain - adjust codec gain  *  * This routine is called once each second. If the signal envelope  * amplitude is too low, the codec gain is bumped up by four units; if  * too high, it is bumped down. The decoder is relatively insensitive to  * amplitude, so this crudity works just fine. The input port is set and  * the error flag is cleared, mostly to be ornery.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_gain
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Apparently, the codec uses only the high order bits of the 	 * gain control field. Thus, it may take awhile for changes to 	 * wiggle the hardware bits. 	 */
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|gain
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|>
literal|255
condition|)
name|up
operator|->
name|gain
operator|=
literal|255
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|>
name|SECOND
operator|/
literal|100
condition|)
block|{
name|up
operator|->
name|gain
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|<
literal|0
condition|)
name|up
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
block|}
name|audio_gain
argument_list|(
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|port
argument_list|)
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_wwv_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

