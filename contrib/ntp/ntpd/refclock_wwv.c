begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_wwv - clock driver for NIST WWV/H time/frequency station  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_WWV
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"audio.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_IOCTL_H */
end_comment

begin_define
define|#
directive|define
name|ICOM
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_include
include|#
directive|include
file|"icom.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * Audio WWV/H demodulator/decoder  *  * This driver synchronizes the computer time using data encoded in  * radio transmissions from NIST time/frequency stations WWV in Boulder,  * CO, and WWVH in Kauai, HI. Transmissions are made continuously on  * 2.5, 5, 10 and 15 MHz from WWV and WWVH, and 20 MHz from WWV. An  * ordinary AM shortwave receiver can be tuned manually to one of these  * frequencies or, in the case of ICOM receivers, the receiver can be  * tuned automatically using this program as propagation conditions  * change throughout the weasons, both day and night.  *  * The driver requires an audio codec or sound card with sampling rate 8  * kHz and mu-law companding. This is the same standard as used by the  * telephone industry and is supported by most hardware and operating  * systems, including Solaris, SunOS, FreeBSD, NetBSD and Linux. In this  * implementation, only one audio driver and codec can be supported on a  * single machine.  *  * The demodulation and decoding algorithms used in this driver are  * based on those developed for the TAPR DSP93 development board and the  * TI 320C25 digital signal processor described in: Mills, D.L. A  * precision radio clock for WWV transmissions. Electrical Engineering  * Report 97-8-1, University of Delaware, August 1997, 25 pp., available  * from www.eecis.udel.edu/~mills/reports.html. The algorithms described  * in this report have been modified somewhat to improve performance  * under weak signal conditions and to provide an automatic station  * identification feature.  *  * The ICOM code is normally compiled in the driver. It isn't used,  * unless the mode keyword on the server configuration command specifies  * a nonzero ICOM ID select code. The C-IV trace is turned on if the  * debug level is greater than one.  *  * Fudge factors  *  * Fudge flag4 causes the debugging output described above to be  * recorded in the clockstats file. Fudge flag2 selects the audio input  * port, where 0 is the mike port (default) and 1 is the line-in port.  * It does not seem useful to select the compact disc player port. Fudge  * flag3 enables audio monitoring of the input signal. For this purpose,  * the monitor gain is set to a default value.  *  * CEVNT_BADTIME	invalid date or time  * CEVNT_PROP		propagation failure - no stations heard  * CEVNT_TIMEOUT	timeout (see newgame() below)  */
end_comment

begin_comment
comment|/*  * General definitions. These ordinarily do not need to be changed.  */
end_comment

begin_define
define|#
directive|define
name|DEVICE_AUDIO
value|"/dev/audio"
end_define

begin_comment
comment|/* audio device name */
end_comment

begin_define
define|#
directive|define
name|AUDIO_BUFSIZ
value|320
end_define

begin_comment
comment|/* audio buffer size (50 ms) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"WWV/H Audio Demodulator/Decoder"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|WWV_SEC
value|8000
end_define

begin_comment
comment|/* second epoch (sample rate) (Hz) */
end_comment

begin_define
define|#
directive|define
name|WWV_MIN
value|(WWV_SEC * 60)
end_define

begin_comment
comment|/* minute epoch */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|128
end_define

begin_comment
comment|/* companded sample offset */
end_comment

begin_define
define|#
directive|define
name|SIZE
value|256
end_define

begin_comment
comment|/* decompanding table size */
end_comment

begin_define
define|#
directive|define
name|MAXAMP
value|6000.
end_define

begin_comment
comment|/* max signal level reference */
end_comment

begin_define
define|#
directive|define
name|MAXCLP
value|100
end_define

begin_comment
comment|/* max clips above reference per s */
end_comment

begin_define
define|#
directive|define
name|MAXSNR
value|40.
end_define

begin_comment
comment|/* max SNR reference */
end_comment

begin_define
define|#
directive|define
name|MAXFREQ
value|1.5
end_define

begin_comment
comment|/* max frequency tolerance (187 PPM) */
end_comment

begin_define
define|#
directive|define
name|DATCYC
value|170
end_define

begin_comment
comment|/* data filter cycles */
end_comment

begin_define
define|#
directive|define
name|DATSIZ
value|(DATCYC * MS)
end_define

begin_comment
comment|/* data filter size */
end_comment

begin_define
define|#
directive|define
name|SYNCYC
value|800
end_define

begin_comment
comment|/* minute filter cycles */
end_comment

begin_define
define|#
directive|define
name|SYNSIZ
value|(SYNCYC * MS)
end_define

begin_comment
comment|/* minute filter size */
end_comment

begin_define
define|#
directive|define
name|TCKCYC
value|5
end_define

begin_comment
comment|/* tick filter cycles */
end_comment

begin_define
define|#
directive|define
name|TCKSIZ
value|(TCKCYC * MS)
end_define

begin_comment
comment|/* tick filter size */
end_comment

begin_define
define|#
directive|define
name|NCHAN
value|5
end_define

begin_comment
comment|/* number of radio channels */
end_comment

begin_define
define|#
directive|define
name|AUDIO_PHI
value|5e-6
end_define

begin_comment
comment|/* dispersion growth factor */
end_comment

begin_define
define|#
directive|define
name|TBUF
value|128
end_define

begin_comment
comment|/* max monitor line length */
end_comment

begin_comment
comment|/*  * Tunable parameters. The DGAIN parameter can be changed to fit the  * audio response of the radio at 100 Hz. The WWV/WWVH data subcarrier  * is transmitted at about 20 percent percent modulation; the matched  * filter boosts it by a factor of 17 and the receiver response does  * what it does. The compromise value works for ICOM radios. If the  * radio is not tunable, the DCHAN parameter can be changed to fit the  * expected best propagation frequency: higher if further from the  * transmitter, lower if nearer. The compromise value works for the US  * right coast.  */
end_comment

begin_define
define|#
directive|define
name|DCHAN
value|3
end_define

begin_comment
comment|/* default radio channel (15 Mhz) */
end_comment

begin_define
define|#
directive|define
name|DGAIN
value|5.
end_define

begin_comment
comment|/* subcarrier gain */
end_comment

begin_comment
comment|/*  * General purpose status bits (status)  *  * SELV and/or SELH are set when WWV or WWVH have been heard and cleared  * on signal loss. SSYNC is set when the second sync pulse has been  * acquired and cleared by signal loss. MSYNC is set when the minute  * sync pulse has been acquired. DSYNC is set when the units digit has  * has reached the threshold and INSYNC is set when all nine digits have  * reached the threshold. The MSYNC, DSYNC and INSYNC bits are cleared  * only by timeout, upon which the driver starts over from scratch.  *  * DGATE is lit if the data bit amplitude or SNR is below thresholds and  * BGATE is lit if the pulse width amplitude or SNR is below thresolds.  * LEPSEC is set during the last minute of the leap day. At the end of  * this minute the driver inserts second 60 in the seconds state machine  * and the minute sync slips a second.  */
end_comment

begin_define
define|#
directive|define
name|MSYNC
value|0x0001
end_define

begin_comment
comment|/* minute epoch sync */
end_comment

begin_define
define|#
directive|define
name|SSYNC
value|0x0002
end_define

begin_comment
comment|/* second epoch sync */
end_comment

begin_define
define|#
directive|define
name|DSYNC
value|0x0004
end_define

begin_comment
comment|/* minute units sync */
end_comment

begin_define
define|#
directive|define
name|INSYNC
value|0x0008
end_define

begin_comment
comment|/* clock synchronized */
end_comment

begin_define
define|#
directive|define
name|FGATE
value|0x0010
end_define

begin_comment
comment|/* frequency gate */
end_comment

begin_define
define|#
directive|define
name|DGATE
value|0x0020
end_define

begin_comment
comment|/* data pulse amplitude error */
end_comment

begin_define
define|#
directive|define
name|BGATE
value|0x0040
end_define

begin_comment
comment|/* data pulse width error */
end_comment

begin_define
define|#
directive|define
name|METRIC
value|0x0080
end_define

begin_comment
comment|/* one or more stations heard */
end_comment

begin_define
define|#
directive|define
name|LEPSEC
value|0x1000
end_define

begin_comment
comment|/* leap minute */
end_comment

begin_comment
comment|/*  * Station scoreboard bits  *  * These are used to establish the signal quality for each of the five  * frequencies and two stations.  */
end_comment

begin_define
define|#
directive|define
name|SELV
value|0x0100
end_define

begin_comment
comment|/* WWV station select */
end_comment

begin_define
define|#
directive|define
name|SELH
value|0x0200
end_define

begin_comment
comment|/* WWVH station select */
end_comment

begin_comment
comment|/*  * Alarm status bits (alarm)  *  * These bits indicate various alarm conditions, which are decoded to  * form the quality character included in the timecode.  */
end_comment

begin_define
define|#
directive|define
name|CMPERR
value|0x1
end_define

begin_comment
comment|/* digit or misc bit compare error */
end_comment

begin_define
define|#
directive|define
name|LOWERR
value|0x2
end_define

begin_comment
comment|/* low bit or digit amplitude or SNR */
end_comment

begin_define
define|#
directive|define
name|NINERR
value|0x4
end_define

begin_comment
comment|/* less than nine digits in minute */
end_comment

begin_define
define|#
directive|define
name|SYNERR
value|0x8
end_define

begin_comment
comment|/* not tracking second sync */
end_comment

begin_comment
comment|/*  * Watchcat timeouts (watch)  *  * If these timeouts expire, the status bits are mashed to zero and the  * driver starts from scratch. Suitably more refined procedures may be  * developed in future. All these are in minutes.  */
end_comment

begin_define
define|#
directive|define
name|ACQSN
value|6
end_define

begin_comment
comment|/* station acquisition timeout */
end_comment

begin_define
define|#
directive|define
name|DATA
value|15
end_define

begin_comment
comment|/* unit minutes timeout */
end_comment

begin_define
define|#
directive|define
name|SYNCH
value|40
end_define

begin_comment
comment|/* station sync timeout */
end_comment

begin_define
define|#
directive|define
name|PANIC
value|(2 * 1440)
end_define

begin_comment
comment|/* panic timeout */
end_comment

begin_comment
comment|/*  * Thresholds. These establish the minimum signal level, minimum SNR and  * maximum jitter thresholds which establish the error and false alarm  * rates of the driver. The values defined here may be on the  * adventurous side in the interest of the highest sensitivity.  */
end_comment

begin_define
define|#
directive|define
name|MTHR
value|13.
end_define

begin_comment
comment|/* minute sync gate (percent) */
end_comment

begin_define
define|#
directive|define
name|TTHR
value|50.
end_define

begin_comment
comment|/* minute sync threshold (percent) */
end_comment

begin_define
define|#
directive|define
name|AWND
value|20
end_define

begin_comment
comment|/* minute sync jitter threshold (ms) */
end_comment

begin_define
define|#
directive|define
name|ATHR
value|2500.
end_define

begin_comment
comment|/* QRZ minute sync threshold */
end_comment

begin_define
define|#
directive|define
name|ASNR
value|20.
end_define

begin_comment
comment|/* QRZ minute sync SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|QTHR
value|2500.
end_define

begin_comment
comment|/* QSY minute sync threshold */
end_comment

begin_define
define|#
directive|define
name|QSNR
value|20.
end_define

begin_comment
comment|/* QSY minute sync SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|STHR
value|2500.
end_define

begin_comment
comment|/* second sync threshold */
end_comment

begin_define
define|#
directive|define
name|SSNR
value|15.
end_define

begin_comment
comment|/* second sync SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|SCMP
value|10
end_define

begin_comment
comment|/* second sync compare threshold */
end_comment

begin_define
define|#
directive|define
name|DTHR
value|1000.
end_define

begin_comment
comment|/* bit threshold */
end_comment

begin_define
define|#
directive|define
name|DSNR
value|10.
end_define

begin_comment
comment|/* bit SNR threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|AMIN
value|3
end_define

begin_comment
comment|/* min bit count */
end_comment

begin_define
define|#
directive|define
name|AMAX
value|6
end_define

begin_comment
comment|/* max bit count */
end_comment

begin_define
define|#
directive|define
name|BTHR
value|1000.
end_define

begin_comment
comment|/* digit threshold */
end_comment

begin_define
define|#
directive|define
name|BSNR
value|3.
end_define

begin_comment
comment|/* digit likelihood threshold (dB) */
end_comment

begin_define
define|#
directive|define
name|BCMP
value|3
end_define

begin_comment
comment|/* digit compare threshold */
end_comment

begin_define
define|#
directive|define
name|MAXERR
value|40
end_define

begin_comment
comment|/* maximum error alarm */
end_comment

begin_comment
comment|/*  * Tone frequency definitions. The increments are for 4.5-deg sine  * table.  */
end_comment

begin_define
define|#
directive|define
name|MS
value|(WWV_SEC / 1000)
end_define

begin_comment
comment|/* samples per millisecond */
end_comment

begin_define
define|#
directive|define
name|IN100
value|((100 * 80) / WWV_SEC)
end_define

begin_comment
comment|/* 100 Hz increment */
end_comment

begin_define
define|#
directive|define
name|IN1000
value|((1000 * 80) / WWV_SEC)
end_define

begin_comment
comment|/* 1000 Hz increment */
end_comment

begin_define
define|#
directive|define
name|IN1200
value|((1200 * 80) / WWV_SEC)
end_define

begin_comment
comment|/* 1200 Hz increment */
end_comment

begin_comment
comment|/*  * Acquisition and tracking time constants  */
end_comment

begin_define
define|#
directive|define
name|MINAVG
value|8
end_define

begin_comment
comment|/* min averaging time */
end_comment

begin_define
define|#
directive|define
name|MAXAVG
value|1024
end_define

begin_comment
comment|/* max averaging time */
end_comment

begin_define
define|#
directive|define
name|FCONST
value|3
end_define

begin_comment
comment|/* frequency time constant */
end_comment

begin_define
define|#
directive|define
name|TCONST
value|16
end_define

begin_comment
comment|/* data bit/digit time constant */
end_comment

begin_comment
comment|/*  * Miscellaneous status bits (misc)  *  * These bits correspond to designated bits in the WWV/H timecode. The  * bit probabilities are exponentially averaged over several minutes and  * processed by a integrator and threshold.  */
end_comment

begin_define
define|#
directive|define
name|DUT1
value|0x01
end_define

begin_comment
comment|/* 56 DUT .1 */
end_comment

begin_define
define|#
directive|define
name|DUT2
value|0x02
end_define

begin_comment
comment|/* 57 DUT .2 */
end_comment

begin_define
define|#
directive|define
name|DUT4
value|0x04
end_define

begin_comment
comment|/* 58 DUT .4 */
end_comment

begin_define
define|#
directive|define
name|DUTS
value|0x08
end_define

begin_comment
comment|/* 50 DUT sign */
end_comment

begin_define
define|#
directive|define
name|DST1
value|0x10
end_define

begin_comment
comment|/* 55 DST1 leap warning */
end_comment

begin_define
define|#
directive|define
name|DST2
value|0x20
end_define

begin_comment
comment|/* 2 DST2 DST1 delayed one day */
end_comment

begin_define
define|#
directive|define
name|SECWAR
value|0x40
end_define

begin_comment
comment|/* 3 leap second warning */
end_comment

begin_comment
comment|/*  * The on-time synchronization point is the positive-going zero crossing  * of the first cycle of the 5-ms second pulse. The IIR baseband filter  * phase delay is 0.91 ms, while the receiver delay is approximately 4.7  * ms at 1000 Hz. The fudge value -0.45 ms due to the codec and other  * causes was determined by calibrating to a PPS signal from a GPS  * receiver. The additional propagation delay specific to each receiver  * location can be  programmed in the fudge time1 and time2 values for  * WWV and WWVH, respectively.  *  * The resulting offsets with a 2.4-GHz P4 running FreeBSD 6.1 are  * generally within .02 ms short-term with .02 ms jitter. The long-term  * offsets vary up to 0.3 ms due to ionosperhic layer height variations.  * The processor load due to the driver is 5.8 percent.  */
end_comment

begin_define
define|#
directive|define
name|PDELAY
value|((.91 + 4.7 - 0.45) / 1000)
end_define

begin_comment
comment|/* system delay (s) */
end_comment

begin_comment
comment|/*  * Table of sine values at 4.5-degree increments. This is used by the  * synchronous matched filter demodulators.  */
end_comment

begin_decl_stmt
name|double
name|sintab
index|[]
init|=
block|{
literal|0.000000e+00
block|,
literal|7.845910e-02
block|,
literal|1.564345e-01
block|,
literal|2.334454e-01
block|,
comment|/* 0-3 */
literal|3.090170e-01
block|,
literal|3.826834e-01
block|,
literal|4.539905e-01
block|,
literal|5.224986e-01
block|,
comment|/* 4-7 */
literal|5.877853e-01
block|,
literal|6.494480e-01
block|,
literal|7.071068e-01
block|,
literal|7.604060e-01
block|,
comment|/* 8-11 */
literal|8.090170e-01
block|,
literal|8.526402e-01
block|,
literal|8.910065e-01
block|,
literal|9.238795e-01
block|,
comment|/* 12-15 */
literal|9.510565e-01
block|,
literal|9.723699e-01
block|,
literal|9.876883e-01
block|,
literal|9.969173e-01
block|,
comment|/* 16-19 */
literal|1.000000e+00
block|,
literal|9.969173e-01
block|,
literal|9.876883e-01
block|,
literal|9.723699e-01
block|,
comment|/* 20-23 */
literal|9.510565e-01
block|,
literal|9.238795e-01
block|,
literal|8.910065e-01
block|,
literal|8.526402e-01
block|,
comment|/* 24-27 */
literal|8.090170e-01
block|,
literal|7.604060e-01
block|,
literal|7.071068e-01
block|,
literal|6.494480e-01
block|,
comment|/* 28-31 */
literal|5.877853e-01
block|,
literal|5.224986e-01
block|,
literal|4.539905e-01
block|,
literal|3.826834e-01
block|,
comment|/* 32-35 */
literal|3.090170e-01
block|,
literal|2.334454e-01
block|,
literal|1.564345e-01
block|,
literal|7.845910e-02
block|,
comment|/* 36-39 */
operator|-
literal|0.000000e+00
block|,
operator|-
literal|7.845910e-02
block|,
operator|-
literal|1.564345e-01
block|,
operator|-
literal|2.334454e-01
block|,
comment|/* 40-43 */
operator|-
literal|3.090170e-01
block|,
operator|-
literal|3.826834e-01
block|,
operator|-
literal|4.539905e-01
block|,
operator|-
literal|5.224986e-01
block|,
comment|/* 44-47 */
operator|-
literal|5.877853e-01
block|,
operator|-
literal|6.494480e-01
block|,
operator|-
literal|7.071068e-01
block|,
operator|-
literal|7.604060e-01
block|,
comment|/* 48-51 */
operator|-
literal|8.090170e-01
block|,
operator|-
literal|8.526402e-01
block|,
operator|-
literal|8.910065e-01
block|,
operator|-
literal|9.238795e-01
block|,
comment|/* 52-55 */
operator|-
literal|9.510565e-01
block|,
operator|-
literal|9.723699e-01
block|,
operator|-
literal|9.876883e-01
block|,
operator|-
literal|9.969173e-01
block|,
comment|/* 56-59 */
operator|-
literal|1.000000e+00
block|,
operator|-
literal|9.969173e-01
block|,
operator|-
literal|9.876883e-01
block|,
operator|-
literal|9.723699e-01
block|,
comment|/* 60-63 */
operator|-
literal|9.510565e-01
block|,
operator|-
literal|9.238795e-01
block|,
operator|-
literal|8.910065e-01
block|,
operator|-
literal|8.526402e-01
block|,
comment|/* 64-67 */
operator|-
literal|8.090170e-01
block|,
operator|-
literal|7.604060e-01
block|,
operator|-
literal|7.071068e-01
block|,
operator|-
literal|6.494480e-01
block|,
comment|/* 68-71 */
operator|-
literal|5.877853e-01
block|,
operator|-
literal|5.224986e-01
block|,
operator|-
literal|4.539905e-01
block|,
operator|-
literal|3.826834e-01
block|,
comment|/* 72-75 */
operator|-
literal|3.090170e-01
block|,
operator|-
literal|2.334454e-01
block|,
operator|-
literal|1.564345e-01
block|,
operator|-
literal|7.845910e-02
block|,
comment|/* 76-79 */
literal|0.000000e+00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 80 */
end_comment

begin_comment
comment|/*  * Decoder operations at the end of each second are driven by a state  * machine. The transition matrix consists of a dispatch table indexed  * by second number. Each entry in the table contains a case switch  * number and argument.  */
end_comment

begin_struct
struct|struct
name|progx
block|{
name|int
name|sw
decl_stmt|;
comment|/* case switch number */
name|int
name|arg
decl_stmt|;
comment|/* argument */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Case switch numbers  */
end_comment

begin_define
define|#
directive|define
name|IDLE
value|0
end_define

begin_comment
comment|/* no operation */
end_comment

begin_define
define|#
directive|define
name|COEF
value|1
end_define

begin_comment
comment|/* BCD bit */
end_comment

begin_define
define|#
directive|define
name|COEF1
value|2
end_define

begin_comment
comment|/* BCD bit for minute unit */
end_comment

begin_define
define|#
directive|define
name|COEF2
value|3
end_define

begin_comment
comment|/* BCD bit not used */
end_comment

begin_define
define|#
directive|define
name|DECIM9
value|4
end_define

begin_comment
comment|/* BCD digit 0-9 */
end_comment

begin_define
define|#
directive|define
name|DECIM6
value|5
end_define

begin_comment
comment|/* BCD digit 0-6 */
end_comment

begin_define
define|#
directive|define
name|DECIM3
value|6
end_define

begin_comment
comment|/* BCD digit 0-3 */
end_comment

begin_define
define|#
directive|define
name|DECIM2
value|7
end_define

begin_comment
comment|/* BCD digit 0-2 */
end_comment

begin_define
define|#
directive|define
name|MSCBIT
value|8
end_define

begin_comment
comment|/* miscellaneous bit */
end_comment

begin_define
define|#
directive|define
name|MSC20
value|9
end_define

begin_comment
comment|/* miscellaneous bit */
end_comment

begin_define
define|#
directive|define
name|MSC21
value|10
end_define

begin_comment
comment|/* QSY probe channel */
end_comment

begin_define
define|#
directive|define
name|MIN1
value|11
end_define

begin_comment
comment|/* latch time */
end_comment

begin_define
define|#
directive|define
name|MIN2
value|12
end_define

begin_comment
comment|/* leap second */
end_comment

begin_define
define|#
directive|define
name|SYNC2
value|13
end_define

begin_comment
comment|/* latch minute sync pulse */
end_comment

begin_define
define|#
directive|define
name|SYNC3
value|14
end_define

begin_comment
comment|/* latch data pulse */
end_comment

begin_comment
comment|/*  * Offsets in decoding matrix  */
end_comment

begin_define
define|#
directive|define
name|MN
value|0
end_define

begin_comment
comment|/* minute digits (2) */
end_comment

begin_define
define|#
directive|define
name|HR
value|2
end_define

begin_comment
comment|/* hour digits (2) */
end_comment

begin_define
define|#
directive|define
name|DA
value|4
end_define

begin_comment
comment|/* day digits (3) */
end_comment

begin_define
define|#
directive|define
name|YR
value|7
end_define

begin_comment
comment|/* year digits (2) */
end_comment

begin_decl_stmt
name|struct
name|progx
name|progx
index|[]
init|=
block|{
block|{
name|SYNC2
block|,
literal|0
block|}
block|,
comment|/* 0 latch minute sync pulse */
block|{
name|SYNC3
block|,
literal|0
block|}
block|,
comment|/* 1 latch data pulse */
block|{
name|MSCBIT
block|,
name|DST2
block|}
block|,
comment|/* 2 dst2 */
block|{
name|MSCBIT
block|,
name|SECWAR
block|}
block|,
comment|/* 3 lw */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 4 1 year units */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 5 2 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 6 4 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 7 8 */
block|{
name|DECIM9
block|,
name|YR
block|}
block|,
comment|/* 8 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 9 p1 */
block|{
name|COEF1
block|,
literal|0
block|}
block|,
comment|/* 10 1 minute units */
block|{
name|COEF1
block|,
literal|1
block|}
block|,
comment|/* 11 2 */
block|{
name|COEF1
block|,
literal|2
block|}
block|,
comment|/* 12 4 */
block|{
name|COEF1
block|,
literal|3
block|}
block|,
comment|/* 13 8 */
block|{
name|DECIM9
block|,
name|MN
block|}
block|,
comment|/* 14 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 15 10 minute tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 16 20 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 17 40 */
block|{
name|COEF2
block|,
literal|3
block|}
block|,
comment|/* 18 80 (not used) */
block|{
name|DECIM6
block|,
name|MN
operator|+
literal|1
block|}
block|,
comment|/* 19 p2 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 20 1 hour units */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 21 2 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 22 4 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 23 8 */
block|{
name|DECIM9
block|,
name|HR
block|}
block|,
comment|/* 24 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 25 10 hour tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 26 20 */
block|{
name|COEF2
block|,
literal|2
block|}
block|,
comment|/* 27 40 (not used) */
block|{
name|COEF2
block|,
literal|3
block|}
block|,
comment|/* 28 80 (not used) */
block|{
name|DECIM2
block|,
name|HR
operator|+
literal|1
block|}
block|,
comment|/* 29 p3 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 30 1 day units */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 31 2 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 32 4 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 33 8 */
block|{
name|DECIM9
block|,
name|DA
block|}
block|,
comment|/* 34 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 35 10 day tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 36 20 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 37 40 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 38 80 */
block|{
name|DECIM9
block|,
name|DA
operator|+
literal|1
block|}
block|,
comment|/* 39 p4 */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 40 100 day hundreds */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 41 200 */
block|{
name|COEF2
block|,
literal|2
block|}
block|,
comment|/* 42 400 (not used) */
block|{
name|COEF2
block|,
literal|3
block|}
block|,
comment|/* 43 800 (not used) */
block|{
name|DECIM3
block|,
name|DA
operator|+
literal|2
block|}
block|,
comment|/* 44 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 45 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 46 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 47 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 48 */
block|{
name|IDLE
block|,
literal|0
block|}
block|,
comment|/* 49 p5 */
block|{
name|MSCBIT
block|,
name|DUTS
block|}
block|,
comment|/* 50 dut+- */
block|{
name|COEF
block|,
literal|0
block|}
block|,
comment|/* 51 10 year tens */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 52 20 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 53 40 */
block|{
name|COEF
block|,
literal|3
block|}
block|,
comment|/* 54 80 */
block|{
name|MSC20
block|,
name|DST1
block|}
block|,
comment|/* 55 dst1 */
block|{
name|MSCBIT
block|,
name|DUT1
block|}
block|,
comment|/* 56 0.1 dut */
block|{
name|MSCBIT
block|,
name|DUT2
block|}
block|,
comment|/* 57 0.2 */
block|{
name|MSC21
block|,
name|DUT4
block|}
block|,
comment|/* 58 0.4 QSY probe channel */
block|{
name|MIN1
block|,
literal|0
block|}
block|,
comment|/* 59 p6 latch time */
block|{
name|MIN2
block|,
literal|0
block|}
comment|/* 60 leap second */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * BCD coefficients for maximum-likelihood digit decode  */
end_comment

begin_define
define|#
directive|define
name|P15
value|1.
end_define

begin_comment
comment|/* max positive number */
end_comment

begin_define
define|#
directive|define
name|N15
value|-1.
end_define

begin_comment
comment|/* max negative number */
end_comment

begin_comment
comment|/*  * Digits 0-9  */
end_comment

begin_define
define|#
directive|define
name|P9
value|(P15 / 4)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N9
value|(N15 / 4)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd9
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N9
block|,
name|N9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 0 */
block|{
name|P9
block|,
name|N9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 1 */
block|{
name|N9
block|,
name|P9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 2 */
block|{
name|P9
block|,
name|P9
block|,
name|N9
block|,
name|N9
block|}
block|,
comment|/* 3 */
block|{
name|N9
block|,
name|N9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 4 */
block|{
name|P9
block|,
name|N9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 5 */
block|{
name|N9
block|,
name|P9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 6 */
block|{
name|P9
block|,
name|P9
block|,
name|P9
block|,
name|N9
block|}
block|,
comment|/* 7 */
block|{
name|N9
block|,
name|N9
block|,
name|N9
block|,
name|P9
block|}
block|,
comment|/* 8 */
block|{
name|P9
block|,
name|N9
block|,
name|N9
block|,
name|P9
block|}
block|,
comment|/* 9 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Digits 0-6 (minute tens)  */
end_comment

begin_define
define|#
directive|define
name|P6
value|(P15 / 3)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N6
value|(N15 / 3)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd6
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N6
block|,
name|N6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|P6
block|,
name|N6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
name|N6
block|,
name|P6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
name|P6
block|,
name|P6
block|,
name|N6
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
name|N6
block|,
name|N6
block|,
name|P6
block|,
literal|0
block|}
block|,
comment|/* 4 */
block|{
name|P6
block|,
name|N6
block|,
name|P6
block|,
literal|0
block|}
block|,
comment|/* 5 */
block|{
name|N6
block|,
name|P6
block|,
name|P6
block|,
literal|0
block|}
block|,
comment|/* 6 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Digits 0-3 (day hundreds)  */
end_comment

begin_define
define|#
directive|define
name|P3
value|(P15 / 2)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N3
value|(N15 / 2)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd3
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N3
block|,
name|N3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|P3
block|,
name|N3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
name|N3
block|,
name|P3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
name|P3
block|,
name|P3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Digits 0-2 (hour tens)  */
end_comment

begin_define
define|#
directive|define
name|P2
value|(P15 / 2)
end_define

begin_comment
comment|/* mark (+1) */
end_comment

begin_define
define|#
directive|define
name|N2
value|(N15 / 2)
end_define

begin_comment
comment|/* space (-1) */
end_comment

begin_decl_stmt
name|double
name|bcd2
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|N2
block|,
name|N2
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
name|P2
block|,
name|N2
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
name|N2
block|,
name|P2
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* backstop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * DST decode (DST2 DST1) for prettyprint  */
end_comment

begin_decl_stmt
name|char
name|dstcod
index|[]
init|=
block|{
literal|'S'
block|,
comment|/* 00 standard time */
literal|'I'
block|,
comment|/* 01 set clock ahead at 0200 local */
literal|'O'
block|,
comment|/* 10 set clock back at 0200 local */
literal|'D'
comment|/* 11 daylight time */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The decoding matrix consists of nine row vectors, one for each digit  * of the timecode. The digits are stored from least to most significant  * order. The maximum-likelihood timecode is formed from the digits  * corresponding to the maximum-likelihood values reading in the  * opposite order: yy ddd hh:mm.  */
end_comment

begin_struct
struct|struct
name|decvec
block|{
name|int
name|radix
decl_stmt|;
comment|/* radix (3, 4, 6, 10) */
name|int
name|digit
decl_stmt|;
comment|/* current clock digit */
name|int
name|count
decl_stmt|;
comment|/* match count */
name|double
name|digprb
decl_stmt|;
comment|/* max digit probability */
name|double
name|digsnr
decl_stmt|;
comment|/* likelihood function (dB) */
name|double
name|like
index|[
literal|10
index|]
decl_stmt|;
comment|/* likelihood integrator 0-9 */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The station structure (sp) is used to acquire the minute pulse from  * WWV and/or WWVH. These stations are distinguished by the frequency  * used for the second and minute sync pulses, 1000 Hz for WWV and 1200  * Hz for WWVH. Other than frequency, the format is the same.  */
end_comment

begin_struct
struct|struct
name|sync
block|{
name|double
name|epoch
decl_stmt|;
comment|/* accumulated epoch differences */
name|double
name|maxeng
decl_stmt|;
comment|/* sync max energy */
name|double
name|noieng
decl_stmt|;
comment|/* sync noise energy */
name|long
name|pos
decl_stmt|;
comment|/* max amplitude position */
name|long
name|lastpos
decl_stmt|;
comment|/* last max position */
name|long
name|mepoch
decl_stmt|;
comment|/* minute synch epoch */
name|double
name|amp
decl_stmt|;
comment|/* sync signal */
name|double
name|syneng
decl_stmt|;
comment|/* sync signal max */
name|double
name|synmax
decl_stmt|;
comment|/* sync signal max latched at 0 s */
name|double
name|synsnr
decl_stmt|;
comment|/* sync signal SNR */
name|double
name|metric
decl_stmt|;
comment|/* signal quality metric */
name|int
name|reach
decl_stmt|;
comment|/* reachability register */
name|int
name|count
decl_stmt|;
comment|/* bit counter */
name|int
name|select
decl_stmt|;
comment|/* select bits */
name|char
name|refid
index|[
literal|5
index|]
decl_stmt|;
comment|/* reference identifier */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The channel structure (cp) is used to mitigate between channels.  */
end_comment

begin_struct
struct|struct
name|chan
block|{
name|int
name|gain
decl_stmt|;
comment|/* audio gain */
name|struct
name|sync
name|wwv
decl_stmt|;
comment|/* wwv station */
name|struct
name|sync
name|wwvh
decl_stmt|;
comment|/* wwvh station */
block|}
struct|;
end_struct

begin_comment
comment|/*  * WWV unit control structure (up)  */
end_comment

begin_struct
struct|struct
name|wwvunit
block|{
name|l_fp
name|timestamp
decl_stmt|;
comment|/* audio sample timestamp */
name|l_fp
name|tick
decl_stmt|;
comment|/* audio sample increment */
name|double
name|phase
decl_stmt|,
name|freq
decl_stmt|;
comment|/* logical clock phase and frequency */
name|double
name|monitor
decl_stmt|;
comment|/* audio monitor point */
name|double
name|pdelay
decl_stmt|;
comment|/* propagation delay (s) */
ifdef|#
directive|ifdef
name|ICOM
name|int
name|fd_icom
decl_stmt|;
comment|/* ICOM file descriptor */
endif|#
directive|endif
comment|/* ICOM */
name|int
name|errflg
decl_stmt|;
comment|/* error flags */
name|int
name|watch
decl_stmt|;
comment|/* watchcat */
comment|/* 	 * Audio codec variables 	 */
name|double
name|comp
index|[
name|SIZE
index|]
decl_stmt|;
comment|/* decompanding table */
name|int
name|port
decl_stmt|;
comment|/* codec port */
name|int
name|gain
decl_stmt|;
comment|/* codec gain */
name|int
name|mongain
decl_stmt|;
comment|/* codec monitor gain */
name|int
name|clipcnt
decl_stmt|;
comment|/* sample clipped count */
comment|/* 	 * Variables used to establish basic system timing 	 */
name|int
name|avgint
decl_stmt|;
comment|/* master time constant */
name|int
name|yepoch
decl_stmt|;
comment|/* sync epoch */
name|int
name|repoch
decl_stmt|;
comment|/* buffered sync epoch */
name|double
name|epomax
decl_stmt|;
comment|/* second sync amplitude */
name|double
name|eposnr
decl_stmt|;
comment|/* second sync SNR */
name|double
name|irig
decl_stmt|;
comment|/* data I channel amplitude */
name|double
name|qrig
decl_stmt|;
comment|/* data Q channel amplitude */
name|int
name|datapt
decl_stmt|;
comment|/* 100 Hz ramp */
name|double
name|datpha
decl_stmt|;
comment|/* 100 Hz VFO control */
name|int
name|rphase
decl_stmt|;
comment|/* second sample counter */
name|long
name|mphase
decl_stmt|;
comment|/* minute sample counter */
comment|/* 	 * Variables used to mitigate which channel to use 	 */
name|struct
name|chan
name|mitig
index|[
name|NCHAN
index|]
decl_stmt|;
comment|/* channel data */
name|struct
name|sync
modifier|*
name|sptr
decl_stmt|;
comment|/* station pointer */
name|int
name|dchan
decl_stmt|;
comment|/* data channel */
name|int
name|schan
decl_stmt|;
comment|/* probe channel */
name|int
name|achan
decl_stmt|;
comment|/* active channel */
comment|/* 	 * Variables used by the clock state machine 	 */
name|struct
name|decvec
name|decvec
index|[
literal|9
index|]
decl_stmt|;
comment|/* decoding matrix */
name|int
name|rsec
decl_stmt|;
comment|/* seconds counter */
name|int
name|digcnt
decl_stmt|;
comment|/* count of digits synchronized */
comment|/* 	 * Variables used to estimate signal levels and bit/digit 	 * probabilities 	 */
name|double
name|datsig
decl_stmt|;
comment|/* data signal max */
name|double
name|datsnr
decl_stmt|;
comment|/* data signal SNR (dB) */
comment|/* 	 * Variables used to establish status and alarm conditions 	 */
name|int
name|status
decl_stmt|;
comment|/* status bits */
name|int
name|alarm
decl_stmt|;
comment|/* alarm flashers */
name|int
name|misc
decl_stmt|;
comment|/* miscellaneous timecode bits */
name|int
name|errcnt
decl_stmt|;
comment|/* data bit error counter */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|wwv_start
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_shutdown
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_poll
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * More function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|wwv_epoch
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_rf
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_endpoc
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_rsec
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_qrz
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|struct
name|sync
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_corr4
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|struct
name|decvec
modifier|*
parameter_list|,
name|double
index|[]
parameter_list|,
name|double
index|[]
index|[
literal|4
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_gain
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_tsec
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|timecode
parameter_list|(
name|struct
name|wwvunit
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|wwv_snr
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|carry
parameter_list|(
name|struct
name|decvec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wwv_newchan
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_newgame
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|wwv_metric
parameter_list|(
name|struct
name|sync
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wwv_clock
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_function_decl
specifier|static
name|int
name|wwv_qsy
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_decl_stmt
specifier|static
name|double
name|qsy
index|[
name|NCHAN
index|]
init|=
block|{
literal|2.5
block|,
literal|5
block|,
literal|10
block|,
literal|15
block|,
literal|20
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequencies (MHz) */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_wwv
init|=
block|{
name|wwv_start
block|,
comment|/* start up driver */
name|wwv_shutdown
block|,
comment|/* shut down driver */
name|wwv_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old wwv_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old wwv_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * wwv_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|wwv_start
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (used by PCM) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
ifdef|#
directive|ifdef
name|ICOM
name|int
name|temp
decl_stmt|;
endif|#
directive|endif
comment|/* ICOM */
comment|/* 	 * Local variables 	 */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|i
decl_stmt|;
comment|/* index */
name|double
name|step
decl_stmt|;
comment|/* codec adjustment */
comment|/* 	 * Open audio device 	 */
name|fd
operator|=
name|audio_init
argument_list|(
name|DEVICE_AUDIO
argument_list|,
name|AUDIO_BUFSIZ
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|audio_show
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Allocate and initialize unit structure 	 */
name|up
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|wwv_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
comment|/* 	 * The companded samples are encoded sign-magnitude. The table 	 * contains all the 256 values in the interest of speed. 	 */
name|up
operator|->
name|comp
index|[
literal|0
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|OFFSET
index|]
operator|=
literal|0.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|1
index|]
operator|=
literal|1.
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|1
index|]
operator|=
operator|-
literal|1.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|2
index|]
operator|=
literal|3.
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|2
index|]
operator|=
operator|-
literal|3.
expr_stmt|;
name|step
operator|=
literal|2.
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|OFFSET
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|comp
index|[
name|i
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|step
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
name|i
index|]
operator|=
operator|-
name|up
operator|->
name|comp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
name|step
operator|*=
literal|2.
expr_stmt|;
block|}
name|DTOLFP
argument_list|(
literal|1.
operator|/
name|WWV_SEC
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the decoding matrix with the radix for each digit 	 * position. 	 */
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* minutes */
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|6
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* hours */
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|3
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* days */
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|radix
operator|=
literal|4
expr_stmt|;
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
comment|/* years */
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
operator|.
name|radix
operator|=
literal|10
expr_stmt|;
ifdef|#
directive|ifdef
name|ICOM
comment|/* 	 * Initialize autotune if available. Note that the ICOM select 	 * code must be less than 128, so the high order bit can be used 	 * to select the line speed 0 (9600 bps) or 1 (1200 bps). Note 	 * we don't complain if the ICOM device is not there; but, if it 	 * is, the radio better be working. 	 */
name|temp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|temp
operator|=
name|P_TRACE
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|peer
operator|->
name|ttl
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|ttl
operator|&
literal|0x80
condition|)
name|up
operator|->
name|fd_icom
operator|=
name|icom_init
argument_list|(
literal|"/dev/icom"
argument_list|,
name|B1200
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|fd_icom
operator|=
name|icom_init
argument_list|(
literal|"/dev/icom"
argument_list|,
name|B9600
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|DCHAN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"icom: radio not found"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|)
expr_stmt|;
name|up
operator|->
name|fd_icom
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"icom: autotune enabled"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ICOM */
comment|/* 	 * Let the games begin. 	 */
name|wwv_newgame
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|wwv_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|==
name|NULL
condition|)
return|return;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICOM
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
name|close
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ICOM */
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_receive - receive data from the audio device  *  * This routine reads input samples and adjusts the logical clock to  * track the A/D sample clock by dropping or duplicating codec samples.  * It also controls the A/D signal level with an AGC loop to mimimize  * quantization noise and avoid overload.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|sample
decl_stmt|;
comment|/* codec sample */
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* buffer pointer */
name|int
name|bufcnt
decl_stmt|;
comment|/* buffer counter */
name|l_fp
name|ltemp
decl_stmt|;
name|peer
operator|=
name|rbufp
operator|->
name|recv_peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Main loop - read until there ain't no more. Note codec 	 * samples are bit-inverted. 	 */
name|DTOLFP
argument_list|(
operator|(
name|double
operator|)
name|rbufp
operator|->
name|recv_length
operator|/
name|WWV_SEC
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|up
operator|->
name|timestamp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|dpt
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
for|for
control|(
name|bufcnt
operator|=
literal|0
init|;
name|bufcnt
operator|<
name|rbufp
operator|->
name|recv_length
condition|;
name|bufcnt
operator|++
control|)
block|{
name|sample
operator|=
name|up
operator|->
name|comp
index|[
operator|~
operator|*
name|dpt
operator|++
operator|&
literal|0xff
index|]
expr_stmt|;
comment|/* 		 * Clip noise spikes greater than MAXAMP (6000) and 		 * record the number of clips to be used later by the 		 * AGC. 		 */
if|if
condition|(
name|sample
operator|>
name|MAXAMP
condition|)
block|{
name|sample
operator|=
name|MAXAMP
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sample
operator|<
operator|-
name|MAXAMP
condition|)
block|{
name|sample
operator|=
operator|-
name|MAXAMP
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
comment|/* 		 * Variable frequency oscillator. The codec oscillator 		 * runs at the nominal rate of 8000 samples per second, 		 * or 125 us per sample. A frequency change of one unit 		 * results in either duplicating or deleting one sample 		 * per second, which results in a frequency change of 		 * 125 PPM. 		 */
name|up
operator|->
name|phase
operator|+=
operator|(
name|up
operator|->
name|freq
operator|+
name|clock_codec
operator|)
operator|/
name|WWV_SEC
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|phase
operator|>=
literal|.5
condition|)
block|{
name|up
operator|->
name|phase
operator|-=
literal|1.
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|phase
operator|<
operator|-
literal|.5
condition|)
block|{
name|up
operator|->
name|phase
operator|+=
literal|1.
expr_stmt|;
name|wwv_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
name|wwv_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wwv_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
name|L_ADD
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the input port and monitor gain for the next buffer. 	 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
name|up
operator|->
name|port
operator|=
literal|2
expr_stmt|;
else|else
name|up
operator|->
name|port
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
condition|)
name|up
operator|->
name|mongain
operator|=
name|MONGAIN
expr_stmt|;
else|else
name|up
operator|->
name|mongain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_poll - called by the transmit procedure  *  * This routine keeps track of status. If no offset samples have been  * processed during a poll interval, a timeout event is declared. If  * errors have have occurred during the interval, they are reported as  * well.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_poll
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errflg
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|errflg
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_rf - process signals and demodulate to baseband  *  * This routine grooms and filters decompanded raw audio samples. The  * output signal is the 100-Hz filtered baseband data signal in  * quadrature phase. The routine also determines the minute synch epoch,  * as well as certain signal maxima, minima and related values.  *  * There are two 1-s ramps used by this program. Both count the 8000  * logical clock samples spanning exactly one second. The epoch ramp  * counts the samples starting at an arbitrary time. The rphase ramp  * counts the samples starting at the 5-ms second sync pulse found  * during the epoch ramp.  *  * There are two 1-m ramps used by this program. The mphase ramp counts  * the 480,000 logical clock samples spanning exactly one minute and  * starting at an arbitrary time. The rsec ramp counts the 60 seconds of  * the minute starting at the 800-ms minute sync pulse found during the  * mphase ramp. The rsec ramp drives the seconds state machine to  * determine the bits and digits of the timecode.   *  * Demodulation operations are based on three synthesized quadrature  * sinusoids: 100 Hz for the data signal, 1000 Hz for the WWV sync  * signal and 1200 Hz for the WWVH sync signal. These drive synchronous  * matched filters for the data signal (170 ms at 100 Hz), WWV minute  * sync signal (800 ms at 1000 Hz) and WWVH minute sync signal (800 ms  * at 1200 Hz). Two additional matched filters are switched in  * as required for the WWV second sync signal (5 cycles at 1000 Hz) and  * WWVH second sync signal (6 cycles at 1200 Hz).  */
end_comment

begin_function
specifier|static
name|void
name|wwv_rf
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peerstructure pointer */
name|double
name|isig
comment|/* input signal */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|sync
modifier|*
name|sp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
specifier|static
name|double
name|lpf
index|[
literal|5
index|]
decl_stmt|;
comment|/* 150-Hz lpf delay line */
name|double
name|data
decl_stmt|;
comment|/* lpf output */
specifier|static
name|double
name|bpf
index|[
literal|9
index|]
decl_stmt|;
comment|/* 1000/1200-Hz bpf delay line */
name|double
name|syncx
decl_stmt|;
comment|/* bpf output */
specifier|static
name|double
name|mf
index|[
literal|41
index|]
decl_stmt|;
comment|/* 1000/1200-Hz mf delay line */
name|double
name|mfsync
decl_stmt|;
comment|/* mf output */
specifier|static
name|int
name|iptr
decl_stmt|;
comment|/* data channel pointer */
specifier|static
name|double
name|ibuf
index|[
name|DATSIZ
index|]
decl_stmt|;
comment|/* data I channel delay line */
specifier|static
name|double
name|qbuf
index|[
name|DATSIZ
index|]
decl_stmt|;
comment|/* data Q channel delay line */
specifier|static
name|int
name|jptr
decl_stmt|;
comment|/* sync channel pointer */
specifier|static
name|int
name|kptr
decl_stmt|;
comment|/* tick channel pointer */
specifier|static
name|int
name|csinptr
decl_stmt|;
comment|/* wwv channel phase */
specifier|static
name|double
name|cibuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwv I channel delay line */
specifier|static
name|double
name|cqbuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwv Q channel delay line */
specifier|static
name|double
name|ciamp
decl_stmt|;
comment|/* wwv I channel amplitude */
specifier|static
name|double
name|cqamp
decl_stmt|;
comment|/* wwv Q channel amplitude */
specifier|static
name|double
name|csibuf
index|[
name|TCKSIZ
index|]
decl_stmt|;
comment|/* wwv I tick delay line */
specifier|static
name|double
name|csqbuf
index|[
name|TCKSIZ
index|]
decl_stmt|;
comment|/* wwv Q tick delay line */
specifier|static
name|double
name|csiamp
decl_stmt|;
comment|/* wwv I tick amplitude */
specifier|static
name|double
name|csqamp
decl_stmt|;
comment|/* wwv Q tick amplitude */
specifier|static
name|int
name|hsinptr
decl_stmt|;
comment|/* wwvh channel phase */
specifier|static
name|double
name|hibuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwvh I channel delay line */
specifier|static
name|double
name|hqbuf
index|[
name|SYNSIZ
index|]
decl_stmt|;
comment|/* wwvh Q channel delay line */
specifier|static
name|double
name|hiamp
decl_stmt|;
comment|/* wwvh I channel amplitude */
specifier|static
name|double
name|hqamp
decl_stmt|;
comment|/* wwvh Q channel amplitude */
specifier|static
name|double
name|hsibuf
index|[
name|TCKSIZ
index|]
decl_stmt|;
comment|/* wwvh I tick delay line */
specifier|static
name|double
name|hsqbuf
index|[
name|TCKSIZ
index|]
decl_stmt|;
comment|/* wwvh Q tick delay line */
specifier|static
name|double
name|hsiamp
decl_stmt|;
comment|/* wwvh I tick amplitude */
specifier|static
name|double
name|hsqamp
decl_stmt|;
comment|/* wwvh Q tick amplitude */
specifier|static
name|double
name|epobuf
index|[
name|WWV_SEC
index|]
decl_stmt|;
comment|/* second sync comb filter */
specifier|static
name|double
name|epomax
decl_stmt|,
name|nxtmax
decl_stmt|;
comment|/* second sync amplitude buffer */
specifier|static
name|int
name|epopos
decl_stmt|;
comment|/* epoch second sync position buffer */
specifier|static
name|int
name|iniflg
decl_stmt|;
comment|/* initialization flag */
name|int
name|epoch
decl_stmt|;
comment|/* comb filter index */
name|double
name|dtemp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
name|iniflg
condition|)
block|{
name|iniflg
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lpf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lpf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bpf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bpf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cqbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cqbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|csibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|csibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|csqbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|csqbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hqbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hqbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hsibuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hsibuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hsqbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hsqbuf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|epobuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|epobuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Baseband data demodulation. The 100-Hz subcarrier is 	 * extracted using a 150-Hz IIR lowpass filter. This attenuates 	 * the 1000/1200-Hz sync signals, as well as the 440-Hz and 	 * 600-Hz tones and most of the noise and voice modulation 	 * components. 	 * 	 * The subcarrier is transmitted 10 dB down from the carrier. 	 * The DGAIN parameter can be adjusted for this and to 	 * compensate for the radio audio response at 100 Hz. 	 * 	 * Matlab IIR 4th-order IIR elliptic, 150 Hz lowpass, 0.2 dB 	 * passband ripple, -50 dB stopband ripple, phase delay 0.97 ms. 	 */
name|data
operator|=
operator|(
name|lpf
index|[
literal|4
index|]
operator|=
name|lpf
index|[
literal|3
index|]
operator|)
operator|*
literal|8.360961e-01
expr_stmt|;
name|data
operator|+=
operator|(
name|lpf
index|[
literal|3
index|]
operator|=
name|lpf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|3.481740e+00
expr_stmt|;
name|data
operator|+=
operator|(
name|lpf
index|[
literal|2
index|]
operator|=
name|lpf
index|[
literal|1
index|]
operator|)
operator|*
literal|5.452988e+00
expr_stmt|;
name|data
operator|+=
operator|(
name|lpf
index|[
literal|1
index|]
operator|=
name|lpf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|3.807229e+00
expr_stmt|;
name|lpf
index|[
literal|0
index|]
operator|=
name|isig
operator|*
name|DGAIN
operator|-
name|data
expr_stmt|;
name|data
operator|=
name|lpf
index|[
literal|0
index|]
operator|*
literal|3.281435e-03
operator|+
name|lpf
index|[
literal|1
index|]
operator|*
operator|-
literal|1.149947e-02
operator|+
name|lpf
index|[
literal|2
index|]
operator|*
literal|1.654858e-02
operator|+
name|lpf
index|[
literal|3
index|]
operator|*
operator|-
literal|1.149947e-02
operator|+
name|lpf
index|[
literal|4
index|]
operator|*
literal|3.281435e-03
expr_stmt|;
comment|/* 	 * The 100-Hz data signal is demodulated using a pair of 	 * quadrature multipliers, matched filters and a phase lock 	 * loop. The I and Q quadrature data signals are produced by 	 * multiplying the filtered signal by 100-Hz sine and cosine 	 * signals, respectively. The signals are processed by 170-ms 	 * synchronous matched filters to produce the amplitude and 	 * phase signals used by the demodulator. The signals are scaled 	 * to produce unit energy at the maximum value. 	 */
name|i
operator|=
name|up
operator|->
name|datapt
expr_stmt|;
name|up
operator|->
name|datapt
operator|=
operator|(
name|up
operator|->
name|datapt
operator|+
name|IN100
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|data
operator|/
operator|(
name|MS
operator|/
literal|2.
operator|*
name|DATCYC
operator|)
expr_stmt|;
name|up
operator|->
name|irig
operator|-=
name|ibuf
index|[
name|iptr
index|]
expr_stmt|;
name|ibuf
index|[
name|iptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|up
operator|->
name|irig
operator|+=
name|dtemp
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|20
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|data
operator|/
operator|(
name|MS
operator|/
literal|2.
operator|*
name|DATCYC
operator|)
expr_stmt|;
name|up
operator|->
name|qrig
operator|-=
name|qbuf
index|[
name|iptr
index|]
expr_stmt|;
name|qbuf
index|[
name|iptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|up
operator|->
name|qrig
operator|+=
name|dtemp
expr_stmt|;
name|iptr
operator|=
operator|(
name|iptr
operator|+
literal|1
operator|)
operator|%
name|DATSIZ
expr_stmt|;
comment|/* 	 * Baseband sync demodulation. The 1000/1200 sync signals are 	 * extracted using a 600-Hz IIR bandpass filter. This removes 	 * the 100-Hz data subcarrier, as well as the 440-Hz and 600-Hz 	 * tones and most of the noise and voice modulation components. 	 * 	 * Matlab 4th-order IIR elliptic, 800-1400 Hz bandpass, 0.2 dB 	 * passband ripple, -50 dB stopband ripple, phase delay 0.91 ms. 	 */
name|syncx
operator|=
operator|(
name|bpf
index|[
literal|8
index|]
operator|=
name|bpf
index|[
literal|7
index|]
operator|)
operator|*
literal|4.897278e-01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|7
index|]
operator|=
name|bpf
index|[
literal|6
index|]
operator|)
operator|*
operator|-
literal|2.765914e+00
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|6
index|]
operator|=
name|bpf
index|[
literal|5
index|]
operator|)
operator|*
literal|8.110921e+00
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|5
index|]
operator|=
name|bpf
index|[
literal|4
index|]
operator|)
operator|*
operator|-
literal|1.517732e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|4
index|]
operator|=
name|bpf
index|[
literal|3
index|]
operator|)
operator|*
literal|1.975197e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|3
index|]
operator|=
name|bpf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|1.814365e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|2
index|]
operator|=
name|bpf
index|[
literal|1
index|]
operator|)
operator|*
literal|1.159783e+01
expr_stmt|;
name|syncx
operator|+=
operator|(
name|bpf
index|[
literal|1
index|]
operator|=
name|bpf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|4.735040e+00
expr_stmt|;
name|bpf
index|[
literal|0
index|]
operator|=
name|isig
operator|-
name|syncx
expr_stmt|;
name|syncx
operator|=
name|bpf
index|[
literal|0
index|]
operator|*
literal|8.203628e-03
operator|+
name|bpf
index|[
literal|1
index|]
operator|*
operator|-
literal|2.375732e-02
operator|+
name|bpf
index|[
literal|2
index|]
operator|*
literal|3.353214e-02
operator|+
name|bpf
index|[
literal|3
index|]
operator|*
operator|-
literal|4.080258e-02
operator|+
name|bpf
index|[
literal|4
index|]
operator|*
literal|4.605479e-02
operator|+
name|bpf
index|[
literal|5
index|]
operator|*
operator|-
literal|4.080258e-02
operator|+
name|bpf
index|[
literal|6
index|]
operator|*
literal|3.353214e-02
operator|+
name|bpf
index|[
literal|7
index|]
operator|*
operator|-
literal|2.375732e-02
operator|+
name|bpf
index|[
literal|8
index|]
operator|*
literal|8.203628e-03
expr_stmt|;
comment|/* 	 * The 1000/1200 sync signals are demodulated using a pair of 	 * quadrature multipliers and matched filters. However, 	 * synchronous demodulation at these frequencies is impractical, 	 * so only the signal amplitude is used. The I and Q quadrature 	 * sync signals are produced by multiplying the filtered signal 	 * by 1000-Hz (WWV) and 1200-Hz (WWVH) sine and cosine signals, 	 * respectively. The WWV and WWVH signals are processed by 800- 	 * ms synchronous matched filters and combined to produce the 	 * minute sync signal and detect which one (or both) the WWV or 	 * WWVH signal is present. The WWV and WWVH signals are also 	 * processed by 5-ms synchronous matched filters and combined to 	 * produce the second sync signal. The signals are scaled to 	 * produce unit energy at the maximum value. 	 * 	 * Note the master timing ramps, which run continuously. The 	 * minute counter (mphase) counts the samples in the minute, 	 * while the second counter (epoch) counts the samples in the 	 * second. 	 */
name|up
operator|->
name|mphase
operator|=
operator|(
name|up
operator|->
name|mphase
operator|+
literal|1
operator|)
operator|%
name|WWV_MIN
expr_stmt|;
name|epoch
operator|=
name|up
operator|->
name|mphase
operator|%
name|WWV_SEC
expr_stmt|;
comment|/* 	 * WWV 	 */
name|i
operator|=
name|csinptr
expr_stmt|;
name|csinptr
operator|=
operator|(
name|csinptr
operator|+
name|IN1000
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
operator|(
name|MS
operator|/
literal|2.
operator|)
expr_stmt|;
name|ciamp
operator|-=
name|cibuf
index|[
name|jptr
index|]
expr_stmt|;
name|cibuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|ciamp
operator|+=
name|dtemp
expr_stmt|;
name|csiamp
operator|-=
name|csibuf
index|[
name|kptr
index|]
expr_stmt|;
name|csibuf
index|[
name|kptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|csiamp
operator|+=
name|dtemp
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|20
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
operator|(
name|MS
operator|/
literal|2.
operator|)
expr_stmt|;
name|cqamp
operator|-=
name|cqbuf
index|[
name|jptr
index|]
expr_stmt|;
name|cqbuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|cqamp
operator|+=
name|dtemp
expr_stmt|;
name|csqamp
operator|-=
name|csqbuf
index|[
name|kptr
index|]
expr_stmt|;
name|csqbuf
index|[
name|kptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|csqamp
operator|+=
name|dtemp
expr_stmt|;
name|sp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|wwv
expr_stmt|;
name|sp
operator|->
name|amp
operator|=
name|sqrt
argument_list|(
name|ciamp
operator|*
name|ciamp
operator|+
name|cqamp
operator|*
name|cqamp
argument_list|)
operator|/
name|SYNCYC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
name|wwv_qrz
argument_list|(
name|peer
argument_list|,
name|sp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|fudgetime1
operator|*
name|WWV_SEC
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * WWVH 	 */
name|i
operator|=
name|hsinptr
expr_stmt|;
name|hsinptr
operator|=
operator|(
name|hsinptr
operator|+
name|IN1200
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
operator|(
name|MS
operator|/
literal|2.
operator|)
expr_stmt|;
name|hiamp
operator|-=
name|hibuf
index|[
name|jptr
index|]
expr_stmt|;
name|hibuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|hiamp
operator|+=
name|dtemp
expr_stmt|;
name|hsiamp
operator|-=
name|hsibuf
index|[
name|kptr
index|]
expr_stmt|;
name|hsibuf
index|[
name|kptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|hsiamp
operator|+=
name|dtemp
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|20
operator|)
operator|%
literal|80
expr_stmt|;
name|dtemp
operator|=
name|sintab
index|[
name|i
index|]
operator|*
name|syncx
operator|/
operator|(
name|MS
operator|/
literal|2.
operator|)
expr_stmt|;
name|hqamp
operator|-=
name|hqbuf
index|[
name|jptr
index|]
expr_stmt|;
name|hqbuf
index|[
name|jptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|hqamp
operator|+=
name|dtemp
expr_stmt|;
name|hsqamp
operator|-=
name|hsqbuf
index|[
name|kptr
index|]
expr_stmt|;
name|hsqbuf
index|[
name|kptr
index|]
operator|=
name|dtemp
expr_stmt|;
name|hsqamp
operator|+=
name|dtemp
expr_stmt|;
name|rp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|wwvh
expr_stmt|;
name|rp
operator|->
name|amp
operator|=
name|sqrt
argument_list|(
name|hiamp
operator|*
name|hiamp
operator|+
name|hqamp
operator|*
name|hqamp
argument_list|)
operator|/
name|SYNCYC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
name|wwv_qrz
argument_list|(
name|peer
argument_list|,
name|rp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|fudgetime2
operator|*
name|WWV_SEC
argument_list|)
argument_list|)
expr_stmt|;
name|jptr
operator|=
operator|(
name|jptr
operator|+
literal|1
operator|)
operator|%
name|SYNSIZ
expr_stmt|;
name|kptr
operator|=
operator|(
name|kptr
operator|+
literal|1
operator|)
operator|%
name|TCKSIZ
expr_stmt|;
comment|/* 	 * The following section is called once per minute. It does 	 * housekeeping and timeout functions and empties the dustbins. 	 */
if|if
condition|(
name|up
operator|->
name|mphase
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|watch
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
block|{
comment|/* 			 * If minute sync has not been acquired before 			 * ACQSN timeout (6 min), or if no signal is 			 * heard, the program cycles to the next 			 * frequency and tries again. 			 */
if|if
condition|(
operator|!
name|wwv_newchan
argument_list|(
name|peer
argument_list|)
condition|)
name|up
operator|->
name|watch
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If the leap bit is set, set the minute epoch 			 * back one second so the station processes 			 * don't miss a beat. 			 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|LEPSEC
condition|)
block|{
name|up
operator|->
name|mphase
operator|-=
name|WWV_SEC
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|mphase
operator|<
literal|0
condition|)
name|up
operator|->
name|mphase
operator|+=
name|WWV_MIN
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * When the channel metric reaches threshold and the second 	 * counter matches the minute epoch within the second, the 	 * driver has synchronized to the station. The second number is 	 * the remaining seconds until the next minute epoch, while the 	 * sync epoch is zero. Watch out for the first second; if 	 * already synchronized to the second, the buffered sync epoch 	 * must be set. 	 * 	 * Note the guard interval is 200 ms; if for some reason the 	 * clock drifts more than that, it might wind up in the wrong 	 * second. If the maximum frequency error is not more than about 	 * 1 PPM, the clock can go as much as two days while still in 	 * the same second. 	 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|MSYNC
condition|)
block|{
name|wwv_epoch
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|sptr
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|up
operator|->
name|sptr
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|metric
operator|>=
name|TTHR
operator|&&
name|epoch
operator|==
name|sp
operator|->
name|mepoch
operator|%
name|WWV_SEC
condition|)
block|{
name|up
operator|->
name|rsec
operator|=
operator|(
literal|60
operator|-
name|sp
operator|->
name|mepoch
operator|/
name|WWV_SEC
operator|)
operator|%
literal|60
expr_stmt|;
name|up
operator|->
name|rphase
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|status
operator||=
name|MSYNC
expr_stmt|;
name|up
operator|->
name|watch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SSYNC
operator|)
condition|)
name|up
operator|->
name|repoch
operator|=
name|up
operator|->
name|yepoch
operator|=
name|epoch
expr_stmt|;
else|else
name|up
operator|->
name|repoch
operator|=
name|up
operator|->
name|yepoch
expr_stmt|;
block|}
block|}
comment|/* 	 * The second sync pulse is extracted using 5-ms (40 sample) FIR 	 * matched filters at 1000 Hz for WWV or 1200 Hz for WWVH. This 	 * pulse is used for the most precise synchronization, since if 	 * provides a resolution of one sample (125 us). The filters run 	 * only if the station has been reliably determined. 	 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|SELV
condition|)
name|mfsync
operator|=
name|sqrt
argument_list|(
name|csiamp
operator|*
name|csiamp
operator|+
name|csqamp
operator|*
name|csqamp
argument_list|)
operator|/
name|TCKCYC
expr_stmt|;
elseif|else
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|SELH
condition|)
name|mfsync
operator|=
name|sqrt
argument_list|(
name|hsiamp
operator|*
name|hsiamp
operator|+
name|hsqamp
operator|*
name|hsqamp
argument_list|)
operator|/
name|TCKCYC
expr_stmt|;
else|else
name|mfsync
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Enhance the seconds sync pulse using a 1-s (8000-sample) comb 	 * filter. Correct for the FIR matched filter delay, which is 5 	 * ms for both the WWV and WWVH filters, and also for the 	 * propagation delay. Once each second look for second sync. If 	 * not in minute sync, fiddle the codec gain. Note the SNR is 	 * computed from the maximum sample and the envelope of the 	 * sample 6 ms before it, so if we slip more than a cycle the 	 * SNR should plummet. The signal is scaled to produce unit 	 * energy at the maximum value. 	 */
name|dtemp
operator|=
operator|(
name|epobuf
index|[
name|epoch
index|]
operator|+=
operator|(
name|mfsync
operator|-
name|epobuf
index|[
name|epoch
index|]
operator|)
operator|/
name|up
operator|->
name|avgint
operator|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
name|epomax
condition|)
block|{
name|int
name|j
decl_stmt|;
name|epomax
operator|=
name|dtemp
expr_stmt|;
name|epopos
operator|=
name|epoch
expr_stmt|;
name|j
operator|=
name|epoch
operator|-
literal|6
operator|*
name|MS
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|j
operator|+=
name|WWV_SEC
expr_stmt|;
name|nxtmax
operator|=
name|fabs
argument_list|(
name|epobuf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|epoch
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|epomax
operator|=
name|epomax
expr_stmt|;
name|up
operator|->
name|eposnr
operator|=
name|wwv_snr
argument_list|(
name|epomax
argument_list|,
name|nxtmax
argument_list|)
expr_stmt|;
name|epopos
operator|-=
name|TCKCYC
operator|*
name|MS
expr_stmt|;
if|if
condition|(
name|epopos
operator|<
literal|0
condition|)
name|epopos
operator|+=
name|WWV_SEC
expr_stmt|;
name|wwv_endpoc
argument_list|(
name|peer
argument_list|,
name|epopos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SSYNC
operator|)
condition|)
name|up
operator|->
name|alarm
operator||=
name|SYNERR
expr_stmt|;
name|epomax
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
name|wwv_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_qrz - identify and acquire WWV/WWVH minute sync pulse  *  * This routine implements a virtual station process used to acquire  * minute sync and to mitigate among the ten frequency and station  * combinations. During minute sync acquisition the process probes each  * frequency and station in turn for the minute pulse, which  * involves searching through the entire 480,000-sample minute. The  * process finds the maximum signal and RMS noise plus signal. Then, the  * actual noise is determined by subtracting the energy of the matched  * filter.  *  * Students of radar receiver technology will discover this algorithm  * amounts to a range-gate discriminator. A valid pulse must have peak  * amplitude at least QTHR (2500) and SNR at least QSNR (20) dB and the  * difference between the current and previous epoch must be less than  * AWND (20 ms). Note that the discriminator peak occurs about 800 ms  * into the second, so the timing is retarded to the previous second  * epoch.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_qrz
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|struct
name|sync
modifier|*
name|sp
parameter_list|,
comment|/* sync channel structure */
name|int
name|pdelay
comment|/* propagation delay (samples) */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|char
name|tbuf
index|[
name|TBUF
index|]
decl_stmt|;
comment|/* monitor buffer */
name|long
name|epoch
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Find the sample with peak amplitude, which defines the minute 	 * epoch. Accumulate all samples to determine the total noise 	 * energy. 	 */
name|epoch
operator|=
name|up
operator|->
name|mphase
operator|-
name|pdelay
operator|-
name|SYNSIZ
expr_stmt|;
if|if
condition|(
name|epoch
operator|<
literal|0
condition|)
name|epoch
operator|+=
name|WWV_MIN
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|amp
operator|>
name|sp
operator|->
name|maxeng
condition|)
block|{
name|sp
operator|->
name|maxeng
operator|=
name|sp
operator|->
name|amp
expr_stmt|;
name|sp
operator|->
name|pos
operator|=
name|epoch
expr_stmt|;
block|}
name|sp
operator|->
name|noieng
operator|+=
name|sp
operator|->
name|amp
expr_stmt|;
comment|/* 	 * At the end of the minute, determine the epoch of the minute 	 * sync pulse, as well as the difference between the current and 	 * previous epoches due to the intrinsic frequency error plus 	 * jitter. When calculating the SNR, subtract the pulse energy 	 * from the total noise energy and then normalize. 	 */
if|if
condition|(
name|up
operator|->
name|mphase
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|synmax
operator|=
name|sp
operator|->
name|maxeng
expr_stmt|;
name|sp
operator|->
name|synsnr
operator|=
name|wwv_snr
argument_list|(
name|sp
operator|->
name|synmax
argument_list|,
operator|(
name|sp
operator|->
name|noieng
operator|-
name|sp
operator|->
name|synmax
operator|)
operator|/
name|WWV_MIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|count
operator|==
literal|0
condition|)
name|sp
operator|->
name|lastpos
operator|=
name|sp
operator|->
name|pos
expr_stmt|;
name|epoch
operator|=
operator|(
name|sp
operator|->
name|pos
operator|-
name|sp
operator|->
name|lastpos
operator|)
operator|%
name|WWV_MIN
expr_stmt|;
name|sp
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|reach
operator|&
operator|(
literal|1
operator|<<
name|AMAX
operator|)
condition|)
name|sp
operator|->
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|synmax
operator|>
name|ATHR
operator|&&
name|sp
operator|->
name|synsnr
operator|>
name|ASNR
condition|)
block|{
if|if
condition|(
name|labs
argument_list|(
name|epoch
argument_list|)
operator|<
name|AWND
operator|*
name|MS
condition|)
block|{
name|sp
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|sp
operator|->
name|count
operator|++
expr_stmt|;
name|sp
operator|->
name|mepoch
operator|=
name|sp
operator|->
name|lastpos
operator|=
name|sp
operator|->
name|pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|count
operator|==
literal|1
condition|)
block|{
name|sp
operator|->
name|lastpos
operator|=
name|sp
operator|->
name|pos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|up
operator|->
name|watch
operator|>
name|ACQSN
condition|)
name|sp
operator|->
name|metric
operator|=
literal|0
expr_stmt|;
else|else
name|sp
operator|->
name|metric
operator|=
name|wwv_metric
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"wwv8 %04x %3d %s %04x %.0f %.0f/%.1f %ld %ld"
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|sp
operator|->
name|refid
argument_list|,
name|sp
operator|->
name|reach
operator|&
literal|0xffff
argument_list|,
name|sp
operator|->
name|metric
argument_list|,
name|sp
operator|->
name|synmax
argument_list|,
name|sp
operator|->
name|synsnr
argument_list|,
name|sp
operator|->
name|pos
operator|%
name|WWV_SEC
argument_list|,
name|epoch
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|sp
operator|->
name|maxeng
operator|=
name|sp
operator|->
name|noieng
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_endpoc - identify and acquire second sync pulse  *  * This routine is called at the end of the second sync interval. It  * determines the second sync epoch position within the second and  * disciplines the sample clock using a frequency-lock loop (FLL).  *  * Second sync is determined in the RF input routine as the maximum  * over all 8000 samples in the second comb filter. To assure accurate  * and reliable time and frequency discipline, this routine performs a  * great deal of heavy-handed heuristic data filtering and grooming.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_endpoc
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|epopos
comment|/* epoch max position */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
specifier|static
name|int
name|epoch_mf
index|[
literal|3
index|]
decl_stmt|;
comment|/* epoch median filter */
specifier|static
name|int
name|tepoch
decl_stmt|;
comment|/* current second epoch */
specifier|static
name|int
name|xepoch
decl_stmt|;
comment|/* last second epoch */
specifier|static
name|int
name|zepoch
decl_stmt|;
comment|/* last run epoch */
specifier|static
name|int
name|zcount
decl_stmt|;
comment|/* last run end time */
specifier|static
name|int
name|scount
decl_stmt|;
comment|/* seconds counter */
specifier|static
name|int
name|syncnt
decl_stmt|;
comment|/* run length counter */
specifier|static
name|int
name|maxrun
decl_stmt|;
comment|/* longest run length */
specifier|static
name|int
name|mepoch
decl_stmt|;
comment|/* longest run end epoch */
specifier|static
name|int
name|mcount
decl_stmt|;
comment|/* longest run end time */
specifier|static
name|int
name|avgcnt
decl_stmt|;
comment|/* averaging interval counter */
specifier|static
name|int
name|avginc
decl_stmt|;
comment|/* averaging ratchet */
specifier|static
name|int
name|iniflg
decl_stmt|;
comment|/* initialization flag */
name|char
name|tbuf
index|[
name|TBUF
index|]
decl_stmt|;
comment|/* monitor buffer */
name|double
name|dtemp
decl_stmt|;
name|int
name|tmp2
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
name|iniflg
condition|)
block|{
name|iniflg
operator|=
literal|1
expr_stmt|;
name|ZERO
argument_list|(
name|epoch_mf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the signal amplitude or SNR fall below thresholds, dim the 	 * second sync lamp and wait for hotter ions. If no stations are 	 * heard, we are either in a probe cycle or the ions are really 	 * cold.  	 */
name|scount
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|epomax
operator|<
name|STHR
operator|||
name|up
operator|->
name|eposnr
operator|<
name|SSNR
condition|)
block|{
name|up
operator|->
name|status
operator|&=
operator|~
operator|(
name|SSYNC
operator||
name|FGATE
operator|)
expr_stmt|;
name|avgcnt
operator|=
name|syncnt
operator|=
name|maxrun
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
operator|(
name|SELV
operator||
name|SELH
operator|)
operator|)
condition|)
return|return;
comment|/* 	 * A three-stage median filter is used to help denoise the 	 * second sync pulse. The median sample becomes the candidate 	 * epoch. 	 */
name|epoch_mf
index|[
literal|2
index|]
operator|=
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
name|epoch_mf
index|[
literal|1
index|]
operator|=
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
name|epoch_mf
index|[
literal|0
index|]
operator|=
name|epopos
expr_stmt|;
if|if
condition|(
name|epoch_mf
index|[
literal|0
index|]
operator|>
name|epoch_mf
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|epoch_mf
index|[
literal|1
index|]
operator|>
name|epoch_mf
index|[
literal|2
index|]
condition|)
name|tepoch
operator|=
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
comment|/* 0 1 2 */
elseif|else
if|if
condition|(
name|epoch_mf
index|[
literal|2
index|]
operator|>
name|epoch_mf
index|[
literal|0
index|]
condition|)
name|tepoch
operator|=
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
comment|/* 2 0 1 */
else|else
name|tepoch
operator|=
name|epoch_mf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 0 2 1 */
block|}
else|else
block|{
if|if
condition|(
name|epoch_mf
index|[
literal|1
index|]
operator|<
name|epoch_mf
index|[
literal|2
index|]
condition|)
name|tepoch
operator|=
name|epoch_mf
index|[
literal|1
index|]
expr_stmt|;
comment|/* 2 1 0 */
elseif|else
if|if
condition|(
name|epoch_mf
index|[
literal|2
index|]
operator|<
name|epoch_mf
index|[
literal|0
index|]
condition|)
name|tepoch
operator|=
name|epoch_mf
index|[
literal|0
index|]
expr_stmt|;
comment|/* 1 0 2 */
else|else
name|tepoch
operator|=
name|epoch_mf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 1 2 0 */
block|}
comment|/* 	 * If the epoch candidate is the same as the last one, increment 	 * the run counter. If not, save the length, epoch and end 	 * time of the current run for use later and reset the counter. 	 * The epoch is considered valid if the run is at least SCMP 	 * (10) s, the minute is synchronized and the interval since the 	 * last epoch  is not greater than the averaging interval. Thus, 	 * after a long absence, the program will wait a full averaging 	 * interval while the comb filter charges up and noise 	 * dissapates.. 	 */
name|tmp2
operator|=
operator|(
name|tepoch
operator|-
name|xepoch
operator|)
operator|%
name|WWV_SEC
expr_stmt|;
if|if
condition|(
name|tmp2
operator|==
literal|0
condition|)
block|{
name|syncnt
operator|++
expr_stmt|;
if|if
condition|(
name|syncnt
operator|>
name|SCMP
operator|&&
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|&&
operator|(
name|up
operator|->
name|status
operator|&
name|FGATE
operator|||
name|scount
operator|-
name|zcount
operator|<=
name|up
operator|->
name|avgint
operator|)
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|SSYNC
expr_stmt|;
name|up
operator|->
name|yepoch
operator|=
name|tepoch
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|syncnt
operator|>=
name|maxrun
condition|)
block|{
name|maxrun
operator|=
name|syncnt
expr_stmt|;
name|mcount
operator|=
name|scount
expr_stmt|;
name|mepoch
operator|=
name|xepoch
expr_stmt|;
name|syncnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
operator|)
operator|&&
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|MSYNC
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"wwv1 %04x %3d %4d %5.0f %5.1f %5d %4d %4d %4d"
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|tepoch
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|up
operator|->
name|eposnr
argument_list|,
name|tmp2
argument_list|,
name|avgcnt
argument_list|,
name|syncnt
argument_list|,
name|maxrun
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|avgcnt
operator|++
expr_stmt|;
if|if
condition|(
name|avgcnt
operator|<
name|up
operator|->
name|avgint
condition|)
block|{
name|xepoch
operator|=
name|tepoch
expr_stmt|;
return|return;
block|}
comment|/* 	 * The sample clock frequency is disciplined using a first-order 	 * feedback loop with time constant consistent with the Allan 	 * intercept of typical computer clocks. During each averaging 	 * interval the candidate epoch at the end of the longest run is 	 * determined. If the longest run is zero, all epoches in the 	 * interval are different, so the candidate epoch is the current 	 * epoch. The frequency update is computed from the candidate 	 * epoch difference (125-us units) and time difference (seconds) 	 * between updates. 	 */
if|if
condition|(
name|syncnt
operator|>=
name|maxrun
condition|)
block|{
name|maxrun
operator|=
name|syncnt
expr_stmt|;
name|mcount
operator|=
name|scount
expr_stmt|;
name|mepoch
operator|=
name|xepoch
expr_stmt|;
block|}
name|xepoch
operator|=
name|tepoch
expr_stmt|;
if|if
condition|(
name|maxrun
operator|==
literal|0
condition|)
block|{
name|mepoch
operator|=
name|tepoch
expr_stmt|;
name|mcount
operator|=
name|scount
expr_stmt|;
block|}
comment|/* 	 * The master clock runs at the codec sample frequency of 8000 	 * Hz, so the intrinsic time resolution is 125 us. The frequency 	 * resolution ranges from 18 PPM at the minimum averaging 	 * interval of 8 s to 0.12 PPM at the maximum interval of 1024 	 * s. An offset update is determined at the end of the longest 	 * run in each averaging interval. The frequency adjustment is 	 * computed from the difference between offset updates and the 	 * interval between them. 	 * 	 * The maximum frequency adjustment ranges from 187 PPM at the 	 * minimum interval to 1.5 PPM at the maximum. If the adjustment 	 * exceeds the maximum, the update is discarded and the 	 * hysteresis counter is decremented. Otherwise, the frequency 	 * is incremented by the adjustment, but clamped to the maximum 	 * 187.5 PPM. If the update is less than half the maximum, the 	 * hysteresis counter is incremented. If the counter increments 	 * to +3, the averaging interval is doubled and the counter set 	 * to zero; if it decrements to -3, the interval is halved and 	 * the counter set to zero. 	 */
name|dtemp
operator|=
operator|(
name|mepoch
operator|-
name|zepoch
operator|)
operator|%
name|WWV_SEC
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|FGATE
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|dtemp
argument_list|)
operator|<
name|MAXFREQ
operator|*
name|MINAVG
condition|)
block|{
name|up
operator|->
name|freq
operator|+=
operator|(
name|dtemp
operator|/
literal|2.
operator|)
operator|/
operator|(
operator|(
name|mcount
operator|-
name|zcount
operator|)
operator|*
name|FCONST
operator|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|freq
operator|>
name|MAXFREQ
condition|)
name|up
operator|->
name|freq
operator|=
name|MAXFREQ
expr_stmt|;
elseif|else
if|if
condition|(
name|up
operator|->
name|freq
operator|<
operator|-
name|MAXFREQ
condition|)
name|up
operator|->
name|freq
operator|=
operator|-
name|MAXFREQ
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|dtemp
argument_list|)
operator|<
name|MAXFREQ
operator|*
name|MINAVG
operator|/
literal|2.
condition|)
block|{
if|if
condition|(
name|avginc
operator|<
literal|3
condition|)
block|{
name|avginc
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|up
operator|->
name|avgint
operator|<
name|MAXAVG
condition|)
block|{
name|up
operator|->
name|avgint
operator|<<=
literal|1
expr_stmt|;
name|avginc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|avginc
operator|>
operator|-
literal|3
condition|)
block|{
name|avginc
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|up
operator|->
name|avgint
operator|>
name|MINAVG
condition|)
block|{
name|up
operator|->
name|avgint
operator|>>=
literal|1
expr_stmt|;
name|avginc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"wwv2 %04x %5.0f %5.1f %5d %4d %4d %4d %4.0f %7.2f"
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|up
operator|->
name|eposnr
argument_list|,
name|mepoch
argument_list|,
name|up
operator|->
name|avgint
argument_list|,
name|maxrun
argument_list|,
name|mcount
operator|-
name|zcount
argument_list|,
name|dtemp
argument_list|,
name|up
operator|->
name|freq
operator|*
literal|1e6
operator|/
name|WWV_SEC
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
comment|/* 	 * This is a valid update; set up for the next interval. 	 */
name|up
operator|->
name|status
operator||=
name|FGATE
expr_stmt|;
name|zepoch
operator|=
name|mepoch
expr_stmt|;
name|zcount
operator|=
name|mcount
expr_stmt|;
name|avgcnt
operator|=
name|syncnt
operator|=
name|maxrun
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_epoch - epoch scanner  *  * This routine extracts data signals from the 100-Hz subcarrier. It  * scans the receiver second epoch to determine the signal amplitudes  * and pulse timings. Receiver synchronization is determined by the  * minute sync pulse detected in the wwv_rf() routine and the second  * sync pulse detected in the wwv_epoch() routine. The transmitted  * signals are delayed by the propagation delay, receiver delay and  * filter delay of this program. Delay corrections are introduced  * separately for WWV and WWVH.   *  * Most communications radios use a highpass filter in the audio stages,  * which can do nasty things to the subcarrier phase relative to the  * sync pulses. Therefore, the data subcarrier reference phase is  * disciplined using the hardlimited quadrature-phase signal sampled at  * the same time as the in-phase signal. The phase tracking loop uses  * phase adjustments of plus-minus one sample (125 us).   */
end_comment

begin_function
specifier|static
name|void
name|wwv_epoch
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
specifier|static
name|double
name|sigmin
decl_stmt|,
name|sigzer
decl_stmt|,
name|sigone
decl_stmt|,
name|engmax
decl_stmt|,
name|engmin
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Find the maximum minute sync pulse energy for both the 	 * WWV and WWVH stations. This will be used later for channel 	 * and station mitigation. Also set the seconds epoch at 800 ms 	 * well before the end of the second to make sure we never set 	 * the epoch backwards. 	 */
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|wwv
operator|.
name|amp
operator|>
name|cp
operator|->
name|wwv
operator|.
name|syneng
condition|)
name|cp
operator|->
name|wwv
operator|.
name|syneng
operator|=
name|cp
operator|->
name|wwv
operator|.
name|amp
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|wwvh
operator|.
name|amp
operator|>
name|cp
operator|->
name|wwvh
operator|.
name|syneng
condition|)
name|cp
operator|->
name|wwvh
operator|.
name|syneng
operator|=
name|cp
operator|->
name|wwvh
operator|.
name|amp
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|rphase
operator|==
literal|800
operator|*
name|MS
condition|)
name|up
operator|->
name|repoch
operator|=
name|up
operator|->
name|yepoch
expr_stmt|;
comment|/* 	 * Use the signal amplitude at epoch 15 ms as the noise floor. 	 * This gives a guard time of +-15 ms from the beginning of the 	 * second until the second pulse rises at 30 ms. There is a 	 * compromise here; we want to delay the sample as long as 	 * possible to give the radio time to change frequency and the 	 * AGC to stabilize, but as early as possible if the second 	 * epoch is not exact. 	 */
if|if
condition|(
name|up
operator|->
name|rphase
operator|==
literal|15
operator|*
name|MS
condition|)
name|sigmin
operator|=
name|sigzer
operator|=
name|sigone
operator|=
name|up
operator|->
name|irig
expr_stmt|;
comment|/* 	 * Latch the data signal at 200 ms. Keep this around until the 	 * end of the second. Use the signal energy as the peak to 	 * compute the SNR. Use the Q sample to adjust the 100-Hz 	 * reference oscillator phase. 	 */
if|if
condition|(
name|up
operator|->
name|rphase
operator|==
literal|200
operator|*
name|MS
condition|)
block|{
name|sigzer
operator|=
name|up
operator|->
name|irig
expr_stmt|;
name|engmax
operator|=
name|sqrt
argument_list|(
name|up
operator|->
name|irig
operator|*
name|up
operator|->
name|irig
operator|+
name|up
operator|->
name|qrig
operator|*
name|up
operator|->
name|qrig
argument_list|)
expr_stmt|;
name|up
operator|->
name|datpha
operator|=
name|up
operator|->
name|qrig
operator|/
name|up
operator|->
name|avgint
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|datpha
operator|>=
literal|0
condition|)
block|{
name|up
operator|->
name|datapt
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|datapt
operator|>=
literal|80
condition|)
name|up
operator|->
name|datapt
operator|-=
literal|80
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|datapt
operator|--
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|datapt
operator|<
literal|0
condition|)
name|up
operator|->
name|datapt
operator|+=
literal|80
expr_stmt|;
block|}
block|}
comment|/* 	 * Latch the data signal at 500 ms. Keep this around until the 	 * end of the second. 	 */
elseif|else
if|if
condition|(
name|up
operator|->
name|rphase
operator|==
literal|500
operator|*
name|MS
condition|)
name|sigone
operator|=
name|up
operator|->
name|irig
expr_stmt|;
comment|/* 	 * At the end of the second crank the clock state machine and 	 * adjust the codec gain. Note the epoch is buffered from the 	 * center of the second in order to avoid jitter while the 	 * seconds synch is diddling the epoch. Then, determine the true 	 * offset and update the median filter in the driver interface. 	 * 	 * Use the energy at the end of the second as the noise to 	 * compute the SNR for the data pulse. This gives a better 	 * measurement than the beginning of the second, especially when 	 * returning from the probe channel. This gives a guard time of 	 * 30 ms from the decay of the longest pulse to the rise of the 	 * next pulse. 	 */
name|up
operator|->
name|rphase
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|mphase
operator|%
name|WWV_SEC
operator|==
name|up
operator|->
name|repoch
condition|)
block|{
name|up
operator|->
name|status
operator|&=
operator|~
operator|(
name|DGATE
operator||
name|BGATE
operator|)
expr_stmt|;
name|engmin
operator|=
name|sqrt
argument_list|(
name|up
operator|->
name|irig
operator|*
name|up
operator|->
name|irig
operator|+
name|up
operator|->
name|qrig
operator|*
name|up
operator|->
name|qrig
argument_list|)
expr_stmt|;
name|up
operator|->
name|datsig
operator|=
name|engmax
expr_stmt|;
name|up
operator|->
name|datsnr
operator|=
name|wwv_snr
argument_list|(
name|engmax
argument_list|,
name|engmin
argument_list|)
expr_stmt|;
comment|/* 		 * If the amplitude or SNR is below threshold, average a 		 * 0 in the the integrators; otherwise, average the 		 * bipolar signal. This is done to avoid noise polution. 		 */
if|if
condition|(
name|engmax
operator|<
name|DTHR
operator|||
name|up
operator|->
name|datsnr
operator|<
name|DSNR
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|DGATE
expr_stmt|;
name|wwv_rsec
argument_list|(
name|peer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sigzer
operator|-=
name|sigone
expr_stmt|;
name|sigone
operator|-=
name|sigmin
expr_stmt|;
name|wwv_rsec
argument_list|(
name|peer
argument_list|,
name|sigone
operator|-
name|sigzer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|status
operator|&
operator|(
name|DGATE
operator||
name|BGATE
operator|)
condition|)
name|up
operator|->
name|errcnt
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errcnt
operator|>
name|MAXERR
condition|)
name|up
operator|->
name|alarm
operator||=
name|LOWERR
expr_stmt|;
name|wwv_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
name|cp
operator|->
name|wwv
operator|.
name|syneng
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|wwvh
operator|.
name|syneng
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|rphase
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_rsec - process receiver second  *  * This routine is called at the end of each receiver second to  * implement the per-second state machine. The machine assembles BCD  * digit bits, decodes miscellaneous bits and dances the leap seconds.  *  * Normally, the minute has 60 seconds numbered 0-59. If the leap  * warning bit is set, the last minute (1439) of 30 June (day 181 or 182  * for leap years) or 31 December (day 365 or 366 for leap years) is  * augmented by one second numbered 60. This is accomplished by  * extending the minute interval by one second and teaching the state  * machine to ignore it.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_rsec
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|bit
parameter_list|)
block|{
specifier|static
name|int
name|iniflg
decl_stmt|;
comment|/* initialization flag */
specifier|static
name|double
name|bcddld
index|[
literal|4
index|]
decl_stmt|;
comment|/* BCD data bits */
specifier|static
name|double
name|bitvec
index|[
literal|61
index|]
decl_stmt|;
comment|/* bit integrator for misc bits */
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
name|struct
name|sync
modifier|*
name|sp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|char
name|tbuf
index|[
name|TBUF
index|]
decl_stmt|;
comment|/* monitor buffer */
name|int
name|sw
decl_stmt|,
name|arg
decl_stmt|,
name|nsec
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
name|iniflg
condition|)
block|{
name|iniflg
operator|=
literal|1
expr_stmt|;
name|ZERO
argument_list|(
name|bitvec
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The bit represents the probability of a hit on zero (negative 	 * values), a hit on one (positive values) or a miss (zero 	 * value). The likelihood vector is the exponential average of 	 * these probabilities. Only the bits of this vector 	 * corresponding to the miscellaneous bits of the timecode are 	 * used, but it's easier to do them all. After that, crank the 	 * seconds state machine. 	 */
name|nsec
operator|=
name|up
operator|->
name|rsec
expr_stmt|;
name|up
operator|->
name|rsec
operator|++
expr_stmt|;
name|bitvec
index|[
name|nsec
index|]
operator|+=
operator|(
name|bit
operator|-
name|bitvec
index|[
name|nsec
index|]
operator|)
operator|/
name|TCONST
expr_stmt|;
name|sw
operator|=
name|progx
index|[
name|nsec
index|]
operator|.
name|sw
expr_stmt|;
name|arg
operator|=
name|progx
index|[
name|nsec
index|]
operator|.
name|arg
expr_stmt|;
comment|/* 	 * The minute state machine. Fly off to a particular section as 	 * directed by the transition matrix and second number. 	 */
switch|switch
condition|(
name|sw
condition|)
block|{
comment|/* 	 * Ignore this second. 	 */
case|case
name|IDLE
case|:
comment|/* 9, 45-49 */
break|break;
comment|/* 	 * Probe channel stuff 	 * 	 * The WWV/H format contains data pulses in second 59 (position 	 * identifier) and second 1, but not in second 0. The minute 	 * sync pulse is contained in second 0. At the end of second 58 	 * QSY to the probe channel, which rotates in turn over all 	 * WWV/H frequencies. At the end of second 0 measure the minute 	 * sync pulse. At the end of second 1 measure the data pulse and 	 * QSY back to the data channel. Note that the actions commented 	 * here happen at the end of the second numbered as shown. 	 * 	 * At the end of second 0 save the minute sync amplitude latched 	 * at 800 ms as the signal later used to calculate the SNR.  	 */
case|case
name|SYNC2
case|:
comment|/* 0 */
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
name|cp
operator|->
name|wwv
operator|.
name|synmax
operator|=
name|cp
operator|->
name|wwv
operator|.
name|syneng
expr_stmt|;
name|cp
operator|->
name|wwvh
operator|.
name|synmax
operator|=
name|cp
operator|->
name|wwvh
operator|.
name|syneng
expr_stmt|;
break|break;
comment|/* 	 * At the end of second 1 use the minute sync amplitude latched 	 * at 800 ms as the noise to calculate the SNR. If the minute 	 * sync pulse and SNR are above thresholds and the data pulse 	 * amplitude and SNR are above thresolds, shift a 1 into the 	 * station reachability register; otherwise, shift a 0. The 	 * number of 1 bits in the last six intervals is a component of 	 * the channel metric computed by the wwv_metric() routine. 	 * Finally, QSY back to the data channel. 	 */
case|case
name|SYNC3
case|:
comment|/* 1 */
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
expr_stmt|;
comment|/* 		 * WWV station 		 */
name|sp
operator|=
operator|&
name|cp
operator|->
name|wwv
expr_stmt|;
name|sp
operator|->
name|synsnr
operator|=
name|wwv_snr
argument_list|(
name|sp
operator|->
name|synmax
argument_list|,
name|sp
operator|->
name|amp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|reach
operator|&
operator|(
literal|1
operator|<<
name|AMAX
operator|)
condition|)
name|sp
operator|->
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|synmax
operator|>=
name|QTHR
operator|&&
name|sp
operator|->
name|synsnr
operator|>=
name|QSNR
operator|&&
operator|!
operator|(
name|up
operator|->
name|status
operator|&
operator|(
name|DGATE
operator||
name|BGATE
operator|)
operator|)
condition|)
block|{
name|sp
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|sp
operator|->
name|count
operator|++
expr_stmt|;
block|}
name|sp
operator|->
name|metric
operator|=
name|wwv_metric
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 		 * WWVH station 		 */
name|rp
operator|=
operator|&
name|cp
operator|->
name|wwvh
expr_stmt|;
name|rp
operator|->
name|synsnr
operator|=
name|wwv_snr
argument_list|(
name|rp
operator|->
name|synmax
argument_list|,
name|rp
operator|->
name|amp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|reach
operator|&
operator|(
literal|1
operator|<<
name|AMAX
operator|)
condition|)
name|rp
operator|->
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|synmax
operator|>=
name|QTHR
operator|&&
name|rp
operator|->
name|synsnr
operator|>=
name|QSNR
operator|&&
operator|!
operator|(
name|up
operator|->
name|status
operator|&
operator|(
name|DGATE
operator||
name|BGATE
operator|)
operator|)
condition|)
block|{
name|rp
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|rp
operator|->
name|count
operator|++
expr_stmt|;
block|}
name|rp
operator|->
name|metric
operator|=
name|wwv_metric
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"wwv5 %04x %3d %4d %.0f/%.1f %.0f/%.1f %s %04x %.0f %.0f/%.1f %s %04x %.0f %.0f/%.1f"
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|yepoch
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|up
operator|->
name|eposnr
argument_list|,
name|up
operator|->
name|datsig
argument_list|,
name|up
operator|->
name|datsnr
argument_list|,
name|sp
operator|->
name|refid
argument_list|,
name|sp
operator|->
name|reach
operator|&
literal|0xffff
argument_list|,
name|sp
operator|->
name|metric
argument_list|,
name|sp
operator|->
name|synmax
argument_list|,
name|sp
operator|->
name|synsnr
argument_list|,
name|rp
operator|->
name|refid
argument_list|,
name|rp
operator|->
name|reach
operator|&
literal|0xffff
argument_list|,
name|rp
operator|->
name|metric
argument_list|,
name|rp
operator|->
name|synmax
argument_list|,
name|rp
operator|->
name|synsnr
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|up
operator|->
name|errcnt
operator|=
name|up
operator|->
name|digcnt
operator|=
name|up
operator|->
name|alarm
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If synchronized to a station, restart if no stations 		 * have been heard within the PANIC timeout (2 days). If 		 * not and the minute digit has been found, restart if 		 * not synchronized withing the SYNCH timeout (40 m). If 		 * not, restart if the unit digit has not been found 		 * within the DATA timeout (15 m). 		 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|INSYNC
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|watch
operator|>
name|PANIC
condition|)
block|{
name|wwv_newgame
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|DSYNC
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|watch
operator|>
name|SYNCH
condition|)
block|{
name|wwv_newgame
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|watch
operator|>
name|DATA
condition|)
block|{
name|wwv_newgame
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
name|wwv_newchan
argument_list|(
name|peer
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Save the bit probability in the BCD data vector at the index 	 * given by the argument. Bits not used in the digit are forced 	 * to zero. 	 */
case|case
name|COEF1
case|:
comment|/* 4-7 */
name|bcddld
index|[
name|arg
index|]
operator|=
name|bit
expr_stmt|;
break|break;
case|case
name|COEF
case|:
comment|/* 10-13, 15-17, 20-23, 25-26, 					   30-33, 35-38, 40-41, 51-54 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|DSYNC
condition|)
name|bcddld
index|[
name|arg
index|]
operator|=
name|bit
expr_stmt|;
else|else
name|bcddld
index|[
name|arg
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|COEF2
case|:
comment|/* 18, 27-28, 42-43 */
name|bcddld
index|[
name|arg
index|]
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 	 * Correlate coefficient vector with each valid digit vector and 	 * save in decoding matrix. We step through the decoding matrix 	 * digits correlating each with the coefficients and saving the 	 * greatest and the next lower for later SNR calculation. 	 */
case|case
name|DECIM2
case|:
comment|/* 29 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIM3
case|:
comment|/* 44 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd3
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIM6
case|:
comment|/* 19 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd6
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIM9
case|:
comment|/* 8, 14, 24, 34, 39 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|arg
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd9
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Miscellaneous bits. If above the positive threshold, declare 	 * 1; if below the negative threshold, declare 0; otherwise 	 * raise the BGATE bit. The design is intended to avoid 	 * integrating noise under low SNR conditions. 	 */
case|case
name|MSC20
case|:
comment|/* 55 */
name|wwv_corr4
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
argument_list|,
name|bcddld
argument_list|,
name|bcd9
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|MSCBIT
case|:
comment|/* 2-3, 50, 56-57 */
if|if
condition|(
name|bitvec
index|[
name|nsec
index|]
operator|>
name|BTHR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|misc
operator|&
name|arg
operator|)
condition|)
name|up
operator|->
name|alarm
operator||=
name|CMPERR
expr_stmt|;
name|up
operator|->
name|misc
operator||=
name|arg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitvec
index|[
name|nsec
index|]
operator|<
operator|-
name|BTHR
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|misc
operator|&
name|arg
condition|)
name|up
operator|->
name|alarm
operator||=
name|CMPERR
expr_stmt|;
name|up
operator|->
name|misc
operator|&=
operator|~
name|arg
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|status
operator||=
name|BGATE
expr_stmt|;
block|}
break|break;
comment|/* 	 * Save the data channel gain, then QSY to the probe channel and 	 * dim the seconds comb filters. The www_newchan() routine will 	 * light them back up. 	 */
case|case
name|MSC21
case|:
comment|/* 58 */
if|if
condition|(
name|bitvec
index|[
name|nsec
index|]
operator|>
name|BTHR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|misc
operator|&
name|arg
operator|)
condition|)
name|up
operator|->
name|alarm
operator||=
name|CMPERR
expr_stmt|;
name|up
operator|->
name|misc
operator||=
name|arg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitvec
index|[
name|nsec
index|]
operator|<
operator|-
name|BTHR
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|misc
operator|&
name|arg
condition|)
name|up
operator|->
name|alarm
operator||=
name|CMPERR
expr_stmt|;
name|up
operator|->
name|misc
operator|&=
operator|~
name|arg
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|status
operator||=
name|BGATE
expr_stmt|;
block|}
name|up
operator|->
name|status
operator|&=
operator|~
operator|(
name|SELV
operator||
name|SELH
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICOM
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|schan
operator|=
operator|(
name|up
operator|->
name|schan
operator|+
literal|1
operator|)
operator|%
name|NCHAN
expr_stmt|;
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|schan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|gain
operator|=
name|up
operator|->
name|gain
expr_stmt|;
block|}
else|#
directive|else
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|gain
operator|=
name|up
operator|->
name|gain
expr_stmt|;
endif|#
directive|endif
comment|/* ICOM */
break|break;
comment|/* 	 * The endgames 	 * 	 * During second 59 the receiver and codec AGC are settling 	 * down, so the data pulse is unusable as quality metric. If 	 * LEPSEC is set on the last minute of 30 June or 31 December, 	 * the transmitter and receiver insert an extra second (60) in 	 * the timescale and the minute sync repeats the second. Once 	 * leaps occurred at intervals of about 18 months, but the last 	 * leap before the most recent leap in 1995 was in  1998. 	 */
case|case
name|MIN1
case|:
comment|/* 59 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|LEPSEC
condition|)
break|break;
comment|/* fall through */
case|case
name|MIN2
case|:
comment|/* 60 */
name|up
operator|->
name|status
operator|&=
operator|~
name|LEPSEC
expr_stmt|;
name|wwv_tsec
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|rsec
operator|=
literal|0
expr_stmt|;
name|wwv_clock
argument_list|(
name|peer
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
operator|)
operator|&&
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|DSYNC
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"wwv3 %2d %04x %3d %4d %5.0f %5.1f %5.0f %5.1f %5.0f"
argument_list|,
name|nsec
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|yepoch
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|up
operator|->
name|eposnr
argument_list|,
name|up
operator|->
name|datsig
argument_list|,
name|up
operator|->
name|datsnr
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|pp
operator|->
name|disp
operator|+=
name|AUDIO_PHI
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The radio clock is set if the alarm bits are all zero. After that,  * the time is considered valid if the second sync bit is lit. It should  * not be a surprise, especially if the radio is not tunable, that  * sometimes no stations are above the noise and the integrators  * discharge below the thresholds. We assume that, after a day of signal  * loss, the minute sync epoch will be in the same second. This requires  * the codec frequency be accurate within 6 PPM. Practical experience  * shows the frequency typically within 0.1 PPM, so after a day of  * signal loss, the time should be within 8.6 ms..   */
end_comment

begin_function
specifier|static
name|void
name|wwv_clock
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer unit pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|l_fp
name|offset
decl_stmt|;
comment|/* offset in NTP seconds */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|SSYNC
operator|)
condition|)
name|up
operator|->
name|alarm
operator||=
name|SYNERR
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|digcnt
operator|<
literal|9
condition|)
name|up
operator|->
name|alarm
operator||=
name|NINERR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|alarm
operator|)
condition|)
name|up
operator|->
name|status
operator||=
name|INSYNC
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|&&
name|up
operator|->
name|status
operator|&
name|SSYNC
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|misc
operator|&
name|SECWAR
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
else|else
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|pp
operator|->
name|second
operator|=
name|up
operator|->
name|rsec
expr_stmt|;
name|pp
operator|->
name|minute
operator|=
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|pp
operator|->
name|hour
operator|=
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|pp
operator|->
name|day
operator|=
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|digit
operator|*
literal|100
expr_stmt|;
name|pp
operator|->
name|year
operator|=
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|pp
operator|->
name|year
operator|+=
literal|2000
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|GMT
argument_list|,
name|up
operator|->
name|timestamp
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|&
name|offset
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|up
operator|->
name|errflg
operator|=
name|CEVNT_BADTIME
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|watch
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|disp
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|lastref
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|offset
argument_list|,
name|up
operator|->
name|timestamp
argument_list|,
name|PDELAY
operator|+
name|up
operator|->
name|pdelay
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
name|pp
operator|->
name|lencode
operator|=
name|timecode
argument_list|(
name|up
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"wwv: timecode %d %s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_comment
comment|/*  * wwv_corr4 - determine maximum-likelihood digit  *  * This routine correlates the received digit vector with the BCD  * coefficient vectors corresponding to all valid digits at the given  * position in the decoding matrix. The maximum value corresponds to the  * maximum-likelihood digit, while the ratio of this value to the next  * lower value determines the likelihood function. Note that, if the  * digit is invalid, the likelihood vector is averaged toward a miss.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_corr4
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer unit pointer */
name|struct
name|decvec
modifier|*
name|vp
parameter_list|,
comment|/* decoding table pointer */
name|double
name|data
index|[]
parameter_list|,
comment|/* received data vector */
name|double
name|tab
index|[]
index|[
literal|4
index|]
comment|/* correlation vector array */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|double
name|topmax
decl_stmt|,
name|nxtmax
decl_stmt|;
comment|/* metrics */
name|double
name|acc
decl_stmt|;
comment|/* accumulator */
name|char
name|tbuf
index|[
name|TBUF
index|]
decl_stmt|;
comment|/* monitor buffer */
name|int
name|mldigit
decl_stmt|;
comment|/* max likelihood digit */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Correlate digit vector with each BCD coefficient vector. If 	 * any BCD digit bit is bad, consider all bits a miss. Until the 	 * minute units digit has been resolved, don't to anything else. 	 * Note the SNR is calculated as the ratio of the largest 	 * likelihood value to the next largest likelihood value.  	 */
name|mldigit
operator|=
literal|0
expr_stmt|;
name|topmax
operator|=
name|nxtmax
operator|=
operator|-
name|MAXAMP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tab
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|acc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
name|acc
operator|+=
name|data
index|[
name|j
index|]
operator|*
name|tab
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|acc
operator|=
operator|(
name|vp
operator|->
name|like
index|[
name|i
index|]
operator|+=
operator|(
name|acc
operator|-
name|vp
operator|->
name|like
index|[
name|i
index|]
operator|)
operator|/
name|TCONST
operator|)
expr_stmt|;
if|if
condition|(
name|acc
operator|>
name|topmax
condition|)
block|{
name|nxtmax
operator|=
name|topmax
expr_stmt|;
name|topmax
operator|=
name|acc
expr_stmt|;
name|mldigit
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acc
operator|>
name|nxtmax
condition|)
block|{
name|nxtmax
operator|=
name|acc
expr_stmt|;
block|}
block|}
name|vp
operator|->
name|digprb
operator|=
name|topmax
expr_stmt|;
name|vp
operator|->
name|digsnr
operator|=
name|wwv_snr
argument_list|(
name|topmax
argument_list|,
name|nxtmax
argument_list|)
expr_stmt|;
comment|/* 	 * The current maximum-likelihood digit is compared to the last 	 * maximum-likelihood digit. If different, the compare counter 	 * and maximum-likelihood digit are reset.  When the compare 	 * counter reaches the BCMP threshold (3), the digit is assumed 	 * correct. When the compare counter of all nine digits have 	 * reached threshold, the clock is assumed correct. 	 * 	 * Note that the clock display digit is set before the compare 	 * counter has reached threshold; however, the clock display is 	 * not considered correct until all nine clock digits have 	 * reached threshold. This is intended as eye candy, but avoids 	 * mistakes when the signal is low and the SNR is very marginal. 	 */
if|if
condition|(
name|vp
operator|->
name|digprb
operator|<
name|BTHR
operator|||
name|vp
operator|->
name|digsnr
operator|<
name|BSNR
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|BGATE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vp
operator|->
name|digit
operator|!=
name|mldigit
condition|)
block|{
name|up
operator|->
name|alarm
operator||=
name|CMPERR
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|count
operator|>
literal|0
condition|)
name|vp
operator|->
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|count
operator|==
literal|0
condition|)
name|vp
operator|->
name|digit
operator|=
name|mldigit
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vp
operator|->
name|count
operator|<
name|BCMP
condition|)
name|vp
operator|->
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|count
operator|==
name|BCMP
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|DSYNC
expr_stmt|;
name|up
operator|->
name|digcnt
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
operator|)
operator|&&
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"wwv4 %2d %04x %3d %4d %5.0f %2d %d %d %d %5.0f %5.1f"
argument_list|,
name|up
operator|->
name|rsec
operator|-
literal|1
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|yepoch
argument_list|,
name|up
operator|->
name|epomax
argument_list|,
name|vp
operator|->
name|radix
argument_list|,
name|vp
operator|->
name|digit
argument_list|,
name|mldigit
argument_list|,
name|vp
operator|->
name|count
argument_list|,
name|vp
operator|->
name|digprb
argument_list|,
name|vp
operator|->
name|digsnr
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
end_function

begin_comment
comment|/*  * wwv_tsec - transmitter minute processing  *  * This routine is called at the end of the transmitter minute. It  * implements a state machine that advances the logical clock subject to  * the funny rules that govern the conventional clock and calendar.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_tsec
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* driver structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|int
name|minute
decl_stmt|,
name|day
decl_stmt|,
name|isleap
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Advance minute unit of the day. Don't propagate carries until 	 * the unit minute digit has been found. 	 */
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|MN
index|]
argument_list|)
expr_stmt|;
comment|/* minute units */
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|DSYNC
operator|)
condition|)
return|return;
comment|/* 	 * Propagate carries through the day. 	 */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
comment|/* carry minutes */
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
comment|/* carry hours */
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Decode the current minute and day. Set leap day if the 	 * timecode leap bit is set on 30 June or 31 December. Set leap 	 * minute if the last minute on leap day, but only if the clock 	 * is syncrhronized. This code fails in 2400 AD. 	 */
name|minute
operator|=
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|digit
operator|*
literal|60
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|600
expr_stmt|;
name|day
operator|=
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|digit
operator|*
literal|100
expr_stmt|;
comment|/* 	 * Set the leap bit on the last minute of the leap day. 	 */
name|isleap
operator|=
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|digit
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|misc
operator|&
name|SECWAR
operator|&&
name|up
operator|->
name|status
operator|&
name|INSYNC
condition|)
block|{
if|if
condition|(
operator|(
name|day
operator|==
operator|(
name|isleap
condition|?
literal|182
else|:
literal|183
operator|)
operator|||
name|day
operator|==
operator|(
name|isleap
condition|?
literal|365
else|:
literal|366
operator|)
operator|)
operator|&&
name|minute
operator|==
literal|1439
condition|)
name|up
operator|->
name|status
operator||=
name|LEPSEC
expr_stmt|;
block|}
comment|/* 	 * Roll the day if this the first minute and propagate carries 	 * through the year. 	 */
if|if
condition|(
name|minute
operator|!=
literal|1440
condition|)
return|return;
name|minute
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/* advance to minute 0 */
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|day
operator|++
expr_stmt|;
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
index|]
argument_list|)
expr_stmt|;
comment|/* carry days */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Roll the year if this the first day and propagate carries 	 * through the century. 	 */
if|if
condition|(
name|day
operator|!=
operator|(
name|isleap
condition|?
literal|365
else|:
literal|366
operator|)
condition|)
return|return;
name|day
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
index|]
argument_list|)
operator|!=
literal|1
condition|)
empty_stmt|;
comment|/* advance to day 1 */
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
while|while
condition|(
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|temp
operator|=
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|YR
index|]
argument_list|)
expr_stmt|;
comment|/* carry years */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|carry
argument_list|(
operator|&
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * carry - process digit  *  * This routine rotates a likelihood vector one position and increments  * the clock digit modulo the radix. It returns the new clock digit or  * zero if a carry occurred. Once synchronized, the clock digit will  * match the maximum-likelihood digit corresponding to that position.  */
end_comment

begin_function
specifier|static
name|int
name|carry
parameter_list|(
name|struct
name|decvec
modifier|*
name|dp
comment|/* decoding table pointer */
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
name|int
name|j
decl_stmt|;
name|dp
operator|->
name|digit
operator|++
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|digit
operator|==
name|dp
operator|->
name|radix
condition|)
name|dp
operator|->
name|digit
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|dp
operator|->
name|like
index|[
name|dp
operator|->
name|radix
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|dp
operator|->
name|radix
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|dp
operator|->
name|like
index|[
name|j
index|]
operator|=
name|dp
operator|->
name|like
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|dp
operator|->
name|like
index|[
literal|0
index|]
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|dp
operator|->
name|digit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_snr - compute SNR or likelihood function  */
end_comment

begin_function
specifier|static
name|double
name|wwv_snr
parameter_list|(
name|double
name|signal
parameter_list|,
comment|/* signal */
name|double
name|noise
comment|/* noise */
parameter_list|)
block|{
name|double
name|rval
decl_stmt|;
comment|/* 	 * This is a little tricky. Due to the way things are measured, 	 * either or both the signal or noise amplitude can be negative 	 * or zero. The intent is that, if the signal is negative or 	 * zero, the SNR must always be zero. This can happen with the 	 * subcarrier SNR before the phase has been aligned. On the 	 * other hand, in the likelihood function the "noise" is the 	 * next maximum down from the peak and this could be negative. 	 * However, in this case the SNR is truly stupendous, so we 	 * simply cap at MAXSNR dB (40). 	 */
if|if
condition|(
name|signal
operator|<=
literal|0
condition|)
block|{
name|rval
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noise
operator|<=
literal|0
condition|)
block|{
name|rval
operator|=
name|MAXSNR
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
literal|20.
operator|*
name|log10
argument_list|(
name|signal
operator|/
name|noise
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|>
name|MAXSNR
condition|)
name|rval
operator|=
name|MAXSNR
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_newchan - change to new data channel  *  * The radio actually appears to have ten channels, one channel for each  * of five frequencies and each of two stations (WWV and WWVH), although  * if not tunable only the DCHAN channel appears live. While the radio  * is tuned to the working data channel frequency and station for most  * of the minute, during seconds 59, 0 and 1 the radio is tuned to a  * probe frequency in order to search for minute sync pulse and data  * subcarrier from other transmitters.  *  * The search for WWV and WWVH operates simultaneously, with WWV minute  * sync pulse at 1000 Hz and WWVH at 1200 Hz. The probe frequency  * rotates each minute over 2.5, 5, 10, 15 and 20 MHz in order and yes,  * we all know WWVH is dark on 20 MHz, but few remember when WWV was lit  * on 25 MHz.  *  * This routine selects the best channel using a metric computed from  * the reachability register and minute pulse amplitude. Normally, the  * award goes to the the channel with the highest metric; but, in case  * of ties, the award goes to the channel with the highest minute sync  * pulse amplitude and then to the highest frequency.  *  * The routine performs an important squelch function to keep dirty data  * from polluting the integrators. In order to consider a station valid,  * the metric must be at least MTHR (13); otherwise, the station select  * bits are cleared so the second sync is disabled and the data bit  * integrators averaged to a miss.   */
end_comment

begin_function
specifier|static
name|int
name|wwv_newchan
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|sync
modifier|*
name|sp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|double
name|rank
decl_stmt|,
name|dtemp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rval
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Search all five station pairs looking for the channel with 	 * maximum metric. 	 */
name|sp
operator|=
name|NULL
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|rank
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
name|i
operator|++
control|)
block|{
name|rp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|i
index|]
operator|.
name|wwvh
expr_stmt|;
name|dtemp
operator|=
name|rp
operator|->
name|metric
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>=
name|rank
condition|)
block|{
name|rank
operator|=
name|dtemp
expr_stmt|;
name|sp
operator|=
name|rp
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
name|rp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|i
index|]
operator|.
name|wwv
expr_stmt|;
name|dtemp
operator|=
name|rp
operator|->
name|metric
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>=
name|rank
condition|)
block|{
name|rank
operator|=
name|dtemp
expr_stmt|;
name|sp
operator|=
name|rp
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * If the strongest signal is less than the MTHR threshold (13), 	 * we are beneath the waves, so squelch the second sync and 	 * advance to the next station. This makes sure all stations are 	 * scanned when the ions grow dim. If the strongest signal is 	 * greater than the threshold, tune to that frequency and 	 * transmitter QTH. 	 */
name|up
operator|->
name|status
operator|&=
operator|~
operator|(
name|SELV
operator||
name|SELH
operator|)
expr_stmt|;
if|if
condition|(
name|rank
operator|<
name|MTHR
condition|)
block|{
name|up
operator|->
name|dchan
operator|=
operator|(
name|up
operator|->
name|dchan
operator|+
literal|1
operator|)
operator|%
name|NCHAN
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|METRIC
condition|)
block|{
name|up
operator|->
name|status
operator|&=
operator|~
name|METRIC
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_PROP
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|dchan
operator|=
name|j
expr_stmt|;
name|up
operator|->
name|sptr
operator|=
name|sp
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|sp
operator|->
name|refid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
name|up
operator|->
name|status
operator||=
name|METRIC
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|select
operator|&
name|SELV
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|SELV
expr_stmt|;
name|up
operator|->
name|pdelay
operator|=
name|pp
operator|->
name|fudgetime1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|select
operator|&
name|SELH
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|SELH
expr_stmt|;
name|up
operator|->
name|pdelay
operator|=
name|pp
operator|->
name|fudgetime2
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|pdelay
operator|=
literal|0
expr_stmt|;
block|}
name|rval
operator|=
name|TRUE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ICOM
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
name|wwv_qsy
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|dchan
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ICOM */
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_newgame - reset and start over  *  * There are three conditions resulting in a new game:  *  * 1	After finding the minute pulse (MSYNC lit), going 15 minutes  *	(DATA) without finding the unit seconds digit.  *  * 2	After finding good data (DSYNC lit), going more than 40 minutes  *	(SYNCH) without finding station sync (INSYNC lit).  *  * 3	After finding station sync (INSYNC lit), going more than 2 days  *	(PANIC) without finding any station.   */
end_comment

begin_function
specifier|static
name|void
name|wwv_newgame
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Initialize strategic values. Note we set the leap bits 	 * NOTINSYNC and the refid "NONE". 	 */
if|if
condition|(
name|up
operator|->
name|status
condition|)
name|up
operator|->
name|errflg
operator|=
name|CEVNT_TIMEOUT
expr_stmt|;
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|up
operator|->
name|watch
operator|=
name|up
operator|->
name|status
operator|=
name|up
operator|->
name|alarm
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|avgint
operator|=
name|MINAVG
expr_stmt|;
name|up
operator|->
name|freq
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|gain
operator|=
name|MAXGAIN
operator|/
literal|2
expr_stmt|;
comment|/* 	 * Initialize the station processes for audio gain, select bit, 	 * station/frequency identifier and reference identifier. Start 	 * probing at the strongest channel or the default channel if 	 * nothing heard. 	 */
name|memset
argument_list|(
name|up
operator|->
name|mitig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|mitig
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|=
operator|&
name|up
operator|->
name|mitig
index|[
name|i
index|]
expr_stmt|;
name|cp
operator|->
name|gain
operator|=
name|up
operator|->
name|gain
expr_stmt|;
name|cp
operator|->
name|wwv
operator|.
name|select
operator|=
name|SELV
expr_stmt|;
name|snprintf
argument_list|(
name|cp
operator|->
name|wwv
operator|.
name|refid
argument_list|,
sizeof|sizeof
argument_list|(
name|cp
operator|->
name|wwv
operator|.
name|refid
argument_list|)
argument_list|,
literal|"WV%.0f"
argument_list|,
name|floor
argument_list|(
name|qsy
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|wwvh
operator|.
name|select
operator|=
name|SELH
expr_stmt|;
name|snprintf
argument_list|(
name|cp
operator|->
name|wwvh
operator|.
name|refid
argument_list|,
sizeof|sizeof
argument_list|(
name|cp
operator|->
name|wwvh
operator|.
name|refid
argument_list|)
argument_list|,
literal|"WH%.0f"
argument_list|,
name|floor
argument_list|(
name|qsy
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|up
operator|->
name|dchan
operator|=
operator|(
name|DCHAN
operator|+
name|NCHAN
operator|-
literal|1
operator|)
operator|%
name|NCHAN
expr_stmt|;
name|wwv_newchan
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|schan
operator|=
name|up
operator|->
name|dchan
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * wwv_metric - compute station metric  *  * The most significant bits represent the number of ones in the  * station reachability register. The least significant bits represent  * the minute sync pulse amplitude. The combined value is scaled 0-100.  */
end_comment

begin_function
name|double
name|wwv_metric
parameter_list|(
name|struct
name|sync
modifier|*
name|sp
comment|/* station pointer */
parameter_list|)
block|{
name|double
name|dtemp
decl_stmt|;
name|dtemp
operator|=
name|sp
operator|->
name|count
operator|*
name|MAXAMP
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|synmax
operator|<
name|MAXAMP
condition|)
name|dtemp
operator|+=
name|sp
operator|->
name|synmax
expr_stmt|;
else|else
name|dtemp
operator|+=
name|MAXAMP
operator|-
literal|1
expr_stmt|;
name|dtemp
operator|/=
operator|(
name|AMAX
operator|+
literal|1
operator|)
operator|*
name|MAXAMP
expr_stmt|;
return|return
operator|(
name|dtemp
operator|*
literal|100.
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_comment
comment|/*  * wwv_qsy - Tune ICOM receiver  *  * This routine saves the AGC for the current channel, switches to a new  * channel and restores the AGC for that channel. If a tunable receiver  * is not available, just fake it.  */
end_comment

begin_function
specifier|static
name|int
name|wwv_qsy
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|chan
comment|/* channel */
parameter_list|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|gain
operator|=
name|up
operator|->
name|gain
expr_stmt|;
name|rval
operator|=
name|icom_freq
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|,
name|peer
operator|->
name|ttl
operator|&
literal|0x7f
argument_list|,
name|qsy
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
name|up
operator|->
name|achan
operator|=
name|chan
expr_stmt|;
name|up
operator|->
name|gain
operator|=
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|achan
index|]
operator|.
name|gain
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * timecode - assemble timecode string and length  *  * Prettytime format - similar to Spectracom  *  * sq yy ddd hh:mm:ss ld dut lset agc iden sig errs freq avgt  *  * s	sync indicator ('?' or ' ')  * q	error bits (hex 0-F)  * yyyy	year of century  * ddd	day of year  * hh	hour of day  * mm	minute of hour  * ss	second of minute)  * l	leap second warning (' ' or 'L')  * d	DST state ('S', 'D', 'I', or 'O')  * dut	DUT sign and magnitude (0.1 s)  * lset	minutes since last clock update  * agc	audio gain (0-255)  * iden	reference identifier (station and frequency)  * sig	signal quality (0-100)  * errs	bit errors in last minute  * freq	frequency offset (PPM)  * avgt	averaging time (s)  */
end_comment

begin_function
specifier|static
name|int
name|timecode
parameter_list|(
name|struct
name|wwvunit
modifier|*
name|up
parameter_list|,
comment|/* driver structure pointer */
name|char
modifier|*
name|tc
parameter_list|,
comment|/* target string */
name|size_t
name|tcsiz
comment|/* target max chars */
parameter_list|)
block|{
name|struct
name|sync
modifier|*
name|sp
decl_stmt|;
name|int
name|year
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|dut
decl_stmt|;
name|char
name|synchar
decl_stmt|,
name|leapchar
decl_stmt|,
name|dst
decl_stmt|;
name|char
name|cptr
index|[
literal|50
index|]
decl_stmt|;
comment|/* 	 * Common fixed-format fields 	 */
name|synchar
operator|=
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|?
literal|' '
else|:
literal|'?'
expr_stmt|;
name|year
operator|=
name|up
operator|->
name|decvec
index|[
name|YR
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|YR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
literal|2000
expr_stmt|;
name|day
operator|=
name|up
operator|->
name|decvec
index|[
name|DA
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
operator|+
name|up
operator|->
name|decvec
index|[
name|DA
operator|+
literal|2
index|]
operator|.
name|digit
operator|*
literal|100
expr_stmt|;
name|hour
operator|=
name|up
operator|->
name|decvec
index|[
name|HR
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|HR
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|minute
operator|=
name|up
operator|->
name|decvec
index|[
name|MN
index|]
operator|.
name|digit
operator|+
name|up
operator|->
name|decvec
index|[
name|MN
operator|+
literal|1
index|]
operator|.
name|digit
operator|*
literal|10
expr_stmt|;
name|second
operator|=
literal|0
expr_stmt|;
name|leapchar
operator|=
operator|(
name|up
operator|->
name|misc
operator|&
name|SECWAR
operator|)
condition|?
literal|'L'
else|:
literal|' '
expr_stmt|;
name|dst
operator|=
name|dstcod
index|[
operator|(
name|up
operator|->
name|misc
operator|>>
literal|4
operator|)
operator|&
literal|0x3
index|]
expr_stmt|;
name|dut
operator|=
name|up
operator|->
name|misc
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|misc
operator|&
name|DUTS
operator|)
condition|)
name|dut
operator|=
operator|-
name|dut
expr_stmt|;
name|snprintf
argument_list|(
name|tc
argument_list|,
name|tcsiz
argument_list|,
literal|"%c%1X"
argument_list|,
name|synchar
argument_list|,
name|up
operator|->
name|alarm
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cptr
argument_list|,
sizeof|sizeof
argument_list|(
name|cptr
argument_list|)
argument_list|,
literal|" %4d %03d %02d:%02d:%02d %c%c %+d"
argument_list|,
name|year
argument_list|,
name|day
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|leapchar
argument_list|,
name|dst
argument_list|,
name|dut
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|tc
argument_list|,
name|cptr
argument_list|,
name|tcsiz
argument_list|)
expr_stmt|;
comment|/* 	 * Specific variable-format fields 	 */
name|sp
operator|=
name|up
operator|->
name|sptr
expr_stmt|;
name|snprintf
argument_list|(
name|cptr
argument_list|,
sizeof|sizeof
argument_list|(
name|cptr
argument_list|)
argument_list|,
literal|" %d %d %s %.0f %d %.1f %d"
argument_list|,
name|up
operator|->
name|watch
argument_list|,
name|up
operator|->
name|mitig
index|[
name|up
operator|->
name|dchan
index|]
operator|.
name|gain
argument_list|,
name|sp
operator|->
name|refid
argument_list|,
name|sp
operator|->
name|metric
argument_list|,
name|up
operator|->
name|errcnt
argument_list|,
name|up
operator|->
name|freq
operator|/
name|WWV_SEC
operator|*
literal|1e6
argument_list|,
name|up
operator|->
name|avgint
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|tc
argument_list|,
name|cptr
argument_list|,
name|tcsiz
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|tc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * wwv_gain - adjust codec gain  *  * This routine is called at the end of each second. During the second  * the number of signal clips above the MAXAMP threshold (6000). If  * there are no clips, the gain is bumped up; if there are more than  * MAXCLP clips (100), it is bumped down. The decoder is relatively  * insensitive to amplitude, so this crudity works just peachy. The  * routine also jiggles the input port and selectively mutes the  * monitor.  */
end_comment

begin_function
specifier|static
name|void
name|wwv_gain
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|wwvunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Apparently, the codec uses only the high order bits of the 	 * gain control field. Thus, it may take awhile for changes to 	 * wiggle the hardware bits. 	 */
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|gain
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|>
name|MAXGAIN
condition|)
name|up
operator|->
name|gain
operator|=
name|MAXGAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|>
name|MAXCLP
condition|)
block|{
name|up
operator|->
name|gain
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|<
literal|0
condition|)
name|up
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
block|}
name|audio_gain
argument_list|(
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|mongain
argument_list|,
name|up
operator|->
name|port
argument_list|)
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|audio_show
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_wwv_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

