begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Refclock_neoclock4x.c  * - NeoClock4X driver for DCF77 or FIA Timecode  *  * Date: 2003-07-07 v1.13  *  * see http://www.linum.com/redir/jump/id=neoclock4x&action=redir  * for details about the NeoClock4X device  *  * Copyright (C) 2002-2003 by Linum Software GmbH<neoclock4x@linum.com>  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|CLOCK_NEOCLOCK4X
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_if
if|#
directive|if
name|defined
name|HAVE_SYS_MODEM_H
end_if

begin_include
include|#
directive|include
file|<sys/modem.h>
end_include

begin_define
define|#
directive|define
name|TIOCMSET
value|MCSETA
end_define

begin_define
define|#
directive|define
name|TIOCMGET
value|MCGETA
end_define

begin_define
define|#
directive|define
name|TIOCM_RTS
value|MRTS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIOS_H
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS_NEEDS__SVID3
end_ifdef

begin_define
define|#
directive|define
name|_SVID3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS_NEEDS__SVID3
end_ifdef

begin_undef
undef|#
directive|undef
name|_SVID3
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * If you want the driver for whatever reason to not use  * the TX line to send anything to your NeoClock4X  * device you must tell the NTP refclock driver which  * firmware you NeoClock4X device uses.  *  * If you want to enable this feature change the "#if 0"  * line to "#if 1" and make sure that the defined firmware  * matches the firmware off your NeoClock4X receiver!  *  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|NEOCLOCK4X_FIRMWARE
value|NEOCLOCK4X_FIRMWARE_VERSION_A
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NEOCLOCK4X_FIRMWARE_VERSION_A
value|'A'
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_TIMECODELEN
value|37
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_SERIAL
value|3
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_RADIOSIGNAL
value|9
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_DAY
value|12
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_MONTH
value|14
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_YEAR
value|16
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_HOUR
value|18
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_MINUTE
value|20
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_SECOND
value|22
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_HSEC
value|24
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_DOW
value|26
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_TIMESOURCE
value|28
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_DSTSTATUS
value|29
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_QUARZSTATUS
value|30
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_ANTENNA1
value|31
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_ANTENNA2
value|33
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_OFFSET_CRC
value|35
end_define

begin_define
define|#
directive|define
name|NEOCLOCK4X_DRIVER_VERSION
value|"1.12 (2003-01-10)"
end_define

begin_struct
struct|struct
name|neoclock4x_unit
block|{
name|l_fp
name|laststamp
decl_stmt|;
comment|/* last receive timestamp */
name|short
name|unit
decl_stmt|;
comment|/* NTP refclock unit number */
name|u_long
name|polled
decl_stmt|;
comment|/* flag to detect noreplies */
name|char
name|leap_status
decl_stmt|;
comment|/* leap second flag */
name|int
name|recvnow
decl_stmt|;
name|char
name|firmware
index|[
literal|80
index|]
decl_stmt|;
name|char
name|firmwaretag
decl_stmt|;
name|char
name|serial
index|[
literal|7
index|]
decl_stmt|;
name|char
name|radiosignal
index|[
literal|4
index|]
decl_stmt|;
name|char
name|timesource
decl_stmt|;
name|char
name|dststatus
decl_stmt|;
name|char
name|quarzstatus
decl_stmt|;
name|int
name|antenna1
decl_stmt|;
name|int
name|antenna2
decl_stmt|;
name|int
name|utc_year
decl_stmt|;
name|int
name|utc_month
decl_stmt|;
name|int
name|utc_day
decl_stmt|;
name|int
name|utc_hour
decl_stmt|;
name|int
name|utc_minute
decl_stmt|;
name|int
name|utc_second
decl_stmt|;
name|int
name|utc_msec
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|neoclock4x_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|neoclock4x_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|neoclock4x_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|neoclock4x_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|neoclock4x_control
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|neol_atoi_len
name|P
argument_list|(
operator|(
specifier|const
name|char
name|str
index|[]
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|neol_hexatoi_len
name|P
argument_list|(
operator|(
specifier|const
name|char
name|str
index|[]
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|neol_jdn_to_ymd
name|P
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|neol_localtime
name|P
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|neol_mktime
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void     neol_mdelay             P((int));
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NEOCLOCK4X_FIRMWARE
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|neol_query_firmware
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|neol_check_firmware
name|P
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|refclock
name|refclock_neoclock4x
init|=
block|{
name|neoclock4x_start
block|,
comment|/* start up driver */
name|neoclock4x_shutdown
block|,
comment|/* shut down driver */
name|neoclock4x_poll
block|,
comment|/* transmit poll message */
name|neoclock4x_control
block|,
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|neoclock4x_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|neoclock4x_unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|dev
index|[
literal|20
index|]
decl_stmt|;
name|int
name|sl232
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
name|struct
name|termios
name|termsettings
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NEOCLOCK4X_FIRMWARE
argument_list|)
name|int
name|tries
decl_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
argument_list|)
operator|-
literal|1
argument_list|,
literal|"/dev/neoclock4x-%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* LDISC_STD, LDISC_RAW    * Open serial port. Use CLK line discipline, if available.    */
name|fd
operator|=
name|refclock_open
argument_list|(
name|dev
argument_list|,
name|B2400
argument_list|,
name|LDISC_CLK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|termsettings
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"NeoClock4X(%d): (tcgetattr) can't query serial port settings: %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 2400 Baud 8N2 */
name|termsettings
operator|.
name|c_cflag
operator|&=
operator|~
name|PARENB
expr_stmt|;
name|termsettings
operator|.
name|c_cflag
operator||=
name|CSTOPB
expr_stmt|;
name|termsettings
operator|.
name|c_cflag
operator|&=
operator|~
name|CSIZE
expr_stmt|;
name|termsettings
operator|.
name|c_cflag
operator||=
name|CS8
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|termsettings
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"NeoClock4X(%d): (tcsetattr) can't set serial port 2400 8N2: %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|termsettings
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"NeoClock4X(%d): (TCGETA) can't query serial port settings: %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 2400 Baud 8N2 */
name|termsettings
operator|.
name|c_cflag
operator|&=
operator|~
name|PARENB
expr_stmt|;
name|termsettings
operator|.
name|c_cflag
operator||=
name|CSTOPB
expr_stmt|;
name|termsettings
operator|.
name|c_cflag
operator|&=
operator|~
name|CSIZE
expr_stmt|;
name|termsettings
operator|.
name|c_cflag
operator||=
name|CS8
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|termsettings
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"NeoClock4X(%d): (TSGETA) can't set serial port 2400 8N2: %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
name|msyslog
argument_list|(
name|LOG_EMERG
argument_list|,
literal|"NeoClock4X(%d): don't know how to set port to 2400 8N2 with this OS!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TIOCMSET
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TIOCM_RTS
argument_list|)
operator|||
name|defined
argument_list|(
name|CIOCM_RTS
argument_list|)
operator|)
comment|/* turn on RTS, and DTR for power supply */
comment|/* NeoClock4x is powered from serial line */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sl232
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"NeoClock4X(%d): can't query RTS/DTR state: %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TIOCM_RTS
name|sl232
operator|=
name|sl232
operator||
name|TIOCM_DTR
operator||
name|TIOCM_RTS
expr_stmt|;
comment|/* turn on RTS, and DTR for power supply */
else|#
directive|else
name|sl232
operator|=
name|sl232
operator||
name|CIOCM_DTR
operator||
name|CIOCM_RTS
expr_stmt|;
comment|/* turn on RTS, and DTR for power supply */
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sl232
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"NeoClock4X(%d): can't set RTS/DTR to power neoclock4x: %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
name|msyslog
argument_list|(
name|LOG_EMERG
argument_list|,
literal|"NeoClock4X(%d): don't know how to set DTR/RTS to power NeoClock4X with this OS!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|up
operator|=
operator|(
expr|struct
name|neoclock4x_unit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|neoclock4x_unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NeoClock4X(%d): can't allocate memory for: %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|neoclock4x_unit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
literal|"NeoClock4X"
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|neoclock4x_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
comment|/*    * no fudge time is given by user!    * use 169.583333 ms to compensate the serial line delay    * formula is:    * 2400 Baud / 11 bit = 218.18 charaters per second    *  (NeoClock4X timecode len)    */
name|pp
operator|->
name|fudgetime1
operator|=
operator|(
name|NEOCLOCK4X_TIMECODELEN
operator|*
literal|11
operator|)
operator|/
literal|2400.0
expr_stmt|;
comment|/*    * Initialize miscellaneous variables    */
name|peer
operator|->
name|precision
operator|=
operator|-
literal|10
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|NSTAGE
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
literal|"neol"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|leap_status
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|strcpy
argument_list|(
name|up
operator|->
name|firmware
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|up
operator|->
name|firmwaretag
operator|=
literal|'?'
expr_stmt|;
name|strcpy
argument_list|(
name|up
operator|->
name|serial
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|up
operator|->
name|radiosignal
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|up
operator|->
name|timesource
operator|=
literal|'?'
expr_stmt|;
name|up
operator|->
name|dststatus
operator|=
literal|'?'
expr_stmt|;
name|up
operator|->
name|quarzstatus
operator|=
literal|'?'
expr_stmt|;
name|up
operator|->
name|antenna1
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|antenna2
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|utc_year
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|utc_month
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|utc_day
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|utc_hour
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|utc_minute
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|utc_second
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|utc_msec
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NEOCLOCK4X_FIRMWARE
argument_list|)
if|#
directive|if
name|NEOCLOCK4X_FIRMWARE
operator|==
name|NEOCLOCK4X_FIRMWARE_VERSION_A
name|strcpy
argument_list|(
name|up
operator|->
name|firmware
argument_list|,
literal|"(c) 2002 NEOL S.A. FRANCE / L0.01 NDF:A:* (compile time)"
argument_list|)
expr_stmt|;
name|up
operator|->
name|firmwaretag
operator|=
literal|'A'
expr_stmt|;
else|#
directive|else
name|msyslog
argument_list|(
name|LOG_EMERG
argument_list|,
literal|"NeoClock4X(%d): Unkown firmware defined at compile time for NeoClock4X"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|pp
operator|->
name|unitptr
argument_list|)
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|5
condition|;
name|tries
operator|++
control|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NeoClock4X(%d): checking NeoClock4X firmware version (%d/5)"
argument_list|,
name|unit
argument_list|,
name|tries
argument_list|)
expr_stmt|;
comment|/* wait 3 seconds for receiver to power up */
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|neol_query_firmware
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|up
operator|->
name|unit
argument_list|,
name|up
operator|->
name|firmware
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|firmware
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|/* can I handle this firmware version? */
if|if
condition|(
operator|!
name|neol_check_firmware
argument_list|(
name|up
operator|->
name|unit
argument_list|,
name|up
operator|->
name|firmware
argument_list|,
operator|&
name|up
operator|->
name|firmwaretag
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|pp
operator|->
name|unitptr
argument_list|)
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NeoClock4X(%d): error add peer to ntpd: %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|pp
operator|->
name|unitptr
argument_list|)
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NeoClock4X(%d): receiver setup successful done"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|neoclock4x_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|neoclock4x_unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|sl232
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|peer
condition|)
block|{
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
name|up
operator|=
operator|(
expr|struct
name|neoclock4x_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TIOCMSET
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|TIOCM_RTS
argument_list|)
operator|||
name|defined
argument_list|(
name|CIOCM_RTS
argument_list|)
operator|)
comment|/* turn on RTS, and DTR for power supply */
comment|/* NeoClock4x is powered from serial line */
if|if
condition|(
name|ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sl232
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"NeoClock4X(%d): can't query RTS/DTR state: %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TIOCM_RTS
comment|/* turn on RTS, and DTR for power supply */
name|sl232
operator|&=
operator|~
operator|(
name|TIOCM_DTR
operator||
name|TIOCM_RTS
operator|)
expr_stmt|;
else|#
directive|else
comment|/* turn on RTS, and DTR for power supply */
name|sl232
operator|&=
operator|~
operator|(
name|CIOCM_DTR
operator||
name|CIOCM_RTS
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sl232
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"NeoClock4X(%d): can't set RTS/DTR to power neoclock4x: %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NeoClock4X(%d): shutdown"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NeoClock4X(%d): receiver shutdown done"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|neoclock4x_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|struct
name|neoclock4x_unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|unsigned
name|long
name|calc_utc
decl_stmt|;
name|int
name|day
decl_stmt|;
name|int
name|month
decl_stmt|;
comment|/* ddd conversion */
name|int
name|c
decl_stmt|;
name|int
name|dsec
decl_stmt|;
name|unsigned
name|char
name|calc_chksum
decl_stmt|;
name|int
name|recv_chksum
decl_stmt|;
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|neoclock4x_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* wait till poll interval is reached */
if|if
condition|(
literal|0
operator|==
name|up
operator|->
name|recvnow
condition|)
return|return;
comment|/* reset poll interval flag */
name|up
operator|->
name|recvnow
operator|=
literal|0
expr_stmt|;
comment|/* read last received timecode */
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
if|if
condition|(
name|NEOCLOCK4X_TIMECODELEN
operator|!=
name|pp
operator|->
name|lencode
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NeoClock4X(%d): received data has invalid length, expected %d bytes, received %d bytes: %s"
argument_list|,
name|up
operator|->
name|unit
argument_list|,
name|NEOCLOCK4X_TIMECODELEN
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|neol_hexatoi_len
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_CRC
index|]
argument_list|,
operator|&
name|recv_chksum
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* calculate checksum */
name|calc_chksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NEOCLOCK4X_OFFSET_CRC
condition|;
name|c
operator|++
control|)
block|{
name|calc_chksum
operator|+=
name|pp
operator|->
name|a_lastcode
index|[
name|c
index|]
expr_stmt|;
block|}
if|if
condition|(
name|recv_chksum
operator|!=
name|calc_chksum
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NeoClock4X(%d): received data has invalid chksum: %s"
argument_list|,
name|up
operator|->
name|unit
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allow synchronization even is quartz clock is    * never initialized.    * WARNING: This is dangerous!    */
name|up
operator|->
name|quarzstatus
operator|=
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_QUARZSTATUS
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
operator|)
condition|)
block|{
if|if
condition|(
literal|'I'
operator|!=
name|up
operator|->
name|quarzstatus
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"NeoClock4X(%d): quartz clock is not initialized: %s"
argument_list|,
name|up
operator|->
name|unit
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
literal|'I'
operator|!=
name|up
operator|->
name|quarzstatus
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"NeoClock4X(%d): using uninitialized quartz clock for time synchronization: %s"
argument_list|,
name|up
operator|->
name|unit
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
block|}
comment|/*    * If NeoClock4X is not synchronized to a radio clock    * check if we're allowed to synchronize with the quartz    * clock.    */
name|up
operator|->
name|timesource
operator|=
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_TIMESOURCE
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
operator|)
condition|)
block|{
if|if
condition|(
literal|'A'
operator|!=
name|up
operator|->
name|timesource
condition|)
block|{
comment|/* not allowed to sync with quartz clock */
if|if
condition|(
literal|0
operator|==
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG1
operator|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* this should only used when first install is done */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"NeoClock4X(%d): received data: %s"
argument_list|,
name|up
operator|->
name|unit
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
block|}
comment|/* 123456789012345678901234567890123456789012345 */
comment|/* S/N123456DCF1004021010001202ASX1213CR\r\n */
name|neol_atoi_len
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_YEAR
index|]
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|neol_atoi_len
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_MONTH
index|]
argument_list|,
operator|&
name|month
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|neol_atoi_len
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_DAY
index|]
argument_list|,
operator|&
name|day
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|neol_atoi_len
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_HOUR
index|]
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|neol_atoi_len
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_MINUTE
index|]
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|neol_atoi_len
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_SECOND
index|]
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|neol_atoi_len
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_HSEC
index|]
argument_list|,
operator|&
name|dsec
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pp
operator|->
name|nsec
operator|=
name|dsec
operator|*
literal|10000
expr_stmt|;
comment|/* convert 1/100s from neoclock to nanoseconds */
name|memcpy
argument_list|(
name|up
operator|->
name|radiosignal
argument_list|,
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_RADIOSIGNAL
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|up
operator|->
name|radiosignal
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|up
operator|->
name|serial
argument_list|,
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_SERIAL
index|]
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|up
operator|->
name|serial
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|dststatus
operator|=
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_DSTSTATUS
index|]
expr_stmt|;
name|neol_hexatoi_len
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_ANTENNA1
index|]
argument_list|,
operator|&
name|up
operator|->
name|antenna1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|neol_hexatoi_len
argument_list|(
operator|&
name|pp
operator|->
name|a_lastcode
index|[
name|NEOCLOCK4X_OFFSET_ANTENNA2
index|]
argument_list|,
operator|&
name|up
operator|->
name|antenna2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/*     Validate received values at least enough to prevent internal     array-bounds problems, etc.   */
if|if
condition|(
operator|(
name|pp
operator|->
name|hour
operator|<
literal|0
operator|)
operator|||
operator|(
name|pp
operator|->
name|hour
operator|>
literal|23
operator|)
operator|||
operator|(
name|pp
operator|->
name|minute
operator|<
literal|0
operator|)
operator|||
operator|(
name|pp
operator|->
name|minute
operator|>
literal|59
operator|)
operator|||
operator|(
name|pp
operator|->
name|second
operator|<
literal|0
operator|)
operator|||
operator|(
name|pp
operator|->
name|second
operator|>
literal|60
operator|)
comment|/*Allow for leap seconds.*/
operator|||
operator|(
name|day
operator|<
literal|1
operator|)
operator|||
operator|(
name|day
operator|>
literal|31
operator|)
operator|||
operator|(
name|month
operator|<
literal|1
operator|)
operator|||
operator|(
name|month
operator|>
literal|12
operator|)
operator|||
operator|(
name|pp
operator|->
name|year
operator|<
literal|0
operator|)
operator|||
operator|(
name|pp
operator|->
name|year
operator|>
literal|99
operator|)
condition|)
block|{
comment|/* Data out of range. */
name|NLOG
argument_list|(
argument|NLOG_CLOCKEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NeoClock4X(%d): date/time out of range: %s"
argument_list|,
name|up
operator|->
name|unit
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Year-2000 check not needed anymore. Same problem    * will arise at 2099 but what should we do...?    *    * wrap 2-digit date into 4-digit    *    * if(pp->year< YEAR_PIVOT)    * {    *   pp->year += 100;    * }   */
name|pp
operator|->
name|year
operator|+=
literal|2000
expr_stmt|;
comment|/* adjust NeoClock4X local time to UTC */
name|calc_utc
operator|=
name|neol_mktime
argument_list|(
name|pp
operator|->
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|)
expr_stmt|;
name|calc_utc
operator|-=
literal|3600
expr_stmt|;
comment|/* adjust NeoClock4X daylight saving time if needed */
if|if
condition|(
literal|'S'
operator|==
name|up
operator|->
name|dststatus
condition|)
name|calc_utc
operator|-=
literal|3600
expr_stmt|;
name|neol_localtime
argument_list|(
name|calc_utc
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|)
expr_stmt|;
comment|/*     some preparations   */
name|pp
operator|->
name|day
operator|=
name|ymd2yd
argument_list|(
name|pp
operator|->
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"NeoClock4X(%d): calculated UTC date/time: %04d-%02d-%02d %02d:%02d:%02d.%03ld"
argument_list|,
name|up
operator|->
name|unit
argument_list|,
name|pp
operator|->
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|pp
operator|->
name|nsec
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|up
operator|->
name|utc_year
operator|=
name|pp
operator|->
name|year
expr_stmt|;
name|up
operator|->
name|utc_month
operator|=
name|month
expr_stmt|;
name|up
operator|->
name|utc_day
operator|=
name|day
expr_stmt|;
name|up
operator|->
name|utc_hour
operator|=
name|pp
operator|->
name|hour
expr_stmt|;
name|up
operator|->
name|utc_minute
operator|=
name|pp
operator|->
name|minute
expr_stmt|;
name|up
operator|->
name|utc_second
operator|=
name|pp
operator|->
name|second
expr_stmt|;
name|up
operator|->
name|utc_msec
operator|=
name|pp
operator|->
name|nsec
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKEVENT
argument_list|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NeoClock4X(%d): refclock_process failed!"
argument_list|,
name|up
operator|->
name|unit
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return;
block|}
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* report good status */
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|neoclock4x_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|neoclock4x_unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|neoclock4x_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
name|up
operator|->
name|recvnow
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|neoclock4x_control
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|in
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|neoclock4x_unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|peer
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NeoClock4X(%d): control: unit invalid/inactive"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pp
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NeoClock4X(%d): control: unit invalid/inactive"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|up
operator|=
operator|(
expr|struct
name|neoclock4x_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|up
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NeoClock4X(%d): control: unit invalid/inactive"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|NULL
operator|!=
name|in
condition|)
block|{
comment|/* check to see if a user supplied time offset is given */
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
condition|)
block|{
name|pp
operator|->
name|fudgetime1
operator|=
name|in
operator|->
name|fudgetime1
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"NeoClock4X(%d): using fudgetime1 with %0.5fs from ntp.conf."
argument_list|,
name|unit
argument_list|,
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
block|}
comment|/* notify */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG1
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"NeoClock4X(%d): quartz clock is used to synchronize time if radio clock has no reception."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"NeoClock4X(%d): time is only adjusted with radio signal reception."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|NULL
operator|!=
name|out
condition|)
block|{
specifier|static
name|char
name|outstatus
index|[
literal|800
index|]
decl_stmt|;
comment|/* status output buffer */
name|char
modifier|*
name|tt
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|80
index|]
decl_stmt|;
name|outstatus
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|out
operator|->
name|kv_list
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
name|out
operator|->
name|type
operator|=
name|REFCLK_NEOCLOCK4X
expr_stmt|;
name|snprintf
argument_list|(
name|tmpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%04d-%02d-%02d %02d:%02d:%02d.%03d"
argument_list|,
name|up
operator|->
name|utc_year
argument_list|,
name|up
operator|->
name|utc_month
argument_list|,
name|up
operator|->
name|utc_day
argument_list|,
name|up
operator|->
name|utc_hour
argument_list|,
name|up
operator|->
name|utc_minute
argument_list|,
name|up
operator|->
name|utc_second
argument_list|,
name|up
operator|->
name|utc_msec
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|-
literal|1
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tt
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|-
literal|1
argument_list|,
literal|"calc_utc=\"%s\""
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|40
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"radiosignal=\"%s\""
argument_list|,
name|up
operator|->
name|radiosignal
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|40
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"antenna1=\"%d\""
argument_list|,
name|up
operator|->
name|antenna1
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|40
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"antenna2=\"%d\""
argument_list|,
name|up
operator|->
name|antenna2
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|40
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'A'
operator|==
name|up
operator|->
name|timesource
condition|)
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"timesource=\"radio\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|'C'
operator|==
name|up
operator|->
name|timesource
condition|)
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"timesource=\"quartz\""
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"timesource=\"unknown\""
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|40
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'I'
operator|==
name|up
operator|->
name|quarzstatus
condition|)
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"quartzstatus=\"synchronized\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|'X'
operator|==
name|up
operator|->
name|quarzstatus
condition|)
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"quartzstatus=\"not synchronized\""
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"quartzstatus=\"unknown\""
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|40
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'S'
operator|==
name|up
operator|->
name|dststatus
condition|)
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"dststatus=\"summer\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|'W'
operator|==
name|up
operator|->
name|dststatus
condition|)
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"dststatus=\"winter\""
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"dststatus=\"unknown\""
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|80
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|79
argument_list|,
literal|"firmware=\"%s\""
argument_list|,
name|up
operator|->
name|firmware
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|40
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|39
argument_list|,
literal|"firmwaretag=\"%c\""
argument_list|,
name|up
operator|->
name|firmwaretag
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|80
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|79
argument_list|,
literal|"driver version=\"%s\""
argument_list|,
name|NEOCLOCK4X_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|80
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tt
argument_list|,
literal|79
argument_list|,
literal|"serialnumber=\"%s\""
argument_list|,
name|up
operator|->
name|serial
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|neol_hexatoi_len
parameter_list|(
specifier|const
name|char
name|str
index|[]
parameter_list|,
name|int
modifier|*
name|result
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|int
name|hexdigit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|isxdigit
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
operator|&&
name|i
operator|<
name|maxlen
condition|;
name|i
operator|++
control|)
block|{
name|hexdigit
operator|=
name|isdigit
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
condition|?
name|toupper
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
operator|-
literal|'0'
else|:
name|toupper
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
name|n
operator|=
literal|16
operator|*
name|n
operator|+
name|hexdigit
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|neol_atoi_len
parameter_list|(
specifier|const
name|char
name|str
index|[]
parameter_list|,
name|int
modifier|*
name|result
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|int
name|digit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|isdigit
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
operator|&&
name|i
operator|<
name|maxlen
condition|;
name|i
operator|++
control|)
block|{
name|digit
operator|=
name|str
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
name|n
operator|=
literal|10
operator|*
name|n
operator|+
name|digit
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Converts Gregorian date to seconds since 1970-01-01 00:00:00.  * Assumes input in normal date format, i.e. 1980-12-31 23:59:59  * => year=1980, mon=12, day=31, hour=23, min=59, sec=59.  *  * [For the Julian calendar (which was used in Russia before 1917,  * Britain& colonies before 1752, anywhere else before 1582,  * and is still in use by some communities) leave out the  * -year/100+year/400 terms, and add 10.]  *  * This algorithm was first published by Gauss (I think).  *  * WARNING: this function will overflow on 2106-02-07 06:28:16 on  * machines were long is 32-bit! (However, as time_t is signed, we  * will already get problems at other places on 2038-01-19 03:14:08)  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|neol_mktime
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|mon
parameter_list|,
name|int
name|day
parameter_list|,
name|int
name|hour
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|sec
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|>=
call|(
name|int
call|)
argument_list|(
name|mon
operator|-=
literal|2
argument_list|)
condition|)
block|{
comment|/* 1..12 . 11,12,1..10 */
name|mon
operator|+=
literal|12
expr_stmt|;
comment|/* Puts Feb last since it has leap day */
name|year
operator|-=
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|year
operator|/
literal|4
operator|-
name|year
operator|/
literal|100
operator|+
name|year
operator|/
literal|400
operator|+
literal|367
operator|*
name|mon
operator|/
literal|12
operator|+
name|day
argument_list|)
operator|+
name|year
operator|*
literal|365
operator|-
literal|719499
operator|)
operator|*
literal|24
operator|+
name|hour
comment|/* now have hours */
operator|)
operator|*
literal|60
operator|+
name|min
comment|/* now have minutes */
operator|)
operator|*
literal|60
operator|+
name|sec
return|;
comment|/* finally seconds */
block|}
end_function

begin_function
specifier|static
name|void
name|neol_localtime
parameter_list|(
name|unsigned
name|long
name|utc
parameter_list|,
name|int
modifier|*
name|year
parameter_list|,
name|int
modifier|*
name|month
parameter_list|,
name|int
modifier|*
name|day
parameter_list|,
name|int
modifier|*
name|hour
parameter_list|,
name|int
modifier|*
name|min
parameter_list|,
name|int
modifier|*
name|sec
parameter_list|)
block|{
operator|*
name|sec
operator|=
name|utc
operator|%
literal|60
expr_stmt|;
name|utc
operator|/=
literal|60
expr_stmt|;
operator|*
name|min
operator|=
name|utc
operator|%
literal|60
expr_stmt|;
name|utc
operator|/=
literal|60
expr_stmt|;
operator|*
name|hour
operator|=
name|utc
operator|%
literal|24
expr_stmt|;
name|utc
operator|/=
literal|24
expr_stmt|;
comment|/*             JDN Date 1/1/1970 */
name|neol_jdn_to_ymd
argument_list|(
name|utc
operator|+
literal|2440588L
argument_list|,
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|neol_jdn_to_ymd
parameter_list|(
name|unsigned
name|long
name|jdn
parameter_list|,
name|int
modifier|*
name|yy
parameter_list|,
name|int
modifier|*
name|mm
parameter_list|,
name|int
modifier|*
name|dd
parameter_list|)
block|{
name|unsigned
name|long
name|x
decl_stmt|,
name|z
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|long
name|daysPer400Years
init|=
literal|146097UL
decl_stmt|;
name|unsigned
name|long
name|fudgedDaysPer4000Years
init|=
literal|1460970UL
operator|+
literal|31UL
decl_stmt|;
name|x
operator|=
name|jdn
operator|+
literal|68569UL
expr_stmt|;
name|z
operator|=
literal|4UL
operator|*
name|x
operator|/
name|daysPer400Years
expr_stmt|;
name|x
operator|=
name|x
operator|-
operator|(
name|daysPer400Years
operator|*
name|z
operator|+
literal|3UL
operator|)
operator|/
literal|4UL
expr_stmt|;
name|y
operator|=
literal|4000UL
operator|*
operator|(
name|x
operator|+
literal|1
operator|)
operator|/
name|fudgedDaysPer4000Years
expr_stmt|;
name|x
operator|=
name|x
operator|-
literal|1461UL
operator|*
name|y
operator|/
literal|4UL
operator|+
literal|31UL
expr_stmt|;
name|m
operator|=
literal|80UL
operator|*
name|x
operator|/
literal|2447UL
expr_stmt|;
name|d
operator|=
name|x
operator|-
literal|2447UL
operator|*
name|m
operator|/
literal|80UL
expr_stmt|;
name|x
operator|=
name|m
operator|/
literal|11UL
expr_stmt|;
name|m
operator|=
name|m
operator|+
literal|2UL
operator|-
literal|12UL
operator|*
name|x
expr_stmt|;
name|y
operator|=
literal|100UL
operator|*
operator|(
name|z
operator|-
literal|49UL
operator|)
operator|+
name|y
operator|+
name|x
expr_stmt|;
operator|*
name|yy
operator|=
operator|(
name|int
operator|)
name|y
expr_stmt|;
operator|*
name|mm
operator|=
operator|(
name|int
operator|)
name|m
expr_stmt|;
operator|*
name|dd
operator|=
operator|(
name|int
operator|)
name|d
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  *  delay in milliseconds  */
end_comment

begin_endif
unit|static void neol_mdelay(int milliseconds) {   struct timeval tv;    if(milliseconds)     {       tv.tv_sec  = 0;       tv.tv_usec = milliseconds * 1000;       select(1, NULL, NULL, NULL,&tv);     } }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NEOCLOCK4X_FIRMWARE
argument_list|)
end_if

begin_function
specifier|static
name|int
name|neol_query_firmware
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|firmware
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|lastsearch
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|last_c_was_crlf
decl_stmt|;
name|int
name|last_crlf_conv_len
decl_stmt|;
name|int
name|init
decl_stmt|;
name|int
name|read_errors
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|int
name|chars_read
decl_stmt|;
comment|/* wait a little bit */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|write
argument_list|(
name|fd
argument_list|,
literal|"V"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* wait a little bit */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmpbuf
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|lastsearch
operator|=
literal|0
expr_stmt|;
name|last_c_was_crlf
operator|=
literal|0
expr_stmt|;
name|last_crlf_conv_len
operator|=
literal|0
expr_stmt|;
name|init
operator|=
literal|1
expr_stmt|;
name|read_errors
operator|=
literal|0
expr_stmt|;
name|chars_read
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|read_errors
operator|>
literal|5
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NeoClock4X(%d): can't read firmware version (timeout)"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"unknown due to timeout"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chars_read
operator|>
literal|500
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NeoClock4X(%d): can't read firmware version (garbage)"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"unknown due to garbage input"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|EAGAIN
operator|!=
name|errno
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"NeoClock4x(%d): read: %s"
argument_list|,
name|unit
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|read_errors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
name|chars_read
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
literal|0xA9
operator|!=
name|c
condition|)
comment|/* wait for (c) char in input stream */
continue|continue;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"(c)"
argument_list|)
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
name|init
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
block|msyslog(LOG_NOTICE, "NeoClock4X(%d): firmware %c = %02Xh", unit, c, c);
endif|#
directive|endif
if|if
condition|(
literal|0x0A
operator|==
name|c
operator|||
literal|0x0D
operator|==
name|c
condition|)
block|{
if|if
condition|(
name|last_c_was_crlf
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|strstr
argument_list|(
operator|&
name|tmpbuf
index|[
name|lastsearch
index|]
argument_list|,
literal|"S/N"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|ptr
condition|)
block|{
name|tmpbuf
index|[
name|last_crlf_conv_len
index|]
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* convert \n to / */
name|last_crlf_conv_len
operator|=
name|len
expr_stmt|;
name|tmpbuf
index|[
name|len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|tmpbuf
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|tmpbuf
index|[
name|len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|lastsearch
operator|=
name|len
expr_stmt|;
block|}
name|last_c_was_crlf
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|last_c_was_crlf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0x00
operator|!=
name|c
condition|)
name|tmpbuf
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
name|tmpbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|-
literal|5
condition|)
break|break;
block|}
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NeoClock4X(%d): can't query firmware version"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"unknown error"
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|firmware
argument_list|,
name|tmpbuf
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|firmware
index|[
name|maxlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NeoClock4X(%d): firmware version: %s"
argument_list|,
name|unit
argument_list|,
name|firmware
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|flag
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|neol_check_firmware
parameter_list|(
name|int
name|unit
parameter_list|,
specifier|const
name|char
modifier|*
name|firmware
parameter_list|,
name|char
modifier|*
name|firmwaretag
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
operator|*
name|firmwaretag
operator|=
literal|'?'
expr_stmt|;
name|ptr
operator|=
name|strstr
argument_list|(
name|firmware
argument_list|,
literal|"NDF:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|ptr
condition|)
block|{
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|firmware
argument_list|)
operator|-
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|)
operator|>=
literal|7
condition|)
block|{
if|if
condition|(
literal|':'
operator|==
operator|*
operator|(
name|ptr
operator|+
literal|5
operator|)
operator|&&
literal|'*'
operator|==
operator|*
operator|(
name|ptr
operator|+
literal|6
operator|)
condition|)
operator|*
name|firmwaretag
operator|=
operator|*
operator|(
name|ptr
operator|+
literal|4
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|'A'
operator|!=
operator|*
name|firmwaretag
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"NeoClock4X(%d): firmware version \"%c\" not supported with this driver version!"
argument_list|,
name|unit
argument_list|,
operator|*
name|firmwaretag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_neoclock4x_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_comment
comment|/*  * History:  * refclock_neoclock4x.c  *  * 2002/04/27 cjh  * Revision 1.0  first release  *  * 2002/07/15 cjh  * preparing for bitkeeper reposity  *  * 2002/09/09 cjh  * Revision 1.1  * - don't assume sprintf returns an int anymore  * - change the way the firmware version is read  * - some customers would like to put a device called  *   data diode to the NeoClock4X device to disable  *   the write line. We need to now the firmware  *   version even in this case. We made a compile time  *   definition in this case. The code was previously  *   only available on request.  *  * 2003/01/08 cjh  * Revision 1.11  * - changing xprinf to xnprinf to avoid buffer overflows  * - change some logic  * - fixed memory leaks if drivers can't initialize  *  * 2003/01/10 cjh  * Revision 1.12  * - replaced ldiv  * - add code to support FreeBSD  *  * 2003/07/07 cjh  * Revision 1.13  * - fix reporting of clock status  *   changes. previously a bad clock  *   status was never reset.  */
end_comment

end_unit

