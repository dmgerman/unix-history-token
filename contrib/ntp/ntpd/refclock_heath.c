begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_heath - clock driver for Heath GC-1000 and and GC-1000 II  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_HEATH
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_SYS_IOCTL_H */
end_comment

begin_comment
comment|/*  * This driver supports the Heath GC-1000 Most Accurate Clock, with  * RS232C Output Accessory. This is a WWV/WWVH receiver somewhat less  * robust than other supported receivers. Its claimed accuracy is 100 ms  * when actually synchronized to the broadcast signal, but this doesn't  * happen even most of the time, due to propagation conditions, ambient  * noise sources, etc. When not synchronized, the accuracy is at the  * whim of the internal clock oscillator, which can wander into the  * sunset without warning. Since the indicated precision is 100 ms,  * expect a host synchronized only to this thing to wander to and fro,  * occasionally being rudely stepped when the offset exceeds the default  * clock_max of 128 ms.   *  * There are two GC-1000 versions supported by this driver. The original  * GC-1000 with RS-232 output first appeared in 1983, but dissapeared  * from the market a few years later. The GC-1000 II with RS-232 output  * first appeared circa 1990, but apparently is no longer manufactured.  * The two models differ considerably, both in interface and commands.  * The GC-1000 has a pseudo-bipolar timecode output triggered by a RTS  * transition. The timecode includes both the day of year and time of  * day. The GC-1000 II has a true bipolar output and a complement of  * single character commands. The timecode includes only the time of  * day.  *  * GC-1000  *  * The internal DIPswitches should be set to operate in MANUAL mode. The  * external DIPswitches should be set to GMT and 24-hour format.  *  * In MANUAL mode the clock responds to a rising edge of the request to  * send (RTS) modem control line by sending the timecode. Therefore, it  * is necessary that the operating system implement the TIOCMBIC and  * TIOCMBIS ioctl system calls and TIOCM_RTS control bit. Present  * restrictions require the use of a POSIX-compatible programming  * interface, although other interfaces may work as well.  *  * A simple hardware modification to the clock can be made which  * prevents the clock hearing the request to send (RTS) if the HI SPEC  * lamp is out. Route the HISPEC signal to the tone decoder board pin  * 19, from the display, pin 19. Isolate pin 19 of the decoder board  * first, but maintain connection with pin 10. Also isolate pin 38 of  * the CPU on the tone board, and use half an added 7400 to gate the  * original signal to pin 38 with that from pin 19.  *  * The clock message consists of 23 ASCII printing characters in the  * following format:  *  * hh:mm:ss.f AM  dd/mm/yr<cr>  *  *	hh:mm:ss.f = hours, minutes, seconds  *	f = deciseconds ('?' when out of spec)  *	AM/PM/bb = blank in 24-hour mode  *	dd/mm/yr = day, month, year  *  * The alarm condition is indicated by '?', rather than a digit, at f.  * Note that 0?:??:??.? is displayed before synchronization is first  * established and hh:mm:ss.? once synchronization is established and  * then lost again for about a day.  *  * GC-1000 II  *  * Commands consist of a single letter and are case sensitive. When  * enterred in lower case, a description of the action performed is  * displayed. When enterred in upper case the action is performed.  * Following is a summary of descriptions as displayed by the clock:  *  * The clock responds with a command The 'A' command returns an ASCII  * local time string:  HH:MM:SS.T xx<CR>, where  *  *	HH = hours  *	MM = minutes  *	SS = seconds  *	T = tenths-of-seconds  *	xx = 'AM', 'PM', or '  '  *<CR> = carriage return  *  * The 'D' command returns 24 pairs of bytes containing the variable  * divisor value at the end of each of the previous 24 hours. This  * allows the timebase trimming process to be observed.  UTC hour 00 is  * always returned first. The first byte of each pair is the high byte  * of (variable divisor * 16); the second byte is the low byte of  * (variable divisor * 16). For example, the byte pair 3C 10 would be  * returned for a divisor of 03C1 hex (961 decimal).  *  * The 'I' command returns:  | TH | TL | ER | DH | DL | U1 | I1 | I2 | ,  * where  *  *	TH = minutes since timebase last trimmed (high byte)  *	TL = minutes since timebase last trimmed (low byte)  *	ER = last accumulated error in 1.25 ms increments  *	DH = high byte of (current variable divisor * 16)  *	DL = low byte of (current variable divisor * 16)  *	U1 = UT1 offset (/.1 s):  | + | 4 | 2 | 1 | 0 | 0 | 0 | 0 |  *	I1 = information byte 1:  | W | C | D | I | U | T | Z | 1 | ,  *	     where  *  *		W = set by WWV(H)  *		C = CAPTURE LED on  *		D = TRIM DN LED on  *		I = HI SPEC LED on  *		U = TRIM UP LED on  *		T = DST switch on  *		Z = UTC switch on  *		1 = UT1 switch on  *  *	I2 = information byte 2:  | 8 | 8 | 4 | 2 | 1 | D | d | S | ,  *	     where  *  *		8, 8, 4, 2, 1 = TIME ZONE switch settings  *		D = DST bit (#55) in last-received frame  *		d = DST bit (#2) in last-received frame  *		S = clock is in simulation mode  *  * The 'P' command returns 24 bytes containing the number of frames  * received without error during UTC hours 00 through 23, providing an  * indication of hourly propagation.  These bytes are updated each hour  * to reflect the previous 24 hour period.  UTC hour 00 is always  * returned first.  *  * The 'T' command returns the UTC time:  | HH | MM | SS | T0 | , where  *	HH = tens-of-hours and hours (packed BCD)  *	MM = tens-of-minutes and minutes (packed BCD)  *	SS = tens-of-seconds and seconds (packed BCD)  *	T = tenths-of-seconds (BCD)  *  * Fudge Factors  *  * A fudge time1 value of .04 s appears to center the clock offset  * residuals. The fudge time2 parameter is the local time offset east of  * Greenwich, which depends on DST. Sorry about that, but the clock  * gives no hint on what the DIPswitches say.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/heath%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-4)
end_define

begin_comment
comment|/* precision assumed (about 100 ms) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"WWV\0"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"Heath GC-1000 Most Accurate Clock"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|LENHEATH1
value|23
end_define

begin_comment
comment|/* min timecode length */
end_comment

begin_define
define|#
directive|define
name|LENHEATH2
value|13
end_define

begin_comment
comment|/* min timecode length */
end_comment

begin_comment
comment|/*  * Tables to compute the ddd of year form icky dd/mm timecode. Viva la  * leap.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|day1tab
index|[]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|day2tab
index|[]
init|=
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Baud rate table. The GC-1000 supports 1200, 2400 and 4800; the  * GC-1000 II supports only 9600.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|speed
index|[]
init|=
block|{
name|B1200
block|,
name|B2400
block|,
name|B4800
block|,
name|B9600
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|heathunit
block|{
name|int
name|pollcnt
decl_stmt|;
comment|/* poll message counter */
name|l_fp
name|tstamp
decl_stmt|;
comment|/* timestamp of last poll */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|heath_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|heath_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|heath_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|heath_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_heath
init|=
block|{
name|heath_start
block|,
comment|/* start up driver */
name|heath_shutdown
block|,
comment|/* shut down driver */
name|heath_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old heath_control) */
name|noentry
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* not used (old heath_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * heath_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|heath_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|heathunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Open serial port 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|speed
index|[
name|peer
operator|->
name|ttlmax
operator|&
literal|0x3
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|heathunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|heathunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|heathunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|heath_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|NSTAGE
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * heath_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|heath_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|heathunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|heathunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * heath_receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|heath_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|heathunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|l_fp
name|trtmp
decl_stmt|;
name|int
name|month
decl_stmt|,
name|day
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|dsec
decl_stmt|,
name|a
index|[
literal|5
index|]
decl_stmt|;
comment|/* 	 * Initialize pointers and read the timecode and timestamp 	 */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|heathunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|trtmp
argument_list|)
expr_stmt|;
comment|/* 	 * We get a buffer and timestamp for each<cr>; however, we use 	 * the timestamp captured at the RTS modem control line toggle 	 * on the assumption that's what the radio bases the timecode 	 * on. Apparently, the radio takes about a second to make up its 	 * mind to send a timecode, so the receive timestamp is 	 * worthless. 	 */
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|tstamp
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"heath: timecode %d %s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We get down to business, check the timecode format and decode 	 * its contents. If the timecode has invalid length or is not in 	 * proper format, we declare bad format and exit. 	 */
switch|switch
condition|(
name|pp
operator|->
name|lencode
condition|)
block|{
comment|/* 	 * GC-1000 timecode format: "hh:mm:ss.f AM  mm/dd/yy" 	 * GC-1000 II timecode format: "hh:mm:ss.f   " 	 */
case|case
name|LENHEATH1
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%2d:%2d:%2d.%c%5c%2d/%2d/%2d"
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|dsec
argument_list|,
name|a
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|)
operator|!=
literal|8
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
comment|/* 	 * GC-1000 II timecode format: "hh:mm:ss.f   " 	 */
case|case
name|LENHEATH2
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%2d:%2d:%2d.%c"
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|dsec
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We determine the day of the year from the DIPswitches. This 	 * should be fixed, since somebody might forget to set them. 	 * Someday this hazard will be fixed by a fiendish scheme that 	 * looks at the timecode and year the radio shows, then computes 	 * the residue of the seconds mod the seconds in a leap cycle. 	 * If in the third year of that cycle and the third and later 	 * months of that year, add one to the day. Then, correct the 	 * timecode accordingly. Icky pooh. This bit of nonsense could 	 * be avoided if the engineers had been required to write a 	 * device driver before finalizing the timecode format. 	 */
if|if
condition|(
name|month
operator|<
literal|1
operator|||
name|month
operator|>
literal|12
operator|||
name|day
operator|<
literal|1
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pp
operator|->
name|year
operator|%
literal|4
condition|)
block|{
if|if
condition|(
name|day
operator|>
name|day1tab
index|[
name|month
operator|-
literal|1
index|]
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|month
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|day
operator|+=
name|day1tab
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|day
operator|>
name|day2tab
index|[
name|month
operator|-
literal|1
index|]
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|month
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|day
operator|+=
name|day2tab
index|[
name|i
index|]
expr_stmt|;
block|}
name|pp
operator|->
name|day
operator|=
name|day
expr_stmt|;
comment|/* 	 * Determine synchronization and last update 	 */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|dsec
argument_list|)
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
else|else
block|{
name|pp
operator|->
name|msec
operator|=
operator|(
name|dsec
operator|-
literal|'0'
operator|)
operator|*
literal|100
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|)
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * heath_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|heath_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|heathunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|bits
init|=
name|TIOCM_RTS
decl_stmt|;
comment|/* 	 * At each poll we check for timeout and toggle the RTS modem 	 * control line, then take a timestamp. Presumably, this is the 	 * event the radio captures to generate the timecode. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|heathunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
comment|/* 	 * We toggle the RTS modem control lead (GC-1000) and sent a T 	 * (GC-1000 II) to kick a timecode loose from the radio. This 	 * code works only for POSIX and SYSV interfaces. With bsd you 	 * are on your own. We take a timestamp between the up and down 	 * edges to lengthen the pulse, which should be about 50 usec on 	 * a Sun IPC. With hotshot CPUs, the pulse might get too short. 	 * Later. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bits
argument_list|)
operator|<
literal|0
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|up
operator|->
name|tstamp
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"T"
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|NSTAGE
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_heath_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

