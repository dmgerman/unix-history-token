begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_monitor - monitor ntpd statistics  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_if.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * I'm still not sure I like what I've done here. It certainly consumes  * memory like it is going out of style, and also may not be as low  * overhead as I'd imagined.  *  * Anyway, we record statistics based on source address, mode and  * version (for now, anyway. Check the code).  The receive procedure  * calls us with the incoming rbufp before it does anything else.  *  * Each entry is doubly linked into two lists, a hash table and a  * most-recently-used list. When a packet arrives it is looked up in  * the hash table.  If found, the statistics are updated and the entry  * relinked at the head of the MRU list. If not found, a new entry is  * allocated, initialized and linked into both the hash table and at the  * head of the MRU list.  *  * Memory is usually allocated by grabbing a big chunk of new memory and  * cutting it up into littler pieces. The exception to this when we hit  * the memory limit. Then we free memory by grabbing entries off the  * tail for the MRU list, unlinking from the hash table, and  * reinitializing.  *  * trimmed back memory consumption ... jdg 8/94  */
end_comment

begin_comment
comment|/*  * Limits on the number of structures allocated.  This limit is picked  * with the illicit knowlege that we can only return somewhat less  * than 8K bytes in a mode 7 response packet, and that each structure  * will require about 20 bytes of space in the response.  *  * ... I don't believe the above is true anymore ... jdg  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXMONMEM
end_ifndef

begin_define
define|#
directive|define
name|MAXMONMEM
value|600
end_define

begin_comment
comment|/* we allocate up to 600 structures */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MONMEMINC
end_ifndef

begin_define
define|#
directive|define
name|MONMEMINC
value|40
end_define

begin_comment
comment|/* allocate them 40 at a time */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Hashing stuff  */
end_comment

begin_define
define|#
directive|define
name|MON_HASH_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|MON_HASH_MASK
value|(MON_HASH_SIZE-1)
end_define

begin_define
define|#
directive|define
name|MON_HASH
parameter_list|(
name|addr
parameter_list|)
value|sock_hash(addr)
end_define

begin_comment
comment|/*  * Pointers to the hash table, the MRU list and the count table.  Memory  * for the hash and count tables is only allocated if monitoring is  * turned on.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mon_data
modifier|*
name|mon_hash
index|[
name|MON_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list ptrs */
end_comment

begin_decl_stmt
name|struct
name|mon_data
name|mon_mru_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of free structures structures, and counters of free and total  * structures.  The free structures are linked with the hash_next field.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mon_data
modifier|*
name|mon_free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free list or null if none */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mon_total_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total structures allocated */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mon_mem_increments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* times called malloc() */
end_comment

begin_comment
comment|/*  * Initialization state.  We may be monitoring, we may not.  If  * we aren't, we may not even have allocated any memory yet.  */
end_comment

begin_decl_stmt
name|int
name|mon_enabled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable switch */
end_comment

begin_decl_stmt
name|u_long
name|mon_age
init|=
literal|3000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* preemption limit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mon_have_memory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mon_getmoremem
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_from_hash
name|P
argument_list|(
operator|(
expr|struct
name|mon_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * init_mon - initialize monitoring global data  */
end_comment

begin_function
name|void
name|init_mon
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Don't do much of anything here.  We don't allocate memory 	 * until someone explicitly starts us. 	 */
name|mon_enabled
operator|=
name|MON_OFF
expr_stmt|;
name|mon_have_memory
operator|=
literal|0
expr_stmt|;
name|mon_total_mem
operator|=
literal|0
expr_stmt|;
name|mon_mem_increments
operator|=
literal|0
expr_stmt|;
name|mon_free
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mon_hash
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|mon_hash
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mon_mru_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|mon_mru_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_start - start up the monitoring software  */
end_comment

begin_function
name|void
name|mon_start
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mon_enabled
operator|!=
name|MON_OFF
condition|)
block|{
name|mon_enabled
operator||=
name|mode
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mode
operator|==
name|MON_OFF
condition|)
return|return;
if|if
condition|(
operator|!
name|mon_have_memory
condition|)
block|{
name|mon_total_mem
operator|=
literal|0
expr_stmt|;
name|mon_mem_increments
operator|=
literal|0
expr_stmt|;
name|mon_free
operator|=
name|NULL
expr_stmt|;
name|mon_getmoremem
argument_list|()
expr_stmt|;
name|mon_have_memory
operator|=
literal|1
expr_stmt|;
block|}
name|mon_mru_list
operator|.
name|mru_next
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_enabled
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_stop - stop the monitoring software  */
end_comment

begin_function
name|void
name|mon_stop
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|,
modifier|*
name|md_next
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mon_enabled
operator|==
name|MON_OFF
condition|)
return|return;
if|if
condition|(
operator|(
name|mon_enabled
operator|&
name|mode
operator|)
operator|==
literal|0
operator|||
name|mode
operator|==
name|MON_OFF
condition|)
return|return;
name|mon_enabled
operator|&=
operator|~
name|mode
expr_stmt|;
if|if
condition|(
name|mon_enabled
operator|!=
name|MON_OFF
condition|)
return|return;
comment|/* 	 * Put everything back on the free list 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MON_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|=
name|mon_hash
index|[
name|i
index|]
expr_stmt|;
comment|/* get next list */
name|mon_hash
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* zero the list head */
while|while
condition|(
name|md
operator|!=
name|NULL
condition|)
block|{
name|md_next
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
name|md
operator|->
name|hash_next
operator|=
name|mon_free
expr_stmt|;
name|mon_free
operator|=
name|md
expr_stmt|;
name|md
operator|=
name|md_next
expr_stmt|;
block|}
block|}
name|mon_mru_list
operator|.
name|mru_next
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ntp_monitor - record stats about this packet  */
end_comment

begin_function
name|void
name|ntp_monitor
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|mon_enabled
operator|==
name|MON_OFF
condition|)
return|return;
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
operator|(
name|rbufp
operator|->
name|recv_srcadr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
name|MON_HASH
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|md
operator|=
name|mon_hash
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|md
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Match address only to conserve MRU size. 		 */
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|md
operator|->
name|rmtadr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|md
operator|->
name|drop_count
operator|=
name|current_time
operator|-
name|md
operator|->
name|lasttime
expr_stmt|;
name|md
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
name|md
operator|->
name|count
operator|++
expr_stmt|;
name|md
operator|->
name|rmtport
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|md
operator|->
name|mode
operator|=
operator|(
name|u_char
operator|)
name|mode
expr_stmt|;
name|md
operator|->
name|version
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
comment|/* 			 * Shuffle to the head of the MRU list. 			 */
name|md
operator|->
name|mru_next
operator|->
name|mru_prev
operator|=
name|md
operator|->
name|mru_prev
expr_stmt|;
name|md
operator|->
name|mru_prev
operator|->
name|mru_next
operator|=
name|md
operator|->
name|mru_next
expr_stmt|;
name|md
operator|->
name|mru_next
operator|=
name|mon_mru_list
operator|.
name|mru_next
expr_stmt|;
name|md
operator|->
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|->
name|mru_prev
operator|=
name|md
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|=
name|md
expr_stmt|;
return|return;
block|}
name|md
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
block|}
comment|/* 	 * If we got here, this is the first we've heard of this 	 * guy.  Get him some memory, either from the free list 	 * or from the tail of the MRU list. 	 */
if|if
condition|(
name|mon_free
operator|==
name|NULL
operator|&&
name|mon_total_mem
operator|>=
name|MAXMONMEM
condition|)
block|{
comment|/* 		 * Preempt from the MRU list if old enough. 		 */
name|md
operator|=
name|mon_mru_list
operator|.
name|mru_prev
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|RANDOM
operator|&
literal|0xffffffff
operator|)
operator|/
name|FRAC
operator|>
call|(
name|double
call|)
argument_list|(
name|current_time
operator|-
name|md
operator|->
name|lasttime
argument_list|)
operator|/
name|mon_age
condition|)
return|return;
name|md
operator|->
name|mru_prev
operator|->
name|mru_next
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_prev
operator|=
name|md
operator|->
name|mru_prev
expr_stmt|;
name|remove_from_hash
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mon_free
operator|==
name|NULL
condition|)
name|mon_getmoremem
argument_list|()
expr_stmt|;
name|md
operator|=
name|mon_free
expr_stmt|;
name|mon_free
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
block|}
comment|/* 	 * Got one, initialize it 	 */
name|md
operator|->
name|avg_interval
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
name|md
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|md
operator|->
name|drop_count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|md
operator|->
name|rmtadr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|rmtadr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|md
operator|->
name|rmtadr
argument_list|,
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|rmtport
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|md
operator|->
name|mode
operator|=
operator|(
name|u_char
operator|)
name|mode
expr_stmt|;
name|md
operator|->
name|version
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|md
operator|->
name|interface
operator|=
name|rbufp
operator|->
name|dstadr
expr_stmt|;
name|md
operator|->
name|cast_flags
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
operator|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MULTICAST
operator|)
operator|&&
name|rbufp
operator|->
name|fd
operator|==
name|md
operator|->
name|interface
operator|->
name|fd
operator|)
condition|?
name|MDF_MCAST
else|:
name|rbufp
operator|->
name|fd
operator|==
name|md
operator|->
name|interface
operator|->
name|bfd
condition|?
name|MDF_BCAST
else|:
name|MDF_UCAST
argument_list|)
expr_stmt|;
comment|/* 	 * Drop him into front of the hash table. Also put him on top of 	 * the MRU list. 	 */
name|md
operator|->
name|hash_next
operator|=
name|mon_hash
index|[
name|hash
index|]
expr_stmt|;
name|mon_hash
index|[
name|hash
index|]
operator|=
name|md
expr_stmt|;
name|md
operator|->
name|mru_next
operator|=
name|mon_mru_list
operator|.
name|mru_next
expr_stmt|;
name|md
operator|->
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|->
name|mru_prev
operator|=
name|md
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|=
name|md
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_getmoremem - get more memory and put it on the free list  */
end_comment

begin_function
specifier|static
name|void
name|mon_getmoremem
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|mon_data
modifier|*
name|freedata
decl_stmt|;
comment|/* 'old' free list (null) */
name|md
operator|=
operator|(
expr|struct
name|mon_data
operator|*
operator|)
name|emalloc
argument_list|(
name|MONMEMINC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mon_data
argument_list|)
argument_list|)
expr_stmt|;
name|freedata
operator|=
name|mon_free
expr_stmt|;
name|mon_free
operator|=
name|md
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|MONMEMINC
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|->
name|hash_next
operator|=
operator|(
name|md
operator|+
literal|1
operator|)
expr_stmt|;
name|md
operator|++
expr_stmt|;
block|}
comment|/* 	 * md now points at the last.  Link in the rest of the chain. 	 */
name|md
operator|->
name|hash_next
operator|=
name|freedata
expr_stmt|;
name|mon_total_mem
operator|+=
name|MONMEMINC
expr_stmt|;
name|mon_mem_increments
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_from_hash
parameter_list|(
name|struct
name|mon_data
modifier|*
name|md
parameter_list|)
block|{
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|struct
name|mon_data
modifier|*
name|md_prev
decl_stmt|;
name|hash
operator|=
name|MON_HASH
argument_list|(
operator|&
name|md
operator|->
name|rmtadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mon_hash
index|[
name|hash
index|]
operator|==
name|md
condition|)
block|{
name|mon_hash
index|[
name|hash
index|]
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
block|}
else|else
block|{
name|md_prev
operator|=
name|mon_hash
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|md_prev
operator|->
name|hash_next
operator|!=
name|md
condition|)
block|{
name|md_prev
operator|=
name|md_prev
operator|->
name|hash_next
expr_stmt|;
if|if
condition|(
name|md_prev
operator|==
name|NULL
condition|)
block|{
comment|/* logic error */
return|return;
block|}
block|}
name|md_prev
operator|->
name|hash_next
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
block|}
block|}
end_function

end_unit

