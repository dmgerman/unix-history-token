begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_monitor - monitor ntpd statistics  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_if.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lists.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<ntp_random.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Record statistics based on source address, mode and version. The  * receive procedure calls us with the incoming rbufp before it does  * anything else. While at it, implement rate controls for inbound  * traffic.  *  * Each entry is doubly linked into two lists, a hash table and a most-  * recently-used (MRU) list. When a packet arrives it is looked up in  * the hash table. If found, the statistics are updated and the entry  * relinked at the head of the MRU list. If not found, a new entry is  * allocated, initialized and linked into both the hash table and at the  * head of the MRU list.  *  * Memory is usually allocated by grabbing a big chunk of new memory and  * cutting it up into littler pieces. The exception to this when we hit  * the memory limit. Then we free memory by grabbing entries off the  * tail for the MRU list, unlinking from the hash table, and  * reinitializing.  *  * INC_MONLIST is the default allocation granularity in entries.  * INIT_MONLIST is the default initial allocation in entries.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MONMEMINC
end_ifdef

begin_comment
comment|/* old name */
end_comment

begin_define
define|#
directive|define
name|INC_MONLIST
value|MONMEMINC
end_define

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|INC_MONLIST
argument_list|)
end_elif

begin_define
define|#
directive|define
name|INC_MONLIST
value|(4 * 1024 / sizeof(mon_entry))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INIT_MONLIST
end_ifndef

begin_define
define|#
directive|define
name|INIT_MONLIST
value|(4 * 1024 / sizeof(mon_entry))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MRU_MAXDEPTH_DEF
end_ifndef

begin_define
define|#
directive|define
name|MRU_MAXDEPTH_DEF
value|(1024 * 1024 / sizeof(mon_entry))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Hashing stuff  */
end_comment

begin_decl_stmt
name|u_char
name|mon_hash_bits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pointers to the hash table and the MRU list.  Memory for the hash  * table is allocated only if monitoring is enabled.  */
end_comment

begin_decl_stmt
name|mon_entry
modifier|*
modifier|*
name|mon_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MRU hash table */
end_comment

begin_decl_stmt
name|mon_entry
name|mon_mru_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mru listhead */
end_comment

begin_comment
comment|/*  * List of free structures structures, and counters of in-use and total  * structures. The free structures are linked with the hash_next field.  */
end_comment

begin_decl_stmt
specifier|static
name|mon_entry
modifier|*
name|mon_free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free list or null if none */
end_comment

begin_decl_stmt
name|u_int
name|mru_alloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mru list + free list count */
end_comment

begin_decl_stmt
name|u_int
name|mru_entries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mru list count */
end_comment

begin_decl_stmt
name|u_int
name|mru_peakentries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* highest mru_entries seen */
end_comment

begin_decl_stmt
name|u_int
name|mru_initalloc
init|=
name|INIT_MONLIST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* entries to preallocate */
end_comment

begin_decl_stmt
name|u_int
name|mru_incalloc
init|=
name|INC_MONLIST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allocation batch factor */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|mon_mem_increments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* times called malloc() */
end_comment

begin_comment
comment|/*  * Parameters of the RES_LIMITED restriction option. We define headway  * as the idle time between packets. A packet is discarded if the  * headway is less than the minimum, as well as if the average headway  * is less than eight times the increment.  */
end_comment

begin_decl_stmt
name|int
name|ntp_minpkt
init|=
name|NTP_MINPKT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum (log 2 s) */
end_comment

begin_decl_stmt
name|u_char
name|ntp_minpoll
init|=
name|NTP_MINPOLL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* increment (log 2 s) */
end_comment

begin_comment
comment|/*  * Initialization state.  We may be monitoring, we may not.  If  * we aren't, we may not even have allocated any memory yet.  */
end_comment

begin_decl_stmt
name|u_int
name|mon_enabled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable switch */
end_comment

begin_decl_stmt
name|u_int
name|mru_mindepth
init|=
literal|600
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* preempt above this */
end_comment

begin_decl_stmt
name|int
name|mru_maxage
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for entries older than */
end_comment

begin_decl_stmt
name|u_int
name|mru_maxdepth
init|=
comment|/* MRU count hard limit */
name|MRU_MAXDEPTH_DEF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mon_age
init|=
literal|3000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* preemption limit */
end_comment

begin_function_decl
specifier|static
name|void
name|mon_getmoremem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_from_hash
parameter_list|(
name|mon_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mon_free_entry
parameter_list|(
name|mon_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mon_reclaim_entry
parameter_list|(
name|mon_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * init_mon - initialize monitoring global data  */
end_comment

begin_function
name|void
name|init_mon
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Don't do much of anything here.  We don't allocate memory 	 * until mon_start(). 	 */
name|mon_enabled
operator|=
name|MON_OFF
expr_stmt|;
name|INIT_DLIST
argument_list|(
name|mon_mru_list
argument_list|,
name|mru
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove_from_hash - removes an entry from the address hash table and  *		      decrements mru_entries.  */
end_comment

begin_function
specifier|static
name|void
name|remove_from_hash
parameter_list|(
name|mon_entry
modifier|*
name|mon
parameter_list|)
block|{
name|u_int
name|hash
decl_stmt|;
name|mon_entry
modifier|*
name|punlinked
decl_stmt|;
name|mru_entries
operator|--
expr_stmt|;
name|hash
operator|=
name|MON_HASH
argument_list|(
operator|&
name|mon
operator|->
name|rmtadr
argument_list|)
expr_stmt|;
name|UNLINK_SLIST
argument_list|(
name|punlinked
argument_list|,
name|mon_hash
index|[
name|hash
index|]
argument_list|,
name|mon
argument_list|,
name|hash_next
argument_list|,
name|mon_entry
argument_list|)
expr_stmt|;
name|NTP_ENSURE
argument_list|(
name|punlinked
operator|==
name|mon
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mon_free_entry
parameter_list|(
name|mon_entry
modifier|*
name|m
parameter_list|)
block|{
name|ZERO
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|mon_free
argument_list|,
name|m
argument_list|,
name|hash_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_reclaim_entry - Remove an entry from the MRU list and from the  *		       hash array, then zero-initialize it.  Indirectly  *		       decrements mru_entries.   * The entry is prepared to be reused.  Before return, in  * remove_from_hash(), mru_entries is decremented.  It is the caller's  * responsibility to increment it again.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mon_reclaim_entry
parameter_list|(
name|mon_entry
modifier|*
name|m
parameter_list|)
block|{
name|DEBUG_INSIST
argument_list|(
name|NULL
operator|!=
name|m
argument_list|)
expr_stmt|;
name|UNLINK_DLIST
argument_list|(
name|m
argument_list|,
name|mru
argument_list|)
expr_stmt|;
name|remove_from_hash
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_getmoremem - get more memory and put it on the free list  */
end_comment

begin_function
specifier|static
name|void
name|mon_getmoremem
parameter_list|(
name|void
parameter_list|)
block|{
name|mon_entry
modifier|*
name|chunk
decl_stmt|;
name|u_int
name|entries
decl_stmt|;
name|entries
operator|=
operator|(
literal|0
operator|==
name|mon_mem_increments
operator|)
condition|?
name|mru_initalloc
else|:
name|mru_incalloc
expr_stmt|;
if|if
condition|(
name|entries
condition|)
block|{
name|chunk
operator|=
name|emalloc
argument_list|(
name|entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|chunk
argument_list|)
argument_list|)
expr_stmt|;
name|mru_alloc
operator|+=
name|entries
expr_stmt|;
for|for
control|(
name|chunk
operator|+=
name|entries
init|;
name|entries
condition|;
name|entries
operator|--
control|)
name|mon_free_entry
argument_list|(
operator|--
name|chunk
argument_list|)
expr_stmt|;
name|mon_mem_increments
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * mon_start - start up the monitoring software  */
end_comment

begin_function
name|void
name|mon_start
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|size_t
name|octets
decl_stmt|;
name|u_int
name|min_hash_slots
decl_stmt|;
if|if
condition|(
name|MON_OFF
operator|==
name|mode
condition|)
comment|/* MON_OFF is 0 */
return|return;
if|if
condition|(
name|mon_enabled
condition|)
block|{
name|mon_enabled
operator||=
name|mode
expr_stmt|;
return|return;
block|}
if|if
condition|(
literal|0
operator|==
name|mon_mem_increments
condition|)
name|mon_getmoremem
argument_list|()
expr_stmt|;
comment|/* 	 * Select the MRU hash table size to limit the average count 	 * per bucket at capacity (mru_maxdepth) to 8, if possible 	 * given our hash is limited to 16 bits. 	 */
name|min_hash_slots
operator|=
operator|(
name|mru_maxdepth
operator|/
literal|8
operator|)
operator|+
literal|1
expr_stmt|;
name|mon_hash_bits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|min_hash_slots
operator|>>=
literal|1
condition|)
name|mon_hash_bits
operator|++
expr_stmt|;
name|mon_hash_bits
operator|=
name|max
argument_list|(
literal|4
argument_list|,
name|mon_hash_bits
argument_list|)
expr_stmt|;
name|mon_hash_bits
operator|=
name|min
argument_list|(
literal|16
argument_list|,
name|mon_hash_bits
argument_list|)
expr_stmt|;
name|octets
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mon_hash
argument_list|)
operator|*
name|MON_HASH_SIZE
expr_stmt|;
name|mon_hash
operator|=
name|erealloc_zero
argument_list|(
name|mon_hash
argument_list|,
name|octets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mon_enabled
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_stop - stop the monitoring software  */
end_comment

begin_function
name|void
name|mon_stop
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|mon_entry
modifier|*
name|mon
decl_stmt|;
if|if
condition|(
name|MON_OFF
operator|==
name|mon_enabled
condition|)
return|return;
if|if
condition|(
operator|(
name|mon_enabled
operator|&
name|mode
operator|)
operator|==
literal|0
operator|||
name|mode
operator|==
name|MON_OFF
condition|)
return|return;
name|mon_enabled
operator|&=
operator|~
name|mode
expr_stmt|;
if|if
condition|(
name|mon_enabled
operator|!=
name|MON_OFF
condition|)
return|return;
comment|/* 	 * Move everything on the MRU list to the free list quickly, 	 * without bothering to remove each from either the MRU list or 	 * the hash table. 	 */
name|ITER_DLIST_BEGIN
argument_list|(
argument|mon_mru_list
argument_list|,
argument|mon
argument_list|,
argument|mru
argument_list|,
argument|mon_entry
argument_list|)
name|mon_free_entry
argument_list|(
name|mon
argument_list|)
expr_stmt|;
name|ITER_DLIST_END
argument_list|()
comment|/* empty the MRU list and hash table. */
name|mru_entries
operator|=
literal|0
expr_stmt|;
name|INIT_DLIST
argument_list|(
name|mon_mru_list
argument_list|,
name|mru
argument_list|)
expr_stmt|;
name|zero_mem
argument_list|(
name|mon_hash
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mon_hash
argument_list|)
operator|*
name|MON_HASH_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_clearinterface -- remove mru entries referring to a local address  *			 which is going away.  */
end_comment

begin_function
name|void
name|mon_clearinterface
parameter_list|(
name|endpt
modifier|*
name|lcladr
parameter_list|)
block|{
name|mon_entry
modifier|*
name|mon
decl_stmt|;
comment|/* iterate mon over mon_mru_list */
name|ITER_DLIST_BEGIN
argument_list|(
argument|mon_mru_list
argument_list|,
argument|mon
argument_list|,
argument|mru
argument_list|,
argument|mon_entry
argument_list|)
if|if
condition|(
name|mon
operator|->
name|lcladr
operator|==
name|lcladr
condition|)
block|{
comment|/* remove from mru list */
name|UNLINK_DLIST
argument_list|(
name|mon
argument_list|,
name|mru
argument_list|)
expr_stmt|;
comment|/* remove from hash list, adjust mru_entries */
name|remove_from_hash
argument_list|(
name|mon
argument_list|)
expr_stmt|;
comment|/* put on free list */
name|mon_free_entry
argument_list|(
name|mon
argument_list|)
expr_stmt|;
block|}
name|ITER_DLIST_END
argument_list|()
block|}
end_function

begin_comment
comment|/*  * ntp_monitor - record stats about this packet  *  * Returns supplied restriction flags, with RES_LIMITED and RES_KOD  * cleared unless the packet should not be responded to normally  * (RES_LIMITED) and possibly should trigger a KoD response (RES_KOD).  * The returned flags are saved in the MRU entry, so that it reflects  * whether the last packet from that source triggered rate limiting,  * and if so, possible KoD response.  This implies you can not tell  * whether a given address is eligible for rate limiting/KoD from the  * monlist restrict bits, only whether or not the last packet triggered  * such responses.  ntpdc -c reslist lets you see whether RES_LIMITED  * or RES_KOD is lit for a particular address before ntp_monitor()'s  * typical dousing.  */
end_comment

begin_function
name|u_short
name|ntp_monitor
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|u_short
name|flags
parameter_list|)
block|{
name|l_fp
name|interval_fp
decl_stmt|;
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
name|mon_entry
modifier|*
name|mon
decl_stmt|;
name|mon_entry
modifier|*
name|oldest
decl_stmt|;
name|int
name|oldest_age
decl_stmt|;
name|u_int
name|hash
decl_stmt|;
name|u_short
name|restrict_mask
decl_stmt|;
name|u_char
name|mode
decl_stmt|;
name|u_char
name|version
decl_stmt|;
name|int
name|interval
decl_stmt|;
name|int
name|head
decl_stmt|;
comment|/* headway increment */
name|int
name|leak
decl_stmt|;
comment|/* new headway */
name|int
name|limit
decl_stmt|;
comment|/* average threshold */
if|if
condition|(
name|mon_enabled
operator|==
name|MON_OFF
condition|)
return|return
operator|~
operator|(
name|RES_LIMITED
operator||
name|RES_KOD
operator|)
operator|&
name|flags
return|;
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
name|hash
operator|=
name|MON_HASH
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|version
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|mon
operator|=
name|mon_hash
index|[
name|hash
index|]
expr_stmt|;
comment|/* 	 * We keep track of all traffic for a given IP in one entry, 	 * otherwise cron'ed ntpdate or similar evades RES_LIMITED. 	 */
for|for
control|(
init|;
name|mon
operator|!=
name|NULL
condition|;
name|mon
operator|=
name|mon
operator|->
name|hash_next
control|)
if|if
condition|(
name|SOCK_EQ
argument_list|(
operator|&
name|mon
operator|->
name|rmtadr
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|mon
operator|!=
name|NULL
condition|)
block|{
name|interval_fp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|interval_fp
argument_list|,
operator|&
name|mon
operator|->
name|last
argument_list|)
expr_stmt|;
comment|/* add one-half second to round up */
name|L_ADDUF
argument_list|(
operator|&
name|interval_fp
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|interval
operator|=
name|interval_fp
operator|.
name|l_i
expr_stmt|;
name|mon
operator|->
name|last
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|NSRCPORT
argument_list|(
operator|&
name|mon
operator|->
name|rmtadr
argument_list|)
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|mon
operator|->
name|count
operator|++
expr_stmt|;
name|restrict_mask
operator|=
name|flags
expr_stmt|;
name|mon
operator|->
name|vn_mode
operator|=
name|VN_MODE
argument_list|(
name|version
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Shuffle to the head of the MRU list. */
name|UNLINK_DLIST
argument_list|(
name|mon
argument_list|,
name|mru
argument_list|)
expr_stmt|;
name|LINK_DLIST
argument_list|(
name|mon_mru_list
argument_list|,
name|mon
argument_list|,
name|mru
argument_list|)
expr_stmt|;
comment|/* 		 * At this point the most recent arrival is first in the 		 * MRU list.  Decrease the counter by the headway, but 		 * not less than zero. 		 */
name|mon
operator|->
name|leak
operator|-=
name|interval
expr_stmt|;
name|mon
operator|->
name|leak
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|mon
operator|->
name|leak
argument_list|)
expr_stmt|;
name|head
operator|=
literal|1
operator|<<
name|ntp_minpoll
expr_stmt|;
name|leak
operator|=
name|mon
operator|->
name|leak
operator|+
name|head
expr_stmt|;
name|limit
operator|=
name|NTP_SHIFT
operator|*
name|head
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"MRU: interval %d headway %d limit %d\n"
operator|,
name|interval
operator|,
name|leak
operator|,
name|limit
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the minimum and average thresholds are not 		 * exceeded, douse the RES_LIMITED and RES_KOD bits and 		 * increase the counter by the headway increment.  Note 		 * that we give a 1-s grace for the minimum threshold 		 * and a 2-s grace for the headway increment.  If one or 		 * both thresholds are exceeded and the old counter is 		 * less than the average threshold, set the counter to 		 * the average threshold plus the increment and leave 		 * the RES_LIMITED and RES_KOD bits lit. Otherwise, 		 * leave the counter alone and douse the RES_KOD bit. 		 * This rate-limits the KoDs to no less than the average 		 * headway. 		 */
if|if
condition|(
name|interval
operator|+
literal|1
operator|>=
name|ntp_minpkt
operator|&&
name|leak
operator|<
name|limit
condition|)
block|{
name|mon
operator|->
name|leak
operator|=
name|leak
operator|-
literal|2
expr_stmt|;
name|restrict_mask
operator|&=
operator|~
operator|(
name|RES_LIMITED
operator||
name|RES_KOD
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mon
operator|->
name|leak
operator|<
name|limit
condition|)
name|mon
operator|->
name|leak
operator|=
name|limit
operator|+
name|head
expr_stmt|;
else|else
name|restrict_mask
operator|&=
operator|~
name|RES_KOD
expr_stmt|;
name|mon
operator|->
name|flags
operator|=
name|restrict_mask
expr_stmt|;
return|return
name|mon
operator|->
name|flags
return|;
block|}
comment|/* 	 * If we got here, this is the first we've heard of this 	 * guy.  Get him some memory, either from the free list 	 * or from the tail of the MRU list. 	 * 	 * The following ntp.conf "mru" knobs come into play determining 	 * the depth (or count) of the MRU list: 	 * - mru_mindepth ("mru mindepth") is a floor beneath which 	 *   entries are kept without regard to their age.  The 	 *   default is 600 which matches the longtime implementation 	 *   limit on the total number of entries. 	 * - mru_maxage ("mru maxage") is a ceiling on the age in 	 *   seconds of entries.  Entries older than this are 	 *   reclaimed once mon_mindepth is exceeded.  64s default. 	 *   Note that entries older than this can easily survive 	 *   as they are reclaimed only as needed. 	 * - mru_maxdepth ("mru maxdepth") is a hard limit on the 	 *   number of entries. 	 * - "mru maxmem" sets mru_maxdepth to the number of entries 	 *   which fit in the given number of kilobytes.  The default is 	 *   1024, or 1 megabyte. 	 * - mru_initalloc ("mru initalloc" sets the count of the 	 *   initial allocation of MRU entries. 	 * - "mru initmem" sets mru_initalloc in units of kilobytes. 	 *   The default is 4. 	 * - mru_incalloc ("mru incalloc" sets the number of entries to 	 *   allocate on-demand each time the free list is empty. 	 * - "mru incmem" sets mru_incalloc in units of kilobytes. 	 *   The default is 4. 	 * Whichever of "mru maxmem" or "mru maxdepth" occurs last in 	 * ntp.conf controls.  Similarly for "mru initalloc" and "mru 	 * initmem", and for "mru incalloc" and "mru incmem". 	 */
if|if
condition|(
name|mru_entries
operator|<
name|mru_mindepth
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|mon_free
condition|)
name|mon_getmoremem
argument_list|()
expr_stmt|;
name|UNLINK_HEAD_SLIST
argument_list|(
name|mon
argument_list|,
name|mon_free
argument_list|,
name|hash_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oldest
operator|=
name|TAIL_DLIST
argument_list|(
name|mon_mru_list
argument_list|,
name|mru
argument_list|)
expr_stmt|;
name|oldest_age
operator|=
literal|0
expr_stmt|;
comment|/* silence uninit warning */
if|if
condition|(
name|oldest
operator|!=
name|NULL
condition|)
block|{
name|interval_fp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|interval_fp
argument_list|,
operator|&
name|oldest
operator|->
name|last
argument_list|)
expr_stmt|;
comment|/* add one-half second to round up */
name|L_ADDUF
argument_list|(
operator|&
name|interval_fp
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|oldest_age
operator|=
name|interval_fp
operator|.
name|l_i
expr_stmt|;
block|}
comment|/* note -1 is legal for mru_maxage (disables) */
if|if
condition|(
name|oldest
operator|!=
name|NULL
operator|&&
name|mru_maxage
operator|<
name|oldest_age
condition|)
block|{
name|mon_reclaim_entry
argument_list|(
name|oldest
argument_list|)
expr_stmt|;
name|mon
operator|=
name|oldest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mon_free
operator|!=
name|NULL
operator|||
name|mru_alloc
operator|<
name|mru_maxdepth
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|mon_free
condition|)
name|mon_getmoremem
argument_list|()
expr_stmt|;
name|UNLINK_HEAD_SLIST
argument_list|(
name|mon
argument_list|,
name|mon_free
argument_list|,
name|hash_next
argument_list|)
expr_stmt|;
comment|/* Preempt from the MRU list if old enough. */
block|}
elseif|else
if|if
condition|(
name|ntp_random
argument_list|()
operator|/
operator|(
literal|2.
operator|*
name|FRAC
operator|)
operator|>
operator|(
name|double
operator|)
name|oldest_age
operator|/
name|mon_age
condition|)
block|{
return|return
operator|~
operator|(
name|RES_LIMITED
operator||
name|RES_KOD
operator|)
operator|&
name|flags
return|;
block|}
else|else
block|{
name|mon_reclaim_entry
argument_list|(
name|oldest
argument_list|)
expr_stmt|;
name|mon
operator|=
name|oldest
expr_stmt|;
block|}
block|}
comment|/* 	 * Got one, initialize it 	 */
name|mru_entries
operator|++
expr_stmt|;
name|mru_peakentries
operator|=
name|max
argument_list|(
name|mru_peakentries
argument_list|,
name|mru_entries
argument_list|)
expr_stmt|;
name|mon
operator|->
name|last
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|mon
operator|->
name|first
operator|=
name|mon
operator|->
name|last
expr_stmt|;
name|mon
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|mon
operator|->
name|flags
operator|=
operator|~
operator|(
name|RES_LIMITED
operator||
name|RES_KOD
operator|)
operator|&
name|flags
expr_stmt|;
name|mon
operator|->
name|leak
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mon
operator|->
name|rmtadr
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
sizeof|sizeof
argument_list|(
name|mon
operator|->
name|rmtadr
argument_list|)
argument_list|)
expr_stmt|;
name|mon
operator|->
name|vn_mode
operator|=
name|VN_MODE
argument_list|(
name|version
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|mon
operator|->
name|lcladr
operator|=
name|rbufp
operator|->
name|dstadr
expr_stmt|;
name|mon
operator|->
name|cast_flags
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
operator|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MCASTOPEN
operator|)
operator|&&
name|rbufp
operator|->
name|fd
operator|==
name|mon
operator|->
name|lcladr
operator|->
name|fd
operator|)
condition|?
name|MDF_MCAST
else|:
name|rbufp
operator|->
name|fd
operator|==
name|mon
operator|->
name|lcladr
operator|->
name|bfd
condition|?
name|MDF_BCAST
else|:
name|MDF_UCAST
argument_list|)
expr_stmt|;
comment|/* 	 * Drop him into front of the hash table. Also put him on top of 	 * the MRU list. 	 */
name|LINK_SLIST
argument_list|(
name|mon_hash
index|[
name|hash
index|]
argument_list|,
name|mon
argument_list|,
name|hash_next
argument_list|)
expr_stmt|;
name|LINK_DLIST
argument_list|(
name|mon_mru_list
argument_list|,
name|mon
argument_list|,
name|mru
argument_list|)
expr_stmt|;
return|return
name|mon
operator|->
name|flags
return|;
block|}
end_function

end_unit

