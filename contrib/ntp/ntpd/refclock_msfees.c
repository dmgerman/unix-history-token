begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* refclock_ees - clock driver for the EES M201 receiver */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_MSFEES
argument_list|)
operator|&&
name|defined
argument_list|(
name|PPS
argument_list|)
end_if

begin_comment
comment|/* Currently REQUIRES STREAM and PPSCD. CLK and CBREAK modes  * were removed as the code was overly hairy, they weren't in use  * (hence probably didn't work).  Still in RCS file at cl.cam.ac.uk  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BSD_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSV_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STREAM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TERMIOS_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PPSCLOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/* 	fudgefactor	= fudgetime1; 	os_delay	= fudgetime2; 	   offset_fudge	= os_delay + fudgefactor + inherent_delay; 	stratumtouse	= fudgeval1& 0xf 	debug		= fudgeval2; 	sloppyclockflag	= flags& CLK_FLAG1; 		1	  log smoothing summary when processing sample 		4	  dump the buffer from the clock 		8	  EIOGETKD the last n uS time stamps 	if (flags& CLK_FLAG2&& unitinuse) ees->leaphold = 0; 	ees->dump_vals	= flags& CLK_FLAG3; 	ees->usealldata	= flags& CLK_FLAG4;   	bug->values[0] = (ees->lasttime) ? current_time - ees->lasttime : 0; 	bug->values[1] = (ees->clocklastgood)?current_time-ees->clocklastgood:0; 	bug->values[2] = (u_long)ees->status; 	bug->values[3] = (u_long)ees->lastevent; 	bug->values[4] = (u_long)ees->reason; 	bug->values[5] = (u_long)ees->nsamples; 	bug->values[6] = (u_long)ees->codestate; 	bug->values[7] = (u_long)ees->day; 	bug->values[8] = (u_long)ees->hour; 	bug->values[9] = (u_long)ees->minute; 	bug->values[10] = (u_long)ees->second; 	bug->values[11] = (u_long)ees->tz; 	bug->values[12] = ees->yearstart; 	bug->values[13] = (ees->leaphold> current_time) ? 				ees->leaphold - current_time : 0; 	bug->values[14] = inherent_delay[unit].l_uf; 	bug->values[15] = offset_fudge[unit].l_uf;  	bug->times[0] = ees->reftime; 	bug->times[1] = ees->arrvtime; 	bug->times[2] = ees->lastsampletime; 	bug->times[3] = ees->offset; 	bug->times[4] = ees->lowoffset; 	bug->times[5] = ees->highoffset; 	bug->times[6] = inherent_delay[unit]; 	bug->times[8] = os_delay[unit]; 	bug->times[7] = fudgefactor[unit]; 	bug->times[9] = offset_fudge[unit]; 	bug->times[10]= ees->yearstart, 0; 	*/
end_comment

begin_comment
comment|/* This should support the use of an EES M201 receiver with RS232  * output (modified to transmit time once per second).  *  * For the format of the message sent by the clock, see the EESM_  * definitions below.  *  * It appears to run free for an integral number of minutes, until the error  * reaches 4mS, at which point it steps at second = 01.  * It appears that sometimes it steps 4mS (say at 7 min interval),  * then the next minute it decides that it was an error, so steps back.  * On the next minute it steps forward again :-(  * This is typically 16.5uS/S then 3975uS at the 4min re-sync,  * or 9.5uS/S then 3990.5uS at a 7min re-sync,  * at which point it may loose the "00" second time stamp.  * I assume that the most accurate time is just AFTER the re-sync.  * Hence remember the last cycle interval,  *  * Can run in any one of:  *  *	PPSCD	PPS signal sets CD which interupts, and grabs the current TOD  *	(sun)		*in the interupt code*, so as to avoid problems with  *			the STREAMS scheduling.  *  * It appears that it goes 16.5 uS slow each second, then every 4 mins it  * generates no "00" second tick, and gains 3975 uS. Ho Hum ! (93/2/7)  */
end_comment

begin_comment
comment|/* Definitions */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXUNITS
end_ifndef

begin_define
define|#
directive|define
name|MAXUNITS
value|4
end_define

begin_comment
comment|/* maximum number of EES units permitted */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EES232
end_ifndef

begin_define
define|#
directive|define
name|EES232
value|"/dev/ees%d"
end_define

begin_comment
comment|/* Device to open to read the data */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Other constant stuff */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EESPRECISION
end_ifndef

begin_define
define|#
directive|define
name|EESPRECISION
value|(-10)
end_define

begin_comment
comment|/* what the heck - 2**-10 = 1ms */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EESREFID
end_ifndef

begin_define
define|#
directive|define
name|EESREFID
value|"MSF\0"
end_define

begin_comment
comment|/* String to identify the clock */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EESHSREFID
end_ifndef

begin_define
define|#
directive|define
name|EESHSREFID
value|(0x7f7f0000 | ((REFCLK_MSF_EES)<< 8))
end_define

begin_comment
comment|/* Numeric refid */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Description of clock */
end_comment

begin_define
define|#
directive|define
name|EESDESCRIPTION
value|"EES M201 MSF Receiver"
end_define

begin_comment
comment|/* Speed we run the clock port at. If this is changed the UARTDELAY  * value should be recomputed to suit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SPEED232
end_ifndef

begin_define
define|#
directive|define
name|SPEED232
value|B9600
end_define

begin_comment
comment|/* 9600 baud */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* What is the inherent delay for this mode of working, i.e. when is the  * data time stamped.  */
end_comment

begin_define
define|#
directive|define
name|SAFETY_SHIFT
value|10
end_define

begin_comment
comment|/* Split the shift to avoid overflow */
end_comment

begin_define
define|#
directive|define
name|BITS_TO_L_FP
parameter_list|(
name|bits
parameter_list|,
name|baud
parameter_list|)
define|\
value|(((((bits)*2 +1)<< (FRACTION_PREC-SAFETY_SHIFT)) / (2*baud))<< SAFETY_SHIFT)
end_define

begin_define
define|#
directive|define
name|INH_DELAY_CBREAK
value|BITS_TO_L_FP(119, 9600)
end_define

begin_define
define|#
directive|define
name|INH_DELAY_PPS
value|BITS_TO_L_FP(  0, 9600)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|STREAM_PP1
end_ifndef

begin_define
define|#
directive|define
name|STREAM_PP1
value|"ppsclocd\0<-- patch space for module name1 -->"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STREAM_PP2
end_ifndef

begin_define
define|#
directive|define
name|STREAM_PP2
value|"ppsclock\0<-- patch space for module name2 -->"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Offsets of the bytes of the serial line code.  The clock gives  * local time with a GMT/BST indication. The EESM_ definitions  * give offsets into ees->lastcode.  */
end_comment

begin_define
define|#
directive|define
name|EESM_CSEC
value|0
end_define

begin_comment
comment|/* centiseconds - always zero in our clock  */
end_comment

begin_define
define|#
directive|define
name|EESM_SEC
value|1
end_define

begin_comment
comment|/* seconds in BCD			    */
end_comment

begin_define
define|#
directive|define
name|EESM_MIN
value|2
end_define

begin_comment
comment|/* minutes in BCD			    */
end_comment

begin_define
define|#
directive|define
name|EESM_HOUR
value|3
end_define

begin_comment
comment|/* hours in BCD				    */
end_comment

begin_define
define|#
directive|define
name|EESM_DAYWK
value|4
end_define

begin_comment
comment|/* day of week (Sun = 0 etc)		    */
end_comment

begin_define
define|#
directive|define
name|EESM_DAY
value|5
end_define

begin_comment
comment|/* day of month in BCD			    */
end_comment

begin_define
define|#
directive|define
name|EESM_MON
value|6
end_define

begin_comment
comment|/* month in BCD				    */
end_comment

begin_define
define|#
directive|define
name|EESM_YEAR
value|7
end_define

begin_comment
comment|/* year MOD 100 in BCD			    */
end_comment

begin_define
define|#
directive|define
name|EESM_LEAP
value|8
end_define

begin_comment
comment|/* 0x0f if leap year, otherwise zero        */
end_comment

begin_define
define|#
directive|define
name|EESM_BST
value|9
end_define

begin_comment
comment|/* 0x03 if BST, 0x00 if GMT		    */
end_comment

begin_define
define|#
directive|define
name|EESM_MSFOK
value|10
end_define

begin_comment
comment|/* 0x3f if radio good, otherwise zero	    */
end_comment

begin_comment
comment|/* followed by a frame alignment byte (0xff) / 				/  which is not put into the lastcode buffer*/
end_comment

begin_comment
comment|/* Length of the serial time code, in characters.  The first length  * is less the frame alignment byte.  */
end_comment

begin_define
define|#
directive|define
name|LENEESPRT
value|(EESM_MSFOK+1)
end_define

begin_define
define|#
directive|define
name|LENEESCODE
value|(LENEESPRT+1)
end_define

begin_comment
comment|/* Code state. */
end_comment

begin_define
define|#
directive|define
name|EESCS_WAIT
value|0
end_define

begin_comment
comment|/* waiting for start of timecode */
end_comment

begin_define
define|#
directive|define
name|EESCS_GOTSOME
value|1
end_define

begin_comment
comment|/* have an incomplete time code buffered */
end_comment

begin_comment
comment|/* Default fudge factor and character to receive */
end_comment

begin_define
define|#
directive|define
name|DEFFUDGETIME
value|0
end_define

begin_comment
comment|/* Default user supplied fudge factor */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFOSTIME
end_ifndef

begin_define
define|#
directive|define
name|DEFOSTIME
value|0
end_define

begin_comment
comment|/* Default OS delay -- passed by Make ? */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEFINHTIME
value|INH_DELAY_PPS
end_define

begin_comment
comment|/* inherent delay due to sample point*/
end_comment

begin_comment
comment|/* Limits on things.  Reduce the number of samples to SAMPLEREDUCE by median  * elimination.  If we're running with an accurate clock, chose the BESTSAMPLE  * as the estimated offset, otherwise average the remainder.  */
end_comment

begin_define
define|#
directive|define
name|FULLSHIFT
value|6
end_define

begin_comment
comment|/* NCODES root 2 */
end_comment

begin_define
define|#
directive|define
name|NCODES
value|(1<< FULLSHIFT)
end_define

begin_comment
comment|/* 64 */
end_comment

begin_define
define|#
directive|define
name|REDUCESHIFT
value|(FULLSHIFT -1)
end_define

begin_comment
comment|/* SAMPLEREDUCE root 2 */
end_comment

begin_comment
comment|/* Towards the high ( Why ?) end of half */
end_comment

begin_define
define|#
directive|define
name|BESTSAMPLE
value|((samplereduce * 3) /4)
end_define

begin_comment
comment|/* 24 */
end_comment

begin_comment
comment|/* Leap hold time.  After a leap second the clock will no longer be  * reliable until it resynchronizes.  Hope 40 minutes is enough. */
end_comment

begin_define
define|#
directive|define
name|EESLEAPHOLD
value|(40 * 60)
end_define

begin_define
define|#
directive|define
name|EES_STEP_F
value|(1<< 24)
end_define

begin_comment
comment|/* the receiver steps in units of about 4ms */
end_comment

begin_define
define|#
directive|define
name|EES_STEP_F_GRACE
value|(EES_STEP_F/8)
end_define

begin_comment
comment|/*Allow for slop of 1/8 which is .5ms*/
end_comment

begin_define
define|#
directive|define
name|EES_STEP_NOTE
value|(1<< 21)
end_define

begin_comment
comment|/* Log any unexpected jumps, say .5 ms .... */
end_comment

begin_define
define|#
directive|define
name|EES_STEP_NOTES
value|50
end_define

begin_comment
comment|/* Only do a limited number */
end_comment

begin_define
define|#
directive|define
name|MAX_STEP
value|16
end_define

begin_comment
comment|/* Max number of steps to remember */
end_comment

begin_comment
comment|/* debug is a bit mask of debugging that is wanted */
end_comment

begin_define
define|#
directive|define
name|DB_SYSLOG_SMPLI
value|0x0001
end_define

begin_define
define|#
directive|define
name|DB_SYSLOG_SMPLE
value|0x0002
end_define

begin_define
define|#
directive|define
name|DB_SYSLOG_SMTHI
value|0x0004
end_define

begin_define
define|#
directive|define
name|DB_SYSLOG_NSMTHE
value|0x0008
end_define

begin_define
define|#
directive|define
name|DB_SYSLOG_NSMTHI
value|0x0010
end_define

begin_define
define|#
directive|define
name|DB_SYSLOG_SMTHE
value|0x0020
end_define

begin_define
define|#
directive|define
name|DB_PRINT_EV
value|0x0040
end_define

begin_define
define|#
directive|define
name|DB_PRINT_CDT
value|0x0080
end_define

begin_define
define|#
directive|define
name|DB_PRINT_CDTC
value|0x0100
end_define

begin_define
define|#
directive|define
name|DB_SYSLOG_KEEPD
value|0x0800
end_define

begin_define
define|#
directive|define
name|DB_SYSLOG_KEEPE
value|0x1000
end_define

begin_define
define|#
directive|define
name|DB_LOG_DELTAS
value|0x2000
end_define

begin_define
define|#
directive|define
name|DB_PRINT_DELTAS
value|0x4000
end_define

begin_define
define|#
directive|define
name|DB_LOG_AWAITMORE
value|0x8000
end_define

begin_define
define|#
directive|define
name|DB_LOG_SAMPLES
value|0x10000
end_define

begin_define
define|#
directive|define
name|DB_NO_PPS
value|0x20000
end_define

begin_define
define|#
directive|define
name|DB_INC_PPS
value|0x40000
end_define

begin_define
define|#
directive|define
name|DB_DUMP_DELTAS
value|0x80000
end_define

begin_struct
struct|struct
name|eesunit
block|{
comment|/* EES unit control structure. */
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* associated peer structure */
name|struct
name|refclockio
name|io
decl_stmt|;
comment|/* given to the I/O handler */
name|l_fp
name|reftime
decl_stmt|;
comment|/* reference time */
name|l_fp
name|lastsampletime
decl_stmt|;
comment|/* time as in txt from last EES msg */
name|l_fp
name|arrvtime
decl_stmt|;
comment|/* Time at which pkt arrived */
name|l_fp
name|codeoffsets
index|[
name|NCODES
index|]
decl_stmt|;
comment|/* the time of arrival of 232 codes */
name|l_fp
name|offset
decl_stmt|;
comment|/* chosen offset        (for clkbug) */
name|l_fp
name|lowoffset
decl_stmt|;
comment|/* lowest sample offset (for clkbug) */
name|l_fp
name|highoffset
decl_stmt|;
comment|/* highest   "     "    (for clkbug) */
name|char
name|lastcode
index|[
name|LENEESCODE
operator|+
literal|6
index|]
decl_stmt|;
comment|/* last time code we received */
name|u_long
name|lasttime
decl_stmt|;
comment|/* last time clock heard from */
name|u_long
name|clocklastgood
decl_stmt|;
comment|/* last time good radio seen */
name|u_char
name|lencode
decl_stmt|;
comment|/* length of code in buffer */
name|u_char
name|nsamples
decl_stmt|;
comment|/* number of samples we've collected */
name|u_char
name|codestate
decl_stmt|;
comment|/* state of 232 code reception */
name|u_char
name|unit
decl_stmt|;
comment|/* unit number for this guy */
name|u_char
name|status
decl_stmt|;
comment|/* clock status */
name|u_char
name|lastevent
decl_stmt|;
comment|/* last clock event */
name|u_char
name|reason
decl_stmt|;
comment|/* reason for last abort */
name|u_char
name|hour
decl_stmt|;
comment|/* hour of day */
name|u_char
name|minute
decl_stmt|;
comment|/* minute of hour */
name|u_char
name|second
decl_stmt|;
comment|/* seconds of minute */
name|char
name|tz
decl_stmt|;
comment|/* timezone from clock */
name|u_char
name|ttytype
decl_stmt|;
comment|/* method used */
name|u_char
name|dump_vals
decl_stmt|;
comment|/* Should clock values be dumped */
name|u_char
name|usealldata
decl_stmt|;
comment|/* Use ALL samples */
name|u_short
name|day
decl_stmt|;
comment|/* day of year from last code */
name|u_long
name|yearstart
decl_stmt|;
comment|/* start of current year */
name|u_long
name|leaphold
decl_stmt|;
comment|/* time of leap hold expiry */
name|u_long
name|badformat
decl_stmt|;
comment|/* number of bad format codes */
name|u_long
name|baddata
decl_stmt|;
comment|/* number of invalid time codes */
name|u_long
name|timestarted
decl_stmt|;
comment|/* time we started this */
name|long
name|last_pps_no
decl_stmt|;
comment|/* The serial # of the last PPS */
name|char
name|fix_pending
decl_stmt|;
comment|/* Is a "sync to time" pending ? */
comment|/* Fine tuning - compensate for 4 mS ramping .... */
name|l_fp
name|last_l
decl_stmt|;
comment|/* last time stamp */
name|u_char
name|last_steps
index|[
name|MAX_STEP
index|]
decl_stmt|;
comment|/* Most recent n steps */
name|int
name|best_av_step
decl_stmt|;
comment|/* Best guess at average step */
name|char
name|best_av_step_count
decl_stmt|;
comment|/* # of steps over used above */
name|char
name|this_step
decl_stmt|;
comment|/* Current pos in buffer */
name|int
name|last_step_late
decl_stmt|;
comment|/* How late the last step was (0-59) */
name|long
name|jump_fsecs
decl_stmt|;
comment|/* # of fractions of a sec last jump */
name|u_long
name|last_step
decl_stmt|;
comment|/* time of last step */
name|int
name|last_step_secs
decl_stmt|;
comment|/* Number of seconds in last step */
name|int
name|using_ramp
decl_stmt|;
comment|/* 1 -> noemal, -1 -> over stepped */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|last_sec
value|last_l.l_ui
end_define

begin_define
define|#
directive|define
name|last_sfsec
value|last_l.l_f
end_define

begin_define
define|#
directive|define
name|this_uisec
value|((ees->arrvtime).l_ui)
end_define

begin_define
define|#
directive|define
name|this_sfsec
value|((ees->arrvtime).l_f)
end_define

begin_define
define|#
directive|define
name|msec
parameter_list|(
name|x
parameter_list|)
value|((x) / (1<<22))
end_define

begin_define
define|#
directive|define
name|LAST_STEPS
value|(sizeof ees->last_steps / sizeof ees->last_steps[0])
end_define

begin_define
define|#
directive|define
name|subms
parameter_list|(
name|x
parameter_list|)
value|((((((x< 0) ? (-(x)) : (x)) % (1<<22))/2) * 625) / (1<<(22 -5)))
end_define

begin_comment
comment|/* Bitmask for what methods to try to use -- currently only PPS enabled */
end_comment

begin_define
define|#
directive|define
name|T_CBREAK
value|1
end_define

begin_define
define|#
directive|define
name|T_PPS
value|8
end_define

begin_comment
comment|/* macros to test above */
end_comment

begin_define
define|#
directive|define
name|is_cbreak
parameter_list|(
name|x
parameter_list|)
value|((x)->ttytype& T_CBREAK)
end_define

begin_define
define|#
directive|define
name|is_pps
parameter_list|(
name|x
parameter_list|)
value|((x)->ttytype& T_PPS)
end_define

begin_define
define|#
directive|define
name|is_any
parameter_list|(
name|x
parameter_list|)
value|((x)->ttytype)
end_define

begin_define
define|#
directive|define
name|CODEREASON
value|20
end_define

begin_comment
comment|/* reason codes */
end_comment

begin_comment
comment|/* Data space for the unit structures.  Note that we allocate these on  * the fly, but never give them back. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|eesunit
modifier|*
name|eesunits
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|unitinuse
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep the fudge factors separately so they can be set even  * when no clock is configured. */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|inherent_delay
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* when time stamp is taken */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|fudgefactor
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fudgetime1 */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|os_delay
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fudgetime2 */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|offset_fudge
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sum of above */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|stratumtouse
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|sloppyclockflag
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|deltas
index|[
literal|60
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_fp
name|acceptable_slop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* = { 0, 1<< (FRACTION_PREC -2) }; */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|onesec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* = { 1, 0 }; */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DUMP_BUF_SIZE
end_ifndef

begin_comment
comment|/* Size of buffer to be used by dump_buf */
end_comment

begin_define
define|#
directive|define
name|DUMP_BUF_SIZE
value|10112
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ees_reset - reset the count back to zero */
end_comment

begin_define
define|#
directive|define
name|ees_reset
parameter_list|(
name|ees
parameter_list|)
value|(ees)->nsamples = 0; \ (ees)->codestate = EESCS_WAIT
end_define

begin_comment
comment|/* ees_event - record and report an event */
end_comment

begin_define
define|#
directive|define
name|ees_event
parameter_list|(
name|ees
parameter_list|,
name|evcode
parameter_list|)
value|if ((ees)->status != (u_char)(evcode)) \ ees_report_event((ees), (evcode))
end_define

begin_comment
comment|/* Find the precision of the system clock by reading it */
end_comment

begin_define
define|#
directive|define
name|USECS
value|1000000
end_define

begin_define
define|#
directive|define
name|MINSTEP
value|5
end_define

begin_comment
comment|/* some systems increment uS on each call */
end_comment

begin_define
define|#
directive|define
name|MAXLOOPS
value|(USECS/9)
end_define

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msfees_start
name|P
argument_list|(
operator|(
name|int
name|unit
operator|,
expr|struct
name|peer
operator|*
name|peer
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|msfees_shutdown
name|P
argument_list|(
operator|(
name|int
name|unit
operator|,
expr|struct
name|peer
operator|*
name|peer
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|msfees_poll
name|P
argument_list|(
operator|(
name|int
name|unit
operator|,
expr|struct
name|peer
operator|*
name|peer
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|msfees_init
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_buf
name|P
argument_list|(
operator|(
name|l_fp
operator|*
name|coffs
operator|,
name|int
name|from
operator|,
name|int
name|to
operator|,
name|char
operator|*
name|text
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ees_report_event
name|P
argument_list|(
operator|(
expr|struct
name|eesunit
operator|*
name|ees
operator|,
name|int
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ees_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
name|rbufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ees_process
name|P
argument_list|(
operator|(
expr|struct
name|eesunit
operator|*
name|ees
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|QSORT_USES_VOID_P
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|offcompare
name|P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|va
operator|,
specifier|const
name|void
operator|*
name|vb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|offcompare
name|P
argument_list|(
operator|(
specifier|const
name|l_fp
operator|*
name|a
operator|,
specifier|const
name|l_fp
operator|*
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QSORT_USES_VOID_P */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_msfees
init|=
block|{
name|msfees_start
block|,
comment|/* start up driver */
name|msfees_shutdown
block|,
comment|/* shut down driver */
name|msfees_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used */
name|msfees_init
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* not used */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dump_buf
parameter_list|(
name|l_fp
modifier|*
name|coffs
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|char
modifier|*
name|text
parameter_list|)
block|{
name|char
name|buff
index|[
name|DUMP_BUF_SIZE
operator|+
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
init|=
name|buff
decl_stmt|;
name|sprintf
argument_list|(
name|ptr
argument_list|,
name|text
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<
name|to
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|ptr
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|-
name|buff
operator|)
operator|>
name|DUMP_BUF_SIZE
condition|)
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"D: %s"
argument_list|,
name|ptr
operator|=
name|buff
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|" %06d"
argument_list|,
operator|(
operator|(
name|int
operator|)
name|coffs
index|[
name|i
index|]
operator|.
name|l_f
operator|)
operator|/
literal|4295
argument_list|)
expr_stmt|;
block|}
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"D: %s"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* msfees_init - initialize internal ees driver data */
end_comment

begin_function
specifier|static
name|void
name|msfees_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Just zero the data arrays */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|eesunits
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|eesunits
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unitinuse
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|unitinuse
argument_list|)
expr_stmt|;
name|acceptable_slop
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|acceptable_slop
operator|.
name|l_uf
operator|=
literal|1
operator|<<
operator|(
name|FRACTION_PREC
operator|-
literal|2
operator|)
expr_stmt|;
name|onesec
operator|.
name|l_ui
operator|=
literal|1
expr_stmt|;
name|onesec
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
comment|/* Initialize fudge factors to default. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNITS
condition|;
name|i
operator|++
control|)
block|{
name|fudgefactor
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|fudgefactor
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|DEFFUDGETIME
expr_stmt|;
name|os_delay
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|os_delay
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|DEFOSTIME
expr_stmt|;
name|inherent_delay
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|inherent_delay
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|DEFINHTIME
expr_stmt|;
name|offset_fudge
index|[
name|i
index|]
operator|=
name|os_delay
index|[
name|i
index|]
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset_fudge
index|[
name|i
index|]
argument_list|,
operator|&
name|fudgefactor
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset_fudge
index|[
name|i
index|]
argument_list|,
operator|&
name|inherent_delay
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|stratumtouse
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sloppyclockflag
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* msfees_start - open the EES devices and initialize data for processing */
end_comment

begin_function
specifier|static
name|int
name|msfees_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|eesunit
modifier|*
name|ees
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|fd232
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|eesdev
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock: unit number %d invalid (max %d)"
argument_list|,
name|unit
argument_list|,
name|MAXUNITS
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock: unit number %d in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Unit okay, attempt to open the devices.  We do them both at 	 * once to make sure we can */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|eesdev
argument_list|,
name|EES232
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fd232
operator|=
name|open
argument_list|(
name|eesdev
argument_list|,
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd232
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock: open of %s failed: %m"
argument_list|,
name|eesdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|TIOCEXCL
comment|/* Set for exclusive use */
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCEXCL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock: ioctl(%s, TIOCEXCL): %m"
argument_list|,
name|eesdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
endif|#
directive|endif
comment|/* STRIPPED DOWN VERSION: Only PPS CD is supported at the moment */
comment|/* Set port characteristics.  If we don't have a STREAMS module or 	 * a clock line discipline, cooked mode is just usable, even though it 	 * strips the top bit.  The only EES byte which uses the top 	 * bit is the year, and we don't use that anyway. If we do 	 * have the line discipline, we choose raw mode, and the 	 * line discipline code will block up the messages. 	 */
comment|/* STIPPED DOWN VERSION: Only PPS CD is supported at the moment */
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd232
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"msfees_start: tcgetattr(%s): %m"
argument_list|,
name|eesdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|SPEED232
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd232
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"msfees_start: tcsetattr(%s): %m"
argument_list|,
name|eesdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|if
condition|(
name|tcflush
argument_list|(
name|fd232
argument_list|,
name|TCIOFLUSH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"msfees_start: tcflush(%s): %m"
argument_list|,
name|eesdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|inherent_delay
index|[
name|unit
index|]
operator|.
name|l_uf
operator|=
name|INH_DELAY_PPS
expr_stmt|;
comment|/* offset fudge (how *late* the timestamp is) = fudge + os delays */
name|offset_fudge
index|[
name|unit
index|]
operator|=
name|os_delay
index|[
name|unit
index|]
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset_fudge
index|[
name|unit
index|]
argument_list|,
operator|&
name|fudgefactor
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset_fudge
index|[
name|unit
index|]
argument_list|,
operator|&
name|inherent_delay
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
comment|/* Looks like this might succeed.  Find memory for the structure. 	 * Look to see if there are any unused ones, if not we malloc() one. 	 */
if|if
condition|(
name|eesunits
index|[
name|unit
index|]
operator|!=
literal|0
condition|)
comment|/* The one we want is okay */
name|ees
operator|=
name|eesunits
index|[
name|unit
index|]
expr_stmt|;
else|else
block|{
comment|/* Look for an unused, but allocated struct */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|unitinuse
index|[
name|i
index|]
operator|&&
name|eesunits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|MAXUNITS
condition|)
block|{
comment|/* Reclaim this one */
name|ees
operator|=
name|eesunits
index|[
name|i
index|]
expr_stmt|;
name|eesunits
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* no spare -- make a new one */
else|else
name|ees
operator|=
operator|(
expr|struct
name|eesunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eesunit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ees
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eesunit
argument_list|)
argument_list|)
expr_stmt|;
name|eesunits
index|[
name|unit
index|]
operator|=
name|ees
expr_stmt|;
comment|/* Set up the structures */
name|ees
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|ees
operator|->
name|unit
operator|=
operator|(
name|u_char
operator|)
name|unit
expr_stmt|;
name|ees
operator|->
name|timestarted
operator|=
name|current_time
expr_stmt|;
name|ees
operator|->
name|ttytype
operator|=
literal|0
expr_stmt|;
name|ees
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|ees_receive
expr_stmt|;
name|ees
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|ees
expr_stmt|;
name|ees
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|ees
operator|->
name|io
operator|.
name|fd
operator|=
name|fd232
expr_stmt|;
comment|/* Okay.  Push one of the two (linked into the kernel, or dynamically 	 * loaded) STREAMS module, and give it to the I/O code to start 	 * receiving stuff. 	 */
ifdef|#
directive|ifdef
name|STREAM
block|{
name|int
name|rc1
decl_stmt|;
comment|/* Pop any existing onews first ... */
while|while
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_POP
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
empty_stmt|;
comment|/* Now try pushing either of the possible modules */
if|if
condition|(
operator|(
name|rc1
operator|=
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_PUSH
argument_list|,
name|STREAM_PP1
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_PUSH
argument_list|,
name|STREAM_PP2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock: Push of `%s' and `%s' to %s failed %m"
argument_list|,
name|STREAM_PP1
argument_list|,
name|STREAM_PP2
argument_list|,
name|eesdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
else|else
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"I: ees clock: PUSHed %s on %s"
argument_list|,
operator|(
name|rc1
operator|>=
literal|0
operator|)
condition|?
name|STREAM_PP1
else|:
name|STREAM_PP2
argument_list|,
name|eesdev
argument_list|)
expr_stmt|;
name|ees
operator|->
name|ttytype
operator||=
name|T_PPS
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* STREAM */
comment|/* Add the clock */
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|ees
operator|->
name|io
argument_list|)
condition|)
block|{
comment|/* Oh shit.  Just close and return. */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock: io_addclock(%s): %m"
argument_list|,
name|eesdev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
comment|/* All done.  Initialize a few random peer variables, then 	 * return success. */
name|peer
operator|->
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|stratumtouse
index|[
name|unit
index|]
operator|<=
literal|1
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|EESREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>
literal|0
operator|&&
name|unit
operator|<
literal|10
condition|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
operator|)
index|[
literal|3
index|]
operator|=
literal|'0'
operator|+
name|unit
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|refid
operator|=
name|htonl
argument_list|(
name|EESHSREFID
argument_list|)
expr_stmt|;
block|}
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|eesunits
index|[
name|unit
index|]
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|EESDESCRIPTION
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock: %s OK on %d"
argument_list|,
name|eesdev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|screwed
label|:
if|if
condition|(
name|fd232
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd232
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* msfees_shutdown - shut down a EES clock */
end_comment

begin_function
specifier|static
name|void
name|msfees_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|eesunit
modifier|*
name|ees
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock: INTERNAL ERROR, unit number %d invalid (max %d)"
argument_list|,
name|unit
argument_list|,
name|MAXUNITS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock: INTERNAL ERROR, unit number %d not in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Tell the I/O module to turn us off.  We're history. */
name|ees
operator|=
name|eesunits
index|[
name|unit
index|]
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|ees
operator|->
name|io
argument_list|)
expr_stmt|;
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ees_report_event - note the occurance of an event */
end_comment

begin_function
specifier|static
name|void
name|ees_report_event
parameter_list|(
name|struct
name|eesunit
modifier|*
name|ees
parameter_list|,
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|ees
operator|->
name|status
operator|!=
operator|(
name|u_char
operator|)
name|code
condition|)
block|{
name|ees
operator|->
name|status
operator|=
operator|(
name|u_char
operator|)
name|code
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|CEVNT_NOMINAL
condition|)
name|ees
operator|->
name|lastevent
operator|=
operator|(
name|u_char
operator|)
name|code
expr_stmt|;
comment|/* Should report event to trap handler in here. 		 * Soon... 		 */
block|}
block|}
end_function

begin_comment
comment|/* ees_receive - receive data from the serial interface on an EES clock */
end_comment

begin_function
specifier|static
name|void
name|ees_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|int
name|n_sample
decl_stmt|;
specifier|register
name|int
name|day
decl_stmt|;
specifier|register
name|struct
name|eesunit
modifier|*
name|ees
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* Data PoinTeR: move along ... */
specifier|register
name|u_char
modifier|*
name|dpend
decl_stmt|;
comment|/* Points just *after* last data char */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|l_fp
name|tmp
decl_stmt|;
name|int
name|call_pps_sample
init|=
literal|0
decl_stmt|;
name|l_fp
name|pps_arrvstamp
decl_stmt|;
name|int
name|sincelast
decl_stmt|;
name|int
name|pps_step
init|=
literal|0
decl_stmt|;
name|int
name|suspect_4ms_step
init|=
literal|0
decl_stmt|;
name|struct
name|ppsclockev
name|ppsclockev
decl_stmt|;
name|long
modifier|*
name|ptr
init|=
operator|(
name|long
operator|*
operator|)
operator|&
name|ppsclockev
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|request
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_CIOGETEV
name|request
operator|=
name|CIOGETEV
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIOCGPPSEV
name|request
operator|=
name|TIOCGPPSEV
expr_stmt|;
endif|#
directive|endif
comment|/* Get the clock this applies to and a pointer to the data */
name|ees
operator|=
operator|(
expr|struct
name|eesunit
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|dpt
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
name|dpend
operator|=
name|dpt
operator|+
name|rbufp
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
operator|(
name|debug
operator|&
name|DB_LOG_AWAITMORE
operator|)
operator|&&
operator|(
name|rbufp
operator|->
name|recv_length
operator|!=
name|LENEESCODE
operator|)
condition|)
name|printf
argument_list|(
literal|"[%d] "
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|)
expr_stmt|;
comment|/* Check out our state and process appropriately */
switch|switch
condition|(
name|ees
operator|->
name|codestate
condition|)
block|{
case|case
name|EESCS_WAIT
case|:
comment|/* Set an initial guess at the timestamp as the recv time. 		 * If just running in CBREAK mode, we can't improve this. 		 * If we have the CLOCK Line Discipline, PPSCD, or sime such, 		 * then we will do better later .... 		 */
name|ees
operator|->
name|arrvtime
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|ees
operator|->
name|codestate
operator|=
name|EESCS_GOTSOME
expr_stmt|;
name|ees
operator|->
name|lencode
operator|=
literal|0
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
name|EESCS_GOTSOME
case|:
name|cp
operator|=
operator|&
operator|(
name|ees
operator|->
name|lastcode
index|[
name|ees
operator|->
name|lencode
index|]
operator|)
expr_stmt|;
comment|/* Gobble the bytes until the final (possibly stripped) 0xff */
while|while
condition|(
name|dpt
operator|<
name|dpend
operator|&&
operator|(
operator|*
name|dpt
operator|&
literal|0x7f
operator|)
operator|!=
literal|0x7f
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
operator|*
name|dpt
operator|++
expr_stmt|;
name|ees
operator|->
name|lencode
operator|++
expr_stmt|;
comment|/* Oh dear -- too many bytes .. */
if|if
condition|(
name|ees
operator|->
name|lencode
operator|>
name|LENEESPRT
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"I: ees clock: %d + %d> %d [%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]"
argument_list|,
name|ees
operator|->
name|lencode
argument_list|,
name|dpend
operator|-
name|dpt
argument_list|,
name|LENEESPRT
argument_list|,
define|#
directive|define
name|D
parameter_list|(
name|x
parameter_list|)
value|(ees->lastcode[x])
name|D
argument_list|(
literal|0
argument_list|)
argument_list|,
name|D
argument_list|(
literal|1
argument_list|)
argument_list|,
name|D
argument_list|(
literal|2
argument_list|)
argument_list|,
name|D
argument_list|(
literal|3
argument_list|)
argument_list|,
name|D
argument_list|(
literal|4
argument_list|)
argument_list|,
name|D
argument_list|(
literal|5
argument_list|)
argument_list|,
name|D
argument_list|(
literal|6
argument_list|)
argument_list|,
name|D
argument_list|(
literal|7
argument_list|)
argument_list|,
name|D
argument_list|(
literal|8
argument_list|)
argument_list|,
name|D
argument_list|(
literal|9
argument_list|)
argument_list|,
name|D
argument_list|(
literal|10
argument_list|)
argument_list|,
name|D
argument_list|(
literal|11
argument_list|)
argument_list|,
name|D
argument_list|(
literal|12
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|D
name|ees
operator|->
name|badformat
operator|++
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|1
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Gave up because it was end of the buffer, rather than ff */
if|if
condition|(
name|dpt
operator|==
name|dpend
condition|)
block|{
comment|/* Incomplete.  Wait for more. */
if|if
condition|(
name|debug
operator|&
name|DB_LOG_AWAITMORE
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"I: ees clock %d: %x == %x: await more"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|dpt
argument_list|,
name|dpend
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This shouldn't happen ... ! */
if|if
condition|(
operator|(
operator|*
name|dpt
operator|&
literal|0x7f
operator|)
operator|!=
literal|0x7f
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"I: ees clock: %0x& 0x7f != 0x7f"
argument_list|,
operator|*
name|dpt
argument_list|)
expr_stmt|;
name|ees
operator|->
name|badformat
operator|++
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|2
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Skip the 0xff */
name|dpt
operator|++
expr_stmt|;
comment|/* Finally, got a complete buffer.  Mainline code will 		 * continue on. */
name|cp
operator|=
name|ees
operator|->
name|lastcode
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock: INTERNAL ERROR: %d state %d"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|ees
operator|->
name|codestate
argument_list|)
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|5
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Boy!  After all that crap, the lastcode buffer now contains 	 * something we hope will be a valid time code.  Do length 	 * checks and sanity checks on constant data. 	 */
name|ees
operator|->
name|codestate
operator|=
name|EESCS_WAIT
expr_stmt|;
name|ees
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
name|ees
operator|->
name|lencode
operator|!=
name|LENEESPRT
condition|)
block|{
name|ees
operator|->
name|badformat
operator|++
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|6
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|ees
operator|->
name|lastcode
expr_stmt|;
comment|/* Check that centisecond is zero */
if|if
condition|(
name|cp
index|[
name|EESM_CSEC
index|]
operator|!=
literal|0
condition|)
block|{
name|ees
operator|->
name|baddata
operator|++
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|7
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check flag formats */
if|if
condition|(
name|cp
index|[
name|EESM_LEAP
index|]
operator|!=
literal|0
operator|&&
name|cp
index|[
name|EESM_LEAP
index|]
operator|!=
literal|0x0f
condition|)
block|{
name|ees
operator|->
name|badformat
operator|++
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|8
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cp
index|[
name|EESM_BST
index|]
operator|!=
literal|0
operator|&&
name|cp
index|[
name|EESM_BST
index|]
operator|!=
literal|0x03
condition|)
block|{
name|ees
operator|->
name|badformat
operator|++
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|9
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cp
index|[
name|EESM_MSFOK
index|]
operator|!=
literal|0
operator|&&
name|cp
index|[
name|EESM_MSFOK
index|]
operator|!=
literal|0x3f
condition|)
block|{
name|ees
operator|->
name|badformat
operator|++
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|10
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* So far, so good.  Compute day, hours, minutes, seconds, 	 * time zone.  Do range checks on these. 	 */
define|#
directive|define
name|bcdunpack
parameter_list|(
name|val
parameter_list|)
value|( (((val)>>4)& 0x0f) * 10 + ((val)& 0x0f) )
define|#
directive|define
name|istrue
parameter_list|(
name|x
parameter_list|)
value|((x)?1:0)
name|ees
operator|->
name|second
operator|=
name|bcdunpack
argument_list|(
name|cp
index|[
name|EESM_SEC
index|]
argument_list|)
expr_stmt|;
comment|/* second       */
name|ees
operator|->
name|minute
operator|=
name|bcdunpack
argument_list|(
name|cp
index|[
name|EESM_MIN
index|]
argument_list|)
expr_stmt|;
comment|/* minute       */
name|ees
operator|->
name|hour
operator|=
name|bcdunpack
argument_list|(
name|cp
index|[
name|EESM_HOUR
index|]
argument_list|)
expr_stmt|;
comment|/* hour         */
name|day
operator|=
name|bcdunpack
argument_list|(
name|cp
index|[
name|EESM_DAY
index|]
argument_list|)
expr_stmt|;
comment|/* day of month */
switch|switch
condition|(
name|bcdunpack
argument_list|(
name|cp
index|[
name|EESM_MON
index|]
argument_list|)
condition|)
block|{
comment|/* month        */
comment|/*  Add in lengths of all previous months.  Add one more 		    if it is a leap year and after February. 		*/
case|case
literal|12
case|:
name|day
operator|+=
name|NOV
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|11
case|:
name|day
operator|+=
name|OCT
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|10
case|:
name|day
operator|+=
name|SEP
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|9
case|:
name|day
operator|+=
name|AUG
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|8
case|:
name|day
operator|+=
name|JUL
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|7
case|:
name|day
operator|+=
name|JUN
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|6
case|:
name|day
operator|+=
name|MAY
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|5
case|:
name|day
operator|+=
name|APR
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|4
case|:
name|day
operator|+=
name|MAR
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|3
case|:
name|day
operator|+=
name|FEB
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|cp
index|[
name|EESM_LEAP
index|]
argument_list|)
condition|)
name|day
operator|++
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|2
case|:
name|day
operator|+=
name|JAN
expr_stmt|;
comment|/*FALLSTHROUGH*/
case|case
literal|1
case|:
break|break;
default|default:
name|ees
operator|->
name|baddata
operator|++
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|11
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
name|ees
operator|->
name|day
operator|=
name|day
expr_stmt|;
comment|/* Get timezone. The clocktime routine wants the number 	 * of hours to add to the delivered time to get UT. 	 * Currently -1 if BST flag set, 0 otherwise.  This 	 * is the place to tweak things if double summer time 	 * ever happens. 	 */
name|ees
operator|->
name|tz
operator|=
name|istrue
argument_list|(
name|cp
index|[
name|EESM_BST
index|]
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|ees
operator|->
name|day
operator|>
literal|366
operator|||
name|ees
operator|->
name|day
operator|<
literal|1
operator|||
name|ees
operator|->
name|hour
operator|>
literal|23
operator|||
name|ees
operator|->
name|minute
operator|>
literal|59
operator|||
name|ees
operator|->
name|second
operator|>
literal|59
condition|)
block|{
name|ees
operator|->
name|baddata
operator|++
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|12
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
name|n_sample
operator|=
name|ees
operator|->
name|nsamples
expr_stmt|;
comment|/* Now, compute the reference time value: text -> tmp.l_ui */
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|ees
operator|->
name|day
argument_list|,
name|ees
operator|->
name|hour
argument_list|,
name|ees
operator|->
name|minute
argument_list|,
name|ees
operator|->
name|second
argument_list|,
name|ees
operator|->
name|tz
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_ui
argument_list|,
operator|&
name|ees
operator|->
name|yearstart
argument_list|,
operator|&
name|tmp
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|ees
operator|->
name|baddata
operator|++
expr_stmt|;
name|ees
operator|->
name|reason
operator|=
name|CODEREASON
operator|+
literal|13
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
comment|/*  DON'T use ees->arrvtime -- it may be< reftime */
name|ees
operator|->
name|lastsampletime
operator|=
name|tmp
expr_stmt|;
comment|/* If we are synchronised to the radio, update the reference time. 	 * Also keep a note of when clock was last good. 	 */
if|if
condition|(
name|istrue
argument_list|(
name|cp
index|[
name|EESM_MSFOK
index|]
argument_list|)
condition|)
block|{
name|ees
operator|->
name|reftime
operator|=
name|tmp
expr_stmt|;
name|ees
operator|->
name|clocklastgood
operator|=
name|current_time
expr_stmt|;
block|}
comment|/* Compute the offset.  For the fractional part of the 	 * offset we use the expected delay for the message. 	 */
name|ees
operator|->
name|codeoffsets
index|[
name|n_sample
index|]
operator|.
name|l_ui
operator|=
name|tmp
operator|.
name|l_ui
expr_stmt|;
name|ees
operator|->
name|codeoffsets
index|[
name|n_sample
index|]
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
comment|/* Number of seconds since the last step */
name|sincelast
operator|=
name|this_uisec
operator|-
name|ees
operator|->
name|last_step
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ppsclockev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ppsclockev
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ioctl
argument_list|(
name|ees
operator|->
name|io
operator|.
name|fd
argument_list|,
name|request
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ppsclockev
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DB_PRINT_EV
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%x] CIOGETEV u%d %d (%x %d) gave %d (%d): %08lx %08lx %ld\n"
argument_list|,
name|DB_PRINT_EV
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|ees
operator|->
name|io
operator|.
name|fd
argument_list|,
name|request
argument_list|,
name|is_pps
argument_list|(
name|ees
argument_list|)
argument_list|,
name|rc
argument_list|,
name|errno
argument_list|,
name|ptr
index|[
literal|0
index|]
argument_list|,
name|ptr
index|[
literal|1
index|]
argument_list|,
name|ptr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* If we managed to get the time of arrival, process the info */
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
block|{
name|int
name|conv
init|=
operator|-
literal|1
decl_stmt|;
name|pps_step
operator|=
name|ppsclockev
operator|.
name|serial
operator|-
name|ees
operator|->
name|last_pps_no
expr_stmt|;
comment|/* Possible that PPS triggered, but text message didn't */
if|if
condition|(
name|pps_step
operator|==
literal|2
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pps step = 2 @ %02d"
argument_list|,
name|ees
operator|->
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|pps_step
operator|==
literal|2
operator|&&
name|ees
operator|->
name|second
operator|==
literal|1
condition|)
name|suspect_4ms_step
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|pps_step
operator|==
literal|2
operator|&&
name|ees
operator|->
name|second
operator|==
literal|2
condition|)
name|suspect_4ms_step
operator||=
literal|4
expr_stmt|;
comment|/* allow for single loss of PPS only */
if|if
condition|(
name|pps_step
operator|!=
literal|1
operator|&&
name|pps_step
operator|!=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PPS step: %d too far off %ld (%d)\n"
argument_list|,
name|ppsclockev
operator|.
name|serial
argument_list|,
name|ees
operator|->
name|last_pps_no
argument_list|,
name|pps_step
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|buftvtots
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|ppsclockev
operator|.
name|tv
operator|)
argument_list|,
operator|&
name|pps_arrvstamp
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buftvtots failed\n"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* if ((ABS(time difference) - 0.25)< 0) 			 * then believe it ... 			 */
name|l_fp
name|diff
decl_stmt|;
name|diff
operator|=
name|pps_arrvstamp
expr_stmt|;
name|conv
operator|=
literal|0
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|ees
operator|->
name|arrvtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DB_PRINT_CDT
condition|)
name|printf
argument_list|(
literal|"[%x] Have %lx.%08lx and %lx.%08lx -> %lx.%08lx @ %s"
argument_list|,
name|DB_PRINT_CDT
argument_list|,
operator|(
name|long
operator|)
name|ees
operator|->
name|arrvtime
operator|.
name|l_ui
argument_list|,
operator|(
name|long
operator|)
name|ees
operator|->
name|arrvtime
operator|.
name|l_uf
argument_list|,
operator|(
name|long
operator|)
name|pps_arrvstamp
operator|.
name|l_ui
argument_list|,
operator|(
name|long
operator|)
name|pps_arrvstamp
operator|.
name|l_uf
argument_list|,
operator|(
name|long
operator|)
name|diff
operator|.
name|l_ui
argument_list|,
operator|(
name|long
operator|)
name|diff
operator|.
name|l_uf
argument_list|,
name|ctime
argument_list|(
operator|&
operator|(
name|ppsclockev
operator|.
name|tv
operator|.
name|tv_sec
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|diff
argument_list|)
condition|)
name|M_NEG
argument_list|(
name|diff
operator|.
name|l_ui
argument_list|,
name|diff
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|acceptable_slop
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|diff
argument_list|)
condition|)
block|{
comment|/* AOK -- pps_sample */
name|ees
operator|->
name|arrvtime
operator|=
name|pps_arrvstamp
expr_stmt|;
name|conv
operator|++
expr_stmt|;
name|call_pps_sample
operator|++
expr_stmt|;
block|}
comment|/* Some loss of some signals around sec = 1 */
elseif|else
if|if
condition|(
name|ees
operator|->
name|second
operator|==
literal|1
condition|)
block|{
name|diff
operator|=
name|pps_arrvstamp
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|onesec
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|ees
operator|->
name|arrvtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|diff
argument_list|)
condition|)
name|M_NEG
argument_list|(
name|diff
operator|.
name|l_ui
argument_list|,
name|diff
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|acceptable_slop
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Have sec==1 slip %ds a=%08x-p=%08x -> %x.%08x (u=%d) %s"
argument_list|,
name|pps_arrvstamp
operator|.
name|l_ui
operator|-
name|ees
operator|->
name|arrvtime
operator|.
name|l_ui
argument_list|,
name|pps_arrvstamp
operator|.
name|l_uf
argument_list|,
name|ees
operator|->
name|arrvtime
operator|.
name|l_uf
argument_list|,
name|diff
operator|.
name|l_ui
argument_list|,
name|diff
operator|.
name|l_uf
argument_list|,
operator|(
name|int
operator|)
name|ppsclockev
operator|.
name|tv
operator|.
name|tv_usec
argument_list|,
name|ctime
argument_list|(
operator|&
operator|(
name|ppsclockev
operator|.
name|tv
operator|.
name|tv_sec
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|diff
argument_list|)
condition|)
block|{
comment|/* AOK -- pps_sample */
name|suspect_4ms_step
operator||=
literal|2
expr_stmt|;
name|ees
operator|->
name|arrvtime
operator|=
name|pps_arrvstamp
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ees
operator|->
name|arrvtime
argument_list|,
operator|&
name|onesec
argument_list|)
expr_stmt|;
name|conv
operator|++
expr_stmt|;
name|call_pps_sample
operator|++
expr_stmt|;
block|}
block|}
block|}
name|ees
operator|->
name|last_pps_no
operator|=
name|ppsclockev
operator|.
name|serial
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DB_PRINT_CDTC
condition|)
name|printf
argument_list|(
literal|"[%x] %08lx %08lx %d u%d (%d %d)\n"
argument_list|,
name|DB_PRINT_CDTC
argument_list|,
operator|(
name|long
operator|)
name|pps_arrvstamp
operator|.
name|l_ui
argument_list|,
operator|(
name|long
operator|)
name|pps_arrvstamp
operator|.
name|l_uf
argument_list|,
name|conv
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|call_pps_sample
argument_list|,
name|pps_step
argument_list|)
expr_stmt|;
block|}
comment|/* See if there has been a 4ms jump at a minute boundry */
block|{
name|l_fp
name|delta
decl_stmt|;
define|#
directive|define
name|delta_isec
value|delta.l_ui
define|#
directive|define
name|delta_ssec
value|delta.l_i
define|#
directive|define
name|delta_sfsec
value|delta.l_f
name|long
name|delta_f_abs
decl_stmt|;
name|delta
operator|.
name|l_i
operator|=
name|ees
operator|->
name|arrvtime
operator|.
name|l_i
expr_stmt|;
name|delta
operator|.
name|l_f
operator|=
name|ees
operator|->
name|arrvtime
operator|.
name|l_f
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|ees
operator|->
name|last_l
argument_list|)
expr_stmt|;
name|delta_f_abs
operator|=
name|delta_sfsec
expr_stmt|;
if|if
condition|(
name|delta_f_abs
operator|<
literal|0
condition|)
name|delta_f_abs
operator|=
operator|-
name|delta_f_abs
expr_stmt|;
comment|/* Dump the deltas each minute */
if|if
condition|(
name|debug
operator|&
name|DB_DUMP_DELTAS
condition|)
block|{
if|if
condition|(
comment|/*0<= ees->second&& */
name|ees
operator|->
name|second
operator|<
operator|(
operator|(
sizeof|sizeof
name|deltas
operator|)
operator|/
operator|(
sizeof|sizeof
name|deltas
index|[
literal|0
index|]
operator|)
operator|)
condition|)
name|deltas
index|[
name|ees
operator|->
name|second
index|]
operator|=
name|delta_sfsec
expr_stmt|;
comment|/* Dump on second 1, as second 0 sometimes missed */
if|if
condition|(
name|ees
operator|->
name|second
operator|==
literal|1
condition|)
block|{
name|char
name|text
index|[
literal|16
operator|*
operator|(
operator|(
sizeof|sizeof
name|deltas
operator|)
operator|/
operator|(
sizeof|sizeof
name|deltas
index|[
literal|0
index|]
operator|)
operator|)
index|]
decl_stmt|;
name|char
modifier|*
name|cptr
init|=
name|text
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
sizeof|sizeof
name|deltas
operator|)
operator|/
operator|(
sizeof|sizeof
name|deltas
index|[
literal|0
index|]
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|cptr
argument_list|,
literal|" %d.%04d"
argument_list|,
name|msec
argument_list|(
name|deltas
index|[
name|i
index|]
argument_list|)
argument_list|,
name|subms
argument_list|(
name|deltas
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cptr
condition|)
name|cptr
operator|++
expr_stmt|;
block|}
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Deltas: %d.%04d<->%d.%04d: %s"
argument_list|,
name|msec
argument_list|(
name|EES_STEP_F
operator|-
name|EES_STEP_F_GRACE
argument_list|)
argument_list|,
name|subms
argument_list|(
name|EES_STEP_F
operator|-
name|EES_STEP_F_GRACE
argument_list|)
argument_list|,
name|msec
argument_list|(
name|EES_STEP_F
operator|+
name|EES_STEP_F_GRACE
argument_list|)
argument_list|,
name|subms
argument_list|(
name|EES_STEP_F
operator|+
name|EES_STEP_F_GRACE
argument_list|)
argument_list|,
name|text
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
sizeof|sizeof
name|deltas
operator|)
operator|/
operator|(
sizeof|sizeof
name|deltas
index|[
literal|0
index|]
operator|)
operator|)
condition|;
name|i
operator|++
control|)
name|deltas
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Lets see if we have a 4 mS step at a minute boundaary */
if|if
condition|(
operator|(
operator|(
name|EES_STEP_F
operator|-
name|EES_STEP_F_GRACE
operator|)
operator|<
name|delta_f_abs
operator|)
operator|&&
operator|(
name|delta_f_abs
operator|<
operator|(
name|EES_STEP_F
operator|+
name|EES_STEP_F_GRACE
operator|)
operator|)
operator|&&
operator|(
name|ees
operator|->
name|second
operator|==
literal|0
operator|||
name|ees
operator|->
name|second
operator|==
literal|1
operator|||
name|ees
operator|->
name|second
operator|==
literal|2
operator|)
operator|&&
operator|(
name|sincelast
operator|<
literal|0
operator|||
name|sincelast
operator|>
literal|122
operator|)
condition|)
block|{
comment|/* 4ms jump at min boundry */
name|int
name|old_sincelast
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
comment|/* Yes -- so compute the ramp time */
if|if
condition|(
name|ees
operator|->
name|last_step
operator|==
literal|0
condition|)
name|sincelast
operator|=
literal|0
expr_stmt|;
name|old_sincelast
operator|=
name|sincelast
expr_stmt|;
comment|/* First time in, just set "ees->last_step" */
if|if
condition|(
name|ees
operator|->
name|last_step
condition|)
block|{
name|int
name|other_step
init|=
literal|0
decl_stmt|;
name|int
name|third_step
init|=
literal|0
decl_stmt|;
name|int
name|this_step
init|=
operator|(
name|sincelast
operator|+
operator|(
literal|60
operator|/
literal|2
operator|)
operator|)
operator|/
literal|60
decl_stmt|;
name|int
name|p_step
init|=
name|ees
operator|->
name|this_step
decl_stmt|;
name|int
name|p
decl_stmt|;
name|ees
operator|->
name|last_steps
index|[
name|p_step
index|]
operator|=
name|this_step
expr_stmt|;
name|p
operator|=
name|p_step
expr_stmt|;
name|p_step
operator|++
expr_stmt|;
if|if
condition|(
name|p_step
operator|>=
name|LAST_STEPS
condition|)
name|p_step
operator|=
literal|0
expr_stmt|;
name|ees
operator|->
name|this_step
operator|=
name|p_step
expr_stmt|;
comment|/* Find the "average" interval */
while|while
condition|(
name|p
operator|!=
name|p_step
condition|)
block|{
name|int
name|this
init|=
name|ees
operator|->
name|last_steps
index|[
name|p
index|]
decl_stmt|;
if|if
condition|(
name|this
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|this
operator|!=
name|this_step
condition|)
block|{
if|if
condition|(
name|other_step
operator|==
literal|0
operator|&&
operator|(
name|this
operator|==
operator|(
name|this_step
operator|+
literal|2
operator|)
operator|||
name|this
operator|==
operator|(
name|this_step
operator|-
literal|2
operator|)
operator|||
name|this
operator|==
operator|(
name|this_step
operator|+
literal|1
operator|)
operator|||
name|this
operator|==
operator|(
name|this_step
operator|-
literal|1
operator|)
operator|)
condition|)
name|other_step
operator|=
name|this
expr_stmt|;
if|if
condition|(
name|other_step
operator|!=
name|this
condition|)
block|{
name|int
name|idelta
init|=
operator|(
name|this_step
operator|-
name|other_step
operator|)
decl_stmt|;
if|if
condition|(
name|idelta
operator|<
literal|0
condition|)
name|idelta
operator|=
operator|-
name|idelta
expr_stmt|;
if|if
condition|(
name|third_step
operator|==
literal|0
operator|&&
operator|(
operator|(
name|idelta
operator|==
literal|1
operator|)
condition|?
operator|(
name|this
operator|==
operator|(
name|other_step
operator|+
literal|1
operator|)
operator|||
name|this
operator|==
operator|(
name|other_step
operator|-
literal|1
operator|)
operator|||
name|this
operator|==
operator|(
name|this_step
operator|+
literal|1
operator|)
operator|||
name|this
operator|==
operator|(
name|this_step
operator|-
literal|1
operator|)
operator|)
else|:
operator|(
name|this
operator|==
operator|(
name|this_step
operator|+
name|other_step
operator|)
operator|/
literal|2
operator|)
operator|)
condition|)
name|third_step
operator|=
name|this
expr_stmt|;
if|if
condition|(
name|third_step
operator|!=
name|this
condition|)
break|break;
block|}
block|}
name|sum
operator|+=
name|this
expr_stmt|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|<
literal|0
condition|)
name|p
operator|+=
name|LAST_STEPS
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"MSF%d: %d: This=%d (%d), other=%d/%d, sum=%d, count=%d, pps_step=%d, suspect=%x"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|p
argument_list|,
name|ees
operator|->
name|last_steps
index|[
name|p
index|]
argument_list|,
name|this_step
argument_list|,
name|other_step
argument_list|,
name|third_step
argument_list|,
name|sum
argument_list|,
name|count
argument_list|,
name|pps_step
argument_list|,
name|suspect_4ms_step
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|sum
operator|=
operator|(
operator|(
name|sum
operator|*
literal|60
operator|)
operator|+
operator|(
name|count
operator|/
literal|2
operator|)
operator|)
operator|/
name|count
expr_stmt|;
define|#
directive|define
name|SV
parameter_list|(
name|x
parameter_list|)
value|(ees->last_steps[(x + p_step) % LAST_STEPS])
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"MSF%d: %x steps %d: %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|suspect_4ms_step
argument_list|,
name|p_step
argument_list|,
name|SV
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|2
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|3
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|4
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|5
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|6
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|7
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|8
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|9
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|10
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|11
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|12
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|13
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|14
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MSF%d: steps %d: %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|p_step
argument_list|,
name|SV
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|2
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|3
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|4
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|5
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|6
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|7
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|8
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|9
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|10
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|11
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|12
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|13
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|14
argument_list|)
argument_list|,
name|SV
argument_list|(
literal|15
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SV
name|ees
operator|->
name|jump_fsecs
operator|=
name|delta_sfsec
expr_stmt|;
name|ees
operator|->
name|using_ramp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sincelast
operator|>
literal|170
condition|)
name|ees
operator|->
name|last_step_late
operator|+=
name|sincelast
operator|-
operator|(
operator|(
name|sum
operator|)
condition|?
name|sum
else|:
name|ees
operator|->
name|last_step_secs
operator|)
expr_stmt|;
else|else
name|ees
operator|->
name|last_step_late
operator|=
literal|30
expr_stmt|;
if|if
condition|(
name|ees
operator|->
name|last_step_late
operator|<
operator|-
literal|60
operator|||
name|ees
operator|->
name|last_step_late
operator|>
literal|120
condition|)
name|ees
operator|->
name|last_step_late
operator|=
literal|30
expr_stmt|;
if|if
condition|(
name|ees
operator|->
name|last_step_late
operator|<
literal|0
condition|)
name|ees
operator|->
name|last_step_late
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ees
operator|->
name|last_step_late
operator|>=
literal|60
condition|)
name|ees
operator|->
name|last_step_late
operator|=
literal|59
expr_stmt|;
name|sincelast
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* First time in -- just save info */
name|ees
operator|->
name|last_step_late
operator|=
literal|30
expr_stmt|;
name|ees
operator|->
name|jump_fsecs
operator|=
name|delta_sfsec
expr_stmt|;
name|ees
operator|->
name|using_ramp
operator|=
literal|1
expr_stmt|;
name|sum
operator|=
literal|4
operator|*
literal|60
expr_stmt|;
block|}
name|ees
operator|->
name|last_step
operator|=
name|this_uisec
expr_stmt|;
name|printf
argument_list|(
literal|"MSF%d: d=%3ld.%04ld@%d :%d:%d:$%d:%d:%d\n"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
operator|(
name|long
operator|)
name|msec
argument_list|(
name|delta_sfsec
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|subms
argument_list|(
name|delta_sfsec
argument_list|)
argument_list|,
name|ees
operator|->
name|second
argument_list|,
name|old_sincelast
argument_list|,
name|ees
operator|->
name|last_step_late
argument_list|,
name|count
argument_list|,
name|sum
argument_list|,
name|ees
operator|->
name|last_step_secs
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"MSF%d: d=%3d.%04d@%d :%d:%d:%d:%d:%d"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|msec
argument_list|(
name|delta_sfsec
argument_list|)
argument_list|,
name|subms
argument_list|(
name|delta_sfsec
argument_list|)
argument_list|,
name|ees
operator|->
name|second
argument_list|,
name|old_sincelast
argument_list|,
name|ees
operator|->
name|last_step_late
argument_list|,
name|count
argument_list|,
name|sum
argument_list|,
name|ees
operator|->
name|last_step_secs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
condition|)
name|ees
operator|->
name|last_step_secs
operator|=
name|sum
expr_stmt|;
block|}
comment|/* OK, so not a 4ms step at a minute boundry */
else|else
block|{
if|if
condition|(
name|suspect_4ms_step
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"MSF%d: suspect = %x, but delta of %d.%04d [%d.%04d<%d.%04d<%d.%04d: %d %d]"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|suspect_4ms_step
argument_list|,
name|msec
argument_list|(
name|delta_sfsec
argument_list|)
argument_list|,
name|subms
argument_list|(
name|delta_sfsec
argument_list|)
argument_list|,
name|msec
argument_list|(
name|EES_STEP_F
operator|-
name|EES_STEP_F_GRACE
argument_list|)
argument_list|,
name|subms
argument_list|(
name|EES_STEP_F
operator|-
name|EES_STEP_F_GRACE
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|msec
argument_list|(
name|delta_f_abs
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|subms
argument_list|(
name|delta_f_abs
argument_list|)
argument_list|,
name|msec
argument_list|(
name|EES_STEP_F
operator|+
name|EES_STEP_F_GRACE
argument_list|)
argument_list|,
name|subms
argument_list|(
name|EES_STEP_F
operator|+
name|EES_STEP_F_GRACE
argument_list|)
argument_list|,
name|ees
operator|->
name|second
argument_list|,
name|sincelast
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|delta_f_abs
operator|>
name|EES_STEP_NOTE
operator|)
operator|&&
name|ees
operator|->
name|last_l
operator|.
name|l_i
condition|)
block|{
specifier|static
name|int
name|ees_step_notes
init|=
name|EES_STEP_NOTES
decl_stmt|;
if|if
condition|(
name|ees_step_notes
operator|>
literal|0
condition|)
block|{
name|ees_step_notes
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"MSF%d: D=%3ld.%04ld@%02d :%d%s\n"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
operator|(
name|long
operator|)
name|msec
argument_list|(
name|delta_sfsec
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|subms
argument_list|(
name|delta_sfsec
argument_list|)
argument_list|,
name|ees
operator|->
name|second
argument_list|,
name|sincelast
argument_list|,
name|ees_step_notes
condition|?
literal|""
else|:
literal|" -- NO MORE !"
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"MSF%d: D=%3d.%04d@%02d :%d%s"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|msec
argument_list|(
name|delta_sfsec
argument_list|)
argument_list|,
name|subms
argument_list|(
name|delta_sfsec
argument_list|)
argument_list|,
name|ees
operator|->
name|second
argument_list|,
operator|(
name|ees
operator|->
name|last_step
operator|)
condition|?
name|sincelast
else|:
operator|-
literal|1
argument_list|,
name|ees_step_notes
condition|?
literal|""
else|:
literal|" -- NO MORE !"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|ees
operator|->
name|last_l
operator|=
name|ees
operator|->
name|arrvtime
expr_stmt|;
comment|/* IF we have found that it's ramping 	 *&& it's within twice the expected ramp period 	 *&& there is a non zero step size (avoid /0 !) 	 * THEN we twiddle things 	 */
if|if
condition|(
name|ees
operator|->
name|using_ramp
operator|&&
name|sincelast
operator|<
operator|(
name|ees
operator|->
name|last_step_secs
operator|)
operator|*
literal|2
operator|&&
name|ees
operator|->
name|last_step_secs
condition|)
block|{
name|long
name|sec_of_ramp
init|=
name|sincelast
operator|+
name|ees
operator|->
name|last_step_late
decl_stmt|;
name|long
name|fsecs
decl_stmt|;
name|l_fp
name|inc
decl_stmt|;
comment|/* Ramp time may vary, so may ramp for longer than last time */
if|if
condition|(
name|sec_of_ramp
operator|>
operator|(
name|ees
operator|->
name|last_step_secs
operator|+
literal|120
operator|)
condition|)
name|sec_of_ramp
operator|=
name|ees
operator|->
name|last_step_secs
expr_stmt|;
comment|/* sec_of_ramp * ees->jump_fsecs may overflow 2**32 */
name|fsecs
operator|=
name|sec_of_ramp
operator|*
operator|(
name|ees
operator|->
name|jump_fsecs
operator|/
name|ees
operator|->
name|last_step_secs
operator|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DB_LOG_DELTAS
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"[%x] MSF%d: %3ld/%03d -> d=%11ld (%d|%ld)"
argument_list|,
name|DB_LOG_DELTAS
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|sec_of_ramp
argument_list|,
name|ees
operator|->
name|last_step_secs
argument_list|,
name|fsecs
argument_list|,
name|pps_arrvstamp
operator|.
name|l_f
argument_list|,
name|pps_arrvstamp
operator|.
name|l_f
operator|+
name|fsecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DB_PRINT_DELTAS
condition|)
name|printf
argument_list|(
literal|"MSF%d: %3ld/%03d -> d=%11ld (%ld|%ld)\n"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|sec_of_ramp
argument_list|,
name|ees
operator|->
name|last_step_secs
argument_list|,
name|fsecs
argument_list|,
operator|(
name|long
operator|)
name|pps_arrvstamp
operator|.
name|l_f
argument_list|,
name|pps_arrvstamp
operator|.
name|l_f
operator|+
name|fsecs
argument_list|)
expr_stmt|;
comment|/* Must sign extend the result */
name|inc
operator|.
name|l_i
operator|=
operator|(
name|fsecs
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|inc
operator|.
name|l_f
operator|=
name|fsecs
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DB_INC_PPS
condition|)
block|{
name|L_SUB
argument_list|(
operator|&
name|pps_arrvstamp
argument_list|,
operator|&
name|inc
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|ees
operator|->
name|arrvtime
argument_list|,
operator|&
name|inc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|L_ADD
argument_list|(
operator|&
name|pps_arrvstamp
argument_list|,
operator|&
name|inc
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ees
operator|->
name|arrvtime
argument_list|,
operator|&
name|inc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|debug
operator|&
name|DB_LOG_DELTAS
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"[%x] MSF%d: ees->using_ramp=%d, sincelast=%x / %x, ees->last_step_secs=%x"
argument_list|,
name|DB_LOG_DELTAS
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|ees
operator|->
name|using_ramp
argument_list|,
name|sincelast
argument_list|,
operator|(
name|ees
operator|->
name|last_step_secs
operator|)
operator|*
literal|2
argument_list|,
name|ees
operator|->
name|last_step_secs
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DB_PRINT_DELTAS
condition|)
name|printf
argument_list|(
literal|"[%x] MSF%d: ees->using_ramp=%d, sincelast=%x / %x, ees->last_step_secs=%x\n"
argument_list|,
name|DB_LOG_DELTAS
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|ees
operator|->
name|using_ramp
argument_list|,
name|sincelast
argument_list|,
operator|(
name|ees
operator|->
name|last_step_secs
operator|)
operator|*
literal|2
argument_list|,
name|ees
operator|->
name|last_step_secs
argument_list|)
expr_stmt|;
block|}
name|L_SUB
argument_list|(
operator|&
name|ees
operator|->
name|arrvtime
argument_list|,
operator|&
name|offset_fudge
index|[
name|ees
operator|->
name|unit
index|]
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|pps_arrvstamp
argument_list|,
operator|&
name|offset_fudge
index|[
name|ees
operator|->
name|unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_pps_sample
operator|&&
operator|!
operator|(
name|debug
operator|&
name|DB_NO_PPS
operator|)
condition|)
block|{
comment|/* Sigh -- it expects its args negated */
name|L_NEG
argument_list|(
operator|&
name|pps_arrvstamp
argument_list|)
expr_stmt|;
comment|/* 		 * I had to disable this here, since it appears there is no pointer to the 		 * peer structure. 		 * 		 (void) pps_sample(peer,&pps_arrvstamp); 		*/
block|}
comment|/* Subtract off the local clock time stamp */
name|L_SUB
argument_list|(
operator|&
name|ees
operator|->
name|codeoffsets
index|[
name|n_sample
index|]
argument_list|,
operator|&
name|ees
operator|->
name|arrvtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DB_LOG_SAMPLES
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"MSF%d: [%x] %d (ees: %d %d) (pps: %d %d)%s"
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|DB_LOG_DELTAS
argument_list|,
name|n_sample
argument_list|,
name|ees
operator|->
name|codeoffsets
index|[
name|n_sample
index|]
operator|.
name|l_f
argument_list|,
name|ees
operator|->
name|codeoffsets
index|[
name|n_sample
index|]
operator|.
name|l_f
operator|/
literal|4295
argument_list|,
name|pps_arrvstamp
operator|.
name|l_f
argument_list|,
name|pps_arrvstamp
operator|.
name|l_f
operator|/
literal|4295
argument_list|,
operator|(
name|debug
operator|&
name|DB_NO_PPS
operator|)
condition|?
literal|" [no PPS]"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ees
operator|->
name|nsamples
operator|++
operator|==
name|NCODES
operator|-
literal|1
condition|)
name|ees_process
argument_list|(
name|ees
argument_list|)
expr_stmt|;
comment|/* Done! */
block|}
end_function

begin_comment
comment|/* offcompare - auxiliary comparison routine for offset sort */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|QSORT_USES_VOID_P
end_ifdef

begin_function
specifier|static
name|int
name|offcompare
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|l_fp
modifier|*
name|a
init|=
operator|(
specifier|const
name|l_fp
operator|*
operator|)
name|va
decl_stmt|;
specifier|const
name|l_fp
modifier|*
name|b
init|=
operator|(
specifier|const
name|l_fp
operator|*
operator|)
name|vb
decl_stmt|;
return|return
operator|(
name|L_ISGEQ
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|?
operator|(
name|L_ISEQU
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|?
literal|0
else|:
literal|1
operator|)
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|offcompare
parameter_list|(
specifier|const
name|l_fp
modifier|*
name|a
parameter_list|,
specifier|const
name|l_fp
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|L_ISGEQ
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|?
operator|(
name|L_ISEQU
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|?
literal|0
else|:
literal|1
operator|)
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QSORT_USES_VOID_P */
end_comment

begin_comment
comment|/* ees_process - process a pile of samples from the clock */
end_comment

begin_function
specifier|static
name|void
name|ees_process
parameter_list|(
name|struct
name|eesunit
modifier|*
name|ees
parameter_list|)
block|{
specifier|static
name|int
name|last_samples
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|noff
decl_stmt|;
specifier|register
name|l_fp
modifier|*
name|coffs
init|=
name|ees
operator|->
name|codeoffsets
decl_stmt|;
name|l_fp
name|offset
decl_stmt|,
name|tmp
decl_stmt|;
name|double
name|dispersion
decl_stmt|;
comment|/* ++++ */
name|int
name|lostsync
decl_stmt|,
name|isinsync
decl_stmt|;
name|int
name|samples
init|=
name|ees
operator|->
name|nsamples
decl_stmt|;
name|int
name|samplelog
init|=
literal|0
decl_stmt|;
comment|/* keep "gcc -Wall" happy ! */
name|int
name|samplereduce
init|=
operator|(
name|samples
operator|+
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
name|double
name|doffset
decl_stmt|;
comment|/* Reset things to zero so we don't have to worry later */
name|ees_reset
argument_list|(
name|ees
argument_list|)
expr_stmt|;
if|if
condition|(
name|sloppyclockflag
index|[
name|ees
operator|->
name|unit
index|]
condition|)
block|{
name|samplelog
operator|=
operator|(
name|samples
operator|<
literal|2
operator|)
condition|?
literal|0
else|:
operator|(
name|samples
operator|<
literal|5
operator|)
condition|?
literal|1
else|:
operator|(
name|samples
operator|<
literal|9
operator|)
condition|?
literal|2
else|:
operator|(
name|samples
operator|<
literal|17
operator|)
condition|?
literal|3
else|:
operator|(
name|samples
operator|<
literal|33
operator|)
condition|?
literal|4
else|:
literal|5
expr_stmt|;
name|samplereduce
operator|=
operator|(
literal|1
operator|<<
name|samplelog
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|samples
operator|!=
name|last_samples
operator|&&
operator|(
operator|(
name|samples
operator|!=
operator|(
name|last_samples
operator|-
literal|1
operator|)
operator|)
operator|||
name|samples
operator|<
literal|3
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Samples=%d (%d), samplereduce=%d ...."
argument_list|,
name|samples
argument_list|,
name|last_samples
argument_list|,
name|samplereduce
argument_list|)
expr_stmt|;
name|last_samples
operator|=
name|samples
expr_stmt|;
block|}
if|if
condition|(
name|samples
operator|<
literal|1
condition|)
return|return;
comment|/* If requested, dump the raw data we have in the buffer */
if|if
condition|(
name|ees
operator|->
name|dump_vals
condition|)
name|dump_buf
argument_list|(
name|coffs
argument_list|,
literal|0
argument_list|,
name|samples
argument_list|,
literal|"Raw  data  is:"
argument_list|)
expr_stmt|;
comment|/* Sort the offsets, trim off the extremes, then choose one. */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|coffs
argument_list|,
operator|(
name|u_int
operator|)
name|samples
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|,
name|offcompare
argument_list|)
expr_stmt|;
name|noff
operator|=
name|samples
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|noff
operator|-
name|i
operator|)
operator|>
name|samplereduce
condition|)
block|{
comment|/* Trim off the sample which is further away 		 * from the median.  We work this out by doubling 		 * the median, subtracting off the end samples, and 		 * looking at the sign of the answer, using the 		 * identity (c-b)-(b-a) == 2*b-a-c 		 */
name|tmp
operator|=
name|coffs
index|[
operator|(
name|noff
operator|+
name|i
operator|)
operator|/
literal|2
index|]
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|coffs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|coffs
index|[
name|noff
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|tmp
argument_list|)
condition|)
name|noff
operator|--
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
comment|/* If requested, dump the reduce data we have in the buffer */
if|if
condition|(
name|ees
operator|->
name|dump_vals
condition|)
name|dump_buf
argument_list|(
name|coffs
argument_list|,
name|i
argument_list|,
name|noff
argument_list|,
literal|"Reduced    to:"
argument_list|)
expr_stmt|;
comment|/* What we do next depends on the setting of the sloppy clock flag. 	 * If it is on, average the remainder to derive our estimate. 	 * Otherwise, just pick a representative value from the remaining stuff 	 */
if|if
condition|(
name|sloppyclockflag
index|[
name|ees
operator|->
name|unit
index|]
condition|)
block|{
name|offset
operator|.
name|l_ui
operator|=
name|offset
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|noff
condition|;
name|j
operator|++
control|)
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|coffs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|samplelog
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|L_RSHIFTU
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|coffs
index|[
name|i
operator|+
name|BESTSAMPLE
index|]
expr_stmt|;
comment|/* Compute the dispersion as the difference between the 	 * lowest and highest offsets that remain in the 	 * consideration list. 	 * 	 * It looks like MOST clocks have MOD (max error), so halve it ! 	 */
name|tmp
operator|=
name|coffs
index|[
name|noff
operator|-
literal|1
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|coffs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
define|#
directive|define
name|FRACT_SEC
parameter_list|(
name|n
parameter_list|)
value|((1<< 30) / (n/2))
name|dispersion
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|tmp
argument_list|)
operator|/
literal|2
expr_stmt|;
comment|/* ++++ */
if|if
condition|(
name|debug
operator|&
operator|(
name|DB_SYSLOG_SMPLI
operator||
name|DB_SYSLOG_SMPLE
operator|)
condition|)
name|msyslog
argument_list|(
operator|(
name|debug
operator|&
name|DB_SYSLOG_SMPLE
operator|)
condition|?
name|LOG_ERR
else|:
name|LOG_INFO
argument_list|,
literal|"I: [%x] Offset=%06d (%d), disp=%f%s [%d], %d %d=%d %d:%d %d=%d %d"
argument_list|,
name|debug
operator|&
operator|(
name|DB_SYSLOG_SMPLI
operator||
name|DB_SYSLOG_SMPLE
operator|)
argument_list|,
name|offset
operator|.
name|l_f
operator|/
literal|4295
argument_list|,
name|offset
operator|.
name|l_f
argument_list|,
operator|(
name|dispersion
operator|*
literal|1526
operator|)
operator|/
literal|100
argument_list|,
operator|(
name|sloppyclockflag
index|[
name|ees
operator|->
name|unit
index|]
operator|)
condition|?
literal|" by averaging"
else|:
literal|""
argument_list|,
name|FRACT_SEC
argument_list|(
literal|10
argument_list|)
operator|/
literal|4295
argument_list|,
operator|(
name|coffs
index|[
literal|0
index|]
operator|.
name|l_f
operator|)
operator|/
literal|4295
argument_list|,
name|i
argument_list|,
operator|(
name|coffs
index|[
name|i
index|]
operator|.
name|l_f
operator|)
operator|/
literal|4295
argument_list|,
operator|(
name|coffs
index|[
name|samples
operator|/
literal|2
index|]
operator|.
name|l_f
operator|)
operator|/
literal|4295
argument_list|,
operator|(
name|coffs
index|[
name|i
operator|+
name|BESTSAMPLE
index|]
operator|.
name|l_f
operator|)
operator|/
literal|4295
argument_list|,
name|noff
operator|-
literal|1
argument_list|,
operator|(
name|coffs
index|[
name|noff
operator|-
literal|1
index|]
operator|.
name|l_f
operator|)
operator|/
literal|4295
argument_list|,
operator|(
name|coffs
index|[
name|samples
operator|-
literal|1
index|]
operator|.
name|l_f
operator|)
operator|/
literal|4295
argument_list|)
expr_stmt|;
comment|/* Are we playing silly wotsits ? 	 * If we are using all data, see if there is a "small" delta, 	 * and if so, blurr this with 3/4 of the delta from the last value 	 */
if|if
condition|(
name|ees
operator|->
name|usealldata
operator|&&
name|ees
operator|->
name|offset
operator|.
name|l_uf
condition|)
block|{
name|long
name|diff
init|=
call|(
name|long
call|)
argument_list|(
name|ees
operator|->
name|offset
operator|.
name|l_uf
operator|-
name|offset
operator|.
name|l_uf
argument_list|)
decl_stmt|;
comment|/* is the delta small enough ? */
if|if
condition|(
operator|(
operator|-
name|FRACT_SEC
argument_list|(
literal|100
argument_list|)
operator|)
operator|<
name|diff
operator|&&
name|diff
operator|<
name|FRACT_SEC
argument_list|(
literal|100
argument_list|)
condition|)
block|{
name|int
name|samd
init|=
operator|(
literal|64
operator|*
literal|4
operator|)
operator|/
name|samples
decl_stmt|;
name|long
name|new
decl_stmt|;
if|if
condition|(
name|samd
operator|<
literal|2
condition|)
name|samd
operator|=
literal|2
expr_stmt|;
name|new
operator|=
name|offset
operator|.
name|l_uf
operator|+
operator|(
operator|(
name|diff
operator|*
operator|(
name|samd
operator|-
literal|1
operator|)
operator|)
operator|/
name|samd
operator|)
expr_stmt|;
comment|/* Sign change -> need to fix up int part */
if|if
condition|(
operator|(
name|new
operator|&
literal|0x80000000
operator|)
operator|!=
operator|(
operator|(
operator|(
name|long
operator|)
name|offset
operator|.
name|l_uf
operator|)
operator|&
literal|0x80000000
operator|)
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"I: %lx != %lx (%lx %lx), so add %d"
argument_list|,
name|new
operator|&
literal|0x80000000
argument_list|,
operator|(
operator|(
name|long
operator|)
name|offset
operator|.
name|l_uf
operator|)
operator|&
literal|0x80000000
argument_list|,
name|new
argument_list|,
operator|(
name|long
operator|)
name|offset
operator|.
name|l_uf
argument_list|,
operator|(
name|new
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|.
name|l_ui
operator|+=
operator|(
name|new
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
name|dispersion
operator|/=
literal|4
expr_stmt|;
if|if
condition|(
name|debug
operator|&
operator|(
name|DB_SYSLOG_SMTHI
operator||
name|DB_SYSLOG_SMTHE
operator|)
condition|)
name|msyslog
argument_list|(
operator|(
name|debug
operator|&
name|DB_SYSLOG_SMTHE
operator|)
condition|?
name|LOG_ERR
else|:
name|LOG_INFO
argument_list|,
literal|"I: [%x] Smooth data: %ld -> %ld, dispersion now %f"
argument_list|,
name|debug
operator|&
operator|(
name|DB_SYSLOG_SMTHI
operator||
name|DB_SYSLOG_SMTHE
operator|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|offset
operator|.
name|l_uf
operator|)
operator|/
literal|4295
argument_list|,
name|new
operator|/
literal|4295
argument_list|,
operator|(
name|dispersion
operator|*
literal|1526
operator|)
operator|/
literal|100
argument_list|)
expr_stmt|;
name|offset
operator|.
name|l_uf
operator|=
operator|(
name|unsigned
name|long
operator|)
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug
operator|&
operator|(
name|DB_SYSLOG_NSMTHI
operator||
name|DB_SYSLOG_NSMTHE
operator|)
condition|)
name|msyslog
argument_list|(
operator|(
name|debug
operator|&
name|DB_SYSLOG_NSMTHE
operator|)
condition|?
name|LOG_ERR
else|:
name|LOG_INFO
argument_list|,
literal|"[%x] No smooth as delta not %d< %ld< %d"
argument_list|,
name|debug
operator|&
operator|(
name|DB_SYSLOG_NSMTHI
operator||
name|DB_SYSLOG_NSMTHE
operator|)
argument_list|,
operator|-
name|FRACT_SEC
argument_list|(
literal|100
argument_list|)
argument_list|,
name|diff
argument_list|,
name|FRACT_SEC
argument_list|(
literal|100
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug
operator|&
operator|(
name|DB_SYSLOG_NSMTHI
operator||
name|DB_SYSLOG_NSMTHE
operator|)
condition|)
name|msyslog
argument_list|(
operator|(
name|debug
operator|&
name|DB_SYSLOG_NSMTHE
operator|)
condition|?
name|LOG_ERR
else|:
name|LOG_INFO
argument_list|,
literal|"I: [%x] No smooth as flag=%x and old=%x=%d (%d:%d)"
argument_list|,
name|debug
operator|&
operator|(
name|DB_SYSLOG_NSMTHI
operator||
name|DB_SYSLOG_NSMTHE
operator|)
argument_list|,
name|ees
operator|->
name|usealldata
argument_list|,
name|ees
operator|->
name|offset
operator|.
name|l_f
argument_list|,
name|ees
operator|->
name|offset
operator|.
name|l_uf
argument_list|,
name|offset
operator|.
name|l_f
argument_list|,
name|ees
operator|->
name|offset
operator|.
name|l_f
operator|-
name|offset
operator|.
name|l_f
argument_list|)
expr_stmt|;
comment|/* Collect offset info for debugging info */
name|ees
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|ees
operator|->
name|lowoffset
operator|=
name|coffs
index|[
name|i
index|]
expr_stmt|;
name|ees
operator|->
name|highoffset
operator|=
name|coffs
index|[
name|noff
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Determine synchronization status.  Can be unsync'd either 	 * by a report from the clock or by a leap hold. 	 * 	 * Loss of the radio signal for a short time does not cause 	 * us to go unsynchronised, since the receiver keeps quite 	 * good time on its own.  The spec says 20ms in 4 hours; the 	 * observed drift in our clock (Cambridge) is about a second 	 * a day, but even that keeps us within the inherent tolerance 	 * of the clock for about 15 minutes. Observation shows that 	 * the typical "short" outage is 3 minutes, so to allow us 	 * to ride out those, we will give it 5 minutes. 	 */
name|lostsync
operator|=
name|current_time
operator|-
name|ees
operator|->
name|clocklastgood
operator|>
literal|300
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|isinsync
operator|=
operator|(
name|lostsync
operator|||
name|ees
operator|->
name|leaphold
operator|>
name|current_time
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* Done.  Use time of last good, synchronised code as the 	 * reference time, and lastsampletime as the receive time. 	 */
if|if
condition|(
name|ees
operator|->
name|fix_pending
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"MSF%d: fix_pending=%d -> jump %x.%08x\n"
argument_list|,
name|ees
operator|->
name|fix_pending
argument_list|,
name|ees
operator|->
name|unit
argument_list|,
name|offset
operator|.
name|l_i
argument_list|,
name|offset
operator|.
name|l_f
argument_list|)
expr_stmt|;
name|ees
operator|->
name|fix_pending
operator|=
literal|0
expr_stmt|;
block|}
name|LFPTOD
argument_list|(
operator|&
name|offset
argument_list|,
name|doffset
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|ees
operator|->
name|peer
argument_list|)
expr_stmt|;
name|ees_event
argument_list|(
name|ees
argument_list|,
name|lostsync
condition|?
name|CEVNT_PROP
else|:
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* msfees_poll - called by the transmit procedure */
end_comment

begin_function
specifier|static
name|void
name|msfees_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock poll: INTERNAL: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ees clock poll: INTERNAL: unit %d unused"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ees_process
argument_list|(
name|eesunits
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current_time
operator|-
name|eesunits
index|[
name|unit
index|]
operator|->
name|lasttime
operator|)
operator|>
literal|150
condition|)
name|ees_event
argument_list|(
name|eesunits
index|[
name|unit
index|]
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_msfees_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

