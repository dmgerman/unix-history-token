begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Ancestor was ripped off from ../ntpres/ntpres.c by Greg Troxel 4/2/92 ** ** The previous resolver only needed to do forward lookups, and all names ** were known before we started the resolver process. ** ** The new code must be able to handle reverse lookups, and the requests can ** show up at any time. ** ** Here's the drill for the new logic. ** ** We want to be able to do forward or reverse lookups.  Forward lookups ** require one set of information to be sent back to the daemon, reverse ** lookups require a different set of information.  The caller knows this. ** ** The daemon must not block.  This includes communicating with the resolver ** process (if the resolver process is a separate task). ** ** Current resolver code blocks waiting for the response, so the ** alternatives are: ** ** - Find a nonblocking resolver library ** - Do each (initial) lookup in a separate process ** - - subsequent lookups *could* be handled by a different process that has **     a queue of pending requests ** ** We could use nonblocking lookups in a separate process (just to help out ** with timers). ** ** If we don't have nonblocking resolver calls we have more opportunities ** for denial-of-service problems. ** ** - too many fork()s ** - communications path ** */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_request.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * Each item we are to resolve and configure gets one of these  * structures defined for it.  */
end_comment

begin_struct
struct|struct
name|dns_entry
block|{
name|int
name|de_done
decl_stmt|;
define|#
directive|define
name|DE_NAME
value|001
define|#
directive|define
name|DE_ADDR
value|002
define|#
directive|define
name|DE_NA
value|(DE_NAME | DE_ADDR)
define|#
directive|define
name|DE_PENDING
value|000
define|#
directive|define
name|DE_GOT
value|010
define|#
directive|define
name|DE_FAIL
value|020
define|#
directive|define
name|DE_RESULT
value|(DE_PENDING | DE_GOT | DE_FAIL)
name|struct
name|dns_entry
modifier|*
name|de_next
decl_stmt|;
name|struct
name|info_dns_assoc
name|de_info
decl_stmt|;
comment|/* DNS info for peer */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|de_associd
value|de_info.associd
end_define

begin_define
define|#
directive|define
name|de_peeraddr
value|de_info.peeraddr
end_define

begin_define
define|#
directive|define
name|de_hostname
value|de_info.hostname
end_define

begin_comment
comment|/*  * dns_entries is a pointer to the list of configuration entries  * we have left to do.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dns_entry
modifier|*
name|dns_entries
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We take an interrupt every thirty seconds, at which time we decrement  * config_timer and resolve_timer.  The former is set to 2, so we retry  * unsucessful reconfigurations every minute.  The latter is set to  * an exponentially increasing value which starts at 2 and increases to  * 32.  When this expires we retry failed name resolutions.  *  * We sleep SLEEPTIME seconds before doing anything, to give the server  * time to arrange itself.  */
end_comment

begin_define
define|#
directive|define
name|MINRESOLVE
value|2
end_define

begin_define
define|#
directive|define
name|MAXRESOLVE
value|32
end_define

begin_define
define|#
directive|define
name|CONFIG_TIME
value|2
end_define

begin_define
define|#
directive|define
name|ALARM_TIME
value|30
end_define

begin_define
define|#
directive|define
name|SLEEPTIME
value|2
end_define

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|config_timer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|resolve_timer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|resolve_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next value of resolve timer */
end_comment

begin_comment
comment|/*  * Big hack attack  */
end_comment

begin_define
define|#
directive|define
name|LOCALHOST
value|0x7f000001
end_define

begin_comment
comment|/* 127.0.0.1, in hex, of course */
end_comment

begin_define
define|#
directive|define
name|SKEWTIME
value|0x08000000
end_define

begin_comment
comment|/* 0.03125 seconds as a l_fp fraction */
end_comment

begin_comment
comment|/*  * Select time out.  Set to 2 seconds.  The server is on the local machine,  * after all.  */
end_comment

begin_define
define|#
directive|define
name|TIMEOUT_SEC
value|2
end_define

begin_define
define|#
directive|define
name|TIMEOUT_USEC
value|0
end_define

begin_comment
comment|/*  * File descriptor for ntp request code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pipe descriptors  */
end_comment

begin_decl_stmt
name|int
name|p_fd
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stuff to be filled in by caller */
end_comment

begin_decl_stmt
specifier|extern
name|keyid_t
name|req_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request keyid */
end_comment

begin_comment
comment|/* end stuff to be filled in */
end_comment

begin_decl_stmt
name|void
name|ntp_res
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|bong
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|checkparent
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|removeentry
name|P
argument_list|(
operator|(
expr|struct
name|dns_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addentry
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|u_int32
operator|,
name|u_short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|findhostaddr
name|P
argument_list|(
operator|(
expr|struct
name|dns_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|openntp
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tell_ntpd
name|P
argument_list|(
operator|(
expr|struct
name|info_dns_assoc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doconfigure
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ntp_res_t_pkt
block|{
comment|/* Tagged packet: */
name|void
modifier|*
name|tag
decl_stmt|;
comment|/* For the caller */
name|u_int32
name|paddr
decl_stmt|;
comment|/* IP to look up, or 0 */
name|char
name|name
index|[
name|NTP_MAXHOSTNAME
index|]
decl_stmt|;
comment|/* Name to look up (if 1st byte is not 0) */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ntp_res_c_pkt
block|{
comment|/* Control packet: */
name|char
name|name
index|[
name|NTP_MAXHOSTNAME
index|]
decl_stmt|;
name|u_int32
name|paddr
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|version
decl_stmt|;
name|int
name|minpoll
decl_stmt|;
name|int
name|maxpoll
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|ttl
decl_stmt|;
name|keyid_t
name|keyid
decl_stmt|;
name|u_char
name|keystr
index|[
name|MAXFILENAME
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * ntp_res_name  */
end_comment

begin_function
name|void
name|ntp_res_name
parameter_list|(
name|u_int32
name|paddr
parameter_list|,
comment|/* Address to resolve */
name|u_short
name|associd
comment|/* Association ID */
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
comment|/* 	 * fork. 	 * - parent returns 	 * - child stuffs data and calls ntp_res() 	 */
for|for
control|(
name|pid
operator|=
operator|-
literal|1
init|;
name|pid
operator|==
operator|-
literal|1
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|RES_TEST
name|pid
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ntp_res_name: fork() failed: %m"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Error */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ntp_res_name: error..."
argument_list|)
expr_stmt|;
comment|/* Can't happen */
break|break;
case|case
literal|0
case|:
comment|/* Child */
name|closelog
argument_list|()
expr_stmt|;
name|kill_asyncio
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"ntp_res"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LOG_DAEMON */
ifndef|#
directive|ifndef
name|LOG_NTP
define|#
directive|define
name|LOG_NTP
value|LOG_DAEMON
endif|#
directive|endif
name|openlog
argument_list|(
literal|"ntp_res_name"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_NTP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addentry
argument_list|(
name|NULL
argument_list|,
name|paddr
argument_list|,
name|associd
argument_list|)
expr_stmt|;
name|ntp_res
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* Parent */
comment|/* Nothing to do.  (In Real Life, this never happens.) */
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * ntp_res needs;  *  *	req_key(???), req_keyid valid  *	syslog still open  */
end_comment

begin_function
name|void
name|ntp_res
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SIGSUSPEND
name|sigset_t
name|set
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGSUSPEND */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NTP_RESOLVER running"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* check out auth stuff */
if|if
condition|(
name|sys_authenticate
condition|)
block|{
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|req_keyid
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid request keyid %08x"
argument_list|,
name|req_keyid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Make a first cut at resolving the bunch 	 */
name|doconfigure
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_entries
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NTP_RESOLVER done!"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|SYS_WINNT
name|ExitThread
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't want to kill whole NT process */
else|#
directive|else
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* done that quick */
endif|#
directive|endif
block|}
comment|/* 	 * Here we've got some problem children.  Set up the timer 	 * and wait for it. 	 */
name|resolve_value
operator|=
name|resolve_timer
operator|=
name|MINRESOLVE
expr_stmt|;
name|config_timer
operator|=
name|CONFIG_TIME
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGALRM
argument_list|,
name|bong
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|ALARM_TIME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dns_entries
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|checkparent
argument_list|()
expr_stmt|;
if|if
condition|(
name|resolve_timer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|resolve_value
operator|<
name|MAXRESOLVE
condition|)
name|resolve_value
operator|<<=
literal|1
expr_stmt|;
name|resolve_timer
operator|=
name|resolve_value
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"resolve_timer: 0->%d"
argument_list|,
name|resolve_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|config_timer
operator|=
name|CONFIG_TIME
expr_stmt|;
name|doconfigure
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|config_timer
operator|==
literal|0
condition|)
block|{
name|config_timer
operator|=
name|CONFIG_TIME
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"config_timer: 0->%d"
argument_list|,
name|config_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|doconfigure
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* 		 * There is a race in here.  Is okay, though, since 		 * all it does is delay things by 30 seconds. 		 */
ifdef|#
directive|ifdef
name|HAVE_SIGSUSPEND
name|sigsuspend
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
else|#
directive|else
name|sigpause
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGSUSPEND */
else|#
directive|else
if|if
condition|(
name|config_timer
operator|>
literal|0
condition|)
name|config_timer
operator|--
expr_stmt|;
if|if
condition|(
name|resolve_timer
operator|>
literal|0
condition|)
name|resolve_timer
operator|--
expr_stmt|;
name|sleep
argument_list|(
name|ALARM_TIME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_comment
comment|/*  * bong - service and reschedule an alarm() interrupt  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|bong
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|config_timer
operator|>
literal|0
condition|)
name|config_timer
operator|--
expr_stmt|;
if|if
condition|(
name|resolve_timer
operator|>
literal|0
condition|)
name|resolve_timer
operator|--
expr_stmt|;
name|alarm
argument_list|(
name|ALARM_TIME
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * checkparent - see if our parent process is still running  *  * No need to worry in the Windows NT environment whether the  * main thread is still running, because if it goes  * down it takes the whole process down with it (in  * which case we won't be running this thread either)  * Turn function into NOP;  */
end_comment

begin_function
specifier|static
name|void
name|checkparent
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
comment|/* 	 * If our parent (the server) has died we will have been 	 * inherited by init.  If so, exit. 	 */
if|if
condition|(
name|getppid
argument_list|()
operator|==
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"parent died before we finished, exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT&& SYS_VXWORKS*/
block|}
end_function

begin_comment
comment|/*  * removeentry - we are done with an entry, remove it from the list  */
end_comment

begin_function
specifier|static
name|void
name|removeentry
parameter_list|(
name|struct
name|dns_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|register
name|struct
name|dns_entry
modifier|*
name|de
decl_stmt|;
name|de
operator|=
name|dns_entries
expr_stmt|;
if|if
condition|(
name|de
operator|==
name|entry
condition|)
block|{
name|dns_entries
operator|=
name|de
operator|->
name|de_next
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|de
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|de
operator|->
name|de_next
operator|==
name|entry
condition|)
block|{
name|de
operator|->
name|de_next
operator|=
name|entry
operator|->
name|de_next
expr_stmt|;
return|return;
block|}
name|de
operator|=
name|de
operator|->
name|de_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * addentry - add an entry to the configuration list  */
end_comment

begin_function
specifier|static
name|void
name|addentry
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|u_int32
name|paddr
parameter_list|,
name|u_short
name|associd
parameter_list|)
block|{
specifier|register
name|struct
name|dns_entry
modifier|*
name|de
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|struct
name|in_addr
name|si
decl_stmt|;
name|si
operator|.
name|s_addr
operator|=
name|paddr
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ntp_res_name:<%s> %s associd %d\n"
argument_list|,
operator|(
name|name
operator|)
condition|?
name|name
else|:
literal|""
argument_list|,
name|inet_ntoa
argument_list|(
name|si
argument_list|)
argument_list|,
name|associd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|de
operator|=
operator|(
expr|struct
name|dns_entry
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dns_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|strncpy
argument_list|(
name|de
operator|->
name|de_hostname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|de
operator|->
name|de_hostname
argument_list|)
expr_stmt|;
name|de
operator|->
name|de_done
operator|=
name|DE_PENDING
operator||
name|DE_ADDR
expr_stmt|;
block|}
else|else
block|{
name|de
operator|->
name|de_hostname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|de
operator|->
name|de_done
operator|=
name|DE_PENDING
operator||
name|DE_NAME
expr_stmt|;
block|}
name|de
operator|->
name|de_peeraddr
operator|=
name|paddr
expr_stmt|;
name|de
operator|->
name|de_associd
operator|=
name|associd
expr_stmt|;
name|de
operator|->
name|de_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dns_entries
operator|==
name|NULL
condition|)
block|{
name|dns_entries
operator|=
name|de
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|dns_entry
modifier|*
name|dep
decl_stmt|;
for|for
control|(
name|dep
operator|=
name|dns_entries
init|;
name|dep
operator|->
name|de_next
operator|!=
name|NULL
condition|;
name|dep
operator|=
name|dep
operator|->
name|de_next
control|)
comment|/* nothing */
empty_stmt|;
name|dep
operator|->
name|de_next
operator|=
name|de
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * findhostaddr - resolve a host name into an address (Or vice-versa)  *  * sets entry->de_done appropriately when we're finished.  We're finished if  * we either successfully look up the missing name or address, or if we get a  * "permanent" failure on the lookup.  *  */
end_comment

begin_function
specifier|static
name|void
name|findhostaddr
parameter_list|(
name|struct
name|dns_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|checkparent
argument_list|()
expr_stmt|;
comment|/* make sure our guy is still running */
comment|/* 	 * The following should never trip - this subroutine isn't 	 * called if hostname and peeraddr are "filled". 	 */
if|if
condition|(
name|entry
operator|->
name|de_hostname
index|[
literal|0
index|]
operator|&&
name|entry
operator|->
name|de_peeraddr
condition|)
block|{
name|struct
name|in_addr
name|si
decl_stmt|;
name|si
operator|.
name|s_addr
operator|=
name|entry
operator|->
name|de_peeraddr
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"findhostaddr: both de_hostname and de_peeraddr are defined:<%s>/%s: state %#x"
argument_list|,
operator|&
name|entry
operator|->
name|de_hostname
index|[
literal|0
index|]
argument_list|,
name|inet_ntoa
argument_list|(
name|si
argument_list|)
argument_list|,
name|entry
operator|->
name|de_done
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * The following should never trip. 	 */
if|if
condition|(
operator|!
name|entry
operator|->
name|de_hostname
index|[
literal|0
index|]
operator|&&
operator|!
name|entry
operator|->
name|de_peeraddr
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"findhostaddr: both de_hostname and de_peeraddr are undefined!"
argument_list|)
expr_stmt|;
name|entry
operator|->
name|de_done
operator||=
name|DE_FAIL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|entry
operator|->
name|de_hostname
index|[
literal|0
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"findhostaddr: Resolving<%s>"
argument_list|,
operator|&
name|entry
operator|->
name|de_hostname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|hp
operator|=
name|gethostbyname
argument_list|(
operator|&
name|entry
operator|->
name|de_hostname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|struct
name|in_addr
name|si
decl_stmt|;
name|si
operator|.
name|s_addr
operator|=
name|entry
operator|->
name|de_peeraddr
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"findhostaddr: Resolving %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|entry
operator|->
name|de_peeraddr
argument_list|,
sizeof|sizeof
name|entry
operator|->
name|de_peeraddr
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Bail if we should TRY_AGAIN. 		 * Otherwise, we have a permanent failure. 		 */
if|if
condition|(
name|h_errno
operator|==
name|TRY_AGAIN
condition|)
return|return;
name|entry
operator|->
name|de_done
operator||=
name|DE_FAIL
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|de_done
operator||=
name|DE_GOT
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|de_done
operator|&
name|DE_GOT
condition|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|de_done
operator|&
name|DE_NA
condition|)
block|{
case|case
name|DE_NAME
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"findhostaddr: name resolved."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Use the first address.  We don't have any way to 			 * tell preferences and older gethostbyname() 			 * implementations only return one. 			 */
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|entry
operator|->
name|de_peeraddr
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DE_ADDR
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"findhostaddr: address resolved."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strncpy
argument_list|(
operator|&
name|entry
operator|->
name|de_hostname
index|[
literal|0
index|]
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
sizeof|sizeof
name|entry
operator|->
name|de_hostname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"findhostaddr: Bogus de_done: %#x"
argument_list|,
name|entry
operator|->
name|de_done
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|struct
name|in_addr
name|si
decl_stmt|;
specifier|const
name|char
modifier|*
name|hes
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_HSTRERROR
name|char
name|hnum
index|[
literal|20
index|]
decl_stmt|;
switch|switch
condition|(
name|h_errno
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
name|hes
operator|=
literal|"Authoritive Answer Host not found"
expr_stmt|;
break|break;
case|case
name|TRY_AGAIN
case|:
name|hes
operator|=
literal|"Non-Authoritative Host not found, or SERVERFAIL"
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
name|hes
operator|=
literal|"Non recoverable errors, FORMERR, REFUSED, NOTIMP"
expr_stmt|;
break|break;
case|case
name|NO_DATA
case|:
name|hes
operator|=
literal|"Valid name, no data record of requested type"
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|hnum
argument_list|,
sizeof|sizeof
name|hnum
argument_list|,
literal|"%d"
argument_list|,
name|h_errno
argument_list|)
expr_stmt|;
name|hes
operator|=
name|hnum
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|hes
operator|=
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|si
operator|.
name|s_addr
operator|=
name|entry
operator|->
name|de_peeraddr
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"findhostaddr: Failed resolution on<%s>/%s: %s"
argument_list|,
name|entry
operator|->
name|de_hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|si
argument_list|)
argument_list|,
name|hes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Send a NAK message back to the daemon */
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * openntp - open a socket to the ntp server  */
end_comment

begin_function
specifier|static
name|void
name|openntp
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|saddr
decl_stmt|;
if|if
condition|(
name|sockfd
operator|>=
literal|0
condition|)
return|return;
name|sockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|saddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
name|saddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|saddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
comment|/* trash */
name|saddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|LOCALHOST
argument_list|)
expr_stmt|;
comment|/* garbage */
comment|/* 	 * Make the socket non-blocking.  We'll wait with select() 	 */
ifndef|#
directive|ifndef
name|SYS_WINNT
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|sockfd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NONBLOCK) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|sockfd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
include|#
directive|include
file|"Bletch: NEED NON BLOCKING IO"
endif|#
directive|endif
comment|/* FNDDELAY */
endif|#
directive|endif
comment|/* O_NONBLOCK */
else|#
directive|else
comment|/* SYS_WINNT */
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ioctlsocket
argument_list|(
name|sockfd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
name|SOCKET_ERROR
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctlsocket(FIONBIO) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Windows NT - set socket in non-blocking mode */
block|}
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"openntp: connect() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * tell_ntpd: Tell ntpd what we discovered.  */
end_comment

begin_function
specifier|static
name|int
name|tell_ntpd
parameter_list|(
name|struct
name|info_dns_assoc
modifier|*
name|conf
parameter_list|)
block|{
name|fd_set
name|fdset
decl_stmt|;
name|struct
name|timeval
name|tvout
decl_stmt|;
name|struct
name|req_pkt
name|reqpkt
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|HANDLE
name|hReadWriteEvent
init|=
name|NULL
decl_stmt|;
name|BOOL
name|ret
decl_stmt|;
name|DWORD
name|NumberOfBytesWritten
decl_stmt|,
name|NumberOfBytesRead
decl_stmt|,
name|dwWait
decl_stmt|;
name|OVERLAPPED
name|overlap
decl_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
name|checkparent
argument_list|()
expr_stmt|;
comment|/* make sure our guy is still running */
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|openntp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|hReadWriteEvent
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Try to clear out any previously received traffic so it 	 * doesn't fool us.  Note the socket is nonblocking. 	 */
name|tvout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
while|while
condition|(
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fdset
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvout
argument_list|)
operator|>
literal|0
condition|)
block|{
name|recv
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_MAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make up a request packet with the configuration info 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reqpkt
argument_list|)
argument_list|)
expr_stmt|;
name|reqpkt
operator|.
name|rm_vn_mode
operator|=
name|RM_VN_MODE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reqpkt
operator|.
name|auth_seq
operator|=
name|AUTH_SEQ
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* authenticated, no seq */
name|reqpkt
operator|.
name|implementation
operator|=
name|IMPL_XNTPD
expr_stmt|;
comment|/* local implementation */
name|reqpkt
operator|.
name|request
operator|=
name|REQ_HOSTNAME_ASSOCID
expr_stmt|;
comment|/* Hostname for associd */
name|reqpkt
operator|.
name|err_nitems
operator|=
name|ERR_NITEMS
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* one item */
name|reqpkt
operator|.
name|mbz_itemsize
operator|=
name|MBZ_ITEMSIZE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|info_dns_assoc
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|reqpkt
operator|.
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|conf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_dns_assoc
argument_list|)
argument_list|)
expr_stmt|;
name|reqpkt
operator|.
name|keyid
operator|=
name|htonl
argument_list|(
name|req_keyid
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|ts
argument_list|,
name|SKEWTIME
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|reqpkt
operator|.
name|tstamp
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sys_authenticate
condition|)
name|n
operator|=
name|authencrypt
argument_list|(
name|req_keyid
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_NOMAC
argument_list|)
expr_stmt|;
comment|/* 	 * Done.  Send it. 	 */
ifndef|#
directive|ifndef
name|SYS_WINNT
name|n
operator|=
name|send
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|REQ_LEN_NOMAC
operator|+
name|n
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"send to NTP server failed: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* maybe should exit */
block|}
else|#
directive|else
comment|/* In the NT world, documentation seems to indicate that there 	 * exist _write and _read routines that can be used to do blocking 	 * I/O on sockets. Problem is these routines require a socket 	 * handle obtained through the _open_osf_handle C run-time API 	 * of which there is no explanation in the documentation. We need 	 * nonblocking write's and read's anyway for our purpose here. 	 * We're therefore forced to deviate a little bit from the Unix 	 * model here and use the ReadFile and WriteFile Win32 I/O API's 	 * on the socket 	 */
name|overlap
operator|.
name|Offset
operator|=
name|overlap
operator|.
name|OffsetHigh
operator|=
operator|(
name|DWORD
operator|)
literal|0
expr_stmt|;
name|overlap
operator|.
name|hEvent
operator|=
name|hReadWriteEvent
expr_stmt|;
name|ret
operator|=
name|WriteFile
argument_list|(
operator|(
name|HANDLE
operator|)
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_NOMAC
operator|+
name|n
argument_list|,
operator|(
name|LPDWORD
operator|)
operator|&
name|NumberOfBytesWritten
argument_list|,
operator|(
name|LPOVERLAPPED
operator|)
operator|&
name|overlap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_IO_PENDING
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"send to NTP server failed: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dwWait
operator|=
name|WaitForSingleObject
argument_list|(
name|hReadWriteEvent
argument_list|,
operator|(
name|DWORD
operator|)
name|TIMEOUT_SEC
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dwWait
operator|==
name|WAIT_FAILED
operator|)
operator|||
operator|(
name|dwWait
operator|==
name|WAIT_TIMEOUT
operator|)
condition|)
block|{
if|if
condition|(
name|dwWait
operator|==
name|WAIT_FAILED
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForSingleObject failed: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Wait for a response.  A weakness of the mode 7 protocol used 	 * is that there is no way to associate a response with a 	 * particular request, i.e. the response to this configuration 	 * request is indistinguishable from that to any other.  I should 	 * fix this some day.  In any event, the time out is fairly 	 * pessimistic to make sure that if an answer is coming back 	 * at all, we get it. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|tvout
operator|.
name|tv_sec
operator|=
name|TIMEOUT_SEC
expr_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
name|TIMEOUT_USEC
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fdset
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvout
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select() fails: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"select() returned 0."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|SYS_WINNT
name|n
operator|=
name|recv
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
name|REQ_LEN_MAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"recv() fails: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
continue|continue;
block|}
else|#
directive|else
comment|/* Overlapped I/O used on non-blocking sockets on Windows NT */
name|ret
operator|=
name|ReadFile
argument_list|(
operator|(
name|HANDLE
operator|)
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqpkt
argument_list|,
operator|(
name|DWORD
operator|)
name|REQ_LEN_MAC
argument_list|,
operator|(
name|LPDWORD
operator|)
operator|&
name|NumberOfBytesRead
argument_list|,
operator|(
name|LPOVERLAPPED
operator|)
operator|&
name|overlap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_IO_PENDING
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ReadFile() fails: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dwWait
operator|=
name|WaitForSingleObject
argument_list|(
name|hReadWriteEvent
argument_list|,
operator|(
name|DWORD
operator|)
name|TIMEOUT_SEC
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dwWait
operator|==
name|WAIT_FAILED
operator|)
operator|||
operator|(
name|dwWait
operator|==
name|WAIT_TIMEOUT
operator|)
condition|)
block|{
if|if
condition|(
name|dwWait
operator|==
name|WAIT_FAILED
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForSingleObject fails: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
continue|continue;
block|}
name|n
operator|=
name|NumberOfBytesRead
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 		 * Got one.  Check through to make sure it is what 		 * we expect. 		 */
if|if
condition|(
name|n
operator|<
name|RESP_HEADER_SIZE
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"received runt response (%d octets)"
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ISRESPONSE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"received non-response packet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|ISMORE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"received fragmented packet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|INFO_VERSION
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|<
literal|2
operator|)
operator|||
operator|(
name|INFO_VERSION
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
operator|)
operator|)
operator|||
name|INFO_MODE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
operator|!=
name|MODE_PRIVATE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"version (%d/%d) or mode (%d/%d) incorrect"
argument_list|,
name|INFO_VERSION
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
argument_list|,
name|NTP_VERSION
argument_list|,
name|INFO_MODE
argument_list|(
name|reqpkt
operator|.
name|rm_vn_mode
argument_list|)
argument_list|,
name|MODE_PRIVATE
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|INFO_SEQ
argument_list|(
name|reqpkt
operator|.
name|auth_seq
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nonzero sequence number (%d)"
argument_list|,
name|INFO_SEQ
argument_list|(
name|reqpkt
operator|.
name|auth_seq
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|reqpkt
operator|.
name|implementation
operator|!=
name|IMPL_XNTPD
operator|||
name|reqpkt
operator|.
name|request
operator|!=
name|REQ_HOSTNAME_ASSOCID
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"implementation (%d/%d) or request (%d/%d) incorrect"
argument_list|,
name|reqpkt
operator|.
name|implementation
argument_list|,
name|IMPL_XNTPD
argument_list|,
name|reqpkt
operator|.
name|request
argument_list|,
name|REQ_HOSTNAME_ASSOCID
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|reqpkt
operator|.
name|err_nitems
argument_list|)
operator|!=
literal|0
operator|||
name|INFO_MBZ
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
operator|!=
literal|0
operator|||
name|INFO_ITEMSIZE
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nitems (%d) mbz (%d) or itemsize (%d) nonzero"
argument_list|,
name|INFO_NITEMS
argument_list|(
name|reqpkt
operator|.
name|err_nitems
argument_list|)
argument_list|,
name|INFO_MBZ
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
argument_list|,
name|INFO_ITEMSIZE
argument_list|(
name|reqpkt
operator|.
name|mbz_itemsize
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|n
operator|=
name|INFO_ERR
argument_list|(
name|reqpkt
operator|.
name|err_nitems
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|INFO_OKAY
case|:
comment|/* success */
return|return
literal|1
return|;
case|case
name|INFO_ERR_IMPL
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server reports implementation mismatch!!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_REQ
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server claims configuration request is unknown"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_FMT
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server indicates a format error occurred(!!)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_NODATA
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server indicates no data available (shouldn't happen)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|INFO_ERR_AUTH
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server returns a permission denied error"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server returns unknown error code %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * doconfigure - attempt to resolve names/addresses  */
end_comment

begin_function
specifier|static
name|void
name|doconfigure
parameter_list|(
name|int
name|dores
parameter_list|)
block|{
specifier|register
name|struct
name|dns_entry
modifier|*
name|de
decl_stmt|;
specifier|register
name|struct
name|dns_entry
modifier|*
name|deremove
decl_stmt|;
name|char
modifier|*
name|done_msg
init|=
literal|""
decl_stmt|;
name|de
operator|=
name|dns_entries
expr_stmt|;
while|while
condition|(
name|de
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|struct
name|in_addr
name|si
decl_stmt|;
name|si
operator|.
name|s_addr
operator|=
name|de
operator|->
name|de_peeraddr
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"doconfigure: name:<%s> peeraddr: %s"
argument_list|,
name|de
operator|->
name|de_hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dores
operator|&&
operator|(
name|de
operator|->
name|de_hostname
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|de
operator|->
name|de_peeraddr
operator|==
literal|0
operator|)
condition|)
block|{
name|findhostaddr
argument_list|(
name|de
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|de
operator|->
name|de_done
operator|&
name|DE_RESULT
condition|)
block|{
case|case
name|DE_PENDING
case|:
name|done_msg
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|DE_GOT
case|:
name|done_msg
operator|=
literal|"succeeded"
expr_stmt|;
break|break;
case|case
name|DE_FAIL
case|:
name|done_msg
operator|=
literal|"failed"
expr_stmt|;
break|break;
default|default:
name|done_msg
operator|=
literal|"(error - shouldn't happen)"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|done_msg
index|[
literal|0
index|]
condition|)
block|{
comment|/* Send the answer */
if|if
condition|(
name|tell_ntpd
argument_list|(
operator|&
name|de
operator|->
name|de_info
argument_list|)
condition|)
block|{
name|struct
name|in_addr
name|si
decl_stmt|;
name|si
operator|.
name|s_addr
operator|=
name|de
operator|->
name|de_peeraddr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DNS resolution on<%s>/%s %s"
argument_list|,
name|de
operator|->
name|de_hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|si
argument_list|)
argument_list|,
name|done_msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|deremove
operator|=
name|de
expr_stmt|;
name|de
operator|=
name|deremove
operator|->
name|de_next
expr_stmt|;
name|removeentry
argument_list|(
name|deremove
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|de
operator|=
name|de
operator|->
name|de_next
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

