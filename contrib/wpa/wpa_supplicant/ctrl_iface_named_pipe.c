begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant / Windows Named Pipe -based control interface  * Copyright (c) 2004-2006, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"eapol_supp/eapol_supp_sm.h"
end_include

begin_include
include|#
directive|include
file|"wpa_supplicant_i.h"
end_include

begin_include
include|#
directive|include
file|"ctrl_iface.h"
end_include

begin_include
include|#
directive|include
file|"common/wpa_ctrl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__MINGW32_VERSION
end_ifdef

begin_comment
comment|/* mingw-w32api v3.1 does not yet include sddl.h, so define needed parts here  */
end_comment

begin_define
define|#
directive|define
name|SDDL_REVISION_1
value|1
end_define

begin_function_decl
name|BOOL
name|WINAPI
name|ConvertStringSecurityDescriptorToSecurityDescriptorA
parameter_list|(
name|LPCSTR
parameter_list|,
name|DWORD
parameter_list|,
name|PSECURITY_DESCRIPTOR
modifier|*
parameter_list|,
name|PULONG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BOOL
name|WINAPI
name|ConvertStringSecurityDescriptorToSecurityDescriptorW
parameter_list|(
name|LPCWSTR
parameter_list|,
name|DWORD
parameter_list|,
name|PSECURITY_DESCRIPTOR
modifier|*
parameter_list|,
name|PULONG
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|UNICODE
end_ifdef

begin_define
define|#
directive|define
name|ConvertStringSecurityDescriptorToSecurityDescriptor
define|\
value|ConvertStringSecurityDescriptorToSecurityDescriptorW
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ConvertStringSecurityDescriptorToSecurityDescriptor
define|\
value|ConvertStringSecurityDescriptorToSecurityDescriptorA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __MINGW32_VERSION */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32_WINNT
end_ifndef

begin_define
define|#
directive|define
name|_WIN32_WINNT
value|0x0500
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sddl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __MINGW32_VERSION */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WPA_SUPPLICANT_NAMED_PIPE
end_ifndef

begin_define
define|#
directive|define
name|WPA_SUPPLICANT_NAMED_PIPE
value|"WpaSupplicant"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NAMED_PIPE_PREFIX
value|TEXT("\\\\.\\pipe\\") TEXT(WPA_SUPPLICANT_NAMED_PIPE)
end_define

begin_comment
comment|/* Per-interface ctrl_iface */
end_comment

begin_define
define|#
directive|define
name|REQUEST_BUFSIZE
value|256
end_define

begin_define
define|#
directive|define
name|REPLY_BUFSIZE
value|4096
end_define

begin_struct_decl
struct_decl|struct
name|ctrl_iface_priv
struct_decl|;
end_struct_decl

begin_comment
comment|/**  * struct wpa_ctrl_dst - Internal data structure of control interface clients  *  * This structure is used to store information about registered control  * interface monitors into struct wpa_supplicant. This data is private to  * ctrl_iface_named_pipe.c and should not be touched directly from other files.  */
end_comment

begin_struct
struct|struct
name|wpa_ctrl_dst
block|{
comment|/* Note: OVERLAPPED must be the first member of struct wpa_ctrl_dst */
name|OVERLAPPED
name|overlap
decl_stmt|;
name|struct
name|wpa_ctrl_dst
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|ctrl_iface_priv
modifier|*
name|priv
decl_stmt|;
name|HANDLE
name|pipe
decl_stmt|;
name|int
name|attached
decl_stmt|;
name|int
name|debug_level
decl_stmt|;
name|int
name|errors
decl_stmt|;
name|char
name|req_buf
index|[
name|REQUEST_BUFSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|rsp_buf
decl_stmt|;
name|int
name|used
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ctrl_iface_priv
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
decl_stmt|;
name|struct
name|wpa_ctrl_dst
modifier|*
name|ctrl_dst
decl_stmt|;
name|SECURITY_ATTRIBUTES
name|attr
decl_stmt|;
name|int
name|sec_attr_set
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|wpa_supplicant_ctrl_iface_send
parameter_list|(
name|struct
name|ctrl_iface_priv
modifier|*
name|priv
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctrl_close_pipe
parameter_list|(
name|struct
name|wpa_ctrl_dst
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpa_supplicant_ctrl_iface_receive
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|VOID
name|WINAPI
name|ctrl_iface_read_completed
parameter_list|(
name|DWORD
name|err
parameter_list|,
name|DWORD
name|bytes
parameter_list|,
name|LPOVERLAPPED
name|overlap
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|wpa_global_dst
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|global_close_pipe
parameter_list|(
name|struct
name|wpa_global_dst
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wpa_supplicant_global_iface_receive
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|VOID
name|WINAPI
name|global_iface_read_completed
parameter_list|(
name|DWORD
name|err
parameter_list|,
name|DWORD
name|bytes
parameter_list|,
name|LPOVERLAPPED
name|overlap
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|ctrl_broken_pipe
parameter_list|(
name|HANDLE
name|pipe
parameter_list|,
name|int
name|used
parameter_list|)
block|{
name|DWORD
name|err
decl_stmt|;
if|if
condition|(
name|PeekNamedPipe
argument_list|(
name|pipe
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERROR_BROKEN_PIPE
operator|||
operator|(
name|err
operator|==
name|ERROR_BAD_PIPE
operator|&&
name|used
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctrl_flush_broken_pipes
parameter_list|(
name|struct
name|ctrl_iface_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|wpa_ctrl_dst
modifier|*
name|dst
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dst
operator|=
name|priv
operator|->
name|ctrl_dst
expr_stmt|;
while|while
condition|(
name|dst
condition|)
block|{
name|next
operator|=
name|dst
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ctrl_broken_pipe
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
name|dst
operator|->
name|used
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: closing broken pipe %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ctrl_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ctrl_open_pipe
parameter_list|(
name|struct
name|ctrl_iface_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|wpa_ctrl_dst
modifier|*
name|dst
decl_stmt|;
name|DWORD
name|err
decl_stmt|;
name|TCHAR
name|name
index|[
literal|256
index|]
decl_stmt|;
name|dst
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: Open pipe %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|->
name|priv
operator|=
name|priv
expr_stmt|;
name|dst
operator|->
name|debug_level
operator|=
name|MSG_INFO
expr_stmt|;
name|dst
operator|->
name|pipe
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|dst
operator|->
name|overlap
operator|.
name|hEvent
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CTRL: CreateEvent failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|eloop_register_event
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|)
argument_list|,
name|wpa_supplicant_ctrl_iface_receive
argument_list|,
name|dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNICODE
name|_snwprintf
argument_list|(
argument|name
argument_list|,
literal|256
argument_list|,
argument|NAMED_PIPE_PREFIX TEXT(
literal|"-%S"
argument|)
argument_list|,
argument|priv->wpa_s->ifname
argument_list|)
empty_stmt|;
else|#
directive|else
comment|/* UNICODE */
name|os_snprintf
argument_list|(
name|name
argument_list|,
literal|256
argument_list|,
name|NAMED_PIPE_PREFIX
literal|"-%s"
argument_list|,
name|priv
operator|->
name|wpa_s
operator|->
name|ifname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNICODE */
comment|/* TODO: add support for configuring access list for the pipe */
name|dst
operator|->
name|pipe
operator|=
name|CreateNamedPipe
argument_list|(
name|name
argument_list|,
name|PIPE_ACCESS_DUPLEX
operator||
name|FILE_FLAG_OVERLAPPED
argument_list|,
name|PIPE_TYPE_MESSAGE
operator||
name|PIPE_READMODE_MESSAGE
operator||
name|PIPE_WAIT
argument_list|,
literal|15
argument_list|,
name|REPLY_BUFSIZE
argument_list|,
name|REQUEST_BUFSIZE
argument_list|,
literal|1000
argument_list|,
name|priv
operator|->
name|sec_attr_set
condition|?
operator|&
name|priv
operator|->
name|attr
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|pipe
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CTRL: CreateNamedPipe failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|ConnectNamedPipe
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
operator|&
name|dst
operator|->
name|overlap
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CTRL: ConnectNamedPipe failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|dst
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|ERROR_IO_PENDING
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: ConnectNamedPipe: connection in "
literal|"progress"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_PIPE_CONNECTED
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: ConnectNamedPipe: already "
literal|"connected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SetEvent
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|)
condition|)
break|break;
comment|/* fall through */
default|default:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: ConnectNamedPipe error: %d"
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|dst
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dst
operator|->
name|next
operator|=
name|priv
operator|->
name|ctrl_dst
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|next
condition|)
name|dst
operator|->
name|next
operator|->
name|prev
operator|=
name|dst
expr_stmt|;
name|priv
operator|->
name|ctrl_dst
operator|=
name|dst
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|ctrl_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctrl_close_pipe
parameter_list|(
name|struct
name|wpa_ctrl_dst
modifier|*
name|dst
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: close pipe %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
condition|)
block|{
name|eloop_unregister_event
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|)
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|->
name|pipe
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
block|{
comment|/* 		 * Could use FlushFileBuffers() here to guarantee that all data 		 * gets delivered to the client, but that can block, so let's 		 * not do this for now. 		 * FlushFileBuffers(dst->pipe); 		 */
name|CloseHandle
argument_list|(
name|dst
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|->
name|prev
condition|)
name|dst
operator|->
name|prev
operator|->
name|next
operator|=
name|dst
operator|->
name|next
expr_stmt|;
else|else
name|dst
operator|->
name|priv
operator|->
name|ctrl_dst
operator|=
name|dst
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|next
condition|)
name|dst
operator|->
name|next
operator|->
name|prev
operator|=
name|dst
operator|->
name|prev
expr_stmt|;
name|os_free
argument_list|(
name|dst
operator|->
name|rsp_buf
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|WINAPI
name|ctrl_iface_write_completed
parameter_list|(
name|DWORD
name|err
parameter_list|,
name|DWORD
name|bytes
parameter_list|,
name|LPOVERLAPPED
name|overlap
parameter_list|)
block|{
name|struct
name|wpa_ctrl_dst
modifier|*
name|dst
init|=
operator|(
expr|struct
name|wpa_ctrl_dst
operator|*
operator|)
name|overlap
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: Overlapped write completed: dst=%p "
literal|"err=%d bytes=%d"
argument_list|,
name|dst
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|,
operator|(
name|int
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ctrl_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
name|os_free
argument_list|(
name|dst
operator|->
name|rsp_buf
argument_list|)
expr_stmt|;
name|dst
operator|->
name|rsp_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ReadFileEx
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
name|dst
operator|->
name|req_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
operator|->
name|req_buf
argument_list|)
argument_list|,
operator|&
name|dst
operator|->
name|overlap
argument_list|,
name|ctrl_iface_read_completed
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: ReadFileEx failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|ctrl_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: Overlapped read started for %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_ctrl_iface_rx
parameter_list|(
name|struct
name|wpa_ctrl_dst
modifier|*
name|dst
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|dst
operator|->
name|priv
operator|->
name|wpa_s
decl_stmt|;
name|char
modifier|*
name|reply
init|=
name|NULL
decl_stmt|,
modifier|*
name|send_buf
decl_stmt|;
name|size_t
name|reply_len
init|=
literal|0
decl_stmt|,
name|send_len
decl_stmt|;
name|int
name|new_attached
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|dst
operator|->
name|req_buf
decl_stmt|;
name|dst
operator|->
name|used
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|REQUEST_BUFSIZE
condition|)
name|len
operator|=
name|REQUEST_BUFSIZE
operator|-
literal|1
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|os_strcmp
argument_list|(
name|buf
argument_list|,
literal|"ATTACH"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dst
operator|->
name|attached
operator|=
literal|1
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL_IFACE monitor attached"
argument_list|)
expr_stmt|;
name|new_attached
operator|=
literal|1
expr_stmt|;
name|reply_len
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os_strcmp
argument_list|(
name|buf
argument_list|,
literal|"DETACH"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dst
operator|->
name|attached
operator|=
literal|0
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL_IFACE monitor detached"
argument_list|)
expr_stmt|;
name|reply_len
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os_strncmp
argument_list|(
name|buf
argument_list|,
literal|"LEVEL "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL_IFACE LEVEL %s"
argument_list|,
name|buf
operator|+
literal|6
argument_list|)
expr_stmt|;
name|dst
operator|->
name|debug_level
operator|=
name|atoi
argument_list|(
name|buf
operator|+
literal|6
argument_list|)
expr_stmt|;
name|reply_len
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|reply
operator|=
name|wpa_supplicant_ctrl_iface_process
argument_list|(
name|wpa_s
argument_list|,
name|buf
argument_list|,
operator|&
name|reply_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reply
condition|)
block|{
name|send_buf
operator|=
name|reply
expr_stmt|;
name|send_len
operator|=
name|reply_len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reply_len
operator|==
literal|2
condition|)
block|{
name|send_buf
operator|=
literal|"OK\n"
expr_stmt|;
name|send_len
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|send_buf
operator|=
literal|"FAIL\n"
expr_stmt|;
name|send_len
operator|=
literal|5
expr_stmt|;
block|}
name|os_free
argument_list|(
name|dst
operator|->
name|rsp_buf
argument_list|)
expr_stmt|;
name|dst
operator|->
name|rsp_buf
operator|=
name|os_malloc
argument_list|(
name|send_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|rsp_buf
operator|==
name|NULL
condition|)
block|{
name|ctrl_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return;
block|}
name|os_memcpy
argument_list|(
name|dst
operator|->
name|rsp_buf
argument_list|,
name|send_buf
argument_list|,
name|send_len
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WriteFileEx
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
name|dst
operator|->
name|rsp_buf
argument_list|,
name|send_len
argument_list|,
operator|&
name|dst
operator|->
name|overlap
argument_list|,
name|ctrl_iface_write_completed
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: WriteFileEx failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|ctrl_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: Overlapped write started for %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_attached
condition|)
name|eapol_sm_notify_ctrl_attached
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|WINAPI
name|ctrl_iface_read_completed
parameter_list|(
name|DWORD
name|err
parameter_list|,
name|DWORD
name|bytes
parameter_list|,
name|LPOVERLAPPED
name|overlap
parameter_list|)
block|{
name|struct
name|wpa_ctrl_dst
modifier|*
name|dst
init|=
operator|(
expr|struct
name|wpa_ctrl_dst
operator|*
operator|)
name|overlap
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: Overlapped read completed: dst=%p err=%d "
literal|"bytes=%d"
argument_list|,
name|dst
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|,
operator|(
name|int
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|bytes
operator|>
literal|0
condition|)
name|wpa_supplicant_ctrl_iface_rx
argument_list|(
name|dst
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_ctrl_iface_receive
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
block|{
name|struct
name|wpa_ctrl_dst
modifier|*
name|dst
init|=
name|eloop_data
decl_stmt|;
name|struct
name|ctrl_iface_priv
modifier|*
name|priv
init|=
name|dst
operator|->
name|priv
decl_stmt|;
name|DWORD
name|bytes
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: wpa_supplicant_ctrl_iface_receive"
argument_list|)
expr_stmt|;
name|ResetEvent
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetOverlappedResult
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
operator|&
name|dst
operator|->
name|overlap
argument_list|,
operator|&
name|bytes
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: GetOverlappedResult failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: GetOverlappedResult: New client "
literal|"connected"
argument_list|)
expr_stmt|;
comment|/* Open a new named pipe for the next client. */
name|ctrl_open_pipe
argument_list|(
name|priv
argument_list|)
expr_stmt|;
comment|/* Use write completion function to start reading a command */
name|ctrl_iface_write_completed
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|dst
operator|->
name|overlap
argument_list|)
expr_stmt|;
name|ctrl_flush_broken_pipes
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctrl_iface_parse
parameter_list|(
name|struct
name|ctrl_iface_priv
modifier|*
name|priv
parameter_list|,
specifier|const
name|char
modifier|*
name|params
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sddl
init|=
name|NULL
decl_stmt|;
name|TCHAR
modifier|*
name|t_sddl
decl_stmt|;
if|if
condition|(
name|os_strncmp
argument_list|(
name|params
argument_list|,
literal|"SDDL="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|sddl
operator|=
name|params
operator|+
literal|5
expr_stmt|;
if|if
condition|(
operator|!
name|sddl
condition|)
block|{
name|sddl
operator|=
name|os_strstr
argument_list|(
name|params
argument_list|,
literal|" SDDL="
argument_list|)
expr_stmt|;
if|if
condition|(
name|sddl
condition|)
name|sddl
operator|+=
literal|6
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sddl
condition|)
return|return
literal|0
return|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: SDDL='%s'"
argument_list|,
name|sddl
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|priv
operator|->
name|attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|attr
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|attr
operator|.
name|nLength
operator|=
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|attr
argument_list|)
expr_stmt|;
name|priv
operator|->
name|attr
operator|.
name|bInheritHandle
operator|=
name|FALSE
expr_stmt|;
name|t_sddl
operator|=
name|wpa_strdup_tchar
argument_list|(
name|sddl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_sddl
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|ConvertStringSecurityDescriptorToSecurityDescriptor
argument_list|(
name|t_sddl
argument_list|,
name|SDDL_REVISION_1
argument_list|,
operator|(
name|PSECURITY_DESCRIPTOR
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|priv
operator|->
name|attr
operator|.
name|lpSecurityDescriptor
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|os_free
argument_list|(
name|t_sddl
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CTRL: SDDL='%s' - could not convert to "
literal|"security descriptor: %d"
argument_list|,
name|sddl
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|os_free
argument_list|(
name|t_sddl
argument_list|)
expr_stmt|;
name|priv
operator|->
name|sec_attr_set
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_ctrl_iface_msg_cb
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|txt
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|ctx
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|==
name|NULL
operator|||
name|wpa_s
operator|->
name|ctrl_iface
operator|==
name|NULL
condition|)
return|return;
name|wpa_supplicant_ctrl_iface_send
argument_list|(
name|wpa_s
operator|->
name|ctrl_iface
argument_list|,
name|level
argument_list|,
name|txt
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ctrl_iface_priv
modifier|*
name|wpa_supplicant_ctrl_iface_init
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|ctrl_iface_priv
modifier|*
name|priv
decl_stmt|;
name|priv
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|priv
operator|->
name|wpa_s
operator|=
name|wpa_s
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|ctrl_interface
operator|==
name|NULL
condition|)
return|return
name|priv
return|;
if|if
condition|(
name|ctrl_iface_parse
argument_list|(
name|priv
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|ctrl_interface
argument_list|)
operator|<
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|priv
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ctrl_open_pipe
argument_list|(
name|priv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|priv
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|wpa_msg_register_cb
argument_list|(
name|wpa_supplicant_ctrl_iface_msg_cb
argument_list|)
expr_stmt|;
return|return
name|priv
return|;
block|}
end_function

begin_function
name|void
name|wpa_supplicant_ctrl_iface_deinit
parameter_list|(
name|struct
name|ctrl_iface_priv
modifier|*
name|priv
parameter_list|)
block|{
while|while
condition|(
name|priv
operator|->
name|ctrl_dst
condition|)
name|ctrl_close_pipe
argument_list|(
name|priv
operator|->
name|ctrl_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|sec_attr_set
condition|)
name|LocalFree
argument_list|(
name|priv
operator|->
name|attr
operator|.
name|lpSecurityDescriptor
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_ctrl_iface_send
parameter_list|(
name|struct
name|ctrl_iface_priv
modifier|*
name|priv
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|wpa_ctrl_dst
modifier|*
name|dst
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
name|levelstr
index|[
literal|10
index|]
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|sbuf
decl_stmt|;
name|int
name|llen
decl_stmt|;
name|DWORD
name|written
decl_stmt|;
name|dst
operator|=
name|priv
operator|->
name|ctrl_dst
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
return|return;
name|os_snprintf
argument_list|(
name|levelstr
argument_list|,
sizeof|sizeof
argument_list|(
name|levelstr
argument_list|)
argument_list|,
literal|"<%d>"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|llen
operator|=
name|os_strlen
argument_list|(
name|levelstr
argument_list|)
expr_stmt|;
name|sbuf
operator|=
name|os_malloc
argument_list|(
name|llen
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf
operator|==
name|NULL
condition|)
return|return;
name|os_memcpy
argument_list|(
name|sbuf
argument_list|,
name|levelstr
argument_list|,
name|llen
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|sbuf
operator|+
name|llen
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dst
condition|)
block|{
name|next
operator|=
name|dst
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|attached
operator|&&
name|level
operator|>=
name|dst
operator|->
name|debug_level
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL_IFACE monitor send %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WriteFile
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
name|sbuf
argument_list|,
name|llen
operator|+
name|len
argument_list|,
operator|&
name|written
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: WriteFile to dst "
literal|"%p failed: %d"
argument_list|,
name|dst
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|dst
operator|->
name|errors
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|errors
operator|>
literal|10
condition|)
name|ctrl_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
name|dst
operator|->
name|errors
operator|=
literal|0
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
name|dst
operator|=
name|next
expr_stmt|;
block|}
name|os_free
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wpa_supplicant_ctrl_iface_wait
parameter_list|(
name|struct
name|ctrl_iface_priv
modifier|*
name|priv
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL_IFACE - %s - wait for monitor"
argument_list|,
name|priv
operator|->
name|wpa_s
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|ctrl_dst
operator|==
name|NULL
condition|)
return|return;
name|WaitForSingleObject
argument_list|(
name|priv
operator|->
name|ctrl_dst
operator|->
name|pipe
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Global ctrl_iface */
end_comment

begin_struct_decl
struct_decl|struct
name|ctrl_iface_global_priv
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|wpa_global_dst
block|{
comment|/* Note: OVERLAPPED must be the first member of struct wpa_global_dst 	 */
name|OVERLAPPED
name|overlap
decl_stmt|;
name|struct
name|wpa_global_dst
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|ctrl_iface_global_priv
modifier|*
name|priv
decl_stmt|;
name|HANDLE
name|pipe
decl_stmt|;
name|char
name|req_buf
index|[
name|REQUEST_BUFSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|rsp_buf
decl_stmt|;
name|int
name|used
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ctrl_iface_global_priv
block|{
name|struct
name|wpa_global
modifier|*
name|global
decl_stmt|;
name|struct
name|wpa_global_dst
modifier|*
name|ctrl_dst
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|global_flush_broken_pipes
parameter_list|(
name|struct
name|ctrl_iface_global_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|wpa_global_dst
modifier|*
name|dst
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dst
operator|=
name|priv
operator|->
name|ctrl_dst
expr_stmt|;
while|while
condition|(
name|dst
condition|)
block|{
name|next
operator|=
name|dst
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ctrl_broken_pipe
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
name|dst
operator|->
name|used
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: closing broken pipe %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|global_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|global_open_pipe
parameter_list|(
name|struct
name|ctrl_iface_global_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|wpa_global_dst
modifier|*
name|dst
decl_stmt|;
name|DWORD
name|err
decl_stmt|;
name|dst
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: Open pipe %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|->
name|priv
operator|=
name|priv
expr_stmt|;
name|dst
operator|->
name|pipe
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|dst
operator|->
name|overlap
operator|.
name|hEvent
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CTRL: CreateEvent failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|eloop_register_event
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|)
argument_list|,
name|wpa_supplicant_global_iface_receive
argument_list|,
name|dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* TODO: add support for configuring access list for the pipe */
name|dst
operator|->
name|pipe
operator|=
name|CreateNamedPipe
argument_list|(
name|NAMED_PIPE_PREFIX
argument_list|,
name|PIPE_ACCESS_DUPLEX
operator||
name|FILE_FLAG_OVERLAPPED
argument_list|,
name|PIPE_TYPE_MESSAGE
operator||
name|PIPE_READMODE_MESSAGE
operator||
name|PIPE_WAIT
argument_list|,
literal|10
argument_list|,
name|REPLY_BUFSIZE
argument_list|,
name|REQUEST_BUFSIZE
argument_list|,
literal|1000
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|pipe
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CTRL: CreateNamedPipe failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|ConnectNamedPipe
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
operator|&
name|dst
operator|->
name|overlap
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CTRL: ConnectNamedPipe failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|dst
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|ERROR_IO_PENDING
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: ConnectNamedPipe: connection in "
literal|"progress"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_PIPE_CONNECTED
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: ConnectNamedPipe: already "
literal|"connected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SetEvent
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|)
condition|)
break|break;
comment|/* fall through */
default|default:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: ConnectNamedPipe error: %d"
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|dst
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dst
operator|->
name|next
operator|=
name|priv
operator|->
name|ctrl_dst
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|next
condition|)
name|dst
operator|->
name|next
operator|->
name|prev
operator|=
name|dst
expr_stmt|;
name|priv
operator|->
name|ctrl_dst
operator|=
name|dst
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|global_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|global_close_pipe
parameter_list|(
name|struct
name|wpa_global_dst
modifier|*
name|dst
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: close pipe %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
condition|)
block|{
name|eloop_unregister_event
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|)
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|->
name|pipe
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
block|{
comment|/* 		 * Could use FlushFileBuffers() here to guarantee that all data 		 * gets delivered to the client, but that can block, so let's 		 * not do this for now. 		 * FlushFileBuffers(dst->pipe); 		 */
name|CloseHandle
argument_list|(
name|dst
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|->
name|prev
condition|)
name|dst
operator|->
name|prev
operator|->
name|next
operator|=
name|dst
operator|->
name|next
expr_stmt|;
else|else
name|dst
operator|->
name|priv
operator|->
name|ctrl_dst
operator|=
name|dst
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|next
condition|)
name|dst
operator|->
name|next
operator|->
name|prev
operator|=
name|dst
operator|->
name|prev
expr_stmt|;
name|os_free
argument_list|(
name|dst
operator|->
name|rsp_buf
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|WINAPI
name|global_iface_write_completed
parameter_list|(
name|DWORD
name|err
parameter_list|,
name|DWORD
name|bytes
parameter_list|,
name|LPOVERLAPPED
name|overlap
parameter_list|)
block|{
name|struct
name|wpa_global_dst
modifier|*
name|dst
init|=
operator|(
expr|struct
name|wpa_global_dst
operator|*
operator|)
name|overlap
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: Overlapped write completed: dst=%p "
literal|"err=%d bytes=%d"
argument_list|,
name|dst
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|,
operator|(
name|int
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|global_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
name|os_free
argument_list|(
name|dst
operator|->
name|rsp_buf
argument_list|)
expr_stmt|;
name|dst
operator|->
name|rsp_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ReadFileEx
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
name|dst
operator|->
name|req_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
operator|->
name|req_buf
argument_list|)
argument_list|,
operator|&
name|dst
operator|->
name|overlap
argument_list|,
name|global_iface_read_completed
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: ReadFileEx failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|global_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* FIX: if this was the pipe waiting for new global 		 * connections, at this point there are no open global pipes.. 		 * Should try to open a new pipe.. */
return|return;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: Overlapped read started for %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_global_iface_rx
parameter_list|(
name|struct
name|wpa_global_dst
modifier|*
name|dst
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|wpa_global
modifier|*
name|global
init|=
name|dst
operator|->
name|priv
operator|->
name|global
decl_stmt|;
name|char
modifier|*
name|reply
init|=
name|NULL
decl_stmt|,
modifier|*
name|send_buf
decl_stmt|;
name|size_t
name|reply_len
init|=
literal|0
decl_stmt|,
name|send_len
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|dst
operator|->
name|req_buf
decl_stmt|;
name|dst
operator|->
name|used
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|REQUEST_BUFSIZE
condition|)
name|len
operator|=
name|REQUEST_BUFSIZE
operator|-
literal|1
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|reply
operator|=
name|wpa_supplicant_global_ctrl_iface_process
argument_list|(
name|global
argument_list|,
name|buf
argument_list|,
operator|&
name|reply_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
name|send_buf
operator|=
name|reply
expr_stmt|;
name|send_len
operator|=
name|reply_len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reply_len
condition|)
block|{
name|send_buf
operator|=
literal|"FAIL\n"
expr_stmt|;
name|send_len
operator|=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|os_free
argument_list|(
name|dst
operator|->
name|rsp_buf
argument_list|)
expr_stmt|;
name|dst
operator|->
name|rsp_buf
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|os_free
argument_list|(
name|dst
operator|->
name|rsp_buf
argument_list|)
expr_stmt|;
name|dst
operator|->
name|rsp_buf
operator|=
name|os_malloc
argument_list|(
name|send_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|rsp_buf
operator|==
name|NULL
condition|)
block|{
name|global_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return;
block|}
name|os_memcpy
argument_list|(
name|dst
operator|->
name|rsp_buf
argument_list|,
name|send_buf
argument_list|,
name|send_len
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WriteFileEx
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
name|dst
operator|->
name|rsp_buf
argument_list|,
name|send_len
argument_list|,
operator|&
name|dst
operator|->
name|overlap
argument_list|,
name|global_iface_write_completed
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: WriteFileEx failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|global_close_pipe
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: Overlapped write started for %p"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|VOID
name|WINAPI
name|global_iface_read_completed
parameter_list|(
name|DWORD
name|err
parameter_list|,
name|DWORD
name|bytes
parameter_list|,
name|LPOVERLAPPED
name|overlap
parameter_list|)
block|{
name|struct
name|wpa_global_dst
modifier|*
name|dst
init|=
operator|(
expr|struct
name|wpa_global_dst
operator|*
operator|)
name|overlap
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: Overlapped read completed: dst=%p err=%d "
literal|"bytes=%d"
argument_list|,
name|dst
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|,
operator|(
name|int
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|bytes
operator|>
literal|0
condition|)
name|wpa_supplicant_global_iface_rx
argument_list|(
name|dst
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_global_iface_receive
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
block|{
name|struct
name|wpa_global_dst
modifier|*
name|dst
init|=
name|eloop_data
decl_stmt|;
name|struct
name|ctrl_iface_global_priv
modifier|*
name|priv
init|=
name|dst
operator|->
name|priv
decl_stmt|;
name|DWORD
name|bytes
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: wpa_supplicant_global_iface_receive"
argument_list|)
expr_stmt|;
name|ResetEvent
argument_list|(
name|dst
operator|->
name|overlap
operator|.
name|hEvent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetOverlappedResult
argument_list|(
name|dst
operator|->
name|pipe
argument_list|,
operator|&
name|dst
operator|->
name|overlap
argument_list|,
operator|&
name|bytes
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: GetOverlappedResult failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: GetOverlappedResult: New client "
literal|"connected"
argument_list|)
expr_stmt|;
comment|/* Open a new named pipe for the next client. */
if|if
condition|(
name|global_open_pipe
argument_list|(
name|priv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CTRL: global_open_pipe failed"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Use write completion function to start reading a command */
name|global_iface_write_completed
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|dst
operator|->
name|overlap
argument_list|)
expr_stmt|;
name|global_flush_broken_pipes
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ctrl_iface_global_priv
modifier|*
name|wpa_supplicant_global_ctrl_iface_init
parameter_list|(
name|struct
name|wpa_global
modifier|*
name|global
parameter_list|)
block|{
name|struct
name|ctrl_iface_global_priv
modifier|*
name|priv
decl_stmt|;
name|priv
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|priv
operator|->
name|global
operator|=
name|global
expr_stmt|;
if|if
condition|(
name|global_open_pipe
argument_list|(
name|priv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|priv
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|priv
return|;
block|}
end_function

begin_function
name|void
name|wpa_supplicant_global_ctrl_iface_deinit
parameter_list|(
name|struct
name|ctrl_iface_global_priv
modifier|*
name|priv
parameter_list|)
block|{
while|while
condition|(
name|priv
operator|->
name|ctrl_dst
condition|)
name|global_close_pipe
argument_list|(
name|priv
operator|->
name|ctrl_dst
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

