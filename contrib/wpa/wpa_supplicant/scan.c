begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant - Scanning  * Copyright (c) 2003-2014, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"utils/includes.h"
end_include

begin_include
include|#
directive|include
file|"utils/common.h"
end_include

begin_include
include|#
directive|include
file|"utils/eloop.h"
end_include

begin_include
include|#
directive|include
file|"common/ieee802_11_defs.h"
end_include

begin_include
include|#
directive|include
file|"common/wpa_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"wpa_supplicant_i.h"
end_include

begin_include
include|#
directive|include
file|"driver_i.h"
end_include

begin_include
include|#
directive|include
file|"wps_supplicant.h"
end_include

begin_include
include|#
directive|include
file|"p2p_supplicant.h"
end_include

begin_include
include|#
directive|include
file|"p2p/p2p.h"
end_include

begin_include
include|#
directive|include
file|"hs20_supplicant.h"
end_include

begin_include
include|#
directive|include
file|"notify.h"
end_include

begin_include
include|#
directive|include
file|"bss.h"
end_include

begin_include
include|#
directive|include
file|"scan.h"
end_include

begin_include
include|#
directive|include
file|"mesh.h"
end_include

begin_function
specifier|static
name|void
name|wpa_supplicant_gen_assoc_event
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|ssid
decl_stmt|;
name|union
name|wpa_event_data
name|data
decl_stmt|;
name|ssid
operator|=
name|wpa_supplicant_get_ssid
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssid
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|wpa_s
operator|->
name|current_ssid
operator|==
name|NULL
condition|)
block|{
name|wpa_s
operator|->
name|current_ssid
operator|=
name|ssid
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|current_ssid
operator|!=
name|NULL
condition|)
name|wpas_notify_network_changed
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
block|}
name|wpa_supplicant_initiate_eapol
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Already associated with a configured "
literal|"network - generating associated event"
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_supplicant_event
argument_list|(
name|wpa_s
argument_list|,
name|EVENT_ASSOC
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_WPS
end_ifdef

begin_function
specifier|static
name|int
name|wpas_wps_in_use
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|enum
name|wps_request_type
modifier|*
name|req_type
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|ssid
decl_stmt|;
name|int
name|wps
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
init|;
name|ssid
condition|;
name|ssid
operator|=
name|ssid
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ssid
operator|->
name|key_mgmt
operator|&
name|WPA_KEY_MGMT_WPS
operator|)
condition|)
continue|continue;
name|wps
operator|=
literal|1
expr_stmt|;
operator|*
name|req_type
operator|=
name|wpas_wps_get_req_type
argument_list|(
name|ssid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssid
operator|->
name|eap
operator|.
name|phase1
condition|)
continue|continue;
if|if
condition|(
name|os_strstr
argument_list|(
name|ssid
operator|->
name|eap
operator|.
name|phase1
argument_list|,
literal|"pbc=1"
argument_list|)
condition|)
return|return
literal|2
return|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_P2P
if|if
condition|(
operator|!
name|wpa_s
operator|->
name|global
operator|->
name|p2p_disabled
operator|&&
name|wpa_s
operator|->
name|global
operator|->
name|p2p
operator|&&
operator|!
name|wpa_s
operator|->
name|conf
operator|->
name|p2p_disabled
condition|)
block|{
name|wpa_s
operator|->
name|wps
operator|->
name|dev
operator|.
name|p2p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|wps
condition|)
block|{
name|wps
operator|=
literal|1
expr_stmt|;
operator|*
name|req_type
operator|=
name|WPS_REQ_ENROLLEE_INFO
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CONFIG_P2P */
return|return
name|wps
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_WPS */
end_comment

begin_comment
comment|/**  * wpa_supplicant_enabled_networks - Check whether there are enabled networks  * @wpa_s: Pointer to wpa_supplicant data  * Returns: 0 if no networks are enabled,>0 if networks are enabled  *  * This function is used to figure out whether any networks (or Interworking  * with enabled credentials and auto_interworking) are present in the current  * configuration.  */
end_comment

begin_function
name|int
name|wpa_supplicant_enabled_networks
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|ssid
init|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|disabled
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|p2p_mgmt
condition|)
return|return
literal|0
return|;
comment|/* no normal network profiles on p2p_mgmt interface */
while|while
condition|(
name|ssid
condition|)
block|{
if|if
condition|(
operator|!
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
else|else
name|disabled
operator|++
expr_stmt|;
name|ssid
operator|=
name|ssid
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|cred
operator|&&
name|wpa_s
operator|->
name|conf
operator|->
name|interworking
operator|&&
name|wpa_s
operator|->
name|conf
operator|->
name|auto_interworking
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|disabled
operator|>
literal|0
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"No enabled networks (%d disabled "
literal|"networks)"
argument_list|,
name|disabled
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_assoc_try
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|)
block|{
while|while
condition|(
name|ssid
condition|)
block|{
if|if
condition|(
operator|!
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
condition|)
break|break;
name|ssid
operator|=
name|ssid
operator|->
name|next
expr_stmt|;
block|}
comment|/* ap_scan=2 mode - try to associate with each SSID. */
if|if
condition|(
name|ssid
operator|==
name|NULL
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"wpa_supplicant_assoc_try: Reached "
literal|"end of scan list - go back to beginning"
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|prev_scan_ssid
operator|=
name|WILDCARD_SSID_SCAN
expr_stmt|;
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ssid
operator|->
name|next
condition|)
block|{
comment|/* Continue from the next SSID on the next attempt. */
name|wpa_s
operator|->
name|prev_scan_ssid
operator|=
name|ssid
expr_stmt|;
block|}
else|else
block|{
comment|/* Start from the beginning of the SSID list. */
name|wpa_s
operator|->
name|prev_scan_ssid
operator|=
name|WILDCARD_SSID_SCAN
expr_stmt|;
block|}
name|wpa_supplicant_associate
argument_list|(
name|wpa_s
argument_list|,
name|NULL
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpas_trigger_scan_cb
parameter_list|(
name|struct
name|wpa_radio_work
modifier|*
name|work
parameter_list|,
name|int
name|deinit
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|work
operator|->
name|wpa_s
decl_stmt|;
name|struct
name|wpa_driver_scan_params
modifier|*
name|params
init|=
name|work
operator|->
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|deinit
condition|)
block|{
if|if
condition|(
operator|!
name|work
operator|->
name|started
condition|)
block|{
name|wpa_scan_free_params
argument_list|(
name|params
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_supplicant_notify_scanning
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpas_notify_scan_done
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|scan_work
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wpas_update_random_addr_disassoc
argument_list|(
name|wpa_s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"Failed to assign random MAC address for a scan"
argument_list|)
expr_stmt|;
name|radio_work_done
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_supplicant_notify_scanning
argument_list|(
name|wpa_s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|clear_driver_scan_cache
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Request driver to clear scan cache due to local BSS flush"
argument_list|)
expr_stmt|;
name|params
operator|->
name|only_new_results
operator|=
literal|1
expr_stmt|;
block|}
name|ret
operator|=
name|wpa_drv_scan
argument_list|(
name|wpa_s
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|wpa_scan_free_params
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|work
operator|->
name|ctx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|int
name|retry
init|=
name|wpa_s
operator|->
name|last_scan_req
operator|!=
name|MANUAL_SCAN_REQ
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|disconnected
condition|)
name|retry
operator|=
literal|0
expr_stmt|;
name|wpa_supplicant_notify_scanning
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpas_notify_scan_done
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|wpa_state
operator|==
name|WPA_SCANNING
condition|)
name|wpa_supplicant_set_state
argument_list|(
name|wpa_s
argument_list|,
name|wpa_s
operator|->
name|scan_prev_wpa_state
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_SCAN_FAILED
literal|"ret=%d%s"
argument_list|,
name|ret
argument_list|,
name|retry
condition|?
literal|" retry=1"
else|:
literal|""
argument_list|)
expr_stmt|;
name|radio_work_done
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
condition|)
block|{
comment|/* Restore scan_req since we will try to scan again */
name|wpa_s
operator|->
name|scan_req
operator|=
name|wpa_s
operator|->
name|last_scan_req
expr_stmt|;
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|os_get_reltime
argument_list|(
operator|&
name|wpa_s
operator|->
name|scan_trigger_time
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|scan_runs
operator|++
expr_stmt|;
name|wpa_s
operator|->
name|normal_scans
operator|++
expr_stmt|;
name|wpa_s
operator|->
name|own_scan_requested
operator|=
literal|1
expr_stmt|;
name|wpa_s
operator|->
name|clear_driver_scan_cache
operator|=
literal|0
expr_stmt|;
name|wpa_s
operator|->
name|scan_work
operator|=
name|work
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_trigger_scan - Request driver to start a scan  * @wpa_s: Pointer to wpa_supplicant data  * @params: Scan parameters  * Returns: 0 on success, -1 on failure  */
end_comment

begin_function
name|int
name|wpa_supplicant_trigger_scan
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_driver_scan_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|wpa_driver_scan_params
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|scan_work
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"Reject scan trigger since one is already pending"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ctx
operator|=
name|wpa_scan_clone_params
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|radio_add_work
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|,
literal|"scan"
argument_list|,
literal|0
argument_list|,
name|wpas_trigger_scan_cb
argument_list|,
name|ctx
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_scan_free_params
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_delayed_sched_scan_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|eloop_ctx
decl_stmt|;
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Starting delayed sched scan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_supplicant_req_sched_scan
argument_list|(
name|wpa_s
argument_list|)
condition|)
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_sched_scan_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|eloop_ctx
decl_stmt|;
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Sched scan timeout - stopping it"
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|sched_scan_timed_out
operator|=
literal|1
expr_stmt|;
name|wpa_supplicant_cancel_sched_scan
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|wpa_supplicant_start_sched_scan
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_driver_scan_params
modifier|*
name|params
parameter_list|,
name|int
name|interval
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|wpa_supplicant_notify_scanning
argument_list|(
name|wpa_s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|wpa_drv_sched_scan
argument_list|(
name|wpa_s
argument_list|,
name|params
argument_list|,
name|interval
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|wpa_supplicant_notify_scanning
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|wpa_s
operator|->
name|sched_scanning
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|wpa_supplicant_stop_sched_scan
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|wpa_drv_stop_sched_scan
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"stopping sched_scan failed!"
argument_list|)
expr_stmt|;
comment|/* TODO: what to do if stopping fails? */
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpa_driver_scan_filter
modifier|*
name|wpa_supplicant_build_filter_ssids
parameter_list|(
name|struct
name|wpa_config
modifier|*
name|conf
parameter_list|,
name|size_t
modifier|*
name|num_ssids
parameter_list|)
block|{
name|struct
name|wpa_driver_scan_filter
modifier|*
name|ssids
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|ssid
decl_stmt|;
name|size_t
name|count
decl_stmt|;
operator|*
name|num_ssids
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|conf
operator|->
name|filter_ssids
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|ssid
operator|=
name|conf
operator|->
name|ssid
init|;
name|ssid
condition|;
name|ssid
operator|=
name|ssid
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ssid
operator|->
name|ssid
operator|&&
name|ssid
operator|->
name|ssid_len
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|ssids
operator|=
name|os_calloc
argument_list|(
name|count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpa_driver_scan_filter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssids
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|ssid
operator|=
name|conf
operator|->
name|ssid
init|;
name|ssid
condition|;
name|ssid
operator|=
name|ssid
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ssid
operator|->
name|ssid
operator|||
operator|!
name|ssid
operator|->
name|ssid_len
condition|)
continue|continue;
name|os_memcpy
argument_list|(
name|ssids
index|[
operator|*
name|num_ssids
index|]
operator|.
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|ssids
index|[
operator|*
name|num_ssids
index|]
operator|.
name|ssid_len
operator|=
name|ssid
operator|->
name|ssid_len
expr_stmt|;
operator|(
operator|*
name|num_ssids
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|ssids
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_optimize_freqs
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_driver_scan_params
modifier|*
name|params
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_P2P
if|if
condition|(
name|params
operator|->
name|freqs
operator|==
name|NULL
operator|&&
name|wpa_s
operator|->
name|p2p_in_provisioning
operator|&&
name|wpa_s
operator|->
name|go_params
condition|)
block|{
comment|/* Optimize provisioning state scan based on GO information */
if|if
condition|(
name|wpa_s
operator|->
name|p2p_in_provisioning
operator|<
literal|5
operator|&&
name|wpa_s
operator|->
name|go_params
operator|->
name|freq
operator|>
literal|0
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"P2P: Scan only GO "
literal|"preferred frequency %d MHz"
argument_list|,
name|wpa_s
operator|->
name|go_params
operator|->
name|freq
argument_list|)
expr_stmt|;
name|params
operator|->
name|freqs
operator|=
name|os_calloc
argument_list|(
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|freqs
condition|)
name|params
operator|->
name|freqs
index|[
literal|0
index|]
operator|=
name|wpa_s
operator|->
name|go_params
operator|->
name|freq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wpa_s
operator|->
name|p2p_in_provisioning
operator|<
literal|8
operator|&&
name|wpa_s
operator|->
name|go_params
operator|->
name|freq_list
index|[
literal|0
index|]
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"P2P: Scan only common "
literal|"channels"
argument_list|)
expr_stmt|;
name|int_array_concat
argument_list|(
operator|&
name|params
operator|->
name|freqs
argument_list|,
name|wpa_s
operator|->
name|go_params
operator|->
name|freq_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|freqs
condition|)
name|int_array_sort_unique
argument_list|(
name|params
operator|->
name|freqs
argument_list|)
expr_stmt|;
block|}
name|wpa_s
operator|->
name|p2p_in_provisioning
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|freqs
operator|==
name|NULL
operator|&&
name|wpa_s
operator|->
name|p2p_in_invitation
condition|)
block|{
comment|/* 		 * Optimize scan based on GO information during persistent 		 * group reinvocation 		 */
if|if
condition|(
name|wpa_s
operator|->
name|p2p_in_invitation
operator|<
literal|5
operator|&&
name|wpa_s
operator|->
name|p2p_invite_go_freq
operator|>
literal|0
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"P2P: Scan only GO preferred frequency %d MHz during invitation"
argument_list|,
name|wpa_s
operator|->
name|p2p_invite_go_freq
argument_list|)
expr_stmt|;
name|params
operator|->
name|freqs
operator|=
name|os_calloc
argument_list|(
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|freqs
condition|)
name|params
operator|->
name|freqs
index|[
literal|0
index|]
operator|=
name|wpa_s
operator|->
name|p2p_invite_go_freq
expr_stmt|;
block|}
name|wpa_s
operator|->
name|p2p_in_invitation
operator|++
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|p2p_in_invitation
operator|>
literal|20
condition|)
block|{
comment|/* 			 * This should not really happen since the variable is 			 * cleared on group removal, but if it does happen, make 			 * sure we do not get stuck in special invitation scan 			 * mode. 			 */
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"P2P: Clear p2p_in_invitation"
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|p2p_in_invitation
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CONFIG_P2P */
ifdef|#
directive|ifdef
name|CONFIG_WPS
if|if
condition|(
name|params
operator|->
name|freqs
operator|==
name|NULL
operator|&&
name|wpa_s
operator|->
name|after_wps
operator|&&
name|wpa_s
operator|->
name|wps_freq
condition|)
block|{
comment|/* 		 * Optimize post-provisioning scan based on channel used 		 * during provisioning. 		 */
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPS: Scan only frequency %u MHz "
literal|"that was used during provisioning"
argument_list|,
name|wpa_s
operator|->
name|wps_freq
argument_list|)
expr_stmt|;
name|params
operator|->
name|freqs
operator|=
name|os_calloc
argument_list|(
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|freqs
condition|)
name|params
operator|->
name|freqs
index|[
literal|0
index|]
operator|=
name|wpa_s
operator|->
name|wps_freq
expr_stmt|;
name|wpa_s
operator|->
name|after_wps
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wpa_s
operator|->
name|after_wps
condition|)
name|wpa_s
operator|->
name|after_wps
operator|--
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|freqs
operator|==
name|NULL
operator|&&
name|wpa_s
operator|->
name|known_wps_freq
operator|&&
name|wpa_s
operator|->
name|wps_freq
condition|)
block|{
comment|/* Optimize provisioning scan based on already known channel */
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPS: Scan only frequency %u MHz"
argument_list|,
name|wpa_s
operator|->
name|wps_freq
argument_list|)
expr_stmt|;
name|params
operator|->
name|freqs
operator|=
name|os_calloc
argument_list|(
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|freqs
condition|)
name|params
operator|->
name|freqs
index|[
literal|0
index|]
operator|=
name|wpa_s
operator|->
name|wps_freq
expr_stmt|;
name|wpa_s
operator|->
name|known_wps_freq
operator|=
literal|0
expr_stmt|;
comment|/* only do this once */
block|}
endif|#
directive|endif
comment|/* CONFIG_WPS */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_INTERWORKING
end_ifdef

begin_function
specifier|static
name|void
name|wpas_add_interworking_elements
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|)
block|{
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|WLAN_EID_INTERWORKING
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|is_zero_ether_addr
argument_list|(
name|wpa_s
operator|->
name|conf
operator|->
name|hessid
argument_list|)
condition|?
literal|1
else|:
literal|1
operator|+
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|access_network_type
argument_list|)
expr_stmt|;
comment|/* No Venue Info */
if|if
condition|(
operator|!
name|is_zero_ether_addr
argument_list|(
name|wpa_s
operator|->
name|conf
operator|->
name|hessid
argument_list|)
condition|)
name|wpabuf_put_data
argument_list|(
name|buf
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|hessid
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_INTERWORKING */
end_comment

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|wpa_supplicant_extra_ies
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|extra_ie
init|=
name|NULL
decl_stmt|;
name|u8
name|ext_capab
index|[
literal|18
index|]
decl_stmt|;
name|int
name|ext_capab_len
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_WPS
name|int
name|wps
init|=
literal|0
decl_stmt|;
name|enum
name|wps_request_type
name|req_type
init|=
name|WPS_REQ_ENROLLEE_INFO
decl_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WPS */
name|ext_capab_len
operator|=
name|wpas_build_ext_capab
argument_list|(
name|wpa_s
argument_list|,
name|ext_capab
argument_list|,
sizeof|sizeof
argument_list|(
name|ext_capab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_capab_len
operator|>
literal|0
operator|&&
name|wpabuf_resize
argument_list|(
operator|&
name|extra_ie
argument_list|,
name|ext_capab_len
argument_list|)
operator|==
literal|0
condition|)
name|wpabuf_put_data
argument_list|(
name|extra_ie
argument_list|,
name|ext_capab
argument_list|,
name|ext_capab_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_INTERWORKING
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|interworking
operator|&&
name|wpabuf_resize
argument_list|(
operator|&
name|extra_ie
argument_list|,
literal|100
argument_list|)
operator|==
literal|0
condition|)
name|wpas_add_interworking_elements
argument_list|(
name|wpa_s
argument_list|,
name|extra_ie
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_INTERWORKING */
ifdef|#
directive|ifdef
name|CONFIG_WPS
name|wps
operator|=
name|wpas_wps_in_use
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|req_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|wps
condition|)
block|{
name|struct
name|wpabuf
modifier|*
name|wps_ie
decl_stmt|;
name|wps_ie
operator|=
name|wps_build_probe_req_ie
argument_list|(
name|wps
operator|==
literal|2
condition|?
name|DEV_PW_PUSHBUTTON
else|:
name|DEV_PW_DEFAULT
argument_list|,
operator|&
name|wpa_s
operator|->
name|wps
operator|->
name|dev
argument_list|,
name|wpa_s
operator|->
name|wps
operator|->
name|uuid
argument_list|,
name|req_type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|wps_ie
condition|)
block|{
if|if
condition|(
name|wpabuf_resize
argument_list|(
operator|&
name|extra_ie
argument_list|,
name|wpabuf_len
argument_list|(
name|wps_ie
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|wpabuf_put_buf
argument_list|(
name|extra_ie
argument_list|,
name|wps_ie
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|wps_ie
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|CONFIG_P2P
if|if
condition|(
name|wps
condition|)
block|{
name|size_t
name|ielen
init|=
name|p2p_scan_ie_buf_len
argument_list|(
name|wpa_s
operator|->
name|global
operator|->
name|p2p
argument_list|)
decl_stmt|;
if|if
condition|(
name|wpabuf_resize
argument_list|(
operator|&
name|extra_ie
argument_list|,
name|ielen
argument_list|)
operator|==
literal|0
condition|)
name|wpas_p2p_scan_ie
argument_list|(
name|wpa_s
argument_list|,
name|extra_ie
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CONFIG_P2P */
name|wpa_supplicant_mesh_add_scan_ie
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|extra_ie
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WPS */
ifdef|#
directive|ifdef
name|CONFIG_HS20
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|hs20
operator|&&
name|wpabuf_resize
argument_list|(
operator|&
name|extra_ie
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|wpas_hs20_add_indication
argument_list|(
name|extra_ie
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_HS20 */
ifdef|#
directive|ifdef
name|CONFIG_FST
if|if
condition|(
name|wpa_s
operator|->
name|fst_ies
operator|&&
name|wpabuf_resize
argument_list|(
operator|&
name|extra_ie
argument_list|,
name|wpabuf_len
argument_list|(
name|wpa_s
operator|->
name|fst_ies
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|wpabuf_put_buf
argument_list|(
name|extra_ie
argument_list|,
name|wpa_s
operator|->
name|fst_ies
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_FST */
return|return
name|extra_ie
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_P2P
end_ifdef

begin_comment
comment|/*  * Check whether there are any enabled networks or credentials that could be  * used for a non-P2P connection.  */
end_comment

begin_function
specifier|static
name|int
name|non_p2p_network_enabled
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|ssid
decl_stmt|;
for|for
control|(
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
init|;
name|ssid
condition|;
name|ssid
operator|=
name|ssid
operator|->
name|next
control|)
block|{
if|if
condition|(
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ssid
operator|->
name|p2p_group
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|cred
operator|&&
name|wpa_s
operator|->
name|conf
operator|->
name|interworking
operator|&&
name|wpa_s
operator|->
name|conf
operator|->
name|auto_interworking
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_P2P */
end_comment

begin_function
specifier|static
name|struct
name|hostapd_hw_modes
modifier|*
name|get_mode
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|modes
parameter_list|,
name|u16
name|num_modes
parameter_list|,
name|enum
name|hostapd_hw_mode
name|mode
parameter_list|)
block|{
name|u16
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_modes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|modes
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|mode
condition|)
return|return
operator|&
name|modes
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_setband_scan_freqs_list
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|enum
name|hostapd_hw_mode
name|band
parameter_list|,
name|struct
name|wpa_driver_scan_params
modifier|*
name|params
parameter_list|)
block|{
comment|/* Include only supported channels for the specified band */
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|mode
operator|=
name|get_mode
argument_list|(
name|wpa_s
operator|->
name|hw
operator|.
name|modes
argument_list|,
name|wpa_s
operator|->
name|hw
operator|.
name|num_modes
argument_list|,
name|band
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|NULL
condition|)
block|{
comment|/* No channels supported in this band - use empty list */
name|params
operator|->
name|freqs
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|params
operator|->
name|freqs
operator|=
name|os_calloc
argument_list|(
name|mode
operator|->
name|num_channels
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|freqs
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mode
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|HOSTAPD_CHAN_DISABLED
condition|)
continue|continue;
name|params
operator|->
name|freqs
index|[
name|count
operator|++
index|]
operator|=
name|mode
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|freq
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_setband_scan_freqs
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_driver_scan_params
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
name|wpa_s
operator|->
name|hw
operator|.
name|modes
operator|==
name|NULL
condition|)
return|return;
comment|/* unknown what channels the driver supports */
if|if
condition|(
name|params
operator|->
name|freqs
condition|)
return|return;
comment|/* already using a limited channel set */
if|if
condition|(
name|wpa_s
operator|->
name|setband
operator|==
name|WPA_SETBAND_5G
condition|)
name|wpa_setband_scan_freqs_list
argument_list|(
name|wpa_s
argument_list|,
name|HOSTAPD_MODE_IEEE80211A
argument_list|,
name|params
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wpa_s
operator|->
name|setband
operator|==
name|WPA_SETBAND_2G
condition|)
name|wpa_setband_scan_freqs_list
argument_list|(
name|wpa_s
argument_list|,
name|HOSTAPD_MODE_IEEE80211G
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_set_scan_ssids
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_driver_scan_params
modifier|*
name|params
parameter_list|,
name|size_t
name|max_ssids
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|ssid
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wpa_s
operator|->
name|scan_id_count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|ssid
operator|=
name|wpa_config_get_network
argument_list|(
name|wpa_s
operator|->
name|conf
argument_list|,
name|wpa_s
operator|->
name|scan_id
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssid
operator|||
operator|!
name|ssid
operator|->
name|scan_ssid
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|params
operator|->
name|num_ssids
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|params
operator|->
name|ssids
index|[
name|j
index|]
operator|.
name|ssid_len
operator|==
name|ssid
operator|->
name|ssid_len
operator|&&
name|params
operator|->
name|ssids
index|[
name|j
index|]
operator|.
name|ssid
operator|&&
name|os_memcmp
argument_list|(
name|params
operator|->
name|ssids
index|[
name|j
index|]
operator|.
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|<
name|params
operator|->
name|num_ssids
condition|)
continue|continue;
comment|/* already in the list */
if|if
condition|(
name|params
operator|->
name|num_ssids
operator|+
literal|1
operator|>
name|max_ssids
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Over max scan SSIDs for manual request"
argument_list|)
expr_stmt|;
break|break;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Scan SSID (manual request): %s"
argument_list|,
name|wpa_ssid_txt
argument_list|(
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|->
name|ssids
index|[
name|params
operator|->
name|num_ssids
index|]
operator|.
name|ssid
operator|=
name|ssid
operator|->
name|ssid
expr_stmt|;
name|params
operator|->
name|ssids
index|[
name|params
operator|->
name|num_ssids
index|]
operator|.
name|ssid_len
operator|=
name|ssid
operator|->
name|ssid_len
expr_stmt|;
name|params
operator|->
name|num_ssids
operator|++
expr_stmt|;
block|}
name|wpa_s
operator|->
name|scan_id_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpa_set_ssids_from_scan_req
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_driver_scan_params
modifier|*
name|params
parameter_list|,
name|size_t
name|max_ssids
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|ssids_from_scan_req
operator|==
name|NULL
operator|||
name|wpa_s
operator|->
name|num_ssids_from_scan_req
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|wpa_s
operator|->
name|num_ssids_from_scan_req
operator|>
name|max_ssids
condition|)
block|{
name|wpa_s
operator|->
name|num_ssids_from_scan_req
operator|=
name|max_ssids
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Over max scan SSIDs from scan req: %u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|max_ssids
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wpa_s
operator|->
name|num_ssids_from_scan_req
condition|;
name|i
operator|++
control|)
block|{
name|params
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid
operator|=
name|wpa_s
operator|->
name|ssids_from_scan_req
index|[
name|i
index|]
operator|.
name|ssid
expr_stmt|;
name|params
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid_len
operator|=
name|wpa_s
operator|->
name|ssids_from_scan_req
index|[
name|i
index|]
operator|.
name|ssid_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"specific SSID"
argument_list|,
name|params
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid
argument_list|,
name|params
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid_len
argument_list|)
expr_stmt|;
block|}
name|params
operator|->
name|num_ssids
operator|=
name|wpa_s
operator|->
name|num_ssids_from_scan_req
expr_stmt|;
name|wpa_s
operator|->
name|num_ssids_from_scan_req
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_scan
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|eloop_ctx
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|ssid
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|p2p_in_prog
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|extra_ie
init|=
name|NULL
decl_stmt|;
name|struct
name|wpa_driver_scan_params
name|params
decl_stmt|;
name|struct
name|wpa_driver_scan_params
modifier|*
name|scan_params
decl_stmt|;
name|size_t
name|max_ssids
decl_stmt|;
name|int
name|connect_without_scan
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|pno
operator|||
name|wpa_s
operator|->
name|pno_sched_pending
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Skip scan - PNO is in progress"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|wpa_state
operator|==
name|WPA_INTERFACE_DISABLED
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Skip scan - interface disabled"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|disconnected
operator|&&
name|wpa_s
operator|->
name|scan_req
operator|==
name|NORMAL_SCAN_REQ
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Disconnected - do not scan"
argument_list|)
expr_stmt|;
name|wpa_supplicant_set_state
argument_list|(
name|wpa_s
argument_list|,
name|WPA_DISCONNECTED
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|scanning
condition|)
block|{
comment|/* 		 * If we are already in scanning state, we shall reschedule the 		 * the incoming scan request. 		 */
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Already scanning - Reschedule the incoming scan req"
argument_list|)
expr_stmt|;
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|wpa_supplicant_enabled_networks
argument_list|(
name|wpa_s
argument_list|)
operator|&&
name|wpa_s
operator|->
name|scan_req
operator|==
name|NORMAL_SCAN_REQ
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"No enabled networks - do not scan"
argument_list|)
expr_stmt|;
name|wpa_supplicant_set_state
argument_list|(
name|wpa_s
argument_list|,
name|WPA_INACTIVE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|ap_scan
operator|!=
literal|0
operator|&&
operator|(
name|wpa_s
operator|->
name|drv_flags
operator|&
name|WPA_DRIVER_FLAGS_WIRED
operator|)
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Using wired authentication - "
literal|"overriding ap_scan configuration"
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|conf
operator|->
name|ap_scan
operator|=
literal|0
expr_stmt|;
name|wpas_notify_ap_scan_changed
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|ap_scan
operator|==
literal|0
condition|)
block|{
name|wpa_supplicant_gen_assoc_event
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ssid
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|scan_req
operator|!=
name|MANUAL_SCAN_REQ
operator|&&
name|wpa_s
operator|->
name|connect_without_scan
condition|)
block|{
name|connect_without_scan
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
init|;
name|ssid
condition|;
name|ssid
operator|=
name|ssid
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ssid
operator|==
name|wpa_s
operator|->
name|connect_without_scan
condition|)
break|break;
block|}
block|}
name|p2p_in_prog
operator|=
name|wpas_p2p_in_progress
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_in_prog
operator|&&
name|p2p_in_prog
operator|!=
literal|2
operator|&&
operator|(
operator|!
name|ssid
operator|||
operator|(
name|ssid
operator|->
name|mode
operator|!=
name|WPAS_MODE_AP
operator|&&
name|ssid
operator|->
name|mode
operator|!=
name|WPAS_MODE_P2P_GO
operator|)
operator|)
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Delay station mode scan while P2P operation is in progress"
argument_list|)
expr_stmt|;
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|ap_scan
operator|==
literal|2
condition|)
name|max_ssids
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|max_ssids
operator|=
name|wpa_s
operator|->
name|max_scan_ssids
expr_stmt|;
if|if
condition|(
name|max_ssids
operator|>
name|WPAS_MAX_SCAN_SSIDS
condition|)
name|max_ssids
operator|=
name|WPAS_MAX_SCAN_SSIDS
expr_stmt|;
block|}
name|wpa_s
operator|->
name|last_scan_req
operator|=
name|wpa_s
operator|->
name|scan_req
expr_stmt|;
name|wpa_s
operator|->
name|scan_req
operator|=
name|NORMAL_SCAN_REQ
expr_stmt|;
if|if
condition|(
name|connect_without_scan
condition|)
block|{
name|wpa_s
operator|->
name|connect_without_scan
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ssid
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Start a pre-selected network "
literal|"without scan step"
argument_list|)
expr_stmt|;
name|wpa_supplicant_associate
argument_list|(
name|wpa_s
argument_list|,
name|NULL
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|os_memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|scan_prev_wpa_state
operator|=
name|wpa_s
operator|->
name|wpa_state
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|wpa_state
operator|==
name|WPA_DISCONNECTED
operator|||
name|wpa_s
operator|->
name|wpa_state
operator|==
name|WPA_INACTIVE
condition|)
name|wpa_supplicant_set_state
argument_list|(
name|wpa_s
argument_list|,
name|WPA_SCANNING
argument_list|)
expr_stmt|;
comment|/* 	 * If autoscan has set its own scanning parameters 	 */
if|if
condition|(
name|wpa_s
operator|->
name|autoscan_params
operator|!=
name|NULL
condition|)
block|{
name|scan_params
operator|=
name|wpa_s
operator|->
name|autoscan_params
expr_stmt|;
goto|goto
name|scan
goto|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|last_scan_req
operator|==
name|MANUAL_SCAN_REQ
operator|&&
name|wpa_set_ssids_from_scan_req
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|params
argument_list|,
name|max_ssids
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Use specific SSIDs from SCAN command"
argument_list|)
expr_stmt|;
goto|goto
name|ssid_list_set
goto|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_P2P
if|if
condition|(
operator|(
name|wpa_s
operator|->
name|p2p_in_provisioning
operator|||
name|wpa_s
operator|->
name|show_group_started
operator|)
operator|&&
name|wpa_s
operator|->
name|go_params
operator|&&
operator|!
name|wpa_s
operator|->
name|conf
operator|->
name|passive_scan
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"P2P: Use specific SSID for scan during P2P group formation (p2p_in_provisioning=%d show_group_started=%d)"
argument_list|,
name|wpa_s
operator|->
name|p2p_in_provisioning
argument_list|,
name|wpa_s
operator|->
name|show_group_started
argument_list|)
expr_stmt|;
name|params
operator|.
name|ssids
index|[
literal|0
index|]
operator|.
name|ssid
operator|=
name|wpa_s
operator|->
name|go_params
operator|->
name|ssid
expr_stmt|;
name|params
operator|.
name|ssids
index|[
literal|0
index|]
operator|.
name|ssid_len
operator|=
name|wpa_s
operator|->
name|go_params
operator|->
name|ssid_len
expr_stmt|;
name|params
operator|.
name|num_ssids
operator|=
literal|1
expr_stmt|;
goto|goto
name|ssid_list_set
goto|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|p2p_in_invitation
condition|)
block|{
if|if
condition|(
name|wpa_s
operator|->
name|current_ssid
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"P2P: Use specific SSID for scan during invitation"
argument_list|)
expr_stmt|;
name|params
operator|.
name|ssids
index|[
literal|0
index|]
operator|.
name|ssid
operator|=
name|wpa_s
operator|->
name|current_ssid
operator|->
name|ssid
expr_stmt|;
name|params
operator|.
name|ssids
index|[
literal|0
index|]
operator|.
name|ssid_len
operator|=
name|wpa_s
operator|->
name|current_ssid
operator|->
name|ssid_len
expr_stmt|;
name|params
operator|.
name|num_ssids
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"P2P: No specific SSID known for scan during invitation"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|ssid_list_set
goto|;
block|}
endif|#
directive|endif
comment|/* CONFIG_P2P */
comment|/* Find the starting point from which to continue scanning */
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|prev_scan_ssid
operator|!=
name|WILDCARD_SSID_SCAN
condition|)
block|{
while|while
condition|(
name|ssid
condition|)
block|{
if|if
condition|(
name|ssid
operator|==
name|wpa_s
operator|->
name|prev_scan_ssid
condition|)
block|{
name|ssid
operator|=
name|ssid
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|ssid
operator|=
name|ssid
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wpa_s
operator|->
name|last_scan_req
operator|!=
name|MANUAL_SCAN_REQ
operator|&&
ifdef|#
directive|ifdef
name|CONFIG_AP
operator|!
name|wpa_s
operator|->
name|ap_iface
operator|&&
endif|#
directive|endif
comment|/* CONFIG_AP */
name|wpa_s
operator|->
name|conf
operator|->
name|ap_scan
operator|==
literal|2
condition|)
block|{
name|wpa_s
operator|->
name|connect_without_scan
operator|=
name|NULL
expr_stmt|;
name|wpa_s
operator|->
name|prev_scan_wildcard
operator|=
literal|0
expr_stmt|;
name|wpa_supplicant_assoc_try
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|ap_scan
operator|==
literal|2
condition|)
block|{
comment|/* 		 * User-initiated scan request in ap_scan == 2; scan with 		 * wildcard SSID. 		 */
name|ssid
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wpa_s
operator|->
name|reattach
operator|&&
name|wpa_s
operator|->
name|current_ssid
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Perform single-channel single-SSID scan for 		 * reassociate-to-same-BSS operation. 		 */
comment|/* Setup SSID */
name|ssid
operator|=
name|wpa_s
operator|->
name|current_ssid
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Scan SSID"
argument_list|,
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|params
operator|.
name|ssids
index|[
literal|0
index|]
operator|.
name|ssid
operator|=
name|ssid
operator|->
name|ssid
expr_stmt|;
name|params
operator|.
name|ssids
index|[
literal|0
index|]
operator|.
name|ssid_len
operator|=
name|ssid
operator|->
name|ssid_len
expr_stmt|;
name|params
operator|.
name|num_ssids
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Allocate memory for frequency array, allocate one extra 		 * slot for the zero-terminator. 		 */
name|params
operator|.
name|freqs
operator|=
name|os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|freqs
operator|==
name|NULL
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_ERROR
argument_list|,
literal|"Memory allocation failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|params
operator|.
name|freqs
index|[
literal|0
index|]
operator|=
name|wpa_s
operator|->
name|assoc_freq
expr_stmt|;
name|params
operator|.
name|freqs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Reset the reattach flag so that we fall back to full scan if 		 * this scan fails. 		 */
name|wpa_s
operator|->
name|reattach
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|wpa_ssid
modifier|*
name|start
init|=
name|ssid
decl_stmt|,
modifier|*
name|tssid
decl_stmt|;
name|int
name|freqs_set
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ssid
operator|==
name|NULL
operator|&&
name|max_ssids
operator|>
literal|1
condition|)
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
expr_stmt|;
while|while
condition|(
name|ssid
condition|)
block|{
if|if
condition|(
operator|!
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
operator|&&
name|ssid
operator|->
name|scan_ssid
condition|)
block|{
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Scan SSID"
argument_list|,
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|params
operator|.
name|ssids
index|[
name|params
operator|.
name|num_ssids
index|]
operator|.
name|ssid
operator|=
name|ssid
operator|->
name|ssid
expr_stmt|;
name|params
operator|.
name|ssids
index|[
name|params
operator|.
name|num_ssids
index|]
operator|.
name|ssid_len
operator|=
name|ssid
operator|->
name|ssid_len
expr_stmt|;
name|params
operator|.
name|num_ssids
operator|++
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|num_ssids
operator|+
literal|1
operator|>=
name|max_ssids
condition|)
break|break;
block|}
name|ssid
operator|=
name|ssid
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ssid
operator|==
name|start
condition|)
break|break;
if|if
condition|(
name|ssid
operator|==
name|NULL
operator|&&
name|max_ssids
operator|>
literal|1
operator|&&
name|start
operator|!=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
condition|)
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|scan_id_count
operator|&&
name|wpa_s
operator|->
name|last_scan_req
operator|==
name|MANUAL_SCAN_REQ
condition|)
name|wpa_set_scan_ssids
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|params
argument_list|,
name|max_ssids
argument_list|)
expr_stmt|;
for|for
control|(
name|tssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
init|;
name|wpa_s
operator|->
name|last_scan_req
operator|!=
name|MANUAL_SCAN_REQ
operator|&&
name|tssid
condition|;
name|tssid
operator|=
name|tssid
operator|->
name|next
control|)
block|{
if|if
condition|(
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|tssid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|params
operator|.
name|freqs
operator|||
operator|!
name|freqs_set
operator|)
operator|&&
name|tssid
operator|->
name|scan_freq
condition|)
block|{
name|int_array_concat
argument_list|(
operator|&
name|params
operator|.
name|freqs
argument_list|,
name|tssid
operator|->
name|scan_freq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|os_free
argument_list|(
name|params
operator|.
name|freqs
argument_list|)
expr_stmt|;
name|params
operator|.
name|freqs
operator|=
name|NULL
expr_stmt|;
block|}
name|freqs_set
operator|=
literal|1
expr_stmt|;
block|}
name|int_array_sort_unique
argument_list|(
name|params
operator|.
name|freqs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ssid
operator|&&
name|max_ssids
operator|==
literal|1
condition|)
block|{
comment|/* 		 * If the driver is limited to 1 SSID at a time interleave 		 * wildcard SSID scans with specific SSID scans to avoid 		 * waiting a long time for a wildcard scan. 		 */
if|if
condition|(
operator|!
name|wpa_s
operator|->
name|prev_scan_wildcard
condition|)
block|{
name|params
operator|.
name|ssids
index|[
literal|0
index|]
operator|.
name|ssid
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|ssids
index|[
literal|0
index|]
operator|.
name|ssid_len
operator|=
literal|0
expr_stmt|;
name|wpa_s
operator|->
name|prev_scan_wildcard
operator|=
literal|1
expr_stmt|;
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Starting AP scan for "
literal|"wildcard SSID (Interleave with specific)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_s
operator|->
name|prev_scan_ssid
operator|=
name|ssid
expr_stmt|;
name|wpa_s
operator|->
name|prev_scan_wildcard
operator|=
literal|0
expr_stmt|;
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Starting AP scan for specific SSID: %s"
argument_list|,
name|wpa_ssid_txt
argument_list|(
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ssid
condition|)
block|{
comment|/* max_ssids> 1 */
name|wpa_s
operator|->
name|prev_scan_ssid
operator|=
name|ssid
expr_stmt|;
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Include wildcard SSID in "
literal|"the scan request"
argument_list|)
expr_stmt|;
name|params
operator|.
name|num_ssids
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wpa_s
operator|->
name|last_scan_req
operator|==
name|MANUAL_SCAN_REQ
operator|&&
name|wpa_s
operator|->
name|manual_scan_passive
operator|&&
name|params
operator|.
name|num_ssids
operator|==
literal|0
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Use passive scan based on manual request"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|passive_scan
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Use passive scan based on configuration"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_s
operator|->
name|prev_scan_ssid
operator|=
name|WILDCARD_SSID_SCAN
expr_stmt|;
name|params
operator|.
name|num_ssids
operator|++
expr_stmt|;
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Starting AP scan for wildcard "
literal|"SSID"
argument_list|)
expr_stmt|;
block|}
name|ssid_list_set
label|:
name|wpa_supplicant_optimize_freqs
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|extra_ie
operator|=
name|wpa_supplicant_extra_ies
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|last_scan_req
operator|==
name|MANUAL_SCAN_REQ
operator|&&
name|wpa_s
operator|->
name|manual_scan_only_new
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Request driver to clear scan cache due to manual only_new=1 scan"
argument_list|)
expr_stmt|;
name|params
operator|.
name|only_new_results
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|last_scan_req
operator|==
name|MANUAL_SCAN_REQ
operator|&&
name|params
operator|.
name|freqs
operator|==
name|NULL
operator|&&
name|wpa_s
operator|->
name|manual_scan_freqs
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Limit manual scan to specified channels"
argument_list|)
expr_stmt|;
name|params
operator|.
name|freqs
operator|=
name|wpa_s
operator|->
name|manual_scan_freqs
expr_stmt|;
name|wpa_s
operator|->
name|manual_scan_freqs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|freqs
operator|==
name|NULL
operator|&&
name|wpa_s
operator|->
name|next_scan_freqs
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Optimize scan based on previously "
literal|"generated frequency list"
argument_list|)
expr_stmt|;
name|params
operator|.
name|freqs
operator|=
name|wpa_s
operator|->
name|next_scan_freqs
expr_stmt|;
block|}
else|else
name|os_free
argument_list|(
name|wpa_s
operator|->
name|next_scan_freqs
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|next_scan_freqs
operator|=
name|NULL
expr_stmt|;
name|wpa_setband_scan_freqs
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
comment|/* See if user specified frequencies. If so, scan only those. */
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|freq_list
operator|&&
operator|!
name|params
operator|.
name|freqs
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Optimize scan based on conf->freq_list"
argument_list|)
expr_stmt|;
name|int_array_concat
argument_list|(
operator|&
name|params
operator|.
name|freqs
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|freq_list
argument_list|)
expr_stmt|;
block|}
comment|/* Use current associated channel? */
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|scan_cur_freq
operator|&&
operator|!
name|params
operator|.
name|freqs
condition|)
block|{
name|unsigned
name|int
name|num
init|=
name|wpa_s
operator|->
name|num_multichan_concurrent
decl_stmt|;
name|params
operator|.
name|freqs
operator|=
name|os_calloc
argument_list|(
name|num
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|freqs
condition|)
block|{
name|num
operator|=
name|get_shared_radio_freqs
argument_list|(
name|wpa_s
argument_list|,
name|params
operator|.
name|freqs
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Scan only the "
literal|"current operating channels since "
literal|"scan_cur_freq is enabled"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|os_free
argument_list|(
name|params
operator|.
name|freqs
argument_list|)
expr_stmt|;
name|params
operator|.
name|freqs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|params
operator|.
name|filter_ssids
operator|=
name|wpa_supplicant_build_filter_ssids
argument_list|(
name|wpa_s
operator|->
name|conf
argument_list|,
operator|&
name|params
operator|.
name|num_filter_ssids
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_ie
condition|)
block|{
name|params
operator|.
name|extra_ies
operator|=
name|wpabuf_head
argument_list|(
name|extra_ie
argument_list|)
expr_stmt|;
name|params
operator|.
name|extra_ies_len
operator|=
name|wpabuf_len
argument_list|(
name|extra_ie
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_P2P
if|if
condition|(
name|wpa_s
operator|->
name|p2p_in_provisioning
operator|||
name|wpa_s
operator|->
name|p2p_in_invitation
operator|||
operator|(
name|wpa_s
operator|->
name|show_group_started
operator|&&
name|wpa_s
operator|->
name|go_params
operator|)
condition|)
block|{
comment|/* 		 * The interface may not yet be in P2P mode, so we have to 		 * explicitly request P2P probe to disable CCK rates. 		 */
name|params
operator|.
name|p2p_probe
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CONFIG_P2P */
if|if
condition|(
name|wpa_s
operator|->
name|mac_addr_rand_enable
operator|&
name|MAC_ADDR_RAND_SCAN
condition|)
block|{
name|params
operator|.
name|mac_addr_rand
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|mac_addr_scan
condition|)
block|{
name|params
operator|.
name|mac_addr
operator|=
name|wpa_s
operator|->
name|mac_addr_scan
expr_stmt|;
name|params
operator|.
name|mac_addr_mask
operator|=
name|wpa_s
operator|->
name|mac_addr_scan
operator|+
name|ETH_ALEN
expr_stmt|;
block|}
block|}
name|scan_params
operator|=
operator|&
name|params
expr_stmt|;
name|scan
label|:
ifdef|#
directive|ifdef
name|CONFIG_P2P
comment|/* 	 * If the driver does not support multi-channel concurrency and a 	 * virtual interface that shares the same radio with the wpa_s interface 	 * is operating there may not be need to scan other channels apart from 	 * the current operating channel on the other virtual interface. Filter 	 * out other channels in case we are trying to find a connection for a 	 * station interface when we are not configured to prefer station 	 * connection and a concurrent operation is already in process. 	 */
if|if
condition|(
name|wpa_s
operator|->
name|scan_for_connection
operator|&&
name|wpa_s
operator|->
name|last_scan_req
operator|==
name|NORMAL_SCAN_REQ
operator|&&
operator|!
name|scan_params
operator|->
name|freqs
operator|&&
operator|!
name|params
operator|.
name|freqs
operator|&&
name|wpas_is_p2p_prioritized
argument_list|(
name|wpa_s
argument_list|)
operator|&&
name|wpa_s
operator|->
name|p2p_group_interface
operator|==
name|NOT_P2P_GROUP_INTERFACE
operator|&&
name|non_p2p_network_enabled
argument_list|(
name|wpa_s
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|num
init|=
name|wpa_s
operator|->
name|num_multichan_concurrent
decl_stmt|;
name|params
operator|.
name|freqs
operator|=
name|os_calloc
argument_list|(
name|num
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|freqs
condition|)
block|{
name|num
operator|=
name|get_shared_radio_freqs
argument_list|(
name|wpa_s
argument_list|,
name|params
operator|.
name|freqs
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|>
literal|0
operator|&&
name|num
operator|==
name|wpa_s
operator|->
name|num_multichan_concurrent
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Scan only the current operating channels since all channels are already used"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|os_free
argument_list|(
name|params
operator|.
name|freqs
argument_list|)
expr_stmt|;
name|params
operator|.
name|freqs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* CONFIG_P2P */
name|ret
operator|=
name|wpa_supplicant_trigger_scan
argument_list|(
name|wpa_s
argument_list|,
name|scan_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|wpa_s
operator|->
name|last_scan_req
operator|==
name|MANUAL_SCAN_REQ
operator|&&
name|params
operator|.
name|freqs
operator|&&
operator|!
name|wpa_s
operator|->
name|manual_scan_freqs
condition|)
block|{
comment|/* Restore manual_scan_freqs for the next attempt */
name|wpa_s
operator|->
name|manual_scan_freqs
operator|=
name|params
operator|.
name|freqs
expr_stmt|;
name|params
operator|.
name|freqs
operator|=
name|NULL
expr_stmt|;
block|}
name|wpabuf_free
argument_list|(
name|extra_ie
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|params
operator|.
name|freqs
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|params
operator|.
name|filter_ssids
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_WARNING
argument_list|,
literal|"Failed to initiate AP scan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|scan_prev_wpa_state
operator|!=
name|wpa_s
operator|->
name|wpa_state
condition|)
name|wpa_supplicant_set_state
argument_list|(
name|wpa_s
argument_list|,
name|wpa_s
operator|->
name|scan_prev_wpa_state
argument_list|)
expr_stmt|;
comment|/* Restore scan_req since we will try to scan again */
name|wpa_s
operator|->
name|scan_req
operator|=
name|wpa_s
operator|->
name|last_scan_req
expr_stmt|;
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_s
operator|->
name|scan_for_connection
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_INTERWORKING
name|wpa_s
operator|->
name|interworking_fast_assoc_tried
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_INTERWORKING */
block|}
block|}
end_function

begin_function
name|void
name|wpa_supplicant_update_scan_int
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|int
name|sec
parameter_list|)
block|{
name|struct
name|os_reltime
name|remaining
decl_stmt|,
name|new_int
decl_stmt|;
name|int
name|cancelled
decl_stmt|;
name|cancelled
operator|=
name|eloop_cancel_timeout_one
argument_list|(
name|wpa_supplicant_scan
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|,
operator|&
name|remaining
argument_list|)
expr_stmt|;
name|new_int
operator|.
name|sec
operator|=
name|sec
expr_stmt|;
name|new_int
operator|.
name|usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cancelled
operator|&&
name|os_reltime_before
argument_list|(
operator|&
name|remaining
argument_list|,
operator|&
name|new_int
argument_list|)
condition|)
block|{
name|new_int
operator|.
name|sec
operator|=
name|remaining
operator|.
name|sec
expr_stmt|;
name|new_int
operator|.
name|usec
operator|=
name|remaining
operator|.
name|usec
expr_stmt|;
block|}
if|if
condition|(
name|cancelled
condition|)
block|{
name|eloop_register_timeout
argument_list|(
name|new_int
operator|.
name|sec
argument_list|,
name|new_int
operator|.
name|usec
argument_list|,
name|wpa_supplicant_scan
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|wpa_s
operator|->
name|scan_interval
operator|=
name|sec
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_req_scan - Schedule a scan for neighboring access points  * @wpa_s: Pointer to wpa_supplicant data  * @sec: Number of seconds after which to scan  * @usec: Number of microseconds after which to scan  *  * This function is used to schedule a scan for neighboring access points after  * the specified time.  */
end_comment

begin_function
name|void
name|wpa_supplicant_req_scan
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|int
name|sec
parameter_list|,
name|int
name|usec
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|p2p_mgmt
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Ignore scan request (%d.%06d sec) on p2p_mgmt interface"
argument_list|,
name|sec
argument_list|,
name|usec
argument_list|)
expr_stmt|;
return|return;
block|}
name|res
operator|=
name|eloop_deplete_timeout
argument_list|(
name|sec
argument_list|,
name|usec
argument_list|,
name|wpa_supplicant_scan
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|1
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Rescheduling scan request: %d.%06d sec"
argument_list|,
name|sec
argument_list|,
name|usec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Ignore new scan request for %d.%06d sec since an earlier request is scheduled to trigger sooner"
argument_list|,
name|sec
argument_list|,
name|usec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Setting scan request: %d.%06d sec"
argument_list|,
name|sec
argument_list|,
name|usec
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|sec
argument_list|,
name|usec
argument_list|,
name|wpa_supplicant_scan
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_delayed_sched_scan - Request a delayed scheduled scan  * @wpa_s: Pointer to wpa_supplicant data  * @sec: Number of seconds after which to scan  * @usec: Number of microseconds after which to scan  * Returns: 0 on success or -1 otherwise  *  * This function is used to schedule periodic scans for neighboring  * access points after the specified time.  */
end_comment

begin_function
name|int
name|wpa_supplicant_delayed_sched_scan
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|int
name|sec
parameter_list|,
name|int
name|usec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|wpa_s
operator|->
name|sched_scan_supported
condition|)
return|return
operator|-
literal|1
return|;
name|eloop_register_timeout
argument_list|(
name|sec
argument_list|,
name|usec
argument_list|,
name|wpa_supplicant_delayed_sched_scan_timeout
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_req_sched_scan - Start a periodic scheduled scan  * @wpa_s: Pointer to wpa_supplicant data  * Returns: 0 is sched_scan was started or -1 otherwise  *  * This function is used to schedule periodic scans for neighboring  * access points repeating the scan continuously.  */
end_comment

begin_function
name|int
name|wpa_supplicant_req_sched_scan
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpa_driver_scan_params
name|params
decl_stmt|;
name|struct
name|wpa_driver_scan_params
modifier|*
name|scan_params
decl_stmt|;
name|enum
name|wpa_states
name|prev_state
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|ssid
init|=
name|NULL
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|extra_ie
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|max_sched_scan_ssids
decl_stmt|;
name|int
name|wildcard
init|=
literal|0
decl_stmt|;
name|int
name|need_ssids
decl_stmt|;
if|if
condition|(
operator|!
name|wpa_s
operator|->
name|sched_scan_supported
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|wpa_s
operator|->
name|max_sched_scan_ssids
operator|>
name|WPAS_MAX_SCAN_SSIDS
condition|)
name|max_sched_scan_ssids
operator|=
name|WPAS_MAX_SCAN_SSIDS
expr_stmt|;
else|else
name|max_sched_scan_ssids
operator|=
name|wpa_s
operator|->
name|max_sched_scan_ssids
expr_stmt|;
if|if
condition|(
name|max_sched_scan_ssids
operator|<
literal|1
operator|||
name|wpa_s
operator|->
name|conf
operator|->
name|disable_scan_offload
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|wpa_s
operator|->
name|sched_scanning
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Already sched scanning"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|need_ssids
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
init|;
name|ssid
condition|;
name|ssid
operator|=
name|ssid
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
operator|&&
operator|!
name|ssid
operator|->
name|scan_ssid
condition|)
block|{
comment|/* Use wildcard SSID to find this network */
name|wildcard
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
operator|&&
name|ssid
operator|->
name|ssid_len
condition|)
name|need_ssids
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_WPS
if|if
condition|(
operator|!
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
operator|&&
name|ssid
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_WPS
condition|)
block|{
comment|/* 			 * Normal scan is more reliable and faster for WPS 			 * operations and since these are for short periods of 			 * time, the benefit of trying to use sched_scan would 			 * be limited. 			 */
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Use normal scan instead of "
literal|"sched_scan for WPS"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* CONFIG_WPS */
block|}
if|if
condition|(
name|wildcard
condition|)
name|need_ssids
operator|++
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|normal_scans
operator|<
literal|3
operator|&&
operator|(
name|need_ssids
operator|<=
name|wpa_s
operator|->
name|max_scan_ssids
operator|||
name|wpa_s
operator|->
name|max_scan_ssids
operator|>=
operator|(
name|int
operator|)
name|max_sched_scan_ssids
operator|)
condition|)
block|{
comment|/* 		 * When normal scan can speed up operations, use that for the 		 * first operations before starting the sched_scan to allow 		 * user space sleep more. We do this only if the normal scan 		 * has functionality that is suitable for this or if the 		 * sched_scan does not have better support for multiple SSIDs. 		 */
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Use normal scan instead of "
literal|"sched_scan for initial scans (normal_scans=%d)"
argument_list|,
name|wpa_s
operator|->
name|normal_scans
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|os_memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we can't allocate space for the filters, we just don't filter */
name|params
operator|.
name|filter_ssids
operator|=
name|os_calloc
argument_list|(
name|wpa_s
operator|->
name|max_match_sets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpa_driver_scan_filter
argument_list|)
argument_list|)
expr_stmt|;
name|prev_state
operator|=
name|wpa_s
operator|->
name|wpa_state
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|wpa_state
operator|==
name|WPA_DISCONNECTED
operator|||
name|wpa_s
operator|->
name|wpa_state
operator|==
name|WPA_INACTIVE
condition|)
name|wpa_supplicant_set_state
argument_list|(
name|wpa_s
argument_list|,
name|WPA_SCANNING
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|autoscan_params
operator|!=
name|NULL
condition|)
block|{
name|scan_params
operator|=
name|wpa_s
operator|->
name|autoscan_params
expr_stmt|;
goto|goto
name|scan
goto|;
block|}
comment|/* Find the starting point from which to continue scanning */
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|prev_sched_ssid
condition|)
block|{
while|while
condition|(
name|ssid
condition|)
block|{
if|if
condition|(
name|ssid
operator|==
name|wpa_s
operator|->
name|prev_sched_ssid
condition|)
block|{
name|ssid
operator|=
name|ssid
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|ssid
operator|=
name|ssid
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ssid
operator|||
operator|!
name|wpa_s
operator|->
name|prev_sched_ssid
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Beginning of SSID list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|sched_scan_interval
condition|)
name|wpa_s
operator|->
name|sched_scan_interval
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|sched_scan_interval
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|sched_scan_interval
operator|==
literal|0
condition|)
name|wpa_s
operator|->
name|sched_scan_interval
operator|=
literal|10
expr_stmt|;
name|wpa_s
operator|->
name|sched_scan_timeout
operator|=
name|max_sched_scan_ssids
operator|*
literal|2
expr_stmt|;
name|wpa_s
operator|->
name|first_sched_scan
operator|=
literal|1
expr_stmt|;
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
expr_stmt|;
name|wpa_s
operator|->
name|prev_sched_ssid
operator|=
name|ssid
expr_stmt|;
block|}
if|if
condition|(
name|wildcard
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Add wildcard SSID to sched_scan"
argument_list|)
expr_stmt|;
name|params
operator|.
name|num_ssids
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|ssid
condition|)
block|{
if|if
condition|(
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|params
operator|.
name|num_filter_ssids
operator|<
name|wpa_s
operator|->
name|max_match_sets
operator|&&
name|params
operator|.
name|filter_ssids
operator|&&
name|ssid
operator|->
name|ssid
operator|&&
name|ssid
operator|->
name|ssid_len
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"add to filter ssid: %s"
argument_list|,
name|wpa_ssid_txt
argument_list|(
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|params
operator|.
name|filter_ssids
index|[
name|params
operator|.
name|num_filter_ssids
index|]
operator|.
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|params
operator|.
name|filter_ssids
index|[
name|params
operator|.
name|num_filter_ssids
index|]
operator|.
name|ssid_len
operator|=
name|ssid
operator|->
name|ssid_len
expr_stmt|;
name|params
operator|.
name|num_filter_ssids
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|params
operator|.
name|filter_ssids
operator|&&
name|ssid
operator|->
name|ssid
operator|&&
name|ssid
operator|->
name|ssid_len
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Not enough room for SSID "
literal|"filter for sched_scan - drop filter"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|params
operator|.
name|filter_ssids
argument_list|)
expr_stmt|;
name|params
operator|.
name|filter_ssids
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|num_filter_ssids
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ssid
operator|->
name|scan_ssid
operator|&&
name|ssid
operator|->
name|ssid
operator|&&
name|ssid
operator|->
name|ssid_len
condition|)
block|{
if|if
condition|(
name|params
operator|.
name|num_ssids
operator|==
name|max_sched_scan_ssids
condition|)
break|break;
comment|/* only room for broadcast SSID */
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"add to active scan ssid: %s"
argument_list|,
name|wpa_ssid_txt
argument_list|(
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|ssids
index|[
name|params
operator|.
name|num_ssids
index|]
operator|.
name|ssid
operator|=
name|ssid
operator|->
name|ssid
expr_stmt|;
name|params
operator|.
name|ssids
index|[
name|params
operator|.
name|num_ssids
index|]
operator|.
name|ssid_len
operator|=
name|ssid
operator|->
name|ssid_len
expr_stmt|;
name|params
operator|.
name|num_ssids
operator|++
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|num_ssids
operator|>=
name|max_sched_scan_ssids
condition|)
block|{
name|wpa_s
operator|->
name|prev_sched_ssid
operator|=
name|ssid
expr_stmt|;
do|do
block|{
name|ssid
operator|=
name|ssid
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|ssid
operator|&&
operator|(
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
operator|||
operator|!
name|ssid
operator|->
name|scan_ssid
operator|)
condition|)
do|;
break|break;
block|}
block|}
name|next
label|:
name|wpa_s
operator|->
name|prev_sched_ssid
operator|=
name|ssid
expr_stmt|;
name|ssid
operator|=
name|ssid
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|num_filter_ssids
operator|==
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|params
operator|.
name|filter_ssids
argument_list|)
expr_stmt|;
name|params
operator|.
name|filter_ssids
operator|=
name|NULL
expr_stmt|;
block|}
name|extra_ie
operator|=
name|wpa_supplicant_extra_ies
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_ie
condition|)
block|{
name|params
operator|.
name|extra_ies
operator|=
name|wpabuf_head
argument_list|(
name|extra_ie
argument_list|)
expr_stmt|;
name|params
operator|.
name|extra_ies_len
operator|=
name|wpabuf_len
argument_list|(
name|extra_ie
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|filter_rssi
condition|)
name|params
operator|.
name|filter_rssi
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|filter_rssi
expr_stmt|;
comment|/* See if user specified frequencies. If so, scan only those. */
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|freq_list
operator|&&
operator|!
name|params
operator|.
name|freqs
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Optimize scan based on conf->freq_list"
argument_list|)
expr_stmt|;
name|int_array_concat
argument_list|(
operator|&
name|params
operator|.
name|freqs
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|freq_list
argument_list|)
expr_stmt|;
block|}
name|scan_params
operator|=
operator|&
name|params
expr_stmt|;
name|scan
label|:
if|if
condition|(
name|ssid
operator|||
operator|!
name|wpa_s
operator|->
name|first_sched_scan
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Starting sched scan: interval %d timeout %d"
argument_list|,
name|wpa_s
operator|->
name|sched_scan_interval
argument_list|,
name|wpa_s
operator|->
name|sched_scan_timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Starting sched scan: interval %d (no timeout)"
argument_list|,
name|wpa_s
operator|->
name|sched_scan_interval
argument_list|)
expr_stmt|;
block|}
name|wpa_setband_scan_freqs
argument_list|(
name|wpa_s
argument_list|,
name|scan_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|mac_addr_rand_enable
operator|&
name|MAC_ADDR_RAND_SCHED_SCAN
condition|)
block|{
name|params
operator|.
name|mac_addr_rand
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|mac_addr_sched_scan
condition|)
block|{
name|params
operator|.
name|mac_addr
operator|=
name|wpa_s
operator|->
name|mac_addr_sched_scan
expr_stmt|;
name|params
operator|.
name|mac_addr_mask
operator|=
name|wpa_s
operator|->
name|mac_addr_sched_scan
operator|+
name|ETH_ALEN
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|wpa_supplicant_start_sched_scan
argument_list|(
name|wpa_s
argument_list|,
name|scan_params
argument_list|,
name|wpa_s
operator|->
name|sched_scan_interval
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|extra_ie
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|params
operator|.
name|filter_ssids
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_WARNING
argument_list|,
literal|"Failed to initiate sched scan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_state
operator|!=
name|wpa_s
operator|->
name|wpa_state
condition|)
name|wpa_supplicant_set_state
argument_list|(
name|wpa_s
argument_list|,
name|prev_state
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* If we have more SSIDs to scan, add a timeout so we scan them too */
if|if
condition|(
name|ssid
operator|||
operator|!
name|wpa_s
operator|->
name|first_sched_scan
condition|)
block|{
name|wpa_s
operator|->
name|sched_scan_timed_out
operator|=
literal|0
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|wpa_s
operator|->
name|sched_scan_timeout
argument_list|,
literal|0
argument_list|,
name|wpa_supplicant_sched_scan_timeout
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|first_sched_scan
operator|=
literal|0
expr_stmt|;
name|wpa_s
operator|->
name|sched_scan_timeout
operator|/=
literal|2
expr_stmt|;
name|wpa_s
operator|->
name|sched_scan_interval
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|sched_scan_timeout
operator|<
name|wpa_s
operator|->
name|sched_scan_interval
condition|)
block|{
name|wpa_s
operator|->
name|sched_scan_interval
operator|=
literal|10
expr_stmt|;
name|wpa_s
operator|->
name|sched_scan_timeout
operator|=
name|max_sched_scan_ssids
operator|*
literal|2
expr_stmt|;
block|}
block|}
comment|/* If there is no more ssids, start next time from the beginning */
if|if
condition|(
operator|!
name|ssid
condition|)
name|wpa_s
operator|->
name|prev_sched_ssid
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_cancel_scan - Cancel a scheduled scan request  * @wpa_s: Pointer to wpa_supplicant data  *  * This function is used to cancel a scan request scheduled with  * wpa_supplicant_req_scan().  */
end_comment

begin_function
name|void
name|wpa_supplicant_cancel_scan
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Cancelling scan request"
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|wpa_supplicant_scan
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_cancel_delayed_sched_scan - Stop a delayed scheduled scan  * @wpa_s: Pointer to wpa_supplicant data  *  * This function is used to stop a delayed scheduled scan.  */
end_comment

begin_function
name|void
name|wpa_supplicant_cancel_delayed_sched_scan
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|wpa_s
operator|->
name|sched_scan_supported
condition|)
return|return;
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Cancelling delayed sched scan"
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|wpa_supplicant_delayed_sched_scan_timeout
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_cancel_sched_scan - Stop running scheduled scans  * @wpa_s: Pointer to wpa_supplicant data  *  * This function is used to stop a periodic scheduled scan.  */
end_comment

begin_function
name|void
name|wpa_supplicant_cancel_sched_scan
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|wpa_s
operator|->
name|sched_scanning
condition|)
return|return;
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Cancelling sched scan"
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|wpa_supplicant_sched_scan_timeout
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wpa_supplicant_stop_sched_scan
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_notify_scanning - Indicate possible scan state change  * @wpa_s: Pointer to wpa_supplicant data  * @scanning: Whether scanning is currently in progress  *  * This function is to generate scanning notifycations. It is called whenever  * there may have been a change in scanning (scan started, completed, stopped).  * wpas_notify_scanning() is called whenever the scanning state changed from the  * previously notified state.  */
end_comment

begin_function
name|void
name|wpa_supplicant_notify_scanning
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|int
name|scanning
parameter_list|)
block|{
if|if
condition|(
name|wpa_s
operator|->
name|scanning
operator|!=
name|scanning
condition|)
block|{
name|wpa_s
operator|->
name|scanning
operator|=
name|scanning
expr_stmt|;
name|wpas_notify_scanning
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wpa_scan_get_max_rate
parameter_list|(
specifier|const
name|struct
name|wpa_scan_res
modifier|*
name|res
parameter_list|)
block|{
name|int
name|rate
init|=
literal|0
decl_stmt|;
specifier|const
name|u8
modifier|*
name|ie
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ie
operator|=
name|wpa_scan_get_ie
argument_list|(
name|res
argument_list|,
name|WLAN_EID_SUPP_RATES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ie
operator|&&
name|i
operator|<
name|ie
index|[
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ie
index|[
name|i
operator|+
literal|2
index|]
operator|&
literal|0x7f
operator|)
operator|>
name|rate
condition|)
name|rate
operator|=
name|ie
index|[
name|i
operator|+
literal|2
index|]
operator|&
literal|0x7f
expr_stmt|;
block|}
name|ie
operator|=
name|wpa_scan_get_ie
argument_list|(
name|res
argument_list|,
name|WLAN_EID_EXT_SUPP_RATES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ie
operator|&&
name|i
operator|<
name|ie
index|[
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ie
index|[
name|i
operator|+
literal|2
index|]
operator|&
literal|0x7f
operator|)
operator|>
name|rate
condition|)
name|rate
operator|=
name|ie
index|[
name|i
operator|+
literal|2
index|]
operator|&
literal|0x7f
expr_stmt|;
block|}
return|return
name|rate
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_scan_get_ie - Fetch a specified information element from a scan result  * @res: Scan result entry  * @ie: Information element identitifier (WLAN_EID_*)  * Returns: Pointer to the information element (id field) or %NULL if not found  *  * This function returns the first matching information element in the scan  * result.  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|wpa_scan_get_ie
parameter_list|(
specifier|const
name|struct
name|wpa_scan_res
modifier|*
name|res
parameter_list|,
name|u8
name|ie
parameter_list|)
block|{
specifier|const
name|u8
modifier|*
name|end
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|res
operator|+
literal|1
operator|)
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|res
operator|->
name|ie_len
expr_stmt|;
while|while
condition|(
name|pos
operator|+
literal|1
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|pos
operator|+
literal|2
operator|+
name|pos
index|[
literal|1
index|]
operator|>
name|end
condition|)
break|break;
if|if
condition|(
name|pos
index|[
literal|0
index|]
operator|==
name|ie
condition|)
return|return
name|pos
return|;
name|pos
operator|+=
literal|2
operator|+
name|pos
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_scan_get_vendor_ie - Fetch vendor information element from a scan result  * @res: Scan result entry  * @vendor_type: Vendor type (four octets starting the IE payload)  * Returns: Pointer to the information element (id field) or %NULL if not found  *  * This function returns the first matching information element in the scan  * result.  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|wpa_scan_get_vendor_ie
parameter_list|(
specifier|const
name|struct
name|wpa_scan_res
modifier|*
name|res
parameter_list|,
name|u32
name|vendor_type
parameter_list|)
block|{
specifier|const
name|u8
modifier|*
name|end
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|res
operator|+
literal|1
operator|)
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|res
operator|->
name|ie_len
expr_stmt|;
while|while
condition|(
name|pos
operator|+
literal|1
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|pos
operator|+
literal|2
operator|+
name|pos
index|[
literal|1
index|]
operator|>
name|end
condition|)
break|break;
if|if
condition|(
name|pos
index|[
literal|0
index|]
operator|==
name|WLAN_EID_VENDOR_SPECIFIC
operator|&&
name|pos
index|[
literal|1
index|]
operator|>=
literal|4
operator|&&
name|vendor_type
operator|==
name|WPA_GET_BE32
argument_list|(
operator|&
name|pos
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
name|pos
return|;
name|pos
operator|+=
literal|2
operator|+
name|pos
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_scan_get_vendor_ie_beacon - Fetch vendor information from a scan result  * @res: Scan result entry  * @vendor_type: Vendor type (four octets starting the IE payload)  * Returns: Pointer to the information element (id field) or %NULL if not found  *  * This function returns the first matching information element in the scan  * result.  *  * This function is like wpa_scan_get_vendor_ie(), but uses IE buffer only  * from Beacon frames instead of either Beacon or Probe Response frames.  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|wpa_scan_get_vendor_ie_beacon
parameter_list|(
specifier|const
name|struct
name|wpa_scan_res
modifier|*
name|res
parameter_list|,
name|u32
name|vendor_type
parameter_list|)
block|{
specifier|const
name|u8
modifier|*
name|end
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
if|if
condition|(
name|res
operator|->
name|beacon_ie_len
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|res
operator|+
literal|1
operator|)
expr_stmt|;
name|pos
operator|+=
name|res
operator|->
name|ie_len
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|res
operator|->
name|beacon_ie_len
expr_stmt|;
while|while
condition|(
name|pos
operator|+
literal|1
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|pos
operator|+
literal|2
operator|+
name|pos
index|[
literal|1
index|]
operator|>
name|end
condition|)
break|break;
if|if
condition|(
name|pos
index|[
literal|0
index|]
operator|==
name|WLAN_EID_VENDOR_SPECIFIC
operator|&&
name|pos
index|[
literal|1
index|]
operator|>=
literal|4
operator|&&
name|vendor_type
operator|==
name|WPA_GET_BE32
argument_list|(
operator|&
name|pos
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
name|pos
return|;
name|pos
operator|+=
literal|2
operator|+
name|pos
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_scan_get_vendor_ie_multi - Fetch vendor IE data from a scan result  * @res: Scan result entry  * @vendor_type: Vendor type (four octets starting the IE payload)  * Returns: Pointer to the information element payload or %NULL if not found  *  * This function returns concatenated payload of possibly fragmented vendor  * specific information elements in the scan result. The caller is responsible  * for freeing the returned buffer.  */
end_comment

begin_function
name|struct
name|wpabuf
modifier|*
name|wpa_scan_get_vendor_ie_multi
parameter_list|(
specifier|const
name|struct
name|wpa_scan_res
modifier|*
name|res
parameter_list|,
name|u32
name|vendor_type
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
specifier|const
name|u8
modifier|*
name|end
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
name|res
operator|->
name|ie_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|res
operator|+
literal|1
operator|)
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|res
operator|->
name|ie_len
expr_stmt|;
while|while
condition|(
name|pos
operator|+
literal|1
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|pos
operator|+
literal|2
operator|+
name|pos
index|[
literal|1
index|]
operator|>
name|end
condition|)
break|break;
if|if
condition|(
name|pos
index|[
literal|0
index|]
operator|==
name|WLAN_EID_VENDOR_SPECIFIC
operator|&&
name|pos
index|[
literal|1
index|]
operator|>=
literal|4
operator|&&
name|vendor_type
operator|==
name|WPA_GET_BE32
argument_list|(
operator|&
name|pos
index|[
literal|2
index|]
argument_list|)
condition|)
name|wpabuf_put_data
argument_list|(
name|buf
argument_list|,
name|pos
operator|+
literal|2
operator|+
literal|4
argument_list|,
name|pos
index|[
literal|1
index|]
operator|-
literal|4
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
operator|+
name|pos
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|wpabuf_len
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Channels with a great SNR can operate at full rate. What is a great SNR?  * This doc https://supportforums.cisco.com/docs/DOC-12954 says, "the general  * rule of thumb is that any SNR above 20 is good." This one  * http://www.cisco.com/en/US/tech/tk722/tk809/technologies_q_and_a_item09186a00805e9a96.shtml#qa23  * recommends 25 as a minimum SNR for 54 Mbps data rate. 30 is chosen here as a  * conservative value.  */
end_comment

begin_define
define|#
directive|define
name|GREAT_SNR
value|30
end_define

begin_define
define|#
directive|define
name|IS_5GHZ
parameter_list|(
name|n
parameter_list|)
value|(n> 4000)
end_define

begin_comment
comment|/* Compare function for sorting scan results. Return>0 if @b is considered  * better. */
end_comment

begin_function
specifier|static
name|int
name|wpa_scan_result_compar
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a< b ? a : b
name|struct
name|wpa_scan_res
modifier|*
modifier|*
name|_wa
init|=
operator|(
name|void
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|wpa_scan_res
modifier|*
modifier|*
name|_wb
init|=
operator|(
name|void
operator|*
operator|)
name|b
decl_stmt|;
name|struct
name|wpa_scan_res
modifier|*
name|wa
init|=
operator|*
name|_wa
decl_stmt|;
name|struct
name|wpa_scan_res
modifier|*
name|wb
init|=
operator|*
name|_wb
decl_stmt|;
name|int
name|wpa_a
decl_stmt|,
name|wpa_b
decl_stmt|;
name|int
name|snr_a
decl_stmt|,
name|snr_b
decl_stmt|,
name|snr_a_full
decl_stmt|,
name|snr_b_full
decl_stmt|;
comment|/* WPA/WPA2 support preferred */
name|wpa_a
operator|=
name|wpa_scan_get_vendor_ie
argument_list|(
name|wa
argument_list|,
name|WPA_IE_VENDOR_TYPE
argument_list|)
operator|!=
name|NULL
operator|||
name|wpa_scan_get_ie
argument_list|(
name|wa
argument_list|,
name|WLAN_EID_RSN
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|wpa_b
operator|=
name|wpa_scan_get_vendor_ie
argument_list|(
name|wb
argument_list|,
name|WPA_IE_VENDOR_TYPE
argument_list|)
operator|!=
name|NULL
operator|||
name|wpa_scan_get_ie
argument_list|(
name|wb
argument_list|,
name|WLAN_EID_RSN
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|wpa_b
operator|&&
operator|!
name|wpa_a
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|wpa_b
operator|&&
name|wpa_a
condition|)
return|return
operator|-
literal|1
return|;
comment|/* privacy support preferred */
if|if
condition|(
operator|(
name|wa
operator|->
name|caps
operator|&
name|IEEE80211_CAP_PRIVACY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|wb
operator|->
name|caps
operator|&
name|IEEE80211_CAP_PRIVACY
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|wa
operator|->
name|caps
operator|&
name|IEEE80211_CAP_PRIVACY
operator|)
operator|&&
operator|(
name|wb
operator|->
name|caps
operator|&
name|IEEE80211_CAP_PRIVACY
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|wa
operator|->
name|flags
operator|&
name|wb
operator|->
name|flags
operator|&
name|WPA_SCAN_LEVEL_DBM
condition|)
block|{
name|snr_a_full
operator|=
name|wa
operator|->
name|snr
expr_stmt|;
name|snr_a
operator|=
name|MIN
argument_list|(
name|wa
operator|->
name|snr
argument_list|,
name|GREAT_SNR
argument_list|)
expr_stmt|;
name|snr_b_full
operator|=
name|wb
operator|->
name|snr
expr_stmt|;
name|snr_b
operator|=
name|MIN
argument_list|(
name|wb
operator|->
name|snr
argument_list|,
name|GREAT_SNR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Level is not in dBm, so we can't calculate 		 * SNR. Just use raw level (units unknown). */
name|snr_a
operator|=
name|snr_a_full
operator|=
name|wa
operator|->
name|level
expr_stmt|;
name|snr_b
operator|=
name|snr_b_full
operator|=
name|wb
operator|->
name|level
expr_stmt|;
block|}
comment|/* if SNR is close, decide by max rate or frequency band */
if|if
condition|(
operator|(
name|snr_a
operator|&&
name|snr_b
operator|&&
name|abs
argument_list|(
name|snr_b
operator|-
name|snr_a
argument_list|)
operator|<
literal|5
operator|)
operator|||
operator|(
name|wa
operator|->
name|qual
operator|&&
name|wb
operator|->
name|qual
operator|&&
name|abs
argument_list|(
name|wb
operator|->
name|qual
operator|-
name|wa
operator|->
name|qual
argument_list|)
operator|<
literal|10
operator|)
condition|)
block|{
if|if
condition|(
name|wa
operator|->
name|est_throughput
operator|!=
name|wb
operator|->
name|est_throughput
condition|)
return|return
name|wb
operator|->
name|est_throughput
operator|-
name|wa
operator|->
name|est_throughput
return|;
if|if
condition|(
name|IS_5GHZ
argument_list|(
name|wa
operator|->
name|freq
argument_list|)
operator|^
name|IS_5GHZ
argument_list|(
name|wb
operator|->
name|freq
argument_list|)
condition|)
return|return
name|IS_5GHZ
argument_list|(
name|wa
operator|->
name|freq
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/* all things being equal, use SNR; if SNRs are 	 * identical, use quality values since some drivers may only report 	 * that value and leave the signal level zero */
if|if
condition|(
name|snr_b_full
operator|==
name|snr_a_full
condition|)
return|return
name|wb
operator|->
name|qual
operator|-
name|wa
operator|->
name|qual
return|;
return|return
name|snr_b_full
operator|-
name|snr_a_full
return|;
undef|#
directive|undef
name|MIN
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_WPS
end_ifdef

begin_comment
comment|/* Compare function for sorting scan results when searching a WPS AP for  * provisioning. Return>0 if @b is considered better. */
end_comment

begin_function
specifier|static
name|int
name|wpa_scan_result_wps_compar
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|wpa_scan_res
modifier|*
modifier|*
name|_wa
init|=
operator|(
name|void
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|wpa_scan_res
modifier|*
modifier|*
name|_wb
init|=
operator|(
name|void
operator|*
operator|)
name|b
decl_stmt|;
name|struct
name|wpa_scan_res
modifier|*
name|wa
init|=
operator|*
name|_wa
decl_stmt|;
name|struct
name|wpa_scan_res
modifier|*
name|wb
init|=
operator|*
name|_wb
decl_stmt|;
name|int
name|uses_wps_a
decl_stmt|,
name|uses_wps_b
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|wps_a
decl_stmt|,
modifier|*
name|wps_b
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* Optimization - check WPS IE existence before allocated memory and 	 * doing full reassembly. */
name|uses_wps_a
operator|=
name|wpa_scan_get_vendor_ie
argument_list|(
name|wa
argument_list|,
name|WPS_IE_VENDOR_TYPE
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|uses_wps_b
operator|=
name|wpa_scan_get_vendor_ie
argument_list|(
name|wb
argument_list|,
name|WPS_IE_VENDOR_TYPE
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|uses_wps_a
operator|&&
operator|!
name|uses_wps_b
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|uses_wps_a
operator|&&
name|uses_wps_b
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|uses_wps_a
operator|&&
name|uses_wps_b
condition|)
block|{
name|wps_a
operator|=
name|wpa_scan_get_vendor_ie_multi
argument_list|(
name|wa
argument_list|,
name|WPS_IE_VENDOR_TYPE
argument_list|)
expr_stmt|;
name|wps_b
operator|=
name|wpa_scan_get_vendor_ie_multi
argument_list|(
name|wb
argument_list|,
name|WPS_IE_VENDOR_TYPE
argument_list|)
expr_stmt|;
name|res
operator|=
name|wps_ap_priority_compar
argument_list|(
name|wps_a
argument_list|,
name|wps_b
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|wps_a
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|wps_b
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
block|}
comment|/* 	 * Do not use current AP security policy as a sorting criteria during 	 * WPS provisioning step since the AP may get reconfigured at the 	 * completion of provisioning. 	 */
comment|/* all things being equal, use signal level; if signal levels are 	 * identical, use quality values since some drivers may only report 	 * that value and leave the signal level zero */
if|if
condition|(
name|wb
operator|->
name|level
operator|==
name|wa
operator|->
name|level
condition|)
return|return
name|wb
operator|->
name|qual
operator|-
name|wa
operator|->
name|qual
return|;
return|return
name|wb
operator|->
name|level
operator|-
name|wa
operator|->
name|level
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_WPS */
end_comment

begin_function
specifier|static
name|void
name|dump_scan_res
parameter_list|(
name|struct
name|wpa_scan_results
modifier|*
name|scan_res
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CONFIG_NO_STDOUT_DEBUG
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|scan_res
operator|->
name|res
operator|==
name|NULL
operator|||
name|scan_res
operator|->
name|num
operator|==
literal|0
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"Sorted scan results"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scan_res
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpa_scan_res
modifier|*
name|r
init|=
name|scan_res
operator|->
name|res
index|[
name|i
index|]
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|flags
operator|&
name|WPA_SCAN_LEVEL_DBM
condition|)
block|{
name|int
name|noise_valid
init|=
operator|!
operator|(
name|r
operator|->
name|flags
operator|&
name|WPA_SCAN_NOISE_INVALID
operator|)
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
name|MACSTR
literal|" freq=%d qual=%d "
literal|"noise=%d%s level=%d snr=%d%s flags=0x%x age=%u est=%u"
argument_list|,
name|MAC2STR
argument_list|(
name|r
operator|->
name|bssid
argument_list|)
argument_list|,
name|r
operator|->
name|freq
argument_list|,
name|r
operator|->
name|qual
argument_list|,
name|r
operator|->
name|noise
argument_list|,
name|noise_valid
condition|?
literal|""
else|:
literal|"~"
argument_list|,
name|r
operator|->
name|level
argument_list|,
name|r
operator|->
name|snr
argument_list|,
name|r
operator|->
name|snr
operator|>=
name|GREAT_SNR
condition|?
literal|"*"
else|:
literal|""
argument_list|,
name|r
operator|->
name|flags
argument_list|,
name|r
operator|->
name|age
argument_list|,
name|r
operator|->
name|est_throughput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
name|MACSTR
literal|" freq=%d qual=%d "
literal|"noise=%d level=%d flags=0x%x age=%u est=%u"
argument_list|,
name|MAC2STR
argument_list|(
name|r
operator|->
name|bssid
argument_list|)
argument_list|,
name|r
operator|->
name|freq
argument_list|,
name|r
operator|->
name|qual
argument_list|,
name|r
operator|->
name|noise
argument_list|,
name|r
operator|->
name|level
argument_list|,
name|r
operator|->
name|flags
argument_list|,
name|r
operator|->
name|age
argument_list|,
name|r
operator|->
name|est_throughput
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|r
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|ie_len
condition|)
name|wpa_hexdump
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"IEs"
argument_list|,
name|pos
argument_list|,
name|r
operator|->
name|ie_len
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|r
operator|->
name|ie_len
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|beacon_ie_len
condition|)
name|wpa_hexdump
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"Beacon IEs"
argument_list|,
name|pos
argument_list|,
name|r
operator|->
name|beacon_ie_len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CONFIG_NO_STDOUT_DEBUG */
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_filter_bssid_match - Is the specified BSSID allowed  * @wpa_s: Pointer to wpa_supplicant data  * @bssid: BSSID to check  * Returns: 0 if the BSSID is filtered or 1 if not  *  * This function is used to filter out specific BSSIDs from scan reslts mainly  * for testing purposes (SET bssid_filter ctrl_iface command).  */
end_comment

begin_function
name|int
name|wpa_supplicant_filter_bssid_match
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|bssid_filter
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wpa_s
operator|->
name|bssid_filter_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|os_memcmp
argument_list|(
name|wpa_s
operator|->
name|bssid_filter
operator|+
name|i
operator|*
name|ETH_ALEN
argument_list|,
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filter_scan_res
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_scan_results
modifier|*
name|res
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|bssid_filter
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wpa_supplicant_filter_bssid_match
argument_list|(
name|wpa_s
argument_list|,
name|res
operator|->
name|res
index|[
name|i
index|]
operator|->
name|bssid
argument_list|)
condition|)
block|{
name|res
operator|->
name|res
index|[
name|j
operator|++
index|]
operator|=
name|res
operator|->
name|res
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|os_free
argument_list|(
name|res
operator|->
name|res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|res
operator|->
name|res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|res
operator|->
name|num
operator|!=
name|j
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Filtered out %d scan results"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|res
operator|->
name|num
operator|-
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|num
operator|=
name|j
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Noise floor values to use when we have signal strength  * measurements, but no noise floor measurments. These values were  * measured in an office environment with many APs.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_NOISE_FLOOR_2GHZ
value|(-89)
end_define

begin_define
define|#
directive|define
name|DEFAULT_NOISE_FLOOR_5GHZ
value|(-92)
end_define

begin_function
specifier|static
name|void
name|scan_snr
parameter_list|(
name|struct
name|wpa_scan_res
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|res
operator|->
name|flags
operator|&
name|WPA_SCAN_NOISE_INVALID
condition|)
block|{
name|res
operator|->
name|noise
operator|=
name|IS_5GHZ
argument_list|(
name|res
operator|->
name|freq
argument_list|)
condition|?
name|DEFAULT_NOISE_FLOOR_5GHZ
else|:
name|DEFAULT_NOISE_FLOOR_2GHZ
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|flags
operator|&
name|WPA_SCAN_LEVEL_DBM
condition|)
block|{
name|res
operator|->
name|snr
operator|=
name|res
operator|->
name|level
operator|-
name|res
operator|->
name|noise
expr_stmt|;
block|}
else|else
block|{
comment|/* Level is not in dBm, so we can't calculate 		 * SNR. Just use raw level (units unknown). */
name|res
operator|->
name|snr
operator|=
name|res
operator|->
name|level
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|max_ht20_rate
parameter_list|(
name|int
name|snr
parameter_list|)
block|{
if|if
condition|(
name|snr
operator|<
literal|6
condition|)
return|return
literal|6500
return|;
comment|/* HT20 MCS0 */
if|if
condition|(
name|snr
operator|<
literal|8
condition|)
return|return
literal|13000
return|;
comment|/* HT20 MCS1 */
if|if
condition|(
name|snr
operator|<
literal|13
condition|)
return|return
literal|19500
return|;
comment|/* HT20 MCS2 */
if|if
condition|(
name|snr
operator|<
literal|17
condition|)
return|return
literal|26000
return|;
comment|/* HT20 MCS3 */
if|if
condition|(
name|snr
operator|<
literal|20
condition|)
return|return
literal|39000
return|;
comment|/* HT20 MCS4 */
if|if
condition|(
name|snr
operator|<
literal|23
condition|)
return|return
literal|52000
return|;
comment|/* HT20 MCS5 */
if|if
condition|(
name|snr
operator|<
literal|24
condition|)
return|return
literal|58500
return|;
comment|/* HT20 MCS6 */
return|return
literal|65000
return|;
comment|/* HT20 MCS7 */
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|max_ht40_rate
parameter_list|(
name|int
name|snr
parameter_list|)
block|{
if|if
condition|(
name|snr
operator|<
literal|3
condition|)
return|return
literal|13500
return|;
comment|/* HT40 MCS0 */
if|if
condition|(
name|snr
operator|<
literal|6
condition|)
return|return
literal|27000
return|;
comment|/* HT40 MCS1 */
if|if
condition|(
name|snr
operator|<
literal|10
condition|)
return|return
literal|40500
return|;
comment|/* HT40 MCS2 */
if|if
condition|(
name|snr
operator|<
literal|15
condition|)
return|return
literal|54000
return|;
comment|/* HT40 MCS3 */
if|if
condition|(
name|snr
operator|<
literal|17
condition|)
return|return
literal|81000
return|;
comment|/* HT40 MCS4 */
if|if
condition|(
name|snr
operator|<
literal|22
condition|)
return|return
literal|108000
return|;
comment|/* HT40 MCS5 */
if|if
condition|(
name|snr
operator|<
literal|24
condition|)
return|return
literal|121500
return|;
comment|/* HT40 MCS6 */
return|return
literal|135000
return|;
comment|/* HT40 MCS7 */
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|max_vht80_rate
parameter_list|(
name|int
name|snr
parameter_list|)
block|{
if|if
condition|(
name|snr
operator|<
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|snr
operator|<
literal|2
condition|)
return|return
literal|29300
return|;
comment|/* VHT80 MCS0 */
if|if
condition|(
name|snr
operator|<
literal|5
condition|)
return|return
literal|58500
return|;
comment|/* VHT80 MCS1 */
if|if
condition|(
name|snr
operator|<
literal|9
condition|)
return|return
literal|87800
return|;
comment|/* VHT80 MCS2 */
if|if
condition|(
name|snr
operator|<
literal|11
condition|)
return|return
literal|117000
return|;
comment|/* VHT80 MCS3 */
if|if
condition|(
name|snr
operator|<
literal|15
condition|)
return|return
literal|175500
return|;
comment|/* VHT80 MCS4 */
if|if
condition|(
name|snr
operator|<
literal|16
condition|)
return|return
literal|234000
return|;
comment|/* VHT80 MCS5 */
if|if
condition|(
name|snr
operator|<
literal|18
condition|)
return|return
literal|263300
return|;
comment|/* VHT80 MCS6 */
if|if
condition|(
name|snr
operator|<
literal|20
condition|)
return|return
literal|292500
return|;
comment|/* VHT80 MCS7 */
if|if
condition|(
name|snr
operator|<
literal|22
condition|)
return|return
literal|351000
return|;
comment|/* VHT80 MCS8 */
return|return
literal|390000
return|;
comment|/* VHT80 MCS9 */
block|}
end_function

begin_function
specifier|static
name|void
name|scan_est_throughput
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_scan_res
modifier|*
name|res
parameter_list|)
block|{
name|enum
name|local_hw_capab
name|capab
init|=
name|wpa_s
operator|->
name|hw_capab
decl_stmt|;
name|int
name|rate
decl_stmt|;
comment|/* max legacy rate in 500 kb/s units */
specifier|const
name|u8
modifier|*
name|ie
decl_stmt|;
name|unsigned
name|int
name|est
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|snr
init|=
name|res
operator|->
name|snr
decl_stmt|;
if|if
condition|(
name|res
operator|->
name|est_throughput
condition|)
return|return;
comment|/* Get maximum legacy rate */
name|rate
operator|=
name|wpa_scan_get_max_rate
argument_list|(
name|res
argument_list|)
expr_stmt|;
comment|/* Limit based on estimated SNR */
if|if
condition|(
name|rate
operator|>
literal|1
operator|*
literal|2
operator|&&
name|snr
operator|<
literal|1
condition|)
name|rate
operator|=
literal|1
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|2
operator|*
literal|2
operator|&&
name|snr
operator|<
literal|4
condition|)
name|rate
operator|=
literal|2
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|6
operator|*
literal|2
operator|&&
name|snr
operator|<
literal|5
condition|)
name|rate
operator|=
literal|6
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|9
operator|*
literal|2
operator|&&
name|snr
operator|<
literal|6
condition|)
name|rate
operator|=
literal|9
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|12
operator|*
literal|2
operator|&&
name|snr
operator|<
literal|7
condition|)
name|rate
operator|=
literal|12
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|18
operator|*
literal|2
operator|&&
name|snr
operator|<
literal|10
condition|)
name|rate
operator|=
literal|18
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|24
operator|*
literal|2
operator|&&
name|snr
operator|<
literal|11
condition|)
name|rate
operator|=
literal|24
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|36
operator|*
literal|2
operator|&&
name|snr
operator|<
literal|15
condition|)
name|rate
operator|=
literal|36
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|48
operator|*
literal|2
operator|&&
name|snr
operator|<
literal|19
condition|)
name|rate
operator|=
literal|48
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|54
operator|*
literal|2
operator|&&
name|snr
operator|<
literal|21
condition|)
name|rate
operator|=
literal|54
operator|*
literal|2
expr_stmt|;
name|est
operator|=
name|rate
operator|*
literal|500
expr_stmt|;
if|if
condition|(
name|capab
operator|==
name|CAPAB_HT
operator|||
name|capab
operator|==
name|CAPAB_HT40
operator|||
name|capab
operator|==
name|CAPAB_VHT
condition|)
block|{
name|ie
operator|=
name|wpa_scan_get_ie
argument_list|(
name|res
argument_list|,
name|WLAN_EID_HT_CAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
condition|)
block|{
name|tmp
operator|=
name|max_ht20_rate
argument_list|(
name|snr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|est
condition|)
name|est
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|capab
operator|==
name|CAPAB_HT40
operator|||
name|capab
operator|==
name|CAPAB_VHT
condition|)
block|{
name|ie
operator|=
name|wpa_scan_get_ie
argument_list|(
name|res
argument_list|,
name|WLAN_EID_HT_OPERATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|&&
name|ie
index|[
literal|1
index|]
operator|>=
literal|2
operator|&&
operator|(
name|ie
index|[
literal|3
index|]
operator|&
name|HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK
operator|)
condition|)
block|{
name|tmp
operator|=
name|max_ht40_rate
argument_list|(
name|snr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|est
condition|)
name|est
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|capab
operator|==
name|CAPAB_VHT
condition|)
block|{
comment|/* Use +1 to assume VHT is always faster than HT */
name|ie
operator|=
name|wpa_scan_get_ie
argument_list|(
name|res
argument_list|,
name|WLAN_EID_VHT_CAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
condition|)
block|{
name|tmp
operator|=
name|max_ht20_rate
argument_list|(
name|snr
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|est
condition|)
name|est
operator|=
name|tmp
expr_stmt|;
name|ie
operator|=
name|wpa_scan_get_ie
argument_list|(
name|res
argument_list|,
name|WLAN_EID_HT_OPERATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|&&
name|ie
index|[
literal|1
index|]
operator|>=
literal|2
operator|&&
operator|(
name|ie
index|[
literal|3
index|]
operator|&
name|HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK
operator|)
condition|)
block|{
name|tmp
operator|=
name|max_ht40_rate
argument_list|(
name|snr
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|est
condition|)
name|est
operator|=
name|tmp
expr_stmt|;
block|}
name|ie
operator|=
name|wpa_scan_get_ie
argument_list|(
name|res
argument_list|,
name|WLAN_EID_VHT_OPERATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|&&
name|ie
index|[
literal|1
index|]
operator|>=
literal|1
operator|&&
operator|(
name|ie
index|[
literal|2
index|]
operator|&
name|VHT_OPMODE_CHANNEL_WIDTH_MASK
operator|)
condition|)
block|{
name|tmp
operator|=
name|max_vht80_rate
argument_list|(
name|snr
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|est
condition|)
name|est
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
comment|/* TODO: channel utilization and AP load (e.g., from AP Beacon) */
name|res
operator|->
name|est_throughput
operator|=
name|est
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_get_scan_results - Get scan results  * @wpa_s: Pointer to wpa_supplicant data  * @info: Information about what was scanned or %NULL if not available  * @new_scan: Whether a new scan was performed  * Returns: Scan results, %NULL on failure  *  * This function request the current scan results from the driver and updates  * the local BSS list wpa_s->bss. The caller is responsible for freeing the  * results with wpa_scan_results_free().  */
end_comment

begin_function
name|struct
name|wpa_scan_results
modifier|*
name|wpa_supplicant_get_scan_results
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|scan_info
modifier|*
name|info
parameter_list|,
name|int
name|new_scan
parameter_list|)
block|{
name|struct
name|wpa_scan_results
modifier|*
name|scan_res
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
init|=
name|wpa_scan_result_compar
function_decl|;
name|scan_res
operator|=
name|wpa_drv_get_scan_results2
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan_res
operator|==
name|NULL
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Failed to get scan results"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|scan_res
operator|->
name|fetch_time
operator|.
name|sec
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Make sure we have a valid timestamp if the driver wrapper 		 * does not set this. 		 */
name|os_get_reltime
argument_list|(
operator|&
name|scan_res
operator|->
name|fetch_time
argument_list|)
expr_stmt|;
block|}
name|filter_scan_res
argument_list|(
name|wpa_s
argument_list|,
name|scan_res
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scan_res
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpa_scan_res
modifier|*
name|scan_res_item
init|=
name|scan_res
operator|->
name|res
index|[
name|i
index|]
decl_stmt|;
name|scan_snr
argument_list|(
name|scan_res_item
argument_list|)
expr_stmt|;
name|scan_est_throughput
argument_list|(
name|wpa_s
argument_list|,
name|scan_res_item
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_WPS
if|if
condition|(
name|wpas_wps_searching
argument_list|(
name|wpa_s
argument_list|)
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPS: Order scan results with WPS "
literal|"provisioning rules"
argument_list|)
expr_stmt|;
name|compar
operator|=
name|wpa_scan_result_wps_compar
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CONFIG_WPS */
name|qsort
argument_list|(
name|scan_res
operator|->
name|res
argument_list|,
name|scan_res
operator|->
name|num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpa_scan_res
operator|*
argument_list|)
argument_list|,
name|compar
argument_list|)
expr_stmt|;
name|dump_scan_res
argument_list|(
name|scan_res
argument_list|)
expr_stmt|;
name|wpa_bss_update_start
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scan_res
operator|->
name|num
condition|;
name|i
operator|++
control|)
name|wpa_bss_update_scan_res
argument_list|(
name|wpa_s
argument_list|,
name|scan_res
operator|->
name|res
index|[
name|i
index|]
argument_list|,
operator|&
name|scan_res
operator|->
name|fetch_time
argument_list|)
expr_stmt|;
name|wpa_bss_update_end
argument_list|(
name|wpa_s
argument_list|,
name|info
argument_list|,
name|new_scan
argument_list|)
expr_stmt|;
return|return
name|scan_res
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_update_scan_results - Update scan results from the driver  * @wpa_s: Pointer to wpa_supplicant data  * Returns: 0 on success, -1 on failure  *  * This function updates the BSS table within wpa_supplicant based on the  * currently available scan results from the driver without requesting a new  * scan. This is used in cases where the driver indicates an association  * (including roaming within ESS) and wpa_supplicant does not yet have the  * needed information to complete the connection (e.g., to perform validation  * steps in 4-way handshake).  */
end_comment

begin_function
name|int
name|wpa_supplicant_update_scan_results
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpa_scan_results
modifier|*
name|scan_res
decl_stmt|;
name|scan_res
operator|=
name|wpa_supplicant_get_scan_results
argument_list|(
name|wpa_s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan_res
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_scan_results_free
argument_list|(
name|scan_res
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * scan_only_handler - Reports scan results  */
end_comment

begin_function
name|void
name|scan_only_handler
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_scan_results
modifier|*
name|scan_res
parameter_list|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Scan-only results received"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|last_scan_req
operator|==
name|MANUAL_SCAN_REQ
operator|&&
name|wpa_s
operator|->
name|manual_scan_use_id
operator|&&
name|wpa_s
operator|->
name|own_scan_running
condition|)
block|{
name|wpa_msg_ctrl
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_SCAN_RESULTS
literal|"id=%u"
argument_list|,
name|wpa_s
operator|->
name|manual_scan_id
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|manual_scan_use_id
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|wpa_msg_ctrl
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_SCAN_RESULTS
argument_list|)
expr_stmt|;
block|}
name|wpas_notify_scan_results
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpas_notify_scan_done
argument_list|(
name|wpa_s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|scan_work
condition|)
block|{
name|struct
name|wpa_radio_work
modifier|*
name|work
init|=
name|wpa_s
operator|->
name|scan_work
decl_stmt|;
name|wpa_s
operator|->
name|scan_work
operator|=
name|NULL
expr_stmt|;
name|radio_work_done
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|wpas_scan_scheduled
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
return|return
name|eloop_is_timeout_registered
argument_list|(
name|wpa_supplicant_scan
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|wpa_driver_scan_params
modifier|*
name|wpa_scan_clone_params
parameter_list|(
specifier|const
name|struct
name|wpa_driver_scan_params
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|wpa_driver_scan_params
modifier|*
name|params
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|u8
modifier|*
name|n
decl_stmt|;
name|params
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|num_ssids
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|src
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid
condition|)
block|{
name|n
operator|=
name|os_malloc
argument_list|(
name|src
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|os_memcpy
argument_list|(
name|n
argument_list|,
name|src
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid
argument_list|,
name|src
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid_len
argument_list|)
expr_stmt|;
name|params
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid
operator|=
name|n
expr_stmt|;
name|params
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid_len
operator|=
name|src
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid_len
expr_stmt|;
block|}
block|}
name|params
operator|->
name|num_ssids
operator|=
name|src
operator|->
name|num_ssids
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|extra_ies
condition|)
block|{
name|n
operator|=
name|os_malloc
argument_list|(
name|src
operator|->
name|extra_ies_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|os_memcpy
argument_list|(
name|n
argument_list|,
name|src
operator|->
name|extra_ies
argument_list|,
name|src
operator|->
name|extra_ies_len
argument_list|)
expr_stmt|;
name|params
operator|->
name|extra_ies
operator|=
name|n
expr_stmt|;
name|params
operator|->
name|extra_ies_len
operator|=
name|src
operator|->
name|extra_ies_len
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|->
name|freqs
condition|)
block|{
name|int
name|len
init|=
name|int_array_len
argument_list|(
name|src
operator|->
name|freqs
argument_list|)
decl_stmt|;
name|params
operator|->
name|freqs
operator|=
name|os_malloc
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|freqs
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|os_memcpy
argument_list|(
name|params
operator|->
name|freqs
argument_list|,
name|src
operator|->
name|freqs
argument_list|,
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|->
name|filter_ssids
condition|)
block|{
name|params
operator|->
name|filter_ssids
operator|=
name|os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|params
operator|->
name|filter_ssids
argument_list|)
operator|*
name|src
operator|->
name|num_filter_ssids
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|filter_ssids
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|os_memcpy
argument_list|(
name|params
operator|->
name|filter_ssids
argument_list|,
name|src
operator|->
name|filter_ssids
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|params
operator|->
name|filter_ssids
argument_list|)
operator|*
name|src
operator|->
name|num_filter_ssids
argument_list|)
expr_stmt|;
name|params
operator|->
name|num_filter_ssids
operator|=
name|src
operator|->
name|num_filter_ssids
expr_stmt|;
block|}
name|params
operator|->
name|filter_rssi
operator|=
name|src
operator|->
name|filter_rssi
expr_stmt|;
name|params
operator|->
name|p2p_probe
operator|=
name|src
operator|->
name|p2p_probe
expr_stmt|;
name|params
operator|->
name|only_new_results
operator|=
name|src
operator|->
name|only_new_results
expr_stmt|;
name|params
operator|->
name|low_priority
operator|=
name|src
operator|->
name|low_priority
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|mac_addr_rand
condition|)
block|{
name|params
operator|->
name|mac_addr_rand
operator|=
name|src
operator|->
name|mac_addr_rand
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|mac_addr
operator|&&
name|src
operator|->
name|mac_addr_mask
condition|)
block|{
name|u8
modifier|*
name|mac_addr
decl_stmt|;
name|mac_addr
operator|=
name|os_malloc
argument_list|(
literal|2
operator|*
name|ETH_ALEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mac_addr
condition|)
goto|goto
name|failed
goto|;
name|os_memcpy
argument_list|(
name|mac_addr
argument_list|,
name|src
operator|->
name|mac_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|mac_addr
operator|+
name|ETH_ALEN
argument_list|,
name|src
operator|->
name|mac_addr_mask
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|params
operator|->
name|mac_addr
operator|=
name|mac_addr
expr_stmt|;
name|params
operator|->
name|mac_addr_mask
operator|=
name|mac_addr
operator|+
name|ETH_ALEN
expr_stmt|;
block|}
block|}
return|return
name|params
return|;
name|failed
label|:
name|wpa_scan_free_params
argument_list|(
name|params
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|wpa_scan_free_params
parameter_list|(
name|struct
name|wpa_driver_scan_params
modifier|*
name|params
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|params
operator|->
name|num_ssids
condition|;
name|i
operator|++
control|)
name|os_free
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|params
operator|->
name|ssids
index|[
name|i
index|]
operator|.
name|ssid
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|params
operator|->
name|extra_ies
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|params
operator|->
name|freqs
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|params
operator|->
name|filter_ssids
argument_list|)
expr_stmt|;
comment|/* 	 * Note: params->mac_addr_mask points to same memory allocation and 	 * must not be freed separately. 	 */
name|os_free
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|params
operator|->
name|mac_addr
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|wpas_start_pno
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|interval
decl_stmt|,
name|prio
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|num_ssid
decl_stmt|,
name|num_match_ssid
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|ssid
decl_stmt|;
name|struct
name|wpa_driver_scan_params
name|params
decl_stmt|;
if|if
condition|(
operator|!
name|wpa_s
operator|->
name|sched_scan_supported
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|wpa_s
operator|->
name|pno
operator|||
name|wpa_s
operator|->
name|pno_sched_pending
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|wpa_s
operator|->
name|wpa_state
operator|>
name|WPA_SCANNING
operator|)
operator|&&
operator|(
name|wpa_s
operator|->
name|wpa_state
operator|<=
name|WPA_COMPLETED
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"PNO: In assoc process"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EAGAIN
return|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|wpa_state
operator|==
name|WPA_SCANNING
condition|)
block|{
name|wpa_supplicant_cancel_scan
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|sched_scanning
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Schedule PNO on completion of "
literal|"ongoing sched scan"
argument_list|)
expr_stmt|;
name|wpa_supplicant_cancel_sched_scan
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|pno_sched_pending
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|os_memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|num_ssid
operator|=
name|num_match_ssid
operator|=
literal|0
expr_stmt|;
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
expr_stmt|;
while|while
condition|(
name|ssid
condition|)
block|{
if|if
condition|(
operator|!
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
condition|)
block|{
name|num_match_ssid
operator|++
expr_stmt|;
if|if
condition|(
name|ssid
operator|->
name|scan_ssid
condition|)
name|num_ssid
operator|++
expr_stmt|;
block|}
name|ssid
operator|=
name|ssid
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|num_match_ssid
operator|==
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"PNO: No configured SSIDs"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|num_match_ssid
operator|>
name|num_ssid
condition|)
block|{
name|params
operator|.
name|num_ssids
operator|++
expr_stmt|;
comment|/* wildcard */
name|num_ssid
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|num_ssid
operator|>
name|WPAS_MAX_SCAN_SSIDS
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"PNO: Use only the first %u SSIDs from "
literal|"%u"
argument_list|,
name|WPAS_MAX_SCAN_SSIDS
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|num_ssid
argument_list|)
expr_stmt|;
name|num_ssid
operator|=
name|WPAS_MAX_SCAN_SSIDS
expr_stmt|;
block|}
if|if
condition|(
name|num_match_ssid
operator|>
name|wpa_s
operator|->
name|max_match_sets
condition|)
block|{
name|num_match_ssid
operator|=
name|wpa_s
operator|->
name|max_match_sets
expr_stmt|;
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"PNO: Too many SSIDs to match"
argument_list|)
expr_stmt|;
block|}
name|params
operator|.
name|filter_ssids
operator|=
name|os_calloc
argument_list|(
name|num_match_ssid
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpa_driver_scan_filter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|filter_ssids
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|i
operator|=
literal|0
expr_stmt|;
name|prio
operator|=
literal|0
expr_stmt|;
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|pssid
index|[
name|prio
index|]
expr_stmt|;
while|while
condition|(
name|ssid
condition|)
block|{
if|if
condition|(
operator|!
name|wpas_network_disabled
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
condition|)
block|{
if|if
condition|(
name|ssid
operator|->
name|scan_ssid
operator|&&
name|params
operator|.
name|num_ssids
operator|<
name|num_ssid
condition|)
block|{
name|params
operator|.
name|ssids
index|[
name|params
operator|.
name|num_ssids
index|]
operator|.
name|ssid
operator|=
name|ssid
operator|->
name|ssid
expr_stmt|;
name|params
operator|.
name|ssids
index|[
name|params
operator|.
name|num_ssids
index|]
operator|.
name|ssid_len
operator|=
name|ssid
operator|->
name|ssid_len
expr_stmt|;
name|params
operator|.
name|num_ssids
operator|++
expr_stmt|;
block|}
name|os_memcpy
argument_list|(
name|params
operator|.
name|filter_ssids
index|[
name|i
index|]
operator|.
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|params
operator|.
name|filter_ssids
index|[
name|i
index|]
operator|.
name|ssid_len
operator|=
name|ssid
operator|->
name|ssid_len
expr_stmt|;
name|params
operator|.
name|num_filter_ssids
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|num_match_ssid
condition|)
break|break;
block|}
if|if
condition|(
name|ssid
operator|->
name|pnext
condition|)
name|ssid
operator|=
name|ssid
operator|->
name|pnext
expr_stmt|;
elseif|else
if|if
condition|(
name|prio
operator|+
literal|1
operator|==
name|wpa_s
operator|->
name|conf
operator|->
name|num_prio
condition|)
break|break;
else|else
name|ssid
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|pssid
index|[
operator|++
name|prio
index|]
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|filter_rssi
condition|)
name|params
operator|.
name|filter_rssi
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|filter_rssi
expr_stmt|;
name|interval
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|sched_scan_interval
condition|?
name|wpa_s
operator|->
name|conf
operator|->
name|sched_scan_interval
else|:
literal|10
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|freqs
operator|==
name|NULL
operator|&&
name|wpa_s
operator|->
name|manual_sched_scan_freqs
condition|)
block|{
name|wpa_dbg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Limit sched scan to specified channels"
argument_list|)
expr_stmt|;
name|params
operator|.
name|freqs
operator|=
name|wpa_s
operator|->
name|manual_sched_scan_freqs
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|mac_addr_rand_enable
operator|&
name|MAC_ADDR_RAND_PNO
condition|)
block|{
name|params
operator|.
name|mac_addr_rand
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|mac_addr_pno
condition|)
block|{
name|params
operator|.
name|mac_addr
operator|=
name|wpa_s
operator|->
name|mac_addr_pno
expr_stmt|;
name|params
operator|.
name|mac_addr_mask
operator|=
name|wpa_s
operator|->
name|mac_addr_pno
operator|+
name|ETH_ALEN
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|wpa_supplicant_start_sched_scan
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|params
argument_list|,
name|interval
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|params
operator|.
name|filter_ssids
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|wpa_s
operator|->
name|pno
operator|=
literal|1
expr_stmt|;
else|else
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_ERROR
argument_list|,
literal|"Failed to schedule PNO"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|wpas_stop_pno
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|wpa_s
operator|->
name|pno
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|wpa_supplicant_stop_sched_scan
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|pno
operator|=
literal|0
expr_stmt|;
name|wpa_s
operator|->
name|pno_sched_pending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|wpa_state
operator|==
name|WPA_SCANNING
condition|)
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|wpas_mac_addr_rand_scan_clear
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|)
block|{
name|type
operator|&=
name|MAC_ADDR_RAND_ALL
expr_stmt|;
name|wpa_s
operator|->
name|mac_addr_rand_enable
operator|&=
operator|~
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|MAC_ADDR_RAND_SCAN
condition|)
block|{
name|os_free
argument_list|(
name|wpa_s
operator|->
name|mac_addr_scan
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|mac_addr_scan
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|&
name|MAC_ADDR_RAND_SCHED_SCAN
condition|)
block|{
name|os_free
argument_list|(
name|wpa_s
operator|->
name|mac_addr_sched_scan
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|mac_addr_sched_scan
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|&
name|MAC_ADDR_RAND_PNO
condition|)
block|{
name|os_free
argument_list|(
name|wpa_s
operator|->
name|mac_addr_pno
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|mac_addr_pno
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|wpas_mac_addr_rand_scan_set
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|mask
parameter_list|)
block|{
name|u8
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|wpas_mac_addr_rand_scan_clear
argument_list|(
name|wpa_s
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|tmp
operator|=
name|os_malloc
argument_list|(
literal|2
operator|*
name|ETH_ALEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
operator|-
literal|1
return|;
name|os_memcpy
argument_list|(
name|tmp
argument_list|,
name|addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|tmp
operator|+
name|ETH_ALEN
argument_list|,
name|mask
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|MAC_ADDR_RAND_SCAN
condition|)
block|{
name|wpa_s
operator|->
name|mac_addr_scan
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|MAC_ADDR_RAND_SCHED_SCAN
condition|)
block|{
name|wpa_s
operator|->
name|mac_addr_sched_scan
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|MAC_ADDR_RAND_PNO
condition|)
block|{
name|wpa_s
operator|->
name|mac_addr_pno
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"scan: Invalid MAC randomization type=0x%x"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_s
operator|->
name|mac_addr_rand_enable
operator||=
name|type
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

