begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * wpa_supplicant D-Bus control interface - common functionality  * Copyright (c) 2006, Dan Williams<dcbw@redhat.com> and Red Hat, Inc.  * Copyright (c) 2009, Witold Sowa<witold.sowa@gmail.com>  * Copyright (c) 2009, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"utils/includes.h"
end_include

begin_include
include|#
directive|include
file|<dbus/dbus.h>
end_include

begin_include
include|#
directive|include
file|"utils/common.h"
end_include

begin_include
include|#
directive|include
file|"utils/eloop.h"
end_include

begin_include
include|#
directive|include
file|"dbus_common.h"
end_include

begin_include
include|#
directive|include
file|"dbus_common_i.h"
end_include

begin_include
include|#
directive|include
file|"dbus_new.h"
end_include

begin_include
include|#
directive|include
file|"dbus_old.h"
end_include

begin_include
include|#
directive|include
file|"../wpa_supplicant_i.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SIGPOLL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGIO
end_ifdef

begin_comment
comment|/*  * If we do not have SIGPOLL, try to use SIGIO instead. This is needed for  * FreeBSD.  */
end_comment

begin_define
define|#
directive|define
name|SIGPOLL
value|SIGIO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dispatch_data
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|)
block|{
while|while
condition|(
name|dbus_connection_get_dispatch_status
argument_list|(
name|con
argument_list|)
operator|==
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
name|dbus_connection_dispatch
argument_list|(
name|con
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * dispatch_initial_dbus_messages - Dispatch initial dbus messages after  *     claiming bus name  * @eloop_ctx: the DBusConnection to dispatch on  * @timeout_ctx: unused  *  * If clients are quick to notice that service claimed its bus name,  * there may have been messages that came in before initialization was  * all finished.  Dispatch those here.  */
end_comment

begin_function
specifier|static
name|void
name|dispatch_initial_dbus_messages
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|DBusConnection
modifier|*
name|con
init|=
name|eloop_ctx
decl_stmt|;
name|dispatch_data
argument_list|(
name|con
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_watch
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
parameter_list|,
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|eloop_event_type
name|type
parameter_list|)
block|{
name|dbus_connection_ref
argument_list|(
name|priv
operator|->
name|con
argument_list|)
expr_stmt|;
name|priv
operator|->
name|should_dispatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|EVENT_TYPE_READ
condition|)
name|dbus_watch_handle
argument_list|(
name|watch
argument_list|,
name|DBUS_WATCH_READABLE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|EVENT_TYPE_WRITE
condition|)
name|dbus_watch_handle
argument_list|(
name|watch
argument_list|,
name|DBUS_WATCH_WRITABLE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|EVENT_TYPE_EXCEPTION
condition|)
name|dbus_watch_handle
argument_list|(
name|watch
argument_list|,
name|DBUS_WATCH_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|should_dispatch
condition|)
block|{
name|dispatch_data
argument_list|(
name|priv
operator|->
name|con
argument_list|)
expr_stmt|;
name|priv
operator|->
name|should_dispatch
operator|=
literal|0
expr_stmt|;
block|}
name|dbus_connection_unref
argument_list|(
name|priv
operator|->
name|con
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_watch_exception
parameter_list|(
name|int
name|sock
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|process_watch
argument_list|(
name|eloop_ctx
argument_list|,
name|sock_ctx
argument_list|,
name|EVENT_TYPE_EXCEPTION
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_watch_read
parameter_list|(
name|int
name|sock
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|process_watch
argument_list|(
name|eloop_ctx
argument_list|,
name|sock_ctx
argument_list|,
name|EVENT_TYPE_READ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_watch_write
parameter_list|(
name|int
name|sock
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|process_watch
argument_list|(
name|eloop_ctx
argument_list|,
name|sock_ctx
argument_list|,
name|EVENT_TYPE_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dbus_bool_t
name|add_watch
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|dbus_watch_get_enabled
argument_list|(
name|watch
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|flags
operator|=
name|dbus_watch_get_flags
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|fd
operator|=
name|dbus_watch_get_unix_fd
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|eloop_register_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_EXCEPTION
argument_list|,
name|process_watch_exception
argument_list|,
name|priv
argument_list|,
name|watch
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_READABLE
condition|)
block|{
name|eloop_register_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_READ
argument_list|,
name|process_watch_read
argument_list|,
name|priv
argument_list|,
name|watch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_WRITABLE
condition|)
block|{
name|eloop_register_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_WRITE
argument_list|,
name|process_watch_write
argument_list|,
name|priv
argument_list|,
name|watch
argument_list|)
expr_stmt|;
block|}
name|dbus_watch_set_data
argument_list|(
name|watch
argument_list|,
name|priv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_watch
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|flags
operator|=
name|dbus_watch_get_flags
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|fd
operator|=
name|dbus_watch_get_unix_fd
argument_list|(
name|watch
argument_list|)
expr_stmt|;
name|eloop_unregister_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_EXCEPTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_READABLE
condition|)
name|eloop_unregister_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DBUS_WATCH_WRITABLE
condition|)
name|eloop_unregister_sock
argument_list|(
name|fd
argument_list|,
name|EVENT_TYPE_WRITE
argument_list|)
expr_stmt|;
name|dbus_watch_set_data
argument_list|(
name|watch
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|watch_toggled
parameter_list|(
name|DBusWatch
modifier|*
name|watch
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|dbus_watch_get_enabled
argument_list|(
name|watch
argument_list|)
condition|)
name|add_watch
argument_list|(
name|watch
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|remove_watch
argument_list|(
name|watch
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|DBusTimeout
modifier|*
name|timeout
init|=
name|sock_ctx
decl_stmt|;
name|dbus_timeout_handle
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dbus_bool_t
name|add_timeout
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|dbus_timeout_get_enabled
argument_list|(
name|timeout
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
name|dbus_timeout_get_interval
argument_list|(
name|timeout
argument_list|)
operator|*
literal|1000
argument_list|,
name|process_timeout
argument_list|,
name|priv
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|dbus_timeout_set_data
argument_list|(
name|timeout
argument_list|,
name|priv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_timeout
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
init|=
name|data
decl_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|process_timeout
argument_list|,
name|priv
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|dbus_timeout_set_data
argument_list|(
name|timeout
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timeout_toggled
parameter_list|(
name|DBusTimeout
modifier|*
name|timeout
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|dbus_timeout_get_enabled
argument_list|(
name|timeout
argument_list|)
condition|)
name|add_timeout
argument_list|(
name|timeout
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|remove_timeout
argument_list|(
name|timeout
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_wakeup_main
parameter_list|(
name|int
name|sig
parameter_list|,
name|void
modifier|*
name|signal_ctx
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
init|=
name|signal_ctx
decl_stmt|;
if|if
condition|(
name|sig
operator|!=
name|SIGPOLL
operator|||
operator|!
name|priv
operator|->
name|con
condition|)
return|return;
if|if
condition|(
name|dbus_connection_get_dispatch_status
argument_list|(
name|priv
operator|->
name|con
argument_list|)
operator|!=
name|DBUS_DISPATCH_DATA_REMAINS
condition|)
return|return;
comment|/* Only dispatch once - we do not want to starve other events */
name|dbus_connection_ref
argument_list|(
name|priv
operator|->
name|con
argument_list|)
expr_stmt|;
name|dbus_connection_dispatch
argument_list|(
name|priv
operator|->
name|con
argument_list|)
expr_stmt|;
name|dbus_connection_unref
argument_list|(
name|priv
operator|->
name|con
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wakeup_main - Attempt to wake our mainloop up  * @data: dbus control interface private data  *  * Try to wake up the main eloop so it will process  * dbus events that may have happened.  */
end_comment

begin_function
specifier|static
name|void
name|wakeup_main
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
init|=
name|data
decl_stmt|;
comment|/* Use SIGPOLL to break out of the eloop select() */
name|raise
argument_list|(
name|SIGPOLL
argument_list|)
expr_stmt|;
name|priv
operator|->
name|should_dispatch
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * integrate_with_eloop - Register our mainloop integration with dbus  * @connection: connection to the system message bus  * @priv: a dbus control interface data structure  * Returns: 0 on success, -1 on failure  */
end_comment

begin_function
specifier|static
name|int
name|integrate_with_eloop
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dbus_connection_set_watch_functions
argument_list|(
name|priv
operator|->
name|con
argument_list|,
name|add_watch
argument_list|,
name|remove_watch
argument_list|,
name|watch_toggled
argument_list|,
name|priv
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|dbus_connection_set_timeout_functions
argument_list|(
name|priv
operator|->
name|con
argument_list|,
name|add_timeout
argument_list|,
name|remove_timeout
argument_list|,
name|timeout_toggled
argument_list|,
name|priv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Failed to set callback functions"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|eloop_register_signal
argument_list|(
name|SIGPOLL
argument_list|,
name|process_wakeup_main
argument_list|,
name|priv
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|dbus_connection_set_wakeup_main_function
argument_list|(
name|priv
operator|->
name|con
argument_list|,
name|wakeup_main
argument_list|,
name|priv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|DBusHandlerResult
name|disconnect_filter
parameter_list|(
name|DBusConnection
modifier|*
name|conn
parameter_list|,
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
init|=
name|data
decl_stmt|;
if|if
condition|(
name|dbus_message_is_signal
argument_list|(
name|message
argument_list|,
name|DBUS_INTERFACE_LOCAL
argument_list|,
literal|"Disconnected"
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"dbus: bus disconnected, terminating"
argument_list|)
expr_stmt|;
name|dbus_connection_set_exit_on_disconnect
argument_list|(
name|conn
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|wpa_supplicant_terminate_proc
argument_list|(
name|priv
operator|->
name|global
argument_list|)
expr_stmt|;
return|return
name|DBUS_HANDLER_RESULT_HANDLED
return|;
block|}
else|else
return|return
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpas_dbus_init_common
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
parameter_list|)
block|{
name|DBusError
name|error
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Get a reference to the system bus */
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
name|priv
operator|->
name|con
operator|=
name|dbus_bus_get
argument_list|(
name|DBUS_BUS_SYSTEM
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|con
condition|)
block|{
name|dbus_connection_add_filter
argument_list|(
name|priv
operator|->
name|con
argument_list|,
name|disconnect_filter
argument_list|,
name|priv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not acquire the system bus: %s - %s"
argument_list|,
name|error
operator|.
name|name
argument_list|,
name|error
operator|.
name|message
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpas_dbus_init_common_finish
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
parameter_list|)
block|{
comment|/* Tell dbus about our mainloop integration functions */
name|integrate_with_eloop
argument_list|(
name|priv
argument_list|)
expr_stmt|;
comment|/* 	 * Dispatch initial DBus messages that may have come in since the bus 	 * name was claimed above. Happens when clients are quick to notice the 	 * service. 	 * 	 * FIXME: is there a better solution to this problem? 	 */
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
literal|50
argument_list|,
name|dispatch_initial_dbus_messages
argument_list|,
name|priv
operator|->
name|con
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpas_dbus_deinit_common
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
parameter_list|)
block|{
if|if
condition|(
name|priv
operator|->
name|con
condition|)
block|{
name|eloop_cancel_timeout
argument_list|(
name|dispatch_initial_dbus_messages
argument_list|,
name|priv
operator|->
name|con
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|process_timeout
argument_list|,
name|priv
argument_list|,
name|ELOOP_ALL_CTX
argument_list|)
expr_stmt|;
name|dbus_connection_set_watch_functions
argument_list|(
name|priv
operator|->
name|con
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_connection_set_timeout_functions
argument_list|(
name|priv
operator|->
name|con
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_connection_remove_filter
argument_list|(
name|priv
operator|->
name|con
argument_list|,
name|disconnect_filter
argument_list|,
name|priv
argument_list|)
expr_stmt|;
name|dbus_connection_unref
argument_list|(
name|priv
operator|->
name|con
argument_list|)
expr_stmt|;
block|}
name|os_free
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|wpas_dbus_priv
modifier|*
name|wpas_dbus_init
parameter_list|(
name|struct
name|wpa_global
modifier|*
name|global
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
decl_stmt|;
name|priv
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|priv
operator|->
name|global
operator|=
name|global
expr_stmt|;
if|if
condition|(
name|wpas_dbus_init_common
argument_list|(
name|priv
argument_list|)
operator|<
literal|0
operator|||
ifdef|#
directive|ifdef
name|CONFIG_CTRL_IFACE_DBUS_NEW
name|wpas_dbus_ctrl_iface_init
argument_list|(
name|priv
argument_list|)
operator|<
literal|0
operator|||
endif|#
directive|endif
comment|/* CONFIG_CTRL_IFACE_DBUS_NEW */
ifdef|#
directive|ifdef
name|CONFIG_CTRL_IFACE_DBUS
name|wpa_supplicant_dbus_ctrl_iface_init
argument_list|(
name|priv
argument_list|)
operator|<
literal|0
operator|||
endif|#
directive|endif
comment|/* CONFIG_CTRL_IFACE_DBUS */
name|wpas_dbus_init_common_finish
argument_list|(
name|priv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpas_dbus_deinit
argument_list|(
name|priv
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|priv
return|;
block|}
end_function

begin_function
name|void
name|wpas_dbus_deinit
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|priv
parameter_list|)
block|{
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|CONFIG_CTRL_IFACE_DBUS_NEW
name|wpas_dbus_ctrl_iface_deinit
argument_list|(
name|priv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_CTRL_IFACE_DBUS_NEW */
ifdef|#
directive|ifdef
name|CONFIG_CTRL_IFACE_DBUS
comment|/* TODO: is any deinit needed? */
endif|#
directive|endif
comment|/* CONFIG_CTRL_IFACE_DBUS */
name|wpas_dbus_deinit_common
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

