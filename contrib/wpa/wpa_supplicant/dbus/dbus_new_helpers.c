begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant / dbus-based control interface  * Copyright (c) 2006, Dan Williams<dcbw@redhat.com> and Red Hat, Inc.  * Copyright (c) 2009, Witold Sowa<witold.sowa@gmail.com>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"utils/includes.h"
end_include

begin_include
include|#
directive|include
file|"utils/common.h"
end_include

begin_include
include|#
directive|include
file|"utils/eloop.h"
end_include

begin_include
include|#
directive|include
file|"dbus_common.h"
end_include

begin_include
include|#
directive|include
file|"dbus_common_i.h"
end_include

begin_include
include|#
directive|include
file|"dbus_new.h"
end_include

begin_include
include|#
directive|include
file|"dbus_new_helpers.h"
end_include

begin_include
include|#
directive|include
file|"dbus_dict_helpers.h"
end_include

begin_function
specifier|static
name|dbus_bool_t
name|fill_dict_with_properties
parameter_list|(
name|DBusMessageIter
modifier|*
name|dict_iter
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|,
name|DBusError
modifier|*
name|error
parameter_list|)
block|{
name|DBusMessageIter
name|entry_iter
decl_stmt|;
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
decl_stmt|;
for|for
control|(
name|dsc
operator|=
name|props
init|;
name|dsc
operator|&&
name|dsc
operator|->
name|dbus_property
condition|;
name|dsc
operator|++
control|)
block|{
comment|/* Only return properties for the requested D-Bus interface */
if|if
condition|(
name|os_strncmp
argument_list|(
name|dsc
operator|->
name|dbus_interface
argument_list|,
name|interface
argument_list|,
name|WPAS_DBUS_INTERFACE_MAX
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Skip write-only properties */
if|if
condition|(
name|dsc
operator|->
name|getter
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dbus_message_iter_open_container
argument_list|(
name|dict_iter
argument_list|,
name|DBUS_TYPE_DICT_ENTRY
argument_list|,
name|NULL
argument_list|,
operator|&
name|entry_iter
argument_list|)
condition|)
block|{
name|dbus_set_error_const
argument_list|(
name|error
argument_list|,
name|DBUS_ERROR_NO_MEMORY
argument_list|,
literal|"no memory"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|dbus_message_iter_append_basic
argument_list|(
operator|&
name|entry_iter
argument_list|,
name|DBUS_TYPE_STRING
argument_list|,
operator|&
name|dsc
operator|->
name|dbus_property
argument_list|)
condition|)
block|{
name|dbus_set_error_const
argument_list|(
name|error
argument_list|,
name|DBUS_ERROR_NO_MEMORY
argument_list|,
literal|"no memory"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* An error getting a property fails the request entirely */
if|if
condition|(
operator|!
name|dsc
operator|->
name|getter
argument_list|(
operator|&
name|entry_iter
argument_list|,
name|error
argument_list|,
name|user_data
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|dbus_message_iter_close_container
argument_list|(
name|dict_iter
argument_list|,
operator|&
name|entry_iter
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * get_all_properties - Responds for GetAll properties calls on object  * @message: Message with GetAll call  * @interface: interface name which properties will be returned  * @property_dsc: list of object's properties  * Returns: Message with dict of variants as argument with properties values  *  * Iterates over all properties registered with object and execute getters  * of those, which are readable and which interface matches interface  * specified as argument. Returned message contains one dict argument  * with properties names as keys and theirs values as values.  */
end_comment

begin_function
specifier|static
name|DBusMessage
modifier|*
name|get_all_properties
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|char
modifier|*
name|interface
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|reply
decl_stmt|;
name|DBusMessageIter
name|iter
decl_stmt|,
name|dict_iter
decl_stmt|;
name|DBusError
name|error
decl_stmt|;
name|reply
operator|=
name|dbus_message_new_method_return
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"%s: out of memory creating dbus reply"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dbus_message_iter_init_append
argument_list|(
name|reply
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wpa_dbus_dict_open_write
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
name|dict_iter
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"%s: out of memory creating reply"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|reply
operator|=
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_NO_MEMORY
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fill_dict_with_properties
argument_list|(
operator|&
name|dict_iter
argument_list|,
name|obj_dsc
operator|->
name|properties
argument_list|,
name|interface
argument_list|,
name|obj_dsc
operator|->
name|user_data
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|reply
operator|=
name|wpas_dbus_reply_new_from_error
argument_list|(
name|message
argument_list|,
operator|&
name|error
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
literal|"No readable properties"
literal|" in this interface"
argument_list|)
expr_stmt|;
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
name|wpa_dbus_dict_close_write
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
name|dict_iter
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_signature_correct
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_method_desc
modifier|*
name|method_dsc
parameter_list|)
block|{
comment|/* According to DBus documentation max length of signature is 255 */
define|#
directive|define
name|MAX_SIG_LEN
value|256
name|char
name|registered_sig
index|[
name|MAX_SIG_LEN
index|]
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
specifier|const
name|char
modifier|*
name|sig
init|=
name|dbus_message_get_signature
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|const
name|struct
name|wpa_dbus_argument
modifier|*
name|arg
decl_stmt|;
name|pos
operator|=
name|registered_sig
expr_stmt|;
operator|*
name|pos
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|method_dsc
operator|->
name|args
init|;
name|arg
operator|&&
name|arg
operator|->
name|name
condition|;
name|arg
operator|++
control|)
block|{
if|if
condition|(
name|arg
operator|->
name|dir
operator|==
name|ARG_IN
condition|)
block|{
name|size_t
name|blen
init|=
name|registered_sig
operator|+
name|MAX_SIG_LEN
operator|-
name|pos
decl_stmt|;
name|ret
operator|=
name|os_snprintf
argument_list|(
name|pos
argument_list|,
name|blen
argument_list|,
literal|"%s"
argument_list|,
name|arg
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|ret
operator|>=
name|blen
condition|)
return|return
literal|0
return|;
name|pos
operator|+=
name|ret
expr_stmt|;
block|}
block|}
return|return
operator|!
name|os_strncmp
argument_list|(
name|registered_sig
argument_list|,
name|sig
argument_list|,
name|MAX_SIG_LEN
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|properties_get_all
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|char
modifier|*
name|interface
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
if|if
condition|(
name|os_strcmp
argument_list|(
name|dbus_message_get_signature
argument_list|(
name|message
argument_list|)
argument_list|,
literal|"s"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|get_all_properties
argument_list|(
name|message
argument_list|,
name|interface
argument_list|,
name|obj_dsc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|properties_get
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|reply
decl_stmt|;
name|DBusMessageIter
name|iter
decl_stmt|;
name|DBusError
name|error
decl_stmt|;
if|if
condition|(
name|os_strcmp
argument_list|(
name|dbus_message_get_signature
argument_list|(
name|message
argument_list|)
argument_list|,
literal|"ss"
argument_list|)
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|dsc
operator|->
name|getter
operator|==
name|NULL
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
literal|"Property is write-only"
argument_list|)
return|;
block|}
name|reply
operator|=
name|dbus_message_new_method_return
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|dbus_message_iter_init_append
argument_list|(
name|reply
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsc
operator|->
name|getter
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
name|error
argument_list|,
name|user_data
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|reply
operator|=
name|wpas_dbus_reply_new_from_error
argument_list|(
name|message
argument_list|,
operator|&
name|error
argument_list|,
name|DBUS_ERROR_FAILED
argument_list|,
literal|"Failed to read property"
argument_list|)
expr_stmt|;
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|reply
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|properties_set
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|reply
decl_stmt|;
name|DBusMessageIter
name|iter
decl_stmt|;
name|DBusError
name|error
decl_stmt|;
if|if
condition|(
name|os_strcmp
argument_list|(
name|dbus_message_get_signature
argument_list|(
name|message
argument_list|)
argument_list|,
literal|"ssv"
argument_list|)
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|dsc
operator|->
name|setter
operator|==
name|NULL
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
literal|"Property is read-only"
argument_list|)
return|;
block|}
name|dbus_message_iter_init
argument_list|(
name|message
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
comment|/* Skip the interface name and the property name */
name|dbus_message_iter_next
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
name|dbus_message_iter_next
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
comment|/* Iter will now point to the property's new value */
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsc
operator|->
name|setter
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
name|error
argument_list|,
name|user_data
argument_list|)
operator|==
name|TRUE
condition|)
block|{
comment|/* Success */
name|reply
operator|=
name|dbus_message_new_method_return
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reply
operator|=
name|wpas_dbus_reply_new_from_error
argument_list|(
name|message
argument_list|,
operator|&
name|error
argument_list|,
name|DBUS_ERROR_FAILED
argument_list|,
literal|"Failed to set property"
argument_list|)
expr_stmt|;
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|reply
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|properties_get_or_set
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|DBusMessageIter
modifier|*
name|iter
parameter_list|,
name|char
modifier|*
name|interface
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|property_dsc
decl_stmt|;
name|char
modifier|*
name|property
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
name|method
operator|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|property_dsc
operator|=
name|obj_dsc
operator|->
name|properties
expr_stmt|;
comment|/* Second argument: property name (DBUS_TYPE_STRING) */
if|if
condition|(
operator|!
name|dbus_message_iter_next
argument_list|(
name|iter
argument_list|)
operator|||
name|dbus_message_iter_get_arg_type
argument_list|(
name|iter
argument_list|)
operator|!=
name|DBUS_TYPE_STRING
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|dbus_message_iter_get_basic
argument_list|(
name|iter
argument_list|,
operator|&
name|property
argument_list|)
expr_stmt|;
while|while
condition|(
name|property_dsc
operator|&&
name|property_dsc
operator|->
name|dbus_property
condition|)
block|{
comment|/* compare property names and 		 * interfaces */
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|property_dsc
operator|->
name|dbus_property
argument_list|,
name|property
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|&&
operator|!
name|os_strncmp
argument_list|(
name|property_dsc
operator|->
name|dbus_interface
argument_list|,
name|interface
argument_list|,
name|WPAS_DBUS_INTERFACE_MAX
argument_list|)
condition|)
break|break;
name|property_dsc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|property_dsc
operator|==
name|NULL
operator|||
name|property_dsc
operator|->
name|dbus_property
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"no property handler for %s.%s on %s"
argument_list|,
name|interface
argument_list|,
name|property
argument_list|,
name|dbus_message_get_path
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
literal|"No such property"
argument_list|)
return|;
block|}
if|if
condition|(
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_GET
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|==
literal|0
condition|)
return|return
name|properties_get
argument_list|(
name|message
argument_list|,
name|property_dsc
argument_list|,
name|obj_dsc
operator|->
name|user_data
argument_list|)
return|;
return|return
name|properties_set
argument_list|(
name|message
argument_list|,
name|property_dsc
argument_list|,
name|obj_dsc
operator|->
name|user_data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|properties_handler
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
name|DBusMessageIter
name|iter
decl_stmt|;
name|char
modifier|*
name|interface
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
name|method
operator|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|dbus_message_iter_init
argument_list|(
name|message
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_GET
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|||
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_SET
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|||
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_GETALL
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
condition|)
block|{
comment|/* First argument: interface name (DBUS_TYPE_STRING) */
if|if
condition|(
name|dbus_message_iter_get_arg_type
argument_list|(
operator|&
name|iter
argument_list|)
operator|!=
name|DBUS_TYPE_STRING
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|dbus_message_iter_get_basic
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_GETALL
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
condition|)
block|{
comment|/* GetAll */
return|return
name|properties_get_all
argument_list|(
name|message
argument_list|,
name|interface
argument_list|,
name|obj_dsc
argument_list|)
return|;
block|}
comment|/* Get or Set */
return|return
name|properties_get_or_set
argument_list|(
name|message
argument_list|,
operator|&
name|iter
argument_list|,
name|interface
argument_list|,
name|obj_dsc
argument_list|)
return|;
block|}
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_UNKNOWN_METHOD
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|msg_method_handler
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
specifier|const
name|struct
name|wpa_dbus_method_desc
modifier|*
name|method_dsc
init|=
name|obj_dsc
operator|->
name|methods
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg_interface
decl_stmt|;
name|method
operator|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|msg_interface
operator|=
name|dbus_message_get_interface
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|/* try match call to any registered method */
while|while
condition|(
name|method_dsc
operator|&&
name|method_dsc
operator|->
name|dbus_method
condition|)
block|{
comment|/* compare method names and interfaces */
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|method_dsc
operator|->
name|dbus_method
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|&&
operator|!
name|os_strncmp
argument_list|(
name|method_dsc
operator|->
name|dbus_interface
argument_list|,
name|msg_interface
argument_list|,
name|WPAS_DBUS_INTERFACE_MAX
argument_list|)
condition|)
break|break;
name|method_dsc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|method_dsc
operator|==
name|NULL
operator|||
name|method_dsc
operator|->
name|dbus_method
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"no method handler for %s.%s on %s"
argument_list|,
name|msg_interface
argument_list|,
name|method
argument_list|,
name|dbus_message_get_path
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_UNKNOWN_METHOD
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|is_signature_correct
argument_list|(
name|message
argument_list|,
name|method_dsc
argument_list|)
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|method_dsc
operator|->
name|method_handler
argument_list|(
name|message
argument_list|,
name|obj_dsc
operator|->
name|user_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * message_handler - Handles incoming DBus messages  * @connection: DBus connection on which message was received  * @message: Received message  * @user_data: pointer to description of object to which message was sent  * Returns: Returns information whether message was handled or not  *  * Reads message interface and method name, then checks if they matches one  * of the special cases i.e. introspection call or properties get/getall/set  * methods and handles it. Else it iterates over registered methods list  * and tries to match method's name and interface to those read from message  * If appropriate method was found its handler function is called and  * response is sent. Otherwise, the DBUS_ERROR_UNKNOWN_METHOD error message  * will be sent.  */
end_comment

begin_function
specifier|static
name|DBusHandlerResult
name|message_handler
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
init|=
name|user_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg_interface
decl_stmt|;
name|DBusMessage
modifier|*
name|reply
decl_stmt|;
comment|/* get method, interface and path the message is addressed to */
name|method
operator|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|path
operator|=
name|dbus_message_get_path
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|msg_interface
operator|=
name|dbus_message_get_interface
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method
operator|||
operator|!
name|path
operator|||
operator|!
name|msg_interface
condition|)
return|return
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"dbus: %s.%s (%s)"
argument_list|,
name|msg_interface
argument_list|,
name|method
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* if message is introspection method call */
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_INTROSPECTION_METHOD
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|&&
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_INTROSPECTION_INTERFACE
argument_list|,
name|msg_interface
argument_list|,
name|WPAS_DBUS_INTERFACE_MAX
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_CTRL_IFACE_DBUS_INTRO
name|reply
operator|=
name|wpa_dbus_introspect
argument_list|(
name|message
argument_list|,
name|obj_dsc
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CONFIG_CTRL_IFACE_DBUS_INTRO */
name|reply
operator|=
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_UNKNOWN_METHOD
argument_list|,
literal|"wpa_supplicant was compiled without "
literal|"introspection support."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_CTRL_IFACE_DBUS_INTRO */
block|}
elseif|else
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_INTERFACE
argument_list|,
name|msg_interface
argument_list|,
name|WPAS_DBUS_INTERFACE_MAX
argument_list|)
condition|)
block|{
comment|/* if message is properties method call */
name|reply
operator|=
name|properties_handler
argument_list|(
name|message
argument_list|,
name|obj_dsc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reply
operator|=
name|msg_method_handler
argument_list|(
name|message
argument_list|,
name|obj_dsc
argument_list|)
expr_stmt|;
block|}
comment|/* If handler succeed returning NULL, reply empty message */
if|if
condition|(
operator|!
name|reply
condition|)
name|reply
operator|=
name|dbus_message_new_method_return
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
if|if
condition|(
operator|!
name|dbus_message_get_no_reply
argument_list|(
name|message
argument_list|)
condition|)
name|dbus_connection_send
argument_list|(
name|connection
argument_list|,
name|reply
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
name|wpa_dbus_flush_all_changed_properties
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|DBUS_HANDLER_RESULT_HANDLED
return|;
block|}
end_function

begin_comment
comment|/**  * free_dbus_object_desc - Frees object description data structure  * @connection: DBus connection  * @obj_dsc: Object description to free  *  * Frees each of properties, methods and signals description lists and  * the object description structure itself.  */
end_comment

begin_function
name|void
name|free_dbus_object_desc
parameter_list|(
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obj_dsc
condition|)
return|return;
comment|/* free handler's argument */
if|if
condition|(
name|obj_dsc
operator|->
name|user_data_free_func
condition|)
name|obj_dsc
operator|->
name|user_data_free_func
argument_list|(
name|obj_dsc
operator|->
name|user_data
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|obj_dsc
operator|->
name|path
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|obj_dsc
operator|->
name|prop_changed_flags
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|obj_dsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_dbus_object_desc_cb
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|void
modifier|*
name|obj_dsc
parameter_list|)
block|{
name|free_dbus_object_desc
argument_list|(
name|obj_dsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_dbus_ctrl_iface_init - Initialize dbus control interface  * @application_data: Pointer to application specific data structure  * @dbus_path: DBus path to interface object  * @dbus_service: DBus service name to register with  * @messageHandler: a pointer to function which will handle dbus messages  * coming on interface  * Returns: 0 on success, -1 on failure  *  * Initialize the dbus control interface and start receiving commands from  * external programs over the bus.  */
end_comment

begin_function
name|int
name|wpa_dbus_ctrl_iface_init
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
parameter_list|,
name|char
modifier|*
name|dbus_path
parameter_list|,
name|char
modifier|*
name|dbus_service
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
parameter_list|)
block|{
name|DBusError
name|error
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|DBusObjectPathVTable
name|wpa_vtable
init|=
block|{
operator|&
name|free_dbus_object_desc_cb
block|,
operator|&
name|message_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|obj_desc
operator|->
name|connection
operator|=
name|iface
operator|->
name|con
expr_stmt|;
name|obj_desc
operator|->
name|path
operator|=
name|os_strdup
argument_list|(
name|dbus_path
argument_list|)
expr_stmt|;
comment|/* Register the message handler for the global dbus interface */
if|if
condition|(
operator|!
name|dbus_connection_register_object_path
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|dbus_path
argument_list|,
operator|&
name|wpa_vtable
argument_list|,
name|obj_desc
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not set up message "
literal|"handler"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Register our service with the message bus */
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dbus_bus_request_name
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|dbus_service
argument_list|,
literal|0
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
case|case
name|DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER
case|:
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DBUS_REQUEST_NAME_REPLY_EXISTS
case|:
case|case
name|DBUS_REQUEST_NAME_REPLY_IN_QUEUE
case|:
case|case
name|DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER
case|:
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not request service name: "
literal|"already registered"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not request service name: "
literal|"%s %s"
argument_list|,
name|error
operator|.
name|name
argument_list|,
name|error
operator|.
name|message
argument_list|)
expr_stmt|;
break|break;
block|}
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Providing DBus service '%s'."
argument_list|,
name|dbus_service
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_dbus_register_object_per_iface - Register a new object with dbus  * @ctrl_iface: pointer to dbus private data  * @path: DBus path to object  * @ifname: interface name  * @obj_desc: description of object's methods, signals and properties  * Returns: 0 on success, -1 on error  *  * Registers a new interface with dbus and assigns it a dbus object path.  */
end_comment

begin_function
name|int
name|wpa_dbus_register_object_per_iface
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|ctrl_iface
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
parameter_list|)
block|{
name|DBusConnection
modifier|*
name|con
decl_stmt|;
name|DBusError
name|error
decl_stmt|;
name|DBusObjectPathVTable
name|vtable
init|=
block|{
operator|&
name|free_dbus_object_desc_cb
block|,
operator|&
name|message_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|ctrl_iface
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|con
operator|=
name|ctrl_iface
operator|->
name|con
expr_stmt|;
name|obj_desc
operator|->
name|connection
operator|=
name|con
expr_stmt|;
name|obj_desc
operator|->
name|path
operator|=
name|os_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
comment|/* Register the message handler for the interface functions */
if|if
condition|(
operator|!
name|dbus_connection_try_register_object_path
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
operator|&
name|vtable
argument_list|,
name|obj_desc
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|os_strcmp
argument_list|(
name|error
operator|.
name|name
argument_list|,
name|DBUS_ERROR_OBJECT_PATH_IN_USE
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"dbus: %s"
argument_list|,
name|error
operator|.
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not set up message "
literal|"handler for interface %s object %s"
argument_list|,
name|ifname
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus error: %s"
argument_list|,
name|error
operator|.
name|name
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: %s"
argument_list|,
name|error
operator|.
name|message
argument_list|)
expr_stmt|;
block|}
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|flush_object_timeout_handler
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * wpa_dbus_unregister_object_per_iface - Unregisters DBus object  * @ctrl_iface: Pointer to dbus private data  * @path: DBus path to object which will be unregistered  * Returns: Zero on success and -1 on failure  *  * Unregisters DBus object given by its path  */
end_comment

begin_function
name|int
name|wpa_dbus_unregister_object_per_iface
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|ctrl_iface
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|DBusConnection
modifier|*
name|con
init|=
name|ctrl_iface
operator|->
name|con
decl_stmt|;
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
init|=
name|NULL
decl_stmt|;
name|dbus_connection_get_object_path_data
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|obj_desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_desc
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: %s: Could not obtain object's "
literal|"private data: %s"
argument_list|,
name|__func__
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eloop_cancel_timeout
argument_list|(
name|flush_object_timeout_handler
argument_list|,
name|con
argument_list|,
name|obj_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dbus_connection_unregister_object_path
argument_list|(
name|con
argument_list|,
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|dbus_bool_t
name|put_changed_properties
parameter_list|(
specifier|const
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
name|DBusMessageIter
modifier|*
name|dict_iter
parameter_list|,
name|int
name|clear_changed
parameter_list|)
block|{
name|DBusMessageIter
name|entry_iter
decl_stmt|;
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBusError
name|error
decl_stmt|;
for|for
control|(
name|dsc
operator|=
name|obj_dsc
operator|->
name|properties
operator|,
name|i
operator|=
literal|0
init|;
name|dsc
operator|&&
name|dsc
operator|->
name|dbus_property
condition|;
name|dsc
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|obj_dsc
operator|->
name|prop_changed_flags
operator|==
name|NULL
operator|||
operator|!
name|obj_dsc
operator|->
name|prop_changed_flags
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|os_strcmp
argument_list|(
name|dsc
operator|->
name|dbus_interface
argument_list|,
name|interface
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|clear_changed
condition|)
name|obj_dsc
operator|->
name|prop_changed_flags
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dbus_message_iter_open_container
argument_list|(
name|dict_iter
argument_list|,
name|DBUS_TYPE_DICT_ENTRY
argument_list|,
name|NULL
argument_list|,
operator|&
name|entry_iter
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|dbus_message_iter_append_basic
argument_list|(
operator|&
name|entry_iter
argument_list|,
name|DBUS_TYPE_STRING
argument_list|,
operator|&
name|dsc
operator|->
name|dbus_property
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsc
operator|->
name|getter
argument_list|(
operator|&
name|entry_iter
argument_list|,
operator|&
name|error
argument_list|,
name|obj_dsc
operator|->
name|user_data
argument_list|)
condition|)
block|{
if|if
condition|(
name|dbus_error_is_set
argument_list|(
operator|&
name|error
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: %s: Cannot get "
literal|"new value of property %s: (%s) %s"
argument_list|,
name|__func__
argument_list|,
name|dsc
operator|->
name|dbus_property
argument_list|,
name|error
operator|.
name|name
argument_list|,
name|error
operator|.
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: %s: Cannot get "
literal|"new value of property %s"
argument_list|,
name|__func__
argument_list|,
name|dsc
operator|->
name|dbus_property
argument_list|)
expr_stmt|;
block|}
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|dbus_message_iter_close_container
argument_list|(
name|dict_iter
argument_list|,
operator|&
name|entry_iter
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_send_prop_changed_signal
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|msg
decl_stmt|;
name|DBusMessageIter
name|signal_iter
decl_stmt|,
name|dict_iter
decl_stmt|;
name|msg
operator|=
name|dbus_message_new_signal
argument_list|(
name|path
argument_list|,
name|DBUS_INTERFACE_PROPERTIES
argument_list|,
literal|"PropertiesChanged"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
name|dbus_message_iter_init_append
argument_list|(
name|msg
argument_list|,
operator|&
name|signal_iter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbus_message_iter_append_basic
argument_list|(
operator|&
name|signal_iter
argument_list|,
name|DBUS_TYPE_STRING
argument_list|,
operator|&
name|interface
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Changed properties dict */
if|if
condition|(
operator|!
name|dbus_message_iter_open_container
argument_list|(
operator|&
name|signal_iter
argument_list|,
name|DBUS_TYPE_ARRAY
argument_list|,
literal|"{sv}"
argument_list|,
operator|&
name|dict_iter
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|put_changed_properties
argument_list|(
name|obj_dsc
argument_list|,
name|interface
argument_list|,
operator|&
name|dict_iter
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|dbus_message_iter_close_container
argument_list|(
operator|&
name|signal_iter
argument_list|,
operator|&
name|dict_iter
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Invalidated properties array (empty) */
if|if
condition|(
operator|!
name|dbus_message_iter_open_container
argument_list|(
operator|&
name|signal_iter
argument_list|,
name|DBUS_TYPE_ARRAY
argument_list|,
literal|"s"
argument_list|,
operator|&
name|dict_iter
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|dbus_message_iter_close_container
argument_list|(
operator|&
name|signal_iter
argument_list|,
operator|&
name|dict_iter
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|dbus_connection_send
argument_list|(
name|con
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
name|dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"dbus: %s: Failed to construct signal"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_send_deprecated_prop_changed_signal
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|msg
decl_stmt|;
name|DBusMessageIter
name|signal_iter
decl_stmt|,
name|dict_iter
decl_stmt|;
name|msg
operator|=
name|dbus_message_new_signal
argument_list|(
name|path
argument_list|,
name|interface
argument_list|,
literal|"PropertiesChanged"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
name|dbus_message_iter_init_append
argument_list|(
name|msg
argument_list|,
operator|&
name|signal_iter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbus_message_iter_open_container
argument_list|(
operator|&
name|signal_iter
argument_list|,
name|DBUS_TYPE_ARRAY
argument_list|,
literal|"{sv}"
argument_list|,
operator|&
name|dict_iter
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|put_changed_properties
argument_list|(
name|obj_dsc
argument_list|,
name|interface
argument_list|,
operator|&
name|dict_iter
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|dbus_message_iter_close_container
argument_list|(
operator|&
name|signal_iter
argument_list|,
operator|&
name|dict_iter
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|dbus_connection_send
argument_list|(
name|con
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
name|dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"dbus: %s: Failed to construct signal"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_prop_changed_signal
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
comment|/* 	 * First, send property change notification on the standardized 	 * org.freedesktop.DBus.Properties interface. This call will not 	 * clear the property change bits, so that they are preserved for 	 * the call that follows. 	 */
name|do_send_prop_changed_signal
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|obj_dsc
argument_list|)
expr_stmt|;
comment|/* 	 * Now send PropertiesChanged on our own interface for backwards 	 * compatibility. This is deprecated and will be removed in a future 	 * release. 	 */
name|do_send_deprecated_prop_changed_signal
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
name|interface
argument_list|,
name|obj_dsc
argument_list|)
expr_stmt|;
comment|/* Property change bits have now been cleared. */
block|}
end_function

begin_function
specifier|static
name|void
name|flush_object_timeout_handler
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|DBusConnection
modifier|*
name|con
init|=
name|eloop_ctx
decl_stmt|;
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
init|=
name|timeout_ctx
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"dbus: %s: Timeout - sending changed properties "
literal|"of object %s"
argument_list|,
name|__func__
argument_list|,
name|obj_desc
operator|->
name|path
argument_list|)
expr_stmt|;
name|wpa_dbus_flush_object_changed_properties
argument_list|(
name|con
argument_list|,
name|obj_desc
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|recursive_flush_changed_properties
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|objects
init|=
name|NULL
decl_stmt|;
name|char
name|subobj_path
index|[
name|WPAS_DBUS_OBJECT_PATH_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|wpa_dbus_flush_object_changed_properties
argument_list|(
name|con
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbus_connection_list_registered
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
operator|&
name|objects
argument_list|)
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|objects
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|os_snprintf
argument_list|(
name|subobj_path
argument_list|,
name|WPAS_DBUS_OBJECT_PATH_MAX
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|objects
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|recursive_flush_changed_properties
argument_list|(
name|con
argument_list|,
name|subobj_path
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|dbus_free_string_array
argument_list|(
name|objects
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_dbus_flush_all_changed_properties - Send all PropertiesChanged signals  * @con: DBus connection  *  * Traverses through all registered objects and sends PropertiesChanged for  * each properties.  */
end_comment

begin_function
name|void
name|wpa_dbus_flush_all_changed_properties
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|)
block|{
name|recursive_flush_changed_properties
argument_list|(
name|con
argument_list|,
name|WPAS_DBUS_NEW_PATH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_dbus_flush_object_changed_properties - Send PropertiesChanged for object  * @con: DBus connection  * @path: path to a DBus object for which PropertiesChanged will be sent.  *  * Iterates over all properties registered with object and for each interface  * containing properties marked as changed, sends a PropertiesChanged signal  * containing names and new values of properties that have changed.  *  * You need to call this function after wpa_dbus_mark_property_changed()  * if you want to send PropertiesChanged signal immediately (i.e., without  * waiting timeout to expire). PropertiesChanged signal for an object is sent  * automatically short time after first marking property as changed. All  * PropertiesChanged signals are sent automatically after responding on DBus  * message, so if you marked a property changed as a result of DBus call  * (e.g., param setter), you usually do not need to call this function.  */
end_comment

begin_function
name|void
name|wpa_dbus_flush_object_changed_properties
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dbus_connection_get_object_path_data
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|obj_desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_desc
condition|)
return|return;
name|eloop_cancel_timeout
argument_list|(
name|flush_object_timeout_handler
argument_list|,
name|con
argument_list|,
name|obj_desc
argument_list|)
expr_stmt|;
name|dsc
operator|=
name|obj_desc
operator|->
name|properties
expr_stmt|;
for|for
control|(
name|dsc
operator|=
name|obj_desc
operator|->
name|properties
operator|,
name|i
operator|=
literal|0
init|;
name|dsc
operator|&&
name|dsc
operator|->
name|dbus_property
condition|;
name|dsc
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|obj_desc
operator|->
name|prop_changed_flags
operator|==
name|NULL
operator|||
operator|!
name|obj_desc
operator|->
name|prop_changed_flags
index|[
name|i
index|]
condition|)
continue|continue;
name|send_prop_changed_signal
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
name|dsc
operator|->
name|dbus_interface
argument_list|,
name|obj_desc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|WPA_DBUS_SEND_PROP_CHANGED_TIMEOUT
value|5000
end_define

begin_comment
comment|/**  * wpa_dbus_mark_property_changed - Mark a property as changed and  * @iface: dbus priv struct  * @path: path to DBus object which property has changed  * @interface: interface containing changed property  * @property: property name which has changed  *  * Iterates over all properties registered with an object and marks the one  * given in parameters as changed. All parameters registered for an object  * within a single interface will be aggregated together and sent in one  * PropertiesChanged signal when function  * wpa_dbus_flush_object_changed_properties() is called.  */
end_comment

begin_function
name|void
name|wpa_dbus_mark_property_changed
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
specifier|const
name|char
modifier|*
name|property
parameter_list|)
block|{
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return;
name|dbus_connection_get_object_path_data
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|path
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|obj_desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_desc
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: wpa_dbus_property_changed: "
literal|"could not obtain object's private data: %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|dsc
operator|=
name|obj_desc
operator|->
name|properties
init|;
name|dsc
operator|&&
name|dsc
operator|->
name|dbus_property
condition|;
name|dsc
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|os_strcmp
argument_list|(
name|property
argument_list|,
name|dsc
operator|->
name|dbus_property
argument_list|)
operator|==
literal|0
operator|&&
name|os_strcmp
argument_list|(
name|interface
argument_list|,
name|dsc
operator|->
name|dbus_interface
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|obj_desc
operator|->
name|prop_changed_flags
condition|)
name|obj_desc
operator|->
name|prop_changed_flags
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|dsc
operator|||
operator|!
name|dsc
operator|->
name|dbus_property
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: wpa_dbus_property_changed: "
literal|"no property %s in object %s"
argument_list|,
name|property
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|eloop_is_timeout_registered
argument_list|(
name|flush_object_timeout_handler
argument_list|,
name|iface
operator|->
name|con
argument_list|,
name|obj_desc
operator|->
name|path
argument_list|)
condition|)
block|{
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
name|WPA_DBUS_SEND_PROP_CHANGED_TIMEOUT
argument_list|,
name|flush_object_timeout_handler
argument_list|,
name|iface
operator|->
name|con
argument_list|,
name|obj_desc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * wpa_dbus_get_object_properties - Put object's properties into dictionary  * @iface: dbus priv struct  * @path: path to DBus object which properties will be obtained  * @interface: interface name which properties will be obtained  * @iter: DBus message iter at which to append property dictionary.  *  * Iterates over all properties registered with object and execute getters  * of those, which are readable and which interface matches interface  * specified as argument. Obtained properties values are stored in  * dict_iter dictionary.  */
end_comment

begin_function
name|dbus_bool_t
name|wpa_dbus_get_object_properties
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
name|DBusMessageIter
modifier|*
name|iter
parameter_list|)
block|{
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
init|=
name|NULL
decl_stmt|;
name|DBusMessageIter
name|dict_iter
decl_stmt|;
name|DBusError
name|error
decl_stmt|;
name|dbus_connection_get_object_path_data
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|path
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|obj_desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_desc
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: %s: could not obtain object's "
literal|"private data: %s"
argument_list|,
name|__func__
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|wpa_dbus_dict_open_write
argument_list|(
name|iter
argument_list|,
operator|&
name|dict_iter
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: %s: failed to open message dict"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fill_dict_with_properties
argument_list|(
operator|&
name|dict_iter
argument_list|,
name|obj_desc
operator|->
name|properties
argument_list|,
name|interface
argument_list|,
name|obj_desc
operator|->
name|user_data
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: %s: failed to get object"
literal|" properties: (%s) %s"
argument_list|,
name|__func__
argument_list|,
name|dbus_error_is_set
argument_list|(
operator|&
name|error
argument_list|)
condition|?
name|error
operator|.
name|name
else|:
literal|"none"
argument_list|,
name|dbus_error_is_set
argument_list|(
operator|&
name|error
argument_list|)
condition|?
name|error
operator|.
name|message
else|:
literal|"none"
argument_list|)
expr_stmt|;
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|wpa_dbus_dict_close_write
argument_list|(
name|iter
argument_list|,
operator|&
name|dict_iter
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_new_decompose_object_path - Decompose an interface object path into parts  * @path: The dbus object path  * @p2p_persistent_group: indicates whether to parse the path as a P2P  *                        persistent group object  * @network: (out) the configured network this object path refers to, if any  * @bssid: (out) the scanned bssid this object path refers to, if any  * Returns: The object path of the network interface this path refers to  *  * For a given object path, decomposes the object path into object id, network,  * and BSSID parts, if those parts exist.  */
end_comment

begin_function
name|char
modifier|*
name|wpas_dbus_new_decompose_object_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|p2p_persistent_group
parameter_list|,
name|char
modifier|*
modifier|*
name|network
parameter_list|,
name|char
modifier|*
modifier|*
name|bssid
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|dev_path_prefix_len
init|=
name|os_strlen
argument_list|(
name|WPAS_DBUS_NEW_PATH_INTERFACES
literal|"/"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|obj_path_only
decl_stmt|;
name|char
modifier|*
name|next_sep
decl_stmt|;
comment|/* Be a bit paranoid about path */
if|if
condition|(
operator|!
name|path
operator|||
name|os_strncmp
argument_list|(
name|path
argument_list|,
name|WPAS_DBUS_NEW_PATH_INTERFACES
literal|"/"
argument_list|,
name|dev_path_prefix_len
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Ensure there's something at the end of the path */
if|if
condition|(
operator|(
name|path
operator|+
name|dev_path_prefix_len
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|obj_path_only
operator|=
name|os_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_path_only
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|next_sep
operator|=
name|os_strchr
argument_list|(
name|obj_path_only
operator|+
name|dev_path_prefix_len
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_sep
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|net_part
init|=
name|os_strstr
argument_list|(
name|next_sep
argument_list|,
name|p2p_persistent_group
condition|?
name|WPAS_DBUS_NEW_PERSISTENT_GROUPS_PART
literal|"/"
else|:
name|WPAS_DBUS_NEW_NETWORKS_PART
literal|"/"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|bssid_part
init|=
name|os_strstr
argument_list|(
name|next_sep
argument_list|,
name|WPAS_DBUS_NEW_BSSIDS_PART
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|network
operator|&&
name|net_part
condition|)
block|{
comment|/* Deal with a request for a configured network */
specifier|const
name|char
modifier|*
name|net_name
init|=
name|net_part
operator|+
name|os_strlen
argument_list|(
name|p2p_persistent_group
condition|?
name|WPAS_DBUS_NEW_PERSISTENT_GROUPS_PART
literal|"/"
else|:
name|WPAS_DBUS_NEW_NETWORKS_PART
literal|"/"
argument_list|)
decl_stmt|;
operator|*
name|network
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|os_strlen
argument_list|(
name|net_name
argument_list|)
condition|)
operator|*
name|network
operator|=
name|os_strdup
argument_list|(
name|net_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bssid
operator|&&
name|bssid_part
condition|)
block|{
comment|/* Deal with a request for a scanned BSSID */
specifier|const
name|char
modifier|*
name|bssid_name
init|=
name|bssid_part
operator|+
name|os_strlen
argument_list|(
name|WPAS_DBUS_NEW_BSSIDS_PART
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|os_strlen
argument_list|(
name|bssid_name
argument_list|)
condition|)
operator|*
name|bssid
operator|=
name|os_strdup
argument_list|(
name|bssid_name
argument_list|)
expr_stmt|;
else|else
operator|*
name|bssid
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Cut off interface object path before "/" */
operator|*
name|next_sep
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|obj_path_only
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_reply_new_from_error - Create a new D-Bus error message from a  *   dbus error structure  * @message: The original request message for which the error is a reply  * @error: The error containing a name and a descriptive error cause  * @fallback_name: A generic error name if @error was not set  * @fallback_string: A generic error string if @error was not set  * Returns: A new D-Bus error message  *  * Given a DBusMessage structure, creates a new D-Bus error message using  * the error name and string contained in that structure.  */
end_comment

begin_function
name|DBusMessage
modifier|*
name|wpas_dbus_reply_new_from_error
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|DBusError
modifier|*
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fallback_name
parameter_list|,
specifier|const
name|char
modifier|*
name|fallback_string
parameter_list|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|->
name|name
operator|&&
name|error
operator|->
name|message
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|error
operator|->
name|name
argument_list|,
name|error
operator|->
name|message
argument_list|)
return|;
block|}
if|if
condition|(
name|fallback_name
operator|&&
name|fallback_string
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|fallback_name
argument_list|,
name|fallback_string
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

