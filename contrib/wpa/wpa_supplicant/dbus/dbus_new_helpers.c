begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant / dbus-based control interface  * Copyright (c) 2006, Dan Williams<dcbw@redhat.com> and Red Hat, Inc.  * Copyright (c) 2009, Witold Sowa<witold.sowa@gmail.com>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|"utils/includes.h"
end_include

begin_include
include|#
directive|include
file|"utils/common.h"
end_include

begin_include
include|#
directive|include
file|"utils/eloop.h"
end_include

begin_include
include|#
directive|include
file|"dbus_common.h"
end_include

begin_include
include|#
directive|include
file|"dbus_common_i.h"
end_include

begin_include
include|#
directive|include
file|"dbus_new.h"
end_include

begin_include
include|#
directive|include
file|"dbus_new_helpers.h"
end_include

begin_comment
comment|/**  * recursive_iter_copy - Reads arguments from one iterator and  * writes to another recursively  * @from: iterator to read from  * @to: iterator to write to  *  * Copies one iterator's elements to another. If any element in  * iterator is of container type, its content is copied recursively  */
end_comment

begin_function
specifier|static
name|void
name|recursive_iter_copy
parameter_list|(
name|DBusMessageIter
modifier|*
name|from
parameter_list|,
name|DBusMessageIter
modifier|*
name|to
parameter_list|)
block|{
name|char
modifier|*
name|subtype
init|=
name|NULL
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* iterate over iterator to copy */
while|while
condition|(
operator|(
name|type
operator|=
name|dbus_message_iter_get_arg_type
argument_list|(
name|from
argument_list|)
operator|)
operator|!=
name|DBUS_TYPE_INVALID
condition|)
block|{
comment|/* simply copy basic type entries */
if|if
condition|(
name|dbus_type_is_basic
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|dbus_type_is_fixed
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* 				 * According to DBus documentation all 				 * fixed-length types are guaranteed to fit 				 * 8 bytes 				 */
name|dbus_uint64_t
name|v
decl_stmt|;
name|dbus_message_iter_get_basic
argument_list|(
name|from
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|dbus_message_iter_append_basic
argument_list|(
name|to
argument_list|,
name|type
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|v
decl_stmt|;
name|dbus_message_iter_get_basic
argument_list|(
name|from
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|dbus_message_iter_append_basic
argument_list|(
name|to
argument_list|,
name|type
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* recursively copy container type entries */
name|DBusMessageIter
name|write_subiter
decl_stmt|,
name|read_subiter
decl_stmt|;
name|dbus_message_iter_recurse
argument_list|(
name|from
argument_list|,
operator|&
name|read_subiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DBUS_TYPE_VARIANT
operator|||
name|type
operator|==
name|DBUS_TYPE_ARRAY
condition|)
block|{
name|subtype
operator|=
name|dbus_message_iter_get_signature
argument_list|(
operator|&
name|read_subiter
argument_list|)
expr_stmt|;
block|}
name|dbus_message_iter_open_container
argument_list|(
name|to
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|,
operator|&
name|write_subiter
argument_list|)
expr_stmt|;
name|recursive_iter_copy
argument_list|(
operator|&
name|read_subiter
argument_list|,
operator|&
name|write_subiter
argument_list|)
expr_stmt|;
name|dbus_message_iter_close_container
argument_list|(
name|to
argument_list|,
operator|&
name|write_subiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype
condition|)
name|dbus_free
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
block|}
name|dbus_message_iter_next
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|fill_dict_with_properties
parameter_list|(
name|DBusMessageIter
modifier|*
name|dict_iter
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
specifier|const
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|reply
decl_stmt|;
name|DBusMessageIter
name|entry_iter
decl_stmt|,
name|ret_iter
decl_stmt|;
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
decl_stmt|;
for|for
control|(
name|dsc
operator|=
name|props
init|;
name|dsc
operator|&&
name|dsc
operator|->
name|dbus_property
condition|;
name|dsc
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|dsc
operator|->
name|dbus_interface
argument_list|,
name|interface
argument_list|,
name|WPAS_DBUS_INTERFACE_MAX
argument_list|)
operator|&&
name|dsc
operator|->
name|access
operator|!=
name|W
operator|&&
name|dsc
operator|->
name|getter
condition|)
block|{
name|reply
operator|=
name|dsc
operator|->
name|getter
argument_list|(
name|NULL
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reply
condition|)
continue|continue;
if|if
condition|(
name|dbus_message_get_type
argument_list|(
name|reply
argument_list|)
operator|==
name|DBUS_MESSAGE_TYPE_ERROR
condition|)
block|{
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dbus_message_iter_init
argument_list|(
name|reply
argument_list|,
operator|&
name|ret_iter
argument_list|)
expr_stmt|;
name|dbus_message_iter_open_container
argument_list|(
name|dict_iter
argument_list|,
name|DBUS_TYPE_DICT_ENTRY
argument_list|,
name|NULL
argument_list|,
operator|&
name|entry_iter
argument_list|)
expr_stmt|;
name|dbus_message_iter_append_basic
argument_list|(
operator|&
name|entry_iter
argument_list|,
name|DBUS_TYPE_STRING
argument_list|,
operator|&
name|dsc
operator|->
name|dbus_property
argument_list|)
expr_stmt|;
name|recursive_iter_copy
argument_list|(
operator|&
name|ret_iter
argument_list|,
operator|&
name|entry_iter
argument_list|)
expr_stmt|;
name|dbus_message_iter_close_container
argument_list|(
name|dict_iter
argument_list|,
operator|&
name|entry_iter
argument_list|)
expr_stmt|;
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
block|}
return|return
name|counter
return|;
block|}
end_function

begin_comment
comment|/**  * get_all_properties - Responds for GetAll properties calls on object  * @message: Message with GetAll call  * @interface: interface name which properties will be returned  * @property_dsc: list of object's properties  * Returns: Message with dict of variants as argument with properties values  *  * Iterates over all properties registered with object and execute getters  * of those, which are readable and which interface matches interface  * specified as argument. Returned message contains one dict argument  * with properties names as keys and theirs values as values.  */
end_comment

begin_function
specifier|static
name|DBusMessage
modifier|*
name|get_all_properties
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|char
modifier|*
name|interface
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
comment|/* Create and initialize the return message */
name|DBusMessage
modifier|*
name|reply
init|=
name|dbus_message_new_method_return
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|DBusMessageIter
name|iter
decl_stmt|,
name|dict_iter
decl_stmt|;
name|int
name|props_num
decl_stmt|;
name|dbus_message_iter_init_append
argument_list|(
name|reply
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|dbus_message_iter_open_container
argument_list|(
argument|&iter
argument_list|,
argument|DBUS_TYPE_ARRAY
argument_list|,
argument|DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING 					 DBUS_TYPE_STRING_AS_STRING 					 DBUS_TYPE_VARIANT_AS_STRING 					 DBUS_DICT_ENTRY_END_CHAR_AS_STRING
argument_list|,
argument|&dict_iter
argument_list|)
empty_stmt|;
name|props_num
operator|=
name|fill_dict_with_properties
argument_list|(
operator|&
name|dict_iter
argument_list|,
name|obj_dsc
operator|->
name|properties
argument_list|,
name|interface
argument_list|,
name|obj_dsc
operator|->
name|user_data
argument_list|)
expr_stmt|;
name|dbus_message_iter_close_container
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
name|dict_iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|props_num
operator|==
literal|0
condition|)
block|{
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|reply
operator|=
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
literal|"No readable properties in "
literal|"this interface"
argument_list|)
expr_stmt|;
block|}
return|return
name|reply
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_signature_correct
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_method_desc
modifier|*
name|method_dsc
parameter_list|)
block|{
comment|/* According to DBus documentation max length of signature is 255 */
define|#
directive|define
name|MAX_SIG_LEN
value|256
name|char
name|registered_sig
index|[
name|MAX_SIG_LEN
index|]
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
specifier|const
name|char
modifier|*
name|sig
init|=
name|dbus_message_get_signature
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|const
name|struct
name|wpa_dbus_argument
modifier|*
name|arg
decl_stmt|;
name|pos
operator|=
name|registered_sig
expr_stmt|;
operator|*
name|pos
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|method_dsc
operator|->
name|args
init|;
name|arg
operator|&&
name|arg
operator|->
name|name
condition|;
name|arg
operator|++
control|)
block|{
if|if
condition|(
name|arg
operator|->
name|dir
operator|==
name|ARG_IN
condition|)
block|{
name|size_t
name|blen
init|=
name|registered_sig
operator|+
name|MAX_SIG_LEN
operator|-
name|pos
decl_stmt|;
name|ret
operator|=
name|os_snprintf
argument_list|(
name|pos
argument_list|,
name|blen
argument_list|,
literal|"%s"
argument_list|,
name|arg
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|ret
operator|>=
name|blen
condition|)
return|return
literal|0
return|;
name|pos
operator|+=
name|ret
expr_stmt|;
block|}
block|}
return|return
operator|!
name|os_strncmp
argument_list|(
name|registered_sig
argument_list|,
name|sig
argument_list|,
name|MAX_SIG_LEN
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|properties_get_all
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|char
modifier|*
name|interface
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
if|if
condition|(
name|os_strcmp
argument_list|(
name|dbus_message_get_signature
argument_list|(
name|message
argument_list|)
argument_list|,
literal|"s"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|get_all_properties
argument_list|(
name|message
argument_list|,
name|interface
argument_list|,
name|obj_dsc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|properties_get
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
if|if
condition|(
name|os_strcmp
argument_list|(
name|dbus_message_get_signature
argument_list|(
name|message
argument_list|)
argument_list|,
literal|"ss"
argument_list|)
condition|)
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|dsc
operator|->
name|access
operator|!=
name|W
operator|&&
name|dsc
operator|->
name|getter
condition|)
return|return
name|dsc
operator|->
name|getter
argument_list|(
name|message
argument_list|,
name|user_data
argument_list|)
return|;
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
literal|"Property is write-only"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|properties_set
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
if|if
condition|(
name|os_strcmp
argument_list|(
name|dbus_message_get_signature
argument_list|(
name|message
argument_list|)
argument_list|,
literal|"ssv"
argument_list|)
condition|)
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|dsc
operator|->
name|access
operator|!=
name|R
operator|&&
name|dsc
operator|->
name|setter
condition|)
return|return
name|dsc
operator|->
name|setter
argument_list|(
name|message
argument_list|,
name|user_data
argument_list|)
return|;
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
literal|"Property is read-only"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|properties_get_or_set
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|DBusMessageIter
modifier|*
name|iter
parameter_list|,
name|char
modifier|*
name|interface
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|property_dsc
decl_stmt|;
name|char
modifier|*
name|property
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
name|method
operator|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|property_dsc
operator|=
name|obj_dsc
operator|->
name|properties
expr_stmt|;
comment|/* Second argument: property name (DBUS_TYPE_STRING) */
if|if
condition|(
operator|!
name|dbus_message_iter_next
argument_list|(
name|iter
argument_list|)
operator|||
name|dbus_message_iter_get_arg_type
argument_list|(
name|iter
argument_list|)
operator|!=
name|DBUS_TYPE_STRING
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|dbus_message_iter_get_basic
argument_list|(
name|iter
argument_list|,
operator|&
name|property
argument_list|)
expr_stmt|;
while|while
condition|(
name|property_dsc
operator|&&
name|property_dsc
operator|->
name|dbus_property
condition|)
block|{
comment|/* compare property names and 		 * interfaces */
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|property_dsc
operator|->
name|dbus_property
argument_list|,
name|property
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|&&
operator|!
name|os_strncmp
argument_list|(
name|property_dsc
operator|->
name|dbus_interface
argument_list|,
name|interface
argument_list|,
name|WPAS_DBUS_INTERFACE_MAX
argument_list|)
condition|)
break|break;
name|property_dsc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|property_dsc
operator|==
name|NULL
operator|||
name|property_dsc
operator|->
name|dbus_property
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"no property handler for %s.%s on %s"
argument_list|,
name|interface
argument_list|,
name|property
argument_list|,
name|dbus_message_get_path
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
literal|"No such property"
argument_list|)
return|;
block|}
if|if
condition|(
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_GET
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|==
literal|0
condition|)
return|return
name|properties_get
argument_list|(
name|message
argument_list|,
name|property_dsc
argument_list|,
name|obj_dsc
operator|->
name|user_data
argument_list|)
return|;
return|return
name|properties_set
argument_list|(
name|message
argument_list|,
name|property_dsc
argument_list|,
name|obj_dsc
operator|->
name|user_data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|properties_handler
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
name|DBusMessageIter
name|iter
decl_stmt|;
name|char
modifier|*
name|interface
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
name|method
operator|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|dbus_message_iter_init
argument_list|(
name|message
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_GET
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|||
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_SET
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|||
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_GETALL
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
condition|)
block|{
comment|/* First argument: interface name (DBUS_TYPE_STRING) */
if|if
condition|(
name|dbus_message_iter_get_arg_type
argument_list|(
operator|&
name|iter
argument_list|)
operator|!=
name|DBUS_TYPE_STRING
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|dbus_message_iter_get_basic
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_GETALL
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
condition|)
block|{
comment|/* GetAll */
return|return
name|properties_get_all
argument_list|(
name|message
argument_list|,
name|interface
argument_list|,
name|obj_dsc
argument_list|)
return|;
block|}
comment|/* Get or Set */
return|return
name|properties_get_or_set
argument_list|(
name|message
argument_list|,
operator|&
name|iter
argument_list|,
name|interface
argument_list|,
name|obj_dsc
argument_list|)
return|;
block|}
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_UNKNOWN_METHOD
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|DBusMessage
modifier|*
name|msg_method_handler
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
specifier|const
name|struct
name|wpa_dbus_method_desc
modifier|*
name|method_dsc
init|=
name|obj_dsc
operator|->
name|methods
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg_interface
decl_stmt|;
name|method
operator|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|msg_interface
operator|=
name|dbus_message_get_interface
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|/* try match call to any registered method */
while|while
condition|(
name|method_dsc
operator|&&
name|method_dsc
operator|->
name|dbus_method
condition|)
block|{
comment|/* compare method names and interfaces */
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|method_dsc
operator|->
name|dbus_method
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|&&
operator|!
name|os_strncmp
argument_list|(
name|method_dsc
operator|->
name|dbus_interface
argument_list|,
name|msg_interface
argument_list|,
name|WPAS_DBUS_INTERFACE_MAX
argument_list|)
condition|)
break|break;
name|method_dsc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|method_dsc
operator|==
name|NULL
operator|||
name|method_dsc
operator|->
name|dbus_method
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"no method handler for %s.%s on %s"
argument_list|,
name|msg_interface
argument_list|,
name|method
argument_list|,
name|dbus_message_get_path
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_UNKNOWN_METHOD
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|is_signature_correct
argument_list|(
name|message
argument_list|,
name|method_dsc
argument_list|)
condition|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_INVALID_ARGS
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|method_dsc
operator|->
name|method_handler
argument_list|(
name|message
argument_list|,
name|obj_dsc
operator|->
name|user_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * message_handler - Handles incoming DBus messages  * @connection: DBus connection on which message was received  * @message: Received message  * @user_data: pointer to description of object to which message was sent  * Returns: Returns information whether message was handled or not  *  * Reads message interface and method name, then checks if they matches one  * of the special cases i.e. introspection call or properties get/getall/set  * methods and handles it. Else it iterates over registered methods list  * and tries to match method's name and interface to those read from message  * If appropriate method was found its handler function is called and  * response is sent. Otherwise, the DBUS_ERROR_UNKNOWN_METHOD error message  * will be sent.  */
end_comment

begin_function
specifier|static
name|DBusHandlerResult
name|message_handler
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
init|=
name|user_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg_interface
decl_stmt|;
name|DBusMessage
modifier|*
name|reply
decl_stmt|;
comment|/* get method, interface and path the message is addressed to */
name|method
operator|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|path
operator|=
name|dbus_message_get_path
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|msg_interface
operator|=
name|dbus_message_get_interface
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method
operator|||
operator|!
name|path
operator|||
operator|!
name|msg_interface
condition|)
return|return
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"dbus: %s.%s (%s)"
argument_list|,
name|msg_interface
argument_list|,
name|method
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* if message is introspection method call */
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_INTROSPECTION_METHOD
argument_list|,
name|method
argument_list|,
name|WPAS_DBUS_METHOD_SIGNAL_PROP_MAX
argument_list|)
operator|&&
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_INTROSPECTION_INTERFACE
argument_list|,
name|msg_interface
argument_list|,
name|WPAS_DBUS_INTERFACE_MAX
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_CTRL_IFACE_DBUS_INTRO
name|reply
operator|=
name|wpa_dbus_introspect
argument_list|(
name|message
argument_list|,
name|obj_dsc
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CONFIG_CTRL_IFACE_DBUS_INTRO */
name|reply
operator|=
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|DBUS_ERROR_UNKNOWN_METHOD
argument_list|,
literal|"wpa_supplicant was compiled without "
literal|"introspection support."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_CTRL_IFACE_DBUS_INTRO */
block|}
elseif|else
if|if
condition|(
operator|!
name|os_strncmp
argument_list|(
name|WPA_DBUS_PROPERTIES_INTERFACE
argument_list|,
name|msg_interface
argument_list|,
name|WPAS_DBUS_INTERFACE_MAX
argument_list|)
condition|)
block|{
comment|/* if message is properties method call */
name|reply
operator|=
name|properties_handler
argument_list|(
name|message
argument_list|,
name|obj_dsc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reply
operator|=
name|msg_method_handler
argument_list|(
name|message
argument_list|,
name|obj_dsc
argument_list|)
expr_stmt|;
block|}
comment|/* If handler succeed returning NULL, reply empty message */
if|if
condition|(
operator|!
name|reply
condition|)
name|reply
operator|=
name|dbus_message_new_method_return
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
if|if
condition|(
operator|!
name|dbus_message_get_no_reply
argument_list|(
name|message
argument_list|)
condition|)
name|dbus_connection_send
argument_list|(
name|connection
argument_list|,
name|reply
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
name|wpa_dbus_flush_all_changed_properties
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|DBUS_HANDLER_RESULT_HANDLED
return|;
block|}
end_function

begin_comment
comment|/**  * free_dbus_object_desc - Frees object description data structure  * @connection: DBus connection  * @obj_dsc: Object description to free  *  * Frees each of properties, methods and signals description lists and  * the object description structure itself.  */
end_comment

begin_function
name|void
name|free_dbus_object_desc
parameter_list|(
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obj_dsc
condition|)
return|return;
comment|/* free handler's argument */
if|if
condition|(
name|obj_dsc
operator|->
name|user_data_free_func
condition|)
name|obj_dsc
operator|->
name|user_data_free_func
argument_list|(
name|obj_dsc
operator|->
name|user_data
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|obj_dsc
operator|->
name|path
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|obj_dsc
operator|->
name|prop_changed_flags
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|obj_dsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_dbus_object_desc_cb
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|void
modifier|*
name|obj_dsc
parameter_list|)
block|{
name|free_dbus_object_desc
argument_list|(
name|obj_dsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_dbus_ctrl_iface_init - Initialize dbus control interface  * @application_data: Pointer to application specific data structure  * @dbus_path: DBus path to interface object  * @dbus_service: DBus service name to register with  * @messageHandler: a pointer to function which will handle dbus messages  * coming on interface  * Returns: 0 on success, -1 on failure  *  * Initialize the dbus control interface and start receiving commands from  * external programs over the bus.  */
end_comment

begin_function
name|int
name|wpa_dbus_ctrl_iface_init
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
parameter_list|,
name|char
modifier|*
name|dbus_path
parameter_list|,
name|char
modifier|*
name|dbus_service
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
parameter_list|)
block|{
name|DBusError
name|error
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|DBusObjectPathVTable
name|wpa_vtable
init|=
block|{
operator|&
name|free_dbus_object_desc_cb
block|,
operator|&
name|message_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|obj_desc
operator|->
name|connection
operator|=
name|iface
operator|->
name|con
expr_stmt|;
name|obj_desc
operator|->
name|path
operator|=
name|os_strdup
argument_list|(
name|dbus_path
argument_list|)
expr_stmt|;
comment|/* Register the message handler for the global dbus interface */
if|if
condition|(
operator|!
name|dbus_connection_register_object_path
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|dbus_path
argument_list|,
operator|&
name|wpa_vtable
argument_list|,
name|obj_desc
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not set up message "
literal|"handler"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Register our service with the message bus */
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dbus_bus_request_name
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|dbus_service
argument_list|,
literal|0
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
case|case
name|DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER
case|:
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DBUS_REQUEST_NAME_REPLY_EXISTS
case|:
case|case
name|DBUS_REQUEST_NAME_REPLY_IN_QUEUE
case|:
case|case
name|DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER
case|:
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not request service name: "
literal|"already registered"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not request service name: "
literal|"%s %s"
argument_list|,
name|error
operator|.
name|name
argument_list|,
name|error
operator|.
name|message
argument_list|)
expr_stmt|;
break|break;
block|}
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Providing DBus service '%s'."
argument_list|,
name|dbus_service
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_dbus_register_object_per_iface - Register a new object with dbus  * @ctrl_iface: pointer to dbus private data  * @path: DBus path to object  * @ifname: interface name  * @obj_desc: description of object's methods, signals and properties  * Returns: 0 on success, -1 on error  *  * Registers a new interface with dbus and assigns it a dbus object path.  */
end_comment

begin_function
name|int
name|wpa_dbus_register_object_per_iface
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|ctrl_iface
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
parameter_list|)
block|{
name|DBusConnection
modifier|*
name|con
decl_stmt|;
name|DBusObjectPathVTable
name|vtable
init|=
block|{
operator|&
name|free_dbus_object_desc_cb
block|,
operator|&
name|message_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|ctrl_iface
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|con
operator|=
name|ctrl_iface
operator|->
name|con
expr_stmt|;
name|obj_desc
operator|->
name|connection
operator|=
name|con
expr_stmt|;
name|obj_desc
operator|->
name|path
operator|=
name|os_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* Register the message handler for the interface functions */
if|if
condition|(
operator|!
name|dbus_connection_register_object_path
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
operator|&
name|vtable
argument_list|,
name|obj_desc
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not set up message "
literal|"handler for interface %s object %s"
argument_list|,
name|ifname
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|flush_object_timeout_handler
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * wpa_dbus_unregister_object_per_iface - Unregisters DBus object  * @ctrl_iface: Pointer to dbus private data  * @path: DBus path to object which will be unregistered  * Returns: Zero on success and -1 on failure  *  * Unregisters DBus object given by its path  */
end_comment

begin_function
name|int
name|wpa_dbus_unregister_object_per_iface
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|ctrl_iface
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|DBusConnection
modifier|*
name|con
init|=
name|ctrl_iface
operator|->
name|con
decl_stmt|;
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
init|=
name|NULL
decl_stmt|;
name|dbus_connection_get_object_path_data
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|obj_desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_desc
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: %s: Could not obtain object's "
literal|"private data: %s"
argument_list|,
name|__func__
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eloop_cancel_timeout
argument_list|(
name|flush_object_timeout_handler
argument_list|,
name|con
argument_list|,
name|obj_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dbus_connection_unregister_object_path
argument_list|(
name|con
argument_list|,
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_changed_properties
parameter_list|(
specifier|const
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
name|DBusMessageIter
modifier|*
name|dict_iter
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|getter_reply
decl_stmt|;
name|DBusMessageIter
name|prop_iter
decl_stmt|,
name|entry_iter
decl_stmt|;
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|dsc
operator|=
name|obj_dsc
operator|->
name|properties
operator|,
name|i
operator|=
literal|0
init|;
name|dsc
operator|&&
name|dsc
operator|->
name|dbus_property
condition|;
name|dsc
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|obj_dsc
operator|->
name|prop_changed_flags
operator|==
name|NULL
operator|||
operator|!
name|obj_dsc
operator|->
name|prop_changed_flags
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|os_strcmp
argument_list|(
name|dsc
operator|->
name|dbus_interface
argument_list|,
name|interface
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|obj_dsc
operator|->
name|prop_changed_flags
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|getter_reply
operator|=
name|dsc
operator|->
name|getter
argument_list|(
name|NULL
argument_list|,
name|obj_dsc
operator|->
name|user_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getter_reply
operator|||
name|dbus_message_get_type
argument_list|(
name|getter_reply
argument_list|)
operator|==
name|DBUS_MESSAGE_TYPE_ERROR
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: %s: Cannot get new value "
literal|"of property %s"
argument_list|,
name|__func__
argument_list|,
name|dsc
operator|->
name|dbus_property
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|dbus_message_iter_init
argument_list|(
name|getter_reply
argument_list|,
operator|&
name|prop_iter
argument_list|)
operator|||
operator|!
name|dbus_message_iter_open_container
argument_list|(
name|dict_iter
argument_list|,
name|DBUS_TYPE_DICT_ENTRY
argument_list|,
name|NULL
argument_list|,
operator|&
name|entry_iter
argument_list|)
operator|||
operator|!
name|dbus_message_iter_append_basic
argument_list|(
operator|&
name|entry_iter
argument_list|,
name|DBUS_TYPE_STRING
argument_list|,
operator|&
name|dsc
operator|->
name|dbus_property
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|recursive_iter_copy
argument_list|(
operator|&
name|prop_iter
argument_list|,
operator|&
name|entry_iter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbus_message_iter_close_container
argument_list|(
name|dict_iter
argument_list|,
operator|&
name|entry_iter
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|dbus_message_unref
argument_list|(
name|getter_reply
argument_list|)
expr_stmt|;
block|}
return|return;
name|err
label|:
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: %s: Cannot construct signal"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_prop_changed_signal
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
specifier|const
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_dsc
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|msg
decl_stmt|;
name|DBusMessageIter
name|signal_iter
decl_stmt|,
name|dict_iter
decl_stmt|;
name|msg
operator|=
name|dbus_message_new_signal
argument_list|(
name|path
argument_list|,
name|interface
argument_list|,
literal|"PropertiesChanged"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
name|dbus_message_iter_init_append
argument_list|(
name|msg
argument_list|,
operator|&
name|signal_iter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbus_message_iter_open_container
argument_list|(
operator|&
name|signal_iter
argument_list|,
name|DBUS_TYPE_ARRAY
argument_list|,
literal|"{sv}"
argument_list|,
operator|&
name|dict_iter
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|put_changed_properties
argument_list|(
name|obj_dsc
argument_list|,
name|interface
argument_list|,
operator|&
name|dict_iter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbus_message_iter_close_container
argument_list|(
operator|&
name|signal_iter
argument_list|,
operator|&
name|dict_iter
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|dbus_connection_send
argument_list|(
name|con
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
name|dbus_message_unref
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"dbus: %s: Failed to construct signal"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_object_timeout_handler
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|DBusConnection
modifier|*
name|con
init|=
name|eloop_ctx
decl_stmt|;
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
init|=
name|timeout_ctx
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"dbus: %s: Timeout - sending changed properties "
literal|"of object %s"
argument_list|,
name|__func__
argument_list|,
name|obj_desc
operator|->
name|path
argument_list|)
expr_stmt|;
name|wpa_dbus_flush_object_changed_properties
argument_list|(
name|con
argument_list|,
name|obj_desc
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|recursive_flush_changed_properties
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|objects
init|=
name|NULL
decl_stmt|;
name|char
name|subobj_path
index|[
name|WPAS_DBUS_OBJECT_PATH_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|wpa_dbus_flush_object_changed_properties
argument_list|(
name|con
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbus_connection_list_registered
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
operator|&
name|objects
argument_list|)
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|objects
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|os_snprintf
argument_list|(
name|subobj_path
argument_list|,
name|WPAS_DBUS_OBJECT_PATH_MAX
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|objects
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|recursive_flush_changed_properties
argument_list|(
name|con
argument_list|,
name|subobj_path
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|dbus_free_string_array
argument_list|(
name|objects
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_dbus_flush_all_changed_properties - Send all PropertiesChanged signals  * @con: DBus connection  *  * Traverses through all registered objects and sends PropertiesChanged for  * each properties.  */
end_comment

begin_function
name|void
name|wpa_dbus_flush_all_changed_properties
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|)
block|{
name|recursive_flush_changed_properties
argument_list|(
name|con
argument_list|,
name|WPAS_DBUS_NEW_PATH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_dbus_flush_object_changed_properties - Send PropertiesChanged for object  * @con: DBus connection  * @path: path to a DBus object for which PropertiesChanged will be sent.  *  * Iterates over all properties registered with object and for each interface  * containing properties marked as changed, sends a PropertiesChanged signal  * containing names and new values of properties that have changed.  *  * You need to call this function after wpa_dbus_mark_property_changed()  * if you want to send PropertiesChanged signal immediately (i.e., without  * waiting timeout to expire). PropertiesChanged signal for an object is sent  * automatically short time after first marking property as changed. All  * PropertiesChanged signals are sent automatically after responding on DBus  * message, so if you marked a property changed as a result of DBus call  * (e.g., param setter), you usually do not need to call this function.  */
end_comment

begin_function
name|void
name|wpa_dbus_flush_object_changed_properties
parameter_list|(
name|DBusConnection
modifier|*
name|con
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dbus_connection_get_object_path_data
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|obj_desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_desc
condition|)
return|return;
name|eloop_cancel_timeout
argument_list|(
name|flush_object_timeout_handler
argument_list|,
name|con
argument_list|,
name|obj_desc
argument_list|)
expr_stmt|;
name|dsc
operator|=
name|obj_desc
operator|->
name|properties
expr_stmt|;
for|for
control|(
name|dsc
operator|=
name|obj_desc
operator|->
name|properties
operator|,
name|i
operator|=
literal|0
init|;
name|dsc
operator|&&
name|dsc
operator|->
name|dbus_property
condition|;
name|dsc
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|obj_desc
operator|->
name|prop_changed_flags
operator|==
name|NULL
operator|||
operator|!
name|obj_desc
operator|->
name|prop_changed_flags
index|[
name|i
index|]
condition|)
continue|continue;
name|send_prop_changed_signal
argument_list|(
name|con
argument_list|,
name|path
argument_list|,
name|dsc
operator|->
name|dbus_interface
argument_list|,
name|obj_desc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|WPA_DBUS_SEND_PROP_CHANGED_TIMEOUT
value|5000
end_define

begin_comment
comment|/**  * wpa_dbus_mark_property_changed - Mark a property as changed and  * @iface: dbus priv struct  * @path: path to DBus object which property has changed  * @interface: interface containing changed property  * @property: property name which has changed  *  * Iterates over all properties registered with an object and marks the one  * given in parameters as changed. All parameters registered for an object  * within a single interface will be aggregated together and sent in one  * PropertiesChanged signal when function  * wpa_dbus_flush_object_changed_properties() is called.  */
end_comment

begin_function
name|void
name|wpa_dbus_mark_property_changed
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
specifier|const
name|char
modifier|*
name|property
parameter_list|)
block|{
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|wpa_dbus_property_desc
modifier|*
name|dsc
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return;
name|dbus_connection_get_object_path_data
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|path
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|obj_desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_desc
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: wpa_dbus_property_changed: "
literal|"could not obtain object's private data: %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|dsc
operator|=
name|obj_desc
operator|->
name|properties
init|;
name|dsc
operator|&&
name|dsc
operator|->
name|dbus_property
condition|;
name|dsc
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|os_strcmp
argument_list|(
name|property
argument_list|,
name|dsc
operator|->
name|dbus_property
argument_list|)
operator|==
literal|0
operator|&&
name|os_strcmp
argument_list|(
name|interface
argument_list|,
name|dsc
operator|->
name|dbus_interface
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|obj_desc
operator|->
name|prop_changed_flags
condition|)
name|obj_desc
operator|->
name|prop_changed_flags
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|dsc
operator|||
operator|!
name|dsc
operator|->
name|dbus_property
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: wpa_dbus_property_changed: "
literal|"no property %s in object %s"
argument_list|,
name|property
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|eloop_is_timeout_registered
argument_list|(
name|flush_object_timeout_handler
argument_list|,
name|iface
operator|->
name|con
argument_list|,
name|obj_desc
operator|->
name|path
argument_list|)
condition|)
block|{
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
name|WPA_DBUS_SEND_PROP_CHANGED_TIMEOUT
argument_list|,
name|flush_object_timeout_handler
argument_list|,
name|iface
operator|->
name|con
argument_list|,
name|obj_desc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * wpa_dbus_get_object_properties - Put object's properties into dictionary  * @iface: dbus priv struct  * @path: path to DBus object which properties will be obtained  * @interface: interface name which properties will be obtained  * @dict_iter: correct, open DBus dictionary iterator.  *  * Iterates over all properties registered with object and execute getters  * of those, which are readable and which interface matches interface  * specified as argument. Obtained properties values are stored in  * dict_iter dictionary.  */
end_comment

begin_function
name|void
name|wpa_dbus_get_object_properties
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|interface
parameter_list|,
name|DBusMessageIter
modifier|*
name|dict_iter
parameter_list|)
block|{
name|struct
name|wpa_dbus_object_desc
modifier|*
name|obj_desc
init|=
name|NULL
decl_stmt|;
name|dbus_connection_get_object_path_data
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|path
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|obj_desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_desc
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: wpa_dbus_get_object_properties: "
literal|"could not obtain object's private data: %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|fill_dict_with_properties
argument_list|(
name|dict_iter
argument_list|,
name|obj_desc
operator|->
name|properties
argument_list|,
name|interface
argument_list|,
name|obj_desc
operator|->
name|user_data
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

