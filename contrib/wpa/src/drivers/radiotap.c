begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Radiotap parser  *  * Copyright 2007		Andy Green<andy@warmcat.com>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  *  *  * Modified for userspace by Johannes Berg<johannes@sipsolutions.net>  * I only modified some things on top to ease syncing should bugs be found.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"radiotap_iter.h"
end_include

begin_define
define|#
directive|define
name|le16_to_cpu
value|le_to_host16
end_define

begin_define
define|#
directive|define
name|le32_to_cpu
value|le_to_host32
end_define

begin_define
define|#
directive|define
name|__le32
value|uint32_t
end_define

begin_define
define|#
directive|define
name|ulong
value|unsigned long
end_define

begin_define
define|#
directive|define
name|unlikely
parameter_list|(
name|cond
parameter_list|)
value|(cond)
end_define

begin_define
define|#
directive|define
name|get_unaligned
parameter_list|(
name|p
parameter_list|)
define|\
value|({								\ 	struct packed_dummy_struct {				\ 		typeof(*(p)) __val;				\ 	} __attribute__((packed)) *__ptr = (void *) (p);	\ 								\ 	__ptr->__val;						\ })
end_define

begin_comment
comment|/* function prototypes and related defs are in radiotap_iter.h */
end_comment

begin_comment
comment|/**  * ieee80211_radiotap_iterator_init - radiotap parser iterator initialization  * @iterator: radiotap_iterator to initialize  * @radiotap_header: radiotap header to parse  * @max_length: total length we can parse into (eg, whole packet length)  *  * Returns: 0 or a negative error code if there is a problem.  *  * This function initializes an opaque iterator struct which can then  * be passed to ieee80211_radiotap_iterator_next() to visit every radiotap  * argument which is present in the header.  It knows about extended  * present headers and handles them.  *  * How to use:  * call __ieee80211_radiotap_iterator_init() to init a semi-opaque iterator  * struct ieee80211_radiotap_iterator (no need to init the struct beforehand)  * checking for a good 0 return code.  Then loop calling  * __ieee80211_radiotap_iterator_next()... it returns either 0,  * -ENOENT if there are no more args to parse, or -EINVAL if there is a problem.  * The iterator's @this_arg member points to the start of the argument  * associated with the current argument index that is present, which can be  * found in the iterator's @this_arg_index member.  This arg index corresponds  * to the IEEE80211_RADIOTAP_... defines.  *  * Radiotap header length:  * You can find the CPU-endian total radiotap header length in  * iterator->max_length after executing ieee80211_radiotap_iterator_init()  * successfully.  *  * Alignment Gotcha:  * You must take care when dereferencing iterator.this_arg  * for multibyte types... the pointer is not aligned.  Use  * get_unaligned((type *)iterator.this_arg) to dereference  * iterator.this_arg for type "type" safely on all arches.  *  * Example code:  * See Documentation/networking/radiotap-headers.txt  */
end_comment

begin_function
name|int
name|ieee80211_radiotap_iterator_init
parameter_list|(
name|struct
name|ieee80211_radiotap_iterator
modifier|*
name|iterator
parameter_list|,
name|struct
name|ieee80211_radiotap_header
modifier|*
name|radiotap_header
parameter_list|,
name|int
name|max_length
parameter_list|)
block|{
comment|/* Linux only supports version 0 radiotap format */
if|if
condition|(
name|radiotap_header
operator|->
name|it_version
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* sanity check for allowed length and radiotap length field */
if|if
condition|(
name|max_length
operator|<
name|le16_to_cpu
argument_list|(
name|get_unaligned
argument_list|(
operator|&
name|radiotap_header
operator|->
name|it_len
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|iterator
operator|->
name|rtheader
operator|=
name|radiotap_header
expr_stmt|;
name|iterator
operator|->
name|max_length
operator|=
name|le16_to_cpu
argument_list|(
name|get_unaligned
argument_list|(
operator|&
name|radiotap_header
operator|->
name|it_len
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|arg_index
operator|=
literal|0
expr_stmt|;
name|iterator
operator|->
name|bitmap_shifter
operator|=
name|le32_to_cpu
argument_list|(
name|get_unaligned
argument_list|(
operator|&
name|radiotap_header
operator|->
name|it_present
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|arg
operator|=
operator|(
name|u8
operator|*
operator|)
name|radiotap_header
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|radiotap_header
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|this_arg
operator|=
name|NULL
expr_stmt|;
comment|/* find payload start allowing for extended bitmap(s) */
if|if
condition|(
name|unlikely
argument_list|(
name|iterator
operator|->
name|bitmap_shifter
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_RADIOTAP_EXT
operator|)
argument_list|)
condition|)
block|{
while|while
condition|(
name|le32_to_cpu
argument_list|(
name|get_unaligned
argument_list|(
operator|(
name|__le32
operator|*
operator|)
name|iterator
operator|->
name|arg
argument_list|)
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_RADIOTAP_EXT
operator|)
condition|)
block|{
name|iterator
operator|->
name|arg
operator|+=
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
expr_stmt|;
comment|/* 			 * check for insanity where the present bitmaps 			 * keep claiming to extend up to or even beyond the 			 * stated radiotap header length 			 */
if|if
condition|(
operator|(
operator|(
name|ulong
operator|)
name|iterator
operator|->
name|arg
operator|-
operator|(
name|ulong
operator|)
name|iterator
operator|->
name|rtheader
operator|)
operator|>
operator|(
name|ulong
operator|)
name|iterator
operator|->
name|max_length
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|iterator
operator|->
name|arg
operator|+=
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
expr_stmt|;
comment|/* 		 * no need to check again for blowing past stated radiotap 		 * header length, because ieee80211_radiotap_iterator_next 		 * checks it before it is dereferenced 		 */
block|}
comment|/* we are all initialized happily */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * ieee80211_radiotap_iterator_next - return next radiotap parser iterator arg  * @iterator: radiotap_iterator to move to next arg (if any)  *  * Returns: 0 if there is an argument to handle,  * -ENOENT if there are no more args or -EINVAL  * if there is something else wrong.  *  * This function provides the next radiotap arg index (IEEE80211_RADIOTAP_*)  * in @this_arg_index and sets @this_arg to point to the  * payload for the field.  It takes care of alignment handling and extended  * present fields.  @this_arg can be changed by the caller (eg,  * incremented to move inside a compound argument like  * IEEE80211_RADIOTAP_CHANNEL).  The args pointed to are in  * little-endian format whatever the endianess of your CPU.  *  * Alignment Gotcha:  * You must take care when dereferencing iterator.this_arg  * for multibyte types... the pointer is not aligned.  Use  * get_unaligned((type *)iterator.this_arg) to dereference  * iterator.this_arg for type "type" safely on all arches.  */
end_comment

begin_function
name|int
name|ieee80211_radiotap_iterator_next
parameter_list|(
name|struct
name|ieee80211_radiotap_iterator
modifier|*
name|iterator
parameter_list|)
block|{
comment|/* 	 * small length lookup table for all radiotap types we heard of 	 * starting from b0 in the bitmap, so we can walk the payload 	 * area of the radiotap header 	 * 	 * There is a requirement to pad args, so that args 	 * of a given length must begin at a boundary of that length 	 * -- but note that compound args are allowed (eg, 2 x u16 	 * for IEEE80211_RADIOTAP_CHANNEL) so total arg length is not 	 * a reliable indicator of alignment requirement. 	 * 	 * upper nybble: content alignment for arg 	 * lower nybble: content length for arg 	 */
specifier|static
specifier|const
name|u8
name|rt_sizes
index|[]
init|=
block|{
index|[
name|IEEE80211_RADIOTAP_TSFT
index|]
operator|=
literal|0x88
block|,
index|[
name|IEEE80211_RADIOTAP_FLAGS
index|]
operator|=
literal|0x11
block|,
index|[
name|IEEE80211_RADIOTAP_RATE
index|]
operator|=
literal|0x11
block|,
index|[
name|IEEE80211_RADIOTAP_CHANNEL
index|]
operator|=
literal|0x24
block|,
index|[
name|IEEE80211_RADIOTAP_FHSS
index|]
operator|=
literal|0x22
block|,
index|[
name|IEEE80211_RADIOTAP_DBM_ANTSIGNAL
index|]
operator|=
literal|0x11
block|,
index|[
name|IEEE80211_RADIOTAP_DBM_ANTNOISE
index|]
operator|=
literal|0x11
block|,
index|[
name|IEEE80211_RADIOTAP_LOCK_QUALITY
index|]
operator|=
literal|0x22
block|,
index|[
name|IEEE80211_RADIOTAP_TX_ATTENUATION
index|]
operator|=
literal|0x22
block|,
index|[
name|IEEE80211_RADIOTAP_DB_TX_ATTENUATION
index|]
operator|=
literal|0x22
block|,
index|[
name|IEEE80211_RADIOTAP_DBM_TX_POWER
index|]
operator|=
literal|0x11
block|,
index|[
name|IEEE80211_RADIOTAP_ANTENNA
index|]
operator|=
literal|0x11
block|,
index|[
name|IEEE80211_RADIOTAP_DB_ANTSIGNAL
index|]
operator|=
literal|0x11
block|,
index|[
name|IEEE80211_RADIOTAP_DB_ANTNOISE
index|]
operator|=
literal|0x11
block|,
index|[
name|IEEE80211_RADIOTAP_RX_FLAGS
index|]
operator|=
literal|0x22
block|,
index|[
name|IEEE80211_RADIOTAP_TX_FLAGS
index|]
operator|=
literal|0x22
block|,
index|[
name|IEEE80211_RADIOTAP_RTS_RETRIES
index|]
operator|=
literal|0x11
block|,
index|[
name|IEEE80211_RADIOTAP_DATA_RETRIES
index|]
operator|=
literal|0x11
block|,
comment|/* 		 * add more here as they are defined in 		 * include/net/ieee80211_radiotap.h 		 */
block|}
decl_stmt|;
comment|/* 	 * for every radiotap entry we can at 	 * least skip (by knowing the length)... 	 */
while|while
condition|(
name|iterator
operator|->
name|arg_index
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|rt_sizes
argument_list|)
condition|)
block|{
name|int
name|hit
init|=
literal|0
decl_stmt|;
name|int
name|pad
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|iterator
operator|->
name|bitmap_shifter
operator|&
literal|1
operator|)
condition|)
goto|goto
name|next_entry
goto|;
comment|/* arg not present */
comment|/* 		 * arg is present, account for alignment padding 		 *  8-bit args can be at any alignment 		 * 16-bit args must start on 16-bit boundary 		 * 32-bit args must start on 32-bit boundary 		 * 64-bit args must start on 64-bit boundary 		 * 		 * note that total arg size can differ from alignment of 		 * elements inside arg, so we use upper nybble of length 		 * table to base alignment on 		 * 		 * also note: these alignments are ** relative to the 		 * start of the radiotap header **.  There is no guarantee 		 * that the radiotap header itself is aligned on any 		 * kind of boundary. 		 * 		 * the above is why get_unaligned() is used to dereference 		 * multibyte elements from the radiotap area 		 */
name|pad
operator|=
operator|(
operator|(
operator|(
name|ulong
operator|)
name|iterator
operator|->
name|arg
operator|)
operator|-
operator|(
operator|(
name|ulong
operator|)
name|iterator
operator|->
name|rtheader
operator|)
operator|)
operator|&
operator|(
operator|(
name|rt_sizes
index|[
name|iterator
operator|->
name|arg_index
index|]
operator|>>
literal|4
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|pad
condition|)
name|iterator
operator|->
name|arg
operator|+=
operator|(
name|rt_sizes
index|[
name|iterator
operator|->
name|arg_index
index|]
operator|>>
literal|4
operator|)
operator|-
name|pad
expr_stmt|;
comment|/* 		 * this is what we will return to user, but we need to 		 * move on first so next call has something fresh to test 		 */
name|iterator
operator|->
name|this_arg_index
operator|=
name|iterator
operator|->
name|arg_index
expr_stmt|;
name|iterator
operator|->
name|this_arg
operator|=
name|iterator
operator|->
name|arg
expr_stmt|;
name|hit
operator|=
literal|1
expr_stmt|;
comment|/* internally move on the size of this arg */
name|iterator
operator|->
name|arg
operator|+=
name|rt_sizes
index|[
name|iterator
operator|->
name|arg_index
index|]
operator|&
literal|0x0f
expr_stmt|;
comment|/* 		 * check for insanity where we are given a bitmap that 		 * claims to have more arg content than the length of the 		 * radiotap section.  We will normally end up equalling this 		 * max_length on the last arg, never exceeding it. 		 */
if|if
condition|(
operator|(
operator|(
name|ulong
operator|)
name|iterator
operator|->
name|arg
operator|-
operator|(
name|ulong
operator|)
name|iterator
operator|->
name|rtheader
operator|)
operator|>
operator|(
name|ulong
operator|)
name|iterator
operator|->
name|max_length
condition|)
return|return
operator|-
name|EINVAL
return|;
name|next_entry
label|:
name|iterator
operator|->
name|arg_index
operator|++
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|iterator
operator|->
name|arg_index
operator|&
literal|31
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
comment|/* completed current u32 bitmap */
if|if
condition|(
name|iterator
operator|->
name|bitmap_shifter
operator|&
literal|1
condition|)
block|{
comment|/* b31 was set, there is more */
comment|/* move to next u32 bitmap */
name|iterator
operator|->
name|bitmap_shifter
operator|=
name|le32_to_cpu
argument_list|(
name|get_unaligned
argument_list|(
name|iterator
operator|->
name|next_bitmap
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|next_bitmap
operator|++
expr_stmt|;
block|}
else|else
comment|/* no more bitmaps: end */
name|iterator
operator|->
name|arg_index
operator|=
sizeof|sizeof
argument_list|(
name|rt_sizes
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* just try the next bit */
name|iterator
operator|->
name|bitmap_shifter
operator|>>=
literal|1
expr_stmt|;
comment|/* if we found a valid arg earlier, return it now */
if|if
condition|(
name|hit
condition|)
return|return
literal|0
return|;
block|}
comment|/* we don't know how to handle any more args, we're done */
return|return
operator|-
name|ENOENT
return|;
block|}
end_function

end_unit

