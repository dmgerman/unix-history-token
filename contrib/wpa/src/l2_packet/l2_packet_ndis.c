begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant - Layer2 packet handling with Microsoft NDISUIO  * Copyright (c) 2003-2006, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  *  * This implementation requires Windows specific event loop implementation,  * i.e., eloop_win.c. In addition, the NDISUIO connection is shared with  * driver_ndis.c, so only that driver interface can be used and  * CONFIG_USE_NDISUIO must be defined.  *  * WinXP version of the code uses overlapped I/O and a single threaded design  * with callback functions from I/O code. WinCE version uses a separate RX  * thread that blocks on ReadFile() whenever the media status is connected.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<ntddndis.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32_WCE
end_ifdef

begin_include
include|#
directive|include
file|<winioctl.h>
end_include

begin_include
include|#
directive|include
file|<nuiouser.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32_WCE */
end_comment

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"l2_packet.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32_WCE
end_ifndef

begin_comment
comment|/* from nuiouser.h */
end_comment

begin_define
define|#
directive|define
name|FSCTL_NDISUIO_BASE
value|FILE_DEVICE_NETWORK
end_define

begin_define
define|#
directive|define
name|_NDISUIO_CTL_CODE
parameter_list|(
name|_Function
parameter_list|,
name|_Method
parameter_list|,
name|_Access
parameter_list|)
define|\
value|CTL_CODE(FSCTL_NDISUIO_BASE, _Function, _Method, _Access)
end_define

begin_define
define|#
directive|define
name|IOCTL_NDISUIO_SET_ETHER_TYPE
define|\
value|_NDISUIO_CTL_CODE(0x202, METHOD_BUFFERED, \ 			  FILE_READ_ACCESS | FILE_WRITE_ACCESS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32_WCE */
end_comment

begin_comment
comment|/* From driver_ndis.c to shared the handle to NDISUIO */
end_comment

begin_function_decl
name|HANDLE
name|driver_ndis_get_ndisuio_handle
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * NDISUIO supports filtering of only one ethertype at the time, so we must  * fake support for two (EAPOL and RSN pre-auth) by switching to pre-auth  * whenever wpa_supplicant is trying to pre-authenticate and then switching  * back to EAPOL when pre-authentication has been completed.  */
end_comment

begin_struct_decl
struct_decl|struct
name|l2_packet_data
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|l2_packet_ndisuio_global
block|{
name|int
name|refcount
decl_stmt|;
name|unsigned
name|short
name|first_proto
decl_stmt|;
name|struct
name|l2_packet_data
modifier|*
name|l2
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32_WCE
name|HANDLE
name|rx_thread
decl_stmt|;
name|HANDLE
name|stop_request
decl_stmt|;
name|HANDLE
name|ready_for_read
decl_stmt|;
name|HANDLE
name|rx_processed
decl_stmt|;
endif|#
directive|endif
comment|/* _WIN32_WCE */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|l2_packet_ndisuio_global
modifier|*
name|l2_ndisuio_global
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|l2_packet_data
block|{
name|char
name|ifname
index|[
literal|100
index|]
decl_stmt|;
name|u8
name|own_addr
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|void
function_decl|(
modifier|*
name|rx_callback
function_decl|)
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u8
modifier|*
name|src_addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
name|void
modifier|*
name|rx_callback_ctx
decl_stmt|;
name|int
name|l2_hdr
decl_stmt|;
comment|/* whether to include layer 2 (Ethernet) header in calls to 		     * rx_callback and l2_packet_send() */
name|HANDLE
name|rx_avail
decl_stmt|;
ifndef|#
directive|ifndef
name|_WIN32_WCE
name|OVERLAPPED
name|rx_overlapped
decl_stmt|;
endif|#
directive|endif
comment|/* _WIN32_WCE */
name|u8
name|rx_buf
index|[
literal|1514
index|]
decl_stmt|;
name|DWORD
name|rx_written
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|l2_packet_get_own_addr
parameter_list|(
name|struct
name|l2_packet_data
modifier|*
name|l2
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|os_memcpy
argument_list|(
name|addr
argument_list|,
name|l2
operator|->
name|own_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|l2_packet_send
parameter_list|(
name|struct
name|l2_packet_data
modifier|*
name|l2
parameter_list|,
specifier|const
name|u8
modifier|*
name|dst_addr
parameter_list|,
name|u16
name|proto
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|BOOL
name|res
decl_stmt|;
name|DWORD
name|written
decl_stmt|;
name|struct
name|l2_ethhdr
modifier|*
name|eth
decl_stmt|;
ifndef|#
directive|ifndef
name|_WIN32_WCE
name|OVERLAPPED
name|overlapped
decl_stmt|;
endif|#
directive|endif
comment|/* _WIN32_WCE */
name|OVERLAPPED
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|_WIN32_WCE
name|o
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
comment|/* _WIN32_WCE */
name|os_memset
argument_list|(
operator|&
name|overlapped
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|overlapped
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
operator|&
name|overlapped
expr_stmt|;
endif|#
directive|endif
comment|/* _WIN32_WCE */
if|if
condition|(
name|l2
operator|->
name|l2_hdr
condition|)
block|{
name|res
operator|=
name|WriteFile
argument_list|(
name|driver_ndis_get_ndisuio_handle
argument_list|()
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|written
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|mlen
init|=
sizeof|sizeof
argument_list|(
operator|*
name|eth
argument_list|)
operator|+
name|len
decl_stmt|;
name|eth
operator|=
name|os_malloc
argument_list|(
name|mlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|os_memcpy
argument_list|(
name|eth
operator|->
name|h_dest
argument_list|,
name|dst_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|eth
operator|->
name|h_source
argument_list|,
name|l2
operator|->
name|own_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|eth
operator|->
name|h_proto
operator|=
name|htons
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|eth
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|res
operator|=
name|WriteFile
argument_list|(
name|driver_ndis_get_ndisuio_handle
argument_list|()
argument_list|,
name|eth
argument_list|,
name|mlen
argument_list|,
operator|&
name|written
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|eth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|DWORD
name|err
init|=
name|GetLastError
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|_WIN32_WCE
if|if
condition|(
name|err
operator|==
name|ERROR_IO_PENDING
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): Wait for pending "
literal|"write to complete"
argument_list|)
expr_stmt|;
name|res
operator|=
name|GetOverlappedResult
argument_list|(
name|driver_ndis_get_ndisuio_handle
argument_list|()
argument_list|,
operator|&
name|overlapped
argument_list|,
operator|&
name|written
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): "
literal|"GetOverlappedResult failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* _WIN32_WCE */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): WriteFile failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|l2_packet_callback
parameter_list|(
name|struct
name|l2_packet_data
modifier|*
name|l2
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32_WCE
end_ifdef

begin_function
specifier|static
name|void
name|l2_packet_rx_thread_try_read
parameter_list|(
name|struct
name|l2_packet_data
modifier|*
name|l2
parameter_list|)
block|{
name|HANDLE
name|handles
index|[
literal|2
index|]
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"l2_packet_rx_thread: -> ReadFile"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ReadFile
argument_list|(
name|driver_ndis_get_ndisuio_handle
argument_list|()
argument_list|,
name|l2
operator|->
name|rx_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
operator|->
name|rx_buf
argument_list|)
argument_list|,
operator|&
name|l2
operator|->
name|rx_written
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|DWORD
name|err
init|=
name|GetLastError
argument_list|()
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"l2_packet_rx_thread: ReadFile failed: "
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|)
expr_stmt|;
comment|/* 		 * ReadFile on NDISUIO/WinCE returns ERROR_DEVICE_NOT_CONNECTED 		 * error whenever the connection is not up. Yield the thread to 		 * avoid triggering a busy loop. Connection event should stop 		 * us from looping for long, but we need to allow enough CPU 		 * for the main thread to process the media disconnection. 		 */
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"l2_packet_rx_thread: Read %d byte packet"
argument_list|,
operator|(
name|int
operator|)
name|l2
operator|->
name|rx_written
argument_list|)
expr_stmt|;
comment|/* 	 * Notify the main thread about the availability of a frame and wait 	 * for the frame to be processed. 	 */
name|SetEvent
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|)
expr_stmt|;
name|handles
index|[
literal|0
index|]
operator|=
name|l2_ndisuio_global
operator|->
name|stop_request
expr_stmt|;
name|handles
index|[
literal|1
index|]
operator|=
name|l2_ndisuio_global
operator|->
name|rx_processed
expr_stmt|;
name|WaitForMultipleObjects
argument_list|(
literal|2
argument_list|,
name|handles
argument_list|,
name|FALSE
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
name|ResetEvent
argument_list|(
name|l2_ndisuio_global
operator|->
name|rx_processed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|DWORD
name|WINAPI
name|l2_packet_rx_thread
parameter_list|(
name|LPVOID
name|arg
parameter_list|)
block|{
name|struct
name|l2_packet_data
modifier|*
name|l2
init|=
name|arg
decl_stmt|;
name|DWORD
name|res
decl_stmt|;
name|HANDLE
name|handles
index|[
literal|2
index|]
decl_stmt|;
name|int
name|run
init|=
literal|1
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): RX thread started"
argument_list|)
expr_stmt|;
name|handles
index|[
literal|0
index|]
operator|=
name|l2_ndisuio_global
operator|->
name|stop_request
expr_stmt|;
name|handles
index|[
literal|1
index|]
operator|=
name|l2_ndisuio_global
operator|->
name|ready_for_read
expr_stmt|;
comment|/* 	 * Unfortunately, NDISUIO on WinCE does not seem to support waiting 	 * on the handle. There do not seem to be anything else that we could 	 * wait for either. If one were to modify NDISUIO to set a named event 	 * whenever packets are available, this event could be used here to 	 * avoid having to poll for new packets or we could even move to use a 	 * single threaded design. 	 * 	 * In addition, NDISUIO on WinCE is returning 	 * ERROR_DEVICE_NOT_CONNECTED whenever ReadFile() is attempted while 	 * the adapter is not in connected state. For now, we are just using a 	 * local event to allow ReadFile calls only after having received NDIS 	 * media connect event. This event could be easily converted to handle 	 * another event if the protocol driver is replaced with somewhat more 	 * useful design. 	 */
while|while
condition|(
name|l2_ndisuio_global
operator|&&
name|run
condition|)
block|{
name|res
operator|=
name|WaitForMultipleObjects
argument_list|(
literal|2
argument_list|,
name|handles
argument_list|,
name|FALSE
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|WAIT_OBJECT_0
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"l2_packet_rx_thread: Received "
literal|"request to stop RX thread"
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|WAIT_OBJECT_0
operator|+
literal|1
case|:
name|l2_packet_rx_thread_try_read
argument_list|(
name|l2
argument_list|)
expr_stmt|;
break|break;
case|case
name|WAIT_FAILED
case|:
default|default:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"l2_packet_rx_thread: "
literal|"WaitForMultipleObjects failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): RX thread stopped"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _WIN32_WCE */
end_comment

begin_function
specifier|static
name|int
name|l2_ndisuio_start_read
parameter_list|(
name|struct
name|l2_packet_data
modifier|*
name|l2
parameter_list|,
name|int
name|recursive
parameter_list|)
block|{
name|os_memset
argument_list|(
operator|&
name|l2
operator|->
name|rx_overlapped
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
operator|->
name|rx_overlapped
argument_list|)
argument_list|)
expr_stmt|;
name|l2
operator|->
name|rx_overlapped
operator|.
name|hEvent
operator|=
name|l2
operator|->
name|rx_avail
expr_stmt|;
if|if
condition|(
operator|!
name|ReadFile
argument_list|(
name|driver_ndis_get_ndisuio_handle
argument_list|()
argument_list|,
name|l2
operator|->
name|rx_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
operator|->
name|rx_buf
argument_list|)
argument_list|,
operator|&
name|l2
operator|->
name|rx_written
argument_list|,
operator|&
name|l2
operator|->
name|rx_overlapped
argument_list|)
condition|)
block|{
name|DWORD
name|err
init|=
name|GetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|ERROR_IO_PENDING
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): ReadFile failed: "
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|err
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 		 * Once read is completed, l2_packet_rx_event() will be 		 * called. 		 */
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): ReadFile returned data "
literal|"without wait for completion"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|recursive
condition|)
name|l2_packet_callback
argument_list|(
name|l2
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32_WCE */
end_comment

begin_function
specifier|static
name|void
name|l2_packet_callback
parameter_list|(
name|struct
name|l2_packet_data
modifier|*
name|l2
parameter_list|)
block|{
specifier|const
name|u8
modifier|*
name|rx_buf
decl_stmt|,
modifier|*
name|rx_src
decl_stmt|;
name|size_t
name|rx_len
decl_stmt|;
name|struct
name|l2_ethhdr
modifier|*
name|ethhdr
init|=
operator|(
expr|struct
name|l2_ethhdr
operator|*
operator|)
name|l2
operator|->
name|rx_buf
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): Read %d bytes"
argument_list|,
operator|(
name|int
operator|)
name|l2
operator|->
name|rx_written
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2
operator|->
name|l2_hdr
operator|||
name|l2
operator|->
name|rx_written
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ethhdr
argument_list|)
condition|)
block|{
name|rx_buf
operator|=
operator|(
name|u8
operator|*
operator|)
name|ethhdr
expr_stmt|;
name|rx_len
operator|=
name|l2
operator|->
name|rx_written
expr_stmt|;
block|}
else|else
block|{
name|rx_buf
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|ethhdr
operator|+
literal|1
operator|)
expr_stmt|;
name|rx_len
operator|=
name|l2
operator|->
name|rx_written
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ethhdr
argument_list|)
expr_stmt|;
block|}
name|rx_src
operator|=
name|ethhdr
operator|->
name|h_source
expr_stmt|;
name|l2
operator|->
name|rx_callback
argument_list|(
name|l2
operator|->
name|rx_callback_ctx
argument_list|,
name|rx_src
argument_list|,
name|rx_buf
argument_list|,
name|rx_len
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32_WCE
name|l2_ndisuio_start_read
argument_list|(
name|l2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _WIN32_WCE */
block|}
end_function

begin_function
specifier|static
name|void
name|l2_packet_rx_event
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|struct
name|l2_packet_data
modifier|*
name|l2
init|=
name|eloop_data
decl_stmt|;
if|if
condition|(
name|l2_ndisuio_global
condition|)
name|l2
operator|=
name|l2_ndisuio_global
operator|->
name|l2
index|[
name|l2_ndisuio_global
operator|->
name|refcount
operator|-
literal|1
index|]
expr_stmt|;
name|ResetEvent
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32_WCE
if|if
condition|(
operator|!
name|GetOverlappedResult
argument_list|(
name|driver_ndis_get_ndisuio_handle
argument_list|()
argument_list|,
operator|&
name|l2
operator|->
name|rx_overlapped
argument_list|,
operator|&
name|l2
operator|->
name|rx_written
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): GetOverlappedResult "
literal|"failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* _WIN32_WCE */
name|l2_packet_callback
argument_list|(
name|l2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32_WCE
name|SetEvent
argument_list|(
name|l2_ndisuio_global
operator|->
name|rx_processed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _WIN32_WCE */
block|}
end_function

begin_function
specifier|static
name|int
name|l2_ndisuio_set_ether_type
parameter_list|(
name|unsigned
name|short
name|protocol
parameter_list|)
block|{
name|USHORT
name|proto
init|=
name|htons
argument_list|(
name|protocol
argument_list|)
decl_stmt|;
name|DWORD
name|written
decl_stmt|;
if|if
condition|(
operator|!
name|DeviceIoControl
argument_list|(
name|driver_ndis_get_ndisuio_handle
argument_list|()
argument_list|,
name|IOCTL_NDISUIO_SET_ETHER_TYPE
argument_list|,
operator|&
name|proto
argument_list|,
sizeof|sizeof
argument_list|(
name|proto
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|written
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"L2(NDISUIO): "
literal|"IOCTL_NDISUIO_SET_ETHER_TYPE failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|l2_packet_data
modifier|*
name|l2_packet_init
parameter_list|(
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
specifier|const
name|u8
modifier|*
name|own_addr
parameter_list|,
name|unsigned
name|short
name|protocol
parameter_list|,
name|void
function_decl|(
modifier|*
name|rx_callback
function_decl|)
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u8
modifier|*
name|src_addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
parameter_list|,
name|void
modifier|*
name|rx_callback_ctx
parameter_list|,
name|int
name|l2_hdr
parameter_list|)
block|{
name|struct
name|l2_packet_data
modifier|*
name|l2
decl_stmt|;
if|if
condition|(
name|l2_ndisuio_global
operator|==
name|NULL
condition|)
block|{
name|l2_ndisuio_global
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|l2_ndisuio_global
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2_ndisuio_global
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|l2_ndisuio_global
operator|->
name|first_proto
operator|=
name|protocol
expr_stmt|;
block|}
if|if
condition|(
name|l2_ndisuio_global
operator|->
name|refcount
operator|>=
literal|2
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"L2(NDISUIO): Not more than two "
literal|"simultaneous connections allowed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|l2_ndisuio_global
operator|->
name|refcount
operator|++
expr_stmt|;
name|l2
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|l2_packet_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|l2_ndisuio_global
operator|->
name|l2
index|[
name|l2_ndisuio_global
operator|->
name|refcount
operator|-
literal|1
index|]
operator|=
name|l2
expr_stmt|;
name|os_strlcpy
argument_list|(
name|l2
operator|->
name|ifname
argument_list|,
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
operator|->
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
name|l2
operator|->
name|rx_callback
operator|=
name|rx_callback
expr_stmt|;
name|l2
operator|->
name|rx_callback_ctx
operator|=
name|rx_callback_ctx
expr_stmt|;
name|l2
operator|->
name|l2_hdr
operator|=
name|l2_hdr
expr_stmt|;
if|if
condition|(
name|own_addr
condition|)
name|os_memcpy
argument_list|(
name|l2
operator|->
name|own_addr
argument_list|,
name|own_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2_ndisuio_set_ether_type
argument_list|(
name|protocol
argument_list|)
operator|<
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|l2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|l2_ndisuio_global
operator|->
name|refcount
operator|>
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): Temporarily setting "
literal|"filtering ethertype to %04x"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2_ndisuio_global
operator|->
name|l2
index|[
literal|0
index|]
condition|)
name|l2
operator|->
name|rx_avail
operator|=
name|l2_ndisuio_global
operator|->
name|l2
index|[
literal|0
index|]
operator|->
name|rx_avail
expr_stmt|;
return|return
name|l2
return|;
block|}
name|l2
operator|->
name|rx_avail
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2
operator|->
name|rx_avail
operator|==
name|NULL
condition|)
block|{
name|os_free
argument_list|(
name|l2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|eloop_register_event
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|)
argument_list|,
name|l2_packet_rx_event
argument_list|,
name|l2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32_WCE
name|l2_ndisuio_global
operator|->
name|stop_request
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * This event is being set based on media connect/disconnect 	 * notifications in driver_ndis.c. 	 */
name|l2_ndisuio_global
operator|->
name|ready_for_read
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TEXT
argument_list|(
literal|"WpaSupplicantConnected"
argument_list|)
argument_list|)
expr_stmt|;
name|l2_ndisuio_global
operator|->
name|rx_processed
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2_ndisuio_global
operator|->
name|stop_request
operator|==
name|NULL
operator|||
name|l2_ndisuio_global
operator|->
name|ready_for_read
operator|==
name|NULL
operator|||
name|l2_ndisuio_global
operator|->
name|rx_processed
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|l2_ndisuio_global
operator|->
name|stop_request
condition|)
block|{
name|CloseHandle
argument_list|(
name|l2_ndisuio_global
operator|->
name|stop_request
argument_list|)
expr_stmt|;
name|l2_ndisuio_global
operator|->
name|stop_request
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|l2_ndisuio_global
operator|->
name|ready_for_read
condition|)
block|{
name|CloseHandle
argument_list|(
name|l2_ndisuio_global
operator|->
name|ready_for_read
argument_list|)
expr_stmt|;
name|l2_ndisuio_global
operator|->
name|ready_for_read
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|l2_ndisuio_global
operator|->
name|rx_processed
condition|)
block|{
name|CloseHandle
argument_list|(
name|l2_ndisuio_global
operator|->
name|rx_processed
argument_list|)
expr_stmt|;
name|l2_ndisuio_global
operator|->
name|rx_processed
operator|=
name|NULL
expr_stmt|;
block|}
name|eloop_unregister_event
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|)
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|l2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|l2_ndisuio_global
operator|->
name|rx_thread
operator|=
name|CreateThread
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|l2_packet_rx_thread
argument_list|,
name|l2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2_ndisuio_global
operator|->
name|rx_thread
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"L2(NDISUIO): Failed to create RX "
literal|"thread: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|eloop_unregister_event
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|)
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|l2_ndisuio_global
operator|->
name|stop_request
argument_list|)
expr_stmt|;
name|l2_ndisuio_global
operator|->
name|stop_request
operator|=
name|NULL
expr_stmt|;
name|os_free
argument_list|(
name|l2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|#
directive|else
comment|/* _WIN32_WCE */
name|l2_ndisuio_start_read
argument_list|(
name|l2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _WIN32_WCE */
return|return
name|l2
return|;
block|}
end_function

begin_function
name|struct
name|l2_packet_data
modifier|*
name|l2_packet_init_bridge
parameter_list|(
specifier|const
name|char
modifier|*
name|br_ifname
parameter_list|,
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
specifier|const
name|u8
modifier|*
name|own_addr
parameter_list|,
name|unsigned
name|short
name|protocol
parameter_list|,
name|void
function_decl|(
modifier|*
name|rx_callback
function_decl|)
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u8
modifier|*
name|src_addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
parameter_list|,
name|void
modifier|*
name|rx_callback_ctx
parameter_list|,
name|int
name|l2_hdr
parameter_list|)
block|{
return|return
name|l2_packet_init
argument_list|(
name|br_ifname
argument_list|,
name|own_addr
argument_list|,
name|protocol
argument_list|,
name|rx_callback
argument_list|,
name|rx_callback_ctx
argument_list|,
name|l2_hdr
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|l2_packet_deinit
parameter_list|(
name|struct
name|l2_packet_data
modifier|*
name|l2
parameter_list|)
block|{
if|if
condition|(
name|l2
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|l2_ndisuio_global
condition|)
block|{
name|l2_ndisuio_global
operator|->
name|refcount
operator|--
expr_stmt|;
name|l2_ndisuio_global
operator|->
name|l2
index|[
name|l2_ndisuio_global
operator|->
name|refcount
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|l2_ndisuio_global
operator|->
name|refcount
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): restore filtering "
literal|"ethertype to %04x"
argument_list|,
name|l2_ndisuio_global
operator|->
name|first_proto
argument_list|)
expr_stmt|;
name|l2_ndisuio_set_ether_type
argument_list|(
name|l2_ndisuio_global
operator|->
name|first_proto
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|_WIN32_WCE
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): Waiting for RX thread to "
literal|"stop"
argument_list|)
expr_stmt|;
name|SetEvent
argument_list|(
name|l2_ndisuio_global
operator|->
name|stop_request
argument_list|)
expr_stmt|;
comment|/* 		 * Cancel pending ReadFile() in the RX thread (if we were still 		 * connected at this point). 		 */
if|if
condition|(
operator|!
name|DeviceIoControl
argument_list|(
name|driver_ndis_get_ndisuio_handle
argument_list|()
argument_list|,
name|IOCTL_CANCEL_READ
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): IOCTL_CANCEL_READ "
literal|"failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
comment|/* RX thread will exit blocking ReadFile once NDISUIO 			 * notices that the adapter is disconnected. */
block|}
name|WaitForSingleObject
argument_list|(
name|l2_ndisuio_global
operator|->
name|rx_thread
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"L2(NDISUIO): RX thread exited"
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|l2_ndisuio_global
operator|->
name|rx_thread
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|l2_ndisuio_global
operator|->
name|stop_request
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|l2_ndisuio_global
operator|->
name|ready_for_read
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|l2_ndisuio_global
operator|->
name|rx_processed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _WIN32_WCE */
name|os_free
argument_list|(
name|l2_ndisuio_global
argument_list|)
expr_stmt|;
name|l2_ndisuio_global
operator|=
name|NULL
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|_WIN32_WCE
name|CancelIo
argument_list|(
name|driver_ndis_get_ndisuio_handle
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _WIN32_WCE */
name|eloop_unregister_event
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|,
sizeof|sizeof
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|)
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|l2
operator|->
name|rx_avail
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|l2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|l2_packet_get_ip_addr
parameter_list|(
name|struct
name|l2_packet_data
modifier|*
name|l2
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|l2_packet_notify_auth_start
parameter_list|(
name|struct
name|l2_packet_data
modifier|*
name|l2
parameter_list|)
block|{ }
end_function

begin_function
name|int
name|l2_packet_set_packet_filter
parameter_list|(
name|struct
name|l2_packet_data
modifier|*
name|l2
parameter_list|,
name|enum
name|l2_packet_filter_type
name|type
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

