begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * EAP common peer/server definitions  * Copyright (c) 2004-2014, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eap_defs.h"
end_include

begin_include
include|#
directive|include
file|"eap_common.h"
end_include

begin_comment
comment|/**  * eap_hdr_len_valid - Validate EAP header length field  * @msg: EAP frame (starting with EAP header)  * @min_payload: Minimum payload length needed  * Returns: 1 for valid header, 0 for invalid  *  * This is a helper function that does minimal validation of EAP messages. The  * length field is verified to be large enough to include the header and not  * too large to go beyond the end of the buffer.  */
end_comment

begin_function
name|int
name|eap_hdr_len_valid
parameter_list|(
specifier|const
name|struct
name|wpabuf
modifier|*
name|msg
parameter_list|,
name|size_t
name|min_payload
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|hdr
operator|=
name|wpabuf_head
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Too short EAP frame"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
name|min_payload
operator|||
name|len
operator|>
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Invalid EAP length"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * eap_hdr_validate - Validate EAP header  * @vendor: Expected EAP Vendor-Id (0 = IETF)  * @eap_type: Expected EAP type number  * @msg: EAP frame (starting with EAP header)  * @plen: Pointer to variable to contain the returned payload length  * Returns: Pointer to EAP payload (after type field), or %NULL on failure  *  * This is a helper function for EAP method implementations. This is usually  * called in the beginning of struct eap_method::process() function to verify  * that the received EAP request packet has a valid header. This function is  * able to process both legacy and expanded EAP headers and in most cases, the  * caller can just use the returned payload pointer (into *plen) for processing  * the payload regardless of whether the packet used the expanded EAP header or  * not.  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_hdr_validate
parameter_list|(
name|int
name|vendor
parameter_list|,
name|EapType
name|eap_type
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|msg
parameter_list|,
name|size_t
modifier|*
name|plen
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|eap_hdr_len_valid
argument_list|(
name|msg
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|hdr
operator|=
name|wpabuf_head
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|len
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|pos
operator|==
name|EAP_TYPE_EXPANDED
condition|)
block|{
name|int
name|exp_vendor
decl_stmt|;
name|u32
name|exp_type
decl_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|8
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Invalid expanded EAP "
literal|"length"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pos
operator|++
expr_stmt|;
name|exp_vendor
operator|=
name|WPA_GET_BE24
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
name|exp_type
operator|=
name|WPA_GET_BE32
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|exp_vendor
operator|!=
name|vendor
operator|||
name|exp_type
operator|!=
operator|(
name|u32
operator|)
name|eap_type
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Invalid expanded frame "
literal|"type"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|plen
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|-
literal|8
expr_stmt|;
return|return
name|pos
return|;
block|}
else|else
block|{
if|if
condition|(
name|vendor
operator|!=
name|EAP_VENDOR_IETF
operator|||
operator|*
name|pos
operator|!=
name|eap_type
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: Invalid frame type"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|plen
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
name|pos
operator|+
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * eap_msg_alloc - Allocate a buffer for an EAP message  * @vendor: Vendor-Id (0 = IETF)  * @type: EAP type  * @payload_len: Payload length in bytes (data after Type)  * @code: Message Code (EAP_CODE_*)  * @identifier: Identifier  * Returns: Pointer to the allocated message buffer or %NULL on error  *  * This function can be used to allocate a buffer for an EAP message and fill  * in the EAP header. This function is automatically using expanded EAP header  * if the selected Vendor-Id is not IETF. In other words, most EAP methods do  * not need to separately select which header type to use when using this  * function to allocate the message buffers. The returned buffer has room for  * payload_len bytes and has the EAP header and Type field already filled in.  */
end_comment

begin_function
name|struct
name|wpabuf
modifier|*
name|eap_msg_alloc
parameter_list|(
name|int
name|vendor
parameter_list|,
name|EapType
name|type
parameter_list|,
name|size_t
name|payload_len
parameter_list|,
name|u8
name|code
parameter_list|,
name|u8
name|identifier
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
operator|(
name|vendor
operator|==
name|EAP_VENDOR_IETF
condition|?
literal|1
else|:
literal|8
operator|)
operator|+
name|payload_len
expr_stmt|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|hdr
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|hdr
operator|->
name|identifier
operator|=
name|identifier
expr_stmt|;
name|hdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor
operator|==
name|EAP_VENDOR_IETF
condition|)
block|{
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|EAP_TYPE_EXPANDED
argument_list|)
expr_stmt|;
name|wpabuf_put_be24
argument_list|(
name|buf
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
name|wpabuf_put_be32
argument_list|(
name|buf
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/**  * eap_update_len - Update EAP header length  * @msg: EAP message from eap_msg_alloc  *  * This function updates the length field in the EAP header to match with the  * current length for the buffer. This allows eap_msg_alloc() to be used to  * allocate a larger buffer than the exact message length (e.g., if exact  * message length is not yet known).  */
end_comment

begin_function
name|void
name|eap_update_len
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
name|wpabuf_mhead
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
return|return;
name|hdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_id - Get EAP Identifier from wpabuf  * @msg: Buffer starting with an EAP header  * Returns: The Identifier field from the EAP header  */
end_comment

begin_function
name|u8
name|eap_get_id
parameter_list|(
specifier|const
name|struct
name|wpabuf
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|eap
decl_stmt|;
if|if
condition|(
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|eap
argument_list|)
condition|)
return|return
literal|0
return|;
name|eap
operator|=
name|wpabuf_head
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|eap
operator|->
name|identifier
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_type - Get EAP Type from wpabuf  * @msg: Buffer starting with an EAP header  * Returns: The EAP Type after the EAP header  */
end_comment

begin_function
name|EapType
name|eap_get_type
parameter_list|(
specifier|const
name|struct
name|wpabuf
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
condition|)
return|return
name|EAP_TYPE_NONE
return|;
return|return
operator|(
operator|(
specifier|const
name|u8
operator|*
operator|)
name|wpabuf_head
argument_list|(
name|msg
argument_list|)
operator|)
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
index|]
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_ERP
end_ifdef

begin_function
name|int
name|erp_parse_tlvs
parameter_list|(
specifier|const
name|u8
modifier|*
name|pos
parameter_list|,
specifier|const
name|u8
modifier|*
name|end
parameter_list|,
name|struct
name|erp_tlvs
modifier|*
name|tlvs
parameter_list|,
name|int
name|stop_at_keyname
parameter_list|)
block|{
name|os_memset
argument_list|(
name|tlvs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tlvs
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|u8
name|tlv_type
decl_stmt|,
name|tlv_len
decl_stmt|;
name|tlv_type
operator|=
operator|*
name|pos
operator|++
expr_stmt|;
switch|switch
condition|(
name|tlv_type
condition|)
block|{
case|case
name|EAP_ERP_TV_RRK_LIFETIME
case|:
case|case
name|EAP_ERP_TV_RMSK_LIFETIME
case|:
comment|/* 4-octet TV */
if|if
condition|(
name|pos
operator|+
literal|4
operator|>
name|end
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Too short TV"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pos
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|EAP_ERP_TLV_DOMAIN_NAME
case|:
case|case
name|EAP_ERP_TLV_KEYNAME_NAI
case|:
case|case
name|EAP_ERP_TLV_CRYPTOSUITES
case|:
case|case
name|EAP_ERP_TLV_AUTHORIZATION_INDICATION
case|:
case|case
name|EAP_ERP_TLV_CALLED_STATION_ID
case|:
case|case
name|EAP_ERP_TLV_CALLING_STATION_ID
case|:
case|case
name|EAP_ERP_TLV_NAS_IDENTIFIER
case|:
case|case
name|EAP_ERP_TLV_NAS_IP_ADDRESS
case|:
case|case
name|EAP_ERP_TLV_NAS_IPV6_ADDRESS
case|:
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Too short TLV"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|tlv_len
operator|=
operator|*
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|tlv_len
operator|>
call|(
name|unsigned
call|)
argument_list|(
name|end
operator|-
name|pos
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Truncated TLV"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|tlv_type
operator|==
name|EAP_ERP_TLV_KEYNAME_NAI
condition|)
block|{
if|if
condition|(
name|tlvs
operator|->
name|keyname
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: More than one keyName-NAI"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|tlvs
operator|->
name|keyname
operator|=
name|pos
expr_stmt|;
name|tlvs
operator|->
name|keyname_len
operator|=
name|tlv_len
expr_stmt|;
if|if
condition|(
name|stop_at_keyname
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|tlv_type
operator|==
name|EAP_ERP_TLV_DOMAIN_NAME
condition|)
block|{
name|tlvs
operator|->
name|domain
operator|=
name|pos
expr_stmt|;
name|tlvs
operator|->
name|domain_len
operator|=
name|tlv_len
expr_stmt|;
block|}
name|pos
operator|+=
name|tlv_len
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|tlv_type
operator|>=
literal|128
operator|&&
name|tlv_type
operator|<=
literal|191
condition|)
block|{
comment|/* Undefined TLV */
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Too short TLV"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|tlv_len
operator|=
operator|*
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|tlv_len
operator|>
call|(
name|unsigned
call|)
argument_list|(
name|end
operator|-
name|pos
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Truncated TLV"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pos
operator|+=
name|tlv_len
expr_stmt|;
break|break;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Unknown TV/TLV type %u"
argument_list|,
name|tlv_type
argument_list|)
expr_stmt|;
name|pos
operator|=
name|end
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_ERP */
end_comment

end_unit

