begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * TLSv1 common routines  * Copyright (c) 2006-2014, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"crypto/md5.h"
end_include

begin_include
include|#
directive|include
file|"crypto/sha1.h"
end_include

begin_include
include|#
directive|include
file|"crypto/sha256.h"
end_include

begin_include
include|#
directive|include
file|"x509v3.h"
end_include

begin_include
include|#
directive|include
file|"tlsv1_common.h"
end_include

begin_comment
comment|/*  * TODO:  * RFC 2246 Section 9: Mandatory to implement TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA  * Add support for commonly used cipher suites; don't bother with exportable  * suites.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tls_cipher_suite
name|tls_cipher_suites
index|[]
init|=
block|{
block|{
name|TLS_NULL_WITH_NULL_NULL
block|,
name|TLS_KEY_X_NULL
block|,
name|TLS_CIPHER_NULL
block|,
name|TLS_HASH_NULL
block|}
block|,
block|{
name|TLS_RSA_WITH_RC4_128_MD5
block|,
name|TLS_KEY_X_RSA
block|,
name|TLS_CIPHER_RC4_128
block|,
name|TLS_HASH_MD5
block|}
block|,
block|{
name|TLS_RSA_WITH_RC4_128_SHA
block|,
name|TLS_KEY_X_RSA
block|,
name|TLS_CIPHER_RC4_128
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_RSA_WITH_DES_CBC_SHA
block|,
name|TLS_KEY_X_RSA
block|,
name|TLS_CIPHER_DES_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_RSA_WITH_3DES_EDE_CBC_SHA
block|,
name|TLS_KEY_X_RSA
block|,
name|TLS_CIPHER_3DES_EDE_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_DHE_RSA_WITH_DES_CBC_SHA
block|,
name|TLS_KEY_X_DHE_RSA
block|,
name|TLS_CIPHER_DES_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
block|,
name|TLS_KEY_X_DHE_RSA
block|,
name|TLS_CIPHER_3DES_EDE_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_DH_anon_WITH_RC4_128_MD5
block|,
name|TLS_KEY_X_DH_anon
block|,
name|TLS_CIPHER_RC4_128
block|,
name|TLS_HASH_MD5
block|}
block|,
block|{
name|TLS_DH_anon_WITH_DES_CBC_SHA
block|,
name|TLS_KEY_X_DH_anon
block|,
name|TLS_CIPHER_DES_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_DH_anon_WITH_3DES_EDE_CBC_SHA
block|,
name|TLS_KEY_X_DH_anon
block|,
name|TLS_CIPHER_3DES_EDE_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_RSA_WITH_AES_128_CBC_SHA
block|,
name|TLS_KEY_X_RSA
block|,
name|TLS_CIPHER_AES_128_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_DHE_RSA_WITH_AES_128_CBC_SHA
block|,
name|TLS_KEY_X_DHE_RSA
block|,
name|TLS_CIPHER_AES_128_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_DH_anon_WITH_AES_128_CBC_SHA
block|,
name|TLS_KEY_X_DH_anon
block|,
name|TLS_CIPHER_AES_128_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_RSA_WITH_AES_256_CBC_SHA
block|,
name|TLS_KEY_X_RSA
block|,
name|TLS_CIPHER_AES_256_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_DHE_RSA_WITH_AES_256_CBC_SHA
block|,
name|TLS_KEY_X_DHE_RSA
block|,
name|TLS_CIPHER_AES_256_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_DH_anon_WITH_AES_256_CBC_SHA
block|,
name|TLS_KEY_X_DH_anon
block|,
name|TLS_CIPHER_AES_256_CBC
block|,
name|TLS_HASH_SHA
block|}
block|,
block|{
name|TLS_RSA_WITH_AES_128_CBC_SHA256
block|,
name|TLS_KEY_X_RSA
block|,
name|TLS_CIPHER_AES_128_CBC
block|,
name|TLS_HASH_SHA256
block|}
block|,
block|{
name|TLS_RSA_WITH_AES_256_CBC_SHA256
block|,
name|TLS_KEY_X_RSA
block|,
name|TLS_CIPHER_AES_256_CBC
block|,
name|TLS_HASH_SHA256
block|}
block|,
block|{
name|TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
block|,
name|TLS_KEY_X_DHE_RSA
block|,
name|TLS_CIPHER_AES_128_CBC
block|,
name|TLS_HASH_SHA256
block|}
block|,
block|{
name|TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
block|,
name|TLS_KEY_X_DHE_RSA
block|,
name|TLS_CIPHER_AES_256_CBC
block|,
name|TLS_HASH_SHA256
block|}
block|,
block|{
name|TLS_DH_anon_WITH_AES_128_CBC_SHA256
block|,
name|TLS_KEY_X_DH_anon
block|,
name|TLS_CIPHER_AES_128_CBC
block|,
name|TLS_HASH_SHA256
block|}
block|,
block|{
name|TLS_DH_anon_WITH_AES_256_CBC_SHA256
block|,
name|TLS_KEY_X_DH_anon
block|,
name|TLS_CIPHER_AES_256_CBC
block|,
name|TLS_HASH_SHA256
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_TLS_CIPHER_SUITES
value|ARRAY_SIZE(tls_cipher_suites)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tls_cipher_data
name|tls_ciphers
index|[]
init|=
block|{
block|{
name|TLS_CIPHER_NULL
block|,
name|TLS_CIPHER_STREAM
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|CRYPTO_CIPHER_NULL
block|}
block|,
block|{
name|TLS_CIPHER_IDEA_CBC
block|,
name|TLS_CIPHER_BLOCK
block|,
literal|16
block|,
literal|16
block|,
literal|8
block|,
name|CRYPTO_CIPHER_NULL
block|}
block|,
block|{
name|TLS_CIPHER_RC2_CBC_40
block|,
name|TLS_CIPHER_BLOCK
block|,
literal|5
block|,
literal|16
block|,
literal|0
block|,
name|CRYPTO_CIPHER_ALG_RC2
block|}
block|,
block|{
name|TLS_CIPHER_RC4_40
block|,
name|TLS_CIPHER_STREAM
block|,
literal|5
block|,
literal|16
block|,
literal|0
block|,
name|CRYPTO_CIPHER_ALG_RC4
block|}
block|,
block|{
name|TLS_CIPHER_RC4_128
block|,
name|TLS_CIPHER_STREAM
block|,
literal|16
block|,
literal|16
block|,
literal|0
block|,
name|CRYPTO_CIPHER_ALG_RC4
block|}
block|,
block|{
name|TLS_CIPHER_DES40_CBC
block|,
name|TLS_CIPHER_BLOCK
block|,
literal|5
block|,
literal|8
block|,
literal|8
block|,
name|CRYPTO_CIPHER_ALG_DES
block|}
block|,
block|{
name|TLS_CIPHER_DES_CBC
block|,
name|TLS_CIPHER_BLOCK
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
name|CRYPTO_CIPHER_ALG_DES
block|}
block|,
block|{
name|TLS_CIPHER_3DES_EDE_CBC
block|,
name|TLS_CIPHER_BLOCK
block|,
literal|24
block|,
literal|24
block|,
literal|8
block|,
name|CRYPTO_CIPHER_ALG_3DES
block|}
block|,
block|{
name|TLS_CIPHER_AES_128_CBC
block|,
name|TLS_CIPHER_BLOCK
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
name|CRYPTO_CIPHER_ALG_AES
block|}
block|,
block|{
name|TLS_CIPHER_AES_256_CBC
block|,
name|TLS_CIPHER_BLOCK
block|,
literal|32
block|,
literal|32
block|,
literal|16
block|,
name|CRYPTO_CIPHER_ALG_AES
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_TLS_CIPHER_DATA
value|ARRAY_SIZE(tls_ciphers)
end_define

begin_comment
comment|/**  * tls_get_cipher_suite - Get TLS cipher suite  * @suite: Cipher suite identifier  * Returns: Pointer to the cipher data or %NULL if not found  */
end_comment

begin_function
specifier|const
name|struct
name|tls_cipher_suite
modifier|*
name|tls_get_cipher_suite
parameter_list|(
name|u16
name|suite
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TLS_CIPHER_SUITES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tls_cipher_suites
index|[
name|i
index|]
operator|.
name|suite
operator|==
name|suite
condition|)
return|return
operator|&
name|tls_cipher_suites
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|tls_cipher_data
modifier|*
name|tls_get_cipher_data
parameter_list|(
name|tls_cipher
name|cipher
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TLS_CIPHER_DATA
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tls_ciphers
index|[
name|i
index|]
operator|.
name|cipher
operator|==
name|cipher
condition|)
return|return
operator|&
name|tls_ciphers
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|tls_server_key_exchange_allowed
parameter_list|(
name|tls_cipher
name|cipher
parameter_list|)
block|{
specifier|const
name|struct
name|tls_cipher_suite
modifier|*
name|suite
decl_stmt|;
comment|/* RFC 2246, Section 7.4.3 */
name|suite
operator|=
name|tls_get_cipher_suite
argument_list|(
name|cipher
argument_list|)
expr_stmt|;
if|if
condition|(
name|suite
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|suite
operator|->
name|key_exchange
condition|)
block|{
case|case
name|TLS_KEY_X_DHE_DSS
case|:
case|case
name|TLS_KEY_X_DHE_DSS_EXPORT
case|:
case|case
name|TLS_KEY_X_DHE_RSA
case|:
case|case
name|TLS_KEY_X_DHE_RSA_EXPORT
case|:
case|case
name|TLS_KEY_X_DH_anon_EXPORT
case|:
case|case
name|TLS_KEY_X_DH_anon
case|:
return|return
literal|1
return|;
case|case
name|TLS_KEY_X_RSA_EXPORT
case|:
return|return
literal|1
comment|/* FIX: public key len> 512 bits */
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * tls_parse_cert - Parse DER encoded X.509 certificate and get public key  * @buf: ASN.1 DER encoded certificate  * @len: Length of the buffer  * @pk: Buffer for returning the allocated public key  * Returns: 0 on success, -1 on failure  *  * This functions parses an ASN.1 DER encoded X.509 certificate and retrieves  * the public key from it. The caller is responsible for freeing the public key  * by calling crypto_public_key_free().  */
end_comment

begin_function
name|int
name|tls_parse_cert
parameter_list|(
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|crypto_public_key
modifier|*
modifier|*
name|pk
parameter_list|)
block|{
name|struct
name|x509_certificate
modifier|*
name|cert
decl_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"TLSv1: Parse ASN.1 DER certificate"
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|pk
operator|=
name|crypto_public_key_from_cert
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pk
condition|)
return|return
literal|0
return|;
name|cert
operator|=
name|x509_certificate_parse
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cert
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"TLSv1: Failed to parse X.509 "
literal|"certificate"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* TODO 	 * verify key usage (must allow encryption) 	 * 	 * All certificate profiles, key and cryptographic formats are 	 * defined by the IETF PKIX working group [PKIX]. When a key 	 * usage extension is present, the digitalSignature bit must be 	 * set for the key to be eligible for signing, as described 	 * above, and the keyEncipherment bit must be present to allow 	 * encryption, as described above. The keyAgreement bit must be 	 * set on Diffie-Hellman certificates. (PKIX: RFC 3280) 	 */
operator|*
name|pk
operator|=
name|crypto_public_key_import
argument_list|(
name|cert
operator|->
name|public_key
argument_list|,
name|cert
operator|->
name|public_key_len
argument_list|)
expr_stmt|;
name|x509_certificate_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pk
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"TLSv1: Failed to import "
literal|"server public key"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tls_verify_hash_init
parameter_list|(
name|struct
name|tls_verify_hash
modifier|*
name|verify
parameter_list|)
block|{
name|tls_verify_hash_free
argument_list|(
name|verify
argument_list|)
expr_stmt|;
name|verify
operator|->
name|md5_client
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_MD5
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verify
operator|->
name|md5_server
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_MD5
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verify
operator|->
name|md5_cert
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_MD5
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verify
operator|->
name|sha1_client
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_SHA1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verify
operator|->
name|sha1_server
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_SHA1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verify
operator|->
name|sha1_cert
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_SHA1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
operator|->
name|md5_client
operator|==
name|NULL
operator|||
name|verify
operator|->
name|md5_server
operator|==
name|NULL
operator|||
name|verify
operator|->
name|md5_cert
operator|==
name|NULL
operator|||
name|verify
operator|->
name|sha1_client
operator|==
name|NULL
operator|||
name|verify
operator|->
name|sha1_server
operator|==
name|NULL
operator|||
name|verify
operator|->
name|sha1_cert
operator|==
name|NULL
condition|)
block|{
name|tls_verify_hash_free
argument_list|(
name|verify
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_TLSV12
name|verify
operator|->
name|sha256_client
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_SHA256
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verify
operator|->
name|sha256_server
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_SHA256
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verify
operator|->
name|sha256_cert
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_SHA256
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
operator|->
name|sha256_client
operator|==
name|NULL
operator|||
name|verify
operator|->
name|sha256_server
operator|==
name|NULL
operator|||
name|verify
operator|->
name|sha256_cert
operator|==
name|NULL
condition|)
block|{
name|tls_verify_hash_free
argument_list|(
name|verify
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* CONFIG_TLSV12 */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|tls_verify_hash_add
parameter_list|(
name|struct
name|tls_verify_hash
modifier|*
name|verify
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|verify
operator|->
name|md5_client
operator|&&
name|verify
operator|->
name|sha1_client
condition|)
block|{
name|crypto_hash_update
argument_list|(
name|verify
operator|->
name|md5_client
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|crypto_hash_update
argument_list|(
name|verify
operator|->
name|sha1_client
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verify
operator|->
name|md5_server
operator|&&
name|verify
operator|->
name|sha1_server
condition|)
block|{
name|crypto_hash_update
argument_list|(
name|verify
operator|->
name|md5_server
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|crypto_hash_update
argument_list|(
name|verify
operator|->
name|sha1_server
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verify
operator|->
name|md5_cert
operator|&&
name|verify
operator|->
name|sha1_cert
condition|)
block|{
name|crypto_hash_update
argument_list|(
name|verify
operator|->
name|md5_cert
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|crypto_hash_update
argument_list|(
name|verify
operator|->
name|sha1_cert
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_TLSV12
if|if
condition|(
name|verify
operator|->
name|sha256_client
condition|)
name|crypto_hash_update
argument_list|(
name|verify
operator|->
name|sha256_client
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
operator|->
name|sha256_server
condition|)
name|crypto_hash_update
argument_list|(
name|verify
operator|->
name|sha256_server
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
operator|->
name|sha256_cert
condition|)
name|crypto_hash_update
argument_list|(
name|verify
operator|->
name|sha256_cert
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_TLSV12 */
block|}
end_function

begin_function
name|void
name|tls_verify_hash_free
parameter_list|(
name|struct
name|tls_verify_hash
modifier|*
name|verify
parameter_list|)
block|{
name|crypto_hash_finish
argument_list|(
name|verify
operator|->
name|md5_client
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|crypto_hash_finish
argument_list|(
name|verify
operator|->
name|md5_server
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|crypto_hash_finish
argument_list|(
name|verify
operator|->
name|md5_cert
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|crypto_hash_finish
argument_list|(
name|verify
operator|->
name|sha1_client
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|crypto_hash_finish
argument_list|(
name|verify
operator|->
name|sha1_server
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|crypto_hash_finish
argument_list|(
name|verify
operator|->
name|sha1_cert
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verify
operator|->
name|md5_client
operator|=
name|NULL
expr_stmt|;
name|verify
operator|->
name|md5_server
operator|=
name|NULL
expr_stmt|;
name|verify
operator|->
name|md5_cert
operator|=
name|NULL
expr_stmt|;
name|verify
operator|->
name|sha1_client
operator|=
name|NULL
expr_stmt|;
name|verify
operator|->
name|sha1_server
operator|=
name|NULL
expr_stmt|;
name|verify
operator|->
name|sha1_cert
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_TLSV12
name|crypto_hash_finish
argument_list|(
name|verify
operator|->
name|sha256_client
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|crypto_hash_finish
argument_list|(
name|verify
operator|->
name|sha256_server
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|crypto_hash_finish
argument_list|(
name|verify
operator|->
name|sha256_cert
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verify
operator|->
name|sha256_client
operator|=
name|NULL
expr_stmt|;
name|verify
operator|->
name|sha256_server
operator|=
name|NULL
expr_stmt|;
name|verify
operator|->
name|sha256_cert
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_TLSV12 */
block|}
end_function

begin_function
name|int
name|tls_version_ok
parameter_list|(
name|u16
name|ver
parameter_list|)
block|{
if|if
condition|(
name|ver
operator|==
name|TLS_VERSION_1
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|CONFIG_TLSV11
if|if
condition|(
name|ver
operator|==
name|TLS_VERSION_1_1
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* CONFIG_TLSV11 */
ifdef|#
directive|ifdef
name|CONFIG_TLSV12
if|if
condition|(
name|ver
operator|==
name|TLS_VERSION_1_2
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* CONFIG_TLSV12 */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|tls_version_str
parameter_list|(
name|u16
name|ver
parameter_list|)
block|{
switch|switch
condition|(
name|ver
condition|)
block|{
case|case
name|TLS_VERSION_1
case|:
return|return
literal|"1.0"
return|;
case|case
name|TLS_VERSION_1_1
case|:
return|return
literal|"1.1"
return|;
case|case
name|TLS_VERSION_1_2
case|:
return|return
literal|"1.2"
return|;
block|}
return|return
literal|"?"
return|;
block|}
end_function

begin_function
name|int
name|tls_prf
parameter_list|(
name|u16
name|ver
parameter_list|,
specifier|const
name|u8
modifier|*
name|secret
parameter_list|,
name|size_t
name|secret_len
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
specifier|const
name|u8
modifier|*
name|seed
parameter_list|,
name|size_t
name|seed_len
parameter_list|,
name|u8
modifier|*
name|out
parameter_list|,
name|size_t
name|outlen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_TLSV12
if|if
condition|(
name|ver
operator|>=
name|TLS_VERSION_1_2
condition|)
block|{
name|tls_prf_sha256
argument_list|(
name|secret
argument_list|,
name|secret_len
argument_list|,
name|label
argument_list|,
name|seed
argument_list|,
name|seed_len
argument_list|,
name|out
argument_list|,
name|outlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* CONFIG_TLSV12 */
return|return
name|tls_prf_sha1_md5
argument_list|(
name|secret
argument_list|,
name|secret_len
argument_list|,
name|label
argument_list|,
name|seed
argument_list|,
name|seed_len
argument_list|,
name|out
argument_list|,
name|outlen
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_TLSV12
end_ifdef

begin_function
name|int
name|tlsv12_key_x_server_params_hash
parameter_list|(
name|u16
name|tls_version
parameter_list|,
specifier|const
name|u8
modifier|*
name|client_random
parameter_list|,
specifier|const
name|u8
modifier|*
name|server_random
parameter_list|,
specifier|const
name|u8
modifier|*
name|server_params
parameter_list|,
name|size_t
name|server_params_len
parameter_list|,
name|u8
modifier|*
name|hash
parameter_list|)
block|{
name|size_t
name|hlen
decl_stmt|;
name|struct
name|crypto_hash
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_SHA256
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|crypto_hash_update
argument_list|(
name|ctx
argument_list|,
name|client_random
argument_list|,
name|TLS_RANDOM_LEN
argument_list|)
expr_stmt|;
name|crypto_hash_update
argument_list|(
name|ctx
argument_list|,
name|server_random
argument_list|,
name|TLS_RANDOM_LEN
argument_list|)
expr_stmt|;
name|crypto_hash_update
argument_list|(
name|ctx
argument_list|,
name|server_params
argument_list|,
name|server_params_len
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|SHA256_MAC_LEN
expr_stmt|;
if|if
condition|(
name|crypto_hash_finish
argument_list|(
name|ctx
argument_list|,
name|hash
argument_list|,
operator|&
name|hlen
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|hlen
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_TLSV12 */
end_comment

begin_function
name|int
name|tls_key_x_server_params_hash
parameter_list|(
name|u16
name|tls_version
parameter_list|,
specifier|const
name|u8
modifier|*
name|client_random
parameter_list|,
specifier|const
name|u8
modifier|*
name|server_random
parameter_list|,
specifier|const
name|u8
modifier|*
name|server_params
parameter_list|,
name|size_t
name|server_params_len
parameter_list|,
name|u8
modifier|*
name|hash
parameter_list|)
block|{
name|u8
modifier|*
name|hpos
decl_stmt|;
name|size_t
name|hlen
decl_stmt|;
name|struct
name|crypto_hash
modifier|*
name|ctx
decl_stmt|;
name|hpos
operator|=
name|hash
expr_stmt|;
name|ctx
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_MD5
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|crypto_hash_update
argument_list|(
name|ctx
argument_list|,
name|client_random
argument_list|,
name|TLS_RANDOM_LEN
argument_list|)
expr_stmt|;
name|crypto_hash_update
argument_list|(
name|ctx
argument_list|,
name|server_random
argument_list|,
name|TLS_RANDOM_LEN
argument_list|)
expr_stmt|;
name|crypto_hash_update
argument_list|(
name|ctx
argument_list|,
name|server_params
argument_list|,
name|server_params_len
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|MD5_MAC_LEN
expr_stmt|;
if|if
condition|(
name|crypto_hash_finish
argument_list|(
name|ctx
argument_list|,
name|hash
argument_list|,
operator|&
name|hlen
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|hpos
operator|+=
name|hlen
expr_stmt|;
name|ctx
operator|=
name|crypto_hash_init
argument_list|(
name|CRYPTO_HASH_ALG_SHA1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|crypto_hash_update
argument_list|(
name|ctx
argument_list|,
name|client_random
argument_list|,
name|TLS_RANDOM_LEN
argument_list|)
expr_stmt|;
name|crypto_hash_update
argument_list|(
name|ctx
argument_list|,
name|server_random
argument_list|,
name|TLS_RANDOM_LEN
argument_list|)
expr_stmt|;
name|crypto_hash_update
argument_list|(
name|ctx
argument_list|,
name|server_params
argument_list|,
name|server_params_len
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|hash
operator|+
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
operator|-
name|hpos
expr_stmt|;
if|if
condition|(
name|crypto_hash_finish
argument_list|(
name|ctx
argument_list|,
name|hpos
argument_list|,
operator|&
name|hlen
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|hpos
operator|+=
name|hlen
expr_stmt|;
return|return
name|hpos
operator|-
name|hash
return|;
block|}
end_function

begin_function
name|int
name|tls_verify_signature
parameter_list|(
name|u16
name|tls_version
parameter_list|,
name|struct
name|crypto_public_key
modifier|*
name|pk
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|data_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|pos
parameter_list|,
name|size_t
name|len
parameter_list|,
name|u8
modifier|*
name|alert
parameter_list|)
block|{
name|u8
modifier|*
name|buf
decl_stmt|;
specifier|const
name|u8
modifier|*
name|end
init|=
name|pos
operator|+
name|len
decl_stmt|;
specifier|const
name|u8
modifier|*
name|decrypted
decl_stmt|;
name|u16
name|slen
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
if|if
condition|(
name|end
operator|-
name|pos
operator|<
literal|2
condition|)
block|{
operator|*
name|alert
operator|=
name|TLS_ALERT_DECODE_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|slen
operator|=
name|WPA_GET_BE16
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|pos
operator|<
name|slen
condition|)
block|{
operator|*
name|alert
operator|=
name|TLS_ALERT_DECODE_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|end
operator|-
name|pos
operator|>
name|slen
condition|)
block|{
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"Additional data after Signature"
argument_list|,
name|pos
operator|+
name|slen
argument_list|,
name|end
operator|-
name|pos
operator|-
name|slen
argument_list|)
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|slen
expr_stmt|;
block|}
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"TLSv1: Signature"
argument_list|,
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pk
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"TLSv1: No public key to verify signature"
argument_list|)
expr_stmt|;
operator|*
name|alert
operator|=
name|TLS_ALERT_INTERNAL_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|buflen
operator|=
name|end
operator|-
name|pos
expr_stmt|;
name|buf
operator|=
name|os_malloc
argument_list|(
name|end
operator|-
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
operator|*
name|alert
operator|=
name|TLS_ALERT_INTERNAL_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|crypto_public_key_decrypt_pkcs1
argument_list|(
name|pk
argument_list|,
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
name|buf
argument_list|,
operator|&
name|buflen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"TLSv1: Failed to decrypt signature"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|alert
operator|=
name|TLS_ALERT_DECRYPT_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|decrypted
operator|=
name|buf
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"TLSv1: Decrypted Signature"
argument_list|,
name|decrypted
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_TLSV12
if|if
condition|(
name|tls_version
operator|>=
name|TLS_VERSION_1_2
condition|)
block|{
comment|/* 		 * RFC 3447, A.2.4 RSASSA-PKCS1-v1_5 		 * 		 * DigestInfo ::= SEQUENCE { 		 *   digestAlgorithm DigestAlgorithm, 		 *   digest OCTET STRING 		 * } 		 * 		 * SHA-256 OID: sha256WithRSAEncryption ::= {pkcs-1 11} 		 * 		 * DER encoded DigestInfo for SHA256 per RFC 3447: 		 * 30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 || 		 * H 		 */
if|if
condition|(
name|buflen
operator|>=
literal|19
operator|+
literal|32
operator|&&
name|os_memcmp
argument_list|(
name|buf
argument_list|,
literal|"\x30\x31\x30\x0d\x06\x09\x60\x86\x48\x01"
literal|"\x65\x03\x04\x02\x01\x05\x00\x04\x20"
argument_list|,
literal|19
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"TLSv1.2: DigestAlgorithn = SHA-256"
argument_list|)
expr_stmt|;
name|decrypted
operator|=
name|buf
operator|+
literal|19
expr_stmt|;
name|buflen
operator|-=
literal|19
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"TLSv1.2: Unrecognized DigestInfo"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|alert
operator|=
name|TLS_ALERT_DECRYPT_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|/* CONFIG_TLSV12 */
if|if
condition|(
name|buflen
operator|!=
name|data_len
operator|||
name|os_memcmp_const
argument_list|(
name|decrypted
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"TLSv1: Invalid Signature in CertificateVerify - did not match calculated hash"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|alert
operator|=
name|TLS_ALERT_DECRYPT_ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|os_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

