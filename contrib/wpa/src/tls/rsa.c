begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * RSA  * Copyright (c) 2006, Jouni Malinen<j@w1.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"crypto.h"
end_include

begin_include
include|#
directive|include
file|"asn1.h"
end_include

begin_include
include|#
directive|include
file|"bignum.h"
end_include

begin_include
include|#
directive|include
file|"rsa.h"
end_include

begin_struct
struct|struct
name|crypto_rsa_key
block|{
name|int
name|private_key
decl_stmt|;
comment|/* whether private key is set */
name|struct
name|bignum
modifier|*
name|n
decl_stmt|;
comment|/* modulus (p * q) */
name|struct
name|bignum
modifier|*
name|e
decl_stmt|;
comment|/* public exponent */
comment|/* The following parameters are available only if private_key is set */
name|struct
name|bignum
modifier|*
name|d
decl_stmt|;
comment|/* private exponent */
name|struct
name|bignum
modifier|*
name|p
decl_stmt|;
comment|/* prime p (factor of n) */
name|struct
name|bignum
modifier|*
name|q
decl_stmt|;
comment|/* prime q (factor of n) */
name|struct
name|bignum
modifier|*
name|dmp1
decl_stmt|;
comment|/* d mod (p - 1); CRT exponent */
name|struct
name|bignum
modifier|*
name|dmq1
decl_stmt|;
comment|/* d mod (q - 1); CRT exponent */
name|struct
name|bignum
modifier|*
name|iqmp
decl_stmt|;
comment|/* 1 / q mod p; CRT coefficient */
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|u8
modifier|*
name|crypto_rsa_parse_integer
parameter_list|(
specifier|const
name|u8
modifier|*
name|pos
parameter_list|,
specifier|const
name|u8
modifier|*
name|end
parameter_list|,
name|struct
name|bignum
modifier|*
name|num
parameter_list|)
block|{
name|struct
name|asn1_hdr
name|hdr
decl_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|asn1_get_next
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
operator|&
name|hdr
argument_list|)
operator|<
literal|0
operator|||
name|hdr
operator|.
name|class
operator|!=
name|ASN1_CLASS_UNIVERSAL
operator|||
name|hdr
operator|.
name|tag
operator|!=
name|ASN1_TAG_INTEGER
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSA: Expected INTEGER - found class %d "
literal|"tag 0x%x"
argument_list|,
name|hdr
operator|.
name|class
argument_list|,
name|hdr
operator|.
name|tag
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bignum_set_unsigned_bin
argument_list|(
name|num
argument_list|,
name|hdr
operator|.
name|payload
argument_list|,
name|hdr
operator|.
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSA: Failed to parse INTEGER"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|hdr
operator|.
name|payload
operator|+
name|hdr
operator|.
name|length
return|;
block|}
end_function

begin_comment
comment|/**  * crypto_rsa_import_public_key - Import an RSA public key  * @buf: Key buffer (DER encoded RSA public key)  * @len: Key buffer length in bytes  * Returns: Pointer to the public key or %NULL on failure  */
end_comment

begin_function
name|struct
name|crypto_rsa_key
modifier|*
name|crypto_rsa_import_public_key
parameter_list|(
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|crypto_rsa_key
modifier|*
name|key
decl_stmt|;
name|struct
name|asn1_hdr
name|hdr
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|key
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|key
operator|->
name|n
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
name|key
operator|->
name|e
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|n
operator|==
name|NULL
operator|||
name|key
operator|->
name|e
operator|==
name|NULL
condition|)
block|{
name|crypto_rsa_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * PKCS #1, 7.1: 	 * RSAPublicKey ::= SEQUENCE { 	 *     modulus INTEGER, -- n 	 *     publicExponent INTEGER -- e  	 * } 	 */
if|if
condition|(
name|asn1_get_next
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|hdr
argument_list|)
operator|<
literal|0
operator|||
name|hdr
operator|.
name|class
operator|!=
name|ASN1_CLASS_UNIVERSAL
operator|||
name|hdr
operator|.
name|tag
operator|!=
name|ASN1_TAG_SEQUENCE
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSA: Expected SEQUENCE "
literal|"(public key) - found class %d tag 0x%x"
argument_list|,
name|hdr
operator|.
name|class
argument_list|,
name|hdr
operator|.
name|tag
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|pos
operator|=
name|hdr
operator|.
name|payload
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|hdr
operator|.
name|length
expr_stmt|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|key
operator|->
name|n
argument_list|)
expr_stmt|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|key
operator|->
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|pos
operator|!=
name|end
condition|)
block|{
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSA: Extra data in public key SEQUENCE"
argument_list|,
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
name|key
return|;
name|error
label|:
name|crypto_rsa_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * crypto_rsa_import_private_key - Import an RSA private key  * @buf: Key buffer (DER encoded RSA private key)  * @len: Key buffer length in bytes  * Returns: Pointer to the private key or %NULL on failure  */
end_comment

begin_function
name|struct
name|crypto_rsa_key
modifier|*
name|crypto_rsa_import_private_key
parameter_list|(
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|crypto_rsa_key
modifier|*
name|key
decl_stmt|;
name|struct
name|bignum
modifier|*
name|zero
decl_stmt|;
name|struct
name|asn1_hdr
name|hdr
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|key
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|key
operator|->
name|private_key
operator|=
literal|1
expr_stmt|;
name|key
operator|->
name|n
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
name|key
operator|->
name|e
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
name|key
operator|->
name|d
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
name|key
operator|->
name|p
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
name|key
operator|->
name|q
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
name|key
operator|->
name|dmp1
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
name|key
operator|->
name|dmq1
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
name|key
operator|->
name|iqmp
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|n
operator|==
name|NULL
operator|||
name|key
operator|->
name|e
operator|==
name|NULL
operator|||
name|key
operator|->
name|d
operator|==
name|NULL
operator|||
name|key
operator|->
name|p
operator|==
name|NULL
operator|||
name|key
operator|->
name|q
operator|==
name|NULL
operator|||
name|key
operator|->
name|dmp1
operator|==
name|NULL
operator|||
name|key
operator|->
name|dmq1
operator|==
name|NULL
operator|||
name|key
operator|->
name|iqmp
operator|==
name|NULL
condition|)
block|{
name|crypto_rsa_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * PKCS #1, 7.2: 	 * RSAPrivateKey ::= SEQUENCE { 	 *    version Version, 	 *    modulus INTEGER, -- n 	 *    publicExponent INTEGER, -- e 	 *    privateExponent INTEGER, -- d 	 *    prime1 INTEGER, -- p 	 *    prime2 INTEGER, -- q 	 *    exponent1 INTEGER, -- d mod (p-1) 	 *    exponent2 INTEGER, -- d mod (q-1) 	 *    coefficient INTEGER -- (inverse of q) mod p 	 * } 	 * 	 * Version ::= INTEGER -- shall be 0 for this version of the standard 	 */
if|if
condition|(
name|asn1_get_next
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|hdr
argument_list|)
operator|<
literal|0
operator|||
name|hdr
operator|.
name|class
operator|!=
name|ASN1_CLASS_UNIVERSAL
operator|||
name|hdr
operator|.
name|tag
operator|!=
name|ASN1_TAG_SEQUENCE
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSA: Expected SEQUENCE "
literal|"(public key) - found class %d tag 0x%x"
argument_list|,
name|hdr
operator|.
name|class
argument_list|,
name|hdr
operator|.
name|tag
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|pos
operator|=
name|hdr
operator|.
name|payload
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|hdr
operator|.
name|length
expr_stmt|;
name|zero
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|zero
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL
operator|||
name|bignum_cmp_d
argument_list|(
name|zero
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSA: Expected zero INTEGER in the "
literal|"beginning of private key; not found"
argument_list|)
expr_stmt|;
name|bignum_deinit
argument_list|(
name|zero
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|bignum_deinit
argument_list|(
name|zero
argument_list|)
expr_stmt|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|key
operator|->
name|n
argument_list|)
expr_stmt|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|key
operator|->
name|e
argument_list|)
expr_stmt|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|key
operator|->
name|d
argument_list|)
expr_stmt|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|key
operator|->
name|p
argument_list|)
expr_stmt|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|key
operator|->
name|q
argument_list|)
expr_stmt|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|key
operator|->
name|dmp1
argument_list|)
expr_stmt|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|key
operator|->
name|dmq1
argument_list|)
expr_stmt|;
name|pos
operator|=
name|crypto_rsa_parse_integer
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
name|key
operator|->
name|iqmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|pos
operator|!=
name|end
condition|)
block|{
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSA: Extra data in public key SEQUENCE"
argument_list|,
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
name|key
return|;
name|error
label|:
name|crypto_rsa_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * crypto_rsa_get_modulus_len - Get the modulus length of the RSA key  * @key: RSA key  * Returns: Modulus length of the key  */
end_comment

begin_function
name|size_t
name|crypto_rsa_get_modulus_len
parameter_list|(
name|struct
name|crypto_rsa_key
modifier|*
name|key
parameter_list|)
block|{
return|return
name|bignum_get_unsigned_bin_len
argument_list|(
name|key
operator|->
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * crypto_rsa_exptmod - RSA modular exponentiation  * @in: Input data  * @inlen: Input data length  * @out: Buffer for output data  * @outlen: Maximum size of the output buffer and used size on success  * @key: RSA key  * @use_private: 1 = Use RSA private key, 0 = Use RSA public key  * Returns: 0 on success, -1 on failure  */
end_comment

begin_function
name|int
name|crypto_rsa_exptmod
parameter_list|(
specifier|const
name|u8
modifier|*
name|in
parameter_list|,
name|size_t
name|inlen
parameter_list|,
name|u8
modifier|*
name|out
parameter_list|,
name|size_t
modifier|*
name|outlen
parameter_list|,
name|struct
name|crypto_rsa_key
modifier|*
name|key
parameter_list|,
name|int
name|use_private
parameter_list|)
block|{
name|struct
name|bignum
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|a
init|=
name|NULL
decl_stmt|,
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|size_t
name|modlen
decl_stmt|;
if|if
condition|(
name|use_private
operator|&&
operator|!
name|key
operator|->
name|private_key
condition|)
return|return
operator|-
literal|1
return|;
name|tmp
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bignum_set_unsigned_bin
argument_list|(
name|tmp
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bignum_cmp
argument_list|(
name|key
operator|->
name|n
argument_list|,
name|tmp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Too large input value for the RSA key modulus */
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|use_private
condition|)
block|{
comment|/* 		 * Decrypt (or sign) using Chinese remainer theorem to speed 		 * up calculation. This is equivalent to tmp = tmp^d mod n 		 * (which would require more CPU to calculate directly). 		 * 		 * dmp1 = (1/e) mod (p-1) 		 * dmq1 = (1/e) mod (q-1) 		 * iqmp = (1/q) mod p, where p> q 		 * m1 = c^dmp1 mod p 		 * m2 = c^dmq1 mod q 		 * h = q^-1 (m1 - m2) mod p 		 * m = m2 + hq 		 */
name|a
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
name|b
operator|=
name|bignum_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|b
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* a = tmp^dmp1 mod p */
if|if
condition|(
name|bignum_exptmod
argument_list|(
name|tmp
argument_list|,
name|key
operator|->
name|dmp1
argument_list|,
name|key
operator|->
name|p
argument_list|,
name|a
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* b = tmp^dmq1 mod q */
if|if
condition|(
name|bignum_exptmod
argument_list|(
name|tmp
argument_list|,
name|key
operator|->
name|dmq1
argument_list|,
name|key
operator|->
name|q
argument_list|,
name|b
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* tmp = (a - b) * (1/q mod p) (mod p) */
if|if
condition|(
name|bignum_sub
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|tmp
argument_list|)
operator|<
literal|0
operator|||
name|bignum_mulmod
argument_list|(
name|tmp
argument_list|,
name|key
operator|->
name|iqmp
argument_list|,
name|key
operator|->
name|p
argument_list|,
name|tmp
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* tmp = b + q * tmp */
if|if
condition|(
name|bignum_mul
argument_list|(
name|tmp
argument_list|,
name|key
operator|->
name|q
argument_list|,
name|tmp
argument_list|)
operator|<
literal|0
operator|||
name|bignum_add
argument_list|(
name|tmp
argument_list|,
name|b
argument_list|,
name|tmp
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
comment|/* Encrypt (or verify signature) */
comment|/* tmp = tmp^e mod N */
if|if
condition|(
name|bignum_exptmod
argument_list|(
name|tmp
argument_list|,
name|key
operator|->
name|e
argument_list|,
name|key
operator|->
name|n
argument_list|,
name|tmp
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
name|modlen
operator|=
name|crypto_rsa_get_modulus_len
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|modlen
operator|>
operator|*
name|outlen
condition|)
block|{
operator|*
name|outlen
operator|=
name|modlen
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|bignum_get_unsigned_bin_len
argument_list|(
name|tmp
argument_list|)
operator|>
name|modlen
condition|)
goto|goto
name|error
goto|;
comment|/* should never happen */
operator|*
name|outlen
operator|=
name|modlen
expr_stmt|;
name|os_memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|modlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bignum_get_unsigned_bin
argument_list|(
name|tmp
argument_list|,
name|out
operator|+
operator|(
name|modlen
operator|-
name|bignum_get_unsigned_bin_len
argument_list|(
name|tmp
argument_list|)
operator|)
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
literal|0
expr_stmt|;
name|error
label|:
name|bignum_deinit
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|bignum_deinit
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bignum_deinit
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * crypto_rsa_free - Free RSA key  * @key: RSA key to be freed  *  * This function frees an RSA key imported with either  * crypto_rsa_import_public_key() or crypto_rsa_import_private_key().  */
end_comment

begin_function
name|void
name|crypto_rsa_free
parameter_list|(
name|struct
name|crypto_rsa_key
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
condition|)
block|{
name|bignum_deinit
argument_list|(
name|key
operator|->
name|n
argument_list|)
expr_stmt|;
name|bignum_deinit
argument_list|(
name|key
operator|->
name|e
argument_list|)
expr_stmt|;
name|bignum_deinit
argument_list|(
name|key
operator|->
name|d
argument_list|)
expr_stmt|;
name|bignum_deinit
argument_list|(
name|key
operator|->
name|p
argument_list|)
expr_stmt|;
name|bignum_deinit
argument_list|(
name|key
operator|->
name|q
argument_list|)
expr_stmt|;
name|bignum_deinit
argument_list|(
name|key
operator|->
name|dmp1
argument_list|)
expr_stmt|;
name|bignum_deinit
argument_list|(
name|key
operator|->
name|dmq1
argument_list|)
expr_stmt|;
name|bignum_deinit
argument_list|(
name|key
operator|->
name|iqmp
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

