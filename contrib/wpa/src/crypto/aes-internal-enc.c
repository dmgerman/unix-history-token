begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * AES (Rijndael) cipher - encrypt  *  * Modifications to public domain implementation:  * - support only 128-bit keys  * - cleanup  * - use C pre-processor to make it easier to change S table access  * - added option (AES_SMALL_TABLES) for reducing code size by about 8 kB at  *   cost of reduced throughput (quite small difference on Pentium 4,  *   10-25% when using -O1 or -O2 optimization)  *  * Copyright (c) 2003-2005, Jouni Malinen<j@w1.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"crypto.h"
end_include

begin_include
include|#
directive|include
file|"aes_i.h"
end_include

begin_function
name|void
name|rijndaelEncrypt
parameter_list|(
specifier|const
name|u32
name|rk
index|[
comment|/*44*/
index|]
parameter_list|,
specifier|const
name|u8
name|pt
index|[
literal|16
index|]
parameter_list|,
name|u8
name|ct
index|[
literal|16
index|]
parameter_list|)
block|{
name|u32
name|s0
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|,
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
specifier|const
name|int
name|Nr
init|=
literal|10
decl_stmt|;
ifndef|#
directive|ifndef
name|FULL_UNROLL
name|int
name|r
decl_stmt|;
endif|#
directive|endif
comment|/* ?FULL_UNROLL */
comment|/* 	 * map byte array block to cipher state 	 * and add initial round key: 	 */
name|s0
operator|=
name|GETU32
argument_list|(
name|pt
argument_list|)
operator|^
name|rk
index|[
literal|0
index|]
expr_stmt|;
name|s1
operator|=
name|GETU32
argument_list|(
name|pt
operator|+
literal|4
argument_list|)
operator|^
name|rk
index|[
literal|1
index|]
expr_stmt|;
name|s2
operator|=
name|GETU32
argument_list|(
name|pt
operator|+
literal|8
argument_list|)
operator|^
name|rk
index|[
literal|2
index|]
expr_stmt|;
name|s3
operator|=
name|GETU32
argument_list|(
name|pt
operator|+
literal|12
argument_list|)
operator|^
name|rk
index|[
literal|3
index|]
expr_stmt|;
define|#
directive|define
name|ROUND
parameter_list|(
name|i
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
define|\
value|d##0 = TE0(s##0) ^ TE1(s##1) ^ TE2(s##2) ^ TE3(s##3) ^ rk[4 * i]; \ d##1 = TE0(s##1) ^ TE1(s##2) ^ TE2(s##3) ^ TE3(s##0) ^ rk[4 * i + 1]; \ d##2 = TE0(s##2) ^ TE1(s##3) ^ TE2(s##0) ^ TE3(s##1) ^ rk[4 * i + 2]; \ d##3 = TE0(s##3) ^ TE1(s##0) ^ TE2(s##1) ^ TE3(s##2) ^ rk[4 * i + 3]
ifdef|#
directive|ifdef
name|FULL_UNROLL
name|ROUND
argument_list|(
literal|1
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|2
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|3
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|4
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|5
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|6
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|7
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|8
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ROUND
argument_list|(
literal|9
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|rk
operator|+=
name|Nr
operator|<<
literal|2
expr_stmt|;
else|#
directive|else
comment|/* !FULL_UNROLL */
comment|/* Nr - 1 full rounds: */
name|r
operator|=
name|Nr
operator|>>
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ROUND
argument_list|(
literal|1
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|rk
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|--
name|r
operator|==
literal|0
condition|)
break|break;
name|ROUND
argument_list|(
literal|0
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ?FULL_UNROLL */
undef|#
directive|undef
name|ROUND
comment|/* 	 * apply last round and 	 * map cipher state to byte array block: 	 */
name|s0
operator|=
name|TE41
argument_list|(
name|t0
argument_list|)
operator|^
name|TE42
argument_list|(
name|t1
argument_list|)
operator|^
name|TE43
argument_list|(
name|t2
argument_list|)
operator|^
name|TE44
argument_list|(
name|t3
argument_list|)
operator|^
name|rk
index|[
literal|0
index|]
expr_stmt|;
name|PUTU32
argument_list|(
name|ct
argument_list|,
name|s0
argument_list|)
expr_stmt|;
name|s1
operator|=
name|TE41
argument_list|(
name|t1
argument_list|)
operator|^
name|TE42
argument_list|(
name|t2
argument_list|)
operator|^
name|TE43
argument_list|(
name|t3
argument_list|)
operator|^
name|TE44
argument_list|(
name|t0
argument_list|)
operator|^
name|rk
index|[
literal|1
index|]
expr_stmt|;
name|PUTU32
argument_list|(
name|ct
operator|+
literal|4
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|TE41
argument_list|(
name|t2
argument_list|)
operator|^
name|TE42
argument_list|(
name|t3
argument_list|)
operator|^
name|TE43
argument_list|(
name|t0
argument_list|)
operator|^
name|TE44
argument_list|(
name|t1
argument_list|)
operator|^
name|rk
index|[
literal|2
index|]
expr_stmt|;
name|PUTU32
argument_list|(
name|ct
operator|+
literal|8
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|s3
operator|=
name|TE41
argument_list|(
name|t3
argument_list|)
operator|^
name|TE42
argument_list|(
name|t0
argument_list|)
operator|^
name|TE43
argument_list|(
name|t1
argument_list|)
operator|^
name|TE44
argument_list|(
name|t2
argument_list|)
operator|^
name|rk
index|[
literal|3
index|]
expr_stmt|;
name|PUTU32
argument_list|(
name|ct
operator|+
literal|12
argument_list|,
name|s3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|aes_encrypt_init
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u32
modifier|*
name|rk
decl_stmt|;
if|if
condition|(
name|len
operator|!=
literal|16
condition|)
return|return
name|NULL
return|;
name|rk
operator|=
name|os_malloc
argument_list|(
name|AES_PRIV_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rk
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|rijndaelKeySetupEnc
argument_list|(
name|rk
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|rk
return|;
block|}
end_function

begin_function
name|void
name|aes_encrypt
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u8
modifier|*
name|plain
parameter_list|,
name|u8
modifier|*
name|crypt
parameter_list|)
block|{
name|rijndaelEncrypt
argument_list|(
name|ctx
argument_list|,
name|plain
argument_list|,
name|crypt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aes_encrypt_deinit
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|os_memset
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
name|AES_PRIV_SIZE
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

