begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Galois/Counter Mode (GCM) and GMAC with AES  *  * Copyright (c) 2012, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"aes.h"
end_include

begin_include
include|#
directive|include
file|"aes_wrap.h"
end_include

begin_function
specifier|static
name|void
name|inc32
parameter_list|(
name|u8
modifier|*
name|block
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|WPA_GET_BE32
argument_list|(
name|block
operator|+
name|AES_BLOCK_SIZE
operator|-
literal|4
argument_list|)
expr_stmt|;
name|val
operator|++
expr_stmt|;
name|WPA_PUT_BE32
argument_list|(
name|block
operator|+
name|AES_BLOCK_SIZE
operator|-
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xor_block
parameter_list|(
name|u8
modifier|*
name|dst
parameter_list|,
specifier|const
name|u8
modifier|*
name|src
parameter_list|)
block|{
name|u32
modifier|*
name|d
init|=
operator|(
name|u32
operator|*
operator|)
name|dst
decl_stmt|;
name|u32
modifier|*
name|s
init|=
operator|(
name|u32
operator|*
operator|)
name|src
decl_stmt|;
operator|*
name|d
operator|++
operator|^=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|^=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|^=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|^=
operator|*
name|s
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shift_right_block
parameter_list|(
name|u8
modifier|*
name|v
parameter_list|)
block|{
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|WPA_GET_BE32
argument_list|(
name|v
operator|+
literal|12
argument_list|)
expr_stmt|;
name|val
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|v
index|[
literal|11
index|]
operator|&
literal|0x01
condition|)
name|val
operator||=
literal|0x80000000
expr_stmt|;
name|WPA_PUT_BE32
argument_list|(
name|v
operator|+
literal|12
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|WPA_GET_BE32
argument_list|(
name|v
operator|+
literal|8
argument_list|)
expr_stmt|;
name|val
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|v
index|[
literal|7
index|]
operator|&
literal|0x01
condition|)
name|val
operator||=
literal|0x80000000
expr_stmt|;
name|WPA_PUT_BE32
argument_list|(
name|v
operator|+
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|WPA_GET_BE32
argument_list|(
name|v
operator|+
literal|4
argument_list|)
expr_stmt|;
name|val
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|v
index|[
literal|3
index|]
operator|&
literal|0x01
condition|)
name|val
operator||=
literal|0x80000000
expr_stmt|;
name|WPA_PUT_BE32
argument_list|(
name|v
operator|+
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|WPA_GET_BE32
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|val
operator|>>=
literal|1
expr_stmt|;
name|WPA_PUT_BE32
argument_list|(
name|v
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Multiplication in GF(2^128) */
end_comment

begin_function
specifier|static
name|void
name|gf_mult
parameter_list|(
specifier|const
name|u8
modifier|*
name|x
parameter_list|,
specifier|const
name|u8
modifier|*
name|y
parameter_list|,
name|u8
modifier|*
name|z
parameter_list|)
block|{
name|u8
name|v
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|os_memset
argument_list|(
name|z
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Z_0 = 0^128 */
name|os_memcpy
argument_list|(
name|v
argument_list|,
name|y
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* V_0 = Y */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|x
index|[
name|i
index|]
operator|&
name|BIT
argument_list|(
literal|7
operator|-
name|j
argument_list|)
condition|)
block|{
comment|/* Z_(i + 1) = Z_i XOR V_i */
name|xor_block
argument_list|(
name|z
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Z_(i + 1) = Z_i */
block|}
if|if
condition|(
name|v
index|[
literal|15
index|]
operator|&
literal|0x01
condition|)
block|{
comment|/* V_(i + 1) = (V_i>> 1) XOR R */
name|shift_right_block
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* R = 11100001 || 0^120 */
name|v
index|[
literal|0
index|]
operator|^=
literal|0xe1
expr_stmt|;
block|}
else|else
block|{
comment|/* V_(i + 1) = V_i>> 1 */
name|shift_right_block
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ghash_start
parameter_list|(
name|u8
modifier|*
name|y
parameter_list|)
block|{
comment|/* Y_0 = 0^128 */
name|os_memset
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ghash
parameter_list|(
specifier|const
name|u8
modifier|*
name|h
parameter_list|,
specifier|const
name|u8
modifier|*
name|x
parameter_list|,
name|size_t
name|xlen
parameter_list|,
name|u8
modifier|*
name|y
parameter_list|)
block|{
name|size_t
name|m
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|u8
modifier|*
name|xpos
init|=
name|x
decl_stmt|;
name|u8
name|tmp
index|[
literal|16
index|]
decl_stmt|;
name|m
operator|=
name|xlen
operator|/
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
comment|/* Y_i = (Y^(i-1) XOR X_i) dot H */
name|xor_block
argument_list|(
name|y
argument_list|,
name|xpos
argument_list|)
expr_stmt|;
name|xpos
operator|+=
literal|16
expr_stmt|;
comment|/* dot operation: 		 * multiplication operation for binary Galois (finite) field of 		 * 2^128 elements */
name|gf_mult
argument_list|(
name|y
argument_list|,
name|h
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|y
argument_list|,
name|tmp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|+
name|xlen
operator|>
name|xpos
condition|)
block|{
comment|/* Add zero padded last block */
name|size_t
name|last
init|=
name|x
operator|+
name|xlen
operator|-
name|xpos
decl_stmt|;
name|os_memcpy
argument_list|(
name|tmp
argument_list|,
name|xpos
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
name|tmp
operator|+
name|last
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
name|last
argument_list|)
expr_stmt|;
comment|/* Y_i = (Y^(i-1) XOR X_i) dot H */
name|xor_block
argument_list|(
name|y
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* dot operation: 		 * multiplication operation for binary Galois (finite) field of 		 * 2^128 elements */
name|gf_mult
argument_list|(
name|y
argument_list|,
name|h
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|y
argument_list|,
name|tmp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* Return Y_m */
block|}
end_function

begin_function
specifier|static
name|void
name|aes_gctr
parameter_list|(
name|void
modifier|*
name|aes
parameter_list|,
specifier|const
name|u8
modifier|*
name|icb
parameter_list|,
specifier|const
name|u8
modifier|*
name|x
parameter_list|,
name|size_t
name|xlen
parameter_list|,
name|u8
modifier|*
name|y
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|n
decl_stmt|,
name|last
decl_stmt|;
name|u8
name|cb
index|[
name|AES_BLOCK_SIZE
index|]
decl_stmt|,
name|tmp
index|[
name|AES_BLOCK_SIZE
index|]
decl_stmt|;
specifier|const
name|u8
modifier|*
name|xpos
init|=
name|x
decl_stmt|;
name|u8
modifier|*
name|ypos
init|=
name|y
decl_stmt|;
if|if
condition|(
name|xlen
operator|==
literal|0
condition|)
return|return;
name|n
operator|=
name|xlen
operator|/
literal|16
expr_stmt|;
name|os_memcpy
argument_list|(
name|cb
argument_list|,
name|icb
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
comment|/* Full blocks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|aes_encrypt
argument_list|(
name|aes
argument_list|,
name|cb
argument_list|,
name|ypos
argument_list|)
expr_stmt|;
name|xor_block
argument_list|(
name|ypos
argument_list|,
name|xpos
argument_list|)
expr_stmt|;
name|xpos
operator|+=
name|AES_BLOCK_SIZE
expr_stmt|;
name|ypos
operator|+=
name|AES_BLOCK_SIZE
expr_stmt|;
name|inc32
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|x
operator|+
name|xlen
operator|-
name|xpos
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
comment|/* Last, partial block */
name|aes_encrypt
argument_list|(
name|aes
argument_list|,
name|cb
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
operator|*
name|ypos
operator|++
operator|=
operator|*
name|xpos
operator|++
operator|^
name|tmp
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|aes_gcm_init_hash_subkey
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|key_len
parameter_list|,
name|u8
modifier|*
name|H
parameter_list|)
block|{
name|void
modifier|*
name|aes
decl_stmt|;
name|aes
operator|=
name|aes_encrypt_init
argument_list|(
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|aes
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Generate hash subkey H = AES_K(0^128) */
name|os_memset
argument_list|(
name|H
argument_list|,
literal|0
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|aes_encrypt
argument_list|(
name|aes
argument_list|,
name|H
argument_list|,
name|H
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"Hash subkey H for GHASH"
argument_list|,
name|H
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
return|return
name|aes
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aes_gcm_prepare_j0
parameter_list|(
specifier|const
name|u8
modifier|*
name|iv
parameter_list|,
name|size_t
name|iv_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|H
parameter_list|,
name|u8
modifier|*
name|J0
parameter_list|)
block|{
name|u8
name|len_buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|iv_len
operator|==
literal|12
condition|)
block|{
comment|/* Prepare block J_0 = IV || 0^31 || 1 [len(IV) = 96] */
name|os_memcpy
argument_list|(
name|J0
argument_list|,
name|iv
argument_list|,
name|iv_len
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
name|J0
operator|+
name|iv_len
argument_list|,
literal|0
argument_list|,
name|AES_BLOCK_SIZE
operator|-
name|iv_len
argument_list|)
expr_stmt|;
name|J0
index|[
name|AES_BLOCK_SIZE
operator|-
literal|1
index|]
operator|=
literal|0x01
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * s = 128 * ceil(len(IV)/128) - len(IV) 		 * J_0 = GHASH_H(IV || 0^(s+64) || [len(IV)]_64) 		 */
name|ghash_start
argument_list|(
name|J0
argument_list|)
expr_stmt|;
name|ghash
argument_list|(
name|H
argument_list|,
name|iv
argument_list|,
name|iv_len
argument_list|,
name|J0
argument_list|)
expr_stmt|;
name|WPA_PUT_BE64
argument_list|(
name|len_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WPA_PUT_BE64
argument_list|(
name|len_buf
operator|+
literal|8
argument_list|,
name|iv_len
operator|*
literal|8
argument_list|)
expr_stmt|;
name|ghash
argument_list|(
name|H
argument_list|,
name|len_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|len_buf
argument_list|)
argument_list|,
name|J0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aes_gcm_gctr
parameter_list|(
name|void
modifier|*
name|aes
parameter_list|,
specifier|const
name|u8
modifier|*
name|J0
parameter_list|,
specifier|const
name|u8
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|,
name|u8
modifier|*
name|out
parameter_list|)
block|{
name|u8
name|J0inc
index|[
name|AES_BLOCK_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
name|os_memcpy
argument_list|(
name|J0inc
argument_list|,
name|J0
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|inc32
argument_list|(
name|J0inc
argument_list|)
expr_stmt|;
name|aes_gctr
argument_list|(
name|aes
argument_list|,
name|J0inc
argument_list|,
name|in
argument_list|,
name|len
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aes_gcm_ghash
parameter_list|(
specifier|const
name|u8
modifier|*
name|H
parameter_list|,
specifier|const
name|u8
modifier|*
name|aad
parameter_list|,
name|size_t
name|aad_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|crypt
parameter_list|,
name|size_t
name|crypt_len
parameter_list|,
name|u8
modifier|*
name|S
parameter_list|)
block|{
name|u8
name|len_buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * u = 128 * ceil[len(C)/128] - len(C) 	 * v = 128 * ceil[len(A)/128] - len(A) 	 * S = GHASH_H(A || 0^v || C || 0^u || [len(A)]64 || [len(C)]64) 	 * (i.e., zero padded to block size A || C and lengths of each in bits) 	 */
name|ghash_start
argument_list|(
name|S
argument_list|)
expr_stmt|;
name|ghash
argument_list|(
name|H
argument_list|,
name|aad
argument_list|,
name|aad_len
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|ghash
argument_list|(
name|H
argument_list|,
name|crypt
argument_list|,
name|crypt_len
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|WPA_PUT_BE64
argument_list|(
name|len_buf
argument_list|,
name|aad_len
operator|*
literal|8
argument_list|)
expr_stmt|;
name|WPA_PUT_BE64
argument_list|(
name|len_buf
operator|+
literal|8
argument_list|,
name|crypt_len
operator|*
literal|8
argument_list|)
expr_stmt|;
name|ghash
argument_list|(
name|H
argument_list|,
name|len_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|len_buf
argument_list|)
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"S = GHASH_H(...)"
argument_list|,
name|S
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * aes_gcm_ae - GCM-AE_K(IV, P, A)  */
end_comment

begin_function
name|int
name|aes_gcm_ae
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|key_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|iv
parameter_list|,
name|size_t
name|iv_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|plain
parameter_list|,
name|size_t
name|plain_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|aad
parameter_list|,
name|size_t
name|aad_len
parameter_list|,
name|u8
modifier|*
name|crypt
parameter_list|,
name|u8
modifier|*
name|tag
parameter_list|)
block|{
name|u8
name|H
index|[
name|AES_BLOCK_SIZE
index|]
decl_stmt|;
name|u8
name|J0
index|[
name|AES_BLOCK_SIZE
index|]
decl_stmt|;
name|u8
name|S
index|[
literal|16
index|]
decl_stmt|;
name|void
modifier|*
name|aes
decl_stmt|;
name|aes
operator|=
name|aes_gcm_init_hash_subkey
argument_list|(
name|key
argument_list|,
name|key_len
argument_list|,
name|H
argument_list|)
expr_stmt|;
if|if
condition|(
name|aes
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|aes_gcm_prepare_j0
argument_list|(
name|iv
argument_list|,
name|iv_len
argument_list|,
name|H
argument_list|,
name|J0
argument_list|)
expr_stmt|;
comment|/* C = GCTR_K(inc_32(J_0), P) */
name|aes_gcm_gctr
argument_list|(
name|aes
argument_list|,
name|J0
argument_list|,
name|plain
argument_list|,
name|plain_len
argument_list|,
name|crypt
argument_list|)
expr_stmt|;
name|aes_gcm_ghash
argument_list|(
name|H
argument_list|,
name|aad
argument_list|,
name|aad_len
argument_list|,
name|crypt
argument_list|,
name|plain_len
argument_list|,
name|S
argument_list|)
expr_stmt|;
comment|/* T = MSB_t(GCTR_K(J_0, S)) */
name|aes_gctr
argument_list|(
name|aes
argument_list|,
name|J0
argument_list|,
name|S
argument_list|,
sizeof|sizeof
argument_list|(
name|S
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* Return (C, T) */
name|aes_encrypt_deinit
argument_list|(
name|aes
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * aes_gcm_ad - GCM-AD_K(IV, C, A, T)  */
end_comment

begin_function
name|int
name|aes_gcm_ad
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|key_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|iv
parameter_list|,
name|size_t
name|iv_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|crypt
parameter_list|,
name|size_t
name|crypt_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|aad
parameter_list|,
name|size_t
name|aad_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|tag
parameter_list|,
name|u8
modifier|*
name|plain
parameter_list|)
block|{
name|u8
name|H
index|[
name|AES_BLOCK_SIZE
index|]
decl_stmt|;
name|u8
name|J0
index|[
name|AES_BLOCK_SIZE
index|]
decl_stmt|;
name|u8
name|S
index|[
literal|16
index|]
decl_stmt|,
name|T
index|[
literal|16
index|]
decl_stmt|;
name|void
modifier|*
name|aes
decl_stmt|;
name|aes
operator|=
name|aes_gcm_init_hash_subkey
argument_list|(
name|key
argument_list|,
name|key_len
argument_list|,
name|H
argument_list|)
expr_stmt|;
if|if
condition|(
name|aes
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|aes_gcm_prepare_j0
argument_list|(
name|iv
argument_list|,
name|iv_len
argument_list|,
name|H
argument_list|,
name|J0
argument_list|)
expr_stmt|;
comment|/* P = GCTR_K(inc_32(J_0), C) */
name|aes_gcm_gctr
argument_list|(
name|aes
argument_list|,
name|J0
argument_list|,
name|crypt
argument_list|,
name|crypt_len
argument_list|,
name|plain
argument_list|)
expr_stmt|;
name|aes_gcm_ghash
argument_list|(
name|H
argument_list|,
name|aad
argument_list|,
name|aad_len
argument_list|,
name|crypt
argument_list|,
name|crypt_len
argument_list|,
name|S
argument_list|)
expr_stmt|;
comment|/* T' = MSB_t(GCTR_K(J_0, S)) */
name|aes_gctr
argument_list|(
name|aes
argument_list|,
name|J0
argument_list|,
name|S
argument_list|,
sizeof|sizeof
argument_list|(
name|S
argument_list|)
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|aes_encrypt_deinit
argument_list|(
name|aes
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_memcmp
argument_list|(
name|tag
argument_list|,
name|T
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"GCM: Tag mismatch"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|aes_gmac
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|key_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|iv
parameter_list|,
name|size_t
name|iv_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|aad
parameter_list|,
name|size_t
name|aad_len
parameter_list|,
name|u8
modifier|*
name|tag
parameter_list|)
block|{
return|return
name|aes_gcm_ae
argument_list|(
name|key
argument_list|,
name|key_len
argument_list|,
name|iv
argument_list|,
name|iv_len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|aad
argument_list|,
name|aad_len
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
return|;
block|}
end_function

end_unit

