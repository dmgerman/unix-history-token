begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * SHA-256 hash implementation and interface functions  * Copyright (c) 2003-2011, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"sha256.h"
end_include

begin_include
include|#
directive|include
file|"sha256_i.h"
end_include

begin_include
include|#
directive|include
file|"crypto.h"
end_include

begin_comment
comment|/**  * sha256_vector - SHA256 hash for data vector  * @num_elem: Number of elements in the data vector  * @addr: Pointers to the data areas  * @len: Lengths of the data blocks  * @mac: Buffer for the hash  * Returns: 0 on success, -1 of failure  */
end_comment

begin_function
name|int
name|sha256_vector
parameter_list|(
name|size_t
name|num_elem
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
index|[]
parameter_list|,
specifier|const
name|size_t
modifier|*
name|len
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|sha256_state
name|ctx
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|sha256_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_elem
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sha256_process
argument_list|(
operator|&
name|ctx
argument_list|,
name|addr
index|[
name|i
index|]
argument_list|,
name|len
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sha256_done
argument_list|(
operator|&
name|ctx
argument_list|,
name|mac
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ===== start - public domain SHA256 implementation ===== */
end_comment

begin_comment
comment|/* This is based on SHA256 implementation in LibTomCrypt that was released into  * public domain by Tom St Denis. */
end_comment

begin_comment
comment|/* the K array */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|long
name|K
index|[
literal|64
index|]
init|=
block|{
literal|0x428a2f98UL
block|,
literal|0x71374491UL
block|,
literal|0xb5c0fbcfUL
block|,
literal|0xe9b5dba5UL
block|,
literal|0x3956c25bUL
block|,
literal|0x59f111f1UL
block|,
literal|0x923f82a4UL
block|,
literal|0xab1c5ed5UL
block|,
literal|0xd807aa98UL
block|,
literal|0x12835b01UL
block|,
literal|0x243185beUL
block|,
literal|0x550c7dc3UL
block|,
literal|0x72be5d74UL
block|,
literal|0x80deb1feUL
block|,
literal|0x9bdc06a7UL
block|,
literal|0xc19bf174UL
block|,
literal|0xe49b69c1UL
block|,
literal|0xefbe4786UL
block|,
literal|0x0fc19dc6UL
block|,
literal|0x240ca1ccUL
block|,
literal|0x2de92c6fUL
block|,
literal|0x4a7484aaUL
block|,
literal|0x5cb0a9dcUL
block|,
literal|0x76f988daUL
block|,
literal|0x983e5152UL
block|,
literal|0xa831c66dUL
block|,
literal|0xb00327c8UL
block|,
literal|0xbf597fc7UL
block|,
literal|0xc6e00bf3UL
block|,
literal|0xd5a79147UL
block|,
literal|0x06ca6351UL
block|,
literal|0x14292967UL
block|,
literal|0x27b70a85UL
block|,
literal|0x2e1b2138UL
block|,
literal|0x4d2c6dfcUL
block|,
literal|0x53380d13UL
block|,
literal|0x650a7354UL
block|,
literal|0x766a0abbUL
block|,
literal|0x81c2c92eUL
block|,
literal|0x92722c85UL
block|,
literal|0xa2bfe8a1UL
block|,
literal|0xa81a664bUL
block|,
literal|0xc24b8b70UL
block|,
literal|0xc76c51a3UL
block|,
literal|0xd192e819UL
block|,
literal|0xd6990624UL
block|,
literal|0xf40e3585UL
block|,
literal|0x106aa070UL
block|,
literal|0x19a4c116UL
block|,
literal|0x1e376c08UL
block|,
literal|0x2748774cUL
block|,
literal|0x34b0bcb5UL
block|,
literal|0x391c0cb3UL
block|,
literal|0x4ed8aa4aUL
block|,
literal|0x5b9cca4fUL
block|,
literal|0x682e6ff3UL
block|,
literal|0x748f82eeUL
block|,
literal|0x78a5636fUL
block|,
literal|0x84c87814UL
block|,
literal|0x8cc70208UL
block|,
literal|0x90befffaUL
block|,
literal|0xa4506cebUL
block|,
literal|0xbef9a3f7UL
block|,
literal|0xc67178f2UL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various logical functions */
end_comment

begin_define
define|#
directive|define
name|RORc
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|( ((((unsigned long) (x)& 0xFFFFFFFFUL)>> (unsigned long) ((y)& 31)) | \    ((unsigned long) (x)<< (unsigned long) (32 - ((y)& 31))))& 0xFFFFFFFFUL)
end_define

begin_define
define|#
directive|define
name|Ch
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(z ^ (x& (y ^ z)))
end_define

begin_define
define|#
directive|define
name|Maj
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(((x | y)& z) | (x& y))
end_define

begin_define
define|#
directive|define
name|S
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|RORc((x), (n))
end_define

begin_define
define|#
directive|define
name|R
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(((x)&0xFFFFFFFFUL)>>(n))
end_define

begin_define
define|#
directive|define
name|Sigma0
parameter_list|(
name|x
parameter_list|)
value|(S(x, 2) ^ S(x, 13) ^ S(x, 22))
end_define

begin_define
define|#
directive|define
name|Sigma1
parameter_list|(
name|x
parameter_list|)
value|(S(x, 6) ^ S(x, 11) ^ S(x, 25))
end_define

begin_define
define|#
directive|define
name|Gamma0
parameter_list|(
name|x
parameter_list|)
value|(S(x, 7) ^ S(x, 18) ^ R(x, 3))
end_define

begin_define
define|#
directive|define
name|Gamma1
parameter_list|(
name|x
parameter_list|)
value|(S(x, 17) ^ S(x, 19) ^ R(x, 10))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)< (y)) ? (x) : (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* compress 512-bits */
end_comment

begin_function
specifier|static
name|int
name|sha256_compress
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|u32
name|S
index|[
literal|8
index|]
decl_stmt|,
name|W
index|[
literal|64
index|]
decl_stmt|,
name|t0
decl_stmt|,
name|t1
decl_stmt|;
name|u32
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* copy state into S */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|S
index|[
name|i
index|]
operator|=
name|md
operator|->
name|state
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* copy the state into 512-bits into W[0..15] */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|W
index|[
name|i
index|]
operator|=
name|WPA_GET_BE32
argument_list|(
name|buf
operator|+
operator|(
literal|4
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* fill W[16..63] */
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|W
index|[
name|i
index|]
operator|=
name|Gamma1
argument_list|(
name|W
index|[
name|i
operator|-
literal|2
index|]
argument_list|)
operator|+
name|W
index|[
name|i
operator|-
literal|7
index|]
operator|+
name|Gamma0
argument_list|(
name|W
index|[
name|i
operator|-
literal|15
index|]
argument_list|)
operator|+
name|W
index|[
name|i
operator|-
literal|16
index|]
expr_stmt|;
block|}
comment|/* Compress */
define|#
directive|define
name|RND
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|,
name|h
parameter_list|,
name|i
parameter_list|)
define|\
value|t0 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];	\ 	t1 = Sigma0(a) + Maj(a, b, c);			\ 	d += t0;					\ 	h  = t0 + t1;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
operator|++
name|i
control|)
block|{
name|RND
argument_list|(
name|S
index|[
literal|0
index|]
argument_list|,
name|S
index|[
literal|1
index|]
argument_list|,
name|S
index|[
literal|2
index|]
argument_list|,
name|S
index|[
literal|3
index|]
argument_list|,
name|S
index|[
literal|4
index|]
argument_list|,
name|S
index|[
literal|5
index|]
argument_list|,
name|S
index|[
literal|6
index|]
argument_list|,
name|S
index|[
literal|7
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
name|S
index|[
literal|7
index|]
expr_stmt|;
name|S
index|[
literal|7
index|]
operator|=
name|S
index|[
literal|6
index|]
expr_stmt|;
name|S
index|[
literal|6
index|]
operator|=
name|S
index|[
literal|5
index|]
expr_stmt|;
name|S
index|[
literal|5
index|]
operator|=
name|S
index|[
literal|4
index|]
expr_stmt|;
name|S
index|[
literal|4
index|]
operator|=
name|S
index|[
literal|3
index|]
expr_stmt|;
name|S
index|[
literal|3
index|]
operator|=
name|S
index|[
literal|2
index|]
expr_stmt|;
name|S
index|[
literal|2
index|]
operator|=
name|S
index|[
literal|1
index|]
expr_stmt|;
name|S
index|[
literal|1
index|]
operator|=
name|S
index|[
literal|0
index|]
expr_stmt|;
name|S
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
block|}
comment|/* feedback */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|->
name|state
index|[
name|i
index|]
operator|=
name|md
operator|->
name|state
index|[
name|i
index|]
operator|+
name|S
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Initialize the hash state */
end_comment

begin_function
name|void
name|sha256_init
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|)
block|{
name|md
operator|->
name|curlen
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|0
index|]
operator|=
literal|0x6A09E667UL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|1
index|]
operator|=
literal|0xBB67AE85UL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|2
index|]
operator|=
literal|0x3C6EF372UL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|3
index|]
operator|=
literal|0xA54FF53AUL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|4
index|]
operator|=
literal|0x510E527FUL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|5
index|]
operator|=
literal|0x9B05688CUL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|6
index|]
operator|=
literal|0x1F83D9ABUL
expr_stmt|;
name|md
operator|->
name|state
index|[
literal|7
index|]
operator|=
literal|0x5BE0CD19UL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    Process a block of memory though the hash    @param md     The hash state    @param in     The data to hash    @param inlen  The length of the data (octets)    @return CRYPT_OK if successful */
end_comment

begin_function
name|int
name|sha256_process
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|long
name|inlen
parameter_list|)
block|{
name|unsigned
name|long
name|n
decl_stmt|;
if|if
condition|(
name|md
operator|->
name|curlen
operator|>=
sizeof|sizeof
argument_list|(
name|md
operator|->
name|buf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|inlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|->
name|curlen
operator|==
literal|0
operator|&&
name|inlen
operator|>=
name|SHA256_BLOCK_SIZE
condition|)
block|{
if|if
condition|(
name|sha256_compress
argument_list|(
name|md
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|md
operator|->
name|length
operator|+=
name|SHA256_BLOCK_SIZE
operator|*
literal|8
expr_stmt|;
name|in
operator|+=
name|SHA256_BLOCK_SIZE
expr_stmt|;
name|inlen
operator|-=
name|SHA256_BLOCK_SIZE
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|MIN
argument_list|(
name|inlen
argument_list|,
operator|(
name|SHA256_BLOCK_SIZE
operator|-
name|md
operator|->
name|curlen
operator|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|md
operator|->
name|buf
operator|+
name|md
operator|->
name|curlen
argument_list|,
name|in
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|md
operator|->
name|curlen
operator|+=
name|n
expr_stmt|;
name|in
operator|+=
name|n
expr_stmt|;
name|inlen
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|curlen
operator|==
name|SHA256_BLOCK_SIZE
condition|)
block|{
if|if
condition|(
name|sha256_compress
argument_list|(
name|md
argument_list|,
name|md
operator|->
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|md
operator|->
name|length
operator|+=
literal|8
operator|*
name|SHA256_BLOCK_SIZE
expr_stmt|;
name|md
operator|->
name|curlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**    Terminate the hash to get the digest    @param md  The hash state    @param out [out] The destination of the hash (32 bytes)    @return CRYPT_OK if successful */
end_comment

begin_function
name|int
name|sha256_done
parameter_list|(
name|struct
name|sha256_state
modifier|*
name|md
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|md
operator|->
name|curlen
operator|>=
sizeof|sizeof
argument_list|(
name|md
operator|->
name|buf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* increase the length of the message */
name|md
operator|->
name|length
operator|+=
name|md
operator|->
name|curlen
operator|*
literal|8
expr_stmt|;
comment|/* append the '1' bit */
name|md
operator|->
name|buf
index|[
name|md
operator|->
name|curlen
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|0x80
expr_stmt|;
comment|/* if the length is currently above 56 bytes we append zeros 	 * then compress.  Then we can fall back to padding zeros and length 	 * encoding like normal. 	 */
if|if
condition|(
name|md
operator|->
name|curlen
operator|>
literal|56
condition|)
block|{
while|while
condition|(
name|md
operator|->
name|curlen
operator|<
name|SHA256_BLOCK_SIZE
condition|)
block|{
name|md
operator|->
name|buf
index|[
name|md
operator|->
name|curlen
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|0
expr_stmt|;
block|}
name|sha256_compress
argument_list|(
name|md
argument_list|,
name|md
operator|->
name|buf
argument_list|)
expr_stmt|;
name|md
operator|->
name|curlen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* pad up to 56 bytes of zeroes */
while|while
condition|(
name|md
operator|->
name|curlen
operator|<
literal|56
condition|)
block|{
name|md
operator|->
name|buf
index|[
name|md
operator|->
name|curlen
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|0
expr_stmt|;
block|}
comment|/* store length */
name|WPA_PUT_BE64
argument_list|(
name|md
operator|->
name|buf
operator|+
literal|56
argument_list|,
name|md
operator|->
name|length
argument_list|)
expr_stmt|;
name|sha256_compress
argument_list|(
name|md
argument_list|,
name|md
operator|->
name|buf
argument_list|)
expr_stmt|;
comment|/* copy output */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|WPA_PUT_BE32
argument_list|(
name|out
operator|+
operator|(
literal|4
operator|*
name|i
operator|)
argument_list|,
name|md
operator|->
name|state
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ===== end - public domain SHA256 implementation ===== */
end_comment

end_unit

