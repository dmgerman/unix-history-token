begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * One-key CBC MAC (OMAC1) hash with AES  *  * Copyright (c) 2003-2007, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"aes.h"
end_include

begin_include
include|#
directive|include
file|"aes_wrap.h"
end_include

begin_function
specifier|static
name|void
name|gf_mulx
parameter_list|(
name|u8
modifier|*
name|pad
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|carry
decl_stmt|;
name|carry
operator|=
name|pad
index|[
literal|0
index|]
operator|&
literal|0x80
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AES_BLOCK_SIZE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|pad
index|[
name|i
index|]
operator|=
operator|(
name|pad
index|[
name|i
index|]
operator|<<
literal|1
operator|)
operator||
operator|(
name|pad
index|[
name|i
operator|+
literal|1
index|]
operator|>>
literal|7
operator|)
expr_stmt|;
name|pad
index|[
name|AES_BLOCK_SIZE
operator|-
literal|1
index|]
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|carry
condition|)
name|pad
index|[
name|AES_BLOCK_SIZE
operator|-
literal|1
index|]
operator|^=
literal|0x87
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * omac1_aes_vector - One-Key CBC MAC (OMAC1) hash with AES  * @key: Key for the hash operation  * @key_len: Key length in octets  * @num_elem: Number of elements in the data vector  * @addr: Pointers to the data areas  * @len: Lengths of the data blocks  * @mac: Buffer for MAC (128 bits, i.e., 16 bytes)  * Returns: 0 on success, -1 on failure  *  * This is a mode for using block cipher (AES in this case) for authentication.  * OMAC1 was standardized with the name CMAC by NIST in a Special Publication  * (SP) 800-38B.  */
end_comment

begin_function
name|int
name|omac1_aes_vector
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|key_len
parameter_list|,
name|size_t
name|num_elem
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
index|[]
parameter_list|,
specifier|const
name|size_t
modifier|*
name|len
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|)
block|{
name|void
modifier|*
name|ctx
decl_stmt|;
name|u8
name|cbc
index|[
name|AES_BLOCK_SIZE
index|]
decl_stmt|,
name|pad
index|[
name|AES_BLOCK_SIZE
index|]
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|e
decl_stmt|,
name|left
decl_stmt|,
name|total_len
decl_stmt|;
name|ctx
operator|=
name|aes_encrypt_init
argument_list|(
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|os_memset
argument_list|(
name|cbc
argument_list|,
literal|0
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|total_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
literal|0
init|;
name|e
operator|<
name|num_elem
condition|;
name|e
operator|++
control|)
name|total_len
operator|+=
name|len
index|[
name|e
index|]
expr_stmt|;
name|left
operator|=
name|total_len
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|len
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|left
operator|>=
name|AES_BLOCK_SIZE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AES_BLOCK_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|cbc
index|[
name|i
index|]
operator|^=
operator|*
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
block|{
comment|/* 				 * Stop if there are no more bytes to process 				 * since there are no more entries in the array. 				 */
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|AES_BLOCK_SIZE
operator|&&
name|left
operator|==
name|AES_BLOCK_SIZE
condition|)
break|break;
name|e
operator|++
expr_stmt|;
name|pos
operator|=
name|addr
index|[
name|e
index|]
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|len
index|[
name|e
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|left
operator|>
name|AES_BLOCK_SIZE
condition|)
name|aes_encrypt
argument_list|(
name|ctx
argument_list|,
name|cbc
argument_list|,
name|cbc
argument_list|)
expr_stmt|;
name|left
operator|-=
name|AES_BLOCK_SIZE
expr_stmt|;
block|}
name|os_memset
argument_list|(
name|pad
argument_list|,
literal|0
argument_list|,
name|AES_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|aes_encrypt
argument_list|(
name|ctx
argument_list|,
name|pad
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|gf_mulx
argument_list|(
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|||
name|total_len
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|left
condition|;
name|i
operator|++
control|)
block|{
name|cbc
index|[
name|i
index|]
operator|^=
operator|*
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
block|{
comment|/* 				 * Stop if there are no more bytes to process 				 * since there are no more entries in the array. 				 */
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|left
condition|)
break|break;
name|e
operator|++
expr_stmt|;
name|pos
operator|=
name|addr
index|[
name|e
index|]
expr_stmt|;
name|end
operator|=
name|pos
operator|+
name|len
index|[
name|e
index|]
expr_stmt|;
block|}
block|}
name|cbc
index|[
name|left
index|]
operator|^=
literal|0x80
expr_stmt|;
name|gf_mulx
argument_list|(
name|pad
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AES_BLOCK_SIZE
condition|;
name|i
operator|++
control|)
name|pad
index|[
name|i
index|]
operator|^=
name|cbc
index|[
name|i
index|]
expr_stmt|;
name|aes_encrypt
argument_list|(
name|ctx
argument_list|,
name|pad
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|aes_encrypt_deinit
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * omac1_aes_128_vector - One-Key CBC MAC (OMAC1) hash with AES-128  * @key: 128-bit key for the hash operation  * @num_elem: Number of elements in the data vector  * @addr: Pointers to the data areas  * @len: Lengths of the data blocks  * @mac: Buffer for MAC (128 bits, i.e., 16 bytes)  * Returns: 0 on success, -1 on failure  *  * This is a mode for using block cipher (AES in this case) for authentication.  * OMAC1 was standardized with the name CMAC by NIST in a Special Publication  * (SP) 800-38B.  */
end_comment

begin_function
name|int
name|omac1_aes_128_vector
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|size_t
name|num_elem
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
index|[]
parameter_list|,
specifier|const
name|size_t
modifier|*
name|len
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|)
block|{
return|return
name|omac1_aes_vector
argument_list|(
name|key
argument_list|,
literal|16
argument_list|,
name|num_elem
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|mac
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * omac1_aes_128 - One-Key CBC MAC (OMAC1) hash with AES-128 (aka AES-CMAC)  * @key: 128-bit key for the hash operation  * @data: Data buffer for which a MAC is determined  * @data_len: Length of data buffer in bytes  * @mac: Buffer for MAC (128 bits, i.e., 16 bytes)  * Returns: 0 on success, -1 on failure  *  * This is a mode for using block cipher (AES in this case) for authentication.  * OMAC1 was standardized with the name CMAC by NIST in a Special Publication  * (SP) 800-38B.  */
end_comment

begin_function
name|int
name|omac1_aes_128
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|data_len
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|)
block|{
return|return
name|omac1_aes_128_vector
argument_list|(
name|key
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|data_len
argument_list|,
name|mac
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * omac1_aes_256 - One-Key CBC MAC (OMAC1) hash with AES-256 (aka AES-CMAC)  * @key: 256-bit key for the hash operation  * @data: Data buffer for which a MAC is determined  * @data_len: Length of data buffer in bytes  * @mac: Buffer for MAC (128 bits, i.e., 16 bytes)  * Returns: 0 on success, -1 on failure  *  * This is a mode for using block cipher (AES in this case) for authentication.  * OMAC1 was standardized with the name CMAC by NIST in a Special Publication  * (SP) 800-38B.  */
end_comment

begin_function
name|int
name|omac1_aes_256
parameter_list|(
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|data_len
parameter_list|,
name|u8
modifier|*
name|mac
parameter_list|)
block|{
return|return
name|omac1_aes_vector
argument_list|(
name|key
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|data_len
argument_list|,
name|mac
argument_list|)
return|;
block|}
end_function

end_unit

