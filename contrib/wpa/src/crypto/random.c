begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Random number generator  * Copyright (c) 2010-2011, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  *  * This random number generator is used to provide additional entropy to the  * one provided by the operating system (os_get_random()) for session key  * generation. The os_get_random() output is expected to be secure and the  * implementation here is expected to provide only limited protection against  * cases where os_get_random() cannot provide strong randomness. This  * implementation shall not be assumed to be secure as the sole source of  * randomness. The random_get_bytes() function mixes in randomness from  * os_get_random() and as such, calls to os_get_random() can be replaced with  * calls to random_get_bytes() without reducing security.  *  * The design here follows partially the design used in the Linux  * drivers/char/random.c, but the implementation here is simpler and not as  * strong. This is a compromise to reduce duplicated CPU effort and to avoid  * extra code/memory size. As pointed out above, os_get_random() needs to be  * guaranteed to be secure for any of the security assumptions to hold.  */
end_comment

begin_include
include|#
directive|include
file|"utils/includes.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_include
include|#
directive|include
file|"utils/common.h"
end_include

begin_include
include|#
directive|include
file|"utils/eloop.h"
end_include

begin_include
include|#
directive|include
file|"crypto/crypto.h"
end_include

begin_include
include|#
directive|include
file|"sha1.h"
end_include

begin_include
include|#
directive|include
file|"random.h"
end_include

begin_define
define|#
directive|define
name|POOL_WORDS
value|32
end_define

begin_define
define|#
directive|define
name|POOL_WORDS_MASK
value|(POOL_WORDS - 1)
end_define

begin_define
define|#
directive|define
name|POOL_TAP1
value|26
end_define

begin_define
define|#
directive|define
name|POOL_TAP2
value|20
end_define

begin_define
define|#
directive|define
name|POOL_TAP3
value|14
end_define

begin_define
define|#
directive|define
name|POOL_TAP4
value|7
end_define

begin_define
define|#
directive|define
name|POOL_TAP5
value|1
end_define

begin_define
define|#
directive|define
name|EXTRACT_LEN
value|16
end_define

begin_define
define|#
directive|define
name|MIN_READY_MARK
value|2
end_define

begin_decl_stmt
specifier|static
name|u32
name|pool
index|[
name|POOL_WORDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|input_rotate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|pool_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u8
name|dummy_key
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_decl_stmt
specifier|static
name|size_t
name|dummy_key_avail
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|random_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|own_pool_ready
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RANDOM_ENTROPY_SIZE
value|20
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|random_entropy_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|random_entropy_file_read
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIN_COLLECT_ENTROPY
value|1000
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|entropy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|total_collected
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|random_write_entropy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|u32
name|__ROL32
parameter_list|(
name|u32
name|x
parameter_list|,
name|u32
name|y
parameter_list|)
block|{
return|return
operator|(
name|x
operator|<<
operator|(
name|y
operator|&
literal|31
operator|)
operator|)
operator||
operator|(
name|x
operator|>>
operator|(
literal|32
operator|-
operator|(
name|y
operator|&
literal|31
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|random_mix_pool
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|static
specifier|const
name|u32
name|twist
index|[
literal|8
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x3b6e20c8
block|,
literal|0x76dc4190
block|,
literal|0x4db26158
block|,
literal|0xedb88320
block|,
literal|0xd6d6a3e8
block|,
literal|0x9b64c2b0
block|,
literal|0xa00ae278
block|}
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
init|=
name|buf
decl_stmt|;
name|u32
name|w
decl_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"random_mix_pool"
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|w
operator|=
name|__ROL32
argument_list|(
operator|*
name|pos
operator|++
argument_list|,
name|input_rotate
operator|&
literal|31
argument_list|)
expr_stmt|;
name|input_rotate
operator|+=
name|pool_pos
condition|?
literal|7
else|:
literal|14
expr_stmt|;
name|pool_pos
operator|=
operator|(
name|pool_pos
operator|-
literal|1
operator|)
operator|&
name|POOL_WORDS_MASK
expr_stmt|;
name|w
operator|^=
name|pool
index|[
name|pool_pos
index|]
expr_stmt|;
name|w
operator|^=
name|pool
index|[
operator|(
name|pool_pos
operator|+
name|POOL_TAP1
operator|)
operator|&
name|POOL_WORDS_MASK
index|]
expr_stmt|;
name|w
operator|^=
name|pool
index|[
operator|(
name|pool_pos
operator|+
name|POOL_TAP2
operator|)
operator|&
name|POOL_WORDS_MASK
index|]
expr_stmt|;
name|w
operator|^=
name|pool
index|[
operator|(
name|pool_pos
operator|+
name|POOL_TAP3
operator|)
operator|&
name|POOL_WORDS_MASK
index|]
expr_stmt|;
name|w
operator|^=
name|pool
index|[
operator|(
name|pool_pos
operator|+
name|POOL_TAP4
operator|)
operator|&
name|POOL_WORDS_MASK
index|]
expr_stmt|;
name|w
operator|^=
name|pool
index|[
operator|(
name|pool_pos
operator|+
name|POOL_TAP5
operator|)
operator|&
name|POOL_WORDS_MASK
index|]
expr_stmt|;
name|pool
index|[
name|pool_pos
index|]
operator|=
operator|(
name|w
operator|>>
literal|3
operator|)
operator|^
name|twist
index|[
name|w
operator|&
literal|7
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|random_extract
parameter_list|(
name|u8
modifier|*
name|out
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|u8
name|hash
index|[
name|SHA1_MAC_LEN
index|]
decl_stmt|;
name|u32
modifier|*
name|hash_ptr
decl_stmt|;
name|u32
name|buf
index|[
name|POOL_WORDS
operator|/
literal|2
index|]
decl_stmt|;
comment|/* First, add hash back to pool to make backtracking more difficult. */
name|hmac_sha1
argument_list|(
name|dummy_key
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|)
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|random_mix_pool
argument_list|(
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Hash half the pool to extra data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|POOL_WORDS
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|pool
index|[
operator|(
name|pool_pos
operator|-
name|i
operator|)
operator|&
name|POOL_WORDS_MASK
index|]
expr_stmt|;
name|hmac_sha1
argument_list|(
name|dummy_key
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|hash
argument_list|)
expr_stmt|;
comment|/* 	 * Fold the hash to further reduce any potential output pattern. 	 * Though, compromise this to reduce CPU use for the most common output 	 * length (32) and return 16 bytes from instead of only half. 	 */
name|hash_ptr
operator|=
operator|(
name|u32
operator|*
operator|)
name|hash
expr_stmt|;
name|hash_ptr
index|[
literal|0
index|]
operator|^=
name|hash_ptr
index|[
literal|4
index|]
expr_stmt|;
name|os_memcpy
argument_list|(
name|out
argument_list|,
name|hash
argument_list|,
name|EXTRACT_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|random_add_randomness
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|os_time
name|t
decl_stmt|;
specifier|static
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|entropy
operator|>
name|MIN_COLLECT_ENTROPY
operator|&&
operator|(
name|count
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * No need to add more entropy at this point, so save CPU and 		 * skip the update. 		 */
return|return;
block|}
name|wpa_printf
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"Add randomness: count=%u entropy=%u"
argument_list|,
name|count
argument_list|,
name|entropy
argument_list|)
expr_stmt|;
name|os_get_time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"random pool"
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|)
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|random_mix_pool
argument_list|(
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|random_mix_pool
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"random pool"
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|)
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|entropy
operator|++
expr_stmt|;
name|total_collected
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|random_get_bytes
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u8
modifier|*
name|bytes
init|=
name|buf
decl_stmt|;
name|size_t
name|left
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"Get randomness: len=%u entropy=%u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|,
name|entropy
argument_list|)
expr_stmt|;
comment|/* Start with assumed strong randomness from OS */
name|ret
operator|=
name|os_get_random
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"random from os_get_random"
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Mix in additional entropy extracted from the internal pool */
name|left
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|left
condition|)
block|{
name|size_t
name|siz
decl_stmt|,
name|i
decl_stmt|;
name|u8
name|tmp
index|[
name|EXTRACT_LEN
index|]
decl_stmt|;
name|random_extract
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"random from internal pool"
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|siz
operator|=
name|left
operator|>
name|EXTRACT_LEN
condition|?
name|EXTRACT_LEN
else|:
name|left
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|siz
condition|;
name|i
operator|++
control|)
operator|*
name|bytes
operator|++
operator|^=
name|tmp
index|[
name|i
index|]
expr_stmt|;
name|left
operator|-=
name|siz
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_FIPS
comment|/* Mix in additional entropy from the crypto module */
name|left
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|left
condition|)
block|{
name|size_t
name|siz
decl_stmt|,
name|i
decl_stmt|;
name|u8
name|tmp
index|[
name|EXTRACT_LEN
index|]
decl_stmt|;
if|if
condition|(
name|crypto_get_random
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"random: No entropy available "
literal|"for generating strong random bytes"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_hexdump_key
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"random from crypto module"
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|siz
operator|=
name|left
operator|>
name|EXTRACT_LEN
condition|?
name|EXTRACT_LEN
else|:
name|left
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|siz
condition|;
name|i
operator|++
control|)
operator|*
name|bytes
operator|++
operator|^=
name|tmp
index|[
name|i
index|]
expr_stmt|;
name|left
operator|-=
name|siz
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CONFIG_FIPS */
name|wpa_hexdump_key
argument_list|(
name|MSG_EXCESSIVE
argument_list|,
literal|"mixed random"
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|entropy
operator|<
name|len
condition|)
name|entropy
operator|=
literal|0
expr_stmt|;
else|else
name|entropy
operator|-=
name|len
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|random_pool_ready
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__linux__
name|int
name|fd
decl_stmt|;
name|ssize_t
name|res
decl_stmt|;
comment|/* 	 * Make sure that there is reasonable entropy available before allowing 	 * some key derivation operations to proceed. 	 */
if|if
condition|(
name|dummy_key_avail
operator|==
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Already initialized - good to continue */
comment|/* 	 * Try to fetch some more data from the kernel high quality 	 * /dev/random. There may not be enough data available at this point, 	 * so use non-blocking read to avoid blocking the application 	 * completely. 	 */
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/random"
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|CONFIG_NO_STDOUT_DEBUG
name|int
name|error
init|=
name|errno
decl_stmt|;
name|perror
argument_list|(
literal|"open(/dev/random)"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"random: Cannot open /dev/random: %s"
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_NO_STDOUT_DEBUG */
return|return
operator|-
literal|1
return|;
block|}
name|res
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|dummy_key
operator|+
name|dummy_key_avail
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
operator|-
name|dummy_key_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"random: Cannot read from /dev/random: "
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"random: Got %u/%u bytes from "
literal|"/dev/random"
argument_list|,
operator|(
name|unsigned
operator|)
name|res
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
operator|-
name|dummy_key_avail
argument_list|)
argument_list|)
expr_stmt|;
name|dummy_key_avail
operator|+=
name|res
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_key_avail
operator|==
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
condition|)
block|{
if|if
condition|(
name|own_pool_ready
operator|<
name|MIN_READY_MARK
condition|)
name|own_pool_ready
operator|=
name|MIN_READY_MARK
expr_stmt|;
name|random_write_entropy
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"random: Only %u/%u bytes of strong "
literal|"random data available from /dev/random"
argument_list|,
operator|(
name|unsigned
operator|)
name|dummy_key_avail
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|own_pool_ready
operator|>=
name|MIN_READY_MARK
operator|||
name|total_collected
operator|+
literal|10
operator|*
name|own_pool_ready
operator|>
name|MIN_COLLECT_ENTROPY
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"random: Allow operation to proceed "
literal|"based on internal entropy"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"random: Not enough entropy pool available for "
literal|"secure operations"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
comment|/* __linux__ */
comment|/* TODO: could do similar checks on non-Linux platforms */
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* __linux__ */
block|}
end_function

begin_function
name|void
name|random_mark_pool_ready
parameter_list|(
name|void
parameter_list|)
block|{
name|own_pool_ready
operator|++
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"random: Mark internal entropy pool to be "
literal|"ready (count=%u/%u)"
argument_list|,
name|own_pool_ready
argument_list|,
name|MIN_READY_MARK
argument_list|)
expr_stmt|;
name|random_write_entropy
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_function
specifier|static
name|void
name|random_close_fd
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|random_fd
operator|>=
literal|0
condition|)
block|{
name|eloop_unregister_read_sock
argument_list|(
name|random_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|random_fd
argument_list|)
expr_stmt|;
name|random_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|random_read_fd
parameter_list|(
name|int
name|sock
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|ssize_t
name|res
decl_stmt|;
if|if
condition|(
name|dummy_key_avail
operator|==
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
condition|)
block|{
name|random_close_fd
argument_list|()
expr_stmt|;
return|return;
block|}
name|res
operator|=
name|read
argument_list|(
name|sock
argument_list|,
name|dummy_key
operator|+
name|dummy_key_avail
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
operator|-
name|dummy_key_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"random: Cannot read from /dev/random: "
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"random: Got %u/%u bytes from /dev/random"
argument_list|,
operator|(
name|unsigned
operator|)
name|res
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
operator|-
name|dummy_key_avail
argument_list|)
argument_list|)
expr_stmt|;
name|dummy_key_avail
operator|+=
name|res
expr_stmt|;
if|if
condition|(
name|dummy_key_avail
operator|==
sizeof|sizeof
argument_list|(
name|dummy_key
argument_list|)
condition|)
block|{
name|random_close_fd
argument_list|()
expr_stmt|;
if|if
condition|(
name|own_pool_ready
operator|<
name|MIN_READY_MARK
condition|)
name|own_pool_ready
operator|=
name|MIN_READY_MARK
expr_stmt|;
name|random_write_entropy
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_function
specifier|static
name|void
name|random_read_entropy
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|random_entropy_file
condition|)
return|return;
name|buf
operator|=
name|os_readfile
argument_list|(
name|random_entropy_file
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
comment|/* entropy file not yet available */
if|if
condition|(
name|len
operator|!=
literal|1
operator|+
name|RANDOM_ENTROPY_SIZE
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"random: Invalid entropy file %s"
argument_list|,
name|random_entropy_file
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|own_pool_ready
operator|=
operator|(
name|u8
operator|)
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|random_add_randomness
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|RANDOM_ENTROPY_SIZE
argument_list|)
expr_stmt|;
name|random_entropy_file_read
operator|=
literal|1
expr_stmt|;
name|os_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"random: Added entropy from %s "
literal|"(own_pool_ready=%u)"
argument_list|,
name|random_entropy_file
argument_list|,
name|own_pool_ready
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|random_write_entropy
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
name|RANDOM_ENTROPY_SIZE
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|u8
name|opr
decl_stmt|;
name|int
name|fail
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|random_entropy_file
condition|)
return|return;
if|if
condition|(
name|random_get_bytes
argument_list|(
name|buf
argument_list|,
name|RANDOM_ENTROPY_SIZE
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|f
operator|=
name|fopen
argument_list|(
name|random_entropy_file
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"random: Could not open entropy file %s "
literal|"for writing"
argument_list|,
name|random_entropy_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|opr
operator|=
name|own_pool_ready
operator|>
literal|0xff
condition|?
literal|0xff
else|:
name|own_pool_ready
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|opr
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
name|buf
argument_list|,
name|RANDOM_ENTROPY_SIZE
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"random: Could not write entropy data "
literal|"to %s"
argument_list|,
name|random_entropy_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"random: Updated entropy file %s "
literal|"(own_pool_ready=%u)"
argument_list|,
name|random_entropy_file
argument_list|,
name|own_pool_ready
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|random_init
parameter_list|(
specifier|const
name|char
modifier|*
name|entropy_file
parameter_list|)
block|{
name|os_free
argument_list|(
name|random_entropy_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|entropy_file
condition|)
name|random_entropy_file
operator|=
name|os_strdup
argument_list|(
name|entropy_file
argument_list|)
expr_stmt|;
else|else
name|random_entropy_file
operator|=
name|NULL
expr_stmt|;
name|random_read_entropy
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
if|if
condition|(
name|random_fd
operator|>=
literal|0
condition|)
return|return;
name|random_fd
operator|=
name|open
argument_list|(
literal|"/dev/random"
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|random_fd
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|CONFIG_NO_STDOUT_DEBUG
name|int
name|error
init|=
name|errno
decl_stmt|;
name|perror
argument_list|(
literal|"open(/dev/random)"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"random: Cannot open /dev/random: %s"
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_NO_STDOUT_DEBUG */
return|return;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"random: Trying to read entropy from "
literal|"/dev/random"
argument_list|)
expr_stmt|;
name|eloop_register_read_sock
argument_list|(
name|random_fd
argument_list|,
name|random_read_fd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __linux__ */
name|random_write_entropy
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|random_deinit
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__linux__
name|random_close_fd
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* __linux__ */
name|random_write_entropy
argument_list|()
expr_stmt|;
name|os_free
argument_list|(
name|random_entropy_file
argument_list|)
expr_stmt|;
name|random_entropy_file
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

