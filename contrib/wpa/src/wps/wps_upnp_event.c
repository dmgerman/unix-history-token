begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * UPnP WPS Device - Event processing  * Copyright (c) 2000-2003 Intel Corporation  * Copyright (c) 2006-2007 Sony Corporation  * Copyright (c) 2008-2009 Atheros Communications  * Copyright (c) 2009, Jouni Malinen<j@w1.fi>  *  * See wps_upnp.c for more details on licensing and code history.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"uuid.h"
end_include

begin_include
include|#
directive|include
file|"httpread.h"
end_include

begin_include
include|#
directive|include
file|"wps_defs.h"
end_include

begin_include
include|#
directive|include
file|"wps_upnp.h"
end_include

begin_include
include|#
directive|include
file|"wps_upnp_i.h"
end_include

begin_comment
comment|/*  * Event message generation (to subscribers)  *  * We make a separate copy for each message for each subscriber. This memory  * wasted could be limited (adding code complexity) by sharing copies, keeping  * a usage count and freeing when zero.  *  * Sending a message requires using a HTTP over TCP NOTIFY  * (like a PUT) which requires a number of states..  */
end_comment

begin_define
define|#
directive|define
name|MAX_EVENTS_QUEUED
value|20
end_define

begin_comment
comment|/* How far behind queued events */
end_comment

begin_define
define|#
directive|define
name|EVENT_TIMEOUT_SEC
value|30
end_define

begin_comment
comment|/* Drop sending event after timeout */
end_comment

begin_comment
comment|/* How long to wait before sending event */
end_comment

begin_define
define|#
directive|define
name|EVENT_DELAY_SECONDS
value|0
end_define

begin_define
define|#
directive|define
name|EVENT_DELAY_MSEC
value|0
end_define

begin_comment
comment|/*  * Event information that we send to each subscriber is remembered in this  * struct. The event cannot be sent by simple UDP; it has to be sent by a HTTP  * over TCP transaction which requires various states.. It may also need to be  * retried at a different address (if more than one is available).  *  * TODO: As an optimization we could share data between subscribers.  */
end_comment

begin_struct
struct|struct
name|wps_event_
block|{
name|struct
name|wps_event_
modifier|*
name|next
decl_stmt|;
name|struct
name|wps_event_
modifier|*
name|prev
decl_stmt|;
comment|/* double linked list */
name|struct
name|subscription
modifier|*
name|s
decl_stmt|;
comment|/* parent */
name|unsigned
name|subscriber_sequence
decl_stmt|;
comment|/* which event for this subscription*/
name|int
name|retry
decl_stmt|;
comment|/* which retry */
name|struct
name|subscr_addr
modifier|*
name|addr
decl_stmt|;
comment|/* address to connect to */
name|struct
name|wpabuf
modifier|*
name|data
decl_stmt|;
comment|/* event data to send */
comment|/* The following apply while we are sending an event message. */
name|int
name|sd
decl_stmt|;
comment|/* -1 or socket descriptor for open connection */
name|int
name|sd_registered
decl_stmt|;
comment|/* nonzero if we must cancel registration */
name|struct
name|httpread
modifier|*
name|hread
decl_stmt|;
comment|/* NULL or open connection for event msg */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|event_timeout_handler
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* event_clean -- clean sockets etc. of event  * Leaves data, retry count etc. alone.  */
end_comment

begin_function
specifier|static
name|void
name|event_clean
parameter_list|(
name|struct
name|wps_event_
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|s
operator|->
name|current_event
operator|==
name|e
condition|)
block|{
name|eloop_cancel_timeout
argument_list|(
name|event_timeout_handler
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|s
operator|->
name|current_event
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|sd_registered
condition|)
block|{
name|eloop_unregister_sock
argument_list|(
name|e
operator|->
name|sd
argument_list|,
name|EVENT_TYPE_WRITE
argument_list|)
expr_stmt|;
name|e
operator|->
name|sd_registered
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|sd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|e
operator|->
name|sd
argument_list|)
expr_stmt|;
name|e
operator|->
name|sd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|hread
condition|)
name|httpread_destroy
argument_list|(
name|e
operator|->
name|hread
argument_list|)
expr_stmt|;
name|e
operator|->
name|hread
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_delete -- delete single unqueued event  * (be sure to dequeue first if need be)  */
end_comment

begin_function
specifier|static
name|void
name|event_delete
parameter_list|(
name|struct
name|wps_event_
modifier|*
name|e
parameter_list|)
block|{
name|event_clean
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_dequeue -- get next event from the queue  * Returns NULL if empty.  */
end_comment

begin_function
specifier|static
name|struct
name|wps_event_
modifier|*
name|event_dequeue
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
modifier|*
name|event_head
init|=
operator|&
name|s
operator|->
name|event_queue
decl_stmt|;
name|struct
name|wps_event_
modifier|*
name|e
init|=
operator|*
name|event_head
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|e
operator|->
name|next
operator|->
name|prev
operator|=
name|e
operator|->
name|prev
expr_stmt|;
name|e
operator|->
name|prev
operator|->
name|next
operator|=
name|e
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|event_head
operator|==
name|e
condition|)
block|{
if|if
condition|(
name|e
operator|==
name|e
operator|->
name|next
condition|)
block|{
comment|/* last in queue */
operator|*
name|event_head
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|event_head
operator|=
name|e
operator|->
name|next
expr_stmt|;
block|}
block|}
name|s
operator|->
name|n_queue
operator|--
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|e
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* but parent "s" is still valid */
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* event_enqueue_at_end -- add event to end of queue */
end_comment

begin_function
specifier|static
name|void
name|event_enqueue_at_end
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|,
name|struct
name|wps_event_
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
modifier|*
name|event_head
init|=
operator|&
name|s
operator|->
name|event_queue
decl_stmt|;
if|if
condition|(
operator|*
name|event_head
operator|==
name|NULL
condition|)
block|{
operator|*
name|event_head
operator|=
name|e
operator|->
name|next
operator|=
name|e
operator|->
name|prev
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|next
operator|=
operator|*
name|event_head
expr_stmt|;
name|e
operator|->
name|prev
operator|=
name|e
operator|->
name|next
operator|->
name|prev
expr_stmt|;
name|e
operator|->
name|prev
operator|->
name|next
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|next
operator|->
name|prev
operator|=
name|e
expr_stmt|;
block|}
name|s
operator|->
name|n_queue
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_enqueue_at_begin -- add event to begin of queue  * (appropriate for retrying event only)  */
end_comment

begin_function
specifier|static
name|void
name|event_enqueue_at_begin
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|,
name|struct
name|wps_event_
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
modifier|*
name|event_head
init|=
operator|&
name|s
operator|->
name|event_queue
decl_stmt|;
if|if
condition|(
operator|*
name|event_head
operator|==
name|NULL
condition|)
block|{
operator|*
name|event_head
operator|=
name|e
operator|->
name|next
operator|=
name|e
operator|->
name|prev
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|prev
operator|=
operator|*
name|event_head
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|e
operator|->
name|prev
operator|->
name|next
expr_stmt|;
name|e
operator|->
name|prev
operator|->
name|next
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|next
operator|->
name|prev
operator|=
name|e
expr_stmt|;
operator|*
name|event_head
operator|=
name|e
expr_stmt|;
block|}
name|s
operator|->
name|n_queue
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_delete_all -- delete entire event queue and current event */
end_comment

begin_function
name|void
name|event_delete_all
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|event_dequeue
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|event_delete
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|current_event
condition|)
block|{
name|event_delete
argument_list|(
name|s
operator|->
name|current_event
argument_list|)
expr_stmt|;
comment|/* will set: s->current_event = NULL;  */
block|}
block|}
end_function

begin_comment
comment|/**  * event_retry - Called when we had a failure delivering event msg  * @e: Event  * @do_next_address: skip address e.g. on connect fail  */
end_comment

begin_function
specifier|static
name|void
name|event_retry
parameter_list|(
name|struct
name|wps_event_
modifier|*
name|e
parameter_list|,
name|int
name|do_next_address
parameter_list|)
block|{
name|struct
name|subscription
modifier|*
name|s
init|=
name|e
operator|->
name|s
decl_stmt|;
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|s
operator|->
name|sm
decl_stmt|;
name|event_clean
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* will set: s->current_event = NULL; */
if|if
condition|(
name|do_next_address
condition|)
name|e
operator|->
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|retry
operator|>=
name|s
operator|->
name|n_addr
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Giving up on sending event "
literal|"for %s"
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
return|return;
block|}
name|event_enqueue_at_begin
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|event_send_all_later
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called if the overall event-sending process takes too long */
end_comment

begin_function
specifier|static
name|void
name|event_timeout_handler
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
init|=
name|user_ctx
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
init|=
name|e
operator|->
name|s
decl_stmt|;
name|assert
argument_list|(
name|e
operator|==
name|s
operator|->
name|current_event
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Event send timeout"
argument_list|)
expr_stmt|;
name|event_retry
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_got_response_handler -- called back when http response is received. */
end_comment

begin_function
specifier|static
name|void
name|event_got_response_handler
parameter_list|(
name|struct
name|httpread
modifier|*
name|handle
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
name|enum
name|httpread_event
name|en
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
init|=
name|cookie
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
init|=
name|e
operator|->
name|s
decl_stmt|;
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|s
operator|->
name|sm
decl_stmt|;
name|struct
name|httpread
modifier|*
name|hread
init|=
name|e
operator|->
name|hread
decl_stmt|;
name|int
name|reply_code
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|e
operator|==
name|s
operator|->
name|current_event
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|event_timeout_handler
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|en
operator|==
name|HTTPREAD_EVENT_FILE_READY
condition|)
block|{
if|if
condition|(
name|httpread_hdr_type_get
argument_list|(
name|hread
argument_list|)
operator|==
name|HTTPREAD_HDR_TYPE_REPLY
condition|)
block|{
name|reply_code
operator|=
name|httpread_reply_code_get
argument_list|(
name|hread
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply_code
operator|==
name|HTTP_OK
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Got event reply OK from "
literal|"%s"
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
name|event_delete
argument_list|(
name|e
argument_list|)
expr_stmt|;
goto|goto
name|send_more
goto|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Got event "
literal|"error reply code %d from %s"
argument_list|,
name|reply_code
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Got bogus event "
literal|"response %d from %s"
argument_list|,
name|en
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Event response timeout/fail "
literal|"for %s"
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|event_retry
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|send_more
goto|;
name|send_more
label|:
comment|/* Schedule sending more if there is more to send */
if|if
condition|(
name|s
operator|->
name|event_queue
condition|)
name|event_send_all_later
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
comment|/* 	 * If other side doesn't like what we say, forget about them. 	 * (There is no way to tell other side that we are dropping 	 * them...). 	 * Alternately, we could just do event_delete(e) 	 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Deleting subscription due to errors"
argument_list|)
expr_stmt|;
name|subscription_unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|subscription_destroy
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_send_tx_ready -- actually write event message  *  * Prequisite: subscription socket descriptor has become ready to  * write (because connection to subscriber has been made).  *  * It is also possible that we are called because the connect has failed;  * it is possible to test for this, or we can just go ahead and then  * the write will fail.  */
end_comment

begin_function
specifier|static
name|void
name|event_send_tx_ready
parameter_list|(
name|int
name|sock
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
init|=
name|sock_ctx
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
init|=
name|e
operator|->
name|s
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|assert
argument_list|(
name|e
operator|==
name|s
operator|->
name|current_event
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|e
operator|->
name|sd
operator|==
name|sock
argument_list|)
expr_stmt|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|1000
operator|+
name|wpabuf_len
argument_list|(
name|e
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|event_retry
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"NOTIFY %s HTTP/1.1\r\n"
argument_list|,
name|e
operator|->
name|addr
operator|->
name|path
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"SERVER: Unspecified, UPnP/1.0, Unspecified\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"HOST: %s\r\n"
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"CONTENT-TYPE: text/xml; charset=\"utf-8\"\r\n"
literal|"NT: upnp:event\r\n"
literal|"NTS: upnp:propchange\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"SID: uuid:"
argument_list|)
expr_stmt|;
name|b
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uuid_bin2str
argument_list|(
name|s
operator|->
name|uuid
argument_list|,
name|b
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
name|os_strlen
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"SEQ: %u\r\n"
argument_list|,
name|e
operator|->
name|subscriber_sequence
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"CONTENT-LENGTH: %d\r\n"
argument_list|,
operator|(
name|int
operator|)
name|wpabuf_len
argument_list|(
name|e
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
comment|/* terminating empty line */
name|wpabuf_put_buf
argument_list|(
name|buf
argument_list|,
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* Since the message size is pretty small, we should be 	 * able to get the operating system to buffer what we give it 	 * and not have to come back again later to write more... 	 */
if|#
directive|if
literal|0
comment|/* we could: Turn blocking back on? */
block|fcntl(e->sd, F_SETFL, 0);
endif|#
directive|endif
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Sending event to %s"
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_wpabuf
argument_list|(
name|e
operator|->
name|sd
argument_list|,
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|event_retry
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|sd_registered
condition|)
block|{
name|e
operator|->
name|sd_registered
operator|=
literal|0
expr_stmt|;
name|eloop_unregister_sock
argument_list|(
name|e
operator|->
name|sd
argument_list|,
name|EVENT_TYPE_WRITE
argument_list|)
expr_stmt|;
block|}
comment|/* Set up to read the reply */
name|e
operator|->
name|hread
operator|=
name|httpread_create
argument_list|(
name|e
operator|->
name|sd
argument_list|,
name|event_got_response_handler
argument_list|,
name|e
comment|/* cookie */
argument_list|,
literal|0
comment|/* no data expected */
argument_list|,
name|EVENT_TIMEOUT_SEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|hread
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"WPS UPnP: httpread_create failed"
argument_list|)
expr_stmt|;
name|event_retry
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
return|return;
name|bad
label|:
comment|/* Schedule sending more if there is more to send */
if|if
condition|(
name|s
operator|->
name|event_queue
condition|)
name|event_send_all_later
argument_list|(
name|s
operator|->
name|sm
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_send_start -- prepare to send a event message to subscriber  *  * This gets complicated because:  * -- The message is sent via TCP and we have to keep the stream open  *      for 30 seconds to get a response... then close it.  * -- But we might have other event happen in the meantime...  *      we have to queue them, if we lose them then the subscriber will  *      be forced to unsubscribe and subscribe again.  * -- If multiple URLs are provided then we are supposed to try successive  *      ones after 30 second timeout.  * -- The URLs might use domain names instead of dotted decimal addresses,  *      and resolution of those may cause unwanted sleeping.  * -- Doing the initial TCP connect can take a while, so we have to come  *      back after connection and then send the data.  *  * Returns nonzero on error;  *  * Prerequisite: No current event send (s->current_event == NULL)  *      and non-empty queue.  */
end_comment

begin_function
specifier|static
name|int
name|event_send_start
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
decl_stmt|;
name|int
name|itry
decl_stmt|;
comment|/* 	 * Assume we are called ONLY with no current event and ONLY with 	 * nonempty event queue and ONLY with at least one address to send to. 	 */
name|assert
argument_list|(
name|s
operator|->
name|addr_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|s
operator|->
name|current_event
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|s
operator|->
name|event_queue
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|current_event
operator|=
name|e
operator|=
name|event_dequeue
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Use address acc. to no. of retries */
name|e
operator|->
name|addr
operator|=
name|s
operator|->
name|addr_list
expr_stmt|;
for|for
control|(
name|itry
operator|=
literal|0
init|;
name|itry
operator|<
name|e
operator|->
name|retry
condition|;
name|itry
operator|++
control|)
name|e
operator|->
name|addr
operator|=
name|e
operator|->
name|addr
operator|->
name|next
expr_stmt|;
name|e
operator|->
name|sd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|sd
operator|<
literal|0
condition|)
block|{
name|event_retry
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* set non-blocking so we don't sleep waiting for connection */
if|if
condition|(
name|fcntl
argument_list|(
name|e
operator|->
name|sd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|event_retry
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Start the connect. It might succeed immediately but more likely will 	 * return errno EINPROGRESS. 	 */
if|if
condition|(
name|connect
argument_list|(
name|e
operator|->
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|e
operator|->
name|addr
operator|->
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|e
operator|->
name|addr
operator|->
name|saddr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINPROGRESS
condition|)
block|{
name|event_retry
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Call back when ready for writing (or on failure...). */
if|if
condition|(
name|eloop_register_sock
argument_list|(
name|e
operator|->
name|sd
argument_list|,
name|EVENT_TYPE_WRITE
argument_list|,
name|event_send_tx_ready
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
condition|)
block|{
name|event_retry
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|e
operator|->
name|sd_registered
operator|=
literal|1
expr_stmt|;
comment|/* Don't wait forever! */
if|if
condition|(
name|eloop_register_timeout
argument_list|(
name|EVENT_TIMEOUT_SEC
argument_list|,
literal|0
argument_list|,
name|event_timeout_handler
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
condition|)
block|{
name|event_retry
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* event_send_all_later_handler -- actually send events as needed */
end_comment

begin_function
specifier|static
name|void
name|event_send_all_later_handler
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|user_ctx
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s_old
decl_stmt|;
name|int
name|nerrors
init|=
literal|0
decl_stmt|;
name|sm
operator|->
name|event_send_all_queued
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|sm
operator|->
name|subscriptions
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
if|if
condition|(
name|s
operator|->
name|addr_list
operator|==
name|NULL
condition|)
block|{
comment|/* if we've given up on all addresses */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Removing "
literal|"subscription with no addresses"
argument_list|)
expr_stmt|;
name|s_old
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|s_old
operator|->
name|next
expr_stmt|;
name|subscription_unlink
argument_list|(
name|s_old
argument_list|)
expr_stmt|;
name|subscription_destroy
argument_list|(
name|s_old
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|->
name|current_event
operator|==
name|NULL
comment|/* not busy */
operator|&&
name|s
operator|->
name|event_queue
operator|!=
name|NULL
comment|/* more to do */
condition|)
block|{
if|if
condition|(
name|event_send_start
argument_list|(
name|s
argument_list|)
condition|)
name|nerrors
operator|++
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
block|}
do|while
condition|(
name|sm
operator|->
name|subscriptions
operator|!=
name|NULL
operator|&&
name|s
operator|!=
name|sm
operator|->
name|subscriptions
condition|)
do|;
if|if
condition|(
name|nerrors
condition|)
block|{
comment|/* Try again later */
name|event_send_all_later
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* event_send_all_later -- schedule sending events to all subscribers  * that need it.  * This avoids two problems:  * -- After getting a subscription, we should not send the first event  *      until after our reply is fully queued to be sent back,  * -- Possible stack depth or infinite recursion issues.  */
end_comment

begin_function
name|void
name|event_send_all_later
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
comment|/* 	 * The exact time in the future isn't too important. Waiting a bit 	 * might let us do several together. 	 */
if|if
condition|(
name|sm
operator|->
name|event_send_all_queued
condition|)
return|return;
name|sm
operator|->
name|event_send_all_queued
operator|=
literal|1
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|EVENT_DELAY_SECONDS
argument_list|,
name|EVENT_DELAY_MSEC
argument_list|,
name|event_send_all_later_handler
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_send_stop_all -- cleanup */
end_comment

begin_function
name|void
name|event_send_stop_all
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|event_send_all_queued
condition|)
name|eloop_cancel_timeout
argument_list|(
name|event_send_all_later_handler
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|event_send_all_queued
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * event_add - Add a new event to a queue  * @s: Subscription  * @data: Event data (is copied; caller retains ownership)  * Returns: 0 on success, 1 on error  */
end_comment

begin_function
name|int
name|event_add
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|n_queue
operator|>=
name|MAX_EVENTS_QUEUED
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Too many events queued for "
literal|"subscriber"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|e
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|e
operator|->
name|s
operator|=
name|s
expr_stmt|;
name|e
operator|->
name|sd
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|->
name|data
operator|=
name|wpabuf_dup
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|os_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|e
operator|->
name|subscriber_sequence
operator|=
name|s
operator|->
name|next_subscriber_sequence
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|next_subscriber_sequence
operator|==
literal|0
condition|)
name|s
operator|->
name|next_subscriber_sequence
operator|++
expr_stmt|;
name|event_enqueue_at_end
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|event_send_all_later
argument_list|(
name|s
operator|->
name|sm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

