begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * httpread - Manage reading file(s) from HTTP/TCP socket  * Author: Ted Merrill  * Copyright 2008 Atheros Communications  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  *  * The files are buffered via internal callbacks from eloop, then presented to  * an application callback routine when completely read into memory. May also  * be used if no file is expected but just to get the header, including HTTP  * replies (e.g. HTTP/1.1 200 OK etc.).  *  * This does not attempt to be an optimally efficient implementation, but does  * attempt to be of reasonably small size and memory consumption; assuming that  * only small files are to be read. A maximum file size is provided by  * application and enforced.  *  * It is assumed that the application does not expect any of the following:  * -- transfer encoding other than chunked  * -- trailer fields  * It is assumed that, even if the other side requested that the connection be  * kept open, that we will close it (thus HTTP messages sent by application  * should have the connection closed field); this is allowed by HTTP/1.1 and  * simplifies things for us.  *  * Other limitations:  * -- HTTP header may not exceed a hard-coded size.  *  * Notes:  * This code would be massively simpler without some of the new features of  * HTTP/1.1, especially chunked data.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"httpread.h"
end_include

begin_comment
comment|/* Tunable parameters */
end_comment

begin_define
define|#
directive|define
name|HTTPREAD_READBUF_SIZE
value|1024
end_define

begin_comment
comment|/* read in chunks of this size */
end_comment

begin_define
define|#
directive|define
name|HTTPREAD_HEADER_MAX_SIZE
value|4096
end_define

begin_comment
comment|/* max allowed for headers */
end_comment

begin_define
define|#
directive|define
name|HTTPREAD_BODYBUF_DELTA
value|4096
end_define

begin_comment
comment|/* increase allocation by this */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* httpread_debug -- set this global variable> 0 e.g. from debugger  * to enable debugs (larger numbers for more debugs)  * Make this a #define of 0 to eliminate the debugging code.  */
end_comment

begin_else
unit|int httpread_debug = 99;
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|httpread_debug
value|0
end_define

begin_comment
comment|/* eliminates even the debugging code */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* control instance -- actual definition (opaque to application)  */
end_comment

begin_struct
struct|struct
name|httpread
block|{
comment|/* information from creation */
name|int
name|sd
decl_stmt|;
comment|/* descriptor of TCP socket to read from */
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|httpread
modifier|*
name|handle
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
name|enum
name|httpread_event
name|e
parameter_list|)
function_decl|;
comment|/* call on event */
name|void
modifier|*
name|cookie
decl_stmt|;
comment|/* pass to callback */
name|int
name|max_bytes
decl_stmt|;
comment|/* maximum file size else abort it */
name|int
name|timeout_seconds
decl_stmt|;
comment|/* 0 or total duration timeout period */
comment|/* dynamically used information follows */
name|int
name|sd_registered
decl_stmt|;
comment|/* nonzero if we need to unregister socket */
name|int
name|to_registered
decl_stmt|;
comment|/* nonzero if we need to unregister timeout */
name|int
name|got_hdr
decl_stmt|;
comment|/* nonzero when header is finalized */
name|char
name|hdr
index|[
name|HTTPREAD_HEADER_MAX_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* headers stored here */
name|int
name|hdr_nbytes
decl_stmt|;
name|enum
name|httpread_hdr_type
name|hdr_type
decl_stmt|;
name|int
name|version
decl_stmt|;
comment|/* 1 if we've seen 1.1 */
name|int
name|reply_code
decl_stmt|;
comment|/* for type REPLY, e.g. 200 for HTTP/1.1 200 OK */
name|int
name|got_content_length
decl_stmt|;
comment|/* true if we know content length for sure */
name|int
name|content_length
decl_stmt|;
comment|/* body length,  iff got_content_length */
name|int
name|chunked
decl_stmt|;
comment|/* nonzero for chunked data */
name|char
modifier|*
name|uri
decl_stmt|;
name|int
name|got_body
decl_stmt|;
comment|/* nonzero when body is finalized */
name|char
modifier|*
name|body
decl_stmt|;
name|int
name|body_nbytes
decl_stmt|;
name|int
name|body_alloc_nbytes
decl_stmt|;
comment|/* amount allocated */
name|int
name|got_file
decl_stmt|;
comment|/* here when we are done */
comment|/* The following apply if data is chunked: */
name|int
name|in_chunk_data
decl_stmt|;
comment|/* 0=in/at header, 1=in the data or tail*/
name|int
name|chunk_start
decl_stmt|;
comment|/* offset in body of chunk hdr or data */
name|int
name|chunk_size
decl_stmt|;
comment|/* data of chunk (not hdr or ending CRLF)*/
name|int
name|in_trailer
decl_stmt|;
comment|/* in header fields after data (chunked only)*/
enum|enum
name|trailer_state
block|{
name|trailer_line_begin
init|=
literal|0
block|,
name|trailer_empty_cr
block|,
comment|/* empty line + CR */
name|trailer_nonempty
block|,
name|trailer_nonempty_cr
block|, 	}
name|trailer_state
enum|;
block|}
struct|;
end_struct

begin_comment
comment|/* Check words for equality, where words consist of graphical characters  * delimited by whitespace  * Returns nonzero if "equal" doing case insensitive comparison.  */
end_comment

begin_function
specifier|static
name|int
name|word_eq
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|int
name|c1
decl_stmt|;
name|int
name|c2
decl_stmt|;
name|int
name|end1
init|=
literal|0
decl_stmt|;
name|int
name|end2
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c1
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
name|c2
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c1
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c1
argument_list|)
condition|)
name|c1
operator|=
name|tolower
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c2
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c2
argument_list|)
condition|)
name|c2
operator|=
name|tolower
argument_list|(
name|c2
argument_list|)
expr_stmt|;
name|end1
operator|=
operator|!
name|isgraph
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|end2
operator|=
operator|!
name|isgraph
argument_list|(
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|end1
operator|||
name|end2
operator|||
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
return|return
name|end1
operator|&&
name|end2
return|;
comment|/* reached end of both words? */
block|}
end_function

begin_comment
comment|/* convert hex to binary  * Requires that c have been previously tested true with isxdigit().  */
end_comment

begin_function
specifier|static
name|int
name|hex_value
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|c
operator|-
literal|'0'
return|;
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|10
operator|+
name|c
operator|-
literal|'a'
return|;
return|return
literal|10
operator|+
name|c
operator|-
literal|'A'
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|httpread_timeout_handler
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* httpread_destroy -- if h is non-NULL, clean up  * This must eventually be called by the application following  * call of the application's callback and may be called  * earlier if desired.  */
end_comment

begin_function
name|void
name|httpread_destroy
parameter_list|(
name|struct
name|httpread
modifier|*
name|h
parameter_list|)
block|{
if|if
condition|(
name|httpread_debug
operator|>=
literal|10
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ENTER httpread_destroy(%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
return|return;
if|if
condition|(
name|h
operator|->
name|to_registered
condition|)
name|eloop_cancel_timeout
argument_list|(
name|httpread_timeout_handler
argument_list|,
name|NULL
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|to_registered
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|sd_registered
condition|)
name|eloop_unregister_sock
argument_list|(
name|h
operator|->
name|sd
argument_list|,
name|EVENT_TYPE_READ
argument_list|)
expr_stmt|;
name|h
operator|->
name|sd_registered
operator|=
literal|0
expr_stmt|;
name|os_free
argument_list|(
name|h
operator|->
name|body
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|h
operator|->
name|uri
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
name|h
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
comment|/* aid debugging */
name|h
operator|->
name|sd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* aid debugging */
name|os_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* httpread_timeout_handler -- called on excessive total duration  */
end_comment

begin_function
specifier|static
name|void
name|httpread_timeout_handler
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
block|{
name|struct
name|httpread
modifier|*
name|h
init|=
name|user_ctx
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread timeout (%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|to_registered
operator|=
literal|0
expr_stmt|;
comment|/* is self-cancelling */
call|(
modifier|*
name|h
operator|->
name|cb
call|)
argument_list|(
name|h
argument_list|,
name|h
operator|->
name|cookie
argument_list|,
name|HTTPREAD_EVENT_TIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze options only so far as is needed to correctly obtain the file.  * The application can look at the raw header to find other options.  */
end_comment

begin_function
specifier|static
name|int
name|httpread_hdr_option_analyze
parameter_list|(
name|struct
name|httpread
modifier|*
name|h
parameter_list|,
name|char
modifier|*
name|hbp
comment|/* pointer to current line in header buffer */
parameter_list|)
block|{
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"CONTENT-LENGTH:"
argument_list|)
condition|)
block|{
while|while
condition|(
name|isgraph
argument_list|(
operator|*
name|hbp
argument_list|)
condition|)
name|hbp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|hbp
operator|==
literal|' '
operator|||
operator|*
name|hbp
operator|==
literal|'\t'
condition|)
name|hbp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|hbp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|h
operator|->
name|content_length
operator|=
name|atol
argument_list|(
name|hbp
argument_list|)
expr_stmt|;
name|h
operator|->
name|got_content_length
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"TRANSFER_ENCODING:"
argument_list|)
operator|||
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"TRANSFER-ENCODING:"
argument_list|)
condition|)
block|{
while|while
condition|(
name|isgraph
argument_list|(
operator|*
name|hbp
argument_list|)
condition|)
name|hbp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|hbp
operator|==
literal|' '
operator|||
operator|*
name|hbp
operator|==
literal|'\t'
condition|)
name|hbp
operator|++
expr_stmt|;
comment|/* There should (?) be no encodings of interest 		 * other than chunked... 		 */
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"CHUNKED"
argument_list|)
condition|)
block|{
name|h
operator|->
name|chunked
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|in_chunk_data
operator|=
literal|0
expr_stmt|;
comment|/* ignore possible ;<parameters> */
block|}
return|return
literal|0
return|;
block|}
comment|/* skip anything we don't know, which is a lot */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|httpread_hdr_analyze
parameter_list|(
name|struct
name|httpread
modifier|*
name|h
parameter_list|)
block|{
name|char
modifier|*
name|hbp
init|=
name|h
operator|->
name|hdr
decl_stmt|;
comment|/* pointer into h->hdr */
name|int
name|standard_first_line
init|=
literal|1
decl_stmt|;
comment|/* First line is special */
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_UNKNOWN
expr_stmt|;
if|if
condition|(
operator|!
name|isgraph
argument_list|(
operator|*
name|hbp
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|os_strncmp
argument_list|(
name|hbp
argument_list|,
literal|"HTTP/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_REPLY
expr_stmt|;
name|standard_first_line
operator|=
literal|0
expr_stmt|;
name|hbp
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|hbp
index|[
literal|0
index|]
operator|==
literal|'1'
operator|&&
name|hbp
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|isdigit
argument_list|(
name|hbp
index|[
literal|2
index|]
argument_list|)
operator|&&
name|hbp
index|[
literal|2
index|]
operator|!=
literal|'0'
condition|)
name|h
operator|->
name|version
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|isgraph
argument_list|(
operator|*
name|hbp
argument_list|)
condition|)
name|hbp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|hbp
operator|==
literal|' '
operator|||
operator|*
name|hbp
operator|==
literal|'\t'
condition|)
name|hbp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|hbp
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|h
operator|->
name|reply_code
operator|=
name|atol
argument_list|(
name|hbp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"GET"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_GET
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_HEAD
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"POST"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_POST
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"PUT"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_PUT
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"DELETE"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_DELETE
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"TRACE"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_TRACE
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"CONNECT"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_CONNECT
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"NOTIFY"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_NOTIFY
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"M-SEARCH"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_M_SEARCH
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"M-POST"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_M_POST
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"SUBSCRIBE"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_SUBSCRIBE
expr_stmt|;
elseif|else
if|if
condition|(
name|word_eq
argument_list|(
name|hbp
argument_list|,
literal|"UNSUBSCRIBE"
argument_list|)
condition|)
name|h
operator|->
name|hdr_type
operator|=
name|HTTPREAD_HDR_TYPE_UNSUBSCRIBE
expr_stmt|;
else|else
block|{ 	}
if|if
condition|(
name|standard_first_line
condition|)
block|{
name|char
modifier|*
name|rawuri
decl_stmt|;
name|char
modifier|*
name|uri
decl_stmt|;
comment|/* skip type */
while|while
condition|(
name|isgraph
argument_list|(
operator|*
name|hbp
argument_list|)
condition|)
name|hbp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|hbp
operator|==
literal|' '
operator|||
operator|*
name|hbp
operator|==
literal|'\t'
condition|)
name|hbp
operator|++
expr_stmt|;
comment|/* parse uri. 		 * Find length, allocate memory for translated 		 * copy, then translate by changing %<hex><hex> 		 * into represented value. 		 */
name|rawuri
operator|=
name|hbp
expr_stmt|;
while|while
condition|(
name|isgraph
argument_list|(
operator|*
name|hbp
argument_list|)
condition|)
name|hbp
operator|++
expr_stmt|;
name|h
operator|->
name|uri
operator|=
name|os_malloc
argument_list|(
operator|(
name|hbp
operator|-
name|rawuri
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|uri
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|uri
operator|=
name|h
operator|->
name|uri
expr_stmt|;
while|while
condition|(
name|rawuri
operator|<
name|hbp
condition|)
block|{
name|int
name|c
init|=
operator|*
name|rawuri
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|isxdigit
argument_list|(
name|rawuri
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isxdigit
argument_list|(
name|rawuri
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|uri
operator|++
operator|=
operator|(
name|hex_value
argument_list|(
name|rawuri
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|hex_value
argument_list|(
name|rawuri
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|rawuri
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
operator|*
name|uri
operator|++
operator|=
name|c
expr_stmt|;
name|rawuri
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|uri
operator|=
literal|0
expr_stmt|;
comment|/* null terminate */
while|while
condition|(
name|isgraph
argument_list|(
operator|*
name|hbp
argument_list|)
condition|)
name|hbp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|hbp
operator|==
literal|' '
operator|||
operator|*
name|hbp
operator|==
literal|'\t'
condition|)
name|hbp
operator|++
expr_stmt|;
comment|/* get version */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|hbp
argument_list|,
literal|"HTTP/"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|hbp
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|hbp
index|[
literal|0
index|]
operator|==
literal|'1'
operator|&&
name|hbp
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|isdigit
argument_list|(
name|hbp
index|[
literal|2
index|]
argument_list|)
operator|&&
name|hbp
index|[
literal|2
index|]
operator|!=
literal|'0'
condition|)
name|h
operator|->
name|version
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* skip rest of line */
while|while
condition|(
operator|*
name|hbp
condition|)
if|if
condition|(
operator|*
name|hbp
operator|++
operator|==
literal|'\n'
condition|)
break|break;
comment|/* Remainder of lines are options, in any order; 	 * or empty line to terminate 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Empty line to terminate */
if|if
condition|(
name|hbp
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
operator|(
name|hbp
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|&&
name|hbp
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|isgraph
argument_list|(
operator|*
name|hbp
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|httpread_hdr_option_analyze
argument_list|(
name|h
argument_list|,
name|hbp
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* skip line */
while|while
condition|(
operator|*
name|hbp
condition|)
if|if
condition|(
operator|*
name|hbp
operator|++
operator|==
literal|'\n'
condition|)
break|break;
block|}
comment|/* chunked overrides content-length always */
if|if
condition|(
name|h
operator|->
name|chunked
condition|)
name|h
operator|->
name|got_content_length
operator|=
literal|0
expr_stmt|;
comment|/* For some types, we should not try to read a body 	 * This is in addition to the application determining 	 * that we should not read a body. 	 */
switch|switch
condition|(
name|h
operator|->
name|hdr_type
condition|)
block|{
case|case
name|HTTPREAD_HDR_TYPE_REPLY
case|:
comment|/* Some codes can have a body and some not. 		 * For now, just assume that any other than 200 		 * do not... 		 */
if|if
condition|(
name|h
operator|->
name|reply_code
operator|!=
literal|200
condition|)
name|h
operator|->
name|max_bytes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HTTPREAD_HDR_TYPE_GET
case|:
case|case
name|HTTPREAD_HDR_TYPE_HEAD
case|:
comment|/* in practice it appears that it is assumed 		 * that GETs have a body length of 0... ? 		 */
if|if
condition|(
name|h
operator|->
name|chunked
operator|==
literal|0
operator|&&
name|h
operator|->
name|got_content_length
operator|==
literal|0
condition|)
name|h
operator|->
name|max_bytes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HTTPREAD_HDR_TYPE_POST
case|:
case|case
name|HTTPREAD_HDR_TYPE_PUT
case|:
case|case
name|HTTPREAD_HDR_TYPE_DELETE
case|:
case|case
name|HTTPREAD_HDR_TYPE_TRACE
case|:
case|case
name|HTTPREAD_HDR_TYPE_CONNECT
case|:
case|case
name|HTTPREAD_HDR_TYPE_NOTIFY
case|:
case|case
name|HTTPREAD_HDR_TYPE_M_SEARCH
case|:
case|case
name|HTTPREAD_HDR_TYPE_M_POST
case|:
case|case
name|HTTPREAD_HDR_TYPE_SUBSCRIBE
case|:
case|case
name|HTTPREAD_HDR_TYPE_UNSUBSCRIBE
case|:
default|default:
break|break;
block|}
return|return
literal|0
return|;
name|bad
label|:
comment|/* Error */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* httpread_read_handler -- called when socket ready to read  *  * Note: any extra data we read past end of transmitted file is ignored;  * if we were to support keeping connections open for multiple files then  * this would have to be addressed.  */
end_comment

begin_function
specifier|static
name|void
name|httpread_read_handler
parameter_list|(
name|int
name|sd
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|struct
name|httpread
modifier|*
name|h
init|=
name|sock_ctx
decl_stmt|;
name|int
name|nread
decl_stmt|;
name|char
modifier|*
name|rbp
decl_stmt|;
comment|/* pointer into read buffer */
name|char
modifier|*
name|hbp
decl_stmt|;
comment|/* pointer into header buffer */
name|char
modifier|*
name|bbp
decl_stmt|;
comment|/* pointer into body buffer */
name|char
name|readbuf
index|[
name|HTTPREAD_READBUF_SIZE
index|]
decl_stmt|;
comment|/* temp use to read into */
if|if
condition|(
name|httpread_debug
operator|>=
literal|20
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ENTER httpread_read_handler(%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* read some at a time, then search for the interal 	 * boundaries between header and data and etc. 	 */
name|nread
operator|=
name|read
argument_list|(
name|h
operator|->
name|sd
argument_list|,
name|readbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|readbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
block|{
comment|/* end of transmission... this may be normal 		 * or may be an error... in some cases we can't 		 * tell which so we must assume it is normal then. 		 */
if|if
condition|(
operator|!
name|h
operator|->
name|got_hdr
condition|)
block|{
comment|/* Must at least have completed header */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread premature eof(%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|h
operator|->
name|chunked
operator|||
name|h
operator|->
name|got_content_length
condition|)
block|{
comment|/* Premature EOF; e.g. dropped connection */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread premature eof(%p) %d/%d"
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|body_nbytes
argument_list|,
name|h
operator|->
name|content_length
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* No explicit length, hopefully we have all the data 		 * although dropped connections can cause false 		 * end 		 */
if|if
condition|(
name|httpread_debug
operator|>=
literal|10
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread ok eof(%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|got_body
operator|=
literal|1
expr_stmt|;
goto|goto
name|got_file
goto|;
block|}
name|rbp
operator|=
name|readbuf
expr_stmt|;
comment|/* Header consists of text lines (terminated by both CR and LF) 	 * and an empty line (CR LF only). 	 */
if|if
condition|(
operator|!
name|h
operator|->
name|got_hdr
condition|)
block|{
name|hbp
operator|=
name|h
operator|->
name|hdr
operator|+
name|h
operator|->
name|hdr_nbytes
expr_stmt|;
comment|/* add to headers until: 		 *      -- we run out of data in read buffer 		 *      -- or, we run out of header buffer room 		 *      -- or, we get double CRLF in headers 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
goto|goto
name|get_more
goto|;
if|if
condition|(
name|h
operator|->
name|hdr_nbytes
operator|==
name|HTTPREAD_HEADER_MAX_SIZE
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
operator|*
name|hbp
operator|++
operator|=
operator|*
name|rbp
operator|++
expr_stmt|;
name|nread
operator|--
expr_stmt|;
name|h
operator|->
name|hdr_nbytes
operator|++
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|hdr_nbytes
operator|>=
literal|4
operator|&&
name|hbp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|hbp
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|&&
name|hbp
index|[
operator|-
literal|3
index|]
operator|==
literal|'\n'
operator|&&
name|hbp
index|[
operator|-
literal|4
index|]
operator|==
literal|'\r'
condition|)
block|{
name|h
operator|->
name|got_hdr
operator|=
literal|1
expr_stmt|;
operator|*
name|hbp
operator|=
literal|0
expr_stmt|;
comment|/* null terminate */
break|break;
block|}
block|}
comment|/* here we've just finished reading the header */
if|if
condition|(
name|httpread_hdr_analyze
argument_list|(
name|h
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread bad hdr(%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|h
operator|->
name|max_bytes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|httpread_debug
operator|>=
literal|10
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread no body hdr end(%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
goto|goto
name|got_file
goto|;
block|}
if|if
condition|(
name|h
operator|->
name|got_content_length
operator|&&
name|h
operator|->
name|content_length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|httpread_debug
operator|>=
literal|10
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread zero content length(%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
goto|goto
name|got_file
goto|;
block|}
block|}
comment|/* Certain types of requests never have data and so 	 * must be specially recognized. 	 */
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
name|h
operator|->
name|hdr
argument_list|,
literal|"SUBSCRIBE"
argument_list|,
literal|9
argument_list|)
operator|||
operator|!
name|os_strncasecmp
argument_list|(
name|h
operator|->
name|hdr
argument_list|,
literal|"UNSUBSCRIBE"
argument_list|,
literal|11
argument_list|)
operator|||
operator|!
name|os_strncasecmp
argument_list|(
name|h
operator|->
name|hdr
argument_list|,
literal|"HEAD"
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|os_strncasecmp
argument_list|(
name|h
operator|->
name|hdr
argument_list|,
literal|"GET"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|h
operator|->
name|got_body
condition|)
block|{
if|if
condition|(
name|httpread_debug
operator|>=
literal|10
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread NO BODY for sp. type"
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|got_body
operator|=
literal|1
expr_stmt|;
goto|goto
name|got_file
goto|;
block|}
comment|/* Data can be just plain binary data, or if "chunked" 	 * consists of chunks each with a header, ending with 	 * an ending header. 	 */
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
goto|goto
name|get_more
goto|;
if|if
condition|(
operator|!
name|h
operator|->
name|got_body
condition|)
block|{
comment|/* Here to get (more of) body */
comment|/* ensure we have enough room for worst case for body 		 * plus a null termination character 		 */
if|if
condition|(
name|h
operator|->
name|body_alloc_nbytes
operator|<
operator|(
name|h
operator|->
name|body_nbytes
operator|+
name|nread
operator|+
literal|1
operator|)
condition|)
block|{
name|char
modifier|*
name|new_body
decl_stmt|;
name|int
name|new_alloc_nbytes
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|body_nbytes
operator|>=
name|h
operator|->
name|max_bytes
condition|)
goto|goto
name|bad
goto|;
name|new_alloc_nbytes
operator|=
name|h
operator|->
name|body_alloc_nbytes
operator|+
name|HTTPREAD_BODYBUF_DELTA
expr_stmt|;
comment|/* For content-length case, the first time 			 * through we allocate the whole amount 			 * we need. 			 */
if|if
condition|(
name|h
operator|->
name|got_content_length
operator|&&
name|new_alloc_nbytes
operator|<
operator|(
name|h
operator|->
name|content_length
operator|+
literal|1
operator|)
condition|)
name|new_alloc_nbytes
operator|=
name|h
operator|->
name|content_length
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|new_body
operator|=
name|os_realloc
argument_list|(
name|h
operator|->
name|body
argument_list|,
name|new_alloc_nbytes
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|h
operator|->
name|body
operator|=
name|new_body
expr_stmt|;
name|h
operator|->
name|body_alloc_nbytes
operator|=
name|new_alloc_nbytes
expr_stmt|;
block|}
comment|/* add bytes */
name|bbp
operator|=
name|h
operator|->
name|body
operator|+
name|h
operator|->
name|body_nbytes
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ncopy
decl_stmt|;
comment|/* See if we need to stop */
if|if
condition|(
name|h
operator|->
name|chunked
operator|&&
name|h
operator|->
name|in_chunk_data
operator|==
literal|0
condition|)
block|{
comment|/* in chunk header */
name|char
modifier|*
name|cbp
init|=
name|h
operator|->
name|body
operator|+
name|h
operator|->
name|chunk_start
decl_stmt|;
if|if
condition|(
name|bbp
operator|-
name|cbp
operator|>=
literal|2
operator|&&
name|bbp
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|&&
name|bbp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* end of chunk hdr line */
comment|/* hdr line consists solely 					 * of a hex numeral and CFLF 					 */
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|*
name|cbp
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|h
operator|->
name|chunk_size
operator|=
name|strtoul
argument_list|(
name|cbp
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* throw away chunk header 					 * so we have only real data 					 */
name|h
operator|->
name|body_nbytes
operator|=
name|h
operator|->
name|chunk_start
expr_stmt|;
name|bbp
operator|=
name|cbp
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|chunk_size
operator|==
literal|0
condition|)
block|{
comment|/* end of chunking */
comment|/* trailer follows */
name|h
operator|->
name|in_trailer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|httpread_debug
operator|>=
literal|20
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread end chunks(%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
block|}
name|h
operator|->
name|in_chunk_data
operator|=
literal|1
expr_stmt|;
comment|/* leave chunk_start alone */
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|chunked
condition|)
block|{
comment|/* in chunk data */
if|if
condition|(
operator|(
name|h
operator|->
name|body_nbytes
operator|-
name|h
operator|->
name|chunk_start
operator|)
operator|==
operator|(
name|h
operator|->
name|chunk_size
operator|+
literal|2
operator|)
condition|)
block|{
comment|/* end of chunk reached, 					 * new chunk starts 					 */
comment|/* check chunk ended w/ CRLF 					 * which we'll throw away 					 */
if|if
condition|(
name|bbp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|bbp
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
condition|)
block|{ 					}
else|else
goto|goto
name|bad
goto|;
name|h
operator|->
name|body_nbytes
operator|-=
literal|2
expr_stmt|;
name|bbp
operator|-=
literal|2
expr_stmt|;
name|h
operator|->
name|chunk_start
operator|=
name|h
operator|->
name|body_nbytes
expr_stmt|;
name|h
operator|->
name|in_chunk_data
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|chunk_size
operator|=
literal|0
expr_stmt|;
comment|/* just in case */
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|got_content_length
operator|&&
name|h
operator|->
name|body_nbytes
operator|>=
name|h
operator|->
name|content_length
condition|)
block|{
name|h
operator|->
name|got_body
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|httpread_debug
operator|>=
literal|10
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread got content(%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
goto|goto
name|got_file
goto|;
block|}
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
break|break;
comment|/* Now transfer. Optimize using memcpy where we can. */
if|if
condition|(
name|h
operator|->
name|chunked
operator|&&
name|h
operator|->
name|in_chunk_data
condition|)
block|{
comment|/* copy up to remainder of chunk data 				 * plus the required CR+LF at end 				 */
name|ncopy
operator|=
operator|(
name|h
operator|->
name|chunk_start
operator|+
name|h
operator|->
name|chunk_size
operator|+
literal|2
operator|)
operator|-
name|h
operator|->
name|body_nbytes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|chunked
condition|)
block|{
comment|/*in chunk header -- don't optimize */
operator|*
name|bbp
operator|++
operator|=
operator|*
name|rbp
operator|++
expr_stmt|;
name|nread
operator|--
expr_stmt|;
name|h
operator|->
name|body_nbytes
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|got_content_length
condition|)
block|{
name|ncopy
operator|=
name|h
operator|->
name|content_length
operator|-
name|h
operator|->
name|body_nbytes
expr_stmt|;
block|}
else|else
block|{
name|ncopy
operator|=
name|nread
expr_stmt|;
block|}
comment|/* Note: should never be 0 */
if|if
condition|(
name|ncopy
operator|>
name|nread
condition|)
name|ncopy
operator|=
name|nread
expr_stmt|;
name|os_memcpy
argument_list|(
name|bbp
argument_list|,
name|rbp
argument_list|,
name|ncopy
argument_list|)
expr_stmt|;
name|bbp
operator|+=
name|ncopy
expr_stmt|;
name|h
operator|->
name|body_nbytes
operator|+=
name|ncopy
expr_stmt|;
name|rbp
operator|+=
name|ncopy
expr_stmt|;
name|nread
operator|-=
name|ncopy
expr_stmt|;
block|}
comment|/* body copy loop */
block|}
comment|/* !got_body */
if|if
condition|(
name|h
operator|->
name|chunked
operator|&&
name|h
operator|->
name|in_trailer
condition|)
block|{
comment|/* If "chunked" then there is always a trailer, 		 * consisting of zero or more non-empty lines 		 * ending with CR LF and then an empty line w/ CR LF. 		 * We do NOT support trailers except to skip them -- 		 * this is supported (generally) by the http spec. 		 */
name|bbp
operator|=
name|h
operator|->
name|body
operator|+
name|h
operator|->
name|body_nbytes
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
break|break;
name|c
operator|=
operator|*
name|rbp
operator|++
expr_stmt|;
name|nread
operator|--
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|trailer_state
condition|)
block|{
case|case
name|trailer_line_begin
case|:
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|h
operator|->
name|trailer_state
operator|=
name|trailer_empty_cr
expr_stmt|;
else|else
name|h
operator|->
name|trailer_state
operator|=
name|trailer_nonempty
expr_stmt|;
break|break;
case|case
name|trailer_empty_cr
case|:
comment|/* end empty line */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|h
operator|->
name|trailer_state
operator|=
name|trailer_line_begin
expr_stmt|;
name|h
operator|->
name|in_trailer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|httpread_debug
operator|>=
literal|10
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread got content(%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|got_body
operator|=
literal|1
expr_stmt|;
goto|goto
name|got_file
goto|;
block|}
name|h
operator|->
name|trailer_state
operator|=
name|trailer_nonempty
expr_stmt|;
break|break;
case|case
name|trailer_nonempty
case|:
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|h
operator|->
name|trailer_state
operator|=
name|trailer_nonempty_cr
expr_stmt|;
break|break;
case|case
name|trailer_nonempty_cr
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|h
operator|->
name|trailer_state
operator|=
name|trailer_line_begin
expr_stmt|;
else|else
name|h
operator|->
name|trailer_state
operator|=
name|trailer_nonempty
expr_stmt|;
break|break;
block|}
block|}
block|}
goto|goto
name|get_more
goto|;
name|bad
label|:
comment|/* Error */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread read/parse failure (%p)"
argument_list|,
name|h
argument_list|)
expr_stmt|;
call|(
modifier|*
name|h
operator|->
name|cb
call|)
argument_list|(
name|h
argument_list|,
name|h
operator|->
name|cookie
argument_list|,
name|HTTPREAD_EVENT_ERROR
argument_list|)
expr_stmt|;
return|return;
name|get_more
label|:
return|return;
name|got_file
label|:
if|if
condition|(
name|httpread_debug
operator|>=
literal|10
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"httpread got file %d bytes type %d"
argument_list|,
name|h
operator|->
name|body_nbytes
argument_list|,
name|h
operator|->
name|hdr_type
argument_list|)
expr_stmt|;
comment|/* Null terminate for convenience of some applications */
if|if
condition|(
name|h
operator|->
name|body
condition|)
name|h
operator|->
name|body
index|[
name|h
operator|->
name|body_nbytes
index|]
operator|=
literal|0
expr_stmt|;
comment|/* null terminate */
name|h
operator|->
name|got_file
operator|=
literal|1
expr_stmt|;
comment|/* Assume that we do NOT support keeping connection alive, 	 * and just in case somehow we don't get destroyed right away, 	 * unregister now. 	 */
if|if
condition|(
name|h
operator|->
name|sd_registered
condition|)
name|eloop_unregister_sock
argument_list|(
name|h
operator|->
name|sd
argument_list|,
name|EVENT_TYPE_READ
argument_list|)
expr_stmt|;
name|h
operator|->
name|sd_registered
operator|=
literal|0
expr_stmt|;
comment|/* The application can destroy us whenever they feel like... 	 * cancel timeout. 	 */
if|if
condition|(
name|h
operator|->
name|to_registered
condition|)
name|eloop_cancel_timeout
argument_list|(
name|httpread_timeout_handler
argument_list|,
name|NULL
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|to_registered
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|h
operator|->
name|cb
call|)
argument_list|(
name|h
argument_list|,
name|h
operator|->
name|cookie
argument_list|,
name|HTTPREAD_EVENT_FILE_READY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* httpread_create -- start a new reading session making use of eloop.  * The new instance will use the socket descriptor for reading (until  * it gets a file and not after) but will not close the socket, even  * when the instance is destroyed (the application must do that).  * Return NULL on error.  *  * Provided that httpread_create successfully returns a handle,  * the callback fnc is called to handle httpread_event events.  * The caller should do destroy on any errors or unknown events.  *  * Pass max_bytes == 0 to not read body at all (required for e.g.  * reply to HEAD request).  */
end_comment

begin_function
name|struct
name|httpread
modifier|*
name|httpread_create
parameter_list|(
name|int
name|sd
parameter_list|,
comment|/* descriptor of TCP socket to read from */
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|httpread
modifier|*
name|handle
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
name|enum
name|httpread_event
name|e
parameter_list|)
parameter_list|,
comment|/* call on event */
name|void
modifier|*
name|cookie
parameter_list|,
comment|/* pass to callback */
name|int
name|max_bytes
parameter_list|,
comment|/* maximum body size else abort it */
name|int
name|timeout_seconds
comment|/* 0; or total duration timeout period */
parameter_list|)
block|{
name|struct
name|httpread
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|h
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|h
operator|->
name|sd
operator|=
name|sd
expr_stmt|;
name|h
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|h
operator|->
name|cookie
operator|=
name|cookie
expr_stmt|;
name|h
operator|->
name|max_bytes
operator|=
name|max_bytes
expr_stmt|;
name|h
operator|->
name|timeout_seconds
operator|=
name|timeout_seconds
expr_stmt|;
if|if
condition|(
name|timeout_seconds
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|eloop_register_timeout
argument_list|(
name|timeout_seconds
argument_list|,
literal|0
argument_list|,
name|httpread_timeout_handler
argument_list|,
name|NULL
argument_list|,
name|h
argument_list|)
condition|)
block|{
comment|/* No way to recover (from malloc failure) */
goto|goto
name|fail
goto|;
block|}
name|h
operator|->
name|to_registered
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|eloop_register_sock
argument_list|(
name|sd
argument_list|,
name|EVENT_TYPE_READ
argument_list|,
name|httpread_read_handler
argument_list|,
name|NULL
argument_list|,
name|h
argument_list|)
condition|)
block|{
comment|/* No way to recover (from malloc failure) */
goto|goto
name|fail
goto|;
block|}
name|h
operator|->
name|sd_registered
operator|=
literal|1
expr_stmt|;
return|return
name|h
return|;
name|fail
label|:
comment|/* Error */
name|httpread_destroy
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* httpread_hdr_type_get -- When file is ready, returns header type. */
end_comment

begin_function
name|enum
name|httpread_hdr_type
name|httpread_hdr_type_get
parameter_list|(
name|struct
name|httpread
modifier|*
name|h
parameter_list|)
block|{
return|return
name|h
operator|->
name|hdr_type
return|;
block|}
end_function

begin_comment
comment|/* httpread_uri_get -- When file is ready, uri_get returns (translated) URI  * or possibly NULL (which would be an error).  */
end_comment

begin_function
name|char
modifier|*
name|httpread_uri_get
parameter_list|(
name|struct
name|httpread
modifier|*
name|h
parameter_list|)
block|{
return|return
name|h
operator|->
name|uri
return|;
block|}
end_function

begin_comment
comment|/* httpread_reply_code_get -- When reply is ready, returns reply code */
end_comment

begin_function
name|int
name|httpread_reply_code_get
parameter_list|(
name|struct
name|httpread
modifier|*
name|h
parameter_list|)
block|{
return|return
name|h
operator|->
name|reply_code
return|;
block|}
end_function

begin_comment
comment|/* httpread_length_get -- When file is ready, returns file length. */
end_comment

begin_function
name|int
name|httpread_length_get
parameter_list|(
name|struct
name|httpread
modifier|*
name|h
parameter_list|)
block|{
return|return
name|h
operator|->
name|body_nbytes
return|;
block|}
end_function

begin_comment
comment|/* httpread_data_get -- When file is ready, returns file content  * with null byte appened.  * Might return NULL in some error condition.  */
end_comment

begin_function
name|void
modifier|*
name|httpread_data_get
parameter_list|(
name|struct
name|httpread
modifier|*
name|h
parameter_list|)
block|{
return|return
name|h
operator|->
name|body
condition|?
name|h
operator|->
name|body
else|:
literal|""
return|;
block|}
end_function

begin_comment
comment|/* httpread_hdr_get -- When file is ready, returns header content  * with null byte appended.  * Might return NULL in some error condition.  */
end_comment

begin_function
name|char
modifier|*
name|httpread_hdr_get
parameter_list|(
name|struct
name|httpread
modifier|*
name|h
parameter_list|)
block|{
return|return
name|h
operator|->
name|hdr
return|;
block|}
end_function

begin_comment
comment|/* httpread_hdr_line_get -- When file is ready, returns pointer  * to line within header content matching the given tag  * (after the tag itself and any spaces/tabs).  *  * The tag should end with a colon for reliable matching.  *  * If not found, returns NULL;  */
end_comment

begin_function
name|char
modifier|*
name|httpread_hdr_line_get
parameter_list|(
name|struct
name|httpread
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|tag_len
init|=
name|os_strlen
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|char
modifier|*
name|hdr
init|=
name|h
operator|->
name|hdr
decl_stmt|;
name|hdr
operator|=
name|os_strchr
argument_list|(
name|hdr
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|hdr
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
name|hdr
argument_list|,
name|tag
argument_list|,
name|tag_len
argument_list|)
condition|)
block|{
name|hdr
operator|+=
name|tag_len
expr_stmt|;
while|while
condition|(
operator|*
name|hdr
operator|==
literal|' '
operator|||
operator|*
name|hdr
operator|==
literal|'\t'
condition|)
name|hdr
operator|++
expr_stmt|;
return|return
name|hdr
return|;
block|}
name|hdr
operator|=
name|os_strchr
argument_list|(
name|hdr
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|hdr
operator|++
expr_stmt|;
block|}
block|}
end_function

end_unit

