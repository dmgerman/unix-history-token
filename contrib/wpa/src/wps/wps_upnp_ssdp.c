begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * UPnP SSDP for WPS  * Copyright (c) 2000-2003 Intel Corporation  * Copyright (c) 2006-2007 Sony Corporation  * Copyright (c) 2008-2009 Atheros Communications  * Copyright (c) 2009, Jouni Malinen<j@w1.fi>  *  * See wps_upnp.c for more details on licensing and code history.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"uuid.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"wps.h"
end_include

begin_include
include|#
directive|include
file|"wps_upnp.h"
end_include

begin_include
include|#
directive|include
file|"wps_upnp_i.h"
end_include

begin_define
define|#
directive|define
name|UPNP_CACHE_SEC
value|(UPNP_CACHE_SEC_MIN + 1)
end_define

begin_comment
comment|/* cache time we use */
end_comment

begin_define
define|#
directive|define
name|UPNP_CACHE_SEC_MIN
value|1800
end_define

begin_comment
comment|/* min cachable time per UPnP standard */
end_comment

begin_define
define|#
directive|define
name|UPNP_ADVERTISE_REPEAT
value|2
end_define

begin_comment
comment|/* no more than 3 */
end_comment

begin_define
define|#
directive|define
name|MAX_MSEARCH
value|20
end_define

begin_comment
comment|/* max simultaneous M-SEARCH replies ongoing */
end_comment

begin_define
define|#
directive|define
name|SSDP_TARGET
value|"239.0.0.0"
end_define

begin_define
define|#
directive|define
name|SSDP_NETMASK
value|"255.0.0.0"
end_define

begin_comment
comment|/* Check tokens for equality, where tokens consist of letters, digits,  * underscore and hyphen, and are matched case insensitive.  */
end_comment

begin_function
specifier|static
name|int
name|token_eq
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|int
name|c1
decl_stmt|;
name|int
name|c2
decl_stmt|;
name|int
name|end1
init|=
literal|0
decl_stmt|;
name|int
name|end2
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c1
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
name|c2
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c1
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c1
argument_list|)
condition|)
name|c1
operator|=
name|tolower
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c2
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c2
argument_list|)
condition|)
name|c2
operator|=
name|tolower
argument_list|(
name|c2
argument_list|)
expr_stmt|;
name|end1
operator|=
operator|!
operator|(
name|isalnum
argument_list|(
name|c1
argument_list|)
operator|||
name|c1
operator|==
literal|'_'
operator|||
name|c1
operator|==
literal|'-'
operator|)
expr_stmt|;
name|end2
operator|=
operator|!
operator|(
name|isalnum
argument_list|(
name|c2
argument_list|)
operator|||
name|c2
operator|==
literal|'_'
operator|||
name|c2
operator|==
literal|'-'
operator|)
expr_stmt|;
if|if
condition|(
name|end1
operator|||
name|end2
operator|||
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
return|return
name|end1
operator|&&
name|end2
return|;
comment|/* reached end of both words? */
block|}
end_function

begin_comment
comment|/* Return length of token (see above for definition of token) */
end_comment

begin_function
specifier|static
name|int
name|token_length
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|begin
init|=
name|s
decl_stmt|;
for|for
control|(
init|;
condition|;
name|s
operator|++
control|)
block|{
name|int
name|c
init|=
operator|*
name|s
decl_stmt|;
name|int
name|end
init|=
operator|!
operator|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'-'
operator|)
decl_stmt|;
if|if
condition|(
name|end
condition|)
break|break;
block|}
return|return
name|s
operator|-
name|begin
return|;
block|}
end_function

begin_comment
comment|/* return length of interword separation.  * This accepts only spaces/tabs and thus will not traverse a line  * or buffer ending.  */
end_comment

begin_function
specifier|static
name|int
name|word_separation_length
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|begin
init|=
name|s
decl_stmt|;
for|for
control|(
init|;
condition|;
name|s
operator|++
control|)
block|{
name|int
name|c
init|=
operator|*
name|s
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
continue|continue;
break|break;
block|}
return|return
name|s
operator|-
name|begin
return|;
block|}
end_function

begin_comment
comment|/* No. of chars through (including) end of line */
end_comment

begin_function
specifier|static
name|int
name|line_length
parameter_list|(
specifier|const
name|char
modifier|*
name|l
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|lp
init|=
name|l
decl_stmt|;
while|while
condition|(
operator|*
name|lp
operator|&&
operator|*
name|lp
operator|!=
literal|'\n'
condition|)
name|lp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|lp
operator|==
literal|'\n'
condition|)
name|lp
operator|++
expr_stmt|;
return|return
name|lp
operator|-
name|l
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_starts
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|)
block|{
return|return
name|os_strncmp
argument_list|(
name|str
argument_list|,
name|start
argument_list|,
name|os_strlen
argument_list|(
name|start
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * Advertisements.  * These are multicast to the world to tell them we are here.  * The individual packets are spread out in time to limit loss,  * and then after a much longer period of time the whole sequence  * is repeated again (for NOTIFYs only).  **************************************************************************/
end_comment

begin_comment
comment|/**  * next_advertisement - Build next message and advance the state machine  * @a: Advertisement state  * @islast: Buffer for indicating whether this is the last message (= 1)  * Returns: The new message (caller is responsible for freeing this)  *  * Note: next_advertisement is shared code with msearchreply_* functions  */
end_comment

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|next_advertisement
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|advertisement_state_machine
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|islast
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|NTString
init|=
literal|""
decl_stmt|;
name|char
name|uuid_string
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|upnp_wps_device_interface
modifier|*
name|iface
decl_stmt|;
operator|*
name|islast
operator|=
literal|0
expr_stmt|;
name|iface
operator|=
name|dl_list_first
argument_list|(
operator|&
name|sm
operator|->
name|interfaces
argument_list|,
expr|struct
name|upnp_wps_device_interface
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|uuid_bin2str
argument_list|(
name|iface
operator|->
name|wps
operator|->
name|uuid
argument_list|,
name|uuid_string
argument_list|,
sizeof|sizeof
argument_list|(
name|uuid_string
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|wpabuf_alloc
argument_list|(
literal|800
argument_list|)
expr_stmt|;
comment|/* more than big enough */
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
name|a
operator|->
name|type
condition|)
block|{
case|case
name|ADVERTISE_UP
case|:
case|case
name|ADVERTISE_DOWN
case|:
name|NTString
operator|=
literal|"NT"
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|msg
argument_list|,
literal|"NOTIFY * HTTP/1.1\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"HOST: %s:%d\r\n"
argument_list|,
name|UPNP_MULTICAST_ADDRESS
argument_list|,
name|UPNP_MULTICAST_PORT
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"CACHE-CONTROL: max-age=%d\r\n"
argument_list|,
name|UPNP_CACHE_SEC
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"NTS: %s\r\n"
argument_list|,
operator|(
name|a
operator|->
name|type
operator|==
name|ADVERTISE_UP
condition|?
literal|"ssdp:alive"
else|:
literal|"ssdp:byebye"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSEARCH_REPLY
case|:
name|NTString
operator|=
literal|"ST"
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|msg
argument_list|,
literal|"HTTP/1.1 200 OK\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"CACHE-CONTROL: max-age=%d\r\n"
argument_list|,
name|UPNP_CACHE_SEC
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|msg
argument_list|,
literal|"DATE: "
argument_list|)
expr_stmt|;
name|format_date
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|msg
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|msg
argument_list|,
literal|"EXT:\r\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|a
operator|->
name|type
operator|!=
name|ADVERTISE_DOWN
condition|)
block|{
comment|/* Where others may get our XML files from */
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"LOCATION: http://%s:%d/%s\r\n"
argument_list|,
name|sm
operator|->
name|ip_addr_text
argument_list|,
name|sm
operator|->
name|web_port
argument_list|,
name|UPNP_WPS_DEVICE_XML_FILE
argument_list|)
expr_stmt|;
block|}
comment|/* The SERVER line has three comma-separated fields: 	 *      operating system / version 	 *      upnp version 	 *      software package / version 	 * However, only the UPnP version is really required, the 	 * others can be place holders... for security reasons 	 * it is better to NOT provide extra information. 	 */
name|wpabuf_put_str
argument_list|(
name|msg
argument_list|,
literal|"SERVER: Unspecified, UPnP/1.0, Unspecified\r\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|state
operator|/
name|UPNP_ADVERTISE_REPEAT
condition|)
block|{
case|case
literal|0
case|:
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"%s: upnp:rootdevice\r\n"
argument_list|,
name|NTString
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"USN: uuid:%s::upnp:rootdevice\r\n"
argument_list|,
name|uuid_string
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"%s: uuid:%s\r\n"
argument_list|,
name|NTString
argument_list|,
name|uuid_string
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"USN: uuid:%s\r\n"
argument_list|,
name|uuid_string
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"%s: urn:schemas-wifialliance-org:device:"
literal|"WFADevice:1\r\n"
argument_list|,
name|NTString
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"USN: uuid:%s::urn:schemas-wifialliance-"
literal|"org:device:WFADevice:1\r\n"
argument_list|,
name|uuid_string
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"%s: urn:schemas-wifialliance-org:service:"
literal|"WFAWLANConfig:1\r\n"
argument_list|,
name|NTString
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|msg
argument_list|,
literal|"USN: uuid:%s::urn:schemas-wifialliance-"
literal|"org:service:WFAWLANConfig:1\r\n"
argument_list|,
name|uuid_string
argument_list|)
expr_stmt|;
break|break;
block|}
name|wpabuf_put_str
argument_list|(
name|msg
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|state
operator|+
literal|1
operator|>=
literal|4
operator|*
name|UPNP_ADVERTISE_REPEAT
condition|)
operator|*
name|islast
operator|=
literal|1
expr_stmt|;
return|return
name|msg
return|;
name|fail
label|:
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|advertisement_state_machine_handler
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * advertisement_state_machine_stop - Stop SSDP advertisements  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * @send_byebye: Send byebye advertisement messages immediately  */
end_comment

begin_function
name|void
name|advertisement_state_machine_stop
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|int
name|send_byebye
parameter_list|)
block|{
name|struct
name|advertisement_state_machine
modifier|*
name|a
init|=
operator|&
name|sm
operator|->
name|advertisement
decl_stmt|;
name|int
name|islast
init|=
literal|0
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|struct
name|sockaddr_in
name|dest
decl_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|advertisement_state_machine_handler
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|send_byebye
operator|||
name|sm
operator|->
name|multicast_sd
operator|<
literal|0
condition|)
return|return;
name|a
operator|->
name|type
operator|=
name|ADVERTISE_DOWN
expr_stmt|;
name|a
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|dest
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dest
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|UPNP_MULTICAST_ADDRESS
argument_list|)
expr_stmt|;
name|dest
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|UPNP_MULTICAST_PORT
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|islast
condition|)
block|{
name|msg
operator|=
name|next_advertisement
argument_list|(
name|sm
argument_list|,
name|a
argument_list|,
operator|&
name|islast
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|sendto
argument_list|(
name|sm
operator|->
name|multicast_sd
argument_list|,
name|wpabuf_head
argument_list|(
name|msg
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Advertisement sendto "
literal|"failed: %d (%s)"
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|a
operator|->
name|state
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|advertisement_state_machine_handler
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|user_ctx
decl_stmt|;
name|struct
name|advertisement_state_machine
modifier|*
name|a
init|=
operator|&
name|sm
operator|->
name|advertisement
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|int
name|next_timeout_msec
init|=
literal|100
decl_stmt|;
name|int
name|next_timeout_sec
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in
name|dest
decl_stmt|;
name|int
name|islast
init|=
literal|0
decl_stmt|;
comment|/* 	 * Each is sent twice (in case lost) w/ 100 msec delay between; 	 * spec says no more than 3 times. 	 * One pair for rootdevice, one pair for uuid, and a pair each for 	 * each of the two urns. 	 * The entire sequence must be repeated before cache control timeout 	 * (which  is min  1800 seconds), 	 * recommend random portion of half of the advertised cache control age 	 * to ensure against loss... perhaps 1800/4 + rand*1800/4 ? 	 * Delay random interval< 100 msec prior to initial sending. 	 * TTL of 4 	 */
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"WPS UPnP: Advertisement state=%d"
argument_list|,
name|a
operator|->
name|state
argument_list|)
expr_stmt|;
name|msg
operator|=
name|next_advertisement
argument_list|(
name|sm
argument_list|,
name|a
argument_list|,
operator|&
name|islast
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
name|os_memset
argument_list|(
operator|&
name|dest
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dest
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|UPNP_MULTICAST_ADDRESS
argument_list|)
expr_stmt|;
name|dest
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|UPNP_MULTICAST_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sm
operator|->
name|multicast_sd
argument_list|,
name|wpabuf_head
argument_list|(
name|msg
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"WPS UPnP: Advertisement sendto failed:"
literal|"%d (%s)"
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|next_timeout_msec
operator|=
literal|0
expr_stmt|;
name|next_timeout_sec
operator|=
literal|10
expr_stmt|;
comment|/* ... later */
block|}
elseif|else
if|if
condition|(
name|islast
condition|)
block|{
name|a
operator|->
name|state
operator|=
literal|0
expr_stmt|;
comment|/* wrap around */
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|ADVERTISE_DOWN
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: ADVERTISE_DOWN->UP"
argument_list|)
expr_stmt|;
name|a
operator|->
name|type
operator|=
name|ADVERTISE_UP
expr_stmt|;
comment|/* do it all over again right away */
block|}
else|else
block|{
name|u16
name|r
decl_stmt|;
comment|/* 			 * Start over again after a long timeout 			 * (see notes above) 			 */
name|next_timeout_msec
operator|=
literal|0
expr_stmt|;
name|os_get_random
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|next_timeout_sec
operator|=
name|UPNP_CACHE_SEC
operator|/
literal|4
operator|+
operator|(
operator|(
operator|(
name|UPNP_CACHE_SEC
operator|/
literal|4
operator|)
operator|*
name|r
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
name|sm
operator|->
name|advertise_count
operator|++
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: ADVERTISE_UP (#%u); "
literal|"next in %d sec"
argument_list|,
name|sm
operator|->
name|advertise_count
argument_list|,
name|next_timeout_sec
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|a
operator|->
name|state
operator|++
expr_stmt|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|next_timeout_sec
argument_list|,
name|next_timeout_msec
argument_list|,
name|advertisement_state_machine_handler
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * advertisement_state_machine_start - Start SSDP advertisements  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * Returns: 0 on success, -1 on failure  */
end_comment

begin_function
name|int
name|advertisement_state_machine_start
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|advertisement_state_machine
modifier|*
name|a
init|=
operator|&
name|sm
operator|->
name|advertisement
decl_stmt|;
name|int
name|next_timeout_msec
decl_stmt|;
name|advertisement_state_machine_stop
argument_list|(
name|sm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Start out advertising down, this automatically switches 	 * to advertising up which signals our restart. 	 */
name|a
operator|->
name|type
operator|=
name|ADVERTISE_DOWN
expr_stmt|;
name|a
operator|->
name|state
operator|=
literal|0
expr_stmt|;
comment|/* (other fields not used here) */
comment|/* First timeout should be random interval< 100 msec */
name|next_timeout_msec
operator|=
operator|(
literal|100
operator|*
operator|(
name|os_random
argument_list|()
operator|&
literal|0xFF
operator|)
operator|)
operator|>>
literal|8
expr_stmt|;
return|return
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
name|next_timeout_msec
argument_list|,
name|advertisement_state_machine_handler
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * M-SEARCH replies  * These are very similar to the multicast advertisements, with some  * small changes in data content; and they are sent (UDP) to a specific  * unicast address instead of multicast.  * They are sent in response to a UDP M-SEARCH packet.  **************************************************************************/
end_comment

begin_comment
comment|/**  * msearchreply_state_machine_stop - Stop M-SEARCH reply state machine  * @a: Selected advertisement/reply state  */
end_comment

begin_function
name|void
name|msearchreply_state_machine_stop
parameter_list|(
name|struct
name|advertisement_state_machine
modifier|*
name|a
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: M-SEARCH stop"
argument_list|)
expr_stmt|;
name|dl_list_del
argument_list|(
operator|&
name|a
operator|->
name|list
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msearchreply_state_machine_handler
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
block|{
name|struct
name|advertisement_state_machine
modifier|*
name|a
init|=
name|user_ctx
decl_stmt|;
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|eloop_data
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|int
name|next_timeout_msec
init|=
literal|100
decl_stmt|;
name|int
name|next_timeout_sec
init|=
literal|0
decl_stmt|;
name|int
name|islast
init|=
literal|0
decl_stmt|;
comment|/* 	 * Each response is sent twice (in case lost) w/ 100 msec delay 	 * between; spec says no more than 3 times. 	 * One pair for rootdevice, one pair for uuid, and a pair each for 	 * each of the two urns. 	 */
comment|/* TODO: should only send the requested response types */
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"WPS UPnP: M-SEARCH reply state=%d (%s:%d)"
argument_list|,
name|a
operator|->
name|state
argument_list|,
name|inet_ntoa
argument_list|(
name|a
operator|->
name|client
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|a
operator|->
name|client
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|next_advertisement
argument_list|(
name|sm
argument_list|,
name|a
argument_list|,
operator|&
name|islast
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Send it on the multicast socket to avoid having to set up another 	 * socket. 	 */
if|if
condition|(
name|sendto
argument_list|(
name|sm
operator|->
name|multicast_sd
argument_list|,
name|wpabuf_head
argument_list|(
name|msg
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|a
operator|->
name|client
argument_list|,
sizeof|sizeof
argument_list|(
name|a
operator|->
name|client
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: M-SEARCH reply sendto "
literal|"errno %d (%s) for %s:%d"
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|inet_ntoa
argument_list|(
name|a
operator|->
name|client
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|a
operator|->
name|client
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore error and hope for the best */
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|islast
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: M-SEARCH reply done"
argument_list|)
expr_stmt|;
name|msearchreply_state_machine_stop
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|a
operator|->
name|state
operator|++
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"WPS UPnP: M-SEARCH reply in %d.%03d sec"
argument_list|,
name|next_timeout_sec
argument_list|,
name|next_timeout_msec
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|next_timeout_sec
argument_list|,
name|next_timeout_msec
argument_list|,
name|msearchreply_state_machine_handler
argument_list|,
name|sm
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * msearchreply_state_machine_start - Reply to M-SEARCH discovery request  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * @client: Client address  * @mx: Maximum delay in seconds  *  * Use TTL of 4 (this was done when socket set up).  * A response should be given in randomized portion of min(MX,120) seconds  *  * UPnP-arch-DeviceArchitecture, 1.2.3:  * To be found, a device must send a UDP response to the source IP address and  * port that sent the request to the multicast channel. Devices respond if the  * ST header of the M-SEARCH request is "ssdp:all", "upnp:rootdevice", "uuid:"  * followed by a UUID that exactly matches one advertised by the device.  */
end_comment

begin_function
specifier|static
name|void
name|msearchreply_state_machine_start
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|client
parameter_list|,
name|int
name|mx
parameter_list|)
block|{
name|struct
name|advertisement_state_machine
modifier|*
name|a
decl_stmt|;
name|int
name|next_timeout_sec
decl_stmt|;
name|int
name|next_timeout_msec
decl_stmt|;
name|int
name|replies
decl_stmt|;
name|replies
operator|=
name|dl_list_len
argument_list|(
operator|&
name|sm
operator|->
name|msearch_replies
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: M-SEARCH reply start (%d "
literal|"outstanding)"
argument_list|,
name|replies
argument_list|)
expr_stmt|;
if|if
condition|(
name|replies
operator|>=
name|MAX_MSEARCH
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Too many outstanding "
literal|"M-SEARCH replies"
argument_list|)
expr_stmt|;
return|return;
block|}
name|a
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return;
name|a
operator|->
name|type
operator|=
name|MSEARCH_REPLY
expr_stmt|;
name|a
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|os_memcpy
argument_list|(
operator|&
name|a
operator|->
name|client
argument_list|,
name|client
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wait time depending on MX value */
name|next_timeout_msec
operator|=
operator|(
literal|1000
operator|*
name|mx
operator|*
operator|(
name|os_random
argument_list|()
operator|&
literal|0xFF
operator|)
operator|)
operator|>>
literal|8
expr_stmt|;
name|next_timeout_sec
operator|=
name|next_timeout_msec
operator|/
literal|1000
expr_stmt|;
name|next_timeout_msec
operator|=
name|next_timeout_msec
operator|%
literal|1000
expr_stmt|;
if|if
condition|(
name|eloop_register_timeout
argument_list|(
name|next_timeout_sec
argument_list|,
name|next_timeout_msec
argument_list|,
name|msearchreply_state_machine_handler
argument_list|,
name|sm
argument_list|,
name|a
argument_list|)
condition|)
block|{
comment|/* No way to recover (from malloc failure) */
goto|goto
name|fail
goto|;
block|}
comment|/* Remember for future cleanup */
name|dl_list_add
argument_list|(
operator|&
name|sm
operator|->
name|msearch_replies
argument_list|,
operator|&
name|a
operator|->
name|list
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: M-SEARCH reply failure!"
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|msearchreply_state_machine_handler
argument_list|,
name|sm
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ssdp_parse_msearch - Process a received M-SEARCH  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * @client: Client address  * @data: NULL terminated M-SEARCH message  *  * Given that we have received a header w/ M-SEARCH, act upon it  *  * Format of M-SEARCH (case insensitive!):  *  * First line must be:  *      M-SEARCH * HTTP/1.1  * Other lines in arbitrary order:  *      HOST:239.255.255.250:1900  *      ST:<varies -- must match>  *      MAN:"ssdp:discover"  *      MX:<varies>  *  * It should be noted that when Microsoft Vista is still learning its IP  * address, it sends out host lines like: HOST:[FF02::C]:1900  */
end_comment

begin_function
specifier|static
name|void
name|ssdp_parse_msearch
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|client
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CONFIG_NO_STDOUT_DEBUG
specifier|const
name|char
modifier|*
name|start
init|=
name|data
decl_stmt|;
endif|#
directive|endif
comment|/* CONFIG_NO_STDOUT_DEBUG */
name|int
name|got_host
init|=
literal|0
decl_stmt|;
name|int
name|got_st
init|=
literal|0
decl_stmt|,
name|st_match
init|=
literal|0
decl_stmt|;
name|int
name|got_man
init|=
literal|0
decl_stmt|;
name|int
name|got_mx
init|=
literal|0
decl_stmt|;
name|int
name|mx
init|=
literal|0
decl_stmt|;
comment|/* 	 * Skip first line M-SEARCH * HTTP/1.1 	 * (perhaps we should check remainder of the line for syntax) 	 */
name|data
operator|+=
name|line_length
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Parse remaining lines */
for|for
control|(
init|;
operator|*
name|data
operator|!=
literal|'\0'
condition|;
name|data
operator|+=
name|line_length
argument_list|(
name|data
argument_list|)
control|)
block|{
if|if
condition|(
name|token_eq
argument_list|(
name|data
argument_list|,
literal|"host"
argument_list|)
condition|)
block|{
comment|/* The host line indicates who the packet 			 * is addressed to... but do we really care? 			 * Note that Microsoft sometimes does funny 			 * stuff with the HOST: line. 			 */
if|#
directive|if
literal|0
comment|/* could be */
block|data += token_length(data); 			data += word_separation_length(data); 			if (*data != ':') 				goto bad; 			data++; 			data += word_separation_length(data);
comment|/* UPNP_MULTICAST_ADDRESS */
block|if (!str_starts(data, "239.255.255.250")) 				goto bad; 			data += os_strlen("239.255.255.250"); 			if (*data == ':') { 				if (!str_starts(data, ":1900")) 					goto bad; 			}
endif|#
directive|endif
comment|/* could be */
name|got_host
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|token_eq
argument_list|(
name|data
argument_list|,
literal|"st"
argument_list|)
condition|)
block|{
comment|/* There are a number of forms; we look 			 * for one that matches our case. 			 */
name|got_st
operator|=
literal|1
expr_stmt|;
name|data
operator|+=
name|token_length
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
name|word_separation_length
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|!=
literal|':'
condition|)
continue|continue;
name|data
operator|++
expr_stmt|;
name|data
operator|+=
name|word_separation_length
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_starts
argument_list|(
name|data
argument_list|,
literal|"ssdp:all"
argument_list|)
condition|)
block|{
name|st_match
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|str_starts
argument_list|(
name|data
argument_list|,
literal|"upnp:rootdevice"
argument_list|)
condition|)
block|{
name|st_match
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|str_starts
argument_list|(
name|data
argument_list|,
literal|"uuid:"
argument_list|)
condition|)
block|{
name|char
name|uuid_string
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|upnp_wps_device_interface
modifier|*
name|iface
decl_stmt|;
name|iface
operator|=
name|dl_list_first
argument_list|(
operator|&
name|sm
operator|->
name|interfaces
argument_list|,
expr|struct
name|upnp_wps_device_interface
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|data
operator|+=
name|os_strlen
argument_list|(
literal|"uuid:"
argument_list|)
expr_stmt|;
name|uuid_bin2str
argument_list|(
name|iface
operator|->
name|wps
operator|->
name|uuid
argument_list|,
name|uuid_string
argument_list|,
sizeof|sizeof
argument_list|(
name|uuid_string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_starts
argument_list|(
name|data
argument_list|,
name|uuid_string
argument_list|)
condition|)
name|st_match
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
comment|/* FIX: should we really reply to IGD string? */
block|if (str_starts(data, "urn:schemas-upnp-org:device:" 				       "InternetGatewayDevice:1")) { 				st_match = 1; 				continue; 			}
endif|#
directive|endif
if|if
condition|(
name|str_starts
argument_list|(
name|data
argument_list|,
literal|"urn:schemas-wifialliance-org:"
literal|"service:WFAWLANConfig:1"
argument_list|)
condition|)
block|{
name|st_match
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|str_starts
argument_list|(
name|data
argument_list|,
literal|"urn:schemas-wifialliance-org:"
literal|"device:WFADevice:1"
argument_list|)
condition|)
block|{
name|st_match
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|token_eq
argument_list|(
name|data
argument_list|,
literal|"man"
argument_list|)
condition|)
block|{
name|data
operator|+=
name|token_length
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
name|word_separation_length
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|!=
literal|':'
condition|)
continue|continue;
name|data
operator|++
expr_stmt|;
name|data
operator|+=
name|word_separation_length
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str_starts
argument_list|(
name|data
argument_list|,
literal|"\"ssdp:discover\""
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Unexpected "
literal|"M-SEARCH man-field"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|got_man
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|token_eq
argument_list|(
name|data
argument_list|,
literal|"mx"
argument_list|)
condition|)
block|{
name|data
operator|+=
name|token_length
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
name|word_separation_length
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|!=
literal|':'
condition|)
continue|continue;
name|data
operator|++
expr_stmt|;
name|data
operator|+=
name|word_separation_length
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mx
operator|=
name|atol
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|got_mx
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* ignore anything else */
block|}
if|if
condition|(
operator|!
name|got_host
operator|||
operator|!
name|got_st
operator|||
operator|!
name|got_man
operator|||
operator|!
name|got_mx
operator|||
name|mx
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Invalid M-SEARCH: %d %d %d "
literal|"%d mx=%d"
argument_list|,
name|got_host
argument_list|,
name|got_st
argument_list|,
name|got_man
argument_list|,
name|got_mx
argument_list|,
name|mx
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|st_match
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Ignored M-SEARCH (no ST "
literal|"match)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mx
operator|>
literal|120
condition|)
name|mx
operator|=
literal|120
expr_stmt|;
comment|/* UPnP-arch-DeviceArchitecture, 1.2.3 */
name|msearchreply_state_machine_start
argument_list|(
name|sm
argument_list|,
name|client
argument_list|,
name|mx
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Failed to parse M-SEARCH"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"WPS UPnP: M-SEARCH data:\n%s"
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Listening for (UDP) discovery (M-SEARCH) packets */
end_comment

begin_comment
comment|/**  * ssdp_listener_stop - Stop SSDP listered  * @sm: WPS UPnP state machine from upnp_wps_device_init()  *  * This function stops the SSDP listener that was started by calling  * ssdp_listener_start().  */
end_comment

begin_function
name|void
name|ssdp_listener_stop
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|ssdp_sd_registered
condition|)
block|{
name|eloop_unregister_sock
argument_list|(
name|sm
operator|->
name|ssdp_sd
argument_list|,
name|EVENT_TYPE_READ
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ssdp_sd_registered
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|ssdp_sd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sm
operator|->
name|ssdp_sd
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ssdp_sd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|eloop_cancel_timeout
argument_list|(
name|msearchreply_state_machine_handler
argument_list|,
name|sm
argument_list|,
name|ELOOP_ALL_CTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssdp_listener_handler
parameter_list|(
name|int
name|sd
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|sock_ctx
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
comment|/* client address */
name|socklen_t
name|addr_len
decl_stmt|;
name|int
name|nread
decl_stmt|;
name|char
name|buf
index|[
name|MULTICAST_MAX_READ
index|]
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
name|addr_len
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|nread
operator|=
name|recvfrom
argument_list|(
name|sm
operator|->
name|ssdp_sd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
return|return;
name|buf
index|[
name|nread
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* need null termination for algorithm */
if|if
condition|(
name|str_starts
argument_list|(
name|buf
argument_list|,
literal|"NOTIFY "
argument_list|)
condition|)
block|{
comment|/* 		 * Silently ignore NOTIFYs to avoid filling debug log with 		 * unwanted messages. 		 */
return|return;
block|}
name|pos
operator|=
name|os_strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
condition|)
operator|*
name|pos
operator|=
literal|'\0'
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"WPS UPnP: Received SSDP packet from %s:%d: "
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
condition|)
operator|*
name|pos
operator|=
literal|'\n'
expr_stmt|;
comment|/* Parse first line */
if|if
condition|(
name|os_strncasecmp
argument_list|(
name|buf
argument_list|,
literal|"M-SEARCH"
argument_list|,
name|os_strlen
argument_list|(
literal|"M-SEARCH"
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|isgraph
argument_list|(
name|buf
index|[
name|strlen
argument_list|(
literal|"M-SEARCH"
argument_list|)
index|]
argument_list|)
condition|)
block|{
name|ssdp_parse_msearch
argument_list|(
name|sm
argument_list|,
operator|&
name|addr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Ignore anything else */
block|}
end_function

begin_function
name|int
name|ssdp_listener_open
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|struct
name|ip_mreq
name|mcast_addr
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
comment|/* per UPnP spec, keep IP packet time to live (TTL) small */
name|unsigned
name|char
name|ttl
init|=
literal|4
decl_stmt|;
name|int
name|sd
decl_stmt|;
name|sd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|fcntl
argument_list|(
name|sd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|os_memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|UPNP_MULTICAST_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|os_memset
argument_list|(
operator|&
name|mcast_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mcast_addr
argument_list|)
argument_list|)
expr_stmt|;
name|mcast_addr
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|mcast_addr
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|UPNP_MULTICAST_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mcast_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|mcast_addr
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_TTL
argument_list|,
operator|&
name|ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|ttl
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
return|return
name|sd
return|;
name|fail
label|:
if|if
condition|(
name|sd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * ssdp_listener_start - Set up for receiving discovery (UDP) packets  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * Returns: 0 on success, -1 on failure  *  * The SSDP listener is stopped by calling ssdp_listener_stop().  */
end_comment

begin_function
name|int
name|ssdp_listener_start
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
name|sm
operator|->
name|ssdp_sd
operator|=
name|ssdp_listener_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|eloop_register_sock
argument_list|(
name|sm
operator|->
name|ssdp_sd
argument_list|,
name|EVENT_TYPE_READ
argument_list|,
name|ssdp_listener_handler
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|sm
operator|->
name|ssdp_sd_registered
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
comment|/* Error */
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"WPS UPnP: ssdp_listener_start failed"
argument_list|)
expr_stmt|;
name|ssdp_listener_stop
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * add_ssdp_network - Add routing entry for SSDP  * @net_if: Selected network interface name  * Returns: 0 on success, -1 on failure  *  * This function assures that the multicast address will be properly  * handled by Linux networking code (by a modification to routing tables).  * This must be done per network interface. It really only needs to be done  * once after booting up, but it does not hurt to call this more frequently  * "to be safe".  */
end_comment

begin_function
name|int
name|add_ssdp_network
parameter_list|(
specifier|const
name|char
modifier|*
name|net_if
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__linux__
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|sock
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|rtentry
name|rt
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
if|if
condition|(
operator|!
name|net_if
condition|)
goto|goto
name|fail
goto|;
name|os_memset
argument_list|(
operator|&
name|rt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rt
argument_list|)
argument_list|)
expr_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|rt
operator|.
name|rt_dev
operator|=
operator|(
name|char
operator|*
operator|)
name|net_if
expr_stmt|;
name|sin
operator|=
name|aliasing_hide_typecast
argument_list|(
operator|&
name|rt
operator|.
name|rt_dst
argument_list|,
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|SSDP_TARGET
argument_list|)
expr_stmt|;
name|sin
operator|=
name|aliasing_hide_typecast
argument_list|(
operator|&
name|rt
operator|.
name|rt_genmask
argument_list|,
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|SSDP_NETMASK
argument_list|)
expr_stmt|;
name|rt
operator|.
name|rt_flags
operator|=
name|RTF_UP
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCADDRT
argument_list|,
operator|&
name|rt
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"add_ssdp_network: No "
literal|"permissions to add routing table entry"
argument_list|)
expr_stmt|;
comment|/* Continue to allow testing as non-root */
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"add_ssdp_network() ioctl errno "
literal|"%d (%s)"
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|sock
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
else|#
directive|else
comment|/* __linux__ */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* __linux__ */
block|}
end_function

begin_function
name|int
name|ssdp_open_multicast_sock
parameter_list|(
name|u32
name|ip_addr
parameter_list|)
block|{
name|int
name|sd
decl_stmt|;
comment|/* per UPnP-arch-DeviceArchitecture, 1. Discovery, keep IP packet 	  * time to live (TTL) small */
name|unsigned
name|char
name|ttl
init|=
literal|4
decl_stmt|;
name|sd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
literal|0
comment|/* maybe ok if we sometimes block on writes */
block|if (fcntl(sd, F_SETFL, O_NONBLOCK) != 0) { 		close(sd); 		return -1; 	}
endif|#
directive|endif
if|if
condition|(
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_IF
argument_list|,
operator|&
name|ip_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ip_addr
argument_list|)
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS: setsockopt(IP_MULTICAST_IF) %x: "
literal|"%d (%s)"
argument_list|,
name|ip_addr
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_TTL
argument_list|,
operator|&
name|ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|ttl
argument_list|)
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS: setsockopt(IP_MULTICAST_TTL): "
literal|"%d (%s)"
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
literal|0
comment|/* not needed, because we don't receive using multicast_sd */
block|{ 		struct ip_mreq mreq; 		mreq.imr_multiaddr.s_addr = inet_addr(UPNP_MULTICAST_ADDRESS); 		mreq.imr_interface.s_addr = ip_addr; 		wpa_printf(MSG_DEBUG, "WPS UPnP: Multicast addr 0x%x if addr " 			   "0x%x", 			   mreq.imr_multiaddr.s_addr, 			   mreq.imr_interface.s_addr); 		if (setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP,&mreq, 				sizeof(mreq))) { 			wpa_printf(MSG_ERROR, 				   "WPS UPnP: setsockopt " 				   "IP_ADD_MEMBERSHIP errno %d (%s)", 				   errno, strerror(errno)); 			close(sd); 			return -1; 		} 	}
endif|#
directive|endif
comment|/* not needed */
comment|/* 	 * TODO: What about IP_MULTICAST_LOOP? It seems to be on by default? 	 * which aids debugging I suppose but isn't really necessary? 	 */
return|return
name|sd
return|;
block|}
end_function

begin_comment
comment|/**  * ssdp_open_multicast - Open socket for sending multicast SSDP messages  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * Returns: 0 on success, -1 on failure  */
end_comment

begin_function
name|int
name|ssdp_open_multicast
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
name|sm
operator|->
name|multicast_sd
operator|=
name|ssdp_open_multicast_sock
argument_list|(
name|sm
operator|->
name|ip_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|multicast_sd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

