begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * UPnP WPS Device - Web connections  * Copyright (c) 2000-2003 Intel Corporation  * Copyright (c) 2006-2007 Sony Corporation  * Copyright (c) 2008-2009 Atheros Communications  * Copyright (c) 2009, Jouni Malinen<j@w1.fi>  *  * See wps_upnp.c for more details on licensing and code history.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"base64.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"uuid.h"
end_include

begin_include
include|#
directive|include
file|"httpread.h"
end_include

begin_include
include|#
directive|include
file|"wps_i.h"
end_include

begin_include
include|#
directive|include
file|"wps_upnp.h"
end_include

begin_include
include|#
directive|include
file|"wps_upnp_i.h"
end_include

begin_comment
comment|/***************************************************************************  * Web connections (we serve pages of info about ourselves, handle  * requests, etc. etc.).  **************************************************************************/
end_comment

begin_define
define|#
directive|define
name|WEB_CONNECTION_TIMEOUT_SEC
value|30
end_define

begin_comment
comment|/* Drop web connection after t.o. */
end_comment

begin_define
define|#
directive|define
name|WEB_CONNECTION_MAX_READ
value|8000
end_define

begin_comment
comment|/* Max we'll read for TCP request */
end_comment

begin_define
define|#
directive|define
name|MAX_WEB_CONNECTIONS
value|10
end_define

begin_comment
comment|/* max simultaneous web connects */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|urn_wfawlanconfig
init|=
literal|"urn:schemas-wifialliance-org:service:WFAWLANConfig:1"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|http_server_hdr
init|=
literal|"Server: unspecified, UPnP/1.0, unspecified\r\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|http_connection_close
init|=
literal|"Connection: close\r\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Incoming web connections are recorded in this struct.  * A web connection is a TCP connection to us, the server;  * it is called a "web connection" because we use http and serve  * data that looks like web pages.  * State information is need to track the connection until we figure  * out what they want and what we want to do about it.  */
end_comment

begin_struct
struct|struct
name|web_connection
block|{
comment|/* double linked list */
name|struct
name|web_connection
modifier|*
name|next
decl_stmt|;
name|struct
name|web_connection
modifier|*
name|prev
decl_stmt|;
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
decl_stmt|;
comment|/* parent */
name|int
name|sd
decl_stmt|;
comment|/* socket to read from */
name|struct
name|sockaddr_in
name|cli_addr
decl_stmt|;
name|int
name|sd_registered
decl_stmt|;
comment|/* nonzero if we must cancel registration */
name|struct
name|httpread
modifier|*
name|hread
decl_stmt|;
comment|/* state machine for reading socket */
name|int
name|n_rcvd_data
decl_stmt|;
comment|/* how much data read so far */
name|int
name|done
decl_stmt|;
comment|/* internal flag, set when we've finished */
block|}
struct|;
end_struct

begin_comment
comment|/*  * XML parsing and formatting  *  * XML is a markup language based on unicode; usually (and in our case,  * always!) based on utf-8. utf-8 uses a variable number of bytes per  * character. utf-8 has the advantage that all non-ASCII unicode characters are  * represented by sequences of non-ascii (high bit set) bytes, whereas ASCII  * characters are single ascii bytes, thus we can use typical text processing.  *  * (One other interesting thing about utf-8 is that it is possible to look at  * any random byte and determine if it is the first byte of a character as  * versus a continuation byte).  *  * The base syntax of XML uses a few ASCII punctionation characters; any  * characters that would appear in the payload data are rewritten using  * sequences, e.g.,&amp; for ampersand(&) and&lt for left angle bracket (<).  * Five such escapes total (more can be defined but that does not apply to our  * case). Thus we can safely parse for angle brackets etc.  *  * XML describes tree structures of tagged data, with each element beginning  * with an opening tag<label> and ending with a closing tag</label> with  * matching label. (There is also a self-closing tag<label/> which is supposed  * to be equivalent to<label></label>, i.e., no payload, but we are unlikely  * to see it for our purpose).  *  * Actually the opening tags are a little more complicated because they can  * contain "attributes" after the label (delimited by ascii space or tab chars)  * of the form attribute_label="value" or attribute_label='value'; as it turns  * out we do not have to read any of these attributes, just ignore them.  *  * Labels are any sequence of chars other than space, tab, right angle bracket  * (and ?), but may have an inner structure of<namespace><colon><plain_label>.  * As it turns out, we can ignore the namespaces, in fact we can ignore the  * entire tree hierarchy, because the plain labels we are looking for will be  * unique (not in general, but for this application). We do however have to be  * careful to skip over the namespaces.  *  * In generating XML we have to be more careful, but that is easy because  * everything we do is pretty canned. The only real care to take is to escape  * any special chars in our payload.  */
end_comment

begin_comment
comment|/**  * xml_next_tag - Advance to next tag  * @in: Input  * @out: OUT: start of tag just after '<'  * @out_tagname: OUT: start of name of tag, skipping namespace  * @end: OUT: one after tag  * Returns: 0 on success, 1 on failure  *  * A tag has form:  *<left angle bracket><...><right angle bracket>  * Within the angle brackets, there is an optional leading forward slash (which  * makes the tag an ending tag), then an optional leading label (followed by  * colon) and then the tag name itself.  *  * Note that angle brackets present in the original data must have been encoded  * as&lt; and&gt; so they will not trouble us.  */
end_comment

begin_function
specifier|static
name|int
name|xml_next_tag
parameter_list|(
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
modifier|*
name|out
parameter_list|,
name|char
modifier|*
modifier|*
name|out_tagname
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|)
block|{
while|while
condition|(
operator|*
name|in
operator|&&
operator|*
name|in
operator|!=
literal|'<'
condition|)
name|in
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|in
operator|!=
literal|'<'
condition|)
return|return
literal|1
return|;
operator|*
name|out
operator|=
operator|++
name|in
expr_stmt|;
if|if
condition|(
operator|*
name|in
operator|==
literal|'/'
condition|)
name|in
operator|++
expr_stmt|;
operator|*
name|out_tagname
operator|=
name|in
expr_stmt|;
comment|/* maybe */
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|in
argument_list|)
operator|||
operator|*
name|in
operator|==
literal|'-'
condition|)
name|in
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|in
operator|==
literal|':'
condition|)
operator|*
name|out_tagname
operator|=
operator|++
name|in
expr_stmt|;
while|while
condition|(
operator|*
name|in
operator|&&
operator|*
name|in
operator|!=
literal|'>'
condition|)
name|in
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|in
operator|!=
literal|'>'
condition|)
return|return
literal|1
return|;
operator|*
name|end
operator|=
operator|++
name|in
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* xml_data_encode -- format data for xml file, escaping special characters.  *  * Note that we assume we are using utf8 both as input and as output!  * In utf8, characters may be classed as follows:  *     0xxxxxxx(2) -- 1 byte ascii char  *     11xxxxxx(2) -- 1st byte of multi-byte char w/ unicode value>= 0x80  *         110xxxxx(2) -- 1st byte of 2 byte sequence (5 payload bits here)  *         1110xxxx(2) -- 1st byte of 3 byte sequence (4 payload bits here)  *         11110xxx(2) -- 1st byte of 4 byte sequence (3 payload bits here)  *      10xxxxxx(2) -- extension byte (6 payload bits per byte)  *      Some values implied by the above are however illegal because they  *      do not represent unicode chars or are not the shortest encoding.  * Actually, we can almost entirely ignore the above and just do  * text processing same as for ascii text.  *  * XML is written with arbitrary unicode characters, except that five  * characters have special meaning and so must be escaped where they  * appear in payload data... which we do here.  */
end_comment

begin_function
specifier|static
name|void
name|xml_data_encode
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|u8
name|c
init|=
operator|(
operator|(
name|u8
operator|*
operator|)
name|data
operator|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"&lt;"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"&gt;"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
block|{
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"&amp;"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"&apos;"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"&quot;"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We could try to represent control characters using the 		 * sequence:&#x; where x is replaced by a hex numeral, but not 		 * clear why we would do this. 		 */
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* xml_add_tagged_data -- format tagged data as a new xml line.  *  * tag must not have any special chars.  * data may have special chars, which are escaped.  */
end_comment

begin_function
specifier|static
name|void
name|xml_add_tagged_data
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"<%s>"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|xml_data_encode
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
name|os_strlen
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"</%s>\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A POST body looks something like (per upnp spec):  *<?xml version="1.0"?>  *<s:Envelope  *     xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"  *     s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">  *<s:Body>  *<u:actionName xmlns:u="urn:schemas-upnp-org:service:serviceType:v">  *<argumentName>in arg value</argumentName>  *       other in args and their values go here, if any  *</u:actionName>  *</s:Body>  *</s:Envelope>  *  * where :  *      s: might be some other namespace name followed by colon  *      u: might be some other namespace name followed by colon  *      actionName will be replaced according to action requested  *      schema following actionName will be WFA scheme instead  *      argumentName will be actual argument name  *      (in arg value) will be actual argument value  */
end_comment

begin_function
specifier|static
name|int
name|upnp_get_first_document_item
parameter_list|(
name|char
modifier|*
name|doc
parameter_list|,
specifier|const
name|char
modifier|*
name|item
parameter_list|,
name|char
modifier|*
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|match
init|=
name|item
decl_stmt|;
name|int
name|match_len
init|=
name|os_strlen
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|tagname
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
operator|*
name|value
operator|=
name|NULL
expr_stmt|;
comment|/* default, bad */
comment|/* 	 * This is crude: ignore any possible tag name conflicts and go right 	 * to the first tag of this name. This should be ok for the limited 	 * domain of UPnP messages. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|xml_next_tag
argument_list|(
name|doc
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|tagname
argument_list|,
operator|&
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
name|doc
operator|=
name|end
expr_stmt|;
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
name|tagname
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|&&
operator|*
name|tag
operator|!=
literal|'/'
operator|&&
operator|(
name|tagname
index|[
name|match_len
index|]
operator|==
literal|'>'
operator|||
operator|!
name|isgraph
argument_list|(
name|tagname
index|[
name|match_len
index|]
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|end
operator|=
name|doc
expr_stmt|;
while|while
condition|(
operator|*
name|end
operator|&&
operator|*
name|end
operator|!=
literal|'<'
condition|)
name|end
operator|++
expr_stmt|;
operator|*
name|value
operator|=
name|os_zalloc
argument_list|(
literal|1
operator|+
operator|(
name|end
operator|-
name|doc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|os_memcpy
argument_list|(
operator|*
name|value
argument_list|,
name|doc
argument_list|,
name|end
operator|-
name|doc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * "Files" that we serve via HTTP. The format of these files is given by  * WFA WPS specifications. Extra white space has been removed to save space.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|wps_scpd_xml
index|[]
init|=
literal|"<?xml version=\"1.0\"?>\n"
literal|"<scpd xmlns=\"urn:schemas-upnp-org:service-1-0\">\n"
literal|"<specVersion><major>1</major><minor>0</minor></specVersion>\n"
literal|"<actionList>\n"
literal|"<action>\n"
literal|"<name>GetDeviceInfo</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewDeviceInfo</name>\n"
literal|"<direction>out</direction>\n"
literal|"<relatedStateVariable>DeviceInfo</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>PutMessage</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewInMessage</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>InMessage</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"<argument>\n"
literal|"<name>NewOutMessage</name>\n"
literal|"<direction>out</direction>\n"
literal|"<relatedStateVariable>OutMessage</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>GetAPSettings</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewMessage</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>Message</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"<argument>\n"
literal|"<name>NewAPSettings</name>\n"
literal|"<direction>out</direction>\n"
literal|"<relatedStateVariable>APSettings</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>SetAPSettings</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>APSettings</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>APSettings</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>DelAPSettings</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewAPSettings</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>APSettings</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>GetSTASettings</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewMessage</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>Message</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"<argument>\n"
literal|"<name>NewSTASettings</name>\n"
literal|"<direction>out</direction>\n"
literal|"<relatedStateVariable>STASettings</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>SetSTASettings</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewSTASettings</name>\n"
literal|"<direction>out</direction>\n"
literal|"<relatedStateVariable>STASettings</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>DelSTASettings</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewSTASettings</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>STASettings</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>PutWLANResponse</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewMessage</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>Message</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"<argument>\n"
literal|"<name>NewWLANEventType</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>WLANEventType</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"<argument>\n"
literal|"<name>NewWLANEventMAC</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>WLANEventMAC</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>SetSelectedRegistrar</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewMessage</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>Message</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>RebootAP</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewAPSettings</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>APSettings</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>ResetAP</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewMessage</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>Message</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>RebootSTA</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewSTASettings</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>APSettings</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"<action>\n"
literal|"<name>ResetSTA</name>\n"
literal|"<argumentList>\n"
literal|"<argument>\n"
literal|"<name>NewMessage</name>\n"
literal|"<direction>in</direction>\n"
literal|"<relatedStateVariable>Message</relatedStateVariable>\n"
literal|"</argument>\n"
literal|"</argumentList>\n"
literal|"</action>\n"
literal|"</actionList>\n"
literal|"<serviceStateTable>\n"
literal|"<stateVariable sendEvents=\"no\">\n"
literal|"<name>Message</name>\n"
literal|"<dataType>bin.base64</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"no\">\n"
literal|"<name>InMessage</name>\n"
literal|"<dataType>bin.base64</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"no\">\n"
literal|"<name>OutMessage</name>\n"
literal|"<dataType>bin.base64</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"no\">\n"
literal|"<name>DeviceInfo</name>\n"
literal|"<dataType>bin.base64</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"no\">\n"
literal|"<name>APSettings</name>\n"
literal|"<dataType>bin.base64</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"yes\">\n"
literal|"<name>APStatus</name>\n"
literal|"<dataType>ui1</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"no\">\n"
literal|"<name>STASettings</name>\n"
literal|"<dataType>bin.base64</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"yes\">\n"
literal|"<name>STAStatus</name>\n"
literal|"<dataType>ui1</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"yes\">\n"
literal|"<name>WLANEvent</name>\n"
literal|"<dataType>bin.base64</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"no\">\n"
literal|"<name>WLANEventType</name>\n"
literal|"<dataType>ui1</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"no\">\n"
literal|"<name>WLANEventMAC</name>\n"
literal|"<dataType>string</dataType>\n"
literal|"</stateVariable>\n"
literal|"<stateVariable sendEvents=\"no\">\n"
literal|"<name>WLANResponse</name>\n"
literal|"<dataType>bin.base64</dataType>\n"
literal|"</stateVariable>\n"
literal|"</serviceStateTable>\n"
literal|"</scpd>\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|wps_device_xml_prefix
init|=
literal|"<?xml version=\"1.0\"?>\n"
literal|"<root xmlns=\"urn:schemas-upnp-org:device-1-0\">\n"
literal|"<specVersion>\n"
literal|"<major>1</major>\n"
literal|"<minor>0</minor>\n"
literal|"</specVersion>\n"
literal|"<device>\n"
literal|"<deviceType>urn:schemas-wifialliance-org:device:WFADevice:1"
literal|"</deviceType>\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|wps_device_xml_postfix
init|=
literal|"<serviceList>\n"
literal|"<service>\n"
literal|"<serviceType>urn:schemas-wifialliance-org:service:WFAWLANConfig:1"
literal|"</serviceType>\n"
literal|"<serviceId>urn:wifialliance-org:serviceId:WFAWLANConfig1</serviceId>"
literal|"\n"
literal|"<SCPDURL>"
name|UPNP_WPS_SCPD_XML_FILE
literal|"</SCPDURL>\n"
literal|"<controlURL>"
name|UPNP_WPS_DEVICE_CONTROL_FILE
literal|"</controlURL>\n"
literal|"<eventSubURL>"
name|UPNP_WPS_DEVICE_EVENT_FILE
literal|"</eventSubURL>\n"
literal|"</service>\n"
literal|"</serviceList>\n"
literal|"</device>\n"
literal|"</root>\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* format_wps_device_xml -- produce content of "file" wps_device.xml  * (UPNP_WPS_DEVICE_XML_FILE)  */
end_comment

begin_function
specifier|static
name|void
name|format_wps_device_xml
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|uuid_string
index|[
literal|80
index|]
decl_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|wps_device_xml_prefix
argument_list|)
expr_stmt|;
comment|/* 	 * Add required fields with default values if not configured. Add 	 * optional and recommended fields only if configured. 	 */
name|s
operator|=
name|sm
operator|->
name|wps
operator|->
name|friendly_name
expr_stmt|;
name|s
operator|=
operator|(
operator|(
name|s
operator|&&
operator|*
name|s
operator|)
condition|?
name|s
else|:
literal|"WPS Access Point"
operator|)
expr_stmt|;
name|xml_add_tagged_data
argument_list|(
name|buf
argument_list|,
literal|"friendlyName"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|sm
operator|->
name|wps
operator|->
name|dev
operator|.
name|manufacturer
expr_stmt|;
name|s
operator|=
operator|(
operator|(
name|s
operator|&&
operator|*
name|s
operator|)
condition|?
name|s
else|:
literal|""
operator|)
expr_stmt|;
name|xml_add_tagged_data
argument_list|(
name|buf
argument_list|,
literal|"manufacturer"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|manufacturer_url
condition|)
name|xml_add_tagged_data
argument_list|(
name|buf
argument_list|,
literal|"manufacturerURL"
argument_list|,
name|sm
operator|->
name|wps
operator|->
name|manufacturer_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|model_description
condition|)
name|xml_add_tagged_data
argument_list|(
name|buf
argument_list|,
literal|"modelDescription"
argument_list|,
name|sm
operator|->
name|wps
operator|->
name|model_description
argument_list|)
expr_stmt|;
name|s
operator|=
name|sm
operator|->
name|wps
operator|->
name|dev
operator|.
name|model_name
expr_stmt|;
name|s
operator|=
operator|(
operator|(
name|s
operator|&&
operator|*
name|s
operator|)
condition|?
name|s
else|:
literal|""
operator|)
expr_stmt|;
name|xml_add_tagged_data
argument_list|(
name|buf
argument_list|,
literal|"modelName"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|dev
operator|.
name|model_number
condition|)
name|xml_add_tagged_data
argument_list|(
name|buf
argument_list|,
literal|"modelNumber"
argument_list|,
name|sm
operator|->
name|wps
operator|->
name|dev
operator|.
name|model_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|model_url
condition|)
name|xml_add_tagged_data
argument_list|(
name|buf
argument_list|,
literal|"modelURL"
argument_list|,
name|sm
operator|->
name|wps
operator|->
name|model_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|dev
operator|.
name|serial_number
condition|)
name|xml_add_tagged_data
argument_list|(
name|buf
argument_list|,
literal|"serialNumber"
argument_list|,
name|sm
operator|->
name|wps
operator|->
name|dev
operator|.
name|serial_number
argument_list|)
expr_stmt|;
name|uuid_bin2str
argument_list|(
name|sm
operator|->
name|wps
operator|->
name|uuid
argument_list|,
name|uuid_string
argument_list|,
sizeof|sizeof
argument_list|(
name|uuid_string
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|uuid_string
expr_stmt|;
comment|/* Need "uuid:" prefix, thus we can't use xml_add_tagged_data() 	 * easily... 	 */
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"<UDN>uuid:"
argument_list|)
expr_stmt|;
name|xml_data_encode
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
name|os_strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"</UDN>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|upc
condition|)
name|xml_add_tagged_data
argument_list|(
name|buf
argument_list|,
literal|"UPC"
argument_list|,
name|sm
operator|->
name|wps
operator|->
name|upc
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|wps_device_xml_postfix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|web_connection_stop
parameter_list|(
name|struct
name|web_connection
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|c
operator|->
name|sm
decl_stmt|;
name|httpread_destroy
argument_list|(
name|c
operator|->
name|hread
argument_list|)
expr_stmt|;
name|c
operator|->
name|hread
operator|=
name|NULL
expr_stmt|;
name|close
argument_list|(
name|c
operator|->
name|sd
argument_list|)
expr_stmt|;
name|c
operator|->
name|sd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|next
operator|==
name|c
condition|)
block|{
name|sm
operator|->
name|web_connections
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sm
operator|->
name|web_connections
operator|==
name|c
condition|)
name|sm
operator|->
name|web_connections
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|c
operator|->
name|next
operator|->
name|prev
operator|=
name|c
operator|->
name|prev
expr_stmt|;
name|c
operator|->
name|prev
operator|->
name|next
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
name|os_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sm
operator|->
name|n_web_connections
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|http_put_reply_code
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|,
name|enum
name|http_reply_code
name|code
parameter_list|)
block|{
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"HTTP/1.1 "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|HTTP_OK
case|:
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"200 OK\r\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTTP_BAD_REQUEST
case|:
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"400 Bad request\r\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTTP_PRECONDITION_FAILED
case|:
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"412 Precondition failed\r\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTTP_UNIMPLEMENTED
case|:
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"501 Unimplemented\r\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTTP_INTERNAL_SERVER_ERROR
case|:
default|default:
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"500 Internal server error\r\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|http_put_date
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|)
block|{
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"Date: "
argument_list|)
expr_stmt|;
name|format_date
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|http_put_empty
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|,
name|enum
name|http_reply_code
name|code
parameter_list|)
block|{
name|http_put_reply_code
argument_list|(
name|buf
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|http_server_hdr
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|http_connection_close
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"Content-Length: 0\r\n"
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given that we have received a header w/ GET, act upon it  *  * Format of GET (case-insensitive):  *  * First line must be:  *      GET /<file> HTTP/1.1  * Since we don't do anything fancy we just ignore other lines.  *  * Our response (if no error) which includes only required lines is:  * HTTP/1.1 200 OK  * Connection: close  * Content-Type: text/xml  * Date:<rfc1123-date>  *  * Header lines must end with \r\n  * Per RFC 2616, content-length: is not required but connection:close  * would appear to be required (given that we will be closing it!).  */
end_comment

begin_function
specifier|static
name|void
name|web_connection_parse_get
parameter_list|(
name|struct
name|web_connection
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|c
operator|->
name|sm
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
comment|/* output buffer, allocated */
name|char
modifier|*
name|put_length_here
decl_stmt|;
name|char
modifier|*
name|body_start
decl_stmt|;
enum|enum
block|{
name|GET_DEVICE_XML_FILE
block|,
name|GET_SCPD_XML_FILE
block|}
name|req
enum|;
name|size_t
name|extra_len
init|=
literal|0
decl_stmt|;
name|int
name|body_length
decl_stmt|;
name|char
name|len_buf
index|[
literal|10
index|]
decl_stmt|;
comment|/* 	 * It is not required that filenames be case insensitive but it is 	 * allowed and cannot hurt here. 	 */
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
literal|"(null)"
expr_stmt|;
comment|/* just in case */
if|if
condition|(
name|os_strcasecmp
argument_list|(
name|filename
argument_list|,
name|UPNP_WPS_DEVICE_XML_FILE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: HTTP GET for device XML"
argument_list|)
expr_stmt|;
name|req
operator|=
name|GET_DEVICE_XML_FILE
expr_stmt|;
name|extra_len
operator|=
literal|3000
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|friendly_name
condition|)
name|extra_len
operator|+=
name|os_strlen
argument_list|(
name|sm
operator|->
name|wps
operator|->
name|friendly_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|manufacturer_url
condition|)
name|extra_len
operator|+=
name|os_strlen
argument_list|(
name|sm
operator|->
name|wps
operator|->
name|manufacturer_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|model_description
condition|)
name|extra_len
operator|+=
name|os_strlen
argument_list|(
name|sm
operator|->
name|wps
operator|->
name|model_description
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|model_url
condition|)
name|extra_len
operator|+=
name|os_strlen
argument_list|(
name|sm
operator|->
name|wps
operator|->
name|model_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wps
operator|->
name|upc
condition|)
name|extra_len
operator|+=
name|os_strlen
argument_list|(
name|sm
operator|->
name|wps
operator|->
name|upc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|os_strcasecmp
argument_list|(
name|filename
argument_list|,
name|UPNP_WPS_SCPD_XML_FILE
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: HTTP GET for SCPD XML"
argument_list|)
expr_stmt|;
name|req
operator|=
name|GET_SCPD_XML_FILE
expr_stmt|;
name|extra_len
operator|=
name|os_strlen
argument_list|(
name|wps_scpd_xml
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* File not found */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: HTTP GET file not found: %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|200
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"HTTP/1.1 404 Not Found\r\n"
literal|"Connection: close\r\n"
argument_list|)
expr_stmt|;
name|http_put_date
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* terminating empty line */
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
goto|goto
name|send_buf
goto|;
block|}
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|1000
operator|+
name|extra_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"HTTP/1.1 200 OK\r\n"
literal|"Content-Type: text/xml; charset=\"utf-8\"\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"Server: Unspecified, UPnP/1.0, Unspecified\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"Connection: close\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"Content-Length: "
argument_list|)
expr_stmt|;
comment|/* 	 * We will paste the length in later, leaving some extra whitespace. 	 * HTTP code is supposed to be tolerant of extra whitespace. 	 */
name|put_length_here
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"        \r\n"
argument_list|)
expr_stmt|;
name|http_put_date
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* terminating empty line */
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|body_start
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|GET_DEVICE_XML_FILE
case|:
name|format_wps_device_xml
argument_list|(
name|sm
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_SCPD_XML_FILE
case|:
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|wps_scpd_xml
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now patch in the content length at the end */
name|body_length
operator|=
operator|(
name|char
operator|*
operator|)
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|-
name|body_start
expr_stmt|;
name|os_snprintf
argument_list|(
name|len_buf
argument_list|,
literal|10
argument_list|,
literal|"%d"
argument_list|,
name|body_length
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|put_length_here
argument_list|,
name|len_buf
argument_list|,
name|os_strlen
argument_list|(
name|len_buf
argument_list|)
argument_list|)
expr_stmt|;
name|send_buf
label|:
name|send_wpabuf
argument_list|(
name|c
operator|->
name|sd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|web_get_item
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|http_reply_code
modifier|*
name|ret
parameter_list|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|decoded
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|upnp_get_first_document_item
argument_list|(
name|data
argument_list|,
name|name
argument_list|,
operator|&
name|msg
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|UPNP_ARG_VALUE_INVALID
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|decoded
operator|=
name|base64_decode
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|msg
argument_list|,
name|os_strlen
argument_list|(
name|msg
argument_list|)
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|decoded
operator|==
name|NULL
condition|)
block|{
operator|*
name|ret
operator|=
name|UPNP_OUT_OF_MEMORY
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buf
operator|=
name|wpabuf_alloc_ext_data
argument_list|(
name|decoded
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|os_free
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|UPNP_OUT_OF_MEMORY
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_get_device_info
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|name
init|=
literal|"NewDeviceInfo"
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: GetDeviceInfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ctx
operator|->
name|rx_req_get_device_info
operator|==
name|NULL
condition|)
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
operator|*
name|reply
operator|=
name|sm
operator|->
name|ctx
operator|->
name|rx_req_get_device_info
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
operator|&
name|sm
operator|->
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|reply
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Failed to get DeviceInfo"
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
operator|*
name|replyname
operator|=
name|name
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_put_message
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|name
init|=
literal|"NewOutMessage"
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
comment|/* 	 * PutMessage is used by external UPnP-based Registrar to perform WPS 	 * operation with the access point itself; as compared with 	 * PutWLANResponse which is for proxying. 	 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: PutMessage"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ctx
operator|->
name|rx_req_put_message
operator|==
name|NULL
condition|)
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewInMessage"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
operator|*
name|reply
operator|=
name|sm
operator|->
name|ctx
operator|->
name|rx_req_put_message
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
operator|&
name|sm
operator|->
name|peer
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|reply
operator|==
name|NULL
condition|)
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
operator|*
name|replyname
operator|=
name|name
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_get_ap_settings
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|name
init|=
literal|"NewAPSettings"
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: GetAPSettings"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ctx
operator|->
name|rx_req_get_ap_settings
operator|==
name|NULL
condition|)
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewMessage"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
operator|*
name|reply
operator|=
name|sm
operator|->
name|ctx
operator|->
name|rx_req_get_ap_settings
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|reply
operator|==
name|NULL
condition|)
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
operator|*
name|replyname
operator|=
name|name
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_set_ap_settings
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: SetAPSettings"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewAPSettings"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|sm
operator|->
name|ctx
operator|->
name|rx_req_set_ap_settings
operator|||
name|sm
operator|->
name|ctx
operator|->
name|rx_req_set_ap_settings
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|replyname
operator|=
name|NULL
expr_stmt|;
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_del_ap_settings
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: DelAPSettings"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewAPSettings"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|sm
operator|->
name|ctx
operator|->
name|rx_req_del_ap_settings
operator|||
name|sm
operator|->
name|ctx
operator|->
name|rx_req_del_ap_settings
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|replyname
operator|=
name|NULL
expr_stmt|;
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_get_sta_settings
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|name
init|=
literal|"NewSTASettings"
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: GetSTASettings"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ctx
operator|->
name|rx_req_get_sta_settings
operator|==
name|NULL
condition|)
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewMessage"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
operator|*
name|reply
operator|=
name|sm
operator|->
name|ctx
operator|->
name|rx_req_get_sta_settings
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|reply
operator|==
name|NULL
condition|)
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
operator|*
name|replyname
operator|=
name|name
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_set_sta_settings
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: SetSTASettings"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewSTASettings"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|sm
operator|->
name|ctx
operator|->
name|rx_req_set_sta_settings
operator|||
name|sm
operator|->
name|ctx
operator|->
name|rx_req_set_sta_settings
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|replyname
operator|=
name|NULL
expr_stmt|;
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_del_sta_settings
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: DelSTASettings"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewSTASettings"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|sm
operator|->
name|ctx
operator|->
name|rx_req_del_sta_settings
operator|||
name|sm
operator|->
name|ctx
operator|->
name|rx_req_del_sta_settings
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|replyname
operator|=
name|NULL
expr_stmt|;
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_put_wlan_response
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|u8
name|macaddr
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|int
name|ev_type
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
comment|/* 	 * External UPnP-based Registrar is passing us a message to be proxied 	 * over to a Wi-Fi -based client of ours. 	 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: PutWLANResponse"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewMessage"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|upnp_get_first_document_item
argument_list|(
name|data
argument_list|,
literal|"NewWLANEventType"
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|UPNP_ARG_VALUE_INVALID
return|;
block|}
name|ev_type
operator|=
name|atol
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|upnp_get_first_document_item
argument_list|(
name|data
argument_list|,
literal|"NewWLANEventMAC"
argument_list|,
operator|&
name|val
argument_list|)
operator|||
name|hwaddr_aton
argument_list|(
name|val
argument_list|,
name|macaddr
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|UPNP_ARG_VALUE_INVALID
return|;
block|}
name|os_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev_type
operator|==
name|UPNP_WPS_WLANEVENT_TYPE_EAP
condition|)
block|{
name|struct
name|wps_parse_attr
name|attr
decl_stmt|;
if|if
condition|(
name|wps_parse_msg
argument_list|(
name|msg
argument_list|,
operator|&
name|attr
argument_list|)
operator|<
literal|0
operator|||
name|attr
operator|.
name|msg_type
operator|==
name|NULL
condition|)
name|type
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|type
operator|=
operator|*
name|attr
operator|.
name|msg_type
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Message Type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|sm
operator|->
name|ctx
operator|->
name|rx_req_put_wlan_response
operator|||
name|sm
operator|->
name|ctx
operator|->
name|rx_req_put_wlan_response
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|ev_type
argument_list|,
name|macaddr
argument_list|,
name|msg
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Fail: sm->ctx->"
literal|"rx_req_put_wlan_response"
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|replyname
operator|=
name|NULL
expr_stmt|;
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_set_selected_registrar
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: SetSelectedRegistrar"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewMessage"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|sm
operator|->
name|ctx
operator|->
name|rx_req_set_selected_registrar
operator|||
name|sm
operator|->
name|ctx
operator|->
name|rx_req_set_selected_registrar
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|replyname
operator|=
name|NULL
expr_stmt|;
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_reboot_ap
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: RebootAP"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewAPSettings"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|sm
operator|->
name|ctx
operator|->
name|rx_req_reboot_ap
operator|||
name|sm
operator|->
name|ctx
operator|->
name|rx_req_reboot_ap
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|replyname
operator|=
name|NULL
expr_stmt|;
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_reset_ap
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: ResetAP"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewMessage"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|sm
operator|->
name|ctx
operator|->
name|rx_req_reset_ap
operator|||
name|sm
operator|->
name|ctx
operator|->
name|rx_req_reset_ap
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|replyname
operator|=
name|NULL
expr_stmt|;
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_reboot_sta
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: RebootSTA"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewSTASettings"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|sm
operator|->
name|ctx
operator|->
name|rx_req_reboot_sta
operator|||
name|sm
operator|->
name|ctx
operator|->
name|rx_req_reboot_sta
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|replyname
operator|=
name|NULL
expr_stmt|;
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|http_reply_code
name|web_process_reset_sta
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: ResetSTA"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|web_get_item
argument_list|(
name|data
argument_list|,
literal|"NewMessage"
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|sm
operator|->
name|ctx
operator|->
name|rx_req_reset_sta
operator|||
name|sm
operator|->
name|ctx
operator|->
name|rx_req_reset_sta
argument_list|(
name|sm
operator|->
name|priv
argument_list|,
name|msg
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|HTTP_INTERNAL_SERVER_ERROR
return|;
block|}
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|replyname
operator|=
name|NULL
expr_stmt|;
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
return|return
name|HTTP_OK
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|soap_prefix
init|=
literal|"<?xml version=\"1.0\"?>\n"
literal|"<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" "
literal|"s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">\n"
literal|"<s:Body>\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|soap_postfix
init|=
literal|"</s:Body>\n</s:Envelope>\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|soap_error_prefix
init|=
literal|"<s:Fault>\n"
literal|"<faultcode>s:Client</faultcode>\n"
literal|"<faultstring>UPnPError</faultstring>\n"
literal|"<detail>\n"
literal|"<UPnPError xmlns=\"urn:schemas-upnp-org:control-1-0\">\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|soap_error_postfix
init|=
literal|"<errorDescription>Error</errorDescription>\n"
literal|"</UPnPError>\n"
literal|"</detail>\n"
literal|"</s:Fault>\n"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|web_connection_send_reply
parameter_list|(
name|struct
name|web_connection
modifier|*
name|c
parameter_list|,
name|enum
name|http_reply_code
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|action
parameter_list|,
name|int
name|action_len
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
name|replyname
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|replydata
decl_stmt|;
name|char
modifier|*
name|put_length_here
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|body_start
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|replydata
operator|=
operator|(
name|char
operator|*
operator|)
name|base64_encode
argument_list|(
name|wpabuf_head
argument_list|(
name|reply
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|reply
argument_list|)
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|replydata
operator|=
name|NULL
expr_stmt|;
comment|/* Parameters of the response: 	 *      action(action_len) -- action we are responding to 	 *      replyname -- a name we need for the reply 	 *      replydata -- NULL or null-terminated string 	 */
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|1000
operator|+
operator|(
name|replydata
condition|?
name|os_strlen
argument_list|(
name|replydata
argument_list|)
else|:
literal|0U
operator|)
operator|+
operator|(
name|action_len
operator|>
literal|0
condition|?
name|action_len
operator|*
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Cannot allocate reply to "
literal|"POST"
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|replydata
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Assuming we will be successful, put in the output header first. 	 * Note: we do not keep connections alive (and httpread does 	 * not support it)... therefore we must have Connection: close. 	 */
if|if
condition|(
name|ret
operator|==
name|HTTP_OK
condition|)
block|{
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"HTTP/1.1 200 OK\r\n"
literal|"Content-Type: text/xml; "
literal|"charset=\"utf-8\"\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"HTTP/1.1 %d Error\r\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|http_connection_close
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"Content-Length: "
argument_list|)
expr_stmt|;
comment|/* 	 * We will paste the length in later, leaving some extra whitespace. 	 * HTTP code is supposed to be tolerant of extra whitespace. 	 */
name|put_length_here
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"        \r\n"
argument_list|)
expr_stmt|;
name|http_put_date
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* terminating empty line */
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|body_start
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|HTTP_OK
condition|)
block|{
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|soap_prefix
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"<u:"
argument_list|)
expr_stmt|;
name|wpabuf_put_data
argument_list|(
name|buf
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"Response xmlns:u=\""
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|urn_wfawlanconfig
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\">\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|replydata
operator|&&
name|replyname
condition|)
block|{
comment|/* TODO: might possibly need to escape part of reply 			 * data? ... 			 * probably not, unlikely to have ampersand(&) or left 			 * angle bracket (<) in it... 			 */
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"<%s>"
argument_list|,
name|replyname
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|replydata
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"</%s>\n"
argument_list|,
name|replyname
argument_list|)
expr_stmt|;
block|}
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"</u:"
argument_list|)
expr_stmt|;
name|wpabuf_put_data
argument_list|(
name|buf
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"Response>\n"
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|soap_postfix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Error case */
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|soap_prefix
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|soap_error_prefix
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"<errorCode>%d</errorCode>\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|soap_error_postfix
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|soap_postfix
argument_list|)
expr_stmt|;
block|}
name|os_free
argument_list|(
name|replydata
argument_list|)
expr_stmt|;
comment|/* Now patch in the content length at the end */
if|if
condition|(
name|body_start
operator|&&
name|put_length_here
condition|)
block|{
name|int
name|body_length
init|=
operator|(
name|char
operator|*
operator|)
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|-
name|body_start
decl_stmt|;
name|char
name|len_buf
index|[
literal|10
index|]
decl_stmt|;
name|os_snprintf
argument_list|(
name|len_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|len_buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|body_length
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|put_length_here
argument_list|,
name|len_buf
argument_list|,
name|os_strlen
argument_list|(
name|len_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|send_wpabuf
argument_list|(
name|c
operator|->
name|sd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|web_get_action
parameter_list|(
name|struct
name|web_connection
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|size_t
modifier|*
name|action_len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|match
decl_stmt|;
name|int
name|match_len
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|action
decl_stmt|;
operator|*
name|action_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|os_strcasecmp
argument_list|(
name|filename
argument_list|,
name|UPNP_WPS_DEVICE_CONTROL_FILE
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Invalid POST filename %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* The SOAPAction line of the header tells us what we want to do */
name|b
operator|=
name|httpread_hdr_line_get
argument_list|(
name|c
operator|->
name|hread
argument_list|,
literal|"SOAPAction:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|b
operator|==
literal|'"'
condition|)
name|b
operator|++
expr_stmt|;
else|else
return|return
name|NULL
return|;
name|match
operator|=
name|urn_wfawlanconfig
expr_stmt|;
name|match_len
operator|=
name|os_strlen
argument_list|(
name|urn_wfawlanconfig
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|os_strncasecmp
argument_list|(
name|b
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
condition|)
return|return
name|NULL
return|;
name|b
operator|+=
name|match_len
expr_stmt|;
comment|/* skip over version */
while|while
condition|(
name|isgraph
argument_list|(
operator|*
name|b
argument_list|)
operator|&&
operator|*
name|b
operator|!=
literal|'#'
condition|)
name|b
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|b
operator|!=
literal|'#'
condition|)
return|return
name|NULL
return|;
name|b
operator|++
expr_stmt|;
comment|/* Following the sharp(#) should be the action and a double quote */
name|action
operator|=
name|b
expr_stmt|;
while|while
condition|(
name|isgraph
argument_list|(
operator|*
name|b
argument_list|)
operator|&&
operator|*
name|b
operator|!=
literal|'"'
condition|)
name|b
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|b
operator|!=
literal|'"'
condition|)
return|return
name|NULL
return|;
operator|*
name|action_len
operator|=
name|b
operator|-
name|action
expr_stmt|;
return|return
name|action
return|;
block|}
end_function

begin_comment
comment|/* Given that we have received a header w/ POST, act upon it  *  * Format of POST (case-insensitive):  *  * First line must be:  *      POST /<file> HTTP/1.1  * Since we don't do anything fancy we just ignore other lines.  *  * Our response (if no error) which includes only required lines is:  * HTTP/1.1 200 OK  * Connection: close  * Content-Type: text/xml  * Date:<rfc1123-date>  *  * Header lines must end with \r\n  * Per RFC 2616, content-length: is not required but connection:close  * would appear to be required (given that we will be closing it!).  */
end_comment

begin_function
specifier|static
name|void
name|web_connection_parse_post
parameter_list|(
name|struct
name|web_connection
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|enum
name|http_reply_code
name|ret
decl_stmt|;
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|c
operator|->
name|sm
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|httpread_data_get
argument_list|(
name|c
operator|->
name|hread
argument_list|)
decl_stmt|;
comment|/* body of http msg */
specifier|const
name|char
modifier|*
name|action
decl_stmt|;
name|size_t
name|action_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|replyname
init|=
name|NULL
decl_stmt|;
comment|/* argument name for the reply */
name|struct
name|wpabuf
modifier|*
name|reply
init|=
name|NULL
decl_stmt|;
comment|/* data for the reply */
name|ret
operator|=
name|UPNP_INVALID_ACTION
expr_stmt|;
name|action
operator|=
name|web_get_action
argument_list|(
name|c
argument_list|,
name|filename
argument_list|,
operator|&
name|action_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * There are quite a few possible actions. Although we appear to 	 * support them all here, not all of them are necessarily supported by 	 * callbacks at higher levels. 	 */
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"GetDeviceInfo"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_get_device_info
argument_list|(
name|sm
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"PutMessage"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_put_message
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"GetAPSettings"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_get_ap_settings
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"SetAPSettings"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_set_ap_settings
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"DelAPSettings"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_del_ap_settings
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"GetSTASettings"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_get_sta_settings
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"SetSTASettings"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_set_sta_settings
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"DelSTASettings"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_del_sta_settings
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"PutWLANResponse"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_put_wlan_response
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"SetSelectedRegistrar"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_set_selected_registrar
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"RebootAP"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_reboot_ap
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"ResetAP"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_reset_ap
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"RebootSTA"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_reboot_sta
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strncasecmp
argument_list|(
literal|"ResetSTA"
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|)
condition|)
name|ret
operator|=
name|web_process_reset_sta
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
operator|&
name|reply
argument_list|,
operator|&
name|replyname
argument_list|)
expr_stmt|;
else|else
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Unknown POST type"
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|ret
operator|!=
name|HTTP_OK
condition|)
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: POST failure ret=%d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|web_connection_send_reply
argument_list|(
name|c
argument_list|,
name|ret
argument_list|,
name|action
argument_list|,
name|action_len
argument_list|,
name|reply
argument_list|,
name|replyname
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given that we have received a header w/ SUBSCRIBE, act upon it  *  * Format of SUBSCRIBE (case-insensitive):  *  * First line must be:  *      SUBSCRIBE /wps_event HTTP/1.1  *  * Our response (if no error) which includes only required lines is:  * HTTP/1.1 200 OK  * Server: xx, UPnP/1.0, xx  * SID: uuid:xxxxxxxxx  * Timeout: Second-<n>  * Content-Length: 0  * Date: xxxx  *  * Header lines must end with \r\n  * Per RFC 2616, content-length: is not required but connection:close  * would appear to be required (given that we will be closing it!).  */
end_comment

begin_function
specifier|static
name|void
name|web_connection_parse_subscribe
parameter_list|(
name|struct
name|web_connection
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|c
operator|->
name|sm
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|hdr
init|=
name|httpread_hdr_get
argument_list|(
name|c
operator|->
name|hread
argument_list|)
decl_stmt|;
name|char
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|match
decl_stmt|;
name|int
name|match_len
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|got_nt
init|=
literal|0
decl_stmt|;
name|u8
name|uuid
index|[
name|UUID_LEN
index|]
decl_stmt|;
name|int
name|got_uuid
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|callback_urls
init|=
name|NULL
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|enum
name|http_reply_code
name|ret
init|=
name|HTTP_INTERNAL_SERVER_ERROR
decl_stmt|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
comment|/* Parse/validate headers */
name|h
operator|=
name|hdr
expr_stmt|;
comment|/* First line: SUBSCRIBE /wps_event HTTP/1.1 	 * has already been parsed. 	 */
if|if
condition|(
name|os_strcasecmp
argument_list|(
name|filename
argument_list|,
name|UPNP_WPS_DEVICE_EVENT_FILE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|HTTP_PRECONDITION_FAILED
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: HTTP SUBSCRIBE for event"
argument_list|)
expr_stmt|;
name|end
operator|=
name|os_strchr
argument_list|(
name|h
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|end
operator|!=
name|NULL
condition|;
name|h
operator|=
name|end
operator|+
literal|1
control|)
block|{
comment|/* Option line by option line */
name|h
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|end
operator|=
name|os_strchr
argument_list|(
name|h
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
break|break;
comment|/* no unterminated lines allowed */
comment|/* NT assures that it is our type of subscription; 		 * not used for a renewl. 		 **/
name|match
operator|=
literal|"NT:"
expr_stmt|;
name|match_len
operator|=
name|os_strlen
argument_list|(
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_strncasecmp
argument_list|(
name|h
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|+=
name|match_len
expr_stmt|;
while|while
condition|(
operator|*
name|h
operator|==
literal|' '
operator|||
operator|*
name|h
operator|==
literal|'\t'
condition|)
name|h
operator|++
expr_stmt|;
name|match
operator|=
literal|"upnp:event"
expr_stmt|;
name|match_len
operator|=
name|os_strlen
argument_list|(
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_strncasecmp
argument_list|(
name|h
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|HTTP_BAD_REQUEST
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|got_nt
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* HOST should refer to us */
if|#
directive|if
literal|0
block|match = "HOST:"; 		match_len = os_strlen(match); 		if (os_strncasecmp(h, match, match_len) == 0) { 			h += match_len; 			while (*h == ' ' || *h == '\t') 				h++; 			..... 		}
endif|#
directive|endif
comment|/* CALLBACK gives one or more URLs for NOTIFYs 		 * to be sent as a result of the subscription. 		 * Each URL is enclosed in angle brackets. 		 */
name|match
operator|=
literal|"CALLBACK:"
expr_stmt|;
name|match_len
operator|=
name|os_strlen
argument_list|(
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_strncasecmp
argument_list|(
name|h
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|+=
name|match_len
expr_stmt|;
while|while
condition|(
operator|*
name|h
operator|==
literal|' '
operator|||
operator|*
name|h
operator|==
literal|'\t'
condition|)
name|h
operator|++
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|h
expr_stmt|;
name|os_free
argument_list|(
name|callback_urls
argument_list|)
expr_stmt|;
name|callback_urls
operator|=
name|os_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback_urls
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HTTP_INTERNAL_SERVER_ERROR
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|os_memcpy
argument_list|(
name|callback_urls
argument_list|,
name|h
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|callback_urls
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* SID is only for renewal */
name|match
operator|=
literal|"SID:"
expr_stmt|;
name|match_len
operator|=
name|os_strlen
argument_list|(
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_strncasecmp
argument_list|(
name|h
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|+=
name|match_len
expr_stmt|;
while|while
condition|(
operator|*
name|h
operator|==
literal|' '
operator|||
operator|*
name|h
operator|==
literal|'\t'
condition|)
name|h
operator|++
expr_stmt|;
name|match
operator|=
literal|"uuid:"
expr_stmt|;
name|match_len
operator|=
name|os_strlen
argument_list|(
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_strncasecmp
argument_list|(
name|h
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|HTTP_BAD_REQUEST
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|h
operator|+=
name|match_len
expr_stmt|;
while|while
condition|(
operator|*
name|h
operator|==
literal|' '
operator|||
operator|*
name|h
operator|==
literal|'\t'
condition|)
name|h
operator|++
expr_stmt|;
if|if
condition|(
name|uuid_str2bin
argument_list|(
name|h
argument_list|,
name|uuid
argument_list|)
condition|)
block|{
name|ret
operator|=
name|HTTP_BAD_REQUEST
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|got_uuid
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* TIMEOUT is requested timeout, but apparently we can 		 * just ignore this. 		 */
block|}
if|if
condition|(
name|got_uuid
condition|)
block|{
comment|/* renewal */
if|if
condition|(
name|callback_urls
condition|)
block|{
name|ret
operator|=
name|HTTP_BAD_REQUEST
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|s
operator|=
name|subscription_renew
argument_list|(
name|sm
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HTTP_PRECONDITION_FAILED
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|callback_urls
condition|)
block|{
if|if
condition|(
operator|!
name|got_nt
condition|)
block|{
name|ret
operator|=
name|HTTP_PRECONDITION_FAILED
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|s
operator|=
name|subscription_start
argument_list|(
name|sm
argument_list|,
name|callback_urls
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|HTTP_INTERNAL_SERVER_ERROR
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|callback_urls
operator|=
name|NULL
expr_stmt|;
comment|/* is now owned by subscription */
block|}
else|else
block|{
name|ret
operator|=
name|HTTP_PRECONDITION_FAILED
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* success */
name|http_put_reply_code
argument_list|(
name|buf
argument_list|,
name|HTTP_OK
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|http_server_hdr
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|http_connection_close
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"Content-Length: 0\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"SID: uuid:"
argument_list|)
expr_stmt|;
comment|/* subscription id */
name|b
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uuid_bin2str
argument_list|(
name|s
operator|->
name|uuid
argument_list|,
name|b
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
name|os_strlen
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"Timeout: Second-%d\r\n"
argument_list|,
name|UPNP_SUBSCRIBE_SEC
argument_list|)
expr_stmt|;
name|http_put_date
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* And empty line to terminate header: */
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|send_wpabuf
argument_list|(
name|c
operator|->
name|sd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|callback_urls
argument_list|)
expr_stmt|;
return|return;
name|error
label|:
comment|/* Per UPnP spec: 	* Errors 	* Incompatible headers 	*   400 Bad Request. If SID header and one of NT or CALLBACK headers 	*     are present, the publisher must respond with HTTP error 	*     400 Bad Request. 	* Missing or invalid CALLBACK 	*   412 Precondition Failed. If CALLBACK header is missing or does not 	*     contain a valid HTTP URL, the publisher must respond with HTTP 	*     error 412 Precondition Failed. 	* Invalid NT 	*   412 Precondition Failed. If NT header does not equal upnp:event, 	*     the publisher must respond with HTTP error 412 Precondition 	*     Failed. 	* [For resubscription, use 412 if unknown uuid]. 	* Unable to accept subscription 	*   5xx. If a publisher is not able to accept a subscription (such as 	*     due to insufficient resources), it must respond with a 	*     HTTP 500-series error code. 	*   599 Too many subscriptions (not a standard HTTP error) 	*/
name|http_put_empty
argument_list|(
name|buf
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|send_wpabuf
argument_list|(
name|c
operator|->
name|sd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given that we have received a header w/ UNSUBSCRIBE, act upon it  *  * Format of UNSUBSCRIBE (case-insensitive):  *  * First line must be:  *      UNSUBSCRIBE /wps_event HTTP/1.1  *  * Our response (if no error) which includes only required lines is:  * HTTP/1.1 200 OK  * Content-Length: 0  *  * Header lines must end with \r\n  * Per RFC 2616, content-length: is not required but connection:close  * would appear to be required (given that we will be closing it!).  */
end_comment

begin_function
specifier|static
name|void
name|web_connection_parse_unsubscribe
parameter_list|(
name|struct
name|web_connection
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|c
operator|->
name|sm
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|hdr
init|=
name|httpread_hdr_get
argument_list|(
name|c
operator|->
name|hread
argument_list|)
decl_stmt|;
name|char
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|match
decl_stmt|;
name|int
name|match_len
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|u8
name|uuid
index|[
name|UUID_LEN
index|]
decl_stmt|;
name|int
name|got_uuid
init|=
literal|0
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|enum
name|http_reply_code
name|ret
init|=
name|HTTP_INTERNAL_SERVER_ERROR
decl_stmt|;
comment|/* Parse/validate headers */
name|h
operator|=
name|hdr
expr_stmt|;
comment|/* First line: UNSUBSCRIBE /wps_event HTTP/1.1 	 * has already been parsed. 	 */
if|if
condition|(
name|os_strcasecmp
argument_list|(
name|filename
argument_list|,
name|UPNP_WPS_DEVICE_EVENT_FILE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|HTTP_PRECONDITION_FAILED
expr_stmt|;
goto|goto
name|send_msg
goto|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: HTTP UNSUBSCRIBE for event"
argument_list|)
expr_stmt|;
name|end
operator|=
name|os_strchr
argument_list|(
name|h
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|end
operator|!=
name|NULL
condition|;
name|h
operator|=
name|end
operator|+
literal|1
control|)
block|{
comment|/* Option line by option line */
name|h
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|end
operator|=
name|os_strchr
argument_list|(
name|h
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
break|break;
comment|/* no unterminated lines allowed */
comment|/* HOST should refer to us */
if|#
directive|if
literal|0
block|match = "HOST:"; 		match_len = os_strlen(match); 		if (os_strncasecmp(h, match, match_len) == 0) { 			h += match_len; 			while (*h == ' ' || *h == '\t') 				h++; 			..... 		}
endif|#
directive|endif
comment|/* SID is only for renewal */
name|match
operator|=
literal|"SID:"
expr_stmt|;
name|match_len
operator|=
name|os_strlen
argument_list|(
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_strncasecmp
argument_list|(
name|h
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|+=
name|match_len
expr_stmt|;
while|while
condition|(
operator|*
name|h
operator|==
literal|' '
operator|||
operator|*
name|h
operator|==
literal|'\t'
condition|)
name|h
operator|++
expr_stmt|;
name|match
operator|=
literal|"uuid:"
expr_stmt|;
name|match_len
operator|=
name|os_strlen
argument_list|(
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_strncasecmp
argument_list|(
name|h
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|HTTP_BAD_REQUEST
expr_stmt|;
goto|goto
name|send_msg
goto|;
block|}
name|h
operator|+=
name|match_len
expr_stmt|;
while|while
condition|(
operator|*
name|h
operator|==
literal|' '
operator|||
operator|*
name|h
operator|==
literal|'\t'
condition|)
name|h
operator|++
expr_stmt|;
if|if
condition|(
name|uuid_str2bin
argument_list|(
name|h
argument_list|,
name|uuid
argument_list|)
condition|)
block|{
name|ret
operator|=
name|HTTP_BAD_REQUEST
expr_stmt|;
goto|goto
name|send_msg
goto|;
block|}
name|got_uuid
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|got_uuid
condition|)
block|{
name|s
operator|=
name|subscription_find
argument_list|(
name|sm
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Unsubscribing %p %s"
argument_list|,
name|s
argument_list|,
operator|(
name|s
operator|&&
name|s
operator|->
name|addr_list
operator|&&
name|s
operator|->
name|addr_list
operator|->
name|domain_and_port
operator|)
condition|?
name|s
operator|->
name|addr_list
operator|->
name|domain_and_port
else|:
literal|"-null-"
argument_list|)
expr_stmt|;
name|subscription_unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|subscription_destroy
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Unsubscribe fails (not "
literal|"found)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|HTTP_PRECONDITION_FAILED
expr_stmt|;
goto|goto
name|send_msg
goto|;
block|}
name|ret
operator|=
name|HTTP_OK
expr_stmt|;
name|send_msg
label|:
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|200
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|http_put_empty
argument_list|(
name|buf
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|send_wpabuf
argument_list|(
name|c
operator|->
name|sd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send error in response to unknown requests */
end_comment

begin_function
specifier|static
name|void
name|web_connection_unimplemented
parameter_list|(
name|struct
name|web_connection
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|200
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|http_put_empty
argument_list|(
name|buf
argument_list|,
name|HTTP_UNIMPLEMENTED
argument_list|)
expr_stmt|;
name|send_wpabuf
argument_list|(
name|c
operator|->
name|sd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when we have gotten an apparently valid http request.  */
end_comment

begin_function
specifier|static
name|void
name|web_connection_check_data
parameter_list|(
name|struct
name|web_connection
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|httpread
modifier|*
name|hread
init|=
name|c
operator|->
name|hread
decl_stmt|;
name|enum
name|httpread_hdr_type
name|htype
init|=
name|httpread_hdr_type_get
argument_list|(
name|hread
argument_list|)
decl_stmt|;
comment|/* char *data = httpread_data_get(hread); */
name|char
modifier|*
name|filename
init|=
name|httpread_uri_get
argument_list|(
name|hread
argument_list|)
decl_stmt|;
name|c
operator|->
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Could not get HTTP URI"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Trim leading slashes from filename */
while|while
condition|(
operator|*
name|filename
operator|==
literal|'/'
condition|)
name|filename
operator|++
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Got HTTP request type %d from %s:%d"
argument_list|,
name|htype
argument_list|,
name|inet_ntoa
argument_list|(
name|c
operator|->
name|cli_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|htons
argument_list|(
name|c
operator|->
name|cli_addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|htype
condition|)
block|{
case|case
name|HTTPREAD_HDR_TYPE_GET
case|:
name|web_connection_parse_get
argument_list|(
name|c
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTTPREAD_HDR_TYPE_POST
case|:
name|web_connection_parse_post
argument_list|(
name|c
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTTPREAD_HDR_TYPE_SUBSCRIBE
case|:
name|web_connection_parse_subscribe
argument_list|(
name|c
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTTPREAD_HDR_TYPE_UNSUBSCRIBE
case|:
name|web_connection_parse_unsubscribe
argument_list|(
name|c
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
comment|/* We are not required to support M-POST; just plain 		 * POST is supposed to work, so we only support that. 		 * If for some reason we need to support M-POST, it is 		 * mostly the same as POST, with small differences. 		 */
default|default:
comment|/* Send 501 for anything else */
name|web_connection_unimplemented
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* called back when we have gotten request */
end_comment

begin_function
specifier|static
name|void
name|web_connection_got_file_handler
parameter_list|(
name|struct
name|httpread
modifier|*
name|handle
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
name|enum
name|httpread_event
name|en
parameter_list|)
block|{
name|struct
name|web_connection
modifier|*
name|c
init|=
name|cookie
decl_stmt|;
if|if
condition|(
name|en
operator|==
name|HTTPREAD_EVENT_FILE_READY
condition|)
name|web_connection_check_data
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|web_connection_stop
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* web_connection_start - Start web connection  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * @sd: Socket descriptor  * @addr: Client address  *  * The socket descriptor sd is handed over for ownership by the WPS UPnP  * state machine.  */
end_comment

begin_function
specifier|static
name|void
name|web_connection_start
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|int
name|sd
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|web_connection
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
comment|/* if too many connections, bail */
if|if
condition|(
name|sm
operator|->
name|n_web_connections
operator|>=
name|MAX_WEB_CONNECTIONS
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return;
name|os_memcpy
argument_list|(
operator|&
name|c
operator|->
name|cli_addr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|cli_addr
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|sm
operator|=
name|sm
expr_stmt|;
name|c
operator|->
name|sd
operator|=
name|sd
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Setting non-blocking should not be necessary for read, and can mess 	 * up sending where blocking might be better. 	 */
block|if (fcntl(sd, F_SETFL, O_NONBLOCK) != 0) 		break;
endif|#
directive|endif
name|c
operator|->
name|hread
operator|=
name|httpread_create
argument_list|(
name|c
operator|->
name|sd
argument_list|,
name|web_connection_got_file_handler
argument_list|,
name|c
comment|/* cookie */
argument_list|,
name|WEB_CONNECTION_MAX_READ
argument_list|,
name|WEB_CONNECTION_TIMEOUT_SEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|hread
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|sm
operator|->
name|web_connections
condition|)
block|{
name|c
operator|->
name|next
operator|=
name|sm
operator|->
name|web_connections
expr_stmt|;
name|c
operator|->
name|prev
operator|=
name|c
operator|->
name|next
operator|->
name|prev
expr_stmt|;
name|c
operator|->
name|prev
operator|->
name|next
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|next
operator|->
name|prev
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|web_connections
operator|=
name|c
operator|->
name|next
operator|=
name|c
operator|->
name|prev
operator|=
name|c
expr_stmt|;
block|}
name|sm
operator|->
name|n_web_connections
operator|++
expr_stmt|;
return|return;
name|fail
label|:
if|if
condition|(
name|c
condition|)
name|web_connection_stop
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Listening for web connections  * We have a single TCP listening port, and hand off connections as we get  * them.  */
end_comment

begin_function
name|void
name|web_listener_stop
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|web_sd_registered
condition|)
block|{
name|sm
operator|->
name|web_sd_registered
operator|=
literal|0
expr_stmt|;
name|eloop_unregister_sock
argument_list|(
name|sm
operator|->
name|web_sd
argument_list|,
name|EVENT_TYPE_READ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|web_sd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|sm
operator|->
name|web_sd
argument_list|)
expr_stmt|;
name|sm
operator|->
name|web_sd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|web_listener_handler
parameter_list|(
name|int
name|sd
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|sock_ctx
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|socklen_t
name|addr_len
init|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|sock_ctx
decl_stmt|;
name|int
name|new_sd
decl_stmt|;
comment|/* Create state for new connection */
comment|/* Remember so we can cancel if need be */
name|new_sd
operator|=
name|accept
argument_list|(
name|sm
operator|->
name|web_sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sd
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"WPS UPnP: web listener accept "
literal|"errno=%d (%s) web_sd=%d"
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|sm
operator|->
name|web_sd
argument_list|)
expr_stmt|;
return|return;
block|}
name|web_connection_start
argument_list|(
name|sm
argument_list|,
name|new_sd
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|web_listener_start
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|int
name|port
decl_stmt|;
name|sm
operator|->
name|web_sd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|web_sd
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|fcntl
argument_list|(
name|sm
operator|->
name|web_sd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|port
operator|=
literal|49152
expr_stmt|;
comment|/* first non-reserved port */
for|for
control|(
init|;
condition|;
control|)
block|{
name|os_memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|sm
operator|->
name|ip_addr
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sm
operator|->
name|web_sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
block|{
comment|/* search for unused port */
if|if
condition|(
operator|++
name|port
operator|==
literal|65535
condition|)
goto|goto
name|fail
goto|;
continue|continue;
block|}
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|sm
operator|->
name|web_sd
argument_list|,
literal|10
comment|/* max backlog */
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|fcntl
argument_list|(
name|sm
operator|->
name|web_sd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|eloop_register_sock
argument_list|(
name|sm
operator|->
name|web_sd
argument_list|,
name|EVENT_TYPE_READ
argument_list|,
name|web_listener_handler
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|sm
operator|->
name|web_sd_registered
operator|=
literal|1
expr_stmt|;
name|sm
operator|->
name|web_port
operator|=
name|port
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
comment|/* Error */
name|web_listener_stop
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

