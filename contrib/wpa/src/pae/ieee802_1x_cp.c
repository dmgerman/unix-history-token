begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * IEEE 802.1X-2010 Controlled Port of PAE state machine - CP state machine  * Copyright (c) 2013-2014, Qualcomm Atheros, Inc.  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"utils/includes.h"
end_include

begin_include
include|#
directive|include
file|"utils/common.h"
end_include

begin_include
include|#
directive|include
file|"utils/eloop.h"
end_include

begin_include
include|#
directive|include
file|"common/defs.h"
end_include

begin_include
include|#
directive|include
file|"common/ieee802_1x_defs.h"
end_include

begin_include
include|#
directive|include
file|"utils/state_machine.h"
end_include

begin_include
include|#
directive|include
file|"ieee802_1x_kay.h"
end_include

begin_include
include|#
directive|include
file|"ieee802_1x_secy_ops.h"
end_include

begin_include
include|#
directive|include
file|"pae/ieee802_1x_cp.h"
end_include

begin_define
define|#
directive|define
name|STATE_MACHINE_DATA
value|struct ieee802_1x_cp_sm
end_define

begin_define
define|#
directive|define
name|STATE_MACHINE_DEBUG_PREFIX
value|"CP"
end_define

begin_decl_stmt
specifier|static
name|u8
name|default_cs_id
index|[]
init|=
name|CS_ID_GCM_AES_128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The variable defined in clause 12 in IEEE Std 802.1X-2010 */
end_comment

begin_enum
enum|enum
name|connect_type
block|{
name|PENDING
block|,
name|UNAUTHENTICATED
block|,
name|AUTHENTICATED
block|,
name|SECURE
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ieee802_1x_cp_sm
block|{
enum|enum
name|cp_states
block|{
name|CP_BEGIN
block|,
name|CP_INIT
block|,
name|CP_CHANGE
block|,
name|CP_ALLOWED
block|,
name|CP_AUTHENTICATED
block|,
name|CP_SECURED
block|,
name|CP_RECEIVE
block|,
name|CP_RECEIVING
block|,
name|CP_READY
block|,
name|CP_TRANSMIT
block|,
name|CP_TRANSMITTING
block|,
name|CP_ABANDON
block|,
name|CP_RETIRE
block|}
name|CP_state
enum|;
name|Boolean
name|changed
decl_stmt|;
comment|/* CP -> Client */
name|Boolean
name|port_valid
decl_stmt|;
comment|/* Logon -> CP */
name|enum
name|connect_type
name|connect
decl_stmt|;
name|u8
modifier|*
name|authorization_data
decl_stmt|;
comment|/* KaY -> CP */
name|Boolean
name|chgd_server
decl_stmt|;
comment|/* clear by CP */
name|Boolean
name|elected_self
decl_stmt|;
name|u8
modifier|*
name|authorization_data1
decl_stmt|;
name|enum
name|confidentiality_offset
name|cipher_offset
decl_stmt|;
name|u8
modifier|*
name|cipher_suite
decl_stmt|;
name|Boolean
name|new_sak
decl_stmt|;
comment|/* clear by CP */
name|struct
name|ieee802_1x_mka_ki
name|distributed_ki
decl_stmt|;
name|u8
name|distributed_an
decl_stmt|;
name|Boolean
name|using_receive_sas
decl_stmt|;
name|Boolean
name|all_receiving
decl_stmt|;
name|Boolean
name|server_transmitting
decl_stmt|;
name|Boolean
name|using_transmit_sa
decl_stmt|;
comment|/* CP -> KaY */
name|struct
name|ieee802_1x_mka_ki
modifier|*
name|lki
decl_stmt|;
name|u8
name|lan
decl_stmt|;
name|Boolean
name|ltx
decl_stmt|;
name|Boolean
name|lrx
decl_stmt|;
name|struct
name|ieee802_1x_mka_ki
modifier|*
name|oki
decl_stmt|;
name|u8
name|oan
decl_stmt|;
name|Boolean
name|otx
decl_stmt|;
name|Boolean
name|orx
decl_stmt|;
comment|/* CP -> SecY */
name|Boolean
name|protect_frames
decl_stmt|;
name|enum
name|validate_frames
name|validate_frames
decl_stmt|;
name|Boolean
name|replay_protect
decl_stmt|;
name|u32
name|replay_window
decl_stmt|;
name|u8
modifier|*
name|current_cipher_suite
decl_stmt|;
name|enum
name|confidentiality_offset
name|confidentiality_offset
decl_stmt|;
name|Boolean
name|controlled_port_enabled
decl_stmt|;
comment|/* SecY -> CP */
name|Boolean
name|port_enabled
decl_stmt|;
comment|/* SecY->CP */
comment|/* private */
name|u32
name|transmit_when
decl_stmt|;
name|u32
name|transmit_delay
decl_stmt|;
name|u32
name|retire_when
decl_stmt|;
name|u32
name|retire_delay
decl_stmt|;
comment|/* not defined IEEE Std 802.1X-2010 */
name|struct
name|ieee802_1x_kay
modifier|*
name|kay
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|ieee802_1x_cp_retire_when_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee802_1x_cp_transmit_when_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|changed_cipher
parameter_list|(
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
operator|->
name|confidentiality_offset
operator|!=
name|sm
operator|->
name|cipher_offset
operator|||
name|os_memcmp
argument_list|(
name|sm
operator|->
name|current_cipher_suite
argument_list|,
name|sm
operator|->
name|cipher_suite
argument_list|,
name|CS_ID_LEN
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|changed_connect
parameter_list|(
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
operator|->
name|connect
operator|!=
name|SECURE
operator|||
name|sm
operator|->
name|chgd_server
operator|||
name|changed_cipher
argument_list|(
name|sm
argument_list|)
return|;
block|}
end_function

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|INIT
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|INIT
argument_list|)
expr_stmt|;
name|sm
operator|->
name|controlled_port_enabled
operator|=
name|FALSE
expr_stmt|;
name|secy_cp_control_enable_port
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|controlled_port_enabled
argument_list|)
expr_stmt|;
name|sm
operator|->
name|port_valid
operator|=
name|FALSE
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|lki
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lki
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|ltx
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|lrx
operator|=
name|FALSE
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|oki
argument_list|)
expr_stmt|;
name|sm
operator|->
name|oki
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|otx
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|orx
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|port_enabled
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|chgd_server
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|CHANGE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|CHANGE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|port_valid
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|controlled_port_enabled
operator|=
name|FALSE
expr_stmt|;
name|secy_cp_control_enable_port
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|controlled_port_enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|lki
condition|)
name|ieee802_1x_kay_delete_sas
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|lki
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|oki
condition|)
name|ieee802_1x_kay_delete_sas
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|oki
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|ALLOWED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|ALLOWED
argument_list|)
expr_stmt|;
name|sm
operator|->
name|protect_frames
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|replay_protect
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|validate_frames
operator|=
name|Checked
expr_stmt|;
name|sm
operator|->
name|port_valid
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|controlled_port_enabled
operator|=
name|TRUE
expr_stmt|;
name|secy_cp_control_enable_port
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|controlled_port_enabled
argument_list|)
expr_stmt|;
name|secy_cp_control_protect_frames
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|protect_frames
argument_list|)
expr_stmt|;
name|secy_cp_control_validate_frames
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|validate_frames
argument_list|)
expr_stmt|;
name|secy_cp_control_replay
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|replay_protect
argument_list|,
name|sm
operator|->
name|replay_window
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|AUTHENTICATED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|AUTHENTICATED
argument_list|)
expr_stmt|;
name|sm
operator|->
name|protect_frames
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|replay_protect
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|validate_frames
operator|=
name|Checked
expr_stmt|;
name|sm
operator|->
name|port_valid
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|controlled_port_enabled
operator|=
name|TRUE
expr_stmt|;
name|secy_cp_control_enable_port
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|controlled_port_enabled
argument_list|)
expr_stmt|;
name|secy_cp_control_protect_frames
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|protect_frames
argument_list|)
expr_stmt|;
name|secy_cp_control_validate_frames
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|validate_frames
argument_list|)
expr_stmt|;
name|secy_cp_control_replay
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|replay_protect
argument_list|,
name|sm
operator|->
name|replay_window
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|SECURED
argument_list|)
end_macro

begin_block
block|{
name|struct
name|ieee802_1x_cp_conf
name|conf
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|SECURED
argument_list|)
expr_stmt|;
name|sm
operator|->
name|chgd_server
operator|=
name|FALSE
expr_stmt|;
name|ieee802_1x_kay_cp_conf
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
operator|&
name|conf
argument_list|)
expr_stmt|;
name|sm
operator|->
name|protect_frames
operator|=
name|conf
operator|.
name|protect
expr_stmt|;
name|sm
operator|->
name|replay_protect
operator|=
name|conf
operator|.
name|replay_protect
expr_stmt|;
name|sm
operator|->
name|validate_frames
operator|=
name|conf
operator|.
name|validate
expr_stmt|;
comment|/* NOTE: now no other than default cipher suiter(AES-GCM-128) */
name|os_memcpy
argument_list|(
name|sm
operator|->
name|current_cipher_suite
argument_list|,
name|sm
operator|->
name|cipher_suite
argument_list|,
name|CS_ID_LEN
argument_list|)
expr_stmt|;
name|secy_cp_control_current_cipher_suite
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|current_cipher_suite
argument_list|,
name|CS_ID_LEN
argument_list|)
expr_stmt|;
name|sm
operator|->
name|confidentiality_offset
operator|=
name|sm
operator|->
name|cipher_offset
expr_stmt|;
name|sm
operator|->
name|port_valid
operator|=
name|TRUE
expr_stmt|;
name|secy_cp_control_confidentiality_offset
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|confidentiality_offset
argument_list|)
expr_stmt|;
name|secy_cp_control_protect_frames
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|protect_frames
argument_list|)
expr_stmt|;
name|secy_cp_control_validate_frames
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|validate_frames
argument_list|)
expr_stmt|;
name|secy_cp_control_replay
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|replay_protect
argument_list|,
name|sm
operator|->
name|replay_window
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|RECEIVE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|RECEIVE
argument_list|)
expr_stmt|;
comment|/* RECEIVE state machine not keep with Figure 12-2 in 	 * IEEE Std 802.1X-2010 */
name|sm
operator|->
name|oki
operator|=
name|sm
operator|->
name|lki
expr_stmt|;
name|sm
operator|->
name|oan
operator|=
name|sm
operator|->
name|lan
expr_stmt|;
name|sm
operator|->
name|otx
operator|=
name|sm
operator|->
name|ltx
expr_stmt|;
name|sm
operator|->
name|orx
operator|=
name|sm
operator|->
name|lrx
expr_stmt|;
name|ieee802_1x_kay_set_old_sa_attr
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|oki
argument_list|,
name|sm
operator|->
name|oan
argument_list|,
name|sm
operator|->
name|otx
argument_list|,
name|sm
operator|->
name|orx
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lki
operator|=
name|os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sm
operator|->
name|lki
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sm
operator|->
name|lki
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CP-%s: Out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|os_memcpy
argument_list|(
name|sm
operator|->
name|lki
argument_list|,
operator|&
name|sm
operator|->
name|distributed_ki
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sm
operator|->
name|lki
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lan
operator|=
name|sm
operator|->
name|distributed_an
expr_stmt|;
name|sm
operator|->
name|ltx
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|lrx
operator|=
name|FALSE
expr_stmt|;
name|ieee802_1x_kay_set_latest_sa_attr
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|lki
argument_list|,
name|sm
operator|->
name|lan
argument_list|,
name|sm
operator|->
name|ltx
argument_list|,
name|sm
operator|->
name|lrx
argument_list|)
expr_stmt|;
name|ieee802_1x_kay_create_sas
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|lki
argument_list|)
expr_stmt|;
name|ieee802_1x_kay_enable_rx_sas
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|lki
argument_list|)
expr_stmt|;
name|sm
operator|->
name|new_sak
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|all_receiving
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|RECEIVING
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|RECEIVING
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lrx
operator|=
name|TRUE
expr_stmt|;
name|ieee802_1x_kay_set_latest_sa_attr
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|lki
argument_list|,
name|sm
operator|->
name|lan
argument_list|,
name|sm
operator|->
name|ltx
argument_list|,
name|sm
operator|->
name|lrx
argument_list|)
expr_stmt|;
name|sm
operator|->
name|transmit_when
operator|=
name|sm
operator|->
name|transmit_delay
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|ieee802_1x_cp_transmit_when_timeout
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|sm
operator|->
name|transmit_when
operator|/
literal|1000
argument_list|,
literal|0
argument_list|,
name|ieee802_1x_cp_transmit_when_timeout
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* the electedSelf have been set before CP entering to RECEIVING 	 * but the CP will transmit from RECEIVING to READY under 	 * the !electedSelf when KaY is not key server */
name|ieee802_1x_cp_sm_step
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|using_receive_sas
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|server_transmitting
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|READY
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|READY
argument_list|)
expr_stmt|;
name|ieee802_1x_kay_enable_new_info
argument_list|(
name|sm
operator|->
name|kay
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|TRANSMIT
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|TRANSMIT
argument_list|)
expr_stmt|;
name|sm
operator|->
name|controlled_port_enabled
operator|=
name|TRUE
expr_stmt|;
name|secy_cp_control_enable_port
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|controlled_port_enabled
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ltx
operator|=
name|TRUE
expr_stmt|;
name|ieee802_1x_kay_set_latest_sa_attr
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|lki
argument_list|,
name|sm
operator|->
name|lan
argument_list|,
name|sm
operator|->
name|ltx
argument_list|,
name|sm
operator|->
name|lrx
argument_list|)
expr_stmt|;
name|ieee802_1x_kay_enable_tx_sas
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|lki
argument_list|)
expr_stmt|;
name|sm
operator|->
name|all_receiving
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|server_transmitting
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|TRANSMITTING
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|TRANSMITTING
argument_list|)
expr_stmt|;
name|sm
operator|->
name|retire_when
operator|=
name|sm
operator|->
name|orx
condition|?
name|sm
operator|->
name|retire_delay
else|:
literal|0
expr_stmt|;
name|sm
operator|->
name|otx
operator|=
name|FALSE
expr_stmt|;
name|ieee802_1x_kay_set_old_sa_attr
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|oki
argument_list|,
name|sm
operator|->
name|oan
argument_list|,
name|sm
operator|->
name|otx
argument_list|,
name|sm
operator|->
name|orx
argument_list|)
expr_stmt|;
name|ieee802_1x_kay_enable_new_info
argument_list|(
name|sm
operator|->
name|kay
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|ieee802_1x_cp_retire_when_timeout
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|sm
operator|->
name|retire_when
operator|/
literal|1000
argument_list|,
literal|0
argument_list|,
name|ieee802_1x_cp_retire_when_timeout
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sm
operator|->
name|using_transmit_sa
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|ABANDON
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|ABANDON
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lrx
operator|=
name|FALSE
expr_stmt|;
name|ieee802_1x_kay_set_latest_sa_attr
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|lki
argument_list|,
name|sm
operator|->
name|lan
argument_list|,
name|sm
operator|->
name|ltx
argument_list|,
name|sm
operator|->
name|lrx
argument_list|)
expr_stmt|;
name|ieee802_1x_kay_delete_sas
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|lki
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|lki
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lki
operator|=
name|NULL
expr_stmt|;
name|ieee802_1x_kay_set_latest_sa_attr
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|lki
argument_list|,
name|sm
operator|->
name|lan
argument_list|,
name|sm
operator|->
name|ltx
argument_list|,
name|sm
operator|->
name|lrx
argument_list|)
expr_stmt|;
name|sm
operator|->
name|new_sak
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|CP
argument_list|,
argument|RETIRE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|CP
argument_list|,
name|RETIRE
argument_list|)
expr_stmt|;
comment|/* RETIRE state machine not keep with Figure 12-2 in 	 * IEEE Std 802.1X-2010 */
name|os_free
argument_list|(
name|sm
operator|->
name|oki
argument_list|)
expr_stmt|;
name|sm
operator|->
name|oki
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|orx
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|otx
operator|=
name|FALSE
expr_stmt|;
name|ieee802_1x_kay_set_old_sa_attr
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|oki
argument_list|,
name|sm
operator|->
name|oan
argument_list|,
name|sm
operator|->
name|otx
argument_list|,
name|sm
operator|->
name|orx
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/**  * CP state machine handler entry  */
end_comment

begin_macro
name|SM_STEP
argument_list|(
argument|CP
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|sm
operator|->
name|port_enabled
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|INIT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sm
operator|->
name|CP_state
condition|)
block|{
case|case
name|CP_BEGIN
case|:
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|INIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_INIT
case|:
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|CHANGE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_CHANGE
case|:
if|if
condition|(
name|sm
operator|->
name|connect
operator|==
name|UNAUTHENTICATED
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|ALLOWED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|connect
operator|==
name|AUTHENTICATED
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|AUTHENTICATED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|connect
operator|==
name|SECURE
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|SECURED
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ALLOWED
case|:
if|if
condition|(
name|sm
operator|->
name|connect
operator|!=
name|UNAUTHENTICATED
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|CHANGE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_AUTHENTICATED
case|:
if|if
condition|(
name|sm
operator|->
name|connect
operator|!=
name|AUTHENTICATED
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|CHANGE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SECURED
case|:
if|if
condition|(
name|changed_connect
argument_list|(
name|sm
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|CHANGE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|new_sak
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|RECEIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_RECEIVE
case|:
if|if
condition|(
name|sm
operator|->
name|using_receive_sas
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|RECEIVING
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_RECEIVING
case|:
if|if
condition|(
name|sm
operator|->
name|new_sak
operator|||
name|changed_connect
argument_list|(
name|sm
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|ABANDON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sm
operator|->
name|elected_self
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|READY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|elected_self
operator|&&
operator|(
name|sm
operator|->
name|all_receiving
operator|||
operator|!
name|sm
operator|->
name|transmit_when
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|TRANSMIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_TRANSMIT
case|:
if|if
condition|(
name|sm
operator|->
name|using_transmit_sa
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|TRANSMITTING
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_TRANSMITTING
case|:
if|if
condition|(
operator|!
name|sm
operator|->
name|retire_when
operator|||
name|changed_connect
argument_list|(
name|sm
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|RETIRE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_RETIRE
case|:
if|if
condition|(
name|changed_connect
argument_list|(
name|sm
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|CHANGE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|new_sak
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|RECEIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_READY
case|:
if|if
condition|(
name|sm
operator|->
name|new_sak
operator|||
name|changed_connect
argument_list|(
name|sm
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|RECEIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|server_transmitting
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|TRANSMIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ABANDON
case|:
if|if
condition|(
name|changed_connect
argument_list|(
name|sm
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|RETIRE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|new_sak
condition|)
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|RECEIVE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CP: the state machine is not defined"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/**  * ieee802_1x_cp_sm_init -  */
end_comment

begin_function
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|ieee802_1x_cp_sm_init
parameter_list|(
name|struct
name|ieee802_1x_kay
modifier|*
name|kay
parameter_list|,
name|struct
name|ieee802_1x_cp_conf
modifier|*
name|pcp_conf
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
decl_stmt|;
name|sm
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CP-%s: out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sm
operator|->
name|kay
operator|=
name|kay
expr_stmt|;
name|sm
operator|->
name|port_valid
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|chgd_server
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|protect_frames
operator|=
name|pcp_conf
operator|->
name|protect
expr_stmt|;
name|sm
operator|->
name|validate_frames
operator|=
name|pcp_conf
operator|->
name|validate
expr_stmt|;
name|sm
operator|->
name|replay_protect
operator|=
name|pcp_conf
operator|->
name|replay_protect
expr_stmt|;
name|sm
operator|->
name|replay_window
operator|=
name|pcp_conf
operator|->
name|replay_window
expr_stmt|;
name|sm
operator|->
name|controlled_port_enabled
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|lki
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|lrx
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|ltx
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|oki
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|orx
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|otx
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|cipher_suite
operator|=
name|os_zalloc
argument_list|(
name|CS_ID_LEN
argument_list|)
expr_stmt|;
name|sm
operator|->
name|current_cipher_suite
operator|=
name|os_zalloc
argument_list|(
name|CS_ID_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sm
operator|->
name|cipher_suite
operator|||
operator|!
name|sm
operator|->
name|current_cipher_suite
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"CP-%s: out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|cipher_suite
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|current_cipher_suite
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|os_memcpy
argument_list|(
name|sm
operator|->
name|current_cipher_suite
argument_list|,
name|default_cs_id
argument_list|,
name|CS_ID_LEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|sm
operator|->
name|cipher_suite
argument_list|,
name|default_cs_id
argument_list|,
name|CS_ID_LEN
argument_list|)
expr_stmt|;
name|sm
operator|->
name|cipher_offset
operator|=
name|CONFIDENTIALITY_OFFSET_0
expr_stmt|;
name|sm
operator|->
name|confidentiality_offset
operator|=
name|sm
operator|->
name|cipher_offset
expr_stmt|;
name|sm
operator|->
name|transmit_delay
operator|=
name|MKA_LIFE_TIME
expr_stmt|;
name|sm
operator|->
name|retire_delay
operator|=
name|MKA_SAK_RETIRE_TIME
expr_stmt|;
name|sm
operator|->
name|CP_state
operator|=
name|CP_BEGIN
expr_stmt|;
name|sm
operator|->
name|changed
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|authorization_data
operator|=
name|NULL
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CP: state machine created"
argument_list|)
expr_stmt|;
name|secy_cp_control_protect_frames
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|protect_frames
argument_list|)
expr_stmt|;
name|secy_cp_control_validate_frames
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|validate_frames
argument_list|)
expr_stmt|;
name|secy_cp_control_replay
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|replay_protect
argument_list|,
name|sm
operator|->
name|replay_window
argument_list|)
expr_stmt|;
name|secy_cp_control_enable_port
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|controlled_port_enabled
argument_list|)
expr_stmt|;
name|secy_cp_control_confidentiality_offset
argument_list|(
name|sm
operator|->
name|kay
argument_list|,
name|sm
operator|->
name|confidentiality_offset
argument_list|)
expr_stmt|;
name|SM_ENTER
argument_list|(
name|CP
argument_list|,
name|INIT
argument_list|)
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|CP
argument_list|)
expr_stmt|;
return|return
name|sm
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee802_1x_cp_step_run
parameter_list|(
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
parameter_list|)
block|{
name|enum
name|cp_states
name|prev_state
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|prev_state
operator|=
name|sm
operator|->
name|CP_state
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|CP
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_state
operator|==
name|sm
operator|->
name|CP_state
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ieee802_1x_cp_step_cb
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|eloop_ctx
decl_stmt|;
name|ieee802_1x_cp_step_run
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_sm_deinit -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_sm_deinit
parameter_list|(
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"CP: state machine removed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sm
condition|)
return|return;
name|eloop_cancel_timeout
argument_list|(
name|ieee802_1x_cp_retire_when_timeout
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|ieee802_1x_cp_transmit_when_timeout
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|ieee802_1x_cp_step_cb
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|lki
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|oki
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|cipher_suite
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|current_cipher_suite
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|authorization_data
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_connect_pending  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_connect_pending
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|connect
operator|=
name|PENDING
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_connect_unauthenticated  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_connect_unauthenticated
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
operator|(
expr|struct
name|ieee802_1x_cp_sm
operator|*
operator|)
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|connect
operator|=
name|UNAUTHENTICATED
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_connect_authenticated  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_connect_authenticated
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|connect
operator|=
name|AUTHENTICATED
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_connect_secure  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_connect_secure
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|connect
operator|=
name|SECURE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_chgdserver -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_signal_chgdserver
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|chgd_server
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_electedself -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_set_electedself
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|,
name|Boolean
name|status
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|elected_self
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_authorizationdata -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_set_authorizationdata
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|,
name|u8
modifier|*
name|pdata
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|authorization_data
argument_list|)
expr_stmt|;
name|sm
operator|->
name|authorization_data
operator|=
name|os_zalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|authorization_data
condition|)
name|os_memcpy
argument_list|(
name|sm
operator|->
name|authorization_data
argument_list|,
name|pdata
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_ciphersuite -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_set_ciphersuite
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|,
name|void
modifier|*
name|pid
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|os_memcpy
argument_list|(
name|sm
operator|->
name|cipher_suite
argument_list|,
name|pid
argument_list|,
name|CS_ID_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_offset -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_set_offset
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|,
name|enum
name|confidentiality_offset
name|offset
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|cipher_offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_signal_newsak -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_signal_newsak
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|new_sak
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_distributedki -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_set_distributedki
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|,
specifier|const
name|struct
name|ieee802_1x_mka_ki
modifier|*
name|dki
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|os_memcpy
argument_list|(
operator|&
name|sm
operator|->
name|distributed_ki
argument_list|,
name|dki
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee802_1x_mka_ki
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_distributedan -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_set_distributedan
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|,
name|u8
name|an
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|distributed_an
operator|=
name|an
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_usingreceivesas -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_set_usingreceivesas
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|,
name|Boolean
name|status
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|using_receive_sas
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_allreceiving -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_set_allreceiving
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|,
name|Boolean
name|status
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|all_receiving
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_servertransmitting -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_set_servertransmitting
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|,
name|Boolean
name|status
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|server_transmitting
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_set_usingtransmitsas -  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_set_usingtransmitas
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|,
name|Boolean
name|status
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|sm
operator|->
name|using_transmit_sa
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ieee802_1x_cp_sm_step - Advance EAPOL state machines  * @sm: EAPOL state machine  *  * This function is called to advance CP state machines after any change  * that could affect their state.  */
end_comment

begin_function
name|void
name|ieee802_1x_cp_sm_step
parameter_list|(
name|void
modifier|*
name|cp_ctx
parameter_list|)
block|{
comment|/* 	 * Run ieee802_1x_cp_step_run from a registered timeout 	 * to make sure that other possible timeouts/events are processed 	 * and to avoid long function call chains. 	 */
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|cp_ctx
decl_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|ieee802_1x_cp_step_cb
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ieee802_1x_cp_step_cb
argument_list|,
name|sm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee802_1x_cp_retire_when_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|eloop_ctx
decl_stmt|;
name|sm
operator|->
name|retire_when
operator|=
literal|0
expr_stmt|;
name|ieee802_1x_cp_step_run
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee802_1x_cp_transmit_when_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|ieee802_1x_cp_sm
modifier|*
name|sm
init|=
name|eloop_ctx
decl_stmt|;
name|sm
operator|->
name|transmit_when
operator|=
literal|0
expr_stmt|;
name|ieee802_1x_cp_step_run
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

