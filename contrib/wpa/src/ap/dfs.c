begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * DFS - Dynamic Frequency Selection  * Copyright (c) 2002-2013, Jouni Malinen<j@w1.fi>  * Copyright (c) 2013-2015, Qualcomm Atheros, Inc.  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"utils/includes.h"
end_include

begin_include
include|#
directive|include
file|"utils/common.h"
end_include

begin_include
include|#
directive|include
file|"common/ieee802_11_defs.h"
end_include

begin_include
include|#
directive|include
file|"common/hw_features_common.h"
end_include

begin_include
include|#
directive|include
file|"common/wpa_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"hostapd.h"
end_include

begin_include
include|#
directive|include
file|"ap_drv_ops.h"
end_include

begin_include
include|#
directive|include
file|"drivers/driver.h"
end_include

begin_include
include|#
directive|include
file|"dfs.h"
end_include

begin_function
specifier|static
name|int
name|dfs_get_used_n_chans
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
modifier|*
name|seg1
parameter_list|)
block|{
name|int
name|n_chans
init|=
literal|1
decl_stmt|;
operator|*
name|seg1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|ieee80211n
operator|&&
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
condition|)
name|n_chans
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|ieee80211ac
condition|)
block|{
switch|switch
condition|(
name|iface
operator|->
name|conf
operator|->
name|vht_oper_chwidth
condition|)
block|{
case|case
name|VHT_CHANWIDTH_USE_HT
case|:
break|break;
case|case
name|VHT_CHANWIDTH_80MHZ
case|:
name|n_chans
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|VHT_CHANWIDTH_160MHZ
case|:
name|n_chans
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|VHT_CHANWIDTH_80P80MHZ
case|:
name|n_chans
operator|=
literal|4
expr_stmt|;
operator|*
name|seg1
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|n_chans
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dfs_channel_available
parameter_list|(
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|,
name|int
name|skip_radar
parameter_list|)
block|{
comment|/* 	 * When radar detection happens, CSA is performed. However, there's no 	 * time for CAC, so radar channels must be skipped when finding a new 	 * channel for CSA, unless they are available for immediate use. 	 */
if|if
condition|(
name|skip_radar
operator|&&
operator|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_RADAR
operator|)
operator|&&
operator|(
operator|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DFS_MASK
operator|)
operator|!=
name|HOSTAPD_CHAN_DFS_AVAILABLE
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DISABLED
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_RADAR
operator|)
operator|&&
operator|(
operator|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DFS_MASK
operator|)
operator|==
name|HOSTAPD_CHAN_DFS_UNAVAILABLE
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dfs_is_chan_allowed
parameter_list|(
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|,
name|int
name|n_chans
parameter_list|)
block|{
comment|/* 	 * The tables contain first valid channel number based on channel width. 	 * We will also choose this first channel as the control one. 	 */
name|int
name|allowed_40
index|[]
init|=
block|{
literal|36
block|,
literal|44
block|,
literal|52
block|,
literal|60
block|,
literal|100
block|,
literal|108
block|,
literal|116
block|,
literal|124
block|,
literal|132
block|,
literal|149
block|,
literal|157
block|,
literal|184
block|,
literal|192
block|}
decl_stmt|;
comment|/* 	 * VHT80, valid channels based on center frequency: 	 * 42, 58, 106, 122, 138, 155 	 */
name|int
name|allowed_80
index|[]
init|=
block|{
literal|36
block|,
literal|52
block|,
literal|100
block|,
literal|116
block|,
literal|132
block|,
literal|149
block|}
decl_stmt|;
comment|/* 	 * VHT160 valid channels based on center frequency: 	 * 50, 114 	 */
name|int
name|allowed_160
index|[]
init|=
block|{
literal|36
block|,
literal|100
block|}
decl_stmt|;
name|int
modifier|*
name|allowed
init|=
name|allowed_40
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|allowed_no
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|n_chans
condition|)
block|{
case|case
literal|2
case|:
name|allowed
operator|=
name|allowed_40
expr_stmt|;
name|allowed_no
operator|=
name|ARRAY_SIZE
argument_list|(
name|allowed_40
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|allowed
operator|=
name|allowed_80
expr_stmt|;
name|allowed_no
operator|=
name|ARRAY_SIZE
argument_list|(
name|allowed_80
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|allowed
operator|=
name|allowed_160
expr_stmt|;
name|allowed_no
operator|=
name|ARRAY_SIZE
argument_list|(
name|allowed_160
argument_list|)
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Unknown width for %d channels"
argument_list|,
name|n_chans
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|allowed_no
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chan
operator|->
name|chan
operator|==
name|allowed
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hostapd_channel_data
modifier|*
name|dfs_get_chan_data
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|first_chan_idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_chan_idx
init|;
name|i
operator|<
name|mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mode
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|freq
operator|==
name|freq
condition|)
return|return
operator|&
name|mode
operator|->
name|channels
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dfs_chan_range_available
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
name|int
name|first_chan_idx
parameter_list|,
name|int
name|num_chans
parameter_list|,
name|int
name|skip_radar
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|first_chan
decl_stmt|,
modifier|*
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|first_chan_idx
operator|+
name|num_chans
operator|>
name|mode
operator|->
name|num_channels
condition|)
return|return
literal|0
return|;
name|first_chan
operator|=
operator|&
name|mode
operator|->
name|channels
index|[
name|first_chan_idx
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
name|dfs_get_chan_data
argument_list|(
name|mode
argument_list|,
name|first_chan
operator|->
name|freq
operator|+
name|i
operator|*
literal|20
argument_list|,
name|first_chan_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chan
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|dfs_channel_available
argument_list|(
name|chan
argument_list|,
name|skip_radar
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_in_chanlist
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iface
operator|->
name|conf
operator|->
name|acs_ch_list
operator|.
name|num
condition|)
return|return
literal|1
return|;
return|return
name|freq_range_list_includes
argument_list|(
operator|&
name|iface
operator|->
name|conf
operator|->
name|acs_ch_list
argument_list|,
name|chan
operator|->
name|chan
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * The function assumes HT40+ operation.  * Make sure to adjust the following variables after calling this:  *  - hapd->secondary_channel  *  - hapd->vht_oper_centr_freq_seg0_idx  *  - hapd->vht_oper_centr_freq_seg1_idx  */
end_comment

begin_function
specifier|static
name|int
name|dfs_find_channel
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|struct
name|hostapd_channel_data
modifier|*
modifier|*
name|ret_chan
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|skip_radar
parameter_list|)
block|{
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|struct
name|hostapd_channel_data
modifier|*
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|,
name|channel_idx
init|=
literal|0
decl_stmt|,
name|n_chans
decl_stmt|,
name|n_chans1
decl_stmt|;
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
name|n_chans
operator|=
name|dfs_get_used_n_chans
argument_list|(
name|iface
argument_list|,
operator|&
name|n_chans1
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS new chan checking %d channels"
argument_list|,
name|n_chans
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
operator|&
name|mode
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
comment|/* Skip HT40/VHT incompatible channels */
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|ieee80211n
operator|&&
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
operator|&&
operator|!
name|dfs_is_chan_allowed
argument_list|(
name|chan
argument_list|,
name|n_chans
argument_list|)
condition|)
continue|continue;
comment|/* Skip incompatible chandefs */
if|if
condition|(
operator|!
name|dfs_chan_range_available
argument_list|(
name|mode
argument_list|,
name|i
argument_list|,
name|n_chans
argument_list|,
name|skip_radar
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_in_chanlist
argument_list|(
name|iface
argument_list|,
name|chan
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ret_chan
operator|&&
name|idx
operator|==
name|channel_idx
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Selected ch. #%d"
argument_list|,
name|chan
operator|->
name|chan
argument_list|)
expr_stmt|;
operator|*
name|ret_chan
operator|=
name|chan
expr_stmt|;
return|return
name|idx
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Adding channel: %d"
argument_list|,
name|chan
operator|->
name|chan
argument_list|)
expr_stmt|;
name|channel_idx
operator|++
expr_stmt|;
block|}
return|return
name|channel_idx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_adjust_vht_center_freq
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|,
name|int
name|secondary_channel
parameter_list|,
name|u8
modifier|*
name|vht_oper_centr_freq_seg0_idx
parameter_list|,
name|u8
modifier|*
name|vht_oper_centr_freq_seg1_idx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iface
operator|->
name|conf
operator|->
name|ieee80211ac
condition|)
return|return;
if|if
condition|(
operator|!
name|chan
condition|)
return|return;
operator|*
name|vht_oper_centr_freq_seg1_idx
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|iface
operator|->
name|conf
operator|->
name|vht_oper_chwidth
condition|)
block|{
case|case
name|VHT_CHANWIDTH_USE_HT
case|:
if|if
condition|(
name|secondary_channel
operator|==
literal|1
condition|)
operator|*
name|vht_oper_centr_freq_seg0_idx
operator|=
name|chan
operator|->
name|chan
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|secondary_channel
operator|==
operator|-
literal|1
condition|)
operator|*
name|vht_oper_centr_freq_seg0_idx
operator|=
name|chan
operator|->
name|chan
operator|-
literal|2
expr_stmt|;
else|else
operator|*
name|vht_oper_centr_freq_seg0_idx
operator|=
name|chan
operator|->
name|chan
expr_stmt|;
break|break;
case|case
name|VHT_CHANWIDTH_80MHZ
case|:
operator|*
name|vht_oper_centr_freq_seg0_idx
operator|=
name|chan
operator|->
name|chan
operator|+
literal|6
expr_stmt|;
break|break;
case|case
name|VHT_CHANWIDTH_160MHZ
case|:
operator|*
name|vht_oper_centr_freq_seg0_idx
operator|=
name|chan
operator|->
name|chan
operator|+
literal|14
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"DFS only VHT20/40/80/160 is supported now"
argument_list|)
expr_stmt|;
operator|*
name|vht_oper_centr_freq_seg0_idx
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS adjusting VHT center frequency: %d, %d"
argument_list|,
operator|*
name|vht_oper_centr_freq_seg0_idx
argument_list|,
operator|*
name|vht_oper_centr_freq_seg1_idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return start channel idx we will use for mode->channels[idx] */
end_comment

begin_function
specifier|static
name|int
name|dfs_get_start_chan_idx
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
modifier|*
name|seg1_start
parameter_list|)
block|{
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|struct
name|hostapd_channel_data
modifier|*
name|chan
decl_stmt|;
name|int
name|channel_no
init|=
name|iface
operator|->
name|conf
operator|->
name|channel
decl_stmt|;
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|int
name|chan_seg1
init|=
operator|-
literal|1
decl_stmt|;
operator|*
name|seg1_start
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* HT40- */
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|ieee80211n
operator|&&
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
operator|==
operator|-
literal|1
condition|)
name|channel_no
operator|-=
literal|4
expr_stmt|;
comment|/* VHT */
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|ieee80211ac
condition|)
block|{
switch|switch
condition|(
name|iface
operator|->
name|conf
operator|->
name|vht_oper_chwidth
condition|)
block|{
case|case
name|VHT_CHANWIDTH_USE_HT
case|:
break|break;
case|case
name|VHT_CHANWIDTH_80MHZ
case|:
name|channel_no
operator|=
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg0_idx
operator|-
literal|6
expr_stmt|;
break|break;
case|case
name|VHT_CHANWIDTH_160MHZ
case|:
name|channel_no
operator|=
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg0_idx
operator|-
literal|14
expr_stmt|;
break|break;
case|case
name|VHT_CHANWIDTH_80P80MHZ
case|:
name|channel_no
operator|=
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg0_idx
operator|-
literal|6
expr_stmt|;
name|chan_seg1
operator|=
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg1_idx
operator|-
literal|6
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"DFS only VHT20/40/80/160/80+80 is supported now"
argument_list|)
expr_stmt|;
name|channel_no
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Get idx */
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
operator|&
name|mode
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|chan
operator|==
name|channel_no
condition|)
block|{
name|res
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
operator|&&
name|chan_seg1
operator|>
operator|-
literal|1
condition|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* Get idx for seg1 */
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
operator|&
name|mode
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|chan
operator|==
name|chan_seg1
condition|)
block|{
operator|*
name|seg1_start
operator|=
name|i
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|res
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS chan_idx seems wrong; num-ch: %d ch-no: %d conf-ch-no: %d 11n: %d sec-ch: %d vht-oper-width: %d"
argument_list|,
name|mode
operator|->
name|num_channels
argument_list|,
name|channel_no
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|channel
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|ieee80211n
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|vht_oper_chwidth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Available channel: %d"
argument_list|,
name|mode
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* At least one channel have radar flag */
end_comment

begin_function
specifier|static
name|int
name|dfs_check_chans_radar
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|start_chan_idx
parameter_list|,
name|int
name|n_chans
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|channel
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|res
init|=
literal|0
decl_stmt|;
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_chans
condition|;
name|i
operator|++
control|)
block|{
name|channel
operator|=
operator|&
name|mode
operator|->
name|channels
index|[
name|start_chan_idx
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_RADAR
condition|)
name|res
operator|++
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* All channels available */
end_comment

begin_function
specifier|static
name|int
name|dfs_check_chans_available
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|start_chan_idx
parameter_list|,
name|int
name|n_chans
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|channel
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_chans
condition|;
name|i
operator|++
control|)
block|{
name|channel
operator|=
operator|&
name|mode
operator|->
name|channels
index|[
name|start_chan_idx
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DISABLED
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|channel
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_RADAR
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|channel
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DFS_MASK
operator|)
operator|!=
name|HOSTAPD_CHAN_DFS_AVAILABLE
condition|)
break|break;
block|}
return|return
name|i
operator|==
name|n_chans
return|;
block|}
end_function

begin_comment
comment|/* At least one channel unavailable */
end_comment

begin_function
specifier|static
name|int
name|dfs_check_chans_unavailable
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|start_chan_idx
parameter_list|,
name|int
name|n_chans
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|channel
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|res
init|=
literal|0
decl_stmt|;
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_chans
condition|;
name|i
operator|++
control|)
block|{
name|channel
operator|=
operator|&
name|mode
operator|->
name|channels
index|[
name|start_chan_idx
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DISABLED
condition|)
name|res
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DFS_MASK
operator|)
operator|==
name|HOSTAPD_CHAN_DFS_UNAVAILABLE
condition|)
name|res
operator|++
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hostapd_channel_data
modifier|*
name|dfs_get_valid_channel
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
modifier|*
name|secondary_channel
parameter_list|,
name|u8
modifier|*
name|vht_oper_centr_freq_seg0_idx
parameter_list|,
name|u8
modifier|*
name|vht_oper_centr_freq_seg1_idx
parameter_list|,
name|int
name|skip_radar
parameter_list|)
block|{
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|struct
name|hostapd_channel_data
modifier|*
name|chan
init|=
name|NULL
decl_stmt|;
name|int
name|num_available_chandefs
decl_stmt|;
name|int
name|chan_idx
decl_stmt|;
name|u32
name|_rand
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS: Selecting random channel"
argument_list|)
expr_stmt|;
operator|*
name|secondary_channel
operator|=
literal|0
expr_stmt|;
operator|*
name|vht_oper_centr_freq_seg0_idx
operator|=
literal|0
expr_stmt|;
operator|*
name|vht_oper_centr_freq_seg1_idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|current_mode
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|mode
operator|!=
name|HOSTAPD_MODE_IEEE80211A
condition|)
return|return
name|NULL
return|;
comment|/* Get the count first */
name|num_available_chandefs
operator|=
name|dfs_find_channel
argument_list|(
name|iface
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|skip_radar
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_available_chandefs
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|os_get_random
argument_list|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|_rand
argument_list|,
sizeof|sizeof
argument_list|(
name|_rand
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|_rand
operator|=
name|os_random
argument_list|()
expr_stmt|;
name|chan_idx
operator|=
name|_rand
operator|%
name|num_available_chandefs
expr_stmt|;
name|dfs_find_channel
argument_list|(
name|iface
argument_list|,
operator|&
name|chan
argument_list|,
name|chan_idx
argument_list|,
name|skip_radar
argument_list|)
expr_stmt|;
comment|/* dfs_find_channel() calculations assume HT40+ */
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
condition|)
operator|*
name|secondary_channel
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|secondary_channel
operator|=
literal|0
expr_stmt|;
name|dfs_adjust_vht_center_freq
argument_list|(
name|iface
argument_list|,
name|chan
argument_list|,
operator|*
name|secondary_channel
argument_list|,
name|vht_oper_centr_freq_seg0_idx
argument_list|,
name|vht_oper_centr_freq_seg1_idx
argument_list|)
expr_stmt|;
return|return
name|chan
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_dfs_state_freq
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|freq
parameter_list|,
name|u32
name|state
parameter_list|)
block|{
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|struct
name|hostapd_channel_data
modifier|*
name|chan
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"set_dfs_state 0x%X for %d MHz"
argument_list|,
name|state
argument_list|,
name|freq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iface
operator|->
name|current_mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
operator|&
name|iface
operator|->
name|current_mode
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|freq
operator|==
name|freq
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_RADAR
condition|)
block|{
name|chan
operator|->
name|flag
operator|&=
operator|~
name|HOSTAPD_CHAN_DFS_MASK
expr_stmt|;
name|chan
operator|->
name|flag
operator||=
name|state
expr_stmt|;
return|return
literal|1
return|;
comment|/* Channel found */
block|}
block|}
block|}
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Can't set DFS state for freq %d MHz"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_dfs_state
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|ht_enabled
parameter_list|,
name|int
name|chan_offset
parameter_list|,
name|int
name|chan_width
parameter_list|,
name|int
name|cf1
parameter_list|,
name|int
name|cf2
parameter_list|,
name|u32
name|state
parameter_list|)
block|{
name|int
name|n_chans
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|int
name|frequency
init|=
name|freq
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|->
name|mode
operator|!=
name|HOSTAPD_MODE_IEEE80211A
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"current_mode != IEEE80211A"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Seems cf1 and chan_width is enough here */
switch|switch
condition|(
name|chan_width
condition|)
block|{
case|case
name|CHAN_WIDTH_20_NOHT
case|:
case|case
name|CHAN_WIDTH_20
case|:
name|n_chans
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|frequency
operator|==
literal|0
condition|)
name|frequency
operator|=
name|cf1
expr_stmt|;
break|break;
case|case
name|CHAN_WIDTH_40
case|:
name|n_chans
operator|=
literal|2
expr_stmt|;
name|frequency
operator|=
name|cf1
operator|-
literal|10
expr_stmt|;
break|break;
case|case
name|CHAN_WIDTH_80
case|:
name|n_chans
operator|=
literal|4
expr_stmt|;
name|frequency
operator|=
name|cf1
operator|-
literal|30
expr_stmt|;
break|break;
case|case
name|CHAN_WIDTH_160
case|:
name|n_chans
operator|=
literal|8
expr_stmt|;
name|frequency
operator|=
name|cf1
operator|-
literal|70
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"DFS chan_width %d not supported"
argument_list|,
name|chan_width
argument_list|)
expr_stmt|;
break|break;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS freq: %dMHz, n_chans: %d"
argument_list|,
name|frequency
argument_list|,
name|n_chans
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_chans
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|+=
name|set_dfs_state_freq
argument_list|(
name|iface
argument_list|,
name|frequency
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|frequency
operator|=
name|frequency
operator|+
literal|20
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dfs_are_channels_overlapped
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|chan_width
parameter_list|,
name|int
name|cf1
parameter_list|,
name|int
name|cf2
parameter_list|)
block|{
name|int
name|start_chan_idx
decl_stmt|,
name|start_chan_idx1
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|struct
name|hostapd_channel_data
modifier|*
name|chan
decl_stmt|;
name|int
name|n_chans
decl_stmt|,
name|n_chans1
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|frequency
init|=
name|freq
decl_stmt|,
name|radar_n_chans
init|=
literal|1
decl_stmt|;
name|u8
name|radar_chan
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
comment|/* Our configuration */
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
name|start_chan_idx
operator|=
name|dfs_get_start_chan_idx
argument_list|(
name|iface
argument_list|,
operator|&
name|start_chan_idx1
argument_list|)
expr_stmt|;
name|n_chans
operator|=
name|dfs_get_used_n_chans
argument_list|(
name|iface
argument_list|,
operator|&
name|n_chans1
argument_list|)
expr_stmt|;
comment|/* Check we are on DFS channel(s) */
if|if
condition|(
operator|!
name|dfs_check_chans_radar
argument_list|(
name|iface
argument_list|,
name|start_chan_idx
argument_list|,
name|n_chans
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reported via radar event */
switch|switch
condition|(
name|chan_width
condition|)
block|{
case|case
name|CHAN_WIDTH_20_NOHT
case|:
case|case
name|CHAN_WIDTH_20
case|:
name|radar_n_chans
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|frequency
operator|==
literal|0
condition|)
name|frequency
operator|=
name|cf1
expr_stmt|;
break|break;
case|case
name|CHAN_WIDTH_40
case|:
name|radar_n_chans
operator|=
literal|2
expr_stmt|;
name|frequency
operator|=
name|cf1
operator|-
literal|10
expr_stmt|;
break|break;
case|case
name|CHAN_WIDTH_80
case|:
name|radar_n_chans
operator|=
literal|4
expr_stmt|;
name|frequency
operator|=
name|cf1
operator|-
literal|30
expr_stmt|;
break|break;
case|case
name|CHAN_WIDTH_160
case|:
name|radar_n_chans
operator|=
literal|8
expr_stmt|;
name|frequency
operator|=
name|cf1
operator|-
literal|70
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"DFS chan_width %d not supported"
argument_list|,
name|chan_width
argument_list|)
expr_stmt|;
break|break;
block|}
name|ieee80211_freq_to_chan
argument_list|(
name|frequency
argument_list|,
operator|&
name|radar_chan
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_chans
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
operator|&
name|mode
operator|->
name|channels
index|[
name|start_chan_idx
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_RADAR
operator|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|radar_n_chans
condition|;
name|j
operator|++
control|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"checking our: %d, radar: %d"
argument_list|,
name|chan
operator|->
name|chan
argument_list|,
name|radar_chan
operator|+
name|j
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|chan
operator|==
name|radar_chan
operator|+
name|j
operator|*
literal|4
condition|)
name|res
operator|++
expr_stmt|;
block|}
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"overlapped: %d"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|dfs_get_cac_time
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|start_chan_idx
parameter_list|,
name|int
name|n_chans
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|channel
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|cac_time_ms
init|=
literal|0
decl_stmt|;
name|mode
operator|=
name|iface
operator|->
name|current_mode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_chans
condition|;
name|i
operator|++
control|)
block|{
name|channel
operator|=
operator|&
name|mode
operator|->
name|channels
index|[
name|start_chan_idx
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|channel
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_RADAR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|channel
operator|->
name|dfs_cac_ms
operator|>
name|cac_time_ms
condition|)
name|cac_time_ms
operator|=
name|channel
operator|->
name|dfs_cac_ms
expr_stmt|;
block|}
return|return
name|cac_time_ms
return|;
block|}
end_function

begin_comment
comment|/*  * Main DFS handler  * 1 - continue channel/ap setup  * 0 - channel/ap setup will be continued after CAC  * -1 - hit critical error  */
end_comment

begin_function
name|int
name|hostapd_handle_dfs
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|channel
decl_stmt|;
name|int
name|res
decl_stmt|,
name|n_chans
decl_stmt|,
name|n_chans1
decl_stmt|,
name|start_chan_idx
decl_stmt|,
name|start_chan_idx1
decl_stmt|;
name|int
name|skip_radar
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|iface
operator|->
name|current_mode
condition|)
block|{
comment|/* 		 * This can happen with drivers that do not provide mode 		 * information and as such, cannot really use hostapd for DFS. 		 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS: No current_mode information - assume no need to perform DFS operations by hostapd"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|iface
operator|->
name|cac_started
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Get start (first) channel for current configuration */
name|start_chan_idx
operator|=
name|dfs_get_start_chan_idx
argument_list|(
name|iface
argument_list|,
operator|&
name|start_chan_idx1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_chan_idx
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Get number of used channels, depend on width */
name|n_chans
operator|=
name|dfs_get_used_n_chans
argument_list|(
name|iface
argument_list|,
operator|&
name|n_chans1
argument_list|)
expr_stmt|;
comment|/* Setup CAC time */
name|iface
operator|->
name|dfs_cac_ms
operator|=
name|dfs_get_cac_time
argument_list|(
name|iface
argument_list|,
name|start_chan_idx
argument_list|,
name|n_chans
argument_list|)
expr_stmt|;
comment|/* Check if any of configured channels require DFS */
name|res
operator|=
name|dfs_check_chans_radar
argument_list|(
name|iface
argument_list|,
name|start_chan_idx
argument_list|,
name|n_chans
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS %d channels required radar detection"
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
literal|1
return|;
comment|/* Check if all channels are DFS available */
name|res
operator|=
name|dfs_check_chans_available
argument_list|(
name|iface
argument_list|,
name|start_chan_idx
argument_list|,
name|n_chans
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS all channels available, (SKIP CAC): %s"
argument_list|,
name|res
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
literal|1
return|;
comment|/* Check if any of configured channels is unavailable */
name|res
operator|=
name|dfs_check_chans_unavailable
argument_list|(
name|iface
argument_list|,
name|start_chan_idx
argument_list|,
name|n_chans
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS %d chans unavailable - choose other channel: %s"
argument_list|,
name|res
argument_list|,
name|res
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|int
name|sec
init|=
literal|0
decl_stmt|;
name|u8
name|cf1
init|=
literal|0
decl_stmt|,
name|cf2
init|=
literal|0
decl_stmt|;
name|channel
operator|=
name|dfs_get_valid_channel
argument_list|(
name|iface
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|cf1
argument_list|,
operator|&
name|cf2
argument_list|,
name|skip_radar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"could not get valid channel"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|iface
operator|->
name|freq
operator|=
name|channel
operator|->
name|freq
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|channel
operator|=
name|channel
operator|->
name|chan
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
operator|=
name|sec
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg0_idx
operator|=
name|cf1
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg1_idx
operator|=
name|cf2
expr_stmt|;
block|}
block|}
do|while
condition|(
name|res
condition|)
do|;
comment|/* Finally start CAC */
name|hostapd_set_state
argument_list|(
name|iface
argument_list|,
name|HAPD_IFACE_DFS
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS start CAC on %d MHz"
argument_list|,
name|iface
operator|->
name|freq
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|DFS_EVENT_CAC_START
literal|"freq=%d chan=%d sec_chan=%d, width=%d, seg0=%d, seg1=%d, cac_time=%ds"
argument_list|,
name|iface
operator|->
name|freq
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|channel
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|vht_oper_chwidth
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg0_idx
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg1_idx
argument_list|,
name|iface
operator|->
name|dfs_cac_ms
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|res
operator|=
name|hostapd_start_dfs_cac
argument_list|(
name|iface
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|hw_mode
argument_list|,
name|iface
operator|->
name|freq
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|channel
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|ieee80211n
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|ieee80211ac
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|vht_oper_chwidth
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg0_idx
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg1_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"DFS start_dfs_cac() failed, %d"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|hostapd_dfs_complete_cac
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|success
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|ht_enabled
parameter_list|,
name|int
name|chan_offset
parameter_list|,
name|int
name|chan_width
parameter_list|,
name|int
name|cf1
parameter_list|,
name|int
name|cf2
parameter_list|)
block|{
name|wpa_msg
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|DFS_EVENT_CAC_COMPLETED
literal|"success=%d freq=%d ht_enabled=%d chan_offset=%d chan_width=%d cf1=%d cf2=%d"
argument_list|,
name|success
argument_list|,
name|freq
argument_list|,
name|ht_enabled
argument_list|,
name|chan_offset
argument_list|,
name|chan_width
argument_list|,
name|cf1
argument_list|,
name|cf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
comment|/* Complete iface/ap configuration */
if|if
condition|(
name|iface
operator|->
name|drv_flags
operator|&
name|WPA_DRIVER_FLAGS_DFS_OFFLOAD
condition|)
block|{
comment|/* Complete AP configuration for the first bring up. */
if|if
condition|(
name|iface
operator|->
name|state
operator|!=
name|HAPD_IFACE_ENABLED
condition|)
name|hostapd_setup_interface_complete
argument_list|(
name|iface
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|iface
operator|->
name|cac_started
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|set_dfs_state
argument_list|(
name|iface
argument_list|,
name|freq
argument_list|,
name|ht_enabled
argument_list|,
name|chan_offset
argument_list|,
name|chan_width
argument_list|,
name|cf1
argument_list|,
name|cf2
argument_list|,
name|HOSTAPD_CHAN_DFS_AVAILABLE
argument_list|)
expr_stmt|;
name|iface
operator|->
name|cac_started
operator|=
literal|0
expr_stmt|;
name|hostapd_setup_interface_complete
argument_list|(
name|iface
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hostapd_dfs_start_channel_switch_cac
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|channel
decl_stmt|;
name|int
name|secondary_channel
decl_stmt|;
name|u8
name|vht_oper_centr_freq_seg0_idx
init|=
literal|0
decl_stmt|;
name|u8
name|vht_oper_centr_freq_seg1_idx
init|=
literal|0
decl_stmt|;
name|int
name|skip_radar
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|1
decl_stmt|;
comment|/* Radar detected during active CAC */
name|iface
operator|->
name|cac_started
operator|=
literal|0
expr_stmt|;
name|channel
operator|=
name|dfs_get_valid_channel
argument_list|(
name|iface
argument_list|,
operator|&
name|secondary_channel
argument_list|,
operator|&
name|vht_oper_centr_freq_seg0_idx
argument_list|,
operator|&
name|vht_oper_centr_freq_seg1_idx
argument_list|,
name|skip_radar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"No valid channel available"
argument_list|)
expr_stmt|;
name|hostapd_setup_interface_complete
argument_list|(
name|iface
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS will switch to a new channel %d"
argument_list|,
name|channel
operator|->
name|chan
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|DFS_EVENT_NEW_CHANNEL
literal|"freq=%d chan=%d sec_chan=%d"
argument_list|,
name|channel
operator|->
name|freq
argument_list|,
name|channel
operator|->
name|chan
argument_list|,
name|secondary_channel
argument_list|)
expr_stmt|;
name|iface
operator|->
name|freq
operator|=
name|channel
operator|->
name|freq
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|channel
operator|=
name|channel
operator|->
name|chan
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
operator|=
name|secondary_channel
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg0_idx
operator|=
name|vht_oper_centr_freq_seg0_idx
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg1_idx
operator|=
name|vht_oper_centr_freq_seg1_idx
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|hostapd_setup_interface_complete
argument_list|(
name|iface
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hostapd_csa_in_progress
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iface
operator|->
name|num_bss
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|iface
operator|->
name|bss
index|[
name|i
index|]
operator|->
name|csa_in_progress
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hostapd_dfs_start_channel_switch
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|channel
decl_stmt|;
name|int
name|secondary_channel
decl_stmt|;
name|u8
name|vht_oper_centr_freq_seg0_idx
decl_stmt|;
name|u8
name|vht_oper_centr_freq_seg1_idx
decl_stmt|;
name|int
name|skip_radar
init|=
literal|1
decl_stmt|;
name|struct
name|csa_settings
name|csa_settings
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|1
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"%s called (CAC active: %s, CSA active: %s)"
argument_list|,
name|__func__
argument_list|,
name|iface
operator|->
name|cac_started
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|hostapd_csa_in_progress
argument_list|(
name|iface
argument_list|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
comment|/* Check if CSA in progress */
if|if
condition|(
name|hostapd_csa_in_progress
argument_list|(
name|iface
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check if active CAC */
if|if
condition|(
name|iface
operator|->
name|cac_started
condition|)
return|return
name|hostapd_dfs_start_channel_switch_cac
argument_list|(
name|iface
argument_list|)
return|;
comment|/* Perform channel switch/CSA */
name|channel
operator|=
name|dfs_get_valid_channel
argument_list|(
name|iface
argument_list|,
operator|&
name|secondary_channel
argument_list|,
operator|&
name|vht_oper_centr_freq_seg0_idx
argument_list|,
operator|&
name|vht_oper_centr_freq_seg1_idx
argument_list|,
name|skip_radar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
block|{
comment|/* 		 * If there is no channel to switch immediately to, check if 		 * there is another channel where we can switch even if it 		 * requires to perform a CAC first. 		 */
name|skip_radar
operator|=
literal|0
expr_stmt|;
name|channel
operator|=
name|dfs_get_valid_channel
argument_list|(
name|iface
argument_list|,
operator|&
name|secondary_channel
argument_list|,
operator|&
name|vht_oper_centr_freq_seg0_idx
argument_list|,
operator|&
name|vht_oper_centr_freq_seg1_idx
argument_list|,
name|skip_radar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
block|{
comment|/* FIXME: Wait for channel(s) to become available */
name|hostapd_disable_iface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|iface
operator|->
name|freq
operator|=
name|channel
operator|->
name|freq
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|channel
operator|=
name|channel
operator|->
name|chan
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
operator|=
name|secondary_channel
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg0_idx
operator|=
name|vht_oper_centr_freq_seg0_idx
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg1_idx
operator|=
name|vht_oper_centr_freq_seg1_idx
expr_stmt|;
name|hostapd_disable_iface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|hostapd_enable_iface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS will switch to a new channel %d"
argument_list|,
name|channel
operator|->
name|chan
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|DFS_EVENT_NEW_CHANNEL
literal|"freq=%d chan=%d sec_chan=%d"
argument_list|,
name|channel
operator|->
name|freq
argument_list|,
name|channel
operator|->
name|chan
argument_list|,
name|secondary_channel
argument_list|)
expr_stmt|;
comment|/* Setup CSA request */
name|os_memset
argument_list|(
operator|&
name|csa_settings
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|csa_settings
argument_list|)
argument_list|)
expr_stmt|;
name|csa_settings
operator|.
name|cs_count
operator|=
literal|5
expr_stmt|;
name|csa_settings
operator|.
name|block_tx
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|hostapd_set_freq_params
argument_list|(
operator|&
name|csa_settings
operator|.
name|freq_params
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|hw_mode
argument_list|,
name|channel
operator|->
name|freq
argument_list|,
name|channel
operator|->
name|chan
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|ieee80211n
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|ieee80211ac
argument_list|,
name|secondary_channel
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|vht_oper_chwidth
argument_list|,
name|vht_oper_centr_freq_seg0_idx
argument_list|,
name|vht_oper_centr_freq_seg1_idx
argument_list|,
name|iface
operator|->
name|current_mode
operator|->
name|vht_capab
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"DFS failed to calculate CSA freq params"
argument_list|)
expr_stmt|;
name|hostapd_disable_iface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iface
operator|->
name|num_bss
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|hostapd_switch_channel
argument_list|(
name|iface
operator|->
name|bss
index|[
name|i
index|]
argument_list|,
operator|&
name|csa_settings
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"DFS failed to schedule CSA (%d) - trying fallback"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|iface
operator|->
name|freq
operator|=
name|channel
operator|->
name|freq
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|channel
operator|=
name|channel
operator|->
name|chan
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
operator|=
name|secondary_channel
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg0_idx
operator|=
name|vht_oper_centr_freq_seg0_idx
expr_stmt|;
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg1_idx
operator|=
name|vht_oper_centr_freq_seg1_idx
expr_stmt|;
name|hostapd_disable_iface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|hostapd_enable_iface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Channel configuration will be updated once CSA completes and 	 * ch_switch_notify event is received */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"DFS waiting channel switch event"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|hostapd_dfs_radar_detected
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|ht_enabled
parameter_list|,
name|int
name|chan_offset
parameter_list|,
name|int
name|chan_width
parameter_list|,
name|int
name|cf1
parameter_list|,
name|int
name|cf2
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|wpa_msg
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|DFS_EVENT_RADAR_DETECTED
literal|"freq=%d ht_enabled=%d chan_offset=%d chan_width=%d cf1=%d cf2=%d"
argument_list|,
name|freq
argument_list|,
name|ht_enabled
argument_list|,
name|chan_offset
argument_list|,
name|chan_width
argument_list|,
name|cf1
argument_list|,
name|cf2
argument_list|)
expr_stmt|;
comment|/* Proceed only if DFS is not offloaded to the driver */
if|if
condition|(
name|iface
operator|->
name|drv_flags
operator|&
name|WPA_DRIVER_FLAGS_DFS_OFFLOAD
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|iface
operator|->
name|conf
operator|->
name|ieee80211h
condition|)
return|return
literal|0
return|;
comment|/* mark radar frequency as invalid */
name|set_dfs_state
argument_list|(
name|iface
argument_list|,
name|freq
argument_list|,
name|ht_enabled
argument_list|,
name|chan_offset
argument_list|,
name|chan_width
argument_list|,
name|cf1
argument_list|,
name|cf2
argument_list|,
name|HOSTAPD_CHAN_DFS_UNAVAILABLE
argument_list|)
expr_stmt|;
comment|/* Skip if reported radar event not overlapped our channels */
name|res
operator|=
name|dfs_are_channels_overlapped
argument_list|(
name|iface
argument_list|,
name|freq
argument_list|,
name|chan_width
argument_list|,
name|cf1
argument_list|,
name|cf2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
literal|0
return|;
comment|/* radar detected while operating, switch the channel. */
name|res
operator|=
name|hostapd_dfs_start_channel_switch
argument_list|(
name|iface
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|hostapd_dfs_nop_finished
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|ht_enabled
parameter_list|,
name|int
name|chan_offset
parameter_list|,
name|int
name|chan_width
parameter_list|,
name|int
name|cf1
parameter_list|,
name|int
name|cf2
parameter_list|)
block|{
name|wpa_msg
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|DFS_EVENT_NOP_FINISHED
literal|"freq=%d ht_enabled=%d chan_offset=%d chan_width=%d cf1=%d cf2=%d"
argument_list|,
name|freq
argument_list|,
name|ht_enabled
argument_list|,
name|chan_offset
argument_list|,
name|chan_width
argument_list|,
name|cf1
argument_list|,
name|cf2
argument_list|)
expr_stmt|;
comment|/* Proceed only if DFS is not offloaded to the driver */
if|if
condition|(
name|iface
operator|->
name|drv_flags
operator|&
name|WPA_DRIVER_FLAGS_DFS_OFFLOAD
condition|)
return|return
literal|0
return|;
comment|/* TODO add correct implementation here */
name|set_dfs_state
argument_list|(
name|iface
argument_list|,
name|freq
argument_list|,
name|ht_enabled
argument_list|,
name|chan_offset
argument_list|,
name|chan_width
argument_list|,
name|cf1
argument_list|,
name|cf2
argument_list|,
name|HOSTAPD_CHAN_DFS_USABLE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|hostapd_is_dfs_required
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|int
name|n_chans
decl_stmt|,
name|n_chans1
decl_stmt|,
name|start_chan_idx
decl_stmt|,
name|start_chan_idx1
decl_stmt|,
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|iface
operator|->
name|conf
operator|->
name|ieee80211h
operator|||
operator|!
name|iface
operator|->
name|current_mode
operator|||
name|iface
operator|->
name|current_mode
operator|->
name|mode
operator|!=
name|HOSTAPD_MODE_IEEE80211A
condition|)
return|return
literal|0
return|;
comment|/* Get start (first) channel for current configuration */
name|start_chan_idx
operator|=
name|dfs_get_start_chan_idx
argument_list|(
name|iface
argument_list|,
operator|&
name|start_chan_idx1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_chan_idx
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Get number of used channels, depend on width */
name|n_chans
operator|=
name|dfs_get_used_n_chans
argument_list|(
name|iface
argument_list|,
operator|&
name|n_chans1
argument_list|)
expr_stmt|;
comment|/* Check if any of configured channels require DFS */
name|res
operator|=
name|dfs_check_chans_radar
argument_list|(
name|iface
argument_list|,
name|start_chan_idx
argument_list|,
name|n_chans
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
if|if
condition|(
name|start_chan_idx1
operator|>=
literal|0
operator|&&
name|n_chans1
operator|>
literal|0
condition|)
name|res
operator|=
name|dfs_check_chans_radar
argument_list|(
name|iface
argument_list|,
name|start_chan_idx1
argument_list|,
name|n_chans1
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|hostapd_dfs_start_cac
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|ht_enabled
parameter_list|,
name|int
name|chan_offset
parameter_list|,
name|int
name|chan_width
parameter_list|,
name|int
name|cf1
parameter_list|,
name|int
name|cf2
parameter_list|)
block|{
name|wpa_msg
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|DFS_EVENT_CAC_START
literal|"freq=%d chan=%d chan_offset=%d width=%d seg0=%d "
literal|"seg1=%d cac_time=%ds"
argument_list|,
name|freq
argument_list|,
operator|(
name|freq
operator|-
literal|5000
operator|)
operator|/
literal|5
argument_list|,
name|chan_offset
argument_list|,
name|chan_width
argument_list|,
name|cf1
argument_list|,
name|cf2
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|iface
operator|->
name|cac_started
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Main DFS handler for offloaded case.  * 2 - continue channel/AP setup for non-DFS channel  * 1 - continue channel/AP setup for DFS channel  * 0 - channel/AP setup will be continued after CAC  * -1 - hit critical error  */
end_comment

begin_function
name|int
name|hostapd_handle_dfs_offload
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"%s: iface->cac_started: %d"
argument_list|,
name|__func__
argument_list|,
name|iface
operator|->
name|cac_started
argument_list|)
expr_stmt|;
comment|/* 	 * If DFS has already been started, then we are being called from a 	 * callback to continue AP/channel setup. Reset the CAC start flag and 	 * return. 	 */
if|if
condition|(
name|iface
operator|->
name|cac_started
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"%s: iface->cac_started: %d"
argument_list|,
name|__func__
argument_list|,
name|iface
operator|->
name|cac_started
argument_list|)
expr_stmt|;
name|iface
operator|->
name|cac_started
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ieee80211_is_dfs
argument_list|(
name|iface
operator|->
name|freq
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"%s: freq %d MHz requires DFS"
argument_list|,
name|__func__
argument_list|,
name|iface
operator|->
name|freq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"%s: freq %d MHz does not require DFS. Continue channel/AP setup"
argument_list|,
name|__func__
argument_list|,
name|iface
operator|->
name|freq
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

end_unit

