begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * hostapd / IEEE 802.11ac VHT  * Copyright (c) 2002-2009, Jouni Malinen<j@w1.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of BSD license  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|"utils/includes.h"
end_include

begin_include
include|#
directive|include
file|"utils/common.h"
end_include

begin_include
include|#
directive|include
file|"common/ieee802_11_defs.h"
end_include

begin_include
include|#
directive|include
file|"hostapd.h"
end_include

begin_include
include|#
directive|include
file|"ap_config.h"
end_include

begin_include
include|#
directive|include
file|"sta_info.h"
end_include

begin_include
include|#
directive|include
file|"beacon.h"
end_include

begin_include
include|#
directive|include
file|"ieee802_11.h"
end_include

begin_function
name|u8
modifier|*
name|hostapd_eid_vht_capabilities
parameter_list|(
name|struct
name|hostapd_data
modifier|*
name|hapd
parameter_list|,
name|u8
modifier|*
name|eid
parameter_list|)
block|{
name|struct
name|ieee80211_vht_capabilities
modifier|*
name|cap
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
init|=
name|hapd
operator|->
name|iface
operator|->
name|current_mode
decl_stmt|;
name|u8
modifier|*
name|pos
init|=
name|eid
decl_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
return|return
name|eid
return|;
if|if
condition|(
name|mode
operator|->
name|mode
operator|==
name|HOSTAPD_MODE_IEEE80211G
operator|&&
name|hapd
operator|->
name|conf
operator|->
name|vendor_vht
operator|&&
name|mode
operator|->
name|vht_capab
operator|==
literal|0
operator|&&
name|hapd
operator|->
name|iface
operator|->
name|hw_features
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hapd
operator|->
name|iface
operator|->
name|num_hw_features
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hapd
operator|->
name|iface
operator|->
name|hw_features
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|HOSTAPD_MODE_IEEE80211A
condition|)
block|{
name|mode
operator|=
operator|&
name|hapd
operator|->
name|iface
operator|->
name|hw_features
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|pos
operator|++
operator|=
name|WLAN_EID_VHT_CAP
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
expr_stmt|;
name|cap
operator|=
operator|(
expr|struct
name|ieee80211_vht_capabilities
operator|*
operator|)
name|pos
expr_stmt|;
name|os_memset
argument_list|(
name|cap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
argument_list|)
expr_stmt|;
name|cap
operator|->
name|vht_capabilities_info
operator|=
name|host_to_le32
argument_list|(
name|hapd
operator|->
name|iface
operator|->
name|conf
operator|->
name|vht_capab
argument_list|)
expr_stmt|;
comment|/* Supported MCS set comes from hw */
name|os_memcpy
argument_list|(
operator|&
name|cap
operator|->
name|vht_supported_mcs_set
argument_list|,
name|mode
operator|->
name|vht_mcs_set
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|pos
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_function
name|u8
modifier|*
name|hostapd_eid_vht_operation
parameter_list|(
name|struct
name|hostapd_data
modifier|*
name|hapd
parameter_list|,
name|u8
modifier|*
name|eid
parameter_list|)
block|{
name|struct
name|ieee80211_vht_operation
modifier|*
name|oper
decl_stmt|;
name|u8
modifier|*
name|pos
init|=
name|eid
decl_stmt|;
operator|*
name|pos
operator|++
operator|=
name|WLAN_EID_VHT_OPERATION
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|oper
argument_list|)
expr_stmt|;
name|oper
operator|=
operator|(
expr|struct
name|ieee80211_vht_operation
operator|*
operator|)
name|pos
expr_stmt|;
name|os_memset
argument_list|(
name|oper
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|oper
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * center freq = 5 GHz + (5 * index) 	 * So index 42 gives center freq 5.210 GHz 	 * which is channel 42 in 5G band 	 */
name|oper
operator|->
name|vht_op_info_chan_center_freq_seg0_idx
operator|=
name|hapd
operator|->
name|iconf
operator|->
name|vht_oper_centr_freq_seg0_idx
expr_stmt|;
name|oper
operator|->
name|vht_op_info_chan_center_freq_seg1_idx
operator|=
name|hapd
operator|->
name|iconf
operator|->
name|vht_oper_centr_freq_seg1_idx
expr_stmt|;
name|oper
operator|->
name|vht_op_info_chwidth
operator|=
name|hapd
operator|->
name|iconf
operator|->
name|vht_oper_chwidth
expr_stmt|;
comment|/* VHT Basic MCS set comes from hw */
comment|/* Hard code 1 stream, MCS0-7 is a min Basic VHT MCS rates */
name|oper
operator|->
name|vht_basic_mcs_set
operator|=
name|host_to_le16
argument_list|(
literal|0xfffc
argument_list|)
expr_stmt|;
name|pos
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|oper
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_valid_vht_mcs
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
specifier|const
name|u8
modifier|*
name|sta_vht_capab
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_vht_capabilities
modifier|*
name|vht_cap
decl_stmt|;
name|struct
name|ieee80211_vht_capabilities
name|ap_vht_cap
decl_stmt|;
name|u16
name|sta_rx_mcs_set
decl_stmt|,
name|ap_tx_mcs_set
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
return|return
literal|1
return|;
comment|/* 	 * Disable VHT caps for STAs for which there is not even a single 	 * allowed MCS in any supported number of streams, i.e., STA is 	 * advertising 3 (not supported) as VHT MCS rates for all supported 	 * stream cases. 	 */
name|os_memcpy
argument_list|(
operator|&
name|ap_vht_cap
operator|.
name|vht_supported_mcs_set
argument_list|,
name|mode
operator|->
name|vht_mcs_set
argument_list|,
sizeof|sizeof
argument_list|(
name|ap_vht_cap
operator|.
name|vht_supported_mcs_set
argument_list|)
argument_list|)
expr_stmt|;
name|vht_cap
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_vht_capabilities
operator|*
operator|)
name|sta_vht_capab
expr_stmt|;
comment|/* AP Tx MCS map vs. STA Rx MCS map */
name|sta_rx_mcs_set
operator|=
name|le_to_host16
argument_list|(
name|vht_cap
operator|->
name|vht_supported_mcs_set
operator|.
name|rx_map
argument_list|)
expr_stmt|;
name|ap_tx_mcs_set
operator|=
name|le_to_host16
argument_list|(
name|ap_vht_cap
operator|.
name|vht_supported_mcs_set
operator|.
name|tx_map
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VHT_RX_NSS_MAX_STREAMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ap_tx_mcs_set
operator|&
operator|(
literal|0x3
operator|<<
operator|(
name|i
operator|*
literal|2
operator|)
operator|)
operator|)
operator|==
literal|3
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sta_rx_mcs_set
operator|&
operator|(
literal|0x3
operator|<<
operator|(
name|i
operator|*
literal|2
operator|)
operator|)
operator|)
operator|==
literal|3
condition|)
continue|continue;
return|return
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"No matching VHT MCS found between AP TX and STA RX"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|u16
name|copy_sta_vht_capab
parameter_list|(
name|struct
name|hostapd_data
modifier|*
name|hapd
parameter_list|,
name|struct
name|sta_info
modifier|*
name|sta
parameter_list|,
specifier|const
name|u8
modifier|*
name|vht_capab
parameter_list|,
name|size_t
name|vht_capab_len
parameter_list|)
block|{
comment|/* Disable VHT caps for STAs associated to no-VHT BSSes. */
if|if
condition|(
operator|!
name|vht_capab
operator|||
name|vht_capab_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_capabilities
argument_list|)
operator|||
name|hapd
operator|->
name|conf
operator|->
name|disable_11ac
operator|||
operator|!
name|check_valid_vht_mcs
argument_list|(
name|hapd
operator|->
name|iface
operator|->
name|current_mode
argument_list|,
name|vht_capab
argument_list|)
condition|)
block|{
name|sta
operator|->
name|flags
operator|&=
operator|~
name|WLAN_STA_VHT
expr_stmt|;
name|os_free
argument_list|(
name|sta
operator|->
name|vht_capabilities
argument_list|)
expr_stmt|;
name|sta
operator|->
name|vht_capabilities
operator|=
name|NULL
expr_stmt|;
return|return
name|WLAN_STATUS_SUCCESS
return|;
block|}
if|if
condition|(
name|sta
operator|->
name|vht_capabilities
operator|==
name|NULL
condition|)
block|{
name|sta
operator|->
name|vht_capabilities
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_capabilities
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sta
operator|->
name|vht_capabilities
operator|==
name|NULL
condition|)
return|return
name|WLAN_STATUS_UNSPECIFIED_FAILURE
return|;
block|}
name|sta
operator|->
name|flags
operator||=
name|WLAN_STA_VHT
expr_stmt|;
name|os_memcpy
argument_list|(
name|sta
operator|->
name|vht_capabilities
argument_list|,
name|vht_capab
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_capabilities
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|WLAN_STATUS_SUCCESS
return|;
block|}
end_function

begin_function
name|u16
name|copy_sta_vendor_vht
parameter_list|(
name|struct
name|hostapd_data
modifier|*
name|hapd
parameter_list|,
name|struct
name|sta_info
modifier|*
name|sta
parameter_list|,
specifier|const
name|u8
modifier|*
name|ie
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|u8
modifier|*
name|vht_capab
decl_stmt|;
name|unsigned
name|int
name|vht_capab_len
decl_stmt|;
if|if
condition|(
operator|!
name|ie
operator|||
name|len
operator|<
literal|5
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_capabilities
argument_list|)
operator|||
name|hapd
operator|->
name|conf
operator|->
name|disable_11ac
condition|)
goto|goto
name|no_capab
goto|;
comment|/* The VHT Capabilities element embedded in vendor VHT */
name|vht_capab
operator|=
name|ie
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|vht_capab
index|[
literal|0
index|]
operator|!=
name|WLAN_EID_VHT_CAP
condition|)
goto|goto
name|no_capab
goto|;
name|vht_capab_len
operator|=
name|vht_capab
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|vht_capab_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_capabilities
argument_list|)
operator|||
operator|(
name|int
operator|)
name|vht_capab_len
operator|>
name|ie
operator|+
name|len
operator|-
name|vht_capab
operator|-
literal|2
condition|)
goto|goto
name|no_capab
goto|;
name|vht_capab
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|sta
operator|->
name|vht_capabilities
operator|==
name|NULL
condition|)
block|{
name|sta
operator|->
name|vht_capabilities
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_capabilities
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sta
operator|->
name|vht_capabilities
operator|==
name|NULL
condition|)
return|return
name|WLAN_STATUS_UNSPECIFIED_FAILURE
return|;
block|}
name|sta
operator|->
name|flags
operator||=
name|WLAN_STA_VHT
operator||
name|WLAN_STA_VENDOR_VHT
expr_stmt|;
name|os_memcpy
argument_list|(
name|sta
operator|->
name|vht_capabilities
argument_list|,
name|vht_capab
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_capabilities
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|WLAN_STATUS_SUCCESS
return|;
name|no_capab
label|:
name|sta
operator|->
name|flags
operator|&=
operator|~
name|WLAN_STA_VENDOR_VHT
expr_stmt|;
return|return
name|WLAN_STATUS_SUCCESS
return|;
block|}
end_function

begin_function
name|u8
modifier|*
name|hostapd_eid_vendor_vht
parameter_list|(
name|struct
name|hostapd_data
modifier|*
name|hapd
parameter_list|,
name|u8
modifier|*
name|eid
parameter_list|)
block|{
name|u8
modifier|*
name|pos
init|=
name|eid
decl_stmt|;
if|if
condition|(
operator|!
name|hapd
operator|->
name|iface
operator|->
name|current_mode
condition|)
return|return
name|eid
return|;
operator|*
name|pos
operator|++
operator|=
name|WLAN_EID_VENDOR_SPECIFIC
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
operator|(
literal|5
operator|+
comment|/* The Vendor OUI, type and subtype */
literal|2
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_capabilities
argument_list|)
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_operation
argument_list|)
operator|)
expr_stmt|;
name|WPA_PUT_BE32
argument_list|(
name|pos
argument_list|,
operator|(
name|OUI_BROADCOM
operator|<<
literal|8
operator|)
operator||
name|VENDOR_VHT_TYPE
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|VENDOR_VHT_SUBTYPE
expr_stmt|;
name|pos
operator|=
name|hostapd_eid_vht_capabilities
argument_list|(
name|hapd
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|=
name|hostapd_eid_vht_operation
argument_list|(
name|hapd
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_function
name|u16
name|set_sta_vht_opmode
parameter_list|(
name|struct
name|hostapd_data
modifier|*
name|hapd
parameter_list|,
name|struct
name|sta_info
modifier|*
name|sta
parameter_list|,
specifier|const
name|u8
modifier|*
name|vht_oper_notif
parameter_list|)
block|{
if|if
condition|(
operator|!
name|vht_oper_notif
condition|)
block|{
name|sta
operator|->
name|flags
operator|&=
operator|~
name|WLAN_STA_VHT_OPMODE_ENABLED
expr_stmt|;
return|return
name|WLAN_STATUS_SUCCESS
return|;
block|}
name|sta
operator|->
name|flags
operator||=
name|WLAN_STA_VHT_OPMODE_ENABLED
expr_stmt|;
name|sta
operator|->
name|vht_opmode
operator|=
operator|*
name|vht_oper_notif
expr_stmt|;
return|return
name|WLAN_STATUS_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|hostapd_get_vht_capab
parameter_list|(
name|struct
name|hostapd_data
modifier|*
name|hapd
parameter_list|,
name|struct
name|ieee80211_vht_capabilities
modifier|*
name|vht_cap
parameter_list|,
name|struct
name|ieee80211_vht_capabilities
modifier|*
name|neg_vht_cap
parameter_list|)
block|{
name|u32
name|cap
decl_stmt|,
name|own_cap
decl_stmt|,
name|sym_caps
decl_stmt|;
if|if
condition|(
name|vht_cap
operator|==
name|NULL
condition|)
return|return;
name|os_memcpy
argument_list|(
name|neg_vht_cap
argument_list|,
name|vht_cap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|neg_vht_cap
argument_list|)
argument_list|)
expr_stmt|;
name|cap
operator|=
name|le_to_host32
argument_list|(
name|neg_vht_cap
operator|->
name|vht_capabilities_info
argument_list|)
expr_stmt|;
name|own_cap
operator|=
name|hapd
operator|->
name|iconf
operator|->
name|vht_capab
expr_stmt|;
comment|/* mask out symmetric VHT capabilities we don't support */
name|sym_caps
operator|=
name|VHT_CAP_SHORT_GI_80
operator||
name|VHT_CAP_SHORT_GI_160
expr_stmt|;
name|cap
operator|&=
operator|~
name|sym_caps
operator||
operator|(
name|own_cap
operator|&
name|sym_caps
operator|)
expr_stmt|;
comment|/* mask out beamformer/beamformee caps if not supported */
if|if
condition|(
operator|!
operator|(
name|own_cap
operator|&
name|VHT_CAP_SU_BEAMFORMER_CAPABLE
operator|)
condition|)
name|cap
operator|&=
operator|~
operator|(
name|VHT_CAP_SU_BEAMFORMEE_CAPABLE
operator||
name|VHT_CAP_BEAMFORMEE_STS_MAX
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|own_cap
operator|&
name|VHT_CAP_SU_BEAMFORMEE_CAPABLE
operator|)
condition|)
name|cap
operator|&=
operator|~
operator|(
name|VHT_CAP_SU_BEAMFORMER_CAPABLE
operator||
name|VHT_CAP_SOUNDING_DIMENSION_MAX
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|own_cap
operator|&
name|VHT_CAP_MU_BEAMFORMER_CAPABLE
operator|)
condition|)
name|cap
operator|&=
operator|~
name|VHT_CAP_MU_BEAMFORMEE_CAPABLE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|own_cap
operator|&
name|VHT_CAP_MU_BEAMFORMEE_CAPABLE
operator|)
condition|)
name|cap
operator|&=
operator|~
name|VHT_CAP_MU_BEAMFORMER_CAPABLE
expr_stmt|;
comment|/* mask channel widths we don't support */
switch|switch
condition|(
name|own_cap
operator|&
name|VHT_CAP_SUPP_CHAN_WIDTH_MASK
condition|)
block|{
case|case
name|VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ
case|:
break|break;
case|case
name|VHT_CAP_SUPP_CHAN_WIDTH_160MHZ
case|:
if|if
condition|(
name|cap
operator|&
name|VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ
condition|)
block|{
name|cap
operator|&=
operator|~
name|VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ
expr_stmt|;
name|cap
operator||=
name|VHT_CAP_SUPP_CHAN_WIDTH_160MHZ
expr_stmt|;
block|}
break|break;
default|default:
name|cap
operator|&=
operator|~
name|VHT_CAP_SUPP_CHAN_WIDTH_MASK
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|cap
operator|&
name|VHT_CAP_SUPP_CHAN_WIDTH_MASK
operator|)
condition|)
name|cap
operator|&=
operator|~
name|VHT_CAP_SHORT_GI_160
expr_stmt|;
comment|/* 	 * if we don't support RX STBC, mask out TX STBC in the STA's HT caps 	 * if we don't support TX STBC, mask out RX STBC in the STA's HT caps 	 */
if|if
condition|(
operator|!
operator|(
name|own_cap
operator|&
name|VHT_CAP_RXSTBC_MASK
operator|)
condition|)
name|cap
operator|&=
operator|~
name|VHT_CAP_TXSTBC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|own_cap
operator|&
name|VHT_CAP_TXSTBC
operator|)
condition|)
name|cap
operator|&=
operator|~
name|VHT_CAP_RXSTBC_MASK
expr_stmt|;
name|neg_vht_cap
operator|->
name|vht_capabilities_info
operator|=
name|host_to_le32
argument_list|(
name|cap
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

