begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ACS - Automatic Channel Selection module  * Copyright (c) 2011, Atheros Communications  * Copyright (c) 2013, Qualcomm Atheros, Inc.  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"utils/includes.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"utils/common.h"
end_include

begin_include
include|#
directive|include
file|"utils/list.h"
end_include

begin_include
include|#
directive|include
file|"common/ieee802_11_defs.h"
end_include

begin_include
include|#
directive|include
file|"common/wpa_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"drivers/driver.h"
end_include

begin_include
include|#
directive|include
file|"hostapd.h"
end_include

begin_include
include|#
directive|include
file|"ap_drv_ops.h"
end_include

begin_include
include|#
directive|include
file|"ap_config.h"
end_include

begin_include
include|#
directive|include
file|"hw_features.h"
end_include

begin_include
include|#
directive|include
file|"acs.h"
end_include

begin_comment
comment|/*  * Automatic Channel Selection  * ===========================  *  * More info at  * ------------  * http://wireless.kernel.org/en/users/Documentation/acs  *  * How to use  * ----------  * - make sure you have CONFIG_ACS=y in hostapd's .config  * - use channel=0 or channel=acs to enable ACS  *  * How does it work  * ----------------  * 1. passive scans are used to collect survey data  *    (it is assumed that scan trigger collection of survey data in driver)  * 2. interference factor is calculated for each channel  * 3. ideal channel is picked depending on channel width by using adjacent  *    channel interference factors  *  * Known limitations  * -----------------  * - Current implementation depends heavily on the amount of time willing to  *   spend gathering survey data during hostapd startup. Short traffic bursts  *   may be missed and a suboptimal channel may be picked.  * - Ideal channel may end up overlapping a channel with 40 MHz intolerant BSS  *  * Todo / Ideas  * ------------  * - implement other interference computation methods  *   - BSS/RSSI based  *   - spectral scan based  *   (should be possibly to hook this up with current ACS scans)  * - add wpa_supplicant support (for P2P)  * - collect a histogram of interference over time allowing more educated  *   guess about an ideal channel (perhaps CSA could be used to migrate AP to a  *   new "better" channel while running)  * - include neighboring BSS scan to avoid conflicts with 40 MHz intolerant BSSs  *   when choosing the ideal channel  *  * Survey interference factor implementation details  * -------------------------------------------------  * Generic interference_factor in struct hostapd_channel_data is used.  *  * The survey interference factor is defined as the ratio of the  * observed busy time over the time we spent on the channel,  * this value is then amplified by the observed noise floor on  * the channel in comparison to the lowest noise floor observed  * on the entire band.  *  * This corresponds to:  * ---  * (busy time - tx time) / (active time - tx time) * 2^(chan_nf + band_min_nf)  * ---  *  * The coefficient of 2 reflects the way power in "far-field"  * radiation decreases as the square of distance from the antenna [1].  * What this does is it decreases the observed busy time ratio if the  * noise observed was low but increases it if the noise was high,  * proportionally to the way "far field" radiation changes over  * distance.  *  * If channel busy time is not available the fallback is to use channel RX time.  *  * Since noise floor is in dBm it is necessary to convert it into Watts so that  * combined channel interference (e.g., HT40, which uses two channels) can be  * calculated easily.  * ---  * (busy time - tx time) / (active time - tx time) *  *    2^(10^(chan_nf/10) + 10^(band_min_nf/10))  * ---  *  * However to account for cases where busy/rx time is 0 (channel load is then  * 0%) channel noise floor signal power is combined into the equation so a  * channel with lower noise floor is preferred. The equation becomes:  * ---  * 10^(chan_nf/5) + (busy time - tx time) / (active time - tx time) *  *    2^(10^(chan_nf/10) + 10^(band_min_nf/10))  * ---  *  * All this "interference factor" is purely subjective and only time  * will tell how usable this is. By using the minimum noise floor we  * remove any possible issues due to card calibration. The computation  * of the interference factor then is dependent on what the card itself  * picks up as the minimum noise, not an actual real possible card  * noise value.  *  * Total interference computation details  * --------------------------------------  * The above channel interference factor is calculated with no respect to  * target operational bandwidth.  *  * To find an ideal channel the above data is combined by taking into account  * the target operational bandwidth and selected band. E.g., on 2.4 GHz channels  * overlap with 20 MHz bandwidth, but there is no overlap for 20 MHz bandwidth  * on 5 GHz.  *  * Each valid and possible channel spec (i.e., channel + width) is taken and its  * interference factor is computed by summing up interferences of each channel  * it overlaps. The one with least total interference is picked up.  *  * Note: This implies base channel interference factor must be non-negative  * allowing easy summing up.  *  * Example ACS analysis printout  * -----------------------------  *  * ACS: Trying survey-based ACS  * ACS: Survey analysis for channel 1 (2412 MHz)  * ACS:  1: min_nf=-113 interference_factor=0.0802469 nf=-113 time=162 busy=0 rx=13  * ACS:  2: min_nf=-113 interference_factor=0.0745342 nf=-113 time=161 busy=0 rx=12  * ACS:  3: min_nf=-113 interference_factor=0.0679012 nf=-113 time=162 busy=0 rx=11  * ACS:  4: min_nf=-113 interference_factor=0.0310559 nf=-113 time=161 busy=0 rx=5  * ACS:  5: min_nf=-113 interference_factor=0.0248447 nf=-113 time=161 busy=0 rx=4  * ACS:  * interference factor average: 0.0557166  * ACS: Survey analysis for channel 2 (2417 MHz)  * ACS:  1: min_nf=-113 interference_factor=0.0185185 nf=-113 time=162 busy=0 rx=3  * ACS:  2: min_nf=-113 interference_factor=0.0246914 nf=-113 time=162 busy=0 rx=4  * ACS:  3: min_nf=-113 interference_factor=0.037037 nf=-113 time=162 busy=0 rx=6  * ACS:  4: min_nf=-113 interference_factor=0.149068 nf=-113 time=161 busy=0 rx=24  * ACS:  5: min_nf=-113 interference_factor=0.0248447 nf=-113 time=161 busy=0 rx=4  * ACS:  * interference factor average: 0.050832  * ACS: Survey analysis for channel 3 (2422 MHz)  * ACS:  1: min_nf=-113 interference_factor=2.51189e-23 nf=-113 time=162 busy=0 rx=0  * ACS:  2: min_nf=-113 interference_factor=0.0185185 nf=-113 time=162 busy=0 rx=3  * ACS:  3: min_nf=-113 interference_factor=0.0186335 nf=-113 time=161 busy=0 rx=3  * ACS:  4: min_nf=-113 interference_factor=0.0186335 nf=-113 time=161 busy=0 rx=3  * ACS:  5: min_nf=-113 interference_factor=0.0186335 nf=-113 time=161 busy=0 rx=3  * ACS:  * interference factor average: 0.0148838  * ACS: Survey analysis for channel 4 (2427 MHz)  * ACS:  1: min_nf=-114 interference_factor=1.58489e-23 nf=-114 time=162 busy=0 rx=0  * ACS:  2: min_nf=-114 interference_factor=0.0555556 nf=-114 time=162 busy=0 rx=9  * ACS:  3: min_nf=-114 interference_factor=1.58489e-23 nf=-114 time=161 busy=0 rx=0  * ACS:  4: min_nf=-114 interference_factor=0.0186335 nf=-114 time=161 busy=0 rx=3  * ACS:  5: min_nf=-114 interference_factor=0.00621118 nf=-114 time=161 busy=0 rx=1  * ACS:  * interference factor average: 0.0160801  * ACS: Survey analysis for channel 5 (2432 MHz)  * ACS:  1: min_nf=-114 interference_factor=0.409938 nf=-113 time=161 busy=0 rx=66  * ACS:  2: min_nf=-114 interference_factor=0.0432099 nf=-113 time=162 busy=0 rx=7  * ACS:  3: min_nf=-114 interference_factor=0.0124224 nf=-113 time=161 busy=0 rx=2  * ACS:  4: min_nf=-114 interference_factor=0.677019 nf=-113 time=161 busy=0 rx=109  * ACS:  5: min_nf=-114 interference_factor=0.0186335 nf=-114 time=161 busy=0 rx=3  * ACS:  * interference factor average: 0.232244  * ACS: Survey analysis for channel 6 (2437 MHz)  * ACS:  1: min_nf=-113 interference_factor=0.552795 nf=-113 time=161 busy=0 rx=89  * ACS:  2: min_nf=-113 interference_factor=0.0807453 nf=-112 time=161 busy=0 rx=13  * ACS:  3: min_nf=-113 interference_factor=0.0310559 nf=-113 time=161 busy=0 rx=5  * ACS:  4: min_nf=-113 interference_factor=0.434783 nf=-112 time=161 busy=0 rx=70  * ACS:  5: min_nf=-113 interference_factor=0.0621118 nf=-113 time=161 busy=0 rx=10  * ACS:  * interference factor average: 0.232298  * ACS: Survey analysis for channel 7 (2442 MHz)  * ACS:  1: min_nf=-113 interference_factor=0.440994 nf=-112 time=161 busy=0 rx=71  * ACS:  2: min_nf=-113 interference_factor=0.385093 nf=-113 time=161 busy=0 rx=62  * ACS:  3: min_nf=-113 interference_factor=0.0372671 nf=-113 time=161 busy=0 rx=6  * ACS:  4: min_nf=-113 interference_factor=0.0372671 nf=-113 time=161 busy=0 rx=6  * ACS:  5: min_nf=-113 interference_factor=0.0745342 nf=-113 time=161 busy=0 rx=12  * ACS:  * interference factor average: 0.195031  * ACS: Survey analysis for channel 8 (2447 MHz)  * ACS:  1: min_nf=-114 interference_factor=0.0496894 nf=-112 time=161 busy=0 rx=8  * ACS:  2: min_nf=-114 interference_factor=0.0496894 nf=-114 time=161 busy=0 rx=8  * ACS:  3: min_nf=-114 interference_factor=0.0372671 nf=-113 time=161 busy=0 rx=6  * ACS:  4: min_nf=-114 interference_factor=0.12963 nf=-113 time=162 busy=0 rx=21  * ACS:  5: min_nf=-114 interference_factor=0.166667 nf=-114 time=162 busy=0 rx=27  * ACS:  * interference factor average: 0.0865885  * ACS: Survey analysis for channel 9 (2452 MHz)  * ACS:  1: min_nf=-114 interference_factor=0.0124224 nf=-114 time=161 busy=0 rx=2  * ACS:  2: min_nf=-114 interference_factor=0.0310559 nf=-114 time=161 busy=0 rx=5  * ACS:  3: min_nf=-114 interference_factor=1.58489e-23 nf=-114 time=161 busy=0 rx=0  * ACS:  4: min_nf=-114 interference_factor=0.00617284 nf=-114 time=162 busy=0 rx=1  * ACS:  5: min_nf=-114 interference_factor=1.58489e-23 nf=-114 time=162 busy=0 rx=0  * ACS:  * interference factor average: 0.00993022  * ACS: Survey analysis for channel 10 (2457 MHz)  * ACS:  1: min_nf=-114 interference_factor=0.00621118 nf=-114 time=161 busy=0 rx=1  * ACS:  2: min_nf=-114 interference_factor=0.00621118 nf=-114 time=161 busy=0 rx=1  * ACS:  3: min_nf=-114 interference_factor=0.00621118 nf=-114 time=161 busy=0 rx=1  * ACS:  4: min_nf=-114 interference_factor=0.0493827 nf=-114 time=162 busy=0 rx=8  * ACS:  5: min_nf=-114 interference_factor=1.58489e-23 nf=-114 time=162 busy=0 rx=0  * ACS:  * interference factor average: 0.0136033  * ACS: Survey analysis for channel 11 (2462 MHz)  * ACS:  1: min_nf=-114 interference_factor=1.58489e-23 nf=-114 time=161 busy=0 rx=0  * ACS:  2: min_nf=-114 interference_factor=2.51189e-23 nf=-113 time=161 busy=0 rx=0  * ACS:  3: min_nf=-114 interference_factor=2.51189e-23 nf=-113 time=161 busy=0 rx=0  * ACS:  4: min_nf=-114 interference_factor=0.0432099 nf=-114 time=162 busy=0 rx=7  * ACS:  5: min_nf=-114 interference_factor=0.0925926 nf=-114 time=162 busy=0 rx=15  * ACS:  * interference factor average: 0.0271605  * ACS: Survey analysis for channel 12 (2467 MHz)  * ACS:  1: min_nf=-114 interference_factor=0.0621118 nf=-113 time=161 busy=0 rx=10  * ACS:  2: min_nf=-114 interference_factor=0.00621118 nf=-114 time=161 busy=0 rx=1  * ACS:  3: min_nf=-114 interference_factor=2.51189e-23 nf=-113 time=162 busy=0 rx=0  * ACS:  4: min_nf=-114 interference_factor=2.51189e-23 nf=-113 time=162 busy=0 rx=0  * ACS:  5: min_nf=-114 interference_factor=0.00617284 nf=-113 time=162 busy=0 rx=1  * ACS:  * interference factor average: 0.0148992  * ACS: Survey analysis for channel 13 (2472 MHz)  * ACS:  1: min_nf=-114 interference_factor=0.0745342 nf=-114 time=161 busy=0 rx=12  * ACS:  2: min_nf=-114 interference_factor=0.0555556 nf=-114 time=162 busy=0 rx=9  * ACS:  3: min_nf=-114 interference_factor=1.58489e-23 nf=-114 time=162 busy=0 rx=0  * ACS:  4: min_nf=-114 interference_factor=1.58489e-23 nf=-114 time=162 busy=0 rx=0  * ACS:  5: min_nf=-114 interference_factor=1.58489e-23 nf=-114 time=162 busy=0 rx=0  * ACS:  * interference factor average: 0.0260179  * ACS: Survey analysis for selected bandwidth 20MHz  * ACS:  * channel 1: total interference = 0.121432  * ACS:  * channel 2: total interference = 0.137512  * ACS:  * channel 3: total interference = 0.369757  * ACS:  * channel 4: total interference = 0.546338  * ACS:  * channel 5: total interference = 0.690538  * ACS:  * channel 6: total interference = 0.762242  * ACS:  * channel 7: total interference = 0.756092  * ACS:  * channel 8: total interference = 0.537451  * ACS:  * channel 9: total interference = 0.332313  * ACS:  * channel 10: total interference = 0.152182  * ACS:  * channel 11: total interference = 0.0916111  * ACS:  * channel 12: total interference = 0.0816809  * ACS:  * channel 13: total interference = 0.0680776  * ACS: Ideal channel is 13 (2472 MHz) with total interference factor of 0.0680776  *  * [1] http://en.wikipedia.org/wiki/Near_and_far_field  */
end_comment

begin_function_decl
specifier|static
name|int
name|acs_request_scan
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|acs_survey_is_sufficient
parameter_list|(
name|struct
name|freq_survey
modifier|*
name|survey
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|acs_clean_chan_surveys
parameter_list|(
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|freq_survey
modifier|*
name|survey
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|dl_list_empty
argument_list|(
operator|&
name|chan
operator|->
name|survey_list
argument_list|)
condition|)
return|return;
name|dl_list_for_each_safe
argument_list|(
argument|survey
argument_list|,
argument|tmp
argument_list|,
argument|&chan->survey_list
argument_list|,
argument|struct freq_survey
argument_list|,
argument|list
argument_list|)
block|{
name|dl_list_del
argument_list|(
operator|&
name|survey
operator|->
name|list
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|survey
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|acs_cleanup
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|hostapd_channel_data
modifier|*
name|chan
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iface
operator|->
name|current_mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
operator|&
name|iface
operator|->
name|current_mode
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_SURVEY_LIST_INITIALIZED
condition|)
name|acs_clean_chan_surveys
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|dl_list_init
argument_list|(
operator|&
name|chan
operator|->
name|survey_list
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_SURVEY_LIST_INITIALIZED
expr_stmt|;
name|chan
operator|->
name|min_nf
operator|=
literal|0
expr_stmt|;
block|}
name|iface
operator|->
name|chans_surveyed
operator|=
literal|0
expr_stmt|;
name|iface
operator|->
name|acs_num_completed_scans
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_fail
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: Failed to start"
argument_list|)
expr_stmt|;
name|acs_cleanup
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|hostapd_disable_iface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|acs_survey_interference_factor
parameter_list|(
name|struct
name|freq_survey
modifier|*
name|survey
parameter_list|,
name|s8
name|min_nf
parameter_list|)
block|{
name|long
name|double
name|factor
decl_stmt|,
name|busy
decl_stmt|,
name|total
decl_stmt|;
if|if
condition|(
name|survey
operator|->
name|filled
operator|&
name|SURVEY_HAS_CHAN_TIME_BUSY
condition|)
name|busy
operator|=
name|survey
operator|->
name|channel_time_busy
expr_stmt|;
elseif|else
if|if
condition|(
name|survey
operator|->
name|filled
operator|&
name|SURVEY_HAS_CHAN_TIME_RX
condition|)
name|busy
operator|=
name|survey
operator|->
name|channel_time_rx
expr_stmt|;
else|else
block|{
comment|/* This shouldn't really happen as survey data is checked in 		 * acs_sanity_check() */
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: Survey data missing"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|total
operator|=
name|survey
operator|->
name|channel_time
expr_stmt|;
if|if
condition|(
name|survey
operator|->
name|filled
operator|&
name|SURVEY_HAS_CHAN_TIME_TX
condition|)
block|{
name|busy
operator|-=
name|survey
operator|->
name|channel_time_tx
expr_stmt|;
name|total
operator|-=
name|survey
operator|->
name|channel_time_tx
expr_stmt|;
block|}
comment|/* TODO: figure out the best multiplier for noise floor base */
name|factor
operator|=
name|pow
argument_list|(
literal|10
argument_list|,
name|survey
operator|->
name|nf
operator|/
literal|5.0L
argument_list|)
operator|+
operator|(
name|busy
operator|/
name|total
operator|)
operator|*
name|pow
argument_list|(
literal|2
argument_list|,
name|pow
argument_list|(
literal|10
argument_list|,
operator|(
name|long
name|double
operator|)
name|survey
operator|->
name|nf
operator|/
literal|10.0L
argument_list|)
operator|-
name|pow
argument_list|(
literal|10
argument_list|,
operator|(
name|long
name|double
operator|)
name|min_nf
operator|/
literal|10.0L
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|factor
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_survey_chan_interference_factor
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|freq_survey
modifier|*
name|survey
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|long
name|double
name|int_factor
init|=
literal|0
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dl_list_empty
argument_list|(
operator|&
name|chan
operator|->
name|survey_list
argument_list|)
condition|)
return|return;
if|if
condition|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DISABLED
condition|)
return|return;
name|chan
operator|->
name|interference_factor
operator|=
literal|0
expr_stmt|;
name|dl_list_for_each
argument_list|(
argument|survey
argument_list|,
argument|&chan->survey_list
argument_list|,
argument|struct freq_survey
argument_list|,
argument|list
argument_list|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|acs_survey_is_sufficient
argument_list|(
name|survey
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: %d: insufficient data"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|count
operator|++
expr_stmt|;
name|int_factor
operator|=
name|acs_survey_interference_factor
argument_list|(
name|survey
argument_list|,
name|iface
operator|->
name|lowest_nf
argument_list|)
expr_stmt|;
name|chan
operator|->
name|interference_factor
operator|+=
name|int_factor
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: %d: min_nf=%d interference_factor=%Lg nf=%d time=%lu busy=%lu rx=%lu"
argument_list|,
name|i
argument_list|,
name|chan
operator|->
name|min_nf
argument_list|,
name|int_factor
argument_list|,
name|survey
operator|->
name|nf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|survey
operator|->
name|channel_time
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|survey
operator|->
name|channel_time_busy
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|survey
operator|->
name|channel_time_rx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|count
condition|)
return|return;
name|chan
operator|->
name|interference_factor
operator|/=
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acs_usable_ht40_chan
parameter_list|(
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|)
block|{
specifier|const
name|int
name|allowed
index|[]
init|=
block|{
literal|36
block|,
literal|44
block|,
literal|52
block|,
literal|60
block|,
literal|100
block|,
literal|108
block|,
literal|116
block|,
literal|124
block|,
literal|132
block|,
literal|149
block|,
literal|157
block|,
literal|184
block|,
literal|192
block|}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|allowed
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|chan
operator|->
name|chan
operator|==
name|allowed
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acs_usable_vht80_chan
parameter_list|(
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|)
block|{
specifier|const
name|int
name|allowed
index|[]
init|=
block|{
literal|36
block|,
literal|52
block|,
literal|100
block|,
literal|116
block|,
literal|132
block|,
literal|149
block|}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|allowed
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|chan
operator|->
name|chan
operator|==
name|allowed
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acs_survey_is_sufficient
parameter_list|(
name|struct
name|freq_survey
modifier|*
name|survey
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|survey
operator|->
name|filled
operator|&
name|SURVEY_HAS_NF
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"ACS: Survey is missing noise floor"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|survey
operator|->
name|filled
operator|&
name|SURVEY_HAS_CHAN_TIME
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"ACS: Survey is missing channel time"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|survey
operator|->
name|filled
operator|&
name|SURVEY_HAS_CHAN_TIME_BUSY
operator|)
operator|&&
operator|!
operator|(
name|survey
operator|->
name|filled
operator|&
name|SURVEY_HAS_CHAN_TIME_RX
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"ACS: Survey is missing RX and busy time (at least one is required)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acs_survey_list_is_sufficient
parameter_list|(
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|freq_survey
modifier|*
name|survey
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|dl_list_for_each
argument_list|(
argument|survey
argument_list|,
argument|&chan->survey_list
argument_list|,
argument|struct freq_survey
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|acs_survey_is_sufficient
argument_list|(
name|survey
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* no survey list entries */
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"ACS: Channel %d has insufficient survey data"
argument_list|,
name|chan
operator|->
name|chan
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acs_surveys_are_sufficient
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|hostapd_channel_data
modifier|*
name|chan
decl_stmt|;
name|int
name|valid
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iface
operator|->
name|current_mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
operator|&
name|iface
operator|->
name|current_mode
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DISABLED
condition|)
continue|continue;
if|if
condition|(
operator|!
name|acs_survey_list_is_sufficient
argument_list|(
name|chan
argument_list|)
condition|)
continue|continue;
name|valid
operator|++
expr_stmt|;
block|}
comment|/* We need at least survey data for one channel */
return|return
operator|!
operator|!
name|valid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acs_usable_chan
parameter_list|(
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
name|dl_list_empty
argument_list|(
operator|&
name|chan
operator|->
name|survey_list
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DISABLED
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|acs_survey_list_is_sufficient
argument_list|(
name|chan
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_in_chanlist
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iface
operator|->
name|conf
operator|->
name|acs_ch_list
operator|.
name|num
condition|)
return|return
literal|1
return|;
return|return
name|freq_range_list_includes
argument_list|(
operator|&
name|iface
operator|->
name|conf
operator|->
name|acs_ch_list
argument_list|,
name|chan
operator|->
name|chan
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_survey_all_chans_intereference_factor
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|hostapd_channel_data
modifier|*
name|chan
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iface
operator|->
name|current_mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
operator|&
name|iface
operator|->
name|current_mode
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|acs_usable_chan
argument_list|(
name|chan
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_in_chanlist
argument_list|(
name|iface
argument_list|,
name|chan
argument_list|)
condition|)
continue|continue;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: Survey analysis for channel %d (%d MHz)"
argument_list|,
name|chan
operator|->
name|chan
argument_list|,
name|chan
operator|->
name|freq
argument_list|)
expr_stmt|;
name|acs_survey_chan_interference_factor
argument_list|(
name|iface
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS:  * interference factor average: %Lg"
argument_list|,
name|chan
operator|->
name|interference_factor
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|hostapd_channel_data
modifier|*
name|acs_find_chan
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iface
operator|->
name|current_mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
operator|&
name|iface
operator|->
name|current_mode
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DISABLED
condition|)
continue|continue;
if|if
condition|(
name|chan
operator|->
name|freq
operator|==
name|freq
condition|)
return|return
name|chan
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_24ghz_mode
parameter_list|(
name|enum
name|hostapd_hw_mode
name|mode
parameter_list|)
block|{
return|return
name|mode
operator|==
name|HOSTAPD_MODE_IEEE80211B
operator|||
name|mode
operator|==
name|HOSTAPD_MODE_IEEE80211G
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_common_24ghz_chan
parameter_list|(
name|int
name|chan
parameter_list|)
block|{
return|return
name|chan
operator|==
literal|1
operator|||
name|chan
operator|==
literal|6
operator|||
name|chan
operator|==
literal|11
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ACS_ADJ_WEIGHT
end_ifndef

begin_define
define|#
directive|define
name|ACS_ADJ_WEIGHT
value|0.85
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ACS_ADJ_WEIGHT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ACS_NEXT_ADJ_WEIGHT
end_ifndef

begin_define
define|#
directive|define
name|ACS_NEXT_ADJ_WEIGHT
value|0.55
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ACS_NEXT_ADJ_WEIGHT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ACS_24GHZ_PREFER_1_6_11
end_ifndef

begin_comment
comment|/*  * Select commonly used channels 1, 6, 11 by default even if a neighboring  * channel has a smaller interference factor as long as it is not better by more  * than this multiplier.  */
end_comment

begin_define
define|#
directive|define
name|ACS_24GHZ_PREFER_1_6_11
value|0.8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ACS_24GHZ_PREFER_1_6_11 */
end_comment

begin_comment
comment|/*  * At this point it's assumed chan->interface_factor has been computed.  * This function should be reusable regardless of interference computation  * option (survey, BSS, spectral, ...). chan->interference factor must be  * summable (i.e., must be always greater than zero).  */
end_comment

begin_function
specifier|static
name|struct
name|hostapd_channel_data
modifier|*
name|acs_find_ideal_chan
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|chan
decl_stmt|,
modifier|*
name|adj_chan
decl_stmt|,
modifier|*
name|ideal_chan
init|=
name|NULL
decl_stmt|,
modifier|*
name|rand_chan
init|=
name|NULL
decl_stmt|;
name|long
name|double
name|factor
decl_stmt|,
name|ideal_factor
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|n_chans
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|k
decl_stmt|;
comment|/* TODO: HT40- support */
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|ieee80211n
operator|&&
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
operator|==
operator|-
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: HT40- is not supported yet. Please try HT40+"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|ieee80211n
operator|&&
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
condition|)
name|n_chans
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|ieee80211ac
operator|&&
name|iface
operator|->
name|conf
operator|->
name|vht_oper_chwidth
operator|==
literal|1
condition|)
name|n_chans
operator|=
literal|4
expr_stmt|;
comment|/* TODO: VHT80+80, VHT160. Update acs_adjust_vht_center_freq() too. */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: Survey analysis for selected bandwidth %d MHz"
argument_list|,
name|n_chans
operator|==
literal|1
condition|?
literal|20
else|:
name|n_chans
operator|==
literal|2
condition|?
literal|40
else|:
name|n_chans
operator|==
literal|4
condition|?
literal|80
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iface
operator|->
name|current_mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|double
name|total_weight
decl_stmt|;
name|struct
name|acs_bias
modifier|*
name|bias
decl_stmt|,
name|tmp_bias
decl_stmt|;
name|chan
operator|=
operator|&
name|iface
operator|->
name|current_mode
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DISABLED
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_in_chanlist
argument_list|(
name|iface
argument_list|,
name|chan
argument_list|)
condition|)
continue|continue;
comment|/* HT40 on 5 GHz has a limited set of primary channels as per 		 * 11n Annex J */
if|if
condition|(
name|iface
operator|->
name|current_mode
operator|->
name|mode
operator|==
name|HOSTAPD_MODE_IEEE80211A
operator|&&
name|iface
operator|->
name|conf
operator|->
name|ieee80211n
operator|&&
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
operator|&&
operator|!
name|acs_usable_ht40_chan
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: Channel %d: not allowed as primary channel for HT40"
argument_list|,
name|chan
operator|->
name|chan
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|iface
operator|->
name|current_mode
operator|->
name|mode
operator|==
name|HOSTAPD_MODE_IEEE80211A
operator|&&
name|iface
operator|->
name|conf
operator|->
name|ieee80211ac
operator|&&
name|iface
operator|->
name|conf
operator|->
name|vht_oper_chwidth
operator|==
literal|1
operator|&&
operator|!
name|acs_usable_vht80_chan
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: Channel %d: not allowed as primary channel for VHT80"
argument_list|,
name|chan
operator|->
name|chan
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|factor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acs_usable_chan
argument_list|(
name|chan
argument_list|)
condition|)
name|factor
operator|=
name|chan
operator|->
name|interference_factor
expr_stmt|;
name|total_weight
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|n_chans
condition|;
name|j
operator|++
control|)
block|{
name|adj_chan
operator|=
name|acs_find_chan
argument_list|(
name|iface
argument_list|,
name|chan
operator|->
name|freq
operator|+
operator|(
name|j
operator|*
literal|20
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adj_chan
condition|)
break|break;
if|if
condition|(
name|acs_usable_chan
argument_list|(
name|adj_chan
argument_list|)
condition|)
block|{
name|factor
operator|+=
name|adj_chan
operator|->
name|interference_factor
expr_stmt|;
name|total_weight
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|!=
name|n_chans
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: Channel %d: not enough bandwidth"
argument_list|,
name|chan
operator|->
name|chan
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 2.4 GHz has overlapping 20 MHz channels. Include adjacent 		 * channel interference factor. */
if|if
condition|(
name|is_24ghz_mode
argument_list|(
name|iface
operator|->
name|current_mode
operator|->
name|mode
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_chans
condition|;
name|j
operator|++
control|)
block|{
name|adj_chan
operator|=
name|acs_find_chan
argument_list|(
name|iface
argument_list|,
name|chan
operator|->
name|freq
operator|+
operator|(
name|j
operator|*
literal|20
operator|)
operator|-
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj_chan
operator|&&
name|acs_usable_chan
argument_list|(
name|adj_chan
argument_list|)
condition|)
block|{
name|factor
operator|+=
name|ACS_ADJ_WEIGHT
operator|*
name|adj_chan
operator|->
name|interference_factor
expr_stmt|;
name|total_weight
operator|+=
name|ACS_ADJ_WEIGHT
expr_stmt|;
block|}
name|adj_chan
operator|=
name|acs_find_chan
argument_list|(
name|iface
argument_list|,
name|chan
operator|->
name|freq
operator|+
operator|(
name|j
operator|*
literal|20
operator|)
operator|-
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj_chan
operator|&&
name|acs_usable_chan
argument_list|(
name|adj_chan
argument_list|)
condition|)
block|{
name|factor
operator|+=
name|ACS_NEXT_ADJ_WEIGHT
operator|*
name|adj_chan
operator|->
name|interference_factor
expr_stmt|;
name|total_weight
operator|+=
name|ACS_NEXT_ADJ_WEIGHT
expr_stmt|;
block|}
name|adj_chan
operator|=
name|acs_find_chan
argument_list|(
name|iface
argument_list|,
name|chan
operator|->
name|freq
operator|+
operator|(
name|j
operator|*
literal|20
operator|)
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj_chan
operator|&&
name|acs_usable_chan
argument_list|(
name|adj_chan
argument_list|)
condition|)
block|{
name|factor
operator|+=
name|ACS_ADJ_WEIGHT
operator|*
name|adj_chan
operator|->
name|interference_factor
expr_stmt|;
name|total_weight
operator|+=
name|ACS_ADJ_WEIGHT
expr_stmt|;
block|}
name|adj_chan
operator|=
name|acs_find_chan
argument_list|(
name|iface
argument_list|,
name|chan
operator|->
name|freq
operator|+
operator|(
name|j
operator|*
literal|20
operator|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj_chan
operator|&&
name|acs_usable_chan
argument_list|(
name|adj_chan
argument_list|)
condition|)
block|{
name|factor
operator|+=
name|ACS_NEXT_ADJ_WEIGHT
operator|*
name|adj_chan
operator|->
name|interference_factor
expr_stmt|;
name|total_weight
operator|+=
name|ACS_NEXT_ADJ_WEIGHT
expr_stmt|;
block|}
block|}
block|}
name|factor
operator|/=
name|total_weight
expr_stmt|;
name|bias
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|acs_chan_bias
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|iface
operator|->
name|conf
operator|->
name|num_acs_chan_bias
condition|;
name|k
operator|++
control|)
block|{
name|bias
operator|=
operator|&
name|iface
operator|->
name|conf
operator|->
name|acs_chan_bias
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|bias
operator|->
name|channel
operator|==
name|chan
operator|->
name|chan
condition|)
break|break;
name|bias
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_24ghz_mode
argument_list|(
name|iface
operator|->
name|current_mode
operator|->
name|mode
argument_list|)
operator|&&
name|is_common_24ghz_chan
argument_list|(
name|chan
operator|->
name|chan
argument_list|)
condition|)
block|{
name|tmp_bias
operator|.
name|channel
operator|=
name|chan
operator|->
name|chan
expr_stmt|;
name|tmp_bias
operator|.
name|bias
operator|=
name|ACS_24GHZ_PREFER_1_6_11
expr_stmt|;
name|bias
operator|=
operator|&
name|tmp_bias
expr_stmt|;
block|}
if|if
condition|(
name|bias
condition|)
block|{
name|factor
operator|*=
name|bias
operator|->
name|bias
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS:  * channel %d: total interference = %Lg (%f bias)"
argument_list|,
name|chan
operator|->
name|chan
argument_list|,
name|factor
argument_list|,
name|bias
operator|->
name|bias
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS:  * channel %d: total interference = %Lg"
argument_list|,
name|chan
operator|->
name|chan
argument_list|,
name|factor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acs_usable_chan
argument_list|(
name|chan
argument_list|)
operator|&&
operator|(
operator|!
name|ideal_chan
operator|||
name|factor
operator|<
name|ideal_factor
operator|)
condition|)
block|{
name|ideal_factor
operator|=
name|factor
expr_stmt|;
name|ideal_chan
operator|=
name|chan
expr_stmt|;
block|}
comment|/* This channel would at least be usable */
if|if
condition|(
operator|!
name|rand_chan
condition|)
name|rand_chan
operator|=
name|chan
expr_stmt|;
block|}
if|if
condition|(
name|ideal_chan
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: Ideal channel is %d (%d MHz) with total interference factor of %Lg"
argument_list|,
name|ideal_chan
operator|->
name|chan
argument_list|,
name|ideal_chan
operator|->
name|freq
argument_list|,
name|ideal_factor
argument_list|)
expr_stmt|;
return|return
name|ideal_chan
return|;
block|}
return|return
name|rand_chan
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_adjust_vht_center_freq
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: Adjusting VHT center frequency"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iface
operator|->
name|conf
operator|->
name|vht_oper_chwidth
condition|)
block|{
case|case
name|VHT_CHANWIDTH_USE_HT
case|:
name|offset
operator|=
literal|2
operator|*
name|iface
operator|->
name|conf
operator|->
name|secondary_channel
expr_stmt|;
break|break;
case|case
name|VHT_CHANWIDTH_80MHZ
case|:
name|offset
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
comment|/* TODO: How can this be calculated? Adjust 		 * acs_find_ideal_chan() */
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"ACS: Only VHT20/40/80 is supported now"
argument_list|)
expr_stmt|;
return|return;
block|}
name|iface
operator|->
name|conf
operator|->
name|vht_oper_centr_freq_seg0_idx
operator|=
name|iface
operator|->
name|conf
operator|->
name|channel
operator|+
name|offset
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acs_study_survey_based
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: Trying survey-based ACS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iface
operator|->
name|chans_surveyed
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: Unable to collect survey data"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|acs_surveys_are_sufficient
argument_list|(
name|iface
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: Surveys have insufficient data"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|acs_survey_all_chans_intereference_factor
argument_list|(
name|iface
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acs_study_options
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|acs_study_survey_based
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* TODO: If no surveys are available/sufficient this is a good 	 * place to fallback to BSS-based ACS */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_study
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|ideal_chan
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|acs_study_options
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: All study options have failed"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ideal_chan
operator|=
name|acs_find_ideal_chan
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ideal_chan
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: Failed to compute ideal channel"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|iface
operator|->
name|conf
operator|->
name|channel
operator|=
name|ideal_chan
operator|->
name|chan
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|conf
operator|->
name|ieee80211ac
condition|)
name|acs_adjust_vht_center_freq
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|fail
label|:
comment|/* 	 * hostapd_setup_interface_complete() will return -1 on failure, 	 * 0 on success and 0 is HOSTAPD_CHAN_VALID :) 	 */
if|if
condition|(
name|hostapd_acs_completed
argument_list|(
name|iface
argument_list|,
name|err
argument_list|)
operator|==
name|HOSTAPD_CHAN_VALID
condition|)
block|{
name|acs_cleanup
argument_list|(
name|iface
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This can possibly happen if channel parameters (secondary 	 * channel, center frequencies) are misconfigured */
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: Possibly channel configuration is invalid, please report this along with your config file."
argument_list|)
expr_stmt|;
name|acs_fail
argument_list|(
name|iface
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_scan_complete
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|iface
operator|->
name|scan_cb
operator|=
name|NULL
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: Using survey based algorithm (acs_num_scans=%d)"
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|acs_num_scans
argument_list|)
expr_stmt|;
name|err
operator|=
name|hostapd_drv_get_survey
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: Failed to get survey data"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|++
name|iface
operator|->
name|acs_num_completed_scans
operator|<
name|iface
operator|->
name|conf
operator|->
name|acs_num_scans
condition|)
block|{
name|err
operator|=
name|acs_request_scan
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: Failed to request scan"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
return|return;
block|}
name|acs_study
argument_list|(
name|iface
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|hostapd_acs_completed
argument_list|(
name|iface
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|acs_fail
argument_list|(
name|iface
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acs_request_scan
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|struct
name|wpa_driver_scan_params
name|params
decl_stmt|;
name|struct
name|hostapd_channel_data
modifier|*
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|,
modifier|*
name|freq
decl_stmt|;
name|os_memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|freqs
operator|=
name|os_calloc
argument_list|(
name|iface
operator|->
name|current_mode
operator|->
name|num_channels
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|params
operator|.
name|freqs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|freqs
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|freq
operator|=
name|params
operator|.
name|freqs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iface
operator|->
name|current_mode
operator|->
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|chan
operator|=
operator|&
name|iface
operator|->
name|current_mode
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_DISABLED
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_in_chanlist
argument_list|(
name|iface
argument_list|,
name|chan
argument_list|)
condition|)
continue|continue;
operator|*
name|freq
operator|++
operator|=
name|chan
operator|->
name|freq
expr_stmt|;
block|}
operator|*
name|freq
operator|=
literal|0
expr_stmt|;
name|iface
operator|->
name|scan_cb
operator|=
name|acs_scan_complete
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"ACS: Scanning %d / %d"
argument_list|,
name|iface
operator|->
name|acs_num_completed_scans
operator|+
literal|1
argument_list|,
name|iface
operator|->
name|conf
operator|->
name|acs_num_scans
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostapd_driver_scan
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
argument_list|,
operator|&
name|params
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"ACS: Failed to request initial scan"
argument_list|)
expr_stmt|;
name|acs_cleanup
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|params
operator|.
name|freqs
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|os_free
argument_list|(
name|params
operator|.
name|freqs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|enum
name|hostapd_chan_status
name|acs_init
parameter_list|(
name|struct
name|hostapd_iface
modifier|*
name|iface
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"ACS: Automatic channel selection started, this may take a bit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|drv_flags
operator|&
name|WPA_DRIVER_FLAGS_ACS_OFFLOAD
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"ACS: Offloading to driver"
argument_list|)
expr_stmt|;
name|err
operator|=
name|hostapd_drv_do_acs
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|HOSTAPD_CHAN_INVALID
return|;
return|return
name|HOSTAPD_CHAN_ACS
return|;
block|}
name|acs_cleanup
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|err
operator|=
name|acs_request_scan
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|HOSTAPD_CHAN_INVALID
return|;
name|hostapd_set_state
argument_list|(
name|iface
argument_list|,
name|HAPD_IFACE_ACS
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|iface
operator|->
name|bss
index|[
literal|0
index|]
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|ACS_EVENT_STARTED
argument_list|)
expr_stmt|;
return|return
name|HOSTAPD_CHAN_ACS
return|;
block|}
end_function

end_unit

