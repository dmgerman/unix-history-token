begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Find and resolve or report look-ahead conflicts for bison,    Copyright (C) 1984, 1989, 1992 Free Software Foundation, Inc.  This file is part of Bison, the GNU Compiler Compiler.  Bison is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Bison is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bison; see the file COPYING.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|tags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tokensetsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|consistent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|accessing_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|shifts
modifier|*
modifier|*
name|shift_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
modifier|*
name|LA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|LAruleno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|lookaheads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|verboseflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fixed_outfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|initialize_conflicts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_conflicts
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|resolve_sr_conflict
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|flush_shift
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|log_resolution
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|conflict_log
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|verbose_conflict_log
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|total_conflicts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|count_sr_conflicts
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|count_rr_conflicts
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_reductions
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|finalize_conflicts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|any_conflicts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|conflicts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|errs
modifier|*
modifier|*
name|err_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expected_conflicts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|shiftset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|lookaheadset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|src_total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rrc_total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|src_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rrc_count
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|initialize_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*  register errs *sp; JF unused */
name|conflicts
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|shiftset
operator|=
name|NEW2
argument_list|(
name|tokensetsize
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|lookaheadset
operator|=
name|NEW2
argument_list|(
name|tokensetsize
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|err_table
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|errs
operator|*
argument_list|)
expr_stmt|;
name|any_conflicts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
name|set_conflicts
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_conflicts
parameter_list|(
name|int
name|state
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|shiftp
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp2
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp3
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp4
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp1
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
if|if
condition|(
name|consistent
index|[
name|state
index|]
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tokensetsize
condition|;
name|i
operator|++
control|)
name|lookaheadset
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|shiftp
operator|=
name|shift_table
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|shiftp
condition|)
block|{
name|k
operator|=
name|shiftp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|symbol
operator|=
name|accessing_symbol
index|[
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
name|SETBIT
argument_list|(
name|lookaheadset
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
block|}
name|k
operator|=
name|lookaheads
index|[
name|state
operator|+
literal|1
index|]
expr_stmt|;
name|fp4
operator|=
name|lookaheadset
operator|+
name|tokensetsize
expr_stmt|;
comment|/* loop over all rules which require lookahead in this state */
comment|/* first check for shift-reduce conflict, and try to resolve using precedence  */
for|for
control|(
name|i
operator|=
name|lookaheads
index|[
name|state
index|]
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rprec
index|[
name|LAruleno
index|[
name|i
index|]
index|]
condition|)
block|{
name|fp1
operator|=
name|LA
operator|+
name|i
operator|*
name|tokensetsize
expr_stmt|;
name|fp2
operator|=
name|fp1
expr_stmt|;
name|fp3
operator|=
name|lookaheadset
expr_stmt|;
while|while
condition|(
name|fp3
operator|<
name|fp4
condition|)
block|{
if|if
condition|(
operator|*
name|fp2
operator|++
operator|&
operator|*
name|fp3
operator|++
condition|)
block|{
name|resolve_sr_conflict
argument_list|(
name|state
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* loop over all rules which require lookahead in this state */
comment|/* Check for conflicts not resolved above.  */
for|for
control|(
name|i
operator|=
name|lookaheads
index|[
name|state
index|]
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|fp1
operator|=
name|LA
operator|+
name|i
operator|*
name|tokensetsize
expr_stmt|;
name|fp2
operator|=
name|fp1
expr_stmt|;
name|fp3
operator|=
name|lookaheadset
expr_stmt|;
while|while
condition|(
name|fp3
operator|<
name|fp4
condition|)
block|{
if|if
condition|(
operator|*
name|fp2
operator|++
operator|&
operator|*
name|fp3
operator|++
condition|)
block|{
name|conflicts
index|[
name|state
index|]
operator|=
literal|1
expr_stmt|;
name|any_conflicts
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|fp2
operator|=
name|fp1
expr_stmt|;
name|fp3
operator|=
name|lookaheadset
expr_stmt|;
while|while
condition|(
name|fp3
operator|<
name|fp4
condition|)
operator|*
name|fp3
operator|++
operator||=
operator|*
name|fp2
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to resolve shift-reduce conflict for one rule by means of precedence declarations. It has already been checked that the rule has a precedence. A conflict is resolved by modifying the shift or reduce tables so that there is no longer a conflict.  */
end_comment

begin_function
name|void
name|resolve_sr_conflict
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|lookaheadnum
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|mask
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp1
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp2
decl_stmt|;
specifier|register
name|int
name|redprec
decl_stmt|;
name|errs
modifier|*
name|errp
init|=
operator|(
name|errs
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|errs
argument_list|)
operator|+
name|ntokens
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
decl_stmt|;
name|short
modifier|*
name|errtokens
init|=
name|errp
operator|->
name|errs
decl_stmt|;
comment|/* find the rule to reduce by to get precedence of reduction  */
name|redprec
operator|=
name|rprec
index|[
name|LAruleno
index|[
name|lookaheadnum
index|]
index|]
expr_stmt|;
name|mask
operator|=
literal|1
expr_stmt|;
name|fp1
operator|=
name|LA
operator|+
name|lookaheadnum
operator|*
name|tokensetsize
expr_stmt|;
name|fp2
operator|=
name|lookaheadset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
operator|*
name|fp2
operator|&
operator|*
name|fp1
operator|)
operator|&&
name|sprec
index|[
name|i
index|]
condition|)
comment|/* Shift-reduce conflict occurs for token number i 	   and it has a precedence. 	   The precedence of shifting is that of token i.  */
block|{
if|if
condition|(
name|sprec
index|[
name|i
index|]
operator|<
name|redprec
condition|)
block|{
if|if
condition|(
name|verboseflag
condition|)
name|log_resolution
argument_list|(
name|state
argument_list|,
name|lookaheadnum
argument_list|,
name|i
argument_list|,
name|_
argument_list|(
literal|"reduce"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|fp2
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* flush the shift for this token */
name|flush_shift
argument_list|(
name|state
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sprec
index|[
name|i
index|]
operator|>
name|redprec
condition|)
block|{
if|if
condition|(
name|verboseflag
condition|)
name|log_resolution
argument_list|(
name|state
argument_list|,
name|lookaheadnum
argument_list|,
name|i
argument_list|,
name|_
argument_list|(
literal|"shift"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|fp1
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* flush the reduce for this token */
block|}
else|else
block|{
comment|/* Matching precedence levels. 		 For left association, keep only the reduction. 		 For right association, keep only the shift. 		 For nonassociation, keep neither.  */
switch|switch
condition|(
name|sassoc
index|[
name|i
index|]
condition|)
block|{
case|case
name|RIGHT_ASSOC
case|:
if|if
condition|(
name|verboseflag
condition|)
name|log_resolution
argument_list|(
name|state
argument_list|,
name|lookaheadnum
argument_list|,
name|i
argument_list|,
name|_
argument_list|(
literal|"shift"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEFT_ASSOC
case|:
if|if
condition|(
name|verboseflag
condition|)
name|log_resolution
argument_list|(
name|state
argument_list|,
name|lookaheadnum
argument_list|,
name|i
argument_list|,
name|_
argument_list|(
literal|"reduce"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NON_ASSOC
case|:
if|if
condition|(
name|verboseflag
condition|)
name|log_resolution
argument_list|(
name|state
argument_list|,
name|lookaheadnum
argument_list|,
name|i
argument_list|,
name|_
argument_list|(
literal|"an error"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sassoc
index|[
name|i
index|]
operator|!=
name|RIGHT_ASSOC
condition|)
block|{
operator|*
name|fp2
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* flush the shift for this token */
name|flush_shift
argument_list|(
name|state
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sassoc
index|[
name|i
index|]
operator|!=
name|LEFT_ASSOC
condition|)
block|{
operator|*
name|fp1
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* flush the reduce for this token */
block|}
if|if
condition|(
name|sassoc
index|[
name|i
index|]
operator|==
name|NON_ASSOC
condition|)
block|{
comment|/* Record an explicit error for this token.  */
operator|*
name|errtokens
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
literal|1
expr_stmt|;
name|fp2
operator|++
expr_stmt|;
name|fp1
operator|++
expr_stmt|;
block|}
block|}
name|errp
operator|->
name|nerrs
operator|=
name|errtokens
operator|-
name|errp
operator|->
name|errs
expr_stmt|;
if|if
condition|(
name|errp
operator|->
name|nerrs
condition|)
block|{
comment|/* Some tokens have been explicitly made errors.  Allocate 	 a permanent errs structure for this state, to record them.  */
name|i
operator|=
operator|(
name|char
operator|*
operator|)
name|errtokens
operator|-
operator|(
name|char
operator|*
operator|)
name|errp
expr_stmt|;
name|err_table
index|[
name|state
index|]
operator|=
operator|(
name|errs
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|errp
argument_list|,
name|err_table
index|[
name|state
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|err_table
index|[
name|state
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|errp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* turn off the shift recorded for the specified token in the specified state. Used when we resolve a shift-reduce conflict in favor of the reduction.  */
end_comment

begin_function
name|void
name|flush_shift
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|token
parameter_list|)
block|{
specifier|register
name|shifts
modifier|*
name|shiftp
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|,
name|i
decl_stmt|;
comment|/*  register unsigned symbol; JF unused */
name|shiftp
operator|=
name|shift_table
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|shiftp
condition|)
block|{
name|k
operator|=
name|shiftp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
operator|&&
name|token
operator|==
name|accessing_symbol
index|[
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
index|]
condition|)
operator|(
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|log_resolution
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|LAno
parameter_list|,
name|int
name|token
parameter_list|,
name|char
modifier|*
name|resolution
parameter_list|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"Conflict in state %d between rule %d and token %s resolved as %s.\n"
argument_list|)
argument_list|,
name|state
argument_list|,
name|LAruleno
index|[
name|LAno
index|]
argument_list|,
name|tags
index|[
name|token
index|]
argument_list|,
name|resolution
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|conflict_log
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|src_total
operator|=
literal|0
expr_stmt|;
name|rrc_total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|conflicts
index|[
name|i
index|]
condition|)
block|{
name|count_sr_conflicts
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|count_rr_conflicts
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|src_total
operator|+=
name|src_count
expr_stmt|;
name|rrc_total
operator|+=
name|rrc_count
expr_stmt|;
block|}
block|}
name|total_conflicts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|verbose_conflict_log
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|src_total
operator|=
literal|0
expr_stmt|;
name|rrc_total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|conflicts
index|[
name|i
index|]
condition|)
block|{
name|count_sr_conflicts
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|count_rr_conflicts
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|src_total
operator|+=
name|src_count
expr_stmt|;
name|rrc_total
operator|+=
name|rrc_count
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"State %d contains"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_count
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|" 1 shift/reduce conflict"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src_count
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|" %d shift/reduce conflicts"
argument_list|)
argument_list|,
name|src_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_count
operator|>
literal|0
operator|&&
name|rrc_count
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|" and"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc_count
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|" 1 reduce/reduce conflict"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rrc_count
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|" %d reduce/reduce conflicts"
argument_list|)
argument_list|,
name|rrc_count
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'.'
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
block|}
block|}
name|total_conflicts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|total_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|src_total
operator|==
name|expected_conflicts
operator|&&
name|rrc_total
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fixed_outfiles
condition|)
block|{
comment|/* If invoked under the name `yacc', use the output format 	 specified by POSIX.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"conflicts: "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_total
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" %d shift/reduce"
argument_list|)
argument_list|,
name|src_total
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_total
operator|>
literal|0
operator|&&
name|rrc_total
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc_total
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" %d reduce/reduce"
argument_list|)
argument_list|,
name|rrc_total
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s contains"
argument_list|)
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_total
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" 1 shift/reduce conflict"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src_total
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" %d shift/reduce conflicts"
argument_list|)
argument_list|,
name|src_total
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_total
operator|>
literal|0
operator|&&
name|rrc_total
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" and"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrc_total
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" 1 reduce/reduce conflict"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rrc_total
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" %d reduce/reduce conflicts"
argument_list|)
argument_list|,
name|rrc_total
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|count_sr_conflicts
parameter_list|(
name|int
name|state
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|mask
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|shiftp
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp1
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp2
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp3
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
name|src_count
operator|=
literal|0
expr_stmt|;
name|shiftp
operator|=
name|shift_table
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|shiftp
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tokensetsize
condition|;
name|i
operator|++
control|)
block|{
name|shiftset
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|lookaheadset
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|k
operator|=
name|shiftp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
condition|)
continue|continue;
name|symbol
operator|=
name|accessing_symbol
index|[
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
name|SETBIT
argument_list|(
name|shiftset
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|lookaheads
index|[
name|state
operator|+
literal|1
index|]
expr_stmt|;
name|fp3
operator|=
name|lookaheadset
operator|+
name|tokensetsize
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lookaheads
index|[
name|state
index|]
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|fp1
operator|=
name|LA
operator|+
name|i
operator|*
name|tokensetsize
expr_stmt|;
name|fp2
operator|=
name|lookaheadset
expr_stmt|;
while|while
condition|(
name|fp2
operator|<
name|fp3
condition|)
operator|*
name|fp2
operator|++
operator||=
operator|*
name|fp1
operator|++
expr_stmt|;
block|}
name|fp1
operator|=
name|shiftset
expr_stmt|;
name|fp2
operator|=
name|lookaheadset
expr_stmt|;
while|while
condition|(
name|fp2
operator|<
name|fp3
condition|)
operator|*
name|fp2
operator|++
operator|&=
operator|*
name|fp1
operator|++
expr_stmt|;
name|mask
operator|=
literal|1
expr_stmt|;
name|fp2
operator|=
name|lookaheadset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|*
name|fp2
condition|)
name|src_count
operator|++
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
literal|1
expr_stmt|;
name|fp2
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|count_rr_conflicts
parameter_list|(
name|int
name|state
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|unsigned
name|mask
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|baseword
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|wordp
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|rrc_count
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|lookaheads
index|[
name|state
index|]
expr_stmt|;
name|n
operator|=
name|lookaheads
index|[
name|state
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|-
name|m
operator|<
literal|2
condition|)
return|return;
name|mask
operator|=
literal|1
expr_stmt|;
name|baseword
operator|=
name|LA
operator|+
name|m
operator|*
name|tokensetsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|wordp
operator|=
name|baseword
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|m
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|*
name|wordp
condition|)
name|count
operator|++
expr_stmt|;
name|wordp
operator|+=
name|tokensetsize
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>=
literal|2
condition|)
name|rrc_count
operator|++
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
literal|1
expr_stmt|;
name|baseword
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|print_reductions
parameter_list|(
name|int
name|state
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp1
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp2
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp3
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp4
decl_stmt|;
specifier|register
name|int
name|rule
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
specifier|register
name|unsigned
name|mask
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|default_LA
decl_stmt|;
specifier|register
name|int
name|default_rule
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|cmax
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|shiftp
decl_stmt|;
specifier|register
name|errs
modifier|*
name|errp
decl_stmt|;
name|int
name|nodefault
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tokensetsize
condition|;
name|i
operator|++
control|)
name|shiftset
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|shiftp
operator|=
name|shift_table
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|shiftp
condition|)
block|{
name|k
operator|=
name|shiftp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
condition|)
continue|continue;
name|symbol
operator|=
name|accessing_symbol
index|[
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
comment|/* if this state has a shift for the error token, 	     don't use a default rule.  */
if|if
condition|(
name|symbol
operator|==
name|error_token_number
condition|)
name|nodefault
operator|=
literal|1
expr_stmt|;
name|SETBIT
argument_list|(
name|shiftset
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
block|}
name|errp
operator|=
name|err_table
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|errp
condition|)
block|{
name|k
operator|=
name|errp
operator|->
name|nerrs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|errp
operator|->
name|errs
index|[
name|i
index|]
condition|)
continue|continue;
name|symbol
operator|=
name|errp
operator|->
name|errs
index|[
name|i
index|]
expr_stmt|;
name|SETBIT
argument_list|(
name|shiftset
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
block|}
name|m
operator|=
name|lookaheads
index|[
name|state
index|]
expr_stmt|;
name|n
operator|=
name|lookaheads
index|[
name|state
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|-
name|m
operator|==
literal|1
operator|&&
operator|!
name|nodefault
condition|)
block|{
name|default_rule
operator|=
name|LAruleno
index|[
name|m
index|]
expr_stmt|;
name|fp1
operator|=
name|LA
operator|+
name|m
operator|*
name|tokensetsize
expr_stmt|;
name|fp2
operator|=
name|shiftset
expr_stmt|;
name|fp3
operator|=
name|lookaheadset
expr_stmt|;
name|fp4
operator|=
name|lookaheadset
operator|+
name|tokensetsize
expr_stmt|;
while|while
condition|(
name|fp3
operator|<
name|fp4
condition|)
operator|*
name|fp3
operator|++
operator|=
operator|*
name|fp1
operator|++
operator|&
operator|*
name|fp2
operator|++
expr_stmt|;
name|mask
operator|=
literal|1
expr_stmt|;
name|fp3
operator|=
name|lookaheadset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|*
name|fp3
condition|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    %-4s\t[reduce using rule %d (%s)]\n"
argument_list|)
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|,
name|default_rule
argument_list|,
name|tags
index|[
name|rlhs
index|[
name|default_rule
index|]
index|]
argument_list|)
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
literal|1
expr_stmt|;
name|fp3
operator|++
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    $default\treduce using rule %d (%s)\n\n"
argument_list|)
argument_list|,
name|default_rule
argument_list|,
name|tags
index|[
name|rlhs
index|[
name|default_rule
index|]
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|-
name|m
operator|>=
literal|1
condition|)
block|{
name|cmax
operator|=
literal|0
expr_stmt|;
name|default_LA
operator|=
operator|-
literal|1
expr_stmt|;
name|fp4
operator|=
name|lookaheadset
operator|+
name|tokensetsize
expr_stmt|;
if|if
condition|(
operator|!
name|nodefault
condition|)
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|fp1
operator|=
name|LA
operator|+
name|i
operator|*
name|tokensetsize
expr_stmt|;
name|fp2
operator|=
name|shiftset
expr_stmt|;
name|fp3
operator|=
name|lookaheadset
expr_stmt|;
while|while
condition|(
name|fp3
operator|<
name|fp4
condition|)
operator|*
name|fp3
operator|++
operator|=
operator|*
name|fp1
operator|++
operator|&
operator|(
operator|~
operator|(
operator|*
name|fp2
operator|++
operator|)
operator|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|1
expr_stmt|;
name|fp3
operator|=
name|lookaheadset
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntokens
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|*
name|fp3
condition|)
name|count
operator|++
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
literal|1
expr_stmt|;
name|fp3
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|>
name|cmax
condition|)
block|{
name|cmax
operator|=
name|count
expr_stmt|;
name|default_LA
operator|=
name|i
expr_stmt|;
name|default_rule
operator|=
name|LAruleno
index|[
name|i
index|]
expr_stmt|;
block|}
name|fp2
operator|=
name|shiftset
expr_stmt|;
name|fp3
operator|=
name|lookaheadset
expr_stmt|;
while|while
condition|(
name|fp3
operator|<
name|fp4
condition|)
operator|*
name|fp2
operator|++
operator||=
operator|*
name|fp3
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tokensetsize
condition|;
name|i
operator|++
control|)
name|shiftset
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shiftp
condition|)
block|{
name|k
operator|=
name|shiftp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
condition|)
continue|continue;
name|symbol
operator|=
name|accessing_symbol
index|[
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
name|SETBIT
argument_list|(
name|shiftset
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
block|}
name|mask
operator|=
literal|1
expr_stmt|;
name|fp1
operator|=
name|LA
operator|+
name|m
operator|*
name|tokensetsize
expr_stmt|;
name|fp2
operator|=
name|shiftset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|int
name|defaulted
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|&
operator|*
name|fp2
condition|)
name|count
operator|=
literal|1
expr_stmt|;
else|else
name|count
operator|=
literal|0
expr_stmt|;
name|fp3
operator|=
name|fp1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|m
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|*
name|fp3
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|j
operator|!=
name|default_LA
condition|)
block|{
name|rule
operator|=
name|LAruleno
index|[
name|j
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    %-4s\treduce using rule %d (%s)\n"
argument_list|)
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|,
name|rule
argument_list|,
name|tags
index|[
name|rlhs
index|[
name|rule
index|]
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|defaulted
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|defaulted
condition|)
block|{
name|rule
operator|=
name|LAruleno
index|[
name|default_LA
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    %-4s\treduce using rule %d (%s)\n"
argument_list|)
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|,
name|rule
argument_list|,
name|tags
index|[
name|rlhs
index|[
name|rule
index|]
index|]
argument_list|)
expr_stmt|;
name|defaulted
operator|=
literal|0
expr_stmt|;
block|}
name|rule
operator|=
name|LAruleno
index|[
name|j
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    %-4s\t[reduce using rule %d (%s)]\n"
argument_list|)
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|,
name|rule
argument_list|,
name|tags
index|[
name|rlhs
index|[
name|rule
index|]
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fp3
operator|+=
name|tokensetsize
expr_stmt|;
block|}
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
literal|1
expr_stmt|;
comment|/* We tried incrementing just fp1, and just fp2; both seem wrong. 		 It seems necessary to increment both in sync.  */
name|fp1
operator|++
expr_stmt|;
name|fp2
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|default_LA
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    $default\treduce using rule %d (%s)\n"
argument_list|)
argument_list|,
name|default_rule
argument_list|,
name|tags
index|[
name|rlhs
index|[
name|default_rule
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|finalize_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
name|FREE
argument_list|(
name|conflicts
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|shiftset
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lookaheadset
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

