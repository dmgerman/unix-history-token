begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Token-reader for Bison's input parser,    Copyright (C) 1984, 1986, 1989, 1992 Free Software Foundation, Inc.  This file is part of Bison, the GNU Compiler Compiler.  Bison is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Bison is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bison; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*     lex is the entry point.  It is called from reader.c.    It returns one of the token-type codes defined in lex.h.    When an identifier is seen, the code IDENTIFIER is returned    and the name is looked up in the symbol table using symtab.c;    symval is set to a pointer to the entry found.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* for optarg */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"new.h"
end_include

begin_comment
comment|/* flags set by % directives */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|definesflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -d */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|toknumflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -k */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|noparserflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -n */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fixed_outfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -y */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nolinesflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -l */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rawtoknumflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -r */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|verboseflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -v */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debugflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -t */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|spec_name_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -p */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|spec_file_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -b */
end_comment

begin_comment
comment|/*spec_outfile is declared in files.h, for -o */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|translations
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|parse_percent_token
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* functions from main.c */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|printable_version
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|warni
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|warn
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Buffer for storing the current token.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|token_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocated size of token_buffer, not including space for terminator.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxtoken
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bucket
modifier|*
name|symval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unlexed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these two describe a token to be reread */
end_comment

begin_decl_stmt
specifier|static
name|bucket
modifier|*
name|unlexed_symval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* by the next call to lex */
end_comment

begin_function
name|void
name|init_lex
parameter_list|()
block|{
name|maxtoken
operator|=
literal|100
expr_stmt|;
name|token_buffer
operator|=
name|NEW2
argument_list|(
name|maxtoken
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|unlexed
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|grow_token_buffer
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|offset
init|=
name|p
operator|-
name|token_buffer
decl_stmt|;
name|maxtoken
operator|*=
literal|2
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|token_buffer
argument_list|,
name|maxtoken
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|token_buffer
operator|+
name|offset
return|;
block|}
end_function

begin_function
name|int
name|skip_white_space
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|inside
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|cplus_comment
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|&&
name|c
operator|!=
literal|'/'
condition|)
block|{
name|warn
argument_list|(
literal|"unexpected `/' found and ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
name|cplus_comment
operator|=
operator|(
name|c
operator|==
literal|'/'
operator|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|inside
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|inside
condition|)
block|{
if|if
condition|(
operator|!
name|cplus_comment
operator|&&
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'*'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|inside
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|cplus_comment
condition|)
name|inside
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
literal|"unterminated comment"
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* do a getc, but give error message if EOF encountered */
end_comment

begin_function
name|int
name|safegetc
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
name|getc
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
literal|"Unexpected end of file"
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* read one literal character from finput.  process \ escapes.    append the normalized string version of the char to *pp.    assign the character code to *pcode    return 1 unless the character is an unescaped `term' or \n 	report error for \n */
end_comment

begin_function
name|int
name|literalchar
parameter_list|(
name|pp
parameter_list|,
name|pcode
parameter_list|,
name|term
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
modifier|*
name|pcode
decl_stmt|;
name|char
name|term
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|code
decl_stmt|;
name|int
name|wasquote
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|safegetc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|warn
argument_list|(
literal|"unescaped newline in constant"
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|code
operator|=
literal|'?'
expr_stmt|;
name|wasquote
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
block|{
name|code
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|term
condition|)
name|wasquote
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|safegetc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
name|code
operator|=
literal|'\t'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
name|code
operator|=
literal|'\n'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'a'
condition|)
name|code
operator|=
literal|'\007'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
name|code
operator|=
literal|'\r'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
name|code
operator|=
literal|'\f'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
name|code
operator|=
literal|'\b'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'v'
condition|)
name|code
operator|=
literal|013
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|code
operator|=
literal|'\\'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|code
operator|=
literal|'\''
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
name|code
operator|=
literal|'\"'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<=
literal|'7'
operator|&&
name|c
operator|>=
literal|'0'
condition|)
block|{
name|code
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|<=
literal|'7'
operator|&&
name|c
operator|>=
literal|'0'
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|*
literal|8
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|256
operator|||
name|code
operator|<
literal|0
condition|)
block|{
name|warni
argument_list|(
literal|"octal value outside range 0...255: `\\%o'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|code
operator|&=
literal|0xFF
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|safegetc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'x'
condition|)
block|{
name|c
operator|=
name|safegetc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|code
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|code
operator|*=
literal|16
operator|,
name|code
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|code
operator|*=
literal|16
operator|,
name|code
operator|+=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|code
operator|*=
literal|16
operator|,
name|code
operator|+=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|code
operator|>=
literal|256
operator|||
name|code
operator|<
literal|0
condition|)
block|{
name|warni
argument_list|(
literal|"hexadecimal value above 255: `\\x%x'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|code
operator|&=
literal|0xFF
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|safegetc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warni
argument_list|(
literal|"unknown escape sequence: `\\' followed by `%s'"
argument_list|,
name|printable_version
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
literal|'?'
expr_stmt|;
block|}
block|}
comment|/* has \ */
comment|/* now fill token_buffer with the canonical name for this character      as a literal token.  Do not use what the user typed,      so that `\012' and `\n' can be interchangeable.  */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|040
operator|&&
name|code
operator|<
literal|0177
condition|)
operator|*
name|p
operator|++
operator|=
name|code
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|'\''
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|'\"'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\"'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|'\t'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'t'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'r'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|'\v'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'v'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|'\b'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'b'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|'\f'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'f'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|code
operator|/
literal|0100
operator|+
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|code
operator|/
literal|010
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|code
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|p
expr_stmt|;
operator|*
name|pcode
operator|=
name|code
expr_stmt|;
return|return
operator|!
name|wasquote
return|;
block|}
end_function

begin_function
name|void
name|unlex
parameter_list|(
name|token
parameter_list|)
name|int
name|token
decl_stmt|;
block|{
name|unlexed
operator|=
name|token
expr_stmt|;
name|unlexed_symval
operator|=
name|symval
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lex
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|unlexed
operator|>=
literal|0
condition|)
block|{
name|symval
operator|=
name|unlexed_symval
expr_stmt|;
name|c
operator|=
name|unlexed
expr_stmt|;
name|unlexed
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|c
operator|=
name|skip_white_space
argument_list|()
expr_stmt|;
operator|*
name|token_buffer
operator|=
name|c
expr_stmt|;
comment|/* for error messages (token buffer always valid) */
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|strcpy
argument_list|(
name|token_buffer
argument_list|,
literal|"EOF"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENDFILE
operator|)
return|;
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'.'
case|:
case|case
literal|'_'
case|:
name|p
operator|=
name|token_buffer
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|grow_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|symval
operator|=
name|getsym
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|IDENTIFIER
operator|)
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|numval
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|token_buffer
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|grow_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|numval
operator|=
name|numval
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
return|return
operator|(
name|NUMBER
operator|)
return|;
block|}
case|case
literal|'\''
case|:
comment|/* parse the literal token and compute character code in  code  */
name|translations
operator|=
operator|-
literal|1
expr_stmt|;
block|{
name|int
name|code
decl_stmt|,
name|discode
decl_stmt|;
name|char
name|discard
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|p
operator|=
name|token_buffer
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
name|literalchar
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|code
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\''
condition|)
block|{
name|warn
argument_list|(
literal|"use \"...\" for multi-character literal tokens"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|discard
expr_stmt|;
while|while
condition|(
name|literalchar
argument_list|(
operator|&
name|dp
argument_list|,
operator|&
name|discode
argument_list|,
literal|'\''
argument_list|)
condition|)
block|{}
block|}
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symval
operator|=
name|getsym
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|symval
operator|->
name|class
operator|=
name|STOKEN
expr_stmt|;
if|if
condition|(
operator|!
name|symval
operator|->
name|user_token_number
condition|)
name|symval
operator|->
name|user_token_number
operator|=
name|code
expr_stmt|;
return|return
operator|(
name|IDENTIFIER
operator|)
return|;
block|}
case|case
literal|'\"'
case|:
comment|/* parse the literal string token and treat as an identifier */
name|translations
operator|=
operator|-
literal|1
expr_stmt|;
block|{
name|int
name|code
decl_stmt|;
comment|/* ignored here */
name|p
operator|=
name|token_buffer
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\"'
expr_stmt|;
while|while
condition|(
name|literalchar
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|code
argument_list|,
literal|'\"'
argument_list|)
condition|)
comment|/* read up to and including " */
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|4
condition|)
name|p
operator|=
name|grow_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symval
operator|=
name|getsym
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|symval
operator|->
name|class
operator|=
name|STOKEN
expr_stmt|;
return|return
operator|(
name|IDENTIFIER
operator|)
return|;
block|}
case|case
literal|','
case|:
return|return
operator|(
name|COMMA
operator|)
return|;
case|case
literal|':'
case|:
return|return
operator|(
name|COLON
operator|)
return|;
case|case
literal|';'
case|:
return|return
operator|(
name|SEMICOLON
operator|)
return|;
case|case
literal|'|'
case|:
return|return
operator|(
name|BAR
operator|)
return|;
case|case
literal|'{'
case|:
return|return
operator|(
name|LEFT_CURLY
operator|)
return|;
case|case
literal|'='
case|:
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|strcpy
argument_list|(
name|token_buffer
argument_list|,
literal|"={"
argument_list|)
expr_stmt|;
return|return
operator|(
name|LEFT_CURLY
operator|)
return|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
return|return
operator|(
name|ILLEGAL
operator|)
return|;
block|}
case|case
literal|'<'
case|:
name|p
operator|=
name|token_buffer
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'>'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
literal|"unterminated type name at end of file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|warn
argument_list|(
literal|"unterminated type name"
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|grow_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|TYPENAME
operator|)
return|;
case|case
literal|'%'
case|:
return|return
operator|(
name|parse_percent_token
argument_list|()
operator|)
return|;
default|default:
return|return
operator|(
name|ILLEGAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* the following table dictates the action taken for the various  	% directives.  A setflag value causes the named flag to be 	set.  A retval action returns the code. */
end_comment

begin_struct
struct|struct
name|percent_table_struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|void
modifier|*
name|setflag
decl_stmt|;
name|int
name|retval
decl_stmt|;
block|}
name|percent_table
index|[]
init|=
block|{
block|{
literal|"token"
block|,
name|NULL
block|,
name|TOKEN
block|}
block|,
block|{
literal|"term"
block|,
name|NULL
block|,
name|TOKEN
block|}
block|,
block|{
literal|"nterm"
block|,
name|NULL
block|,
name|NTERM
block|}
block|,
block|{
literal|"type"
block|,
name|NULL
block|,
name|TYPE
block|}
block|,
block|{
literal|"guard"
block|,
name|NULL
block|,
name|GUARD
block|}
block|,
block|{
literal|"union"
block|,
name|NULL
block|,
name|UNION
block|}
block|,
block|{
literal|"expect"
block|,
name|NULL
block|,
name|EXPECT
block|}
block|,
block|{
literal|"thong"
block|,
name|NULL
block|,
name|THONG
block|}
block|,
block|{
literal|"start"
block|,
name|NULL
block|,
name|START
block|}
block|,
block|{
literal|"left"
block|,
name|NULL
block|,
name|LEFT
block|}
block|,
block|{
literal|"right"
block|,
name|NULL
block|,
name|RIGHT
block|}
block|,
block|{
literal|"nonassoc"
block|,
name|NULL
block|,
name|NONASSOC
block|}
block|,
block|{
literal|"binary"
block|,
name|NULL
block|,
name|NONASSOC
block|}
block|,
block|{
literal|"semantic_parser"
block|,
name|NULL
block|,
name|SEMANTIC_PARSER
block|}
block|,
block|{
literal|"pure_parser"
block|,
name|NULL
block|,
name|PURE_PARSER
block|}
block|,
block|{
literal|"prec"
block|,
name|NULL
block|,
name|PREC
block|}
block|,
block|{
literal|"no_lines"
block|,
operator|&
name|nolinesflag
block|,
name|NOOP
block|}
block|,
comment|/* -l */
block|{
literal|"raw"
block|,
operator|&
name|rawtoknumflag
block|,
name|NOOP
block|}
block|,
comment|/* -r */
block|{
literal|"token_table"
block|,
operator|&
name|toknumflag
block|,
name|NOOP
block|}
block|,
comment|/* -k */
if|#
directive|if
literal|0
comment|/* These can be utilized after main is reoganized so      open_files() is deferred 'til after read_declarations().      But %{ and %union both put information into files      that have to be opened before read_declarations().      */
block|{"yacc",&fixed_outfiles, NOOP},
comment|/* -y */
block|{"fixed_output_files",&fixed_outfiles, NOOP},
comment|/* -y */
block|{"defines",&definesflag, NOOP},
comment|/* -d */
block|{"no_parser",&noparserflag, NOOP},
comment|/* -n */
block|{"output_file",&spec_outfile, SETOPT},
comment|/* -o */
block|{"file_prefix",&spec_file_prefix, SETOPT},
comment|/* -b */
block|{"name_prefix",&spec_name_prefix, SETOPT},
comment|/* -p */
comment|/* These would be acceptable, but they do not affect processing */
block|{"verbose",&verboseflag, NOOP},
comment|/* -v */
block|{"debug",&debugflag, NOOP},
comment|/* -t */
comment|/*	{"help",<print usage stmt>, NOOP},	/* -h */
comment|/*	{"version",<print version number> ,  NOOP},	/* -V */
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|,
name|ILLEGAL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Parse a token which starts with %.    Assumes the % has already been read and discarded.  */
end_comment

begin_function
name|int
name|parse_percent_token
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|percent_table_struct
modifier|*
name|tx
decl_stmt|;
name|p
operator|=
name|token_buffer
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
comment|/* for error msg */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
return|return
operator|(
name|TWO_PERCENTS
operator|)
return|;
case|case
literal|'{'
case|:
return|return
operator|(
name|PERCENT_LEFT_CURLY
operator|)
return|;
case|case
literal|'<'
case|:
return|return
operator|(
name|LEFT
operator|)
return|;
case|case
literal|'>'
case|:
return|return
operator|(
name|RIGHT
operator|)
return|;
case|case
literal|'2'
case|:
return|return
operator|(
name|NONASSOC
operator|)
return|;
case|case
literal|'0'
case|:
return|return
operator|(
name|TOKEN
operator|)
return|;
case|case
literal|'='
case|:
return|return
operator|(
name|PREC
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|ILLEGAL
operator|)
return|;
name|p
operator|=
name|token_buffer
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|grow_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
name|c
operator|=
literal|'_'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* table lookup % directive */
for|for
control|(
name|tx
operator|=
name|percent_table
init|;
name|tx
operator|->
name|name
condition|;
name|tx
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|token_buffer
operator|+
literal|1
argument_list|,
name|tx
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|tx
operator|->
name|retval
operator|==
name|SETOPT
condition|)
block|{
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|tx
operator|->
name|setflag
operator|)
operator|)
operator|=
name|optarg
expr_stmt|;
return|return
name|NOOP
return|;
block|}
if|if
condition|(
name|tx
operator|->
name|setflag
condition|)
block|{
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|tx
operator|->
name|setflag
operator|)
operator|)
operator|=
literal|1
expr_stmt|;
return|return
name|NOOP
return|;
block|}
return|return
name|tx
operator|->
name|retval
return|;
block|}
end_function

end_unit

