begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate the nondeterministic finite state machine for bison,    Copyright (C) 1984, 1986, 1989 Free Software Foundation, Inc.  This file is part of Bison, the GNU Compiler Compiler.  Bison is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Bison is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bison; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* See comments in state.h for the data structures that represent it.    The entry point is generate_states.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"new.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|nullable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|itemset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|itemsetend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nstates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|final_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|core
modifier|*
name|first_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|shifts
modifier|*
name|first_shift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|reductions
modifier|*
name|first_reduction
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|get_state
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|core
modifier|*
name|new_state
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|new_itemsets
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|append_states
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|initialize_states
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|save_shifts
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|save_reductions
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|augment_automaton
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_start_shift
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|initialize_closure
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|closure
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|finalize_closure
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|toomany
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|core
modifier|*
name|this_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|core
modifier|*
name|last_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|shifts
modifier|*
name|last_shift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reductions
modifier|*
name|last_reduction
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nshifts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|shift_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|redset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|shiftset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|kernel_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|kernel_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|kernel_items
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for states, to recognize equivalent ones.  */
end_comment

begin_define
define|#
directive|define
name|STATE_TABLE_SIZE
value|1009
end_define

begin_decl_stmt
specifier|static
name|core
modifier|*
modifier|*
name|state_table
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|allocate_itemsets
parameter_list|()
block|{
specifier|register
name|short
modifier|*
name|itemp
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|short
modifier|*
name|symbol_count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|symbol_count
operator|=
name|NEW2
argument_list|(
name|nsyms
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|itemp
operator|=
name|ritem
expr_stmt|;
name|symbol
operator|=
operator|*
name|itemp
operator|++
expr_stmt|;
while|while
condition|(
name|symbol
condition|)
block|{
if|if
condition|(
name|symbol
operator|>
literal|0
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|symbol_count
index|[
name|symbol
index|]
operator|++
expr_stmt|;
block|}
name|symbol
operator|=
operator|*
name|itemp
operator|++
expr_stmt|;
block|}
comment|/* see comments before new_itemsets.  All the vectors of items      live inside kernel_items.  The number of active items after      some symbol cannot be more than the number of times that symbol      appears as an item, which is symbol_count[symbol].      We allocate that much space for each symbol.  */
name|kernel_base
operator|=
name|NEW2
argument_list|(
name|nsyms
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|kernel_items
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|kernel_base
index|[
name|i
index|]
operator|=
name|kernel_items
operator|+
name|count
expr_stmt|;
name|count
operator|+=
name|symbol_count
index|[
name|i
index|]
expr_stmt|;
block|}
name|shift_symbol
operator|=
name|symbol_count
expr_stmt|;
name|kernel_end
operator|=
name|NEW2
argument_list|(
name|nsyms
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|allocate_storage
parameter_list|()
block|{
name|allocate_itemsets
argument_list|()
expr_stmt|;
name|shiftset
operator|=
name|NEW2
argument_list|(
name|nsyms
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|redset
operator|=
name|NEW2
argument_list|(
name|nrules
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|state_table
operator|=
name|NEW2
argument_list|(
name|STATE_TABLE_SIZE
argument_list|,
name|core
operator|*
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_storage
parameter_list|()
block|{
name|FREE
argument_list|(
name|shift_symbol
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|redset
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|shiftset
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|kernel_base
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|kernel_end
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|kernel_items
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|state_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* compute the nondeterministic finite state machine (see state.h for details) from the grammar.  */
end_comment

begin_function
name|void
name|generate_states
parameter_list|()
block|{
name|allocate_storage
argument_list|()
expr_stmt|;
name|initialize_closure
argument_list|(
name|nitems
argument_list|)
expr_stmt|;
name|initialize_states
argument_list|()
expr_stmt|;
while|while
condition|(
name|this_state
condition|)
block|{
comment|/* Set up ruleset and itemset for the transitions out of this state.          ruleset gets a 1 bit for each rule that could reduce now. 	 itemset gets a vector of all the items that could be accepted next.  */
name|closure
argument_list|(
name|this_state
operator|->
name|items
argument_list|,
name|this_state
operator|->
name|nitems
argument_list|)
expr_stmt|;
comment|/* record the reductions allowed out of this state */
name|save_reductions
argument_list|()
expr_stmt|;
comment|/* find the itemsets of the states that shifts can reach */
name|new_itemsets
argument_list|()
expr_stmt|;
comment|/* find or create the core structures for those states */
name|append_states
argument_list|()
expr_stmt|;
comment|/* create the shifts structures for the shifts to those states,          now that the state numbers transitioning to are known */
if|if
condition|(
name|nshifts
operator|>
literal|0
condition|)
name|save_shifts
argument_list|()
expr_stmt|;
comment|/* states are queued when they are created; process them all */
name|this_state
operator|=
name|this_state
operator|->
name|next
expr_stmt|;
block|}
comment|/* discard various storage */
name|finalize_closure
argument_list|()
expr_stmt|;
name|free_storage
argument_list|()
expr_stmt|;
comment|/* set up initial and final states as parser wants them */
name|augment_automaton
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find which symbols can be shifted in the current state,    and for each one record which items would be active after that shift.    Uses the contents of itemset.    shift_symbol is set to a vector of the symbols that can be shifted.    For each symbol in the grammar, kernel_base[symbol] points to    a vector of item numbers activated if that symbol is shifted,    and kernel_end[symbol] points after the end of that vector.  */
end_comment

begin_function
name|void
name|new_itemsets
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|shiftcount
decl_stmt|;
specifier|register
name|short
modifier|*
name|isp
decl_stmt|;
specifier|register
name|short
modifier|*
name|ksp
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Entering new_itemsets\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
name|kernel_end
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|shiftcount
operator|=
literal|0
expr_stmt|;
name|isp
operator|=
name|itemset
expr_stmt|;
while|while
condition|(
name|isp
operator|<
name|itemsetend
condition|)
block|{
name|i
operator|=
operator|*
name|isp
operator|++
expr_stmt|;
name|symbol
operator|=
name|ritem
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|symbol
operator|>
literal|0
condition|)
block|{
name|ksp
operator|=
name|kernel_end
index|[
name|symbol
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ksp
condition|)
block|{
name|shift_symbol
index|[
name|shiftcount
operator|++
index|]
operator|=
name|symbol
expr_stmt|;
name|ksp
operator|=
name|kernel_base
index|[
name|symbol
index|]
expr_stmt|;
block|}
operator|*
name|ksp
operator|++
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|kernel_end
index|[
name|symbol
index|]
operator|=
name|ksp
expr_stmt|;
block|}
block|}
name|nshifts
operator|=
name|shiftcount
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use the information computed by new_itemsets to find the state numbers    reached by each shift transition from the current state.     shiftset is set up as a vector of state numbers of those states.  */
end_comment

begin_function
name|void
name|append_states
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Entering append_states\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* first sort shift_symbol into increasing order */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nshifts
condition|;
name|i
operator|++
control|)
block|{
name|symbol
operator|=
name|shift_symbol
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|j
operator|>
literal|0
operator|&&
name|shift_symbol
index|[
name|j
operator|-
literal|1
index|]
operator|>
name|symbol
condition|)
block|{
name|shift_symbol
index|[
name|j
index|]
operator|=
name|shift_symbol
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
name|shift_symbol
index|[
name|j
index|]
operator|=
name|symbol
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nshifts
condition|;
name|i
operator|++
control|)
block|{
name|symbol
operator|=
name|shift_symbol
index|[
name|i
index|]
expr_stmt|;
name|shiftset
index|[
name|i
index|]
operator|=
name|get_state
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* find the state number for the state we would get to (from the current state) by shifting symbol. Create a new state if no equivalent one exists already. Used by append_states  */
end_comment

begin_function
name|int
name|get_state
parameter_list|(
name|symbol
parameter_list|)
name|int
name|symbol
decl_stmt|;
block|{
specifier|register
name|int
name|key
decl_stmt|;
specifier|register
name|short
modifier|*
name|isp1
decl_stmt|;
specifier|register
name|short
modifier|*
name|isp2
decl_stmt|;
specifier|register
name|short
modifier|*
name|iend
decl_stmt|;
specifier|register
name|core
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|found
decl_stmt|;
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Entering get_state, symbol = %d\n"
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isp1
operator|=
name|kernel_base
index|[
name|symbol
index|]
expr_stmt|;
name|iend
operator|=
name|kernel_end
index|[
name|symbol
index|]
expr_stmt|;
name|n
operator|=
name|iend
operator|-
name|isp1
expr_stmt|;
comment|/* add up the target state's active item numbers to get a hash key */
name|key
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isp1
operator|<
name|iend
condition|)
name|key
operator|+=
operator|*
name|isp1
operator|++
expr_stmt|;
name|key
operator|=
name|key
operator|%
name|STATE_TABLE_SIZE
expr_stmt|;
name|sp
operator|=
name|state_table
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|nitems
operator|==
name|n
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|isp1
operator|=
name|kernel_base
index|[
name|symbol
index|]
expr_stmt|;
name|isp2
operator|=
name|sp
operator|->
name|items
expr_stmt|;
while|while
condition|(
name|found
operator|&&
name|isp1
operator|<
name|iend
condition|)
block|{
if|if
condition|(
operator|*
name|isp1
operator|++
operator|!=
operator|*
name|isp2
operator|++
condition|)
name|found
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|link
condition|)
block|{
name|sp
operator|=
name|sp
operator|->
name|link
expr_stmt|;
block|}
else|else
comment|/* bucket exhausted and no match */
block|{
name|sp
operator|=
name|sp
operator|->
name|link
operator|=
name|new_state
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
comment|/* bucket is empty */
block|{
name|state_table
index|[
name|key
index|]
operator|=
name|sp
operator|=
name|new_state
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|->
name|number
operator|)
return|;
block|}
end_function

begin_comment
comment|/* subroutine of get_state.  create a new state for those items, if necessary.  */
end_comment

begin_function
name|core
modifier|*
name|new_state
parameter_list|(
name|symbol
parameter_list|)
name|int
name|symbol
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|core
modifier|*
name|p
decl_stmt|;
specifier|register
name|short
modifier|*
name|isp1
decl_stmt|;
specifier|register
name|short
modifier|*
name|isp2
decl_stmt|;
specifier|register
name|short
modifier|*
name|iend
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Entering new_state, symbol = %d\n"
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nstates
operator|>=
name|MAXSHORT
condition|)
name|toomany
argument_list|(
literal|"states"
argument_list|)
expr_stmt|;
name|isp1
operator|=
name|kernel_base
index|[
name|symbol
index|]
expr_stmt|;
name|iend
operator|=
name|kernel_end
index|[
name|symbol
index|]
expr_stmt|;
name|n
operator|=
name|iend
operator|-
name|isp1
expr_stmt|;
name|p
operator|=
operator|(
name|core
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|core
argument_list|)
operator|+
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|accessing_symbol
operator|=
name|symbol
expr_stmt|;
name|p
operator|->
name|number
operator|=
name|nstates
expr_stmt|;
name|p
operator|->
name|nitems
operator|=
name|n
expr_stmt|;
name|isp2
operator|=
name|p
operator|->
name|items
expr_stmt|;
while|while
condition|(
name|isp1
operator|<
name|iend
condition|)
operator|*
name|isp2
operator|++
operator|=
operator|*
name|isp1
operator|++
expr_stmt|;
name|last_state
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|last_state
operator|=
name|p
expr_stmt|;
name|nstates
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
name|initialize_states
parameter_list|()
block|{
specifier|register
name|core
modifier|*
name|p
decl_stmt|;
comment|/*  register unsigned *rp1; JF unused */
comment|/*  register unsigned *rp2; JF unused */
comment|/*  register unsigned *rend; JF unused */
name|p
operator|=
operator|(
name|core
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|core
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|first_state
operator|=
name|last_state
operator|=
name|this_state
operator|=
name|p
expr_stmt|;
name|nstates
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|save_shifts
parameter_list|()
block|{
specifier|register
name|shifts
modifier|*
name|p
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp1
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp2
decl_stmt|;
specifier|register
name|short
modifier|*
name|send
decl_stmt|;
name|p
operator|=
operator|(
name|shifts
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|shifts
argument_list|)
operator|+
operator|(
name|nshifts
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|number
operator|=
name|this_state
operator|->
name|number
expr_stmt|;
name|p
operator|->
name|nshifts
operator|=
name|nshifts
expr_stmt|;
name|sp1
operator|=
name|shiftset
expr_stmt|;
name|sp2
operator|=
name|p
operator|->
name|shifts
expr_stmt|;
name|send
operator|=
name|shiftset
operator|+
name|nshifts
expr_stmt|;
while|while
condition|(
name|sp1
operator|<
name|send
condition|)
operator|*
name|sp2
operator|++
operator|=
operator|*
name|sp1
operator|++
expr_stmt|;
if|if
condition|(
name|last_shift
condition|)
block|{
name|last_shift
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|last_shift
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|first_shift
operator|=
name|p
expr_stmt|;
name|last_shift
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* find which rules can be used for reduction transitions from the current state    and make a reductions structure for the state to record their rule numbers.  */
end_comment

begin_function
name|void
name|save_reductions
parameter_list|()
block|{
specifier|register
name|short
modifier|*
name|isp
decl_stmt|;
specifier|register
name|short
modifier|*
name|rp1
decl_stmt|;
specifier|register
name|short
modifier|*
name|rp2
decl_stmt|;
specifier|register
name|int
name|item
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|reductions
modifier|*
name|p
decl_stmt|;
name|short
modifier|*
name|rend
decl_stmt|;
comment|/* find and count the active items that represent ends of rules */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|isp
operator|=
name|itemset
init|;
name|isp
operator|<
name|itemsetend
condition|;
name|isp
operator|++
control|)
block|{
name|item
operator|=
name|ritem
index|[
operator|*
name|isp
index|]
expr_stmt|;
if|if
condition|(
name|item
operator|<
literal|0
condition|)
block|{
name|redset
index|[
name|count
operator|++
index|]
operator|=
operator|-
name|item
expr_stmt|;
block|}
block|}
comment|/* make a reductions structure and copy the data into it.  */
if|if
condition|(
name|count
condition|)
block|{
name|p
operator|=
operator|(
name|reductions
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|reductions
argument_list|)
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|number
operator|=
name|this_state
operator|->
name|number
expr_stmt|;
name|p
operator|->
name|nreds
operator|=
name|count
expr_stmt|;
name|rp1
operator|=
name|redset
expr_stmt|;
name|rp2
operator|=
name|p
operator|->
name|rules
expr_stmt|;
name|rend
operator|=
name|rp1
operator|+
name|count
expr_stmt|;
while|while
condition|(
name|rp1
operator|<
name|rend
condition|)
operator|*
name|rp2
operator|++
operator|=
operator|*
name|rp1
operator|++
expr_stmt|;
if|if
condition|(
name|last_reduction
condition|)
block|{
name|last_reduction
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|last_reduction
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|first_reduction
operator|=
name|p
expr_stmt|;
name|last_reduction
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make sure that the initial state has a shift that accepts the grammar's start symbol and goes to the next-to-final state, which has a shift going to the final state, which has a shift to the termination state. Create such states and shifts if they don't happen to exist already.  */
end_comment

begin_function
name|void
name|augment_automaton
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
comment|/*  register int found; JF unused */
specifier|register
name|core
modifier|*
name|statep
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|sp2
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|sp1
decl_stmt|;
name|sp
operator|=
name|first_shift
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|number
operator|==
literal|0
condition|)
block|{
name|k
operator|=
name|sp
operator|->
name|nshifts
expr_stmt|;
name|statep
operator|=
name|first_state
operator|->
name|next
expr_stmt|;
comment|/* The states reached by shifts from first_state are numbered 1...K. 	     Look for one reached by start_symbol.  */
while|while
condition|(
name|statep
operator|->
name|accessing_symbol
operator|<
name|start_symbol
operator|&&
name|statep
operator|->
name|number
operator|<
name|k
condition|)
name|statep
operator|=
name|statep
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|statep
operator|->
name|accessing_symbol
operator|==
name|start_symbol
condition|)
block|{
comment|/* We already have a next-to-final state. 		 Make sure it has a shift to what will be the final state.  */
name|k
operator|=
name|statep
operator|->
name|number
expr_stmt|;
while|while
condition|(
name|sp
operator|&&
name|sp
operator|->
name|number
operator|<
name|k
condition|)
block|{
name|sp1
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|&&
name|sp
operator|->
name|number
operator|==
name|k
condition|)
block|{
name|sp2
operator|=
operator|(
name|shifts
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|shifts
argument_list|)
operator|+
name|sp
operator|->
name|nshifts
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sp2
operator|->
name|number
operator|=
name|k
expr_stmt|;
name|sp2
operator|->
name|nshifts
operator|=
name|sp
operator|->
name|nshifts
operator|+
literal|1
expr_stmt|;
name|sp2
operator|->
name|shifts
index|[
literal|0
index|]
operator|=
name|nstates
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sp
operator|->
name|nshifts
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|sp2
operator|->
name|shifts
index|[
name|i
index|]
operator|=
name|sp
operator|->
name|shifts
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Patch sp2 into the chain of shifts in place of sp, 		     following sp1.  */
name|sp2
operator|->
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|sp1
operator|->
name|next
operator|=
name|sp2
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|last_shift
condition|)
name|last_shift
operator|=
name|sp2
expr_stmt|;
name|FREE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp2
operator|=
name|NEW
argument_list|(
name|shifts
argument_list|)
expr_stmt|;
name|sp2
operator|->
name|number
operator|=
name|k
expr_stmt|;
name|sp2
operator|->
name|nshifts
operator|=
literal|1
expr_stmt|;
name|sp2
operator|->
name|shifts
index|[
literal|0
index|]
operator|=
name|nstates
expr_stmt|;
comment|/* Patch sp2 into the chain of shifts between sp1 and sp.  */
name|sp2
operator|->
name|next
operator|=
name|sp
expr_stmt|;
name|sp1
operator|->
name|next
operator|=
name|sp2
expr_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
name|last_shift
operator|=
name|sp2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is no next-to-final state as yet.  */
comment|/* Add one more shift in first_shift, 		 going to the next-to-final state (yet to be made).  */
name|sp
operator|=
name|first_shift
expr_stmt|;
name|sp2
operator|=
operator|(
name|shifts
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|shifts
argument_list|)
operator|+
name|sp
operator|->
name|nshifts
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|sp2
operator|->
name|nshifts
operator|=
name|sp
operator|->
name|nshifts
operator|+
literal|1
expr_stmt|;
comment|/* Stick this shift into the vector at the proper place.  */
name|statep
operator|=
name|first_state
operator|->
name|next
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|nshifts
condition|;
name|k
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|statep
operator|->
name|accessing_symbol
operator|>
name|start_symbol
operator|&&
name|i
operator|==
name|k
condition|)
name|sp2
operator|->
name|shifts
index|[
name|k
operator|++
index|]
operator|=
name|nstates
expr_stmt|;
name|sp2
operator|->
name|shifts
index|[
name|k
index|]
operator|=
name|sp
operator|->
name|shifts
index|[
name|i
index|]
expr_stmt|;
name|statep
operator|=
name|statep
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|k
condition|)
name|sp2
operator|->
name|shifts
index|[
name|k
operator|++
index|]
operator|=
name|nstates
expr_stmt|;
comment|/* Patch sp2 into the chain of shifts 		 in place of sp, at the beginning.  */
name|sp2
operator|->
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|first_shift
operator|=
name|sp2
expr_stmt|;
if|if
condition|(
name|last_shift
operator|==
name|sp
condition|)
name|last_shift
operator|=
name|sp2
expr_stmt|;
name|FREE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Create the next-to-final state, with shift to 		 what will be the final state.  */
name|insert_start_shift
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The initial state didn't even have any shifts. 	     Give it one shift, to the next-to-final state.  */
name|sp
operator|=
name|NEW
argument_list|(
name|shifts
argument_list|)
expr_stmt|;
name|sp
operator|->
name|nshifts
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|shifts
index|[
literal|0
index|]
operator|=
name|nstates
expr_stmt|;
comment|/* Patch sp into the chain of shifts at the beginning.  */
name|sp
operator|->
name|next
operator|=
name|first_shift
expr_stmt|;
name|first_shift
operator|=
name|sp
expr_stmt|;
comment|/* Create the next-to-final state, with shift to 	     what will be the final state.  */
name|insert_start_shift
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There are no shifts for any state. 	 Make one shift, from the initial state to the next-to-final state.  */
name|sp
operator|=
name|NEW
argument_list|(
name|shifts
argument_list|)
expr_stmt|;
name|sp
operator|->
name|nshifts
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|shifts
index|[
literal|0
index|]
operator|=
name|nstates
expr_stmt|;
comment|/* Initialize the chain of shifts with sp.  */
name|first_shift
operator|=
name|sp
expr_stmt|;
name|last_shift
operator|=
name|sp
expr_stmt|;
comment|/* Create the next-to-final state, with shift to 	 what will be the final state.  */
name|insert_start_shift
argument_list|()
expr_stmt|;
block|}
comment|/* Make the final state--the one that follows a shift from the      next-to-final state.      The symbol for that shift is 0 (end-of-file).  */
name|statep
operator|=
operator|(
name|core
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|core
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|statep
operator|->
name|number
operator|=
name|nstates
expr_stmt|;
name|last_state
operator|->
name|next
operator|=
name|statep
expr_stmt|;
name|last_state
operator|=
name|statep
expr_stmt|;
comment|/* Make the shift from the final state to the termination state.  */
name|sp
operator|=
name|NEW
argument_list|(
name|shifts
argument_list|)
expr_stmt|;
name|sp
operator|->
name|number
operator|=
name|nstates
operator|++
expr_stmt|;
name|sp
operator|->
name|nshifts
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|shifts
index|[
literal|0
index|]
operator|=
name|nstates
expr_stmt|;
name|last_shift
operator|->
name|next
operator|=
name|sp
expr_stmt|;
name|last_shift
operator|=
name|sp
expr_stmt|;
comment|/* Note that the variable `final_state' refers to what we sometimes call      the termination state.  */
name|final_state
operator|=
name|nstates
expr_stmt|;
comment|/* Make the termination state.  */
name|statep
operator|=
operator|(
name|core
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|core
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|statep
operator|->
name|number
operator|=
name|nstates
operator|++
expr_stmt|;
name|last_state
operator|->
name|next
operator|=
name|statep
expr_stmt|;
name|last_state
operator|=
name|statep
expr_stmt|;
block|}
end_function

begin_comment
comment|/* subroutine of augment_automaton.    Create the next-to-final state, to which a shift has already been made in    the initial state.  */
end_comment

begin_function
name|void
name|insert_start_shift
parameter_list|()
block|{
specifier|register
name|core
modifier|*
name|statep
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
name|statep
operator|=
operator|(
name|core
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|core
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|statep
operator|->
name|number
operator|=
name|nstates
expr_stmt|;
name|statep
operator|->
name|accessing_symbol
operator|=
name|start_symbol
expr_stmt|;
name|last_state
operator|->
name|next
operator|=
name|statep
expr_stmt|;
name|last_state
operator|=
name|statep
expr_stmt|;
comment|/* Make a shift from this state to (what will be) the final state.  */
name|sp
operator|=
name|NEW
argument_list|(
name|shifts
argument_list|)
expr_stmt|;
name|sp
operator|->
name|number
operator|=
name|nstates
operator|++
expr_stmt|;
name|sp
operator|->
name|nshifts
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|shifts
index|[
literal|0
index|]
operator|=
name|nstates
expr_stmt|;
name|last_shift
operator|->
name|next
operator|=
name|sp
expr_stmt|;
name|last_shift
operator|=
name|sp
expr_stmt|;
block|}
end_function

end_unit

