begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print information on generated parser, for bison,    Copyright (C) 1984, 1986, 1989 Free Software Foundation, Inc.  This file is part of Bison, the GNU Compiler Compiler.  Bison is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Bison is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bison; see the file COPYING.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|tags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nstates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|accessing_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|core
modifier|*
modifier|*
name|state_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|shifts
modifier|*
modifier|*
name|shift_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|errs
modifier|*
modifier|*
name|err_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|reductions
modifier|*
modifier|*
name|reduction_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|consistent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|any_conflicts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|conflicts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|final_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|conflict_log
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|verbose_conflict_log
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|print_reductions
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|terse
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|verbose
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_token
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_state
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_core
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_actions
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_grammar
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|terse
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|any_conflicts
condition|)
block|{
name|conflict_log
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|verbose
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|any_conflicts
condition|)
name|verbose_conflict_log
argument_list|()
expr_stmt|;
name|print_grammar
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
name|print_state
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_token
parameter_list|(
name|int
name|extnum
parameter_list|,
name|int
name|token
parameter_list|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|" type %d is %s\n"
argument_list|)
argument_list|,
name|extnum
argument_list|,
name|tags
index|[
name|token
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_state
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"\n\nstate %d\n\n"
argument_list|)
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|print_core
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|print_actions
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_core
parameter_list|(
name|int
name|state
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|rule
decl_stmt|;
specifier|register
name|core
modifier|*
name|statep
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp1
decl_stmt|;
name|statep
operator|=
name|state_table
index|[
name|state
index|]
expr_stmt|;
name|k
operator|=
name|statep
operator|->
name|nitems
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|sp1
operator|=
name|sp
operator|=
name|ritem
operator|+
name|statep
operator|->
name|items
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|>
literal|0
condition|)
name|sp
operator|++
expr_stmt|;
name|rule
operator|=
operator|-
operator|(
operator|*
name|sp
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"    %s  ->  "
argument_list|,
name|tags
index|[
name|rlhs
index|[
name|rule
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|ritem
operator|+
name|rrhs
index|[
name|rule
index|]
init|;
name|sp
operator|<
name|sp1
condition|;
name|sp
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%s "
argument_list|,
name|tags
index|[
operator|*
name|sp
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'.'
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|" %s"
argument_list|,
name|tags
index|[
operator|*
name|sp
index|]
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"   (rule %d)"
argument_list|)
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_actions
parameter_list|(
name|int
name|state
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|state1
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|shiftp
decl_stmt|;
specifier|register
name|errs
modifier|*
name|errp
decl_stmt|;
specifier|register
name|reductions
modifier|*
name|redp
decl_stmt|;
specifier|register
name|int
name|rule
decl_stmt|;
name|shiftp
operator|=
name|shift_table
index|[
name|state
index|]
expr_stmt|;
name|redp
operator|=
name|reduction_table
index|[
name|state
index|]
expr_stmt|;
name|errp
operator|=
name|err_table
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|shiftp
operator|&&
operator|!
name|redp
condition|)
block|{
if|if
condition|(
name|final_state
operator|==
name|state
condition|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    $default\taccept\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    NO ACTIONS\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|shiftp
condition|)
block|{
name|k
operator|=
name|shiftp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
condition|)
continue|continue;
name|state1
operator|=
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
expr_stmt|;
name|symbol
operator|=
name|accessing_symbol
index|[
name|state1
index|]
expr_stmt|;
comment|/* The following line used to be turned off.  */
if|if
condition|(
name|ISVAR
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
if|if
condition|(
name|symbol
operator|==
literal|0
condition|)
comment|/* I.e. strcmp(tags[symbol],"$")==0 */
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    $   \tgo to state %d\n"
argument_list|)
argument_list|,
name|state1
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    %-4s\tshift, and go to state %d\n"
argument_list|)
argument_list|,
name|tags
index|[
name|symbol
index|]
argument_list|,
name|state1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|errp
condition|)
block|{
name|int
name|j
decl_stmt|,
name|nerrs
decl_stmt|;
name|nerrs
operator|=
name|errp
operator|->
name|nerrs
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nerrs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|errp
operator|->
name|errs
index|[
name|j
index|]
condition|)
continue|continue;
name|symbol
operator|=
name|errp
operator|->
name|errs
index|[
name|j
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    %-4s\terror (nonassociative)\n"
argument_list|)
argument_list|,
name|tags
index|[
name|symbol
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|consistent
index|[
name|state
index|]
operator|&&
name|redp
condition|)
block|{
name|rule
operator|=
name|redp
operator|->
name|rules
index|[
literal|0
index|]
expr_stmt|;
name|symbol
operator|=
name|rlhs
index|[
name|rule
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    $default\treduce using rule %d (%s)\n\n"
argument_list|)
argument_list|,
name|rule
argument_list|,
name|tags
index|[
name|symbol
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|redp
condition|)
block|{
name|print_reductions
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|k
condition|)
block|{
for|for
control|(
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
condition|)
continue|continue;
name|state1
operator|=
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
expr_stmt|;
name|symbol
operator|=
name|accessing_symbol
index|[
name|state1
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"    %-4s\tgo to state %d\n"
argument_list|)
argument_list|,
name|tags
index|[
name|symbol
index|]
argument_list|,
name|state1
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|END_TEST
parameter_list|(
name|end
parameter_list|)
define|\
value|if (column + strlen(buffer)> (end))					 \     { fprintf (foutput, "%s\n   ", buffer); column = 3; buffer[0] = 0; } \   else
end_define

begin_function
name|void
name|print_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|short
modifier|*
name|rule
decl_stmt|;
name|char
name|buffer
index|[
literal|90
index|]
decl_stmt|;
name|int
name|column
init|=
literal|0
decl_stmt|;
comment|/* rule # : LHS -> RHS */
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\nGrammar\n"
argument_list|)
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrules
condition|;
name|i
operator|++
control|)
comment|/* Don't print rules disabled in reduce_grammar_tables.  */
if|if
condition|(
name|rlhs
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"rule %-4d %s ->"
argument_list|)
argument_list|,
name|i
argument_list|,
name|tags
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|rule
operator|=
operator|&
name|ritem
index|[
name|rrhs
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|rule
operator|>
literal|0
condition|)
while|while
condition|(
operator|*
name|rule
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|" %s"
argument_list|,
name|tags
index|[
operator|*
name|rule
operator|++
index|]
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|_
argument_list|(
literal|"		/* empty */"
argument_list|)
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
block|}
comment|/* TERMINAL (type #) : rule #s terminal is on RHS */
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\nTerminals, with rules where they appear\n\n"
argument_list|)
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%s (-1)\n"
argument_list|,
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|translations
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_user_token_number
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|token_translations
index|[
name|i
index|]
operator|!=
literal|2
condition|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|column
operator|=
name|strlen
argument_list|(
name|tags
index|[
name|token_translations
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%s"
argument_list|,
name|tags
index|[
name|token_translations
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|END_TEST
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|" (%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|nrules
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|rule
operator|=
operator|&
name|ritem
index|[
name|rrhs
index|[
name|j
index|]
index|]
init|;
operator|*
name|rule
operator|>
literal|0
condition|;
name|rule
operator|++
control|)
if|if
condition|(
operator|*
name|rule
operator|==
name|token_translations
index|[
name|i
index|]
condition|)
block|{
name|END_TEST
argument_list|(
literal|65
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|column
operator|=
name|strlen
argument_list|(
name|tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%s"
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|END_TEST
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|" (%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|nrules
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|rule
operator|=
operator|&
name|ritem
index|[
name|rrhs
index|[
name|j
index|]
index|]
init|;
operator|*
name|rule
operator|>
literal|0
condition|;
name|rule
operator|++
control|)
if|if
condition|(
operator|*
name|rule
operator|==
name|i
condition|)
block|{
name|END_TEST
argument_list|(
literal|65
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\nNonterminals, with rules where they appear\n\n"
argument_list|)
argument_list|,
name|foutput
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<=
name|nsyms
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|left_count
init|=
literal|0
decl_stmt|,
name|right_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|nrules
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rlhs
index|[
name|j
index|]
operator|==
name|i
condition|)
name|left_count
operator|++
expr_stmt|;
for|for
control|(
name|rule
operator|=
operator|&
name|ritem
index|[
name|rrhs
index|[
name|j
index|]
index|]
init|;
operator|*
name|rule
operator|>
literal|0
condition|;
name|rule
operator|++
control|)
if|if
condition|(
operator|*
name|rule
operator|==
name|i
condition|)
block|{
name|right_count
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%s"
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|column
operator|=
name|strlen
argument_list|(
name|tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|" (%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|END_TEST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|left_count
operator|>
literal|0
condition|)
block|{
name|END_TEST
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|_
argument_list|(
literal|" on left:"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|nrules
condition|;
name|j
operator|++
control|)
block|{
name|END_TEST
argument_list|(
literal|65
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlhs
index|[
name|j
index|]
operator|==
name|i
condition|)
name|sprintf
argument_list|(
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|right_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|left_count
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|END_TEST
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|_
argument_list|(
literal|" on right:"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|nrules
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|rule
operator|=
operator|&
name|ritem
index|[
name|rrhs
index|[
name|j
index|]
index|]
init|;
operator|*
name|rule
operator|>
literal|0
condition|;
name|rule
operator|++
control|)
if|if
condition|(
operator|*
name|rule
operator|==
name|i
condition|)
block|{
name|END_TEST
argument_list|(
literal|65
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

