begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Grammar reduction for Bison.    Copyright (C) 1988, 1989 Free Software Foundation, Inc.  This file is part of Bison, the GNU Compiler Compiler.  Bison is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Bison is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bison; see the file COPYING.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  * Reduce the grammar:  Find and eliminate unreachable terminals,  * nonterminals, and productions.  David S. Bakin.  */
end_comment

begin_comment
comment|/*  * Don't eliminate unreachable terminals:  They may be used by the user's  * parser.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reader.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|verboseflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* getargs.c */
end_comment

begin_decl_stmt
specifier|static
name|int
name|statisticsflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXXXXXX */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fixed_outfiles
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|(1)
end_define

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|int
name|bool
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
modifier|*
name|BSet
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|short
modifier|*
name|rule
typedef|;
end_typedef

begin_comment
comment|/*  * N is set of all nonterminals which are not useless.  P is set of all rules  * which have no useless nonterminals in their RHS.  V is the set of all  * accessible symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|BSet
name|N
decl_stmt|,
name|P
decl_stmt|,
name|V
decl_stmt|,
name|V1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nuseful_productions
decl_stmt|,
name|nuseless_productions
decl_stmt|,
name|nuseful_nonterminals
decl_stmt|,
name|nuseless_nonterminals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|bits_equal
name|PARAMS
argument_list|(
operator|(
name|BSet
operator|,
name|BSet
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nbits
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bits_size
name|PARAMS
argument_list|(
operator|(
name|BSet
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|reduce_grammar
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|useless_nonterminals
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|inaccessable_symbols
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reduce_grammar_tables
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_results
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_notices
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dump_grammar
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fatals
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|bool
name|bits_equal
parameter_list|(
name|BSet
name|L
parameter_list|,
name|BSet
name|R
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|L
index|[
name|i
index|]
operator|!=
name|R
index|[
name|i
index|]
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
name|nbits
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|i
operator|^=
operator|(
name|i
operator|&
operator|(
call|(
name|unsigned
call|)
argument_list|(
operator|-
operator|(
name|int
operator|)
name|i
argument_list|)
operator|)
operator|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
name|int
name|bits_size
parameter_list|(
name|BSet
name|S
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|count
operator|+=
name|nbits
argument_list|(
name|S
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|reduce_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|reduced
decl_stmt|;
comment|/* Allocate the global sets used to compute the reduced grammar */
name|N
operator|=
name|NEW2
argument_list|(
name|WORDSIZE
argument_list|(
name|nvars
argument_list|)
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|P
operator|=
name|NEW2
argument_list|(
name|WORDSIZE
argument_list|(
name|nrules
operator|+
literal|1
argument_list|)
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|V
operator|=
name|NEW2
argument_list|(
name|WORDSIZE
argument_list|(
name|nsyms
argument_list|)
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|V1
operator|=
name|NEW2
argument_list|(
name|WORDSIZE
argument_list|(
name|nsyms
argument_list|)
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|useless_nonterminals
argument_list|()
expr_stmt|;
name|inaccessable_symbols
argument_list|()
expr_stmt|;
name|reduced
operator|=
call|(
name|bool
call|)
argument_list|(
name|nuseless_nonterminals
operator|+
name|nuseless_productions
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verboseflag
condition|)
name|print_results
argument_list|()
expr_stmt|;
if|if
condition|(
name|reduced
operator|==
name|FALSE
condition|)
goto|goto
name|done_reducing
goto|;
name|print_notices
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|BITISSET
argument_list|(
name|N
argument_list|,
name|start_symbol
operator|-
name|ntokens
argument_list|)
condition|)
name|fatals
argument_list|(
name|_
argument_list|(
literal|"Start symbol %s does not derive any sentence"
argument_list|)
argument_list|,
name|tags
index|[
name|start_symbol
index|]
argument_list|)
expr_stmt|;
name|reduce_grammar_tables
argument_list|()
expr_stmt|;
comment|/* if (verboseflag) {      fprintf(foutput, "REDUCED GRAMMAR\n\n");      dump_grammar();      }      */
comment|/**/
name|statisticsflag
operator|=
name|FALSE
expr_stmt|;
comment|/* someday getopts should handle this */
if|if
condition|(
name|statisticsflag
operator|==
name|TRUE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"reduced %s defines %d terminal%s, %d nonterminal%s\ , and %d production%s.\n"
argument_list|)
argument_list|,
name|infile
argument_list|,
name|ntokens
argument_list|,
operator|(
name|ntokens
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|,
name|nvars
argument_list|,
operator|(
name|nvars
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|,
name|nrules
argument_list|,
operator|(
name|nrules
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
name|done_reducing
label|:
comment|/* Free the global sets used to compute the reduced grammar */
name|FREE
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|P
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Another way to do this would be with a set for each production and then do  * subset tests against N0, but even for the C grammar the whole reducing  * process takes only 2 seconds on my 8Mhz AT.  */
end_comment

begin_function
specifier|static
name|bool
name|useful_production
parameter_list|(
name|int
name|i
parameter_list|,
name|BSet
name|N0
parameter_list|)
block|{
name|rule
name|r
decl_stmt|;
name|short
name|n
decl_stmt|;
comment|/*    * A production is useful if all of the nonterminals in its RHS    * appear in the set of useful nonterminals.    */
for|for
control|(
name|r
operator|=
operator|&
name|ritem
index|[
name|rrhs
index|[
name|i
index|]
index|]
init|;
operator|*
name|r
operator|>
literal|0
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|ISVAR
argument_list|(
name|n
operator|=
operator|*
name|r
argument_list|)
condition|)
if|if
condition|(
operator|!
name|BITISSET
argument_list|(
name|N0
argument_list|,
name|n
operator|-
name|ntokens
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Remember that rules are 1-origin, symbols are 0-origin. */
end_comment

begin_function
specifier|static
name|void
name|useless_nonterminals
parameter_list|(
name|void
parameter_list|)
block|{
name|BSet
name|Np
decl_stmt|,
name|Ns
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/*    * N is set as built.  Np is set being built this iteration. P is set    * of all productions which have a RHS all in N.    */
name|Np
operator|=
name|NEW2
argument_list|(
name|WORDSIZE
argument_list|(
name|nvars
argument_list|)
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
comment|/*    * The set being computed is a set of nonterminals which can derive    * the empty string or strings consisting of all terminals. At each    * iteration a nonterminal is added to the set if there is a    * production with that nonterminal as its LHS for which all the    * nonterminals in its RHS are already in the set.  Iterate until the    * set being computed remains unchanged.  Any nonterminals not in the    * set at that point are useless in that they will never be used in    * deriving a sentence of the language.    *    * This iteration doesn't use any special traversal over the    * productions.  A set is kept of all productions for which all the    * nonterminals in the RHS are in useful.  Only productions not in    * this set are scanned on each iteration.  At the end, this set is    * saved to be used when finding useful productions: only productions    * in this set will appear in the final grammar.    */
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
name|WORDSIZE
argument_list|(
name|nvars
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|Np
index|[
name|i
index|]
operator|=
name|N
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrules
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|BITISSET
argument_list|(
name|P
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|useful_production
argument_list|(
name|i
argument_list|,
name|N
argument_list|)
condition|)
block|{
name|SETBIT
argument_list|(
name|Np
argument_list|,
name|rlhs
index|[
name|i
index|]
operator|-
name|ntokens
argument_list|)
expr_stmt|;
name|SETBIT
argument_list|(
name|P
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bits_equal
argument_list|(
name|N
argument_list|,
name|Np
argument_list|,
name|WORDSIZE
argument_list|(
name|nvars
argument_list|)
argument_list|)
condition|)
break|break;
name|Ns
operator|=
name|Np
expr_stmt|;
name|Np
operator|=
name|N
expr_stmt|;
name|N
operator|=
name|Ns
expr_stmt|;
block|}
name|FREE
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|N
operator|=
name|Np
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|inaccessable_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|BSet
name|Vp
decl_stmt|,
name|Vs
decl_stmt|,
name|Pp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|short
name|t
decl_stmt|;
name|rule
name|r
decl_stmt|;
comment|/*    * Find out which productions are reachable and which symbols are    * used.  Starting with an empty set of productions and a set of    * symbols which only has the start symbol in it, iterate over all    * productions until the set of productions remains unchanged for an    * iteration.  For each production which has a LHS in the set of    * reachable symbols, add the production to the set of reachable    * productions, and add all of the nonterminals in the RHS of the    * production to the set of reachable symbols.    *    * Consider only the (partially) reduced grammar which has only    * nonterminals in N and productions in P.    *    * The result is the set P of productions in the reduced grammar, and    * the set V of symbols in the reduced grammar.    *    * Although this algorithm also computes the set of terminals which are    * reachable, no terminal will be deleted from the grammar. Some    * terminals might not be in the grammar but might be generated by    * semantic routines, and so the user might want them available with    * specified numbers.  (Is this true?)  However, the nonreachable    * terminals are printed (if running in verbose mode) so that the user    * can know.    */
name|Vp
operator|=
name|NEW2
argument_list|(
name|WORDSIZE
argument_list|(
name|nsyms
argument_list|)
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|Pp
operator|=
name|NEW2
argument_list|(
name|WORDSIZE
argument_list|(
name|nrules
operator|+
literal|1
argument_list|)
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
comment|/* If the start symbol isn't useful, then nothing will be useful. */
if|if
condition|(
operator|!
name|BITISSET
argument_list|(
name|N
argument_list|,
name|start_symbol
operator|-
name|ntokens
argument_list|)
condition|)
goto|goto
name|end_iteration
goto|;
name|SETBIT
argument_list|(
name|V
argument_list|,
name|start_symbol
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
name|WORDSIZE
argument_list|(
name|nsyms
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|Vp
index|[
name|i
index|]
operator|=
name|V
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrules
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|BITISSET
argument_list|(
name|Pp
argument_list|,
name|i
argument_list|)
operator|&&
name|BITISSET
argument_list|(
name|P
argument_list|,
name|i
argument_list|)
operator|&&
name|BITISSET
argument_list|(
name|V
argument_list|,
name|rlhs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|r
operator|=
operator|&
name|ritem
index|[
name|rrhs
index|[
name|i
index|]
index|]
init|;
operator|*
name|r
operator|>=
literal|0
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|ISTOKEN
argument_list|(
name|t
operator|=
operator|*
name|r
argument_list|)
operator|||
name|BITISSET
argument_list|(
name|N
argument_list|,
name|t
operator|-
name|ntokens
argument_list|)
condition|)
block|{
name|SETBIT
argument_list|(
name|Vp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|SETBIT
argument_list|(
name|Pp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bits_equal
argument_list|(
name|V
argument_list|,
name|Vp
argument_list|,
name|WORDSIZE
argument_list|(
name|nsyms
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|Vs
operator|=
name|Vp
expr_stmt|;
name|Vp
operator|=
name|V
expr_stmt|;
name|V
operator|=
name|Vs
expr_stmt|;
block|}
name|end_iteration
label|:
name|FREE
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|V
operator|=
name|Vp
expr_stmt|;
comment|/* Tokens 0, 1, and 2 are internal to Bison.  Consider them useful. */
name|SETBIT
argument_list|(
name|V
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* end-of-input token */
name|SETBIT
argument_list|(
name|V
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* error token */
name|SETBIT
argument_list|(
name|V
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* some undefined token */
name|FREE
argument_list|(
name|P
argument_list|)
expr_stmt|;
name|P
operator|=
name|Pp
expr_stmt|;
name|nuseful_productions
operator|=
name|bits_size
argument_list|(
name|P
argument_list|,
name|WORDSIZE
argument_list|(
name|nrules
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|nuseless_productions
operator|=
name|nrules
operator|-
name|nuseful_productions
expr_stmt|;
name|nuseful_nonterminals
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BITISSET
argument_list|(
name|V
argument_list|,
name|i
argument_list|)
condition|)
name|nuseful_nonterminals
operator|++
expr_stmt|;
name|nuseless_nonterminals
operator|=
name|nvars
operator|-
name|nuseful_nonterminals
expr_stmt|;
comment|/* A token that was used in %prec should not be warned about.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nrules
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rprecsym
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|SETBIT
argument_list|(
name|V1
argument_list|,
name|rprecsym
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|reduce_grammar_tables
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This is turned off because we would need to change the numbers    in the case statements in the actions file.  */
if|#
directive|if
literal|0
comment|/* remove useless productions */
block|if (nuseless_productions> 0)     {       short np, pn, ni, pi;        np = 0;       ni = 0;       for (pn = 1; pn<= nrules; pn++) 	{ 	  if (BITISSET(P, pn)) 	    { 	      np++; 	      if (pn != np) 		{ 		  rlhs[np] = rlhs[pn]; 		  rline[np] = rline[pn]; 		  rprec[np] = rprec[pn]; 		  rassoc[np] = rassoc[pn]; 		  rrhs[np] = rrhs[pn]; 		  if (rrhs[np] != ni) 		    { 		      pi = rrhs[np]; 		      rrhs[np] = ni; 		      while (ritem[pi]>= 0) 			ritem[ni++] = ritem[pi++]; 		      ritem[ni++] = -np; 		    } 		} else { 		  while (ritem[ni++]>= 0); 		} 	    } 	}       ritem[ni] = 0;       nrules -= nuseless_productions;       nitems = ni;
comment|/*        * Is it worth it to reduce the amount of memory for the        * grammar? Probably not.        */
block|}
endif|#
directive|endif
comment|/* 0 */
comment|/* Disable useless productions,      since they may contain useless nonterms      that would get mapped below to -1 and confuse everyone.  */
if|if
condition|(
name|nuseless_productions
operator|>
literal|0
condition|)
block|{
name|int
name|pn
decl_stmt|;
for|for
control|(
name|pn
operator|=
literal|1
init|;
name|pn
operator|<=
name|nrules
condition|;
name|pn
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|BITISSET
argument_list|(
name|P
argument_list|,
name|pn
argument_list|)
condition|)
block|{
name|rlhs
index|[
name|pn
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* remove useless symbols */
if|if
condition|(
name|nuseless_nonterminals
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/*      short  j; JF unused */
name|short
modifier|*
name|nontermmap
decl_stmt|;
name|rule
name|r
decl_stmt|;
comment|/*        * create a map of nonterminal number to new nonterminal        * number. -1 in the map means it was useless and is being        * eliminated.        */
name|nontermmap
operator|=
name|NEW2
argument_list|(
name|nvars
argument_list|,
name|short
argument_list|)
operator|-
name|ntokens
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
name|nontermmap
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|n
operator|=
name|ntokens
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BITISSET
argument_list|(
name|V
argument_list|,
name|i
argument_list|)
condition|)
name|nontermmap
index|[
name|i
index|]
operator|=
name|n
operator|++
expr_stmt|;
comment|/* Shuffle elements of tables indexed by symbol number.  */
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
name|nontermmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|sassoc
index|[
name|n
index|]
operator|=
name|sassoc
index|[
name|i
index|]
expr_stmt|;
name|sprec
index|[
name|n
index|]
operator|=
name|sprec
index|[
name|i
index|]
expr_stmt|;
name|tags
index|[
name|n
index|]
operator|=
name|tags
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Replace all symbol numbers in valid data structures.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrules
condition|;
name|i
operator|++
control|)
block|{
comment|/* Ignore the rules disabled above.  */
if|if
condition|(
name|rlhs
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|rlhs
index|[
name|i
index|]
operator|=
name|nontermmap
index|[
name|rlhs
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
name|rprecsym
index|[
name|i
index|]
argument_list|)
condition|)
comment|/* Can this happen?  */
name|rprecsym
index|[
name|i
index|]
operator|=
name|nontermmap
index|[
name|rprecsym
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
name|ritem
init|;
operator|*
name|r
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|ISVAR
argument_list|(
operator|*
name|r
argument_list|)
condition|)
operator|*
name|r
operator|=
name|nontermmap
index|[
operator|*
name|r
index|]
expr_stmt|;
name|start_symbol
operator|=
name|nontermmap
index|[
name|start_symbol
index|]
expr_stmt|;
name|nsyms
operator|-=
name|nuseless_nonterminals
expr_stmt|;
name|nvars
operator|-=
name|nuseless_nonterminals
expr_stmt|;
name|free
argument_list|(
operator|&
name|nontermmap
index|[
name|ntokens
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_results
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/*  short j; JF unused */
name|rule
name|r
decl_stmt|;
name|bool
name|b
decl_stmt|;
if|if
condition|(
name|nuseless_nonterminals
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"Useless nonterminals:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|BITISSET
argument_list|(
name|V
argument_list|,
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"   %s\n"
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|BITISSET
argument_list|(
name|V
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|BITISSET
argument_list|(
name|V1
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"\n\nTerminals which are not used:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|TRUE
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"   %s\n"
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nuseless_productions
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"\n\nUseless rules:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrules
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|BITISSET
argument_list|(
name|P
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"#%-4d  "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%s :\t"
argument_list|,
name|tags
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
operator|&
name|ritem
index|[
name|rrhs
index|[
name|i
index|]
index|]
init|;
operator|*
name|r
operator|>=
literal|0
condition|;
name|r
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|" %s"
argument_list|,
name|tags
index|[
operator|*
name|r
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nuseless_nonterminals
operator|>
literal|0
operator|||
name|nuseless_productions
operator|>
literal|0
operator|||
name|b
condition|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|dump_grammar
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rule
name|r
decl_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"ntokens = %d, nvars = %d, nsyms = %d, nrules = %d, nitems = %d\n\n"
argument_list|,
name|ntokens
argument_list|,
name|nvars
argument_list|,
name|nsyms
argument_list|,
name|nrules
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"Variables\n---------\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"Value  Sprec    Sassoc    Tag\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%5d  %5d  %5d  %s\n"
argument_list|,
name|i
argument_list|,
name|sprec
index|[
name|i
index|]
argument_list|,
name|sassoc
index|[
name|i
index|]
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"Rules\n-----\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrules
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%-5d(%5d%5d)%5d : (@%-5d)"
argument_list|,
name|i
argument_list|,
name|rprec
index|[
name|i
index|]
argument_list|,
name|rassoc
index|[
name|i
index|]
argument_list|,
name|rlhs
index|[
name|i
index|]
argument_list|,
name|rrhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
operator|&
name|ritem
index|[
name|rrhs
index|[
name|i
index|]
index|]
init|;
operator|*
name|r
operator|>
literal|0
condition|;
name|r
operator|++
control|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%5d"
argument_list|,
operator|*
name|r
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|" [%d]\n"
argument_list|,
operator|-
operator|(
operator|*
name|r
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
name|_
argument_list|(
literal|"Rules interpreted\n-----------------\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrules
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"%-5d  %s :"
argument_list|,
name|i
argument_list|,
name|tags
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
operator|&
name|ritem
index|[
name|rrhs
index|[
name|i
index|]
index|]
init|;
operator|*
name|r
operator|>
literal|0
condition|;
name|r
operator|++
control|)
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|" %s"
argument_list|,
name|tags
index|[
operator|*
name|r
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|foutput
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_notices
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|fixed_outfiles
operator|&&
name|nuseless_productions
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%d rules never reduced\n"
argument_list|)
argument_list|,
name|nuseless_productions
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s contains "
argument_list|)
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|nuseless_nonterminals
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%d useless nonterminal%s"
argument_list|)
argument_list|,
name|nuseless_nonterminals
argument_list|,
operator|(
name|nuseless_nonterminals
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nuseless_nonterminals
operator|>
literal|0
operator|&&
name|nuseless_productions
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" and "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nuseless_productions
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%d useless rule%s"
argument_list|)
argument_list|,
name|nuseless_productions
argument_list|,
operator|(
name|nuseless_productions
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

