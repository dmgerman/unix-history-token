begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for bison    Copyright (C) 1984, 1989 Free Software Foundation, Inc.  This file is part of Bison, the GNU Compiler Compiler.  Bison is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Bison is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bison; see the file COPYING.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* subroutines of file LR0.c.  Entry points:    closure (items, n)  Given a vector of item numbers items, of length n, set up ruleset and itemset to indicate what rules could be run and which items could be accepted when those items are the active ones.  ruleset contains a bit for each rule.  closure sets the bits for all rules which could potentially describe the next input to be read.  itemset is a vector of item numbers; itemsetend points to just beyond the end  of the part of it that is significant. closure places there the indices of all items which represent units of input that could arrive next.    initialize_closure (n)  Allocates the itemset and ruleset vectors, and precomputes useful data so that closure can be called. n is the number of elements to allocate for itemset.    finalize_closure ()  Frees itemset, ruleset and internal data.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_decl_stmt
specifier|extern
name|short
modifier|*
modifier|*
name|derives
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|tags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|initialize_closure
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_fderives
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_firsts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|closure
name|PARAMS
argument_list|(
operator|(
name|short
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|finalize_closure
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|RTC
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|itemset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|itemsetend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|ruleset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal data.  See comments before set_fderives and set_firsts.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|fderives
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|firsts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of words required to hold a bit for each rule */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rulesetsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of words required to hold a bit for each variable */
end_comment

begin_decl_stmt
specifier|static
name|int
name|varsetsize
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|initialize_closure
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|itemset
operator|=
name|NEW2
argument_list|(
name|n
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|rulesetsize
operator|=
name|WORDSIZE
argument_list|(
name|nrules
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ruleset
operator|=
name|NEW2
argument_list|(
name|rulesetsize
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|set_fderives
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set fderives to an nvars by nrules matrix of bits    indicating which rules can help derive the beginning of the data    for each nonterminal.  For example, if symbol 5 can be derived as    the sequence of symbols 8 3 20, and one of the rules for deriving    symbol 8 is rule 4, then the [5 - ntokens, 4] bit in fderives is set.  */
end_comment

begin_function
name|void
name|set_fderives
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|unsigned
modifier|*
name|rrow
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|vrow
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|unsigned
name|cword
decl_stmt|;
specifier|register
name|short
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|b
decl_stmt|;
name|int
name|ruleno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fderives
operator|=
name|NEW2
argument_list|(
name|nvars
operator|*
name|rulesetsize
argument_list|,
name|unsigned
argument_list|)
operator|-
name|ntokens
operator|*
name|rulesetsize
expr_stmt|;
name|set_firsts
argument_list|()
expr_stmt|;
name|rrow
operator|=
name|fderives
operator|+
name|ntokens
operator|*
name|rulesetsize
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|vrow
operator|=
name|firsts
operator|+
operator|(
operator|(
name|i
operator|-
name|ntokens
operator|)
operator|*
name|varsetsize
operator|)
expr_stmt|;
name|cword
operator|=
operator|*
name|vrow
operator|++
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|ntokens
init|;
name|j
operator|<
name|nsyms
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cword
operator|&
operator|(
literal|1
operator|<<
name|b
operator|)
condition|)
block|{
name|rp
operator|=
name|derives
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|ruleno
operator|=
operator|*
name|rp
operator|++
operator|)
operator|>
literal|0
condition|)
block|{
name|SETBIT
argument_list|(
name|rrow
argument_list|,
name|ruleno
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|++
expr_stmt|;
if|if
condition|(
name|b
operator|>=
name|BITS_PER_WORD
operator|&&
name|j
operator|+
literal|1
operator|<
name|nsyms
condition|)
block|{
name|cword
operator|=
operator|*
name|vrow
operator|++
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|rrow
operator|+=
name|rulesetsize
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|print_fderives
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FREE
argument_list|(
name|firsts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set firsts to be an nvars by nvars bit matrix indicating which items    can represent the beginning of the input corresponding to which other items.    For example, if some rule expands symbol 5 into the sequence of symbols 8 3 20,    the symbol 8 can be the beginning of the data for symbol 5,    so the bit [8 - ntokens, 5 - ntokens] in firsts is set. */
end_comment

begin_function
name|void
name|set_firsts
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|unsigned
modifier|*
name|row
decl_stmt|;
comment|/*   register int done; JF unused */
specifier|register
name|int
name|symbol
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|rowsize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|varsetsize
operator|=
name|rowsize
operator|=
name|WORDSIZE
argument_list|(
name|nvars
argument_list|)
expr_stmt|;
name|firsts
operator|=
name|NEW2
argument_list|(
name|nvars
operator|*
name|rowsize
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|row
operator|=
name|firsts
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|derives
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|>=
literal|0
condition|)
block|{
name|symbol
operator|=
name|ritem
index|[
name|rrhs
index|[
operator|*
name|sp
operator|++
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|symbol
operator|-=
name|ntokens
expr_stmt|;
name|SETBIT
argument_list|(
name|row
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
block|}
name|row
operator|+=
name|rowsize
expr_stmt|;
block|}
name|RTC
argument_list|(
name|firsts
argument_list|,
name|nvars
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|print_firsts
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|closure
parameter_list|(
name|short
modifier|*
name|core
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|register
name|int
name|ruleno
decl_stmt|;
specifier|register
name|unsigned
name|word
decl_stmt|;
specifier|register
name|short
modifier|*
name|csp
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|dsp
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|rsp
decl_stmt|;
name|short
modifier|*
name|csend
decl_stmt|;
name|unsigned
modifier|*
name|rsend
decl_stmt|;
name|int
name|symbol
decl_stmt|;
name|int
name|itemno
decl_stmt|;
name|rsp
operator|=
name|ruleset
expr_stmt|;
name|rsend
operator|=
name|ruleset
operator|+
name|rulesetsize
expr_stmt|;
name|csend
operator|=
name|core
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|dsp
operator|=
name|fderives
operator|+
name|start_symbol
operator|*
name|rulesetsize
expr_stmt|;
while|while
condition|(
name|rsp
operator|<
name|rsend
condition|)
operator|*
name|rsp
operator|++
operator|=
operator|*
name|dsp
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|rsp
operator|<
name|rsend
condition|)
operator|*
name|rsp
operator|++
operator|=
literal|0
expr_stmt|;
name|csp
operator|=
name|core
expr_stmt|;
while|while
condition|(
name|csp
operator|<
name|csend
condition|)
block|{
name|symbol
operator|=
name|ritem
index|[
operator|*
name|csp
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|dsp
operator|=
name|fderives
operator|+
name|symbol
operator|*
name|rulesetsize
expr_stmt|;
name|rsp
operator|=
name|ruleset
expr_stmt|;
while|while
condition|(
name|rsp
operator|<
name|rsend
condition|)
operator|*
name|rsp
operator|++
operator||=
operator|*
name|dsp
operator|++
expr_stmt|;
block|}
block|}
block|}
name|ruleno
operator|=
literal|0
expr_stmt|;
name|itemsetend
operator|=
name|itemset
expr_stmt|;
name|csp
operator|=
name|core
expr_stmt|;
name|rsp
operator|=
name|ruleset
expr_stmt|;
while|while
condition|(
name|rsp
operator|<
name|rsend
condition|)
block|{
name|word
operator|=
operator|*
name|rsp
operator|++
expr_stmt|;
if|if
condition|(
name|word
operator|==
literal|0
condition|)
block|{
name|ruleno
operator|+=
name|BITS_PER_WORD
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|BITS_PER_WORD
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|word
operator|&
operator|(
literal|1
operator|<<
name|b
operator|)
condition|)
block|{
name|itemno
operator|=
name|rrhs
index|[
name|ruleno
index|]
expr_stmt|;
while|while
condition|(
name|csp
operator|<
name|csend
operator|&&
operator|*
name|csp
operator|<
name|itemno
condition|)
operator|*
name|itemsetend
operator|++
operator|=
operator|*
name|csp
operator|++
expr_stmt|;
operator|*
name|itemsetend
operator|++
operator|=
name|itemno
expr_stmt|;
block|}
name|ruleno
operator|++
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|csp
operator|<
name|csend
condition|)
operator|*
name|itemsetend
operator|++
operator|=
operator|*
name|csp
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|print_closure
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|finalize_closure
parameter_list|(
name|void
parameter_list|)
block|{
name|FREE
argument_list|(
name|itemset
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ruleset
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|fderives
operator|+
name|ntokens
operator|*
name|rulesetsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|print_closure
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|isp
decl_stmt|;
name|printf
argument_list|(
literal|"\n\nn = %d\n\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
name|itemset
init|;
name|isp
operator|<
name|itemsetend
condition|;
name|isp
operator|++
control|)
name|printf
argument_list|(
literal|"   %d\n"
argument_list|,
operator|*
name|isp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|print_firsts
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|rowp
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n\n\nFIRSTS\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n\n%s firsts\n\n"
argument_list|)
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rowp
operator|=
name|firsts
operator|+
operator|(
operator|(
name|i
operator|-
name|ntokens
operator|)
operator|*
name|varsetsize
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nvars
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|BITISSET
argument_list|(
name|rowp
argument_list|,
name|j
argument_list|)
condition|)
name|printf
argument_list|(
literal|"   %s\n"
argument_list|,
name|tags
index|[
name|j
operator|+
name|ntokens
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_fderives
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|rp
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n\n\nFDERIVES\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n\n%s derives\n\n"
argument_list|)
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rp
operator|=
name|fderives
operator|+
name|i
operator|*
name|rulesetsize
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nrules
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|BITISSET
argument_list|(
name|rp
argument_list|,
name|j
argument_list|)
condition|)
name|printf
argument_list|(
literal|"   %d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

