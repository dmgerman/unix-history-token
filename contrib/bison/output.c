begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output the generated parsing program for bison,    Copyright (C) 1984, 1986, 1989, 1992 Free Software Foundation, Inc.  This file is part of Bison, the GNU Compiler Compiler.  Bison is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Bison is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bison; see the file COPYING.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* functions to output parsing data to various files.  Entries are:    output_headers ()  Output constant strings to the beginning of certain files.    output_trailers()  Output constant strings to the ends of certain files.    output ()  Output the parsing tables and the parser code to ftable.  The parser tables consist of these tables. Starred ones needed only for the semantic parser. Double starred are output only if switches are set.  yytranslate = vector mapping yylex's token numbers into bison's token numbers.  ** yytname = vector of string-names indexed by bison token number  ** yytoknum = vector of yylex token numbers corresponding to entries in yytname  yyrline = vector of line-numbers of all rules.  For yydebug printouts.  yyrhs = vector of items of all rules.         This is exactly what ritems contains.  For yydebug and for semantic 	parser.  yyprhs[r] = index in yyrhs of first item for rule r.  yyr1[r] = symbol number of symbol that rule r derives.  yyr2[r] = number of symbols composing right hand side of rule r.  * yystos[s] = the symbol number of the symbol that leads to state s.  yydefact[s] = default rule to reduce with in state s, 	      when yytable doesn't specify something else to do. 	      Zero means the default is an error.  yydefgoto[i] = default state to go to after a reduction of a rule that 	       generates variable ntokens + i, except when yytable 	       specifies something else to do.  yypact[s] = index in yytable of the portion describing state s.             The lookahead token's type is used to index that portion             to find out what to do.  	    If the value in yytable is positive, 	    we shift the token and go to that state.  	    If the value is negative, it is minus a rule number to reduce by.  	    If the value is zero, the default action from yydefact[s] is used.  yypgoto[i] = the index in yytable of the portion describing               what to do after reducing a rule that derives variable i + ntokens.              This portion is indexed by the parser state number, s, 	     as of before the text for this nonterminal was read. 	     The value from yytable is the state to go to if               the corresponding value in yycheck is s.  yytable = a vector filled with portions for different uses,           found via yypact and yypgoto.  yycheck = a vector indexed in parallel with yytable. 	  It indicates, in a roundabout way, the bounds of the 	  portion you are trying to examine.  	  Suppose that the portion of yytable starts at index p 	  and the index to be examined within the portion is i. 	  Then if yycheck[p+i] != i, i is outside the bounds 	  of what is actually allocated, and the default 	  (from yydefact or yydefgoto) should be used. 	  Otherwise, yytable[p+i] should be used.  YYFINAL = the state number of the termination state. YYFLAG = most negative short int.  Used to flag ?? YYNTBASE = ntokens.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|debugflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nolinesflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|noparserflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|toknumflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|tags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|user_toknums
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tokensetsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|final_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|core
modifier|*
modifier|*
name|state_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|shifts
modifier|*
modifier|*
name|shift_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|errs
modifier|*
modifier|*
name|err_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|reductions
modifier|*
modifier|*
name|reduction_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|accessing_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
modifier|*
name|LA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|LAruleno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|lookaheads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|consistent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|goto_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|from_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|to_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_headers
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_trailers
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_token_translations
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_gram
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_stos
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_rule_data
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_defines
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_actions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|token_actions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|save_row
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|goto_actions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|save_column
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sort_actions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pack_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_base
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_check
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_parser
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_program
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|free_shifts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|free_reductions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|free_itemsets
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|action_row
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_goto
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|matching_state
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pack_vector
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|berror
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fatals
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|int_to_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|reader_output_yylsp
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nvectors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nentries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|froms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|tos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|tally
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|actrow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|state_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|order
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lowzero
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|high
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GUARDSTR
value|"\n#include \"%s\"\nextern int yyerror;\n\ extern int yycost;\nextern char * yymsg;\nextern YYSTYPE yyval;\n\n\ yyguard(n, yyvsp, yylsp)\nregister int n;\nregister YYSTYPE *yyvsp;\n\ register YYLTYPE *yylsp;\n\ {\n  yyerror = 0;\nyycost = 0;\n  yymsg = 0;\nswitch (n)\n    {"
end_define

begin_define
define|#
directive|define
name|ACTSTR
value|"\n#include \"%s\"\nextern YYSTYPE yyval;\ \nextern int yychar;\ yyaction(n, yyvsp, yylsp)\nregister int n;\nregister YYSTYPE *yyvsp;\n\ register YYLTYPE *yylsp;\n{\n  switch (n)\n{"
end_define

begin_define
define|#
directive|define
name|ACTSTR_SIMPLE
value|"\n  switch (yyn) {\n"
end_define

begin_function
name|void
name|output_headers
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|semantic_parser
condition|)
name|fprintf
argument_list|(
name|fguard
argument_list|,
name|GUARDSTR
argument_list|,
name|attrsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|noparserflag
condition|)
return|return;
name|fprintf
argument_list|(
name|faction
argument_list|,
operator|(
name|semantic_parser
condition|?
name|ACTSTR
else|:
name|ACTSTR_SIMPLE
operator|)
argument_list|,
name|attrsfile
argument_list|)
expr_stmt|;
comment|/*  if (semantic_parser)	JF moved this below     fprintf(ftable, "#include \"%s\"\n", attrsfile);   fprintf(ftable, "#include<stdio.h>\n\n"); */
comment|/* Rename certain symbols if -p was specified.  */
if|if
condition|(
name|spec_name_prefix
condition|)
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define yyparse %sparse\n"
argument_list|,
name|spec_name_prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define yylex %slex\n"
argument_list|,
name|spec_name_prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define yyerror %serror\n"
argument_list|,
name|spec_name_prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define yylval %slval\n"
argument_list|,
name|spec_name_prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define yychar %schar\n"
argument_list|,
name|spec_name_prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define yydebug %sdebug\n"
argument_list|,
name|spec_name_prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define yynerrs %snerrs\n"
argument_list|,
name|spec_name_prefix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|output_trailers
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|semantic_parser
condition|)
name|fprintf
argument_list|(
name|fguard
argument_list|,
literal|"\n    }\n}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noparserflag
condition|)
return|return;
if|if
condition|(
name|semantic_parser
condition|)
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|"    }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
comment|/* output_token_defines(ftable);	/ * JF put out token defines FIRST */
if|if
condition|(
operator|!
name|semantic_parser
condition|)
comment|/* JF Put out other stuff */
block|{
name|rewind
argument_list|(
name|fattrs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fattrs
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
block|}
name|reader_output_yylsp
argument_list|(
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflag
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#ifndef YYDEBUG\n#define YYDEBUG %d\n#endif\n\n"
argument_list|,
operator|!
operator|!
name|debugflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|semantic_parser
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|attrsfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noparserflag
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#include<stdio.h>\n\n"
argument_list|)
expr_stmt|;
comment|/* Make "const" do nothing if not in ANSI C.  */
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#ifndef __cplusplus\n#ifndef __STDC__\n#define const\n#endif\n#endif\n\n"
argument_list|)
expr_stmt|;
name|free_itemsets
argument_list|()
expr_stmt|;
name|output_defines
argument_list|()
expr_stmt|;
name|output_token_translations
argument_list|()
expr_stmt|;
comment|/*   if (semantic_parser) */
comment|/* This is now unconditional because debugging printouts can use it.  */
name|output_gram
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|ritem
argument_list|)
expr_stmt|;
if|if
condition|(
name|semantic_parser
condition|)
name|output_stos
argument_list|()
expr_stmt|;
name|output_rule_data
argument_list|()
expr_stmt|;
name|output_actions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|noparserflag
condition|)
name|output_parser
argument_list|()
expr_stmt|;
name|output_program
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_token_translations
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/*   register short *sp; JF unused */
if|if
condition|(
name|translations
condition|)
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n#define YYTRANSLATE(x) ((unsigned)(x)<= %d ? yytranslate[x] : %d)\n"
argument_list|,
name|max_user_token_number
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntokens
operator|<
literal|127
condition|)
comment|/* play it very safe; check maximum element value.  */
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\nstatic const char yytranslate[] = {     0"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\nstatic const short yytranslate[] = {     0"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|max_user_token_number
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|token_translations
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n#define YYTRANSLATE(x) (x)\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|output_gram
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
comment|/* With the ordinary parser,       yyprhs and yyrhs are needed only for yydebug. */
comment|/* With the noparser option, all tables are generated */
if|if
condition|(
operator|!
name|semantic_parser
operator|&&
operator|!
name|noparserflag
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n#if YYDEBUG != 0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\nstatic const short yyprhs[] = {     0"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrules
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|rrhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\nstatic const short yyrhs[] = {%6d"
argument_list|,
name|ritem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|ritem
operator|+
literal|1
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sp
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"     0"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|semantic_parser
operator|&&
operator|!
name|noparserflag
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n#endif\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_stos
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\nstatic const short yystos[] = {     0"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|accessing_symbol
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_rule_data
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n#if YYDEBUG != 0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"static const short yyrline[] = { 0"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrules
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|rline
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n#endif\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|toknumflag
operator|||
name|noparserflag
condition|)
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define YYNTOKENS %d\n"
argument_list|,
name|ntokens
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define YYNNTS %d\n"
argument_list|,
name|nvars
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define YYNRULES %d\n"
argument_list|,
name|nrules
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define YYNSTATES %d\n"
argument_list|,
name|nstates
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define YYMAXUTOK %d\n\n"
argument_list|,
name|max_user_token_number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|toknumflag
operator|&&
operator|!
name|noparserflag
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)\n\n"
argument_list|)
expr_stmt|;
comment|/* Output the table of symbol names.  */
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"static const char * const yytname[] = {   \"%s\""
argument_list|,
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
operator|+
literal|44
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
comment|/* this used to be i<=nsyms, but that output a final "" symbol 			almost by accident */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|75
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\"'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tags
index|[
name|i
index|]
init|;
name|p
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
operator|||
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\\%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
condition|)
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\b'
condition|)
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\\b"
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|<
literal|040
operator|||
operator|*
name|p
operator|>=
literal|0177
condition|)
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\\%03o"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|putc
argument_list|(
literal|'\"'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|", NULL\n};\n"
argument_list|)
expr_stmt|;
comment|/* add a NULL entry to list of tokens */
if|if
condition|(
operator|!
name|toknumflag
operator|&&
operator|!
name|noparserflag
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|toknumflag
condition|)
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"static const short yytoknum[] = { 0"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|j
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|user_toknums
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"static const short yyr1[] = {     0"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrules
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|rlhs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|rlhs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n\nstatic const short yyr2[] = {     0"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nrules
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|rrhs
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|rrhs
index|[
name|i
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d\n};\n"
argument_list|,
name|nitems
operator|-
name|rrhs
index|[
name|nrules
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|rrhs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_defines
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n\n#define\tYYFINAL\t\t%d\n"
argument_list|,
name|final_state
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define\tYYFLAG\t\t%d\n"
argument_list|,
name|MINSHORT
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define\tYYNTBASE\t%d\n"
argument_list|,
name|ntokens
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* compute and output yydefact, yydefgoto, yypact, yypgoto, yytable and yycheck.  */
end_comment

begin_function
name|void
name|output_actions
parameter_list|(
name|void
parameter_list|)
block|{
name|nvectors
operator|=
name|nstates
operator|+
name|nvars
expr_stmt|;
name|froms
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|tos
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|tally
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|width
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|token_actions
argument_list|()
expr_stmt|;
name|free_shifts
argument_list|()
expr_stmt|;
name|free_reductions
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|lookaheads
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|LA
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|LAruleno
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|accessing_symbol
argument_list|)
expr_stmt|;
name|goto_actions
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|goto_map
operator|+
name|ntokens
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|from_state
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|to_state
argument_list|)
expr_stmt|;
name|sort_actions
argument_list|()
expr_stmt|;
name|pack_table
argument_list|()
expr_stmt|;
name|output_base
argument_list|()
expr_stmt|;
name|output_table
argument_list|()
expr_stmt|;
name|output_check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* figure out the actions for the specified state, indexed by lookahead token type.     The yydefact table is output now.  The detailed info    is saved for putting into yytable later.  */
end_comment

begin_function
name|void
name|token_actions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|actrow
operator|=
name|NEW2
argument_list|(
name|ntokens
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|k
operator|=
name|action_row
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\nstatic const short yydefact[] = {%6d"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|save_row
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|k
operator|=
name|action_row
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|save_row
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|actrow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide what to do for each type of token if seen as the lookahead token in specified state.    The value returned is used as the default action (yydefact) for the state.    In addition, actrow is filled with what to do for each kind of token,    index by symbol number, with zero meaning do the default action.    The value MINSHORT, a very negative number, means this situation    is an error.  The parser recognizes this value specially.     This is where conflicts are resolved.  The loop over lookahead rules    considered lower-numbered rules last, and the last rule considered that likes    a token gets to handle it.  */
end_comment

begin_function
name|int
name|action_row
parameter_list|(
name|int
name|state
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|m
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|default_rule
decl_stmt|;
specifier|register
name|int
name|nreds
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|;
specifier|register
name|int
name|rule
decl_stmt|;
specifier|register
name|int
name|shift_state
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
specifier|register
name|unsigned
name|mask
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|wordp
decl_stmt|;
specifier|register
name|reductions
modifier|*
name|redp
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|shiftp
decl_stmt|;
specifier|register
name|errs
modifier|*
name|errp
decl_stmt|;
name|int
name|nodefault
init|=
literal|0
decl_stmt|;
comment|/* set nonzero to inhibit having any default reduction */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
name|actrow
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|default_rule
operator|=
literal|0
expr_stmt|;
name|nreds
operator|=
literal|0
expr_stmt|;
name|redp
operator|=
name|reduction_table
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|redp
condition|)
block|{
name|nreds
operator|=
name|redp
operator|->
name|nreds
expr_stmt|;
if|if
condition|(
name|nreds
operator|>=
literal|1
condition|)
block|{
comment|/* loop over all the rules available here which require lookahead */
name|m
operator|=
name|lookaheads
index|[
name|state
index|]
expr_stmt|;
name|n
operator|=
name|lookaheads
index|[
name|state
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
name|m
condition|;
name|i
operator|--
control|)
block|{
name|rule
operator|=
operator|-
name|LAruleno
index|[
name|i
index|]
expr_stmt|;
name|wordp
operator|=
name|LA
operator|+
name|i
operator|*
name|tokensetsize
expr_stmt|;
name|mask
operator|=
literal|1
expr_stmt|;
comment|/* and find each token which the rule finds acceptable to come next */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntokens
condition|;
name|j
operator|++
control|)
block|{
comment|/* and record this rule as the rule to use if that token follows.  */
if|if
condition|(
name|mask
operator|&
operator|*
name|wordp
condition|)
name|actrow
index|[
name|j
index|]
operator|=
name|rule
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
literal|1
expr_stmt|;
name|wordp
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|shiftp
operator|=
name|shift_table
index|[
name|state
index|]
expr_stmt|;
comment|/* now see which tokens are allowed for shifts in this state.      For them, record the shift as the thing to do.  So shift is preferred to reduce.  */
if|if
condition|(
name|shiftp
condition|)
block|{
name|k
operator|=
name|shiftp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|shift_state
operator|=
name|shiftp
operator|->
name|shifts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|shift_state
condition|)
continue|continue;
name|symbol
operator|=
name|accessing_symbol
index|[
name|shift_state
index|]
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
name|actrow
index|[
name|symbol
index|]
operator|=
name|shift_state
expr_stmt|;
comment|/* do not use any default reduction if there is a shift for error */
if|if
condition|(
name|symbol
operator|==
name|error_token_number
condition|)
name|nodefault
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|errp
operator|=
name|err_table
index|[
name|state
index|]
expr_stmt|;
comment|/* See which tokens are an explicit error in this state      (due to %nonassoc).  For them, record MINSHORT as the action.  */
if|if
condition|(
name|errp
condition|)
block|{
name|k
operator|=
name|errp
operator|->
name|nerrs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|symbol
operator|=
name|errp
operator|->
name|errs
index|[
name|i
index|]
expr_stmt|;
name|actrow
index|[
name|symbol
index|]
operator|=
name|MINSHORT
expr_stmt|;
block|}
block|}
comment|/* now find the most common reduction and make it the default action for this state.  */
if|if
condition|(
name|nreds
operator|>=
literal|1
operator|&&
operator|!
name|nodefault
condition|)
block|{
if|if
condition|(
name|consistent
index|[
name|state
index|]
condition|)
name|default_rule
operator|=
name|redp
operator|->
name|rules
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|rule
operator|=
operator|-
name|LAruleno
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntokens
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|actrow
index|[
name|j
index|]
operator|==
name|rule
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|count
expr_stmt|;
name|default_rule
operator|=
name|rule
expr_stmt|;
block|}
block|}
comment|/* actions which match the default are replaced with zero, 	     which means "use the default" */
if|if
condition|(
name|max
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntokens
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|actrow
index|[
name|j
index|]
operator|==
name|default_rule
condition|)
name|actrow
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|default_rule
operator|=
operator|-
name|default_rule
expr_stmt|;
block|}
block|}
block|}
comment|/* If have no default rule, the default is an error.      So replace any action which says "error" with "use default".  */
if|if
condition|(
name|default_rule
operator|==
literal|0
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntokens
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|actrow
index|[
name|j
index|]
operator|==
name|MINSHORT
condition|)
name|actrow
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|default_rule
operator|)
return|;
block|}
end_function

begin_function
name|void
name|save_row
parameter_list|(
name|int
name|state
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp1
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp2
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|actrow
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|froms
index|[
name|state
index|]
operator|=
name|sp1
operator|=
name|sp
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|tos
index|[
name|state
index|]
operator|=
name|sp2
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|actrow
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
operator|*
name|sp1
operator|++
operator|=
name|i
expr_stmt|;
operator|*
name|sp2
operator|++
operator|=
name|actrow
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|tally
index|[
name|state
index|]
operator|=
name|count
expr_stmt|;
name|width
index|[
name|state
index|]
operator|=
name|sp1
index|[
operator|-
literal|1
index|]
operator|-
name|sp
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* figure out what to do after reducing with each rule,    depending on the saved state from before the beginning    of parsing the data that matched this rule.     The yydefgoto table is output now.  The detailed info    is saved for putting into yytable later.  */
end_comment

begin_function
name|void
name|goto_actions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|state_count
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|k
operator|=
name|default_goto
argument_list|(
name|ntokens
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\nstatic const short yydefgoto[] = {%6d"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|save_column
argument_list|(
name|ntokens
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
operator|+
literal|1
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|k
operator|=
name|default_goto
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|save_column
argument_list|(
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|state_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|default_goto
parameter_list|(
name|int
name|symbol
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|default_state
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|;
name|m
operator|=
name|goto_map
index|[
name|symbol
index|]
expr_stmt|;
name|n
operator|=
name|goto_map
index|[
name|symbol
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|n
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
name|state_count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|state_count
index|[
name|to_state
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
name|default_state
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|state_count
index|[
name|i
index|]
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|state_count
index|[
name|i
index|]
expr_stmt|;
name|default_state
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
operator|(
name|default_state
operator|)
return|;
block|}
end_function

begin_function
name|void
name|save_column
parameter_list|(
name|int
name|symbol
parameter_list|,
name|int
name|default_state
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp1
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp2
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|symno
decl_stmt|;
name|m
operator|=
name|goto_map
index|[
name|symbol
index|]
expr_stmt|;
name|n
operator|=
name|goto_map
index|[
name|symbol
operator|+
literal|1
index|]
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|to_state
index|[
name|i
index|]
operator|!=
name|default_state
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|symno
operator|=
name|symbol
operator|-
name|ntokens
operator|+
name|nstates
expr_stmt|;
name|froms
index|[
name|symno
index|]
operator|=
name|sp1
operator|=
name|sp
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|tos
index|[
name|symno
index|]
operator|=
name|sp2
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|to_state
index|[
name|i
index|]
operator|!=
name|default_state
condition|)
block|{
operator|*
name|sp1
operator|++
operator|=
name|from_state
index|[
name|i
index|]
expr_stmt|;
operator|*
name|sp2
operator|++
operator|=
name|to_state
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|tally
index|[
name|symno
index|]
operator|=
name|count
expr_stmt|;
name|width
index|[
name|symno
index|]
operator|=
name|sp1
index|[
operator|-
literal|1
index|]
operator|-
name|sp
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* the next few functions decide how to pack     the actions and gotos information into yytable. */
end_comment

begin_function
name|void
name|sort_actions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|int
name|w
decl_stmt|;
name|order
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|nentries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvectors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tally
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|t
operator|=
name|tally
index|[
name|i
index|]
expr_stmt|;
name|w
operator|=
name|width
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|nentries
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
operator|&&
operator|(
name|width
index|[
name|order
index|[
name|j
index|]
index|]
operator|<
name|w
operator|)
condition|)
name|j
operator|--
expr_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
operator|&&
operator|(
name|width
index|[
name|order
index|[
name|j
index|]
index|]
operator|==
name|w
operator|)
operator|&&
operator|(
name|tally
index|[
name|order
index|[
name|j
index|]
index|]
operator|<
name|t
operator|)
condition|)
name|j
operator|--
expr_stmt|;
for|for
control|(
name|k
operator|=
name|nentries
operator|-
literal|1
init|;
name|k
operator|>
name|j
condition|;
name|k
operator|--
control|)
name|order
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|order
index|[
name|k
index|]
expr_stmt|;
name|order
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|nentries
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|pack_table
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|place
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
name|base
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|pos
operator|=
name|NEW2
argument_list|(
name|nentries
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|table
operator|=
name|NEW2
argument_list|(
name|MAXTABLE
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|check
operator|=
name|NEW2
argument_list|(
name|MAXTABLE
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|lowzero
operator|=
literal|0
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvectors
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|=
name|MINSHORT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXTABLE
condition|;
name|i
operator|++
control|)
name|check
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|state
operator|=
name|matching_state
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|<
literal|0
condition|)
name|place
operator|=
name|pack_vector
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|place
operator|=
name|base
index|[
name|state
index|]
expr_stmt|;
name|pos
index|[
name|i
index|]
operator|=
name|place
expr_stmt|;
name|base
index|[
name|order
index|[
name|i
index|]
index|]
operator|=
name|place
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvectors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|froms
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|froms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tos
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|tos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|froms
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|tos
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|matching_state
parameter_list|(
name|int
name|vector
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|int
name|w
decl_stmt|;
specifier|register
name|int
name|match
decl_stmt|;
specifier|register
name|int
name|prev
decl_stmt|;
name|i
operator|=
name|order
index|[
name|vector
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|nstates
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|t
operator|=
name|tally
index|[
name|i
index|]
expr_stmt|;
name|w
operator|=
name|width
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|vector
operator|-
literal|1
init|;
name|prev
operator|>=
literal|0
condition|;
name|prev
operator|--
control|)
block|{
name|j
operator|=
name|order
index|[
name|prev
index|]
expr_stmt|;
if|if
condition|(
name|width
index|[
name|j
index|]
operator|!=
name|w
operator|||
name|tally
index|[
name|j
index|]
operator|!=
name|t
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|match
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|match
operator|&&
name|k
operator|<
name|t
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|tos
index|[
name|j
index|]
index|[
name|k
index|]
operator|!=
name|tos
index|[
name|i
index|]
index|[
name|k
index|]
operator|||
name|froms
index|[
name|j
index|]
index|[
name|k
index|]
operator|!=
name|froms
index|[
name|i
index|]
index|[
name|k
index|]
condition|)
name|match
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
return|return
operator|(
name|j
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pack_vector
parameter_list|(
name|int
name|vector
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|int
name|loc
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|ok
decl_stmt|;
specifier|register
name|short
modifier|*
name|from
decl_stmt|;
specifier|register
name|short
modifier|*
name|to
decl_stmt|;
name|i
operator|=
name|order
index|[
name|vector
index|]
expr_stmt|;
name|t
operator|=
name|tally
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|berror
argument_list|(
literal|"pack_vector"
argument_list|)
expr_stmt|;
name|from
operator|=
name|froms
index|[
name|i
index|]
expr_stmt|;
name|to
operator|=
name|tos
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|lowzero
operator|-
name|from
index|[
literal|0
index|]
init|;
name|j
operator|<
name|MAXTABLE
condition|;
name|j
operator|++
control|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|ok
operator|&&
name|k
operator|<
name|t
condition|;
name|k
operator|++
control|)
block|{
name|loc
operator|=
name|j
operator|+
name|from
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|loc
operator|>
name|MAXTABLE
condition|)
name|fatals
argument_list|(
name|_
argument_list|(
literal|"maximum table size (%s) exceeded"
argument_list|)
argument_list|,
name|int_to_string
argument_list|(
name|MAXTABLE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
index|[
name|loc
index|]
operator|!=
literal|0
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|ok
operator|&&
name|k
operator|<
name|vector
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|pos
index|[
name|k
index|]
operator|==
name|j
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|t
condition|;
name|k
operator|++
control|)
block|{
name|loc
operator|=
name|j
operator|+
name|from
index|[
name|k
index|]
expr_stmt|;
name|table
index|[
name|loc
index|]
operator|=
name|to
index|[
name|k
index|]
expr_stmt|;
name|check
index|[
name|loc
index|]
operator|=
name|from
index|[
name|k
index|]
expr_stmt|;
block|}
while|while
condition|(
name|table
index|[
name|lowzero
index|]
operator|!=
literal|0
condition|)
name|lowzero
operator|++
expr_stmt|;
if|if
condition|(
name|loc
operator|>
name|high
condition|)
name|high
operator|=
name|loc
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
block|}
name|berror
argument_list|(
literal|"pack_vector"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* JF keep lint happy */
block|}
end_function

begin_comment
comment|/* the following functions output yytable, yycheck    and the vectors whose elements index the portion starts */
end_comment

begin_function
name|void
name|output_base
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\nstatic const short yypact[] = {%6d"
argument_list|,
name|base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n\nstatic const short yypgoto[] = {%6d"
argument_list|,
name|base
index|[
name|nstates
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nstates
operator|+
literal|1
init|;
name|i
operator|<
name|nvectors
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_table
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n\n#define\tYYLAST\t\t%d\n\n"
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\nstatic const short yytable[] = {%6d"
argument_list|,
name|table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|high
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_check
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\nstatic const short yycheck[] = {%6d"
argument_list|,
name|check
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|high
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"%6d"
argument_list|,
name|check
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n};\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|check
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy the parser code into the ftable file at the end.  */
end_comment

begin_function
name|void
name|output_parser
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|DONTDEF
name|FILE
modifier|*
name|fpars
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|fpars
value|fparser
endif|#
directive|endif
if|if
condition|(
name|pure_parser
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define YYPURE 1\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DONTDEF
comment|/* JF no longer needed 'cuz open_extra_files changes the 		   currently open parser from bison.simple to bison.hairy */
if|if
condition|(
name|semantic_parser
condition|)
name|fpars
operator|=
name|fparser
expr_stmt|;
else|else
name|fpars
operator|=
name|fparser1
expr_stmt|;
endif|#
directive|endif
comment|/* Loop over lines in the standard parser file.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|write_line
init|=
literal|1
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fpars
argument_list|)
expr_stmt|;
comment|/* See if the line starts with `#line. 	 If so, set write_line to 0.  */
if|if
condition|(
name|nolinesflag
condition|)
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fpars
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fpars
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fpars
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fpars
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'e'
condition|)
name|write_line
operator|=
literal|0
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#lin"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#li"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#l"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#"
argument_list|)
expr_stmt|;
block|}
comment|/* now write out the line... */
for|for
control|(
init|;
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|;
name|c
operator|=
name|getc
argument_list|(
name|fpars
argument_list|)
control|)
if|if
condition|(
name|write_line
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
comment|/* `$' in the parser file indicates where to put the actions. 		 Copy them in at this point.  */
name|rewind
argument_list|(
name|faction
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|getc
argument_list|(
name|faction
argument_list|)
init|;
name|c
operator|!=
name|EOF
condition|;
name|c
operator|=
name|getc
argument_list|(
name|faction
argument_list|)
control|)
name|putc
argument_list|(
name|c
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|putc
argument_list|(
name|c
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|output_program
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|nolinesflag
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#line %d \"%s\"\n"
argument_list|,
name|lineno
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|ftable
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|free_itemsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|core
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cptmp
decl_stmt|;
name|FREE
argument_list|(
name|state_table
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|first_state
init|;
name|cp
condition|;
name|cp
operator|=
name|cptmp
control|)
block|{
name|cptmp
operator|=
name|cp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|free_shifts
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|,
modifier|*
name|sptmp
decl_stmt|;
comment|/* JF derefrenced freed ptr */
name|FREE
argument_list|(
name|shift_table
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_shift
init|;
name|sp
condition|;
name|sp
operator|=
name|sptmp
control|)
block|{
name|sptmp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|free_reductions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|reductions
modifier|*
name|rp
decl_stmt|,
modifier|*
name|rptmp
decl_stmt|;
comment|/* JF fixed freed ptr */
name|FREE
argument_list|(
name|reduction_table
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|first_reduction
init|;
name|rp
condition|;
name|rp
operator|=
name|rptmp
control|)
block|{
name|rptmp
operator|=
name|rp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

