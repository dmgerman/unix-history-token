begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Input parser for bison    Copyright (C) 1984, 1986, 1989, 1992, 1998 Free Software Foundation, Inc.  This file is part of Bison, the GNU Compiler Compiler.  Bison is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Bison is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bison; see the file COPYING.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* read in the grammar specification and record it in the format described in gram.h.   All guards are copied into the fguard file and all actions into faction,   in each case forming the body of a C function (yyguard or yyaction)   which contains a switch statement to decide which guard or action to execute.  The entry point is reader().  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_define
define|#
directive|define
name|LTYPESTR
value|"\n#ifndef YYLTYPE\ntypedef\n  struct yyltype\n\     {\n      int timestamp;\n      int first_line;\n      int first_column;\ \n      int last_line;\n      int last_column;\n      char *text;\n   }\n\   yyltype;\n\n#define YYLTYPE yyltype\n#endif\n\n"
end_define

begin_comment
comment|/* Number of slots allocated (but not necessarily used yet) in `rline'  */
end_comment

begin_decl_stmt
name|int
name|rline_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|definesflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nolinesflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|noparserflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rawtoknumflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bucket
modifier|*
name|symval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|numval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|expected_conflicts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|token_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maxtoken
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|init_lex
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|grow_token_buffer
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|tabinit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|output_headers
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|output_trailers
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|free_symtab
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|open_extra_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|int_to_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|printable_version
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fatal
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fatals
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|warn
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|warni
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|warns
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|warnss
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|warnsss
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|unlex
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|done
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|skip_white_space
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|parse_percent_token
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lex
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|symbol_list
block|{
name|struct
name|symbol_list
modifier|*
name|next
decl_stmt|;
name|bucket
modifier|*
name|sym
decl_stmt|;
name|bucket
modifier|*
name|ruleprec
decl_stmt|;
block|}
name|symbol_list
typedef|;
end_typedef

begin_decl_stmt
name|void
name|reader
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|reader_output_yylsp
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|read_declarations
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|copy_definition
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|parse_token_decl
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|parse_start_decl
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|parse_type_decl
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|parse_assoc_decl
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|parse_union_decl
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|parse_expect_decl
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|get_type_name
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|symbol_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|copy_guard
name|PARAMS
argument_list|(
operator|(
name|symbol_list
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|parse_thong_decl
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|copy_action
name|PARAMS
argument_list|(
operator|(
name|symbol_list
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bucket
modifier|*
name|gensym
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|readgram
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|record_rule_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|packsymbols
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|output_token_defines
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|packgram
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|read_signed_integer
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int get_type PARAMS((void));
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbol_list
modifier|*
name|grammar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|start_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bucket
modifier|*
name|startval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|tags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|user_toknums
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if components of semantic values are used, implying    they must be unions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|value_components_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero if %union has been seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lastprec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* incremented for each %left, %right or %nonassoc seen */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gensym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* incremented for each generated symbol */
end_comment

begin_decl_stmt
specifier|static
name|bucket
modifier|*
name|errtoken
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bucket
modifier|*
name|undeftoken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if any action or guard uses the @n construct.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|yylsp_needed
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|skip_to_char
parameter_list|(
name|int
name|target
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|'\n'
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"   Skipping to next \\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warni
argument_list|(
name|_
argument_list|(
literal|"   Skipping to next %c"
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
do|do
name|c
operator|=
name|skip_white_space
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|!=
name|target
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reader
parameter_list|(
name|void
parameter_list|)
block|{
name|start_flag
operator|=
literal|0
expr_stmt|;
name|startval
operator|=
name|NULL
expr_stmt|;
comment|/* start symbol not specified yet. */
if|#
directive|if
literal|0
block|translations = 0;
comment|/* initially assume token number translation not needed.  */
endif|#
directive|endif
comment|/* Nowadays translations is always set to 1,      since we give `error' a user-token-number      to satisfy the Posix demand for YYERRCODE==256.  */
name|translations
operator|=
literal|1
expr_stmt|;
name|nsyms
operator|=
literal|1
expr_stmt|;
name|nvars
operator|=
literal|0
expr_stmt|;
name|nrules
operator|=
literal|0
expr_stmt|;
name|nitems
operator|=
literal|0
expr_stmt|;
name|rline_allocated
operator|=
literal|10
expr_stmt|;
name|rline
operator|=
name|NEW2
argument_list|(
name|rline_allocated
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|typed
operator|=
literal|0
expr_stmt|;
name|lastprec
operator|=
literal|0
expr_stmt|;
name|gensym_count
operator|=
literal|0
expr_stmt|;
name|semantic_parser
operator|=
literal|0
expr_stmt|;
name|pure_parser
operator|=
literal|0
expr_stmt|;
name|yylsp_needed
operator|=
literal|0
expr_stmt|;
name|grammar
operator|=
name|NULL
expr_stmt|;
name|init_lex
argument_list|()
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
comment|/* initialize the symbol table.  */
name|tabinit
argument_list|()
expr_stmt|;
comment|/* construct the error token */
name|errtoken
operator|=
name|getsym
argument_list|(
literal|"error"
argument_list|)
expr_stmt|;
name|errtoken
operator|->
name|class
operator|=
name|STOKEN
expr_stmt|;
name|errtoken
operator|->
name|user_token_number
operator|=
literal|256
expr_stmt|;
comment|/* Value specified by posix.  */
comment|/* construct a token that represents all undefined literal tokens. */
comment|/* it is always token number 2.  */
name|undeftoken
operator|=
name|getsym
argument_list|(
literal|"$undefined."
argument_list|)
expr_stmt|;
name|undeftoken
operator|->
name|class
operator|=
name|STOKEN
expr_stmt|;
name|undeftoken
operator|->
name|user_token_number
operator|=
literal|2
expr_stmt|;
comment|/* Read the declaration section.  Copy %{ ... %} groups to ftable and fdefines file.      Also notice any %token, %left, etc. found there.  */
if|if
condition|(
name|noparserflag
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n/*  Bison-generated parse tables, made from %s\n"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"\n/*  A Bison parser, made from %s\n"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"    by %s  */\n\n"
argument_list|,
name|VERSION_STRING
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define YYBISON 1  /* Identify Bison output.  */\n\n"
argument_list|)
expr_stmt|;
name|read_declarations
argument_list|()
expr_stmt|;
comment|/* start writing the guard and action files, if they are needed.  */
name|output_headers
argument_list|()
expr_stmt|;
comment|/* read in the grammar, build grammar in list form.  write out guards and actions.  */
name|readgram
argument_list|()
expr_stmt|;
comment|/* Now we know whether we need the line-number stack.      If we do, write its type into the .tab.h file.  */
if|if
condition|(
name|fdefines
condition|)
name|reader_output_yylsp
argument_list|(
name|fdefines
argument_list|)
expr_stmt|;
comment|/* write closing delimiters for actions and guards.  */
name|output_trailers
argument_list|()
expr_stmt|;
if|if
condition|(
name|yylsp_needed
condition|)
name|fprintf
argument_list|(
name|ftable
argument_list|,
literal|"#define YYLSP_NEEDED\n\n"
argument_list|)
expr_stmt|;
comment|/* assign the symbols their symbol numbers.      Write #defines for the token symbols into fdefines if requested.  */
name|packsymbols
argument_list|()
expr_stmt|;
comment|/* convert the grammar into the format described in gram.h.  */
name|packgram
argument_list|()
expr_stmt|;
comment|/* free the symbol table data structure      since symbols are now all referred to by symbol number.  */
name|free_symtab
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reader_output_yylsp
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|yylsp_needed
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|LTYPESTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read from finput until %% is seen.  Discard the %%. Handle any % declarations, and copy the contents of any %{ ... %} groups to fattrs.  */
end_comment

begin_function
name|void
name|read_declarations
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|tok
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|skip_white_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|tok
operator|=
name|parse_percent_token
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TWO_PERCENTS
case|:
return|return;
case|case
name|PERCENT_LEFT_CURLY
case|:
name|copy_definition
argument_list|()
expr_stmt|;
break|break;
case|case
name|TOKEN
case|:
name|parse_token_decl
argument_list|(
name|STOKEN
argument_list|,
name|SNTERM
argument_list|)
expr_stmt|;
break|break;
case|case
name|NTERM
case|:
name|parse_token_decl
argument_list|(
name|SNTERM
argument_list|,
name|STOKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE
case|:
name|parse_type_decl
argument_list|()
expr_stmt|;
break|break;
case|case
name|START
case|:
name|parse_start_decl
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNION
case|:
name|parse_union_decl
argument_list|()
expr_stmt|;
break|break;
case|case
name|EXPECT
case|:
name|parse_expect_decl
argument_list|()
expr_stmt|;
break|break;
case|case
name|THONG
case|:
name|parse_thong_decl
argument_list|()
expr_stmt|;
break|break;
case|case
name|LEFT
case|:
name|parse_assoc_decl
argument_list|(
name|LEFT_ASSOC
argument_list|)
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|parse_assoc_decl
argument_list|(
name|RIGHT_ASSOC
argument_list|)
expr_stmt|;
break|break;
case|case
name|NONASSOC
case|:
name|parse_assoc_decl
argument_list|(
name|NON_ASSOC
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEMANTIC_PARSER
case|:
if|if
condition|(
name|semantic_parser
operator|==
literal|0
condition|)
block|{
name|semantic_parser
operator|=
literal|1
expr_stmt|;
name|open_extra_files
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|PURE_PARSER
case|:
name|pure_parser
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NOOP
case|:
break|break;
default|default:
name|warns
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %s"
argument_list|)
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|skip_to_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"no input grammar"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"unknown character: %s"
argument_list|)
argument_list|,
name|printable_version
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|warn
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|skip_to_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* copy the contents of a %{ ... %} into the definitions file. The %{ has already been read.  Return after reading the %}.  */
end_comment

begin_function
name|void
name|copy_definition
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|match
decl_stmt|;
specifier|register
name|int
name|ended
decl_stmt|;
specifier|register
name|int
name|after_percent
decl_stmt|;
comment|/* -1 while reading a character if prev char was % */
name|int
name|cplus_comment
decl_stmt|;
if|if
condition|(
operator|!
name|nolinesflag
condition|)
name|fprintf
argument_list|(
name|fattrs
argument_list|,
literal|"#line %d \"%s\"\n"
argument_list|,
name|lineno
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|after_percent
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|after_percent
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
name|match
operator|=
name|c
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|match
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated string at end of file"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|c
operator|=
name|match
expr_stmt|;
continue|continue;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated string at end of file"
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|&&
name|c
operator|!=
literal|'/'
condition|)
continue|continue;
name|cplus_comment
operator|=
operator|(
name|c
operator|==
literal|'/'
operator|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|ended
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|ended
condition|)
block|{
if|if
condition|(
operator|!
name|cplus_comment
operator|&&
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
name|ended
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cplus_comment
condition|)
name|ended
operator|=
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated comment in `%{' definition"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EOF
case|:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated `%{' definition"
argument_list|)
argument_list|)
expr_stmt|;
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_percent
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
return|return;
name|putc
argument_list|(
literal|'%'
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
block|}
name|after_percent
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* parse what comes after %token or %nterm. For %token, what_is is STOKEN and what_is_not is SNTERM. For %nterm, the arguments are reversed.  */
end_comment

begin_function
name|void
name|parse_token_decl
parameter_list|(
name|int
name|what_is
parameter_list|,
name|int
name|what_is_not
parameter_list|)
block|{
specifier|register
name|int
name|token
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|typename
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|bucket
modifier|*
name|symbol
init|=
name|NULL
decl_stmt|;
comment|/* pts to symbol being defined */
name|int
name|k
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|tmp_char
init|=
name|ungetc
argument_list|(
name|skip_white_space
argument_list|()
argument_list|,
name|finput
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp_char
operator|==
literal|'%'
condition|)
return|return;
if|if
condition|(
name|tmp_char
operator|==
name|EOF
condition|)
name|fatals
argument_list|(
literal|"Premature EOF after %s"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|token
operator|=
name|lex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|COMMA
condition|)
block|{
name|symbol
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|token
operator|==
name|TYPENAME
condition|)
block|{
name|k
operator|=
name|strlen
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|typename
operator|=
name|NEW2
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|typename
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|value_components_used
operator|=
literal|1
expr_stmt|;
name|symbol
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|IDENTIFIER
operator|&&
operator|*
name|symval
operator|->
name|tag
operator|==
literal|'\"'
operator|&&
name|symbol
condition|)
block|{
name|translations
operator|=
literal|1
expr_stmt|;
name|symval
operator|->
name|class
operator|=
name|STOKEN
expr_stmt|;
name|symval
operator|->
name|type_name
operator|=
name|typename
expr_stmt|;
name|symval
operator|->
name|user_token_number
operator|=
name|symbol
operator|->
name|user_token_number
expr_stmt|;
name|symbol
operator|->
name|user_token_number
operator|=
name|SALIAS
expr_stmt|;
name|symval
operator|->
name|alias
operator|=
name|symbol
expr_stmt|;
name|symbol
operator|->
name|alias
operator|=
name|symval
expr_stmt|;
name|symbol
operator|=
name|NULL
expr_stmt|;
name|nsyms
operator|--
expr_stmt|;
comment|/* symbol and symval combined are only one symbol */
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|IDENTIFIER
condition|)
block|{
name|int
name|oldclass
init|=
name|symval
operator|->
name|class
decl_stmt|;
name|symbol
operator|=
name|symval
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|class
operator|==
name|what_is_not
condition|)
name|warns
argument_list|(
name|_
argument_list|(
literal|"symbol %s redefined"
argument_list|)
argument_list|,
name|symbol
operator|->
name|tag
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|class
operator|=
name|what_is
expr_stmt|;
if|if
condition|(
name|what_is
operator|==
name|SNTERM
operator|&&
name|oldclass
operator|!=
name|SNTERM
condition|)
name|symbol
operator|->
name|value
operator|=
name|nvars
operator|++
expr_stmt|;
if|if
condition|(
name|typename
condition|)
block|{
if|if
condition|(
name|symbol
operator|->
name|type_name
operator|==
name|NULL
condition|)
name|symbol
operator|->
name|type_name
operator|=
name|typename
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|typename
argument_list|,
name|symbol
operator|->
name|type_name
argument_list|)
operator|!=
literal|0
condition|)
name|warns
argument_list|(
name|_
argument_list|(
literal|"type redeclaration for %s"
argument_list|)
argument_list|,
name|symbol
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|symbol
operator|&&
name|token
operator|==
name|NUMBER
condition|)
block|{
name|symbol
operator|->
name|user_token_number
operator|=
name|numval
expr_stmt|;
name|translations
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warnss
argument_list|(
name|_
argument_list|(
literal|"`%s' is invalid in %s"
argument_list|)
argument_list|,
name|token_buffer
argument_list|,
operator|(
name|what_is
operator|==
name|STOKEN
operator|)
condition|?
literal|"%token"
else|:
literal|"%nterm"
argument_list|)
expr_stmt|;
name|skip_to_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* parse what comes after %thong 	the full syntax is 		%thong<type> token number literal  the<type> or number may be omitted.  The number specifies the  user_token_number.   Two symbols are entered in the table, one for the token symbol and  one for the literal.  Both are given the<type>, if any, from the declaration.  The ->user_token_number of the first is SALIAS and the ->user_token_number  of the second is set to the number, if any, from the declaration.  The two symbols are linked via pointers in their ->alias fields.   during output_defines_table, the symbol is reported  thereafter, only the literal string is retained  it is the literal string that is output to yytname */
end_comment

begin_function
name|void
name|parse_thong_decl
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|token
decl_stmt|;
specifier|register
name|struct
name|bucket
modifier|*
name|symbol
decl_stmt|;
specifier|register
name|char
modifier|*
name|typename
init|=
literal|0
decl_stmt|;
name|int
name|k
decl_stmt|,
name|usrtoknum
decl_stmt|;
name|translations
operator|=
literal|1
expr_stmt|;
name|token
operator|=
name|lex
argument_list|()
expr_stmt|;
comment|/* fetch typename or first token */
if|if
condition|(
name|token
operator|==
name|TYPENAME
condition|)
block|{
name|k
operator|=
name|strlen
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|typename
operator|=
name|NEW2
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|typename
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|value_components_used
operator|=
literal|1
expr_stmt|;
name|token
operator|=
name|lex
argument_list|()
expr_stmt|;
comment|/* fetch first token */
block|}
comment|/* process first token */
if|if
condition|(
name|token
operator|!=
name|IDENTIFIER
condition|)
block|{
name|warns
argument_list|(
name|_
argument_list|(
literal|"unrecognized item %s, expected an identifier"
argument_list|)
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|skip_to_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
return|return;
block|}
name|symval
operator|->
name|class
operator|=
name|STOKEN
expr_stmt|;
name|symval
operator|->
name|type_name
operator|=
name|typename
expr_stmt|;
name|symval
operator|->
name|user_token_number
operator|=
name|SALIAS
expr_stmt|;
name|symbol
operator|=
name|symval
expr_stmt|;
name|token
operator|=
name|lex
argument_list|()
expr_stmt|;
comment|/* get number or literal string */
if|if
condition|(
name|token
operator|==
name|NUMBER
condition|)
block|{
name|usrtoknum
operator|=
name|numval
expr_stmt|;
name|token
operator|=
name|lex
argument_list|()
expr_stmt|;
comment|/* okay, did number, now get literal */
block|}
else|else
name|usrtoknum
operator|=
literal|0
expr_stmt|;
comment|/* process literal string token */
if|if
condition|(
name|token
operator|!=
name|IDENTIFIER
operator|||
operator|*
name|symval
operator|->
name|tag
operator|!=
literal|'\"'
condition|)
block|{
name|warns
argument_list|(
name|_
argument_list|(
literal|"expected string constant instead of %s"
argument_list|)
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|skip_to_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
return|return;
block|}
name|symval
operator|->
name|class
operator|=
name|STOKEN
expr_stmt|;
name|symval
operator|->
name|type_name
operator|=
name|typename
expr_stmt|;
name|symval
operator|->
name|user_token_number
operator|=
name|usrtoknum
expr_stmt|;
name|symval
operator|->
name|alias
operator|=
name|symbol
expr_stmt|;
name|symbol
operator|->
name|alias
operator|=
name|symval
expr_stmt|;
name|nsyms
operator|--
expr_stmt|;
comment|/* symbol and symval combined are only one symbol */
block|}
end_function

begin_comment
comment|/* parse what comes after %start */
end_comment

begin_function
name|void
name|parse_start_decl
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|start_flag
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"multiple %start declarations"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex
argument_list|()
operator|!=
name|IDENTIFIER
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"invalid %start declaration"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|start_flag
operator|=
literal|1
expr_stmt|;
name|startval
operator|=
name|symval
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* read in a %type declaration and record its information for get_type_name to access */
end_comment

begin_function
name|void
name|parse_type_decl
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|lex
argument_list|()
operator|!=
name|TYPENAME
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"%type declaration has no<typename>"
argument_list|)
argument_list|)
expr_stmt|;
name|skip_to_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
return|return;
block|}
name|k
operator|=
name|strlen
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|name
operator|=
name|NEW2
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|int
name|t
decl_stmt|;
name|int
name|tmp_char
init|=
name|ungetc
argument_list|(
name|skip_white_space
argument_list|()
argument_list|,
name|finput
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp_char
operator|==
literal|'%'
condition|)
return|return;
if|if
condition|(
name|tmp_char
operator|==
name|EOF
condition|)
name|fatals
argument_list|(
literal|"Premature EOF after %s"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|COMMA
case|:
case|case
name|SEMICOLON
case|:
break|break;
case|case
name|IDENTIFIER
case|:
if|if
condition|(
name|symval
operator|->
name|type_name
operator|==
name|NULL
condition|)
name|symval
operator|->
name|type_name
operator|=
name|name
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|symval
operator|->
name|type_name
argument_list|)
operator|!=
literal|0
condition|)
name|warns
argument_list|(
name|_
argument_list|(
literal|"type redeclaration for %s"
argument_list|)
argument_list|,
name|symval
operator|->
name|tag
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warns
argument_list|(
name|_
argument_list|(
literal|"invalid %%type declaration due to item: `%s'"
argument_list|)
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|skip_to_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* read in a %left, %right or %nonassoc declaration and record its information.  */
end_comment

begin_comment
comment|/* assoc is either LEFT_ASSOC, RIGHT_ASSOC or NON_ASSOC.  */
end_comment

begin_function
name|void
name|parse_assoc_decl
parameter_list|(
name|int
name|assoc
parameter_list|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|register
name|int
name|prev
init|=
literal|0
decl_stmt|;
name|lastprec
operator|++
expr_stmt|;
comment|/* Assign a new precedence level, never 0.  */
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|int
name|t
decl_stmt|;
name|int
name|tmp_char
init|=
name|ungetc
argument_list|(
name|skip_white_space
argument_list|()
argument_list|,
name|finput
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp_char
operator|==
literal|'%'
condition|)
return|return;
if|if
condition|(
name|tmp_char
operator|==
name|EOF
condition|)
name|fatals
argument_list|(
literal|"Premature EOF after %s"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TYPENAME
case|:
name|k
operator|=
name|strlen
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|name
operator|=
name|NEW2
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMA
case|:
break|break;
case|case
name|IDENTIFIER
case|:
if|if
condition|(
name|symval
operator|->
name|prec
operator|!=
literal|0
condition|)
name|warns
argument_list|(
name|_
argument_list|(
literal|"redefining precedence of %s"
argument_list|)
argument_list|,
name|symval
operator|->
name|tag
argument_list|)
expr_stmt|;
name|symval
operator|->
name|prec
operator|=
name|lastprec
expr_stmt|;
name|symval
operator|->
name|assoc
operator|=
name|assoc
expr_stmt|;
if|if
condition|(
name|symval
operator|->
name|class
operator|==
name|SNTERM
condition|)
name|warns
argument_list|(
name|_
argument_list|(
literal|"symbol %s redefined"
argument_list|)
argument_list|,
name|symval
operator|->
name|tag
argument_list|)
expr_stmt|;
name|symval
operator|->
name|class
operator|=
name|STOKEN
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* record the type, if one is specified */
if|if
condition|(
name|symval
operator|->
name|type_name
operator|==
name|NULL
condition|)
name|symval
operator|->
name|type_name
operator|=
name|name
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|symval
operator|->
name|type_name
argument_list|)
operator|!=
literal|0
condition|)
name|warns
argument_list|(
name|_
argument_list|(
literal|"type redeclaration for %s"
argument_list|)
argument_list|,
name|symval
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NUMBER
case|:
if|if
condition|(
name|prev
operator|==
name|IDENTIFIER
condition|)
block|{
name|symval
operator|->
name|user_token_number
operator|=
name|numval
expr_stmt|;
name|translations
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warns
argument_list|(
name|_
argument_list|(
literal|"invalid text (%s) - number should be after identifier"
argument_list|)
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|skip_to_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SEMICOLON
case|:
return|return;
default|default:
name|warns
argument_list|(
name|_
argument_list|(
literal|"unexpected item: %s"
argument_list|)
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|skip_to_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* copy the union declaration into fattrs (and fdefines),    where it is made into the    definition of YYSTYPE, the type of elements of the parser value stack.  */
end_comment

begin_function
name|void
name|parse_union_decl
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|in_comment
decl_stmt|;
name|int
name|cplus_comment
decl_stmt|;
if|if
condition|(
name|typed
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"multiple %union declarations"
argument_list|)
argument_list|)
expr_stmt|;
name|typed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|nolinesflag
condition|)
name|fprintf
argument_list|(
name|fattrs
argument_list|,
literal|"\n#line %d \"%s\"\n"
argument_list|,
name|lineno
argument_list|,
name|infile
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fattrs
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fattrs
argument_list|,
literal|"typedef union"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdefines
condition|)
name|fprintf
argument_list|(
name|fdefines
argument_list|,
literal|"typedef union"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|in_comment
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdefines
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fdefines
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|&&
name|c
operator|!=
literal|'/'
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdefines
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fdefines
argument_list|)
expr_stmt|;
name|cplus_comment
operator|=
operator|(
name|c
operator|==
literal|'/'
operator|)
expr_stmt|;
name|in_comment
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|in_comment
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdefines
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fdefines
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|cplus_comment
condition|)
block|{
name|in_comment
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated comment at end of file"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cplus_comment
operator|&&
name|c
operator|==
literal|'*'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'/'
argument_list|,
name|fattrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdefines
condition|)
name|putc
argument_list|(
literal|'/'
argument_list|,
name|fdefines
argument_list|)
expr_stmt|;
name|in_comment
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'{'
case|:
name|count
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"unmatched close-brace (`}')"
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|fattrs
argument_list|,
literal|" YYSTYPE;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdefines
condition|)
name|fprintf
argument_list|(
name|fdefines
argument_list|,
literal|" YYSTYPE;\n"
argument_list|)
expr_stmt|;
comment|/* JF don't choke on trailing semi */
name|c
operator|=
name|skip_white_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|';'
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* parse the declaration %expect N which says to expect N    shift-reduce conflicts.  */
end_comment

begin_function
name|void
name|parse_expect_decl
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|count
operator|<
literal|20
condition|)
name|buffer
index|[
name|count
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
operator|||
name|count
operator|>
literal|10
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"argument of %expect is not an integer"
argument_list|)
argument_list|)
expr_stmt|;
name|expected_conflicts
operator|=
name|atoi
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* that's all of parsing the declaration section */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Get the data type (alternative in the union) of the value for symbol n in rule rule.  */
end_comment

begin_function
name|char
modifier|*
name|get_type_name
parameter_list|(
name|int
name|n
parameter_list|,
name|symbol_list
modifier|*
name|rule
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|msg
init|=
name|N_
argument_list|(
literal|"invalid $ value"
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|symbol_list
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rp
operator|=
name|rule
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|rp
operator|=
name|rp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
operator|||
name|rp
operator|->
name|sym
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|rp
operator|->
name|sym
operator|->
name|type_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/* after %guard is seen in the input file, copy the actual guard into the guards file. If the guard is followed by an action, copy that into the actions file. stack_offset is the number of values in the current rule so far, which says where to find $0 with respect to the top of the stack, for the simple parser in which the stack is not popped until after the guard is run.  */
end_comment

begin_function
name|void
name|copy_guard
parameter_list|(
name|symbol_list
modifier|*
name|rule
parameter_list|,
name|int
name|stack_offset
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|match
decl_stmt|;
specifier|register
name|int
name|ended
decl_stmt|;
specifier|register
name|char
modifier|*
name|type_name
decl_stmt|;
name|int
name|brace_flag
init|=
literal|0
decl_stmt|;
name|int
name|cplus_comment
decl_stmt|;
comment|/* offset is always 0 if parser has already popped the stack pointer */
if|if
condition|(
name|semantic_parser
condition|)
name|stack_offset
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|fguard
argument_list|,
literal|"\ncase %d:\n"
argument_list|,
name|nrules
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nolinesflag
condition|)
name|fprintf
argument_list|(
name|fguard
argument_list|,
literal|"#line %d \"%s\"\n"
argument_list|,
name|lineno
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'{'
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|brace_flag
condition|?
operator|(
name|count
operator|>
literal|0
operator|)
else|:
operator|(
name|c
operator|!=
literal|';'
operator|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
name|brace_flag
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|count
operator|--
expr_stmt|;
else|else
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"unmatched right brace (`}')"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* skip it */
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
name|match
operator|=
name|c
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|match
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated string at end of file"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|c
operator|=
name|match
expr_stmt|;
comment|/* invent terminator */
continue|continue;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|&&
name|c
operator|!=
literal|'/'
condition|)
continue|continue;
name|cplus_comment
operator|=
operator|(
name|c
operator|==
literal|'/'
operator|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|ended
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|ended
condition|)
block|{
if|if
condition|(
operator|!
name|cplus_comment
operator|&&
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
name|ended
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
if|if
condition|(
name|cplus_comment
condition|)
name|ended
operator|=
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated comment"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'$'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|type_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|token_buffer
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|!=
literal|'>'
operator|&&
name|c
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|==
name|token_buffer
operator|+
name|maxtoken
condition|)
name|cp
operator|=
name|grow_token_buffer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|type_name
operator|=
name|token_buffer
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|fprintf
argument_list|(
name|fguard
argument_list|,
literal|"yyval"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_name
condition|)
name|type_name
operator|=
name|rule
operator|->
name|sym
operator|->
name|type_name
expr_stmt|;
if|if
condition|(
name|type_name
condition|)
name|fprintf
argument_list|(
name|fguard
argument_list|,
literal|".%s"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_name
operator|&&
name|typed
condition|)
name|warns
argument_list|(
name|_
argument_list|(
literal|"$$ of `%s' has no declared type"
argument_list|)
argument_list|,
name|rule
operator|->
name|sym
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|n
operator|=
name|read_signed_integer
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_name
operator|&&
name|n
operator|>
literal|0
condition|)
name|type_name
operator|=
name|get_type_name
argument_list|(
name|n
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fguard
argument_list|,
literal|"yyvsp[%d]"
argument_list|,
name|n
operator|-
name|stack_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_name
condition|)
name|fprintf
argument_list|(
name|fguard
argument_list|,
literal|".%s"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_name
operator|&&
name|typed
condition|)
name|warnss
argument_list|(
name|_
argument_list|(
literal|"$%s of `%s' has no declared type"
argument_list|)
argument_list|,
name|int_to_string
argument_list|(
name|n
argument_list|)
argument_list|,
name|rule
operator|->
name|sym
operator|->
name|tag
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|warns
argument_list|(
name|_
argument_list|(
literal|"$%s is invalid"
argument_list|)
argument_list|,
name|printable_version
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|n
operator|=
name|read_signed_integer
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warns
argument_list|(
name|_
argument_list|(
literal|"@%s is invalid"
argument_list|)
argument_list|,
name|printable_version
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fguard
argument_list|,
literal|"yylsp[%d]"
argument_list|,
name|n
operator|-
name|stack_offset
argument_list|)
expr_stmt|;
name|yylsp_needed
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|EOF
case|:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated %%guard clause"
argument_list|)
argument_list|)
expr_stmt|;
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|fguard
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'}'
operator|||
name|count
operator|!=
literal|0
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|skip_white_space
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|fguard
argument_list|,
literal|";\n    break;}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|copy_action
argument_list|(
name|rule
argument_list|,
name|stack_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* why not skip_white_space -wjh */
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|copy_action
argument_list|(
name|rule
argument_list|,
name|stack_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assuming that a { has just been seen, copy everything up to the matching } into the actions file. stack_offset is the number of values in the current rule so far, which says where to find $0 with respect to the top of the stack.  */
end_comment

begin_function
name|void
name|copy_action
parameter_list|(
name|symbol_list
modifier|*
name|rule
parameter_list|,
name|int
name|stack_offset
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|match
decl_stmt|;
specifier|register
name|int
name|ended
decl_stmt|;
specifier|register
name|char
modifier|*
name|type_name
decl_stmt|;
name|int
name|cplus_comment
decl_stmt|;
comment|/* offset is always 0 if parser has already popped the stack pointer */
if|if
condition|(
name|semantic_parser
condition|)
name|stack_offset
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|"\ncase %d:\n"
argument_list|,
name|nrules
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nolinesflag
condition|)
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|"#line %d \"%s\"\n"
argument_list|,
name|lineno
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'{'
argument_list|,
name|faction
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|c
operator|!=
literal|'}'
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
name|match
operator|=
name|c
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|match
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|c
operator|=
name|match
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated string at end of file"
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated string"
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|&&
name|c
operator|!=
literal|'/'
condition|)
continue|continue;
name|cplus_comment
operator|=
operator|(
name|c
operator|==
literal|'/'
operator|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|ended
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|ended
condition|)
block|{
if|if
condition|(
operator|!
name|cplus_comment
operator|&&
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
name|ended
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
if|if
condition|(
name|cplus_comment
condition|)
name|ended
operator|=
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unterminated comment"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'$'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|type_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|token_buffer
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|!=
literal|'>'
operator|&&
name|c
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|==
name|token_buffer
operator|+
name|maxtoken
condition|)
name|cp
operator|=
name|grow_token_buffer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|type_name
operator|=
name|token_buffer
expr_stmt|;
name|value_components_used
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|"yyval"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_name
condition|)
name|type_name
operator|=
name|get_type_name
argument_list|(
literal|0
argument_list|,
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_name
condition|)
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|".%s"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_name
operator|&&
name|typed
condition|)
name|warns
argument_list|(
name|_
argument_list|(
literal|"$$ of `%s' has no declared type"
argument_list|)
argument_list|,
name|rule
operator|->
name|sym
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|n
operator|=
name|read_signed_integer
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_name
operator|&&
name|n
operator|>
literal|0
condition|)
name|type_name
operator|=
name|get_type_name
argument_list|(
name|n
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|"yyvsp[%d]"
argument_list|,
name|n
operator|-
name|stack_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_name
condition|)
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|".%s"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_name
operator|&&
name|typed
condition|)
name|warnss
argument_list|(
name|_
argument_list|(
literal|"$%s of `%s' has no declared type"
argument_list|)
argument_list|,
name|int_to_string
argument_list|(
name|n
argument_list|)
argument_list|,
name|rule
operator|->
name|sym
operator|->
name|tag
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|warns
argument_list|(
name|_
argument_list|(
literal|"$%s is invalid"
argument_list|)
argument_list|,
name|printable_version
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|n
operator|=
name|read_signed_integer
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"invalid @-construct"
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|"yylsp[%d]"
argument_list|,
name|n
operator|-
name|stack_offset
argument_list|)
expr_stmt|;
name|yylsp_needed
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|EOF
case|:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unmatched `{'"
argument_list|)
argument_list|)
expr_stmt|;
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
comment|/* above loop exits when c is '}' */
if|if
condition|(
operator|--
name|count
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|faction
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|faction
argument_list|,
literal|";\n    break;}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* generate a dummy symbol, a nonterminal, whose name cannot conflict with the user's names. */
end_comment

begin_function
name|bucket
modifier|*
name|gensym
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|bucket
modifier|*
name|sym
decl_stmt|;
name|sprintf
argument_list|(
name|token_buffer
argument_list|,
literal|"@%d"
argument_list|,
operator|++
name|gensym_count
argument_list|)
expr_stmt|;
name|sym
operator|=
name|getsym
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|sym
operator|->
name|class
operator|=
name|SNTERM
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|nvars
operator|++
expr_stmt|;
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse the input grammar into a one symbol_list structure. Each rule is represented by a sequence of symbols: the left hand side followed by the contents of the right hand side, followed by a null pointer instead of a symbol to terminate the rule. The next symbol is the lhs of the following rule.  All guards and actions are copied out to the appropriate files, labelled by the rule number they apply to.  */
end_comment

begin_function
name|void
name|readgram
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|bucket
modifier|*
name|lhs
init|=
name|NULL
decl_stmt|;
specifier|register
name|symbol_list
modifier|*
name|p
decl_stmt|;
specifier|register
name|symbol_list
modifier|*
name|p1
decl_stmt|;
specifier|register
name|bucket
modifier|*
name|bp
decl_stmt|;
name|symbol_list
modifier|*
name|crule
decl_stmt|;
comment|/* points to first symbol_list of current rule.  */
comment|/* its symbol is the lhs of the rule.   */
name|symbol_list
modifier|*
name|crule1
decl_stmt|;
comment|/* points to the symbol_list preceding crule.  */
name|p1
operator|=
name|NULL
expr_stmt|;
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|TWO_PERCENTS
operator|&&
name|t
operator|!=
name|ENDFILE
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|IDENTIFIER
operator|||
name|t
operator|==
name|BAR
condition|)
block|{
specifier|register
name|int
name|actionflag
init|=
literal|0
decl_stmt|;
name|int
name|rulelength
init|=
literal|0
decl_stmt|;
comment|/* number of symbols in rhs of this rule so far  */
name|int
name|xactions
init|=
literal|0
decl_stmt|;
comment|/* JF for error checking */
name|bucket
modifier|*
name|first_rhs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|IDENTIFIER
condition|)
block|{
name|lhs
operator|=
name|symval
expr_stmt|;
if|if
condition|(
operator|!
name|start_flag
condition|)
block|{
name|startval
operator|=
name|lhs
expr_stmt|;
name|start_flag
operator|=
literal|1
expr_stmt|;
block|}
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|COLON
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"ill-formed rule: initial symbol not followed by colon"
argument_list|)
argument_list|)
expr_stmt|;
name|unlex
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nrules
operator|==
literal|0
operator|&&
name|t
operator|==
name|BAR
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"grammar starts with vertical bar"
argument_list|)
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|symval
expr_stmt|;
comment|/* BOGUS: use a random symval */
block|}
comment|/* start a new rule and record its lhs.  */
name|nrules
operator|++
expr_stmt|;
name|nitems
operator|++
expr_stmt|;
name|record_rule_line
argument_list|()
expr_stmt|;
name|p
operator|=
name|NEW
argument_list|(
name|symbol_list
argument_list|)
expr_stmt|;
name|p
operator|->
name|sym
operator|=
name|lhs
expr_stmt|;
name|crule1
operator|=
name|p1
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|p1
operator|->
name|next
operator|=
name|p
expr_stmt|;
else|else
name|grammar
operator|=
name|p
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
name|crule
operator|=
name|p
expr_stmt|;
comment|/* mark the rule's lhs as a nonterminal if not already so.  */
if|if
condition|(
name|lhs
operator|->
name|class
operator|==
name|SUNKNOWN
condition|)
block|{
name|lhs
operator|->
name|class
operator|=
name|SNTERM
expr_stmt|;
name|lhs
operator|->
name|value
operator|=
name|nvars
expr_stmt|;
name|nvars
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lhs
operator|->
name|class
operator|==
name|STOKEN
condition|)
name|warns
argument_list|(
name|_
argument_list|(
literal|"rule given for %s, which is a token"
argument_list|)
argument_list|,
name|lhs
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* read the rhs of the rule.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|PREC
condition|)
block|{
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
name|crule
operator|->
name|ruleprec
operator|=
name|symval
expr_stmt|;
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|t
operator|==
name|IDENTIFIER
operator|||
name|t
operator|==
name|LEFT_CURLY
operator|)
condition|)
break|break;
comment|/* If next token is an identifier, see if a colon follows it. 		 If one does, exit this rule now.  */
if|if
condition|(
name|t
operator|==
name|IDENTIFIER
condition|)
block|{
specifier|register
name|bucket
modifier|*
name|ssave
decl_stmt|;
specifier|register
name|int
name|t1
decl_stmt|;
name|ssave
operator|=
name|symval
expr_stmt|;
name|t1
operator|=
name|lex
argument_list|()
expr_stmt|;
name|unlex
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|symval
operator|=
name|ssave
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|COLON
condition|)
break|break;
if|if
condition|(
operator|!
name|first_rhs
condition|)
comment|/* JF */
name|first_rhs
operator|=
name|symval
expr_stmt|;
comment|/* Not followed by colon => 		     process as part of this rule's rhs.  */
block|}
comment|/* If we just passed an action, that action was in the middle 		 of a rule, so make a dummy rule to reduce it to a 		 non-terminal.  */
if|if
condition|(
name|actionflag
condition|)
block|{
specifier|register
name|bucket
modifier|*
name|sdummy
decl_stmt|;
comment|/* Since the action was written out with this rule's */
comment|/* number, we must give the new rule this number */
comment|/* by inserting the new rule before it.  */
comment|/* Make a dummy nonterminal, a gensym.  */
name|sdummy
operator|=
name|gensym
argument_list|()
expr_stmt|;
comment|/* Make a new rule, whose body is empty, 		     before the current one, so that the action 		     just read can belong to it.  */
name|nrules
operator|++
expr_stmt|;
name|nitems
operator|++
expr_stmt|;
name|record_rule_line
argument_list|()
expr_stmt|;
name|p
operator|=
name|NEW
argument_list|(
name|symbol_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|crule1
condition|)
name|crule1
operator|->
name|next
operator|=
name|p
expr_stmt|;
else|else
name|grammar
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sym
operator|=
name|sdummy
expr_stmt|;
name|crule1
operator|=
name|NEW
argument_list|(
name|symbol_list
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|crule1
expr_stmt|;
name|crule1
operator|->
name|next
operator|=
name|crule
expr_stmt|;
comment|/* insert the dummy generated by that rule into this rule.  */
name|nitems
operator|++
expr_stmt|;
name|p
operator|=
name|NEW
argument_list|(
name|symbol_list
argument_list|)
expr_stmt|;
name|p
operator|->
name|sym
operator|=
name|sdummy
expr_stmt|;
name|p1
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
name|actionflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|IDENTIFIER
condition|)
block|{
name|nitems
operator|++
expr_stmt|;
name|p
operator|=
name|NEW
argument_list|(
name|symbol_list
argument_list|)
expr_stmt|;
name|p
operator|->
name|sym
operator|=
name|symval
expr_stmt|;
name|p1
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
block|}
else|else
comment|/* handle an action.  */
block|{
name|copy_action
argument_list|(
name|crule
argument_list|,
name|rulelength
argument_list|)
expr_stmt|;
name|actionflag
operator|=
literal|1
expr_stmt|;
name|xactions
operator|++
expr_stmt|;
comment|/* JF */
block|}
name|rulelength
operator|++
expr_stmt|;
block|}
comment|/* end of  read rhs of rule */
comment|/* Put an empty link in the list to mark the end of this rule  */
name|p
operator|=
name|NEW
argument_list|(
name|symbol_list
argument_list|)
expr_stmt|;
name|p1
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|PREC
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"two @prec's in a row"
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
name|crule
operator|->
name|ruleprec
operator|=
name|symval
expr_stmt|;
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|GUARD
condition|)
block|{
if|if
condition|(
operator|!
name|semantic_parser
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"%%guard present but %%semantic_parser not specified"
argument_list|)
argument_list|)
expr_stmt|;
name|copy_guard
argument_list|(
name|crule
argument_list|,
name|rulelength
argument_list|)
expr_stmt|;
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|LEFT_CURLY
condition|)
block|{
comment|/* This case never occurs -wjh */
if|if
condition|(
name|actionflag
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"two actions at end of one rule"
argument_list|)
argument_list|)
expr_stmt|;
name|copy_action
argument_list|(
name|crule
argument_list|,
name|rulelength
argument_list|)
expr_stmt|;
name|actionflag
operator|=
literal|1
expr_stmt|;
name|xactions
operator|++
expr_stmt|;
comment|/* -wjh */
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
comment|/* If $$ is being set in default way, 	     warn if any type mismatch.  */
elseif|else
if|if
condition|(
operator|!
name|xactions
operator|&&
name|first_rhs
operator|&&
name|lhs
operator|->
name|type_name
operator|!=
name|first_rhs
operator|->
name|type_name
condition|)
block|{
if|if
condition|(
name|lhs
operator|->
name|type_name
operator|==
literal|0
operator|||
name|first_rhs
operator|->
name|type_name
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|lhs
operator|->
name|type_name
argument_list|,
name|first_rhs
operator|->
name|type_name
argument_list|)
condition|)
name|warnss
argument_list|(
name|_
argument_list|(
literal|"type clash (`%s' `%s') on default action"
argument_list|)
argument_list|,
name|lhs
operator|->
name|type_name
condition|?
name|lhs
operator|->
name|type_name
else|:
literal|""
argument_list|,
name|first_rhs
operator|->
name|type_name
condition|?
name|first_rhs
operator|->
name|type_name
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Warn if there is no default for $$ but we need one.  */
elseif|else
if|if
condition|(
operator|!
name|xactions
operator|&&
operator|!
name|first_rhs
operator|&&
name|lhs
operator|->
name|type_name
operator|!=
literal|0
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"empty rule for typed nonterminal, and no action"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|SEMICOLON
condition|)
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* these things can appear as alternatives to rules.  */
comment|/* NO, they cannot. 	a) none of the documentation allows them 	b) most of them scan forward until finding a next % 		thus they may swallow lots of intervening rules */
if|else if (t == TOKEN) 	{ 	  parse_token_decl(STOKEN, SNTERM); 	  t = lex(); 	}       else if (t == NTERM) 	{ 	  parse_token_decl(SNTERM, STOKEN); 	  t = lex(); 	}       else if (t == TYPE) 	{ 	  t = get_type(); 	}       else if (t == UNION) 	{ 	  parse_union_decl(); 	  t = lex(); 	}       else if (t == EXPECT) 	{ 	  parse_expect_decl(); 	  t = lex(); 	}       else if (t == START) 	{ 	  parse_start_decl(); 	  t = lex(); 	}
endif|#
directive|endif
else|else
block|{
name|warns
argument_list|(
name|_
argument_list|(
literal|"invalid input: %s"
argument_list|)
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|t
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* grammar has been read.  Do some checking */
if|if
condition|(
name|nsyms
operator|>
name|MAXSHORT
condition|)
name|fatals
argument_list|(
name|_
argument_list|(
literal|"too many symbols (tokens plus nonterminals); maximum %s"
argument_list|)
argument_list|,
name|int_to_string
argument_list|(
name|MAXSHORT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrules
operator|==
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"no rules in the input grammar"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typed
operator|==
literal|0
comment|/* JF put out same default YYSTYPE as YACC does */
operator|&&
operator|!
name|value_components_used
condition|)
block|{
comment|/* We used to use `unsigned long' as YYSTYPE on MSDOS, 	 but it seems better to be consistent. 	 Most programs should declare their own type anyway.  */
name|fprintf
argument_list|(
name|fattrs
argument_list|,
literal|"#ifndef YYSTYPE\n#define YYSTYPE int\n#endif\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdefines
condition|)
name|fprintf
argument_list|(
name|fdefines
argument_list|,
literal|"#ifndef YYSTYPE\n#define YYSTYPE int\n#endif\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Report any undefined symbols and consider them nonterminals.  */
for|for
control|(
name|bp
operator|=
name|firstsymbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|SUNKNOWN
condition|)
block|{
name|warns
argument_list|(
name|_
argument_list|(
literal|"symbol %s is used, but is not defined as a token and has no rules"
argument_list|)
argument_list|,
name|bp
operator|->
name|tag
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|SNTERM
expr_stmt|;
name|bp
operator|->
name|value
operator|=
name|nvars
operator|++
expr_stmt|;
block|}
name|ntokens
operator|=
name|nsyms
operator|-
name|nvars
expr_stmt|;
block|}
end_function

begin_function
name|void
name|record_rule_line
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Record each rule's source line number in rline table.  */
if|if
condition|(
name|nrules
operator|>=
name|rline_allocated
condition|)
block|{
name|rline_allocated
operator|=
name|nrules
operator|*
literal|2
expr_stmt|;
name|rline
operator|=
operator|(
name|short
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rline
argument_list|,
name|rline_allocated
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rline
index|[
name|nrules
index|]
operator|=
name|lineno
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* read in a %type declaration and record its information for get_type_name to access */
end_comment

begin_comment
comment|/* this is unused.  it is only called from the #if 0 part of readgram */
end_comment

begin_endif
unit|static int get_type (void) {   register int k;   register int t;   register char *name;    t = lex();    if (t != TYPENAME)     {       warn(_("ill-formed %type declaration"));       return t;     }    k = strlen(token_buffer);   name = NEW2(k + 1, char);   strcpy(name, token_buffer);    for (;;)     {       t = lex();        switch (t) 	{ 	case SEMICOLON: 	  return (lex());  	case COMMA: 	  break;  	case IDENTIFIER: 	  if (symval->type_name == NULL) 	    symval->type_name = name; 	  else if (strcmp(name, symval->type_name) != 0) 	    warns(_("type redeclaration for %s"), symval->tag);  	  break;  	default: 	  return (t); 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* assign symbol numbers, and write definition of token names into fdefines. Set up vectors tags and sprec of names and precedences of symbols.  */
end_comment

begin_function
name|void
name|packsymbols
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|bucket
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|tokno
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|last_user_token_number
decl_stmt|;
comment|/* int lossage = 0; JF set but not used */
name|tags
operator|=
name|NEW2
argument_list|(
name|nsyms
operator|+
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|tags
index|[
literal|0
index|]
operator|=
literal|"$"
expr_stmt|;
name|user_toknums
operator|=
name|NEW2
argument_list|(
name|nsyms
operator|+
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|user_toknums
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sprec
operator|=
name|NEW2
argument_list|(
name|nsyms
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|sassoc
operator|=
name|NEW2
argument_list|(
name|nsyms
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|max_user_token_number
operator|=
literal|256
expr_stmt|;
name|last_user_token_number
operator|=
literal|256
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|firstsymbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|SNTERM
condition|)
block|{
name|bp
operator|->
name|value
operator|+=
name|ntokens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|alias
condition|)
block|{
comment|/* this symbol and its alias are a single token defn. 		  allocate a tokno, and assign to both 		  check agreement of ->prec and ->assoc fields 			and make both the same 		*/
if|if
condition|(
name|bp
operator|->
name|value
operator|==
literal|0
condition|)
name|bp
operator|->
name|value
operator|=
name|bp
operator|->
name|alias
operator|->
name|value
operator|=
name|tokno
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|prec
operator|!=
name|bp
operator|->
name|alias
operator|->
name|prec
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|prec
operator|!=
literal|0
operator|&&
name|bp
operator|->
name|alias
operator|->
name|prec
operator|!=
literal|0
operator|&&
name|bp
operator|->
name|user_token_number
operator|==
name|SALIAS
condition|)
name|warnss
argument_list|(
name|_
argument_list|(
literal|"conflicting precedences for %s and %s"
argument_list|)
argument_list|,
name|bp
operator|->
name|tag
argument_list|,
name|bp
operator|->
name|alias
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|prec
operator|!=
literal|0
condition|)
name|bp
operator|->
name|alias
operator|->
name|prec
operator|=
name|bp
operator|->
name|prec
expr_stmt|;
else|else
name|bp
operator|->
name|prec
operator|=
name|bp
operator|->
name|alias
operator|->
name|prec
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|assoc
operator|!=
name|bp
operator|->
name|alias
operator|->
name|assoc
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|assoc
operator|!=
literal|0
operator|&&
name|bp
operator|->
name|alias
operator|->
name|assoc
operator|!=
literal|0
operator|&&
name|bp
operator|->
name|user_token_number
operator|==
name|SALIAS
condition|)
name|warnss
argument_list|(
name|_
argument_list|(
literal|"conflicting assoc values for %s and %s"
argument_list|)
argument_list|,
name|bp
operator|->
name|tag
argument_list|,
name|bp
operator|->
name|alias
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|assoc
operator|!=
literal|0
condition|)
name|bp
operator|->
name|alias
operator|->
name|assoc
operator|=
name|bp
operator|->
name|assoc
expr_stmt|;
else|else
name|bp
operator|->
name|assoc
operator|=
name|bp
operator|->
name|alias
operator|->
name|assoc
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|user_token_number
operator|==
name|SALIAS
condition|)
continue|continue;
comment|/* do not do processing below for SALIASs */
block|}
else|else
comment|/* bp->class == STOKEN */
block|{
name|bp
operator|->
name|value
operator|=
name|tokno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|STOKEN
condition|)
block|{
if|if
condition|(
name|translations
operator|&&
operator|!
operator|(
name|bp
operator|->
name|user_token_number
operator|)
condition|)
name|bp
operator|->
name|user_token_number
operator|=
operator|++
name|last_user_token_number
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|user_token_number
operator|>
name|max_user_token_number
condition|)
name|max_user_token_number
operator|=
name|bp
operator|->
name|user_token_number
expr_stmt|;
block|}
name|tags
index|[
name|bp
operator|->
name|value
index|]
operator|=
name|bp
operator|->
name|tag
expr_stmt|;
name|user_toknums
index|[
name|bp
operator|->
name|value
index|]
operator|=
name|bp
operator|->
name|user_token_number
expr_stmt|;
name|sprec
index|[
name|bp
operator|->
name|value
index|]
operator|=
name|bp
operator|->
name|prec
expr_stmt|;
name|sassoc
index|[
name|bp
operator|->
name|value
index|]
operator|=
name|bp
operator|->
name|assoc
expr_stmt|;
block|}
if|if
condition|(
name|translations
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|token_translations
operator|=
name|NEW2
argument_list|(
name|max_user_token_number
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
comment|/* initialize all entries for literal tokens to 2, 	 the internal token number for $undefined., 	 which represents all invalid inputs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_user_token_number
condition|;
name|i
operator|++
control|)
name|token_translations
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|firstsymbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|value
operator|>=
name|ntokens
condition|)
continue|continue;
comment|/* non-terminal */
if|if
condition|(
name|bp
operator|->
name|user_token_number
operator|==
name|SALIAS
condition|)
continue|continue;
if|if
condition|(
name|token_translations
index|[
name|bp
operator|->
name|user_token_number
index|]
operator|!=
literal|2
condition|)
name|warnsss
argument_list|(
name|_
argument_list|(
literal|"tokens %s and %s both assigned number %s"
argument_list|)
argument_list|,
name|tags
index|[
name|token_translations
index|[
name|bp
operator|->
name|user_token_number
index|]
index|]
argument_list|,
name|bp
operator|->
name|tag
argument_list|,
name|int_to_string
argument_list|(
name|bp
operator|->
name|user_token_number
argument_list|)
argument_list|)
expr_stmt|;
name|token_translations
index|[
name|bp
operator|->
name|user_token_number
index|]
operator|=
name|bp
operator|->
name|value
expr_stmt|;
block|}
block|}
name|error_token_number
operator|=
name|errtoken
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|noparserflag
condition|)
name|output_token_defines
argument_list|(
name|ftable
argument_list|)
expr_stmt|;
if|if
condition|(
name|startval
operator|->
name|class
operator|==
name|SUNKNOWN
condition|)
name|fatals
argument_list|(
name|_
argument_list|(
literal|"the start symbol %s is undefined"
argument_list|)
argument_list|,
name|startval
operator|->
name|tag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|startval
operator|->
name|class
operator|==
name|STOKEN
condition|)
name|fatals
argument_list|(
name|_
argument_list|(
literal|"the start symbol %s is a token"
argument_list|)
argument_list|,
name|startval
operator|->
name|tag
argument_list|)
expr_stmt|;
name|start_symbol
operator|=
name|startval
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|definesflag
condition|)
block|{
name|output_token_defines
argument_list|(
name|fdefines
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pure_parser
condition|)
block|{
if|if
condition|(
name|spec_name_prefix
condition|)
name|fprintf
argument_list|(
name|fdefines
argument_list|,
literal|"\nextern YYSTYPE %slval;\n"
argument_list|,
name|spec_name_prefix
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdefines
argument_list|,
literal|"\nextern YYSTYPE yylval;\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|semantic_parser
condition|)
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
comment|/* don't make these for dummy nonterminals made by gensym.  */
if|if
condition|(
operator|*
name|tags
index|[
name|i
index|]
operator|!=
literal|'@'
condition|)
name|fprintf
argument_list|(
name|fdefines
argument_list|,
literal|"#define\tNT%s\t%d\n"
argument_list|,
name|tags
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* `fdefines' is now a temporary file, so we need to copy its          contents in `done', so we can't close it here.  */
block|fclose(fdefines);       fdefines = NULL;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* For named tokens, but not literal ones, define the name.    The value is the user token number. */
end_comment

begin_function
name|void
name|output_token_defines
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|bucket
modifier|*
name|bp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|symbol
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|firstsymbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
name|symbol
operator|=
name|bp
operator|->
name|tag
expr_stmt|;
comment|/* get symbol */
if|if
condition|(
name|bp
operator|->
name|value
operator|>=
name|ntokens
condition|)
continue|continue;
if|if
condition|(
name|bp
operator|->
name|user_token_number
operator|==
name|SALIAS
condition|)
continue|continue;
if|if
condition|(
literal|'\''
operator|==
operator|*
name|symbol
condition|)
continue|continue;
comment|/* skip literal character */
if|if
condition|(
name|bp
operator|==
name|errtoken
condition|)
continue|continue;
comment|/* skip error token */
if|if
condition|(
literal|'\"'
operator|==
operator|*
name|symbol
condition|)
block|{
comment|/* use literal string only if given a symbol with an alias */
if|if
condition|(
name|bp
operator|->
name|alias
condition|)
name|symbol
operator|=
name|bp
operator|->
name|alias
operator|->
name|tag
expr_stmt|;
else|else
continue|continue;
block|}
comment|/* Don't #define nonliteral tokens whose names contain periods.  */
name|cp
operator|=
name|symbol
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|++
operator|)
operator|&&
name|c
operator|!=
literal|'.'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"#define\t%s\t%d\n"
argument_list|,
name|symbol
argument_list|,
operator|(
operator|(
name|translations
operator|&&
operator|!
name|rawtoknumflag
operator|)
condition|?
name|bp
operator|->
name|user_token_number
else|:
name|bp
operator|->
name|value
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|semantic_parser
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"#define\tT%s\t%d\n"
argument_list|,
name|symbol
argument_list|,
name|bp
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* convert the rules into the representation using rrhs, rlhs and ritems.  */
end_comment

begin_function
name|void
name|packgram
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|itemno
decl_stmt|;
specifier|register
name|int
name|ruleno
decl_stmt|;
specifier|register
name|symbol_list
modifier|*
name|p
decl_stmt|;
comment|/*  register bucket *bp; JF unused */
name|bucket
modifier|*
name|ruleprec
decl_stmt|;
name|ritem
operator|=
name|NEW2
argument_list|(
name|nitems
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|rlhs
operator|=
name|NEW2
argument_list|(
name|nrules
argument_list|,
name|short
argument_list|)
operator|-
literal|1
expr_stmt|;
name|rrhs
operator|=
name|NEW2
argument_list|(
name|nrules
argument_list|,
name|short
argument_list|)
operator|-
literal|1
expr_stmt|;
name|rprec
operator|=
name|NEW2
argument_list|(
name|nrules
argument_list|,
name|short
argument_list|)
operator|-
literal|1
expr_stmt|;
name|rprecsym
operator|=
name|NEW2
argument_list|(
name|nrules
argument_list|,
name|short
argument_list|)
operator|-
literal|1
expr_stmt|;
name|rassoc
operator|=
name|NEW2
argument_list|(
name|nrules
argument_list|,
name|short
argument_list|)
operator|-
literal|1
expr_stmt|;
name|itemno
operator|=
literal|0
expr_stmt|;
name|ruleno
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|grammar
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|rlhs
index|[
name|ruleno
index|]
operator|=
name|p
operator|->
name|sym
operator|->
name|value
expr_stmt|;
name|rrhs
index|[
name|ruleno
index|]
operator|=
name|itemno
expr_stmt|;
name|ruleprec
operator|=
name|p
operator|->
name|ruleprec
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|sym
condition|)
block|{
name|ritem
index|[
name|itemno
operator|++
index|]
operator|=
name|p
operator|->
name|sym
operator|->
name|value
expr_stmt|;
comment|/* A rule gets by default the precedence and associativity 	     of the last token in it.  */
if|if
condition|(
name|p
operator|->
name|sym
operator|->
name|class
operator|==
name|STOKEN
condition|)
block|{
name|rprec
index|[
name|ruleno
index|]
operator|=
name|p
operator|->
name|sym
operator|->
name|prec
expr_stmt|;
name|rassoc
index|[
name|ruleno
index|]
operator|=
name|p
operator|->
name|sym
operator|->
name|assoc
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
comment|/* If this rule has a %prec, 	 the specified symbol's precedence replaces the default.  */
if|if
condition|(
name|ruleprec
condition|)
block|{
name|rprec
index|[
name|ruleno
index|]
operator|=
name|ruleprec
operator|->
name|prec
expr_stmt|;
name|rassoc
index|[
name|ruleno
index|]
operator|=
name|ruleprec
operator|->
name|assoc
expr_stmt|;
name|rprecsym
index|[
name|ruleno
index|]
operator|=
name|ruleprec
operator|->
name|value
expr_stmt|;
block|}
name|ritem
index|[
name|itemno
operator|++
index|]
operator|=
operator|-
name|ruleno
expr_stmt|;
name|ruleno
operator|++
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|ritem
index|[
name|itemno
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a signed integer from STREAM and return its value.  */
end_comment

begin_function
name|int
name|read_signed_integer
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
specifier|register
name|int
name|c
init|=
name|getc
argument_list|(
name|stream
argument_list|)
decl_stmt|;
specifier|register
name|int
name|sign
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
name|n
operator|*
name|sign
return|;
block|}
end_function

end_unit

