begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compute look-ahead criteria for bison,    Copyright (C) 1984, 1986, 1989 Free Software Foundation, Inc.  This file is part of Bison, the GNU Compiler Compiler.  Bison is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Bison is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bison; see the file COPYING.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Compute how to make the finite state machine deterministic;  find which rules need lookahead in each state, and which lookahead tokens they accept.  lalr(), the entry point, builds these data structures:  goto_map, from_state and to_state   record each shift transition which accepts a variable (a nonterminal). ngotos is the number of such transitions. from_state[t] is the state number which a transition leads from and to_state[t] is the state number it leads to. All the transitions that accept a particular variable are grouped together and goto_map[i - ntokens] is the index in from_state and to_state of the first of them.  consistent[s] is nonzero if no lookahead is needed to decide what to do in state s.  LAruleno is a vector which records the rules that need lookahead in various states. The elements of LAruleno that apply to state s are those from  lookaheads[s] through lookaheads[s+1]-1. Each element of LAruleno is a rule number.  If lr is the length of LAruleno, then a number from 0 to lr-1  can specify both a rule and a state where the rule might be applied.  LA is a lr by ntokens matrix of bits. LA[l, i] is 1 if the rule LAruleno[l] is applicable in the appropriate state  when the next token is symbol i. If LA[l, i] and LA[l, j] are both 1 for i != j, it is a conflict. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_decl_stmt
specifier|extern
name|short
modifier|*
modifier|*
name|derives
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|nullable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tokensetsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|lookaheads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|LAruleno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
modifier|*
name|LA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|accessing_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|consistent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|core
modifier|*
modifier|*
name|state_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|shifts
modifier|*
modifier|*
name|shift_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|reductions
modifier|*
modifier|*
name|reduction_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|goto_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|from_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|to_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|lalr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
modifier|*
name|transpose
name|PARAMS
argument_list|(
operator|(
name|short
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_state_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_accessing_symbol
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_shift_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_reduction_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_maxrhs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|initialize_LA
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_goto_map
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|map_goto
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|initialize_F
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|build_relations
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|add_lookback_edge
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|compute_FOLLOWS
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|compute_lookaheads
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|digraph
name|PARAMS
argument_list|(
operator|(
name|short
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|traverse
name|PARAMS
argument_list|(
operator|(
specifier|register
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|toomany
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|berror
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|infinity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxrhs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ngotos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|F
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|includes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|shorts
modifier|*
modifier|*
name|lookback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|R
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|INDEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|VERTICES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|top
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|lalr
parameter_list|(
name|void
parameter_list|)
block|{
name|tokensetsize
operator|=
name|WORDSIZE
argument_list|(
name|ntokens
argument_list|)
expr_stmt|;
name|set_state_table
argument_list|()
expr_stmt|;
name|set_accessing_symbol
argument_list|()
expr_stmt|;
name|set_shift_table
argument_list|()
expr_stmt|;
name|set_reduction_table
argument_list|()
expr_stmt|;
name|set_maxrhs
argument_list|()
expr_stmt|;
name|initialize_LA
argument_list|()
expr_stmt|;
name|set_goto_map
argument_list|()
expr_stmt|;
name|initialize_F
argument_list|()
expr_stmt|;
name|build_relations
argument_list|()
expr_stmt|;
name|compute_FOLLOWS
argument_list|()
expr_stmt|;
name|compute_lookaheads
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_state_table
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|core
modifier|*
name|sp
decl_stmt|;
name|state_table
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|core
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_state
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|state_table
index|[
name|sp
operator|->
name|number
index|]
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_accessing_symbol
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|core
modifier|*
name|sp
decl_stmt|;
name|accessing_symbol
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_state
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|accessing_symbol
index|[
name|sp
operator|->
name|number
index|]
operator|=
name|sp
operator|->
name|accessing_symbol
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_shift_table
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
name|shift_table
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|shifts
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_shift
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|shift_table
index|[
name|sp
operator|->
name|number
index|]
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_reduction_table
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|reductions
modifier|*
name|rp
decl_stmt|;
name|reduction_table
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|reductions
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|first_reduction
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
name|reduction_table
index|[
name|rp
operator|->
name|number
index|]
operator|=
name|rp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_maxrhs
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|short
modifier|*
name|itemp
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|itemp
operator|=
name|ritem
init|;
operator|*
name|itemp
condition|;
name|itemp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|itemp
operator|>
literal|0
condition|)
block|{
name|length
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|length
operator|>
name|max
condition|)
name|max
operator|=
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|maxrhs
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_function
name|void
name|initialize_LA
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|reductions
modifier|*
name|rp
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
specifier|register
name|short
modifier|*
name|np
decl_stmt|;
name|consistent
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|lookaheads
operator|=
name|NEW2
argument_list|(
name|nstates
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|lookaheads
index|[
name|i
index|]
operator|=
name|count
expr_stmt|;
name|rp
operator|=
name|reduction_table
index|[
name|i
index|]
expr_stmt|;
name|sp
operator|=
name|shift_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rp
operator|&&
operator|(
name|rp
operator|->
name|nreds
operator|>
literal|1
operator|||
operator|(
name|sp
operator|&&
operator|!
name|ISVAR
argument_list|(
name|accessing_symbol
index|[
name|sp
operator|->
name|shifts
index|[
literal|0
index|]
index|]
argument_list|)
operator|)
operator|)
condition|)
name|count
operator|+=
name|rp
operator|->
name|nreds
expr_stmt|;
else|else
name|consistent
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sp
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|sp
operator|->
name|nshifts
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|accessing_symbol
index|[
name|sp
operator|->
name|shifts
index|[
name|k
index|]
index|]
operator|==
name|error_token_number
condition|)
block|{
name|consistent
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
name|lookaheads
index|[
name|nstates
index|]
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|LA
operator|=
name|NEW2
argument_list|(
literal|1
operator|*
name|tokensetsize
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|LAruleno
operator|=
name|NEW2
argument_list|(
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|lookback
operator|=
name|NEW2
argument_list|(
literal|1
argument_list|,
name|shorts
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LA
operator|=
name|NEW2
argument_list|(
name|count
operator|*
name|tokensetsize
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|LAruleno
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|lookback
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|shorts
operator|*
argument_list|)
expr_stmt|;
block|}
name|np
operator|=
name|LAruleno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|consistent
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|rp
operator|=
name|reduction_table
index|[
name|i
index|]
operator|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rp
operator|->
name|nreds
condition|;
name|j
operator|++
control|)
operator|*
name|np
operator|++
operator|=
name|rp
operator|->
name|rules
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|set_goto_map
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|short
modifier|*
name|temp_map
decl_stmt|;
specifier|register
name|int
name|state2
decl_stmt|;
specifier|register
name|int
name|state1
decl_stmt|;
name|goto_map
operator|=
name|NEW2
argument_list|(
name|nvars
operator|+
literal|1
argument_list|,
name|short
argument_list|)
operator|-
name|ntokens
expr_stmt|;
name|temp_map
operator|=
name|NEW2
argument_list|(
name|nvars
operator|+
literal|1
argument_list|,
name|short
argument_list|)
operator|-
name|ntokens
expr_stmt|;
name|ngotos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_shift
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
name|sp
operator|->
name|nshifts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|symbol
operator|=
name|accessing_symbol
index|[
name|sp
operator|->
name|shifts
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ISTOKEN
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ngotos
operator|==
name|MAXSHORT
condition|)
name|toomany
argument_list|(
name|_
argument_list|(
literal|"gotos"
argument_list|)
argument_list|)
expr_stmt|;
name|ngotos
operator|++
expr_stmt|;
name|goto_map
index|[
name|symbol
index|]
operator|++
expr_stmt|;
block|}
block|}
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|temp_map
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
name|k
operator|+=
name|goto_map
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
name|goto_map
index|[
name|i
index|]
operator|=
name|temp_map
index|[
name|i
index|]
expr_stmt|;
name|goto_map
index|[
name|nsyms
index|]
operator|=
name|ngotos
expr_stmt|;
name|temp_map
index|[
name|nsyms
index|]
operator|=
name|ngotos
expr_stmt|;
name|from_state
operator|=
name|NEW2
argument_list|(
name|ngotos
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|to_state
operator|=
name|NEW2
argument_list|(
name|ngotos
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_shift
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|state1
operator|=
name|sp
operator|->
name|number
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sp
operator|->
name|nshifts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|state2
operator|=
name|sp
operator|->
name|shifts
index|[
name|i
index|]
expr_stmt|;
name|symbol
operator|=
name|accessing_symbol
index|[
name|state2
index|]
expr_stmt|;
if|if
condition|(
name|ISTOKEN
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
name|k
operator|=
name|temp_map
index|[
name|symbol
index|]
operator|++
expr_stmt|;
name|from_state
index|[
name|k
index|]
operator|=
name|state1
expr_stmt|;
name|to_state
index|[
name|k
index|]
operator|=
name|state2
expr_stmt|;
block|}
block|}
name|FREE
argument_list|(
name|temp_map
operator|+
name|ntokens
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Map_goto maps a state/symbol pair into its numeric representation.	*/
end_comment

begin_function
name|int
name|map_goto
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|symbol
parameter_list|)
block|{
specifier|register
name|int
name|high
decl_stmt|;
specifier|register
name|int
name|low
decl_stmt|;
specifier|register
name|int
name|middle
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|low
operator|=
name|goto_map
index|[
name|symbol
index|]
expr_stmt|;
name|high
operator|=
name|goto_map
index|[
name|symbol
operator|+
literal|1
index|]
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|s
operator|=
name|from_state
index|[
name|middle
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|state
condition|)
return|return
operator|(
name|middle
operator|)
return|;
elseif|else
if|if
condition|(
name|s
operator|<
name|state
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
block|}
name|berror
argument_list|(
literal|"map_goto"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|initialize_F
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
specifier|register
name|short
modifier|*
name|edge
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|rowp
decl_stmt|;
specifier|register
name|short
modifier|*
name|rp
decl_stmt|;
specifier|register
name|short
modifier|*
modifier|*
name|reads
decl_stmt|;
specifier|register
name|int
name|nedges
decl_stmt|;
specifier|register
name|int
name|stateno
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
specifier|register
name|int
name|nwords
decl_stmt|;
name|nwords
operator|=
name|ngotos
operator|*
name|tokensetsize
expr_stmt|;
name|F
operator|=
name|NEW2
argument_list|(
name|nwords
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|reads
operator|=
name|NEW2
argument_list|(
name|ngotos
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|edge
operator|=
name|NEW2
argument_list|(
name|ngotos
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|nedges
operator|=
literal|0
expr_stmt|;
name|rowp
operator|=
name|F
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
block|{
name|stateno
operator|=
name|to_state
index|[
name|i
index|]
expr_stmt|;
name|sp
operator|=
name|shift_table
index|[
name|stateno
index|]
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
name|k
operator|=
name|sp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|symbol
operator|=
name|accessing_symbol
index|[
name|sp
operator|->
name|shifts
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
name|SETBIT
argument_list|(
name|rowp
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|symbol
operator|=
name|accessing_symbol
index|[
name|sp
operator|->
name|shifts
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|nullable
index|[
name|symbol
index|]
condition|)
name|edge
index|[
name|nedges
operator|++
index|]
operator|=
name|map_goto
argument_list|(
name|stateno
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nedges
condition|)
block|{
name|reads
index|[
name|i
index|]
operator|=
name|rp
operator|=
name|NEW2
argument_list|(
name|nedges
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nedges
condition|;
name|j
operator|++
control|)
name|rp
index|[
name|j
index|]
operator|=
name|edge
index|[
name|j
index|]
expr_stmt|;
name|rp
index|[
name|nedges
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nedges
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|rowp
operator|+=
name|tokensetsize
expr_stmt|;
block|}
name|digraph
argument_list|(
name|reads
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reads
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|reads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|reads
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|build_relations
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|short
modifier|*
name|rulep
decl_stmt|;
specifier|register
name|short
modifier|*
name|rp
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|nedges
decl_stmt|;
specifier|register
name|int
name|done
decl_stmt|;
specifier|register
name|int
name|state1
decl_stmt|;
specifier|register
name|int
name|stateno
decl_stmt|;
specifier|register
name|int
name|symbol1
decl_stmt|;
specifier|register
name|int
name|symbol2
decl_stmt|;
specifier|register
name|short
modifier|*
name|shortp
decl_stmt|;
specifier|register
name|short
modifier|*
name|edge
decl_stmt|;
specifier|register
name|short
modifier|*
name|states
decl_stmt|;
specifier|register
name|short
modifier|*
modifier|*
name|new_includes
decl_stmt|;
name|includes
operator|=
name|NEW2
argument_list|(
name|ngotos
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|edge
operator|=
name|NEW2
argument_list|(
name|ngotos
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|states
operator|=
name|NEW2
argument_list|(
name|maxrhs
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
block|{
name|nedges
operator|=
literal|0
expr_stmt|;
name|state1
operator|=
name|from_state
index|[
name|i
index|]
expr_stmt|;
name|symbol1
operator|=
name|accessing_symbol
index|[
name|to_state
index|[
name|i
index|]
index|]
expr_stmt|;
for|for
control|(
name|rulep
operator|=
name|derives
index|[
name|symbol1
index|]
init|;
operator|*
name|rulep
operator|>
literal|0
condition|;
name|rulep
operator|++
control|)
block|{
name|length
operator|=
literal|1
expr_stmt|;
name|states
index|[
literal|0
index|]
operator|=
name|state1
expr_stmt|;
name|stateno
operator|=
name|state1
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|ritem
operator|+
name|rrhs
index|[
operator|*
name|rulep
index|]
init|;
operator|*
name|rp
operator|>
literal|0
condition|;
name|rp
operator|++
control|)
block|{
name|symbol2
operator|=
operator|*
name|rp
expr_stmt|;
name|sp
operator|=
name|shift_table
index|[
name|stateno
index|]
expr_stmt|;
name|k
operator|=
name|sp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|stateno
operator|=
name|sp
operator|->
name|shifts
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|accessing_symbol
index|[
name|stateno
index|]
operator|==
name|symbol2
condition|)
break|break;
block|}
name|states
index|[
name|length
operator|++
index|]
operator|=
name|stateno
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|consistent
index|[
name|stateno
index|]
condition|)
name|add_lookback_edge
argument_list|(
name|stateno
argument_list|,
operator|*
name|rulep
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|length
operator|--
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
name|rp
operator|--
expr_stmt|;
comment|/* JF added rp>=ritem&&   I hope to god its right! */
if|if
condition|(
name|rp
operator|>=
name|ritem
operator|&&
name|ISVAR
argument_list|(
operator|*
name|rp
argument_list|)
condition|)
block|{
name|stateno
operator|=
name|states
index|[
operator|--
name|length
index|]
expr_stmt|;
name|edge
index|[
name|nedges
operator|++
index|]
operator|=
name|map_goto
argument_list|(
name|stateno
argument_list|,
operator|*
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullable
index|[
operator|*
name|rp
index|]
condition|)
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nedges
condition|)
block|{
name|includes
index|[
name|i
index|]
operator|=
name|shortp
operator|=
name|NEW2
argument_list|(
name|nedges
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nedges
condition|;
name|j
operator|++
control|)
name|shortp
index|[
name|j
index|]
operator|=
name|edge
index|[
name|j
index|]
expr_stmt|;
name|shortp
index|[
name|nedges
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|new_includes
operator|=
name|transpose
argument_list|(
name|includes
argument_list|,
name|ngotos
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|includes
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|includes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|includes
argument_list|)
expr_stmt|;
name|includes
operator|=
name|new_includes
expr_stmt|;
name|FREE
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|states
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_lookback_edge
parameter_list|(
name|int
name|stateno
parameter_list|,
name|int
name|ruleno
parameter_list|,
name|int
name|gotono
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|found
decl_stmt|;
specifier|register
name|shorts
modifier|*
name|sp
decl_stmt|;
name|i
operator|=
name|lookaheads
index|[
name|stateno
index|]
expr_stmt|;
name|k
operator|=
name|lookaheads
index|[
name|stateno
operator|+
literal|1
index|]
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|found
operator|&&
name|i
operator|<
name|k
condition|)
block|{
if|if
condition|(
name|LAruleno
index|[
name|i
index|]
operator|==
name|ruleno
condition|)
name|found
operator|=
literal|1
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
name|berror
argument_list|(
literal|"add_lookback_edge"
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NEW
argument_list|(
name|shorts
argument_list|)
expr_stmt|;
name|sp
operator|->
name|next
operator|=
name|lookback
index|[
name|i
index|]
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|gotono
expr_stmt|;
name|lookback
index|[
name|i
index|]
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_function
name|short
modifier|*
modifier|*
name|transpose
parameter_list|(
name|short
modifier|*
modifier|*
name|R_arg
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|register
name|short
modifier|*
modifier|*
name|new_R
decl_stmt|;
specifier|register
name|short
modifier|*
modifier|*
name|temp_R
decl_stmt|;
specifier|register
name|short
modifier|*
name|nedges
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|nedges
operator|=
name|NEW2
argument_list|(
name|n
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|R_arg
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
while|while
condition|(
operator|*
name|sp
operator|>=
literal|0
condition|)
name|nedges
index|[
operator|*
name|sp
operator|++
index|]
operator|++
expr_stmt|;
block|}
block|}
name|new_R
operator|=
name|NEW2
argument_list|(
name|n
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|temp_R
operator|=
name|NEW2
argument_list|(
name|n
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|k
operator|=
name|nedges
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|sp
operator|=
name|NEW2
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|new_R
index|[
name|i
index|]
operator|=
name|sp
expr_stmt|;
name|temp_R
index|[
name|i
index|]
operator|=
name|sp
expr_stmt|;
name|sp
index|[
name|k
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|FREE
argument_list|(
name|nedges
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|R_arg
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
while|while
condition|(
operator|*
name|sp
operator|>=
literal|0
condition|)
operator|*
name|temp_R
index|[
operator|*
name|sp
operator|++
index|]
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
name|FREE
argument_list|(
name|temp_R
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_R
operator|)
return|;
block|}
end_function

begin_function
name|void
name|compute_FOLLOWS
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|digraph
argument_list|(
name|includes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|includes
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|includes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|includes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compute_lookaheads
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp1
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp2
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp3
decl_stmt|;
specifier|register
name|shorts
modifier|*
name|sp
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|rowp
decl_stmt|;
comment|/*   register short *rulep; JF unused */
comment|/*  register int count; JF unused */
specifier|register
name|shorts
modifier|*
name|sptmp
decl_stmt|;
comment|/* JF */
name|rowp
operator|=
name|LA
expr_stmt|;
name|n
operator|=
name|lookaheads
index|[
name|nstates
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|fp3
operator|=
name|rowp
operator|+
name|tokensetsize
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|lookback
index|[
name|i
index|]
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|fp1
operator|=
name|rowp
expr_stmt|;
name|fp2
operator|=
name|F
operator|+
name|tokensetsize
operator|*
name|sp
operator|->
name|value
expr_stmt|;
while|while
condition|(
name|fp1
operator|<
name|fp3
condition|)
operator|*
name|fp1
operator|++
operator||=
operator|*
name|fp2
operator|++
expr_stmt|;
block|}
name|rowp
operator|=
name|fp3
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* JF removed ref to freed storage */
for|for
control|(
name|sp
operator|=
name|lookback
index|[
name|i
index|]
init|;
name|sp
condition|;
name|sp
operator|=
name|sptmp
control|)
block|{
name|sptmp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
name|FREE
argument_list|(
name|lookback
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|F
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|digraph
parameter_list|(
name|short
modifier|*
modifier|*
name|relation
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|infinity
operator|=
name|ngotos
operator|+
literal|2
expr_stmt|;
name|INDEX
operator|=
name|NEW2
argument_list|(
name|ngotos
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|VERTICES
operator|=
name|NEW2
argument_list|(
name|ngotos
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|R
operator|=
name|relation
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
name|INDEX
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|INDEX
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|R
index|[
name|i
index|]
condition|)
name|traverse
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|INDEX
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|VERTICES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|traverse
parameter_list|(
specifier|register
name|int
name|i
parameter_list|)
block|{
specifier|register
name|unsigned
modifier|*
name|fp1
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp2
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp3
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|short
modifier|*
name|rp
decl_stmt|;
name|int
name|height
decl_stmt|;
name|unsigned
modifier|*
name|base
decl_stmt|;
name|VERTICES
index|[
operator|++
name|top
index|]
operator|=
name|i
expr_stmt|;
name|INDEX
index|[
name|i
index|]
operator|=
name|height
operator|=
name|top
expr_stmt|;
name|base
operator|=
name|F
operator|+
name|i
operator|*
name|tokensetsize
expr_stmt|;
name|fp3
operator|=
name|base
operator|+
name|tokensetsize
expr_stmt|;
name|rp
operator|=
name|R
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rp
condition|)
block|{
while|while
condition|(
operator|(
name|j
operator|=
operator|*
name|rp
operator|++
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|INDEX
index|[
name|j
index|]
operator|==
literal|0
condition|)
name|traverse
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX
index|[
name|i
index|]
operator|>
name|INDEX
index|[
name|j
index|]
condition|)
name|INDEX
index|[
name|i
index|]
operator|=
name|INDEX
index|[
name|j
index|]
expr_stmt|;
name|fp1
operator|=
name|base
expr_stmt|;
name|fp2
operator|=
name|F
operator|+
name|j
operator|*
name|tokensetsize
expr_stmt|;
while|while
condition|(
name|fp1
operator|<
name|fp3
condition|)
operator|*
name|fp1
operator|++
operator||=
operator|*
name|fp2
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|INDEX
index|[
name|i
index|]
operator|==
name|height
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|j
operator|=
name|VERTICES
index|[
name|top
operator|--
index|]
expr_stmt|;
name|INDEX
index|[
name|j
index|]
operator|=
name|infinity
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
condition|)
break|break;
name|fp1
operator|=
name|base
expr_stmt|;
name|fp2
operator|=
name|F
operator|+
name|j
operator|*
name|tokensetsize
expr_stmt|;
while|while
condition|(
name|fp1
operator|<
name|fp3
condition|)
operator|*
name|fp2
operator|++
operator|=
operator|*
name|fp1
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

