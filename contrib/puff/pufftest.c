begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * pufftest.c  * Copyright (C) 2002-2013 Mark Adler  * For conditions of distribution and use, see copyright notice in puff.h  * version 2.3, 21 Jan 2013  */
end_comment

begin_comment
comment|/* Example of how to use puff().     Usage: puff [-w] [-f] [-nnn] file           ... | puff [-w] [-f] [-nnn]     where file is the input file with deflate data, nnn is the number of bytes    of input to skip before inflating (e.g. to skip a zlib or gzip header), and    -w is used to write the decompressed data to stdout.  -f is for coverage    testing, and causes pufftest to fail with not enough output space (-f does    a write like -w, so -w is not required). */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"puff.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|file
parameter_list|)
value|setmode(fileno(file), O_BINARY)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|file
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_comment
comment|/* Return size times approximately the cube root of 2, keeping the result as 1,    3, or 5 times a power of 2 -- the result is always> size, until the result    is the maximum value of an unsigned long, where it remains.  This is useful    to keep reallocations less than ~33% over the actual data. */
end_comment

begin_function
name|local
name|size_t
name|bythirds
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|size_t
name|m
decl_stmt|;
name|m
operator|=
name|size
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|m
condition|;
name|n
operator|++
control|)
name|m
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|3
condition|)
return|return
name|size
operator|+
literal|1
return|;
name|n
operator|-=
literal|3
expr_stmt|;
name|m
operator|=
name|size
operator|>>
name|n
expr_stmt|;
name|m
operator|+=
name|m
operator|==
literal|6
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|m
operator|<<=
name|n
expr_stmt|;
return|return
name|m
operator|>
name|size
condition|?
name|m
else|:
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the input file *name, or stdin if name is NULL, into allocated memory.    Reallocate to larger buffers until the entire file is read in.  Return a    pointer to the allocated data, or NULL if there was a memory allocation    failure.  *len is the number of bytes of data read from the input file (even    if load() returns NULL).  If the input file was empty or could not be opened    or read, *len is zero. */
end_comment

begin_function
name|local
name|void
modifier|*
name|load
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|,
modifier|*
name|swap
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|size
operator|=
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|in
operator|=
name|name
operator|==
name|NULL
condition|?
name|stdin
else|:
name|fopen
argument_list|(
name|name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|len
operator|+=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
operator|*
name|len
argument_list|,
literal|1
argument_list|,
name|size
operator|-
operator|*
name|len
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|len
operator|<
name|size
condition|)
break|break;
name|size
operator|=
name|bythirds
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
operator|*
name|len
operator|||
operator|(
name|swap
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|buf
operator|=
name|swap
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|put
init|=
literal|0
decl_stmt|,
name|fail
init|=
literal|0
decl_stmt|;
name|unsigned
name|skip
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|source
init|=
name|NULL
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|sourcelen
decl_stmt|,
name|destlen
decl_stmt|;
comment|/* process arguments */
while|while
condition|(
name|arg
operator|=
operator|*
operator|++
name|argv
operator|,
operator|--
name|argc
condition|)
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'w'
operator|&&
name|arg
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|put
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|arg
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|fail
operator|=
literal|1
operator|,
name|put
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|arg
index|[
literal|1
index|]
operator|<=
literal|'9'
condition|)
name|skip
operator|=
operator|(
name|unsigned
operator|)
name|atoi
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid option %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"only one file name allowed\n"
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
else|else
name|name
operator|=
name|arg
expr_stmt|;
name|source
operator|=
name|load
argument_list|(
name|name
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"memory allocation failure\n"
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not read %s, or it was empty\n"
argument_list|,
name|name
operator|==
name|NULL
condition|?
literal|"<stdin>"
else|:
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|source
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|skip
operator|>=
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"skip request of %d leaves no input\n"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|source
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
comment|/* test inflate data with offset skip */
name|len
operator|-=
name|skip
expr_stmt|;
name|sourcelen
operator|=
operator|(
name|unsigned
name|long
operator|)
name|len
expr_stmt|;
name|ret
operator|=
name|puff
argument_list|(
name|NIL
argument_list|,
operator|&
name|destlen
argument_list|,
name|source
operator|+
name|skip
argument_list|,
operator|&
name|sourcelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"puff() failed with return code %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"puff() succeeded uncompressing %lu bytes\n"
argument_list|,
name|destlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourcelen
operator|<
name|len
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu compressed bytes unused\n"
argument_list|,
name|len
operator|-
name|sourcelen
argument_list|)
expr_stmt|;
block|}
comment|/* if requested, inflate again and write decompressd data to stdout */
if|if
condition|(
name|put
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fail
condition|)
name|destlen
operator|>>=
literal|1
expr_stmt|;
name|dest
operator|=
name|malloc
argument_list|(
name|destlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"memory allocation failure\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|source
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
name|puff
argument_list|(
name|dest
argument_list|,
operator|&
name|destlen
argument_list|,
name|source
operator|+
name|skip
argument_list|,
operator|&
name|sourcelen
argument_list|)
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|,
name|destlen
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
comment|/* clean up */
name|free
argument_list|(
name|source
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

