begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * puff.c  * Copyright (C) 2002-2013 Mark Adler  * For conditions of distribution and use, see copyright notice in puff.h  * version 2.3, 21 Jan 2013  *  * puff.c is a simple inflate written to be an unambiguous way to specify the  * deflate format.  It is not written for speed but rather simplicity.  As a  * side benefit, this code might actually be useful when small code is more  * important than speed, such as bootstrap applications.  For typical deflate  * data, zlib's inflate() is about four times as fast as puff().  zlib's  * inflate compiles to around 20K on my machine, whereas puff.c compiles to  * around 4K on my machine (a PowerPC using GNU cc).  If the faster decode()  * function here is used, then puff() is only twice as slow as zlib's  * inflate().  *  * All dynamically allocated memory comes from the stack.  The stack required  * is less than 2K bytes.  This code is compatible with 16-bit int's and  * assumes that long's are at least 32 bits.  puff.c uses the short data type,  * assumed to be 16 bits, for arrays in order to to conserve memory.  The code  * works whether integers are stored big endian or little endian.  *  * In the comments below are "Format notes" that describe the inflate process  * and document some of the less obvious aspects of the format.  This source  * code is meant to supplement RFC 1951, which formally describes the deflate  * format:  *  *    http://www.zlib.org/rfc-deflate.html  */
end_comment

begin_comment
comment|/*  * Change history:  *  * 1.0  10 Feb 2002     - First version  * 1.1  17 Feb 2002     - Clarifications of some comments and notes  *                      - Update puff() dest and source pointers on negative  *                        errors to facilitate debugging deflators  *                      - Remove longest from struct huffman -- not needed  *                      - Simplify offs[] index in construct()  *                      - Add input size and checking, using longjmp() to  *                        maintain easy readability  *                      - Use short data type for large arrays  *                      - Use pointers instead of long to specify source and  *                        destination sizes to avoid arbitrary 4 GB limits  * 1.2  17 Mar 2002     - Add faster version of decode(), doubles speed (!),  *                        but leave simple version for readabilty  *                      - Make sure invalid distances detected if pointers  *                        are 16 bits  *                      - Fix fixed codes table error  *                      - Provide a scanning mode for determining size of  *                        uncompressed data  * 1.3  20 Mar 2002     - Go back to lengths for puff() parameters [Gailly]  *                      - Add a puff.h file for the interface  *                      - Add braces in puff() for else do [Gailly]  *                      - Use indexes instead of pointers for readability  * 1.4  31 Mar 2002     - Simplify construct() code set check  *                      - Fix some comments  *                      - Add FIXLCODES #define  * 1.5   6 Apr 2002     - Minor comment fixes  * 1.6   7 Aug 2002     - Minor format changes  * 1.7   3 Mar 2003     - Added test code for distribution  *                      - Added zlib-like license  * 1.8   9 Jan 2004     - Added some comments on no distance codes case  * 1.9  21 Feb 2008     - Fix bug on 16-bit integer architectures [Pohland]  *                      - Catch missing end-of-block symbol error  * 2.0  25 Jul 2008     - Add #define to permit distance too far back  *                      - Add option in TEST code for puff to write the data  *                      - Add option in TEST code to skip input bytes  *                      - Allow TEST code to read from piped stdin  * 2.1   4 Apr 2010     - Avoid variable initialization for happier compilers  *                      - Avoid unsigned comparisons for even happier compilers  * 2.2  25 Apr 2010     - Fix bug in variable initializations [Oberhumer]  *                      - Add const where appropriate [Oberhumer]  *                      - Split if's and ?'s for coverage testing  *                      - Break out test code to separate file  *                      - Move NIL to puff.h  *                      - Allow incomplete code only if single code length is 1  *                      - Add full code coverage test to Makefile  * 2.3  21 Jan 2013     - Check for invalid code length codes in dynamic blocks  */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* for setjmp(), longjmp(), and jmp_buf */
end_comment

begin_include
include|#
directive|include
file|"puff.h"
end_include

begin_comment
comment|/* prototype for puff() */
end_comment

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_comment
comment|/* for local function definitions */
end_comment

begin_comment
comment|/*  * Maximums for allocations and loops.  It is not useful to change these --  * they are fixed by the deflate format.  */
end_comment

begin_define
define|#
directive|define
name|MAXBITS
value|15
end_define

begin_comment
comment|/* maximum bits in a code */
end_comment

begin_define
define|#
directive|define
name|MAXLCODES
value|286
end_define

begin_comment
comment|/* maximum number of literal/length codes */
end_comment

begin_define
define|#
directive|define
name|MAXDCODES
value|30
end_define

begin_comment
comment|/* maximum number of distance codes */
end_comment

begin_define
define|#
directive|define
name|MAXCODES
value|(MAXLCODES+MAXDCODES)
end_define

begin_comment
comment|/* maximum codes lengths to read */
end_comment

begin_define
define|#
directive|define
name|FIXLCODES
value|288
end_define

begin_comment
comment|/* number of fixed literal/length codes */
end_comment

begin_comment
comment|/* input and output state */
end_comment

begin_struct
struct|struct
name|state
block|{
comment|/* output state */
name|unsigned
name|char
modifier|*
name|out
decl_stmt|;
comment|/* output buffer */
name|unsigned
name|long
name|outlen
decl_stmt|;
comment|/* available space at out */
name|unsigned
name|long
name|outcnt
decl_stmt|;
comment|/* bytes written to out so far */
comment|/* input state */
specifier|const
name|unsigned
name|char
modifier|*
name|in
decl_stmt|;
comment|/* input buffer */
name|unsigned
name|long
name|inlen
decl_stmt|;
comment|/* available input at in */
name|unsigned
name|long
name|incnt
decl_stmt|;
comment|/* bytes read so far */
name|int
name|bitbuf
decl_stmt|;
comment|/* bit buffer */
name|int
name|bitcnt
decl_stmt|;
comment|/* number of bits in bit buffer */
comment|/* input limit error return state for bits() and decode() */
name|jmp_buf
name|env
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Return need bits from the input stream.  This always leaves less than  * eight bits in the buffer.  bits() works properly for need == 0.  *  * Format notes:  *  * - Bits are stored in bytes from the least significant bit to the most  *   significant bit.  Therefore bits are dropped from the bottom of the bit  *   buffer, using shift right, and new bytes are appended to the top of the  *   bit buffer, using shift left.  */
end_comment

begin_function
name|local
name|int
name|bits
parameter_list|(
name|struct
name|state
modifier|*
name|s
parameter_list|,
name|int
name|need
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
comment|/* bit accumulator (can use up to 20 bits) */
comment|/* load at least need bits into val */
name|val
operator|=
name|s
operator|->
name|bitbuf
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|bitcnt
operator|<
name|need
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|incnt
operator|==
name|s
operator|->
name|inlen
condition|)
name|longjmp
argument_list|(
name|s
operator|->
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* out of input */
name|val
operator||=
call|(
name|long
call|)
argument_list|(
name|s
operator|->
name|in
index|[
name|s
operator|->
name|incnt
operator|++
index|]
argument_list|)
operator|<<
name|s
operator|->
name|bitcnt
expr_stmt|;
comment|/* load eight bits */
name|s
operator|->
name|bitcnt
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* drop need bits and update buffer, always zero to seven bits left */
name|s
operator|->
name|bitbuf
operator|=
call|(
name|int
call|)
argument_list|(
name|val
operator|>>
name|need
argument_list|)
expr_stmt|;
name|s
operator|->
name|bitcnt
operator|-=
name|need
expr_stmt|;
comment|/* return need bits, zeroing the bits above that */
return|return
call|(
name|int
call|)
argument_list|(
name|val
operator|&
operator|(
operator|(
literal|1L
operator|<<
name|need
operator|)
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a stored block.  *  * Format notes:  *  * - After the two-bit stored block type (00), the stored block length and  *   stored bytes are byte-aligned for fast copying.  Therefore any leftover  *   bits in the byte that has the last bit of the type, as many as seven, are  *   discarded.  The value of the discarded bits are not defined and should not  *   be checked against any expectation.  *  * - The second inverted copy of the stored block length does not have to be  *   checked, but it's probably a good idea to do so anyway.  *  * - A stored block can have zero length.  This is sometimes used to byte-align  *   subsets of the compressed data for random access or partial recovery.  */
end_comment

begin_function
name|local
name|int
name|stored
parameter_list|(
name|struct
name|state
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|len
decl_stmt|;
comment|/* length of stored block */
comment|/* discard leftover bits from current byte (assumes s->bitcnt< 8) */
name|s
operator|->
name|bitbuf
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|bitcnt
operator|=
literal|0
expr_stmt|;
comment|/* get length and check against its one's complement */
if|if
condition|(
name|s
operator|->
name|incnt
operator|+
literal|4
operator|>
name|s
operator|->
name|inlen
condition|)
return|return
literal|2
return|;
comment|/* not enough input */
name|len
operator|=
name|s
operator|->
name|in
index|[
name|s
operator|->
name|incnt
operator|++
index|]
expr_stmt|;
name|len
operator||=
name|s
operator|->
name|in
index|[
name|s
operator|->
name|incnt
operator|++
index|]
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|in
index|[
name|s
operator|->
name|incnt
operator|++
index|]
operator|!=
operator|(
operator|~
name|len
operator|&
literal|0xff
operator|)
operator|||
name|s
operator|->
name|in
index|[
name|s
operator|->
name|incnt
operator|++
index|]
operator|!=
operator|(
operator|(
operator|~
name|len
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
condition|)
return|return
operator|-
literal|2
return|;
comment|/* didn't match complement! */
comment|/* copy len bytes from in to out */
if|if
condition|(
name|s
operator|->
name|incnt
operator|+
name|len
operator|>
name|s
operator|->
name|inlen
condition|)
return|return
literal|2
return|;
comment|/* not enough input */
if|if
condition|(
name|s
operator|->
name|out
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|outcnt
operator|+
name|len
operator|>
name|s
operator|->
name|outlen
condition|)
return|return
literal|1
return|;
comment|/* not enough output space */
while|while
condition|(
name|len
operator|--
condition|)
name|s
operator|->
name|out
index|[
name|s
operator|->
name|outcnt
operator|++
index|]
operator|=
name|s
operator|->
name|in
index|[
name|s
operator|->
name|incnt
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* just scanning */
name|s
operator|->
name|outcnt
operator|+=
name|len
expr_stmt|;
name|s
operator|->
name|incnt
operator|+=
name|len
expr_stmt|;
block|}
comment|/* done with a valid stored block */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of  * each length, which for a canonical code are stepped through in order.  * symbol[] are the symbol values in canonical order, where the number of  * entries is the sum of the counts in count[].  The decoding process can be  * seen in the function decode() below.  */
end_comment

begin_struct
struct|struct
name|huffman
block|{
name|short
modifier|*
name|count
decl_stmt|;
comment|/* number of symbols of each length */
name|short
modifier|*
name|symbol
decl_stmt|;
comment|/* canonically ordered symbols */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Decode a code from the stream s using huffman table h.  Return the symbol or  * a negative value if there is an error.  If all of the lengths are zero, i.e.  * an empty code, or if the code is incomplete and an invalid code is received,  * then -10 is returned after reading MAXBITS bits.  *  * Format notes:  *  * - The codes as stored in the compressed data are bit-reversed relative to  *   a simple integer ordering of codes of the same lengths.  Hence below the  *   bits are pulled from the compressed data one at a time and used to  *   build the code value reversed from what is in the stream in order to  *   permit simple integer comparisons for decoding.  A table-based decoding  *   scheme (as used in zlib) does not need to do this reversal.  *  * - The first code for the shortest length is all zeros.  Subsequent codes of  *   the same length are simply integer increments of the previous code.  When  *   moving up a length, a zero bit is appended to the code.  For a complete  *   code, the last code of the longest length will be all ones.  *  * - Incomplete codes are handled by this decoder, since they are permitted  *   in the deflate format.  See the format notes for fixed() and dynamic().  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SLOW
end_ifdef

begin_function
name|local
name|int
name|decode
parameter_list|(
name|struct
name|state
modifier|*
name|s
parameter_list|,
specifier|const
name|struct
name|huffman
modifier|*
name|h
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* current number of bits in code */
name|int
name|code
decl_stmt|;
comment|/* len bits being decoded */
name|int
name|first
decl_stmt|;
comment|/* first code of length len */
name|int
name|count
decl_stmt|;
comment|/* number of codes of length len */
name|int
name|index
decl_stmt|;
comment|/* index of first code of length len in symbol table */
name|code
operator|=
name|first
operator|=
name|index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|1
init|;
name|len
operator|<=
name|MAXBITS
condition|;
name|len
operator|++
control|)
block|{
name|code
operator||=
name|bits
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* get next bit */
name|count
operator|=
name|h
operator|->
name|count
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|-
name|count
operator|<
name|first
condition|)
comment|/* if length len, return symbol */
return|return
name|h
operator|->
name|symbol
index|[
name|index
operator|+
operator|(
name|code
operator|-
name|first
operator|)
index|]
return|;
name|index
operator|+=
name|count
expr_stmt|;
comment|/* else update for next length */
name|first
operator|+=
name|count
expr_stmt|;
name|first
operator|<<=
literal|1
expr_stmt|;
name|code
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
operator|-
literal|10
return|;
comment|/* ran out of codes */
block|}
end_function

begin_comment
comment|/*  * A faster version of decode() for real applications of this code.   It's not  * as readable, but it makes puff() twice as fast.  And it only makes the code  * a few percent larger.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SLOW */
end_comment

begin_function
name|local
name|int
name|decode
parameter_list|(
name|struct
name|state
modifier|*
name|s
parameter_list|,
specifier|const
name|struct
name|huffman
modifier|*
name|h
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* current number of bits in code */
name|int
name|code
decl_stmt|;
comment|/* len bits being decoded */
name|int
name|first
decl_stmt|;
comment|/* first code of length len */
name|int
name|count
decl_stmt|;
comment|/* number of codes of length len */
name|int
name|index
decl_stmt|;
comment|/* index of first code of length len in symbol table */
name|int
name|bitbuf
decl_stmt|;
comment|/* bits from stream */
name|int
name|left
decl_stmt|;
comment|/* bits left in next or left to process */
name|short
modifier|*
name|next
decl_stmt|;
comment|/* next number of codes */
name|bitbuf
operator|=
name|s
operator|->
name|bitbuf
expr_stmt|;
name|left
operator|=
name|s
operator|->
name|bitcnt
expr_stmt|;
name|code
operator|=
name|first
operator|=
name|index
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|h
operator|->
name|count
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|left
operator|--
condition|)
block|{
name|code
operator||=
name|bitbuf
operator|&
literal|1
expr_stmt|;
name|bitbuf
operator|>>=
literal|1
expr_stmt|;
name|count
operator|=
operator|*
name|next
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|-
name|count
operator|<
name|first
condition|)
block|{
comment|/* if length len, return symbol */
name|s
operator|->
name|bitbuf
operator|=
name|bitbuf
expr_stmt|;
name|s
operator|->
name|bitcnt
operator|=
operator|(
name|s
operator|->
name|bitcnt
operator|-
name|len
operator|)
operator|&
literal|7
expr_stmt|;
return|return
name|h
operator|->
name|symbol
index|[
name|index
operator|+
operator|(
name|code
operator|-
name|first
operator|)
index|]
return|;
block|}
name|index
operator|+=
name|count
expr_stmt|;
comment|/* else update for next length */
name|first
operator|+=
name|count
expr_stmt|;
name|first
operator|<<=
literal|1
expr_stmt|;
name|code
operator|<<=
literal|1
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|left
operator|=
operator|(
name|MAXBITS
operator|+
literal|1
operator|)
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|s
operator|->
name|incnt
operator|==
name|s
operator|->
name|inlen
condition|)
name|longjmp
argument_list|(
name|s
operator|->
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* out of input */
name|bitbuf
operator|=
name|s
operator|->
name|in
index|[
name|s
operator|->
name|incnt
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|left
operator|>
literal|8
condition|)
name|left
operator|=
literal|8
expr_stmt|;
block|}
return|return
operator|-
literal|10
return|;
comment|/* ran out of codes */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SLOW */
end_comment

begin_comment
comment|/*  * Given the list of code lengths length[0..n-1] representing a canonical  * Huffman code for n symbols, construct the tables required to decode those  * codes.  Those tables are the number of codes of each length, and the symbols  * sorted by length, retaining their original order within each length.  The  * return value is zero for a complete code set, negative for an over-  * subscribed code set, and positive for an incomplete code set.  The tables  * can be used if the return value is zero or positive, but they cannot be used  * if the return value is negative.  If the return value is zero, it is not  * possible for decode() using that table to return an error--any stream of  * enough bits will resolve to a symbol.  If the return value is positive, then  * it is possible for decode() using that table to return an error for received  * codes past the end of the incomplete lengths.  *  * Not used by decode(), but used for error checking, h->count[0] is the number  * of the n symbols not in the code.  So n - h->count[0] is the number of  * codes.  This is useful for checking for incomplete codes that have more than  * one symbol, which is an error in a dynamic block.  *  * Assumption: for all i in 0..n-1, 0<= length[i]<= MAXBITS  * This is assured by the construction of the length arrays in dynamic() and  * fixed() and is not verified by construct().  *  * Format notes:  *  * - Permitted and expected examples of incomplete codes are one of the fixed  *   codes and any code with a single symbol which in deflate is coded as one  *   bit instead of zero bits.  See the format notes for fixed() and dynamic().  *  * - Within a given code length, the symbols are kept in ascending order for  *   the code bits definition.  */
end_comment

begin_function
name|local
name|int
name|construct
parameter_list|(
name|struct
name|huffman
modifier|*
name|h
parameter_list|,
specifier|const
name|short
modifier|*
name|length
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|symbol
decl_stmt|;
comment|/* current symbol when stepping through length[] */
name|int
name|len
decl_stmt|;
comment|/* current length when stepping through h->count[] */
name|int
name|left
decl_stmt|;
comment|/* number of possible codes left of current length */
name|short
name|offs
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* offsets in symbol table for each length */
comment|/* count number of codes of each length */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<=
name|MAXBITS
condition|;
name|len
operator|++
control|)
name|h
operator|->
name|count
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|symbol
operator|=
literal|0
init|;
name|symbol
operator|<
name|n
condition|;
name|symbol
operator|++
control|)
operator|(
name|h
operator|->
name|count
index|[
name|length
index|[
name|symbol
index|]
index|]
operator|)
operator|++
expr_stmt|;
comment|/* assumes lengths are within bounds */
if|if
condition|(
name|h
operator|->
name|count
index|[
literal|0
index|]
operator|==
name|n
condition|)
comment|/* no codes! */
return|return
literal|0
return|;
comment|/* complete, but decode() will fail */
comment|/* check for an over-subscribed or incomplete set of lengths */
name|left
operator|=
literal|1
expr_stmt|;
comment|/* one possible code of zero length */
for|for
control|(
name|len
operator|=
literal|1
init|;
name|len
operator|<=
name|MAXBITS
condition|;
name|len
operator|++
control|)
block|{
name|left
operator|<<=
literal|1
expr_stmt|;
comment|/* one more bit, double codes left */
name|left
operator|-=
name|h
operator|->
name|count
index|[
name|len
index|]
expr_stmt|;
comment|/* deduct count from possible codes */
if|if
condition|(
name|left
operator|<
literal|0
condition|)
return|return
name|left
return|;
comment|/* over-subscribed--return negative */
block|}
comment|/* left> 0 means incomplete */
comment|/* generate offsets into symbol table for each length for sorting */
name|offs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|1
init|;
name|len
operator|<
name|MAXBITS
condition|;
name|len
operator|++
control|)
name|offs
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|offs
index|[
name|len
index|]
operator|+
name|h
operator|->
name|count
index|[
name|len
index|]
expr_stmt|;
comment|/*      * put symbols in table sorted by length, by symbol order within each      * length      */
for|for
control|(
name|symbol
operator|=
literal|0
init|;
name|symbol
operator|<
name|n
condition|;
name|symbol
operator|++
control|)
if|if
condition|(
name|length
index|[
name|symbol
index|]
operator|!=
literal|0
condition|)
name|h
operator|->
name|symbol
index|[
name|offs
index|[
name|length
index|[
name|symbol
index|]
index|]
operator|++
index|]
operator|=
name|symbol
expr_stmt|;
comment|/* return zero for complete set, positive for incomplete set */
return|return
name|left
return|;
block|}
end_function

begin_comment
comment|/*  * Decode literal/length and distance codes until an end-of-block code.  *  * Format notes:  *  * - Compressed data that is after the block type if fixed or after the code  *   description if dynamic is a combination of literals and length/distance  *   pairs terminated by and end-of-block code.  Literals are simply Huffman  *   coded bytes.  A length/distance pair is a coded length followed by a  *   coded distance to represent a string that occurs earlier in the  *   uncompressed data that occurs again at the current location.  *  * - Literals, lengths, and the end-of-block code are combined into a single  *   code of up to 286 symbols.  They are 256 literals (0..255), 29 length  *   symbols (257..285), and the end-of-block symbol (256).  *  * - There are 256 possible lengths (3..258), and so 29 symbols are not enough  *   to represent all of those.  Lengths 3..10 and 258 are in fact represented  *   by just a length symbol.  Lengths 11..257 are represented as a symbol and  *   some number of extra bits that are added as an integer to the base length  *   of the length symbol.  The number of extra bits is determined by the base  *   length symbol.  These are in the static arrays below, lens[] for the base  *   lengths and lext[] for the corresponding number of extra bits.  *  * - The reason that 258 gets its own symbol is that the longest length is used  *   often in highly redundant files.  Note that 258 can also be coded as the  *   base value 227 plus the maximum extra value of 31.  While a good deflate  *   should never do this, it is not an error, and should be decoded properly.  *  * - If a length is decoded, including its extra bits if any, then it is  *   followed a distance code.  There are up to 30 distance symbols.  Again  *   there are many more possible distances (1..32768), so extra bits are added  *   to a base value represented by the symbol.  The distances 1..4 get their  *   own symbol, but the rest require extra bits.  The base distances and  *   corresponding number of extra bits are below in the static arrays dist[]  *   and dext[].  *  * - Literal bytes are simply written to the output.  A length/distance pair is  *   an instruction to copy previously uncompressed bytes to the output.  The  *   copy is from distance bytes back in the output stream, copying for length  *   bytes.  *  * - Distances pointing before the beginning of the output data are not  *   permitted.  *  * - Overlapped copies, where the length is greater than the distance, are  *   allowed and common.  For example, a distance of one and a length of 258  *   simply copies the last byte 258 times.  A distance of four and a length of  *   twelve copies the last four bytes three times.  A simple forward copy  *   ignoring whether the length is greater than the distance or not implements  *   this correctly.  You should not use memcpy() since its behavior is not  *   defined for overlapped arrays.  You should not use memmove() or bcopy()  *   since though their behavior -is- defined for overlapping arrays, it is  *   defined to do the wrong thing in this case.  */
end_comment

begin_function
name|local
name|int
name|codes
parameter_list|(
name|struct
name|state
modifier|*
name|s
parameter_list|,
specifier|const
name|struct
name|huffman
modifier|*
name|lencode
parameter_list|,
specifier|const
name|struct
name|huffman
modifier|*
name|distcode
parameter_list|)
block|{
name|int
name|symbol
decl_stmt|;
comment|/* decoded symbol */
name|int
name|len
decl_stmt|;
comment|/* length for copy */
name|unsigned
name|dist
decl_stmt|;
comment|/* distance for copy */
specifier|static
specifier|const
name|short
name|lens
index|[
literal|29
index|]
init|=
block|{
comment|/* Size base for length codes 257..285 */
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|13
block|,
literal|15
block|,
literal|17
block|,
literal|19
block|,
literal|23
block|,
literal|27
block|,
literal|31
block|,
literal|35
block|,
literal|43
block|,
literal|51
block|,
literal|59
block|,
literal|67
block|,
literal|83
block|,
literal|99
block|,
literal|115
block|,
literal|131
block|,
literal|163
block|,
literal|195
block|,
literal|227
block|,
literal|258
block|}
decl_stmt|;
specifier|static
specifier|const
name|short
name|lext
index|[
literal|29
index|]
init|=
block|{
comment|/* Extra bits for length codes 257..285 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|}
decl_stmt|;
specifier|static
specifier|const
name|short
name|dists
index|[
literal|30
index|]
init|=
block|{
comment|/* Offset base for distance codes 0..29 */
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|,
literal|13
block|,
literal|17
block|,
literal|25
block|,
literal|33
block|,
literal|49
block|,
literal|65
block|,
literal|97
block|,
literal|129
block|,
literal|193
block|,
literal|257
block|,
literal|385
block|,
literal|513
block|,
literal|769
block|,
literal|1025
block|,
literal|1537
block|,
literal|2049
block|,
literal|3073
block|,
literal|4097
block|,
literal|6145
block|,
literal|8193
block|,
literal|12289
block|,
literal|16385
block|,
literal|24577
block|}
decl_stmt|;
specifier|static
specifier|const
name|short
name|dext
index|[
literal|30
index|]
init|=
block|{
comment|/* Extra bits for distance codes 0..29 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|12
block|,
literal|13
block|,
literal|13
block|}
decl_stmt|;
comment|/* decode literals and length/distance pairs */
do|do
block|{
name|symbol
operator|=
name|decode
argument_list|(
name|s
argument_list|,
name|lencode
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|<
literal|0
condition|)
return|return
name|symbol
return|;
comment|/* invalid symbol */
if|if
condition|(
name|symbol
operator|<
literal|256
condition|)
block|{
comment|/* literal: symbol is the byte */
comment|/* write out the literal */
if|if
condition|(
name|s
operator|->
name|out
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|outcnt
operator|==
name|s
operator|->
name|outlen
condition|)
return|return
literal|1
return|;
name|s
operator|->
name|out
index|[
name|s
operator|->
name|outcnt
index|]
operator|=
name|symbol
expr_stmt|;
block|}
name|s
operator|->
name|outcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|>
literal|256
condition|)
block|{
comment|/* length */
comment|/* get and compute length */
name|symbol
operator|-=
literal|257
expr_stmt|;
if|if
condition|(
name|symbol
operator|>=
literal|29
condition|)
return|return
operator|-
literal|10
return|;
comment|/* invalid fixed code */
name|len
operator|=
name|lens
index|[
name|symbol
index|]
operator|+
name|bits
argument_list|(
name|s
argument_list|,
name|lext
index|[
name|symbol
index|]
argument_list|)
expr_stmt|;
comment|/* get and check distance */
name|symbol
operator|=
name|decode
argument_list|(
name|s
argument_list|,
name|distcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|<
literal|0
condition|)
return|return
name|symbol
return|;
comment|/* invalid symbol */
name|dist
operator|=
name|dists
index|[
name|symbol
index|]
operator|+
name|bits
argument_list|(
name|s
argument_list|,
name|dext
index|[
name|symbol
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
if|if
condition|(
name|dist
operator|>
name|s
operator|->
name|outcnt
condition|)
return|return
operator|-
literal|11
return|;
comment|/* distance too far back */
endif|#
directive|endif
comment|/* copy length bytes from distance bytes back */
if|if
condition|(
name|s
operator|->
name|out
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|outcnt
operator|+
name|len
operator|>
name|s
operator|->
name|outlen
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|s
operator|->
name|out
index|[
name|s
operator|->
name|outcnt
index|]
operator|=
ifdef|#
directive|ifdef
name|INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
name|dist
operator|>
name|s
operator|->
name|outcnt
condition|?
literal|0
else|:
endif|#
directive|endif
name|s
operator|->
name|out
index|[
name|s
operator|->
name|outcnt
operator|-
name|dist
index|]
expr_stmt|;
name|s
operator|->
name|outcnt
operator|++
expr_stmt|;
block|}
block|}
else|else
name|s
operator|->
name|outcnt
operator|+=
name|len
expr_stmt|;
block|}
block|}
do|while
condition|(
name|symbol
operator|!=
literal|256
condition|)
do|;
comment|/* end of block symbol */
comment|/* done with a valid fixed or dynamic block */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process a fixed codes block.  *  * Format notes:  *  * - This block type can be useful for compressing small amounts of data for  *   which the size of the code descriptions in a dynamic block exceeds the  *   benefit of custom codes for that block.  For fixed codes, no bits are  *   spent on code descriptions.  Instead the code lengths for literal/length  *   codes and distance codes are fixed.  The specific lengths for each symbol  *   can be seen in the "for" loops below.  *  * - The literal/length code is complete, but has two symbols that are invalid  *   and should result in an error if received.  This cannot be implemented  *   simply as an incomplete code since those two symbols are in the "middle"  *   of the code.  They are eight bits long and the longest literal/length\  *   code is nine bits.  Therefore the code must be constructed with those  *   symbols, and the invalid symbols must be detected after decoding.  *  * - The fixed distance codes also have two invalid symbols that should result  *   in an error if received.  Since all of the distance codes are the same  *   length, this can be implemented as an incomplete code.  Then the invalid  *   codes are detected while decoding.  */
end_comment

begin_function
name|local
name|int
name|fixed
parameter_list|(
name|struct
name|state
modifier|*
name|s
parameter_list|)
block|{
specifier|static
name|int
name|virgin
init|=
literal|1
decl_stmt|;
specifier|static
name|short
name|lencnt
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|,
name|lensym
index|[
name|FIXLCODES
index|]
decl_stmt|;
specifier|static
name|short
name|distcnt
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|,
name|distsym
index|[
name|MAXDCODES
index|]
decl_stmt|;
specifier|static
name|struct
name|huffman
name|lencode
decl_stmt|,
name|distcode
decl_stmt|;
comment|/* build fixed huffman tables if first call (may not be thread safe) */
if|if
condition|(
name|virgin
condition|)
block|{
name|int
name|symbol
decl_stmt|;
name|short
name|lengths
index|[
name|FIXLCODES
index|]
decl_stmt|;
comment|/* construct lencode and distcode */
name|lencode
operator|.
name|count
operator|=
name|lencnt
expr_stmt|;
name|lencode
operator|.
name|symbol
operator|=
name|lensym
expr_stmt|;
name|distcode
operator|.
name|count
operator|=
name|distcnt
expr_stmt|;
name|distcode
operator|.
name|symbol
operator|=
name|distsym
expr_stmt|;
comment|/* literal/length table */
for|for
control|(
name|symbol
operator|=
literal|0
init|;
name|symbol
operator|<
literal|144
condition|;
name|symbol
operator|++
control|)
name|lengths
index|[
name|symbol
index|]
operator|=
literal|8
expr_stmt|;
for|for
control|(
init|;
name|symbol
operator|<
literal|256
condition|;
name|symbol
operator|++
control|)
name|lengths
index|[
name|symbol
index|]
operator|=
literal|9
expr_stmt|;
for|for
control|(
init|;
name|symbol
operator|<
literal|280
condition|;
name|symbol
operator|++
control|)
name|lengths
index|[
name|symbol
index|]
operator|=
literal|7
expr_stmt|;
for|for
control|(
init|;
name|symbol
operator|<
name|FIXLCODES
condition|;
name|symbol
operator|++
control|)
name|lengths
index|[
name|symbol
index|]
operator|=
literal|8
expr_stmt|;
name|construct
argument_list|(
operator|&
name|lencode
argument_list|,
name|lengths
argument_list|,
name|FIXLCODES
argument_list|)
expr_stmt|;
comment|/* distance table */
for|for
control|(
name|symbol
operator|=
literal|0
init|;
name|symbol
operator|<
name|MAXDCODES
condition|;
name|symbol
operator|++
control|)
name|lengths
index|[
name|symbol
index|]
operator|=
literal|5
expr_stmt|;
name|construct
argument_list|(
operator|&
name|distcode
argument_list|,
name|lengths
argument_list|,
name|MAXDCODES
argument_list|)
expr_stmt|;
comment|/* do this just once */
name|virgin
operator|=
literal|0
expr_stmt|;
block|}
comment|/* decode data until end-of-block code */
return|return
name|codes
argument_list|(
name|s
argument_list|,
operator|&
name|lencode
argument_list|,
operator|&
name|distcode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a dynamic codes block.  *  * Format notes:  *  * - A dynamic block starts with a description of the literal/length and  *   distance codes for that block.  New dynamic blocks allow the compressor to  *   rapidly adapt to changing data with new codes optimized for that data.  *  * - The codes used by the deflate format are "canonical", which means that  *   the actual bits of the codes are generated in an unambiguous way simply  *   from the number of bits in each code.  Therefore the code descriptions  *   are simply a list of code lengths for each symbol.  *  * - The code lengths are stored in order for the symbols, so lengths are  *   provided for each of the literal/length symbols, and for each of the  *   distance symbols.  *  * - If a symbol is not used in the block, this is represented by a zero as  *   as the code length.  This does not mean a zero-length code, but rather  *   that no code should be created for this symbol.  There is no way in the  *   deflate format to represent a zero-length code.  *  * - The maximum number of bits in a code is 15, so the possible lengths for  *   any code are 1..15.  *  * - The fact that a length of zero is not permitted for a code has an  *   interesting consequence.  Normally if only one symbol is used for a given  *   code, then in fact that code could be represented with zero bits.  However  *   in deflate, that code has to be at least one bit.  So for example, if  *   only a single distance base symbol appears in a block, then it will be  *   represented by a single code of length one, in particular one 0 bit.  This  *   is an incomplete code, since if a 1 bit is received, it has no meaning,  *   and should result in an error.  So incomplete distance codes of one symbol  *   should be permitted, and the receipt of invalid codes should be handled.  *  * - It is also possible to have a single literal/length code, but that code  *   must be the end-of-block code, since every dynamic block has one.  This  *   is not the most efficient way to create an empty block (an empty fixed  *   block is fewer bits), but it is allowed by the format.  So incomplete  *   literal/length codes of one symbol should also be permitted.  *  * - If there are only literal codes and no lengths, then there are no distance  *   codes.  This is represented by one distance code with zero bits.  *  * - The list of up to 286 length/literal lengths and up to 30 distance lengths  *   are themselves compressed using Huffman codes and run-length encoding.  In  *   the list of code lengths, a 0 symbol means no code, a 1..15 symbol means  *   that length, and the symbols 16, 17, and 18 are run-length instructions.  *   Each of 16, 17, and 18 are follwed by extra bits to define the length of  *   the run.  16 copies the last length 3 to 6 times.  17 represents 3 to 10  *   zero lengths, and 18 represents 11 to 138 zero lengths.  Unused symbols  *   are common, hence the special coding for zero lengths.  *  * - The symbols for 0..18 are Huffman coded, and so that code must be  *   described first.  This is simply a sequence of up to 19 three-bit values  *   representing no code (0) or the code length for that symbol (1..7).  *  * - A dynamic block starts with three fixed-size counts from which is computed  *   the number of literal/length code lengths, the number of distance code  *   lengths, and the number of code length code lengths (ok, you come up with  *   a better name!) in the code descriptions.  For the literal/length and  *   distance codes, lengths after those provided are considered zero, i.e. no  *   code.  The code length code lengths are received in a permuted order (see  *   the order[] array below) to make a short code length code length list more  *   likely.  As it turns out, very short and very long codes are less likely  *   to be seen in a dynamic code description, hence what may appear initially  *   to be a peculiar ordering.  *  * - Given the number of literal/length code lengths (nlen) and distance code  *   lengths (ndist), then they are treated as one long list of nlen + ndist  *   code lengths.  Therefore run-length coding can and often does cross the  *   boundary between the two sets of lengths.  *  * - So to summarize, the code description at the start of a dynamic block is  *   three counts for the number of code lengths for the literal/length codes,  *   the distance codes, and the code length codes.  This is followed by the  *   code length code lengths, three bits each.  This is used to construct the  *   code length code which is used to read the remainder of the lengths.  Then  *   the literal/length code lengths and distance lengths are read as a single  *   set of lengths using the code length codes.  Codes are constructed from  *   the resulting two sets of lengths, and then finally you can start  *   decoding actual compressed data in the block.  *  * - For reference, a "typical" size for the code description in a dynamic  *   block is around 80 bytes.  */
end_comment

begin_function
name|local
name|int
name|dynamic
parameter_list|(
name|struct
name|state
modifier|*
name|s
parameter_list|)
block|{
name|int
name|nlen
decl_stmt|,
name|ndist
decl_stmt|,
name|ncode
decl_stmt|;
comment|/* number of lengths in descriptor */
name|int
name|index
decl_stmt|;
comment|/* index of lengths[] */
name|int
name|err
decl_stmt|;
comment|/* construct() return value */
name|short
name|lengths
index|[
name|MAXCODES
index|]
decl_stmt|;
comment|/* descriptor code lengths */
name|short
name|lencnt
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|,
name|lensym
index|[
name|MAXLCODES
index|]
decl_stmt|;
comment|/* lencode memory */
name|short
name|distcnt
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|,
name|distsym
index|[
name|MAXDCODES
index|]
decl_stmt|;
comment|/* distcode memory */
name|struct
name|huffman
name|lencode
decl_stmt|,
name|distcode
decl_stmt|;
comment|/* length and distance codes */
specifier|static
specifier|const
name|short
name|order
index|[
literal|19
index|]
init|=
comment|/* permutation of code length codes */
block|{
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|10
block|,
literal|5
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|3
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|}
decl_stmt|;
comment|/* construct lencode and distcode */
name|lencode
operator|.
name|count
operator|=
name|lencnt
expr_stmt|;
name|lencode
operator|.
name|symbol
operator|=
name|lensym
expr_stmt|;
name|distcode
operator|.
name|count
operator|=
name|distcnt
expr_stmt|;
name|distcode
operator|.
name|symbol
operator|=
name|distsym
expr_stmt|;
comment|/* get number of lengths in each table, check lengths */
name|nlen
operator|=
name|bits
argument_list|(
name|s
argument_list|,
literal|5
argument_list|)
operator|+
literal|257
expr_stmt|;
name|ndist
operator|=
name|bits
argument_list|(
name|s
argument_list|,
literal|5
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ncode
operator|=
name|bits
argument_list|(
name|s
argument_list|,
literal|4
argument_list|)
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|nlen
operator|>
name|MAXLCODES
operator|||
name|ndist
operator|>
name|MAXDCODES
condition|)
return|return
operator|-
literal|3
return|;
comment|/* bad counts */
comment|/* read code length code lengths (really), missing lengths are zero */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|ncode
condition|;
name|index
operator|++
control|)
name|lengths
index|[
name|order
index|[
name|index
index|]
index|]
operator|=
name|bits
argument_list|(
name|s
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|index
operator|<
literal|19
condition|;
name|index
operator|++
control|)
name|lengths
index|[
name|order
index|[
name|index
index|]
index|]
operator|=
literal|0
expr_stmt|;
comment|/* build huffman table for code lengths codes (use lencode temporarily) */
name|err
operator|=
name|construct
argument_list|(
operator|&
name|lencode
argument_list|,
name|lengths
argument_list|,
literal|19
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
comment|/* require complete code set here */
return|return
operator|-
literal|4
return|;
comment|/* read length/literal and distance code length tables */
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|nlen
operator|+
name|ndist
condition|)
block|{
name|int
name|symbol
decl_stmt|;
comment|/* decoded value */
name|int
name|len
decl_stmt|;
comment|/* last length to repeat */
name|symbol
operator|=
name|decode
argument_list|(
name|s
argument_list|,
operator|&
name|lencode
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|<
literal|0
condition|)
return|return
name|symbol
return|;
comment|/* invalid symbol */
if|if
condition|(
name|symbol
operator|<
literal|16
condition|)
comment|/* length in 0..15 */
name|lengths
index|[
name|index
operator|++
index|]
operator|=
name|symbol
expr_stmt|;
else|else
block|{
comment|/* repeat instruction */
name|len
operator|=
literal|0
expr_stmt|;
comment|/* assume repeating zeros */
if|if
condition|(
name|symbol
operator|==
literal|16
condition|)
block|{
comment|/* repeat last length 3..6 times */
if|if
condition|(
name|index
operator|==
literal|0
condition|)
return|return
operator|-
literal|5
return|;
comment|/* no last length! */
name|len
operator|=
name|lengths
index|[
name|index
operator|-
literal|1
index|]
expr_stmt|;
comment|/* last length */
name|symbol
operator|=
literal|3
operator|+
name|bits
argument_list|(
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|==
literal|17
condition|)
comment|/* repeat zero 3..10 times */
name|symbol
operator|=
literal|3
operator|+
name|bits
argument_list|(
name|s
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
comment|/* == 18, repeat zero 11..138 times */
name|symbol
operator|=
literal|11
operator|+
name|bits
argument_list|(
name|s
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|+
name|symbol
operator|>
name|nlen
operator|+
name|ndist
condition|)
return|return
operator|-
literal|6
return|;
comment|/* too many lengths! */
while|while
condition|(
name|symbol
operator|--
condition|)
comment|/* repeat last or zero symbol times */
name|lengths
index|[
name|index
operator|++
index|]
operator|=
name|len
expr_stmt|;
block|}
block|}
comment|/* check for end-of-block code -- there better be one! */
if|if
condition|(
name|lengths
index|[
literal|256
index|]
operator|==
literal|0
condition|)
return|return
operator|-
literal|9
return|;
comment|/* build huffman table for literal/length codes */
name|err
operator|=
name|construct
argument_list|(
operator|&
name|lencode
argument_list|,
name|lengths
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|<
literal|0
operator|||
name|nlen
operator|!=
name|lencode
operator|.
name|count
index|[
literal|0
index|]
operator|+
name|lencode
operator|.
name|count
index|[
literal|1
index|]
operator|)
condition|)
return|return
operator|-
literal|7
return|;
comment|/* incomplete code ok only for single length 1 code */
comment|/* build huffman table for distance codes */
name|err
operator|=
name|construct
argument_list|(
operator|&
name|distcode
argument_list|,
name|lengths
operator|+
name|nlen
argument_list|,
name|ndist
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|<
literal|0
operator|||
name|ndist
operator|!=
name|distcode
operator|.
name|count
index|[
literal|0
index|]
operator|+
name|distcode
operator|.
name|count
index|[
literal|1
index|]
operator|)
condition|)
return|return
operator|-
literal|8
return|;
comment|/* incomplete code ok only for single length 1 code */
comment|/* decode data until end-of-block code */
return|return
name|codes
argument_list|(
name|s
argument_list|,
operator|&
name|lencode
argument_list|,
operator|&
name|distcode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inflate source to dest.  On return, destlen and sourcelen are updated to the  * size of the uncompressed data and the size of the deflate data respectively.  * On success, the return value of puff() is zero.  If there is an error in the  * source data, i.e. it is not in the deflate format, then a negative value is  * returned.  If there is not enough input available or there is not enough  * output space, then a positive error is returned.  In that case, destlen and  * sourcelen are not updated to facilitate retrying from the beginning with the  * provision of more input data or more output space.  In the case of invalid  * inflate data (a negative error), the dest and source pointers are updated to  * facilitate the debugging of deflators.  *  * puff() also has a mode to determine the size of the uncompressed output with  * no output written.  For this dest must be (unsigned char *)0.  In this case,  * the input value of *destlen is ignored, and on return *destlen is set to the  * size of the uncompressed output.  *  * The return codes are:  *  *   2:  available inflate data did not terminate  *   1:  output space exhausted before completing inflate  *   0:  successful inflate  *  -1:  invalid block type (type == 3)  *  -2:  stored block length did not match one's complement  *  -3:  dynamic block code description: too many length or distance codes  *  -4:  dynamic block code description: code lengths codes incomplete  *  -5:  dynamic block code description: repeat lengths with no first length  *  -6:  dynamic block code description: repeat more than specified lengths  *  -7:  dynamic block code description: invalid literal/length code lengths  *  -8:  dynamic block code description: invalid distance code lengths  *  -9:  dynamic block code description: missing end-of-block code  * -10:  invalid literal/length or distance code in fixed or dynamic block  * -11:  distance is too far back in fixed or dynamic block  *  * Format notes:  *  * - Three bits are read for each block to determine the kind of block and  *   whether or not it is the last block.  Then the block is decoded and the  *   process repeated if it was not the last block.  *  * - The leftover bits in the last byte of the deflate data after the last  *   block (if it was a fixed or dynamic block) are undefined and have no  *   expected values to check.  */
end_comment

begin_function
name|int
name|puff
parameter_list|(
name|unsigned
name|char
modifier|*
name|dest
parameter_list|,
comment|/* pointer to destination pointer */
name|unsigned
name|long
modifier|*
name|destlen
parameter_list|,
comment|/* amount of output space */
specifier|const
name|unsigned
name|char
modifier|*
name|source
parameter_list|,
comment|/* pointer to source data pointer */
name|unsigned
name|long
modifier|*
name|sourcelen
parameter_list|)
comment|/* amount of input available */
block|{
name|struct
name|state
name|s
decl_stmt|;
comment|/* input/output state */
name|int
name|last
decl_stmt|,
name|type
decl_stmt|;
comment|/* block information */
name|int
name|err
decl_stmt|;
comment|/* return value */
comment|/* initialize output state */
name|s
operator|.
name|out
operator|=
name|dest
expr_stmt|;
name|s
operator|.
name|outlen
operator|=
operator|*
name|destlen
expr_stmt|;
comment|/* ignored if dest is NIL */
name|s
operator|.
name|outcnt
operator|=
literal|0
expr_stmt|;
comment|/* initialize input state */
name|s
operator|.
name|in
operator|=
name|source
expr_stmt|;
name|s
operator|.
name|inlen
operator|=
operator|*
name|sourcelen
expr_stmt|;
name|s
operator|.
name|incnt
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|bitbuf
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|bitcnt
operator|=
literal|0
expr_stmt|;
comment|/* return if bits() or decode() tries to read past available input */
if|if
condition|(
name|setjmp
argument_list|(
name|s
operator|.
name|env
argument_list|)
operator|!=
literal|0
condition|)
comment|/* if came back here via longjmp() */
name|err
operator|=
literal|2
expr_stmt|;
comment|/* then skip do-loop, return error */
else|else
block|{
comment|/* process blocks until last block or error */
do|do
block|{
name|last
operator|=
name|bits
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* one if last block */
name|type
operator|=
name|bits
argument_list|(
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* block type 0..3 */
name|err
operator|=
name|type
operator|==
literal|0
condition|?
name|stored
argument_list|(
operator|&
name|s
argument_list|)
else|:
operator|(
name|type
operator|==
literal|1
condition|?
name|fixed
argument_list|(
operator|&
name|s
argument_list|)
else|:
operator|(
name|type
operator|==
literal|2
condition|?
name|dynamic
argument_list|(
operator|&
name|s
argument_list|)
else|:
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* type == 3, invalid */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
comment|/* return with error */
block|}
do|while
condition|(
operator|!
name|last
condition|)
do|;
block|}
comment|/* update the lengths and return */
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
block|{
operator|*
name|destlen
operator|=
name|s
operator|.
name|outcnt
expr_stmt|;
operator|*
name|sourcelen
operator|=
name|s
operator|.
name|incnt
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

end_unit

