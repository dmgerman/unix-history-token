begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// Internal policy header for TR1 unordered_set and unordered_map -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2005, 2006 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|/** @file tr1/hashtable_policy.h  *  This is a TR1 C++ Library header.   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_TR1_HASHTABLE_POLICY_H
end_ifndef

begin_define
define|#
directive|define
name|_TR1_HASHTABLE_POLICY_H
value|1
end_define

begin_include
include|#
directive|include
file|<functional>
end_include

begin_comment
comment|// _Identity, _Select1st
end_comment

begin_include
include|#
directive|include
file|<tr1/utility>
end_include

begin_include
include|#
directive|include
file|<ext/type_traits.h>
end_include

begin_decl_stmt
name|namespace
name|std
block|{
name|_GLIBCXX_BEGIN_NAMESPACE
argument_list|(
argument|tr1
argument_list|)
name|namespace
name|__detail
block|{
comment|// Helper function: return distance(first, last) for forward
comment|// iterators, or 0 for input iterators.
name|template
operator|<
name|class
name|_Iterator
operator|>
specifier|inline
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|difference_type
name|__distance_fw
argument_list|(
argument|_Iterator __first
argument_list|,
argument|_Iterator __last
argument_list|,
argument|std::input_iterator_tag
argument_list|)
block|{
return|return
literal|0
return|;
block|}
name|template
operator|<
name|class
name|_Iterator
operator|>
specifier|inline
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|difference_type
name|__distance_fw
argument_list|(
argument|_Iterator __first
argument_list|,
argument|_Iterator __last
argument_list|,
argument|std::forward_iterator_tag
argument_list|)
block|{
return|return
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|_Iterator
operator|>
specifier|inline
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|difference_type
name|__distance_fw
argument_list|(
argument|_Iterator __first
argument_list|,
argument|_Iterator __last
argument_list|)
block|{
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|iterator_category
name|_Tag
expr_stmt|;
return|return
name|__distance_fw
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|_Tag
argument_list|()
argument_list|)
return|;
block|}
comment|// XXX This is a hack.  _Prime_rehash_policy's member functions, and
comment|// certainly the list of primes, should be defined in a .cc file.
comment|// We're temporarily putting them in a header because we don't have a
comment|// place to put TR1 .cc files yet.  There's no good reason for any of
comment|// _Prime_rehash_policy's member functions to be inline, and there's
comment|// certainly no good reason for _Primes<> to exist at all.
struct|struct
name|_LessThan
block|{
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Up
operator|>
name|bool
name|operator
argument_list|()
operator|(
name|_Tp
name|__x
operator|,
name|_Up
name|__y
operator|)
block|{
return|return
name|__x
operator|<
name|__y
return|;
block|}
block|}
struct|;
name|template
operator|<
name|int
name|__ulongsize
operator|=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|>
expr|struct
name|_Primes
block|{
specifier|static
specifier|const
name|int
name|__n_primes
operator|=
name|__ulongsize
operator|!=
literal|8
operator|?
literal|256
operator|:
literal|256
operator|+
literal|48
block|;
specifier|static
specifier|const
name|unsigned
name|long
name|__primes
index|[
literal|256
operator|+
literal|48
operator|+
literal|1
index|]
block|;     }
expr_stmt|;
name|template
operator|<
name|int
name|__ulongsize
operator|>
specifier|const
name|int
name|_Primes
operator|<
name|__ulongsize
operator|>
operator|::
name|__n_primes
expr_stmt|;
name|template
operator|<
name|int
name|__ulongsize
operator|>
specifier|const
name|unsigned
name|long
name|_Primes
operator|<
name|__ulongsize
operator|>
operator|::
name|__primes
index|[
literal|256
operator|+
literal|48
operator|+
literal|1
index|]
operator|=
block|{
literal|2ul
block|,
literal|3ul
block|,
literal|5ul
block|,
literal|7ul
block|,
literal|11ul
block|,
literal|13ul
block|,
literal|17ul
block|,
literal|19ul
block|,
literal|23ul
block|,
literal|29ul
block|,
literal|31ul
block|,
literal|37ul
block|,
literal|41ul
block|,
literal|43ul
block|,
literal|47ul
block|,
literal|53ul
block|,
literal|59ul
block|,
literal|61ul
block|,
literal|67ul
block|,
literal|71ul
block|,
literal|73ul
block|,
literal|79ul
block|,
literal|83ul
block|,
literal|89ul
block|,
literal|97ul
block|,
literal|103ul
block|,
literal|109ul
block|,
literal|113ul
block|,
literal|127ul
block|,
literal|137ul
block|,
literal|139ul
block|,
literal|149ul
block|,
literal|157ul
block|,
literal|167ul
block|,
literal|179ul
block|,
literal|193ul
block|,
literal|199ul
block|,
literal|211ul
block|,
literal|227ul
block|,
literal|241ul
block|,
literal|257ul
block|,
literal|277ul
block|,
literal|293ul
block|,
literal|313ul
block|,
literal|337ul
block|,
literal|359ul
block|,
literal|383ul
block|,
literal|409ul
block|,
literal|439ul
block|,
literal|467ul
block|,
literal|503ul
block|,
literal|541ul
block|,
literal|577ul
block|,
literal|619ul
block|,
literal|661ul
block|,
literal|709ul
block|,
literal|761ul
block|,
literal|823ul
block|,
literal|887ul
block|,
literal|953ul
block|,
literal|1031ul
block|,
literal|1109ul
block|,
literal|1193ul
block|,
literal|1289ul
block|,
literal|1381ul
block|,
literal|1493ul
block|,
literal|1613ul
block|,
literal|1741ul
block|,
literal|1879ul
block|,
literal|2029ul
block|,
literal|2179ul
block|,
literal|2357ul
block|,
literal|2549ul
block|,
literal|2753ul
block|,
literal|2971ul
block|,
literal|3209ul
block|,
literal|3469ul
block|,
literal|3739ul
block|,
literal|4027ul
block|,
literal|4349ul
block|,
literal|4703ul
block|,
literal|5087ul
block|,
literal|5503ul
block|,
literal|5953ul
block|,
literal|6427ul
block|,
literal|6949ul
block|,
literal|7517ul
block|,
literal|8123ul
block|,
literal|8783ul
block|,
literal|9497ul
block|,
literal|10273ul
block|,
literal|11113ul
block|,
literal|12011ul
block|,
literal|12983ul
block|,
literal|14033ul
block|,
literal|15173ul
block|,
literal|16411ul
block|,
literal|17749ul
block|,
literal|19183ul
block|,
literal|20753ul
block|,
literal|22447ul
block|,
literal|24281ul
block|,
literal|26267ul
block|,
literal|28411ul
block|,
literal|30727ul
block|,
literal|33223ul
block|,
literal|35933ul
block|,
literal|38873ul
block|,
literal|42043ul
block|,
literal|45481ul
block|,
literal|49201ul
block|,
literal|53201ul
block|,
literal|57557ul
block|,
literal|62233ul
block|,
literal|67307ul
block|,
literal|72817ul
block|,
literal|78779ul
block|,
literal|85229ul
block|,
literal|92203ul
block|,
literal|99733ul
block|,
literal|107897ul
block|,
literal|116731ul
block|,
literal|126271ul
block|,
literal|136607ul
block|,
literal|147793ul
block|,
literal|159871ul
block|,
literal|172933ul
block|,
literal|187091ul
block|,
literal|202409ul
block|,
literal|218971ul
block|,
literal|236897ul
block|,
literal|256279ul
block|,
literal|277261ul
block|,
literal|299951ul
block|,
literal|324503ul
block|,
literal|351061ul
block|,
literal|379787ul
block|,
literal|410857ul
block|,
literal|444487ul
block|,
literal|480881ul
block|,
literal|520241ul
block|,
literal|562841ul
block|,
literal|608903ul
block|,
literal|658753ul
block|,
literal|712697ul
block|,
literal|771049ul
block|,
literal|834181ul
block|,
literal|902483ul
block|,
literal|976369ul
block|,
literal|1056323ul
block|,
literal|1142821ul
block|,
literal|1236397ul
block|,
literal|1337629ul
block|,
literal|1447153ul
block|,
literal|1565659ul
block|,
literal|1693859ul
block|,
literal|1832561ul
block|,
literal|1982627ul
block|,
literal|2144977ul
block|,
literal|2320627ul
block|,
literal|2510653ul
block|,
literal|2716249ul
block|,
literal|2938679ul
block|,
literal|3179303ul
block|,
literal|3439651ul
block|,
literal|3721303ul
block|,
literal|4026031ul
block|,
literal|4355707ul
block|,
literal|4712381ul
block|,
literal|5098259ul
block|,
literal|5515729ul
block|,
literal|5967347ul
block|,
literal|6456007ul
block|,
literal|6984629ul
block|,
literal|7556579ul
block|,
literal|8175383ul
block|,
literal|8844859ul
block|,
literal|9569143ul
block|,
literal|10352717ul
block|,
literal|11200489ul
block|,
literal|12117689ul
block|,
literal|13109983ul
block|,
literal|14183539ul
block|,
literal|15345007ul
block|,
literal|16601593ul
block|,
literal|17961079ul
block|,
literal|19431899ul
block|,
literal|21023161ul
block|,
literal|22744717ul
block|,
literal|24607243ul
block|,
literal|26622317ul
block|,
literal|28802401ul
block|,
literal|31160981ul
block|,
literal|33712729ul
block|,
literal|36473443ul
block|,
literal|39460231ul
block|,
literal|42691603ul
block|,
literal|46187573ul
block|,
literal|49969847ul
block|,
literal|54061849ul
block|,
literal|58488943ul
block|,
literal|63278561ul
block|,
literal|68460391ul
block|,
literal|74066549ul
block|,
literal|80131819ul
block|,
literal|86693767ul
block|,
literal|93793069ul
block|,
literal|101473717ul
block|,
literal|109783337ul
block|,
literal|118773397ul
block|,
literal|128499677ul
block|,
literal|139022417ul
block|,
literal|150406843ul
block|,
literal|162723577ul
block|,
literal|176048909ul
block|,
literal|190465427ul
block|,
literal|206062531ul
block|,
literal|222936881ul
block|,
literal|241193053ul
block|,
literal|260944219ul
block|,
literal|282312799ul
block|,
literal|305431229ul
block|,
literal|330442829ul
block|,
literal|357502601ul
block|,
literal|386778277ul
block|,
literal|418451333ul
block|,
literal|452718089ul
block|,
literal|489790921ul
block|,
literal|529899637ul
block|,
literal|573292817ul
block|,
literal|620239453ul
block|,
literal|671030513ul
block|,
literal|725980837ul
block|,
literal|785430967ul
block|,
literal|849749479ul
block|,
literal|919334987ul
block|,
literal|994618837ul
block|,
literal|1076067617ul
block|,
literal|1164186217ul
block|,
literal|1259520799ul
block|,
literal|1362662261ul
block|,
literal|1474249943ul
block|,
literal|1594975441ul
block|,
literal|1725587117ul
block|,
literal|1866894511ul
block|,
literal|2019773507ul
block|,
literal|2185171673ul
block|,
literal|2364114217ul
block|,
literal|2557710269ul
block|,
literal|2767159799ul
block|,
literal|2993761039ul
block|,
literal|3238918481ul
block|,
literal|3504151727ul
block|,
literal|3791104843ul
block|,
literal|4101556399ul
block|,
literal|4294967291ul
block|,
comment|// Sentinel, so we don't have to test the result of lower_bound,
comment|// or, on 64-bit machines, rest of the table.
name|__ulongsize
operator|!=
literal|8
operator|?
literal|4294967291ul
operator|:
operator|(
name|unsigned
name|long
operator|)
literal|6442450933ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|8589934583ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|12884901857ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|17179869143ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|25769803693ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|34359738337ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|51539607367ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|68719476731ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|103079215087ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|137438953447ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|206158430123ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|274877906899ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|412316860387ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|549755813881ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|824633720731ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|1099511627689ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|1649267441579ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|2199023255531ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|3298534883309ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|4398046511093ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|6597069766607ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|8796093022151ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|13194139533241ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|17592186044399ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|26388279066581ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|35184372088777ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|52776558133177ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|70368744177643ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|105553116266399ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|140737488355213ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|211106232532861ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|281474976710597ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|562949953421231ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|1125899906842597ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|2251799813685119ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|4503599627370449ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|9007199254740881ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|18014398509481951ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|36028797018963913ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|72057594037927931ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|144115188075855859ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|288230376151711717ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|576460752303423433ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|1152921504606846883ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|2305843009213693951ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|4611686018427387847ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|9223372036854775783ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|18446744073709551557ull
block|,
operator|(
name|unsigned
name|long
operator|)
literal|18446744073709551557ull
block|}
expr_stmt|;
comment|// Auxiliary types used for all instantiations of _Hashtable: nodes
comment|// and iterators.
comment|// Nodes, used to wrap elements stored in the hash table.  A policy
comment|// template parameter of class template _Hashtable controls whether
comment|// nodes also store a hash code. In some cases (e.g. strings) this
comment|// may be a performance win.
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__cache_hash_code
operator|>
expr|struct
name|_Hash_node
expr_stmt|;
name|template
operator|<
name|typename
name|_Value
operator|>
expr|struct
name|_Hash_node
operator|<
name|_Value
operator|,
name|true
operator|>
block|{
name|_Value
name|_M_v
block|;
name|std
operator|::
name|size_t
name|_M_hash_code
block|;
name|_Hash_node
operator|*
name|_M_next
block|;     }
expr_stmt|;
name|template
operator|<
name|typename
name|_Value
operator|>
expr|struct
name|_Hash_node
operator|<
name|_Value
operator|,
name|false
operator|>
block|{
name|_Value
name|_M_v
block|;
name|_Hash_node
operator|*
name|_M_next
block|;     }
expr_stmt|;
comment|// Local iterators, used to iterate within a bucket but not between
comment|// buckets.
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__cache
operator|>
expr|struct
name|_Node_iterator_base
block|{
name|_Node_iterator_base
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
name|__p
argument_list|)
operator|:
name|_M_cur
argument_list|(
argument|__p
argument_list|)
block|{ }
name|void
name|_M_incr
argument_list|()
block|{
name|_M_cur
operator|=
name|_M_cur
operator|->
name|_M_next
block|; }
name|_Hash_node
operator|<
name|_Value
block|,
name|__cache
operator|>
operator|*
name|_M_cur
block|;     }
expr_stmt|;
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__cache
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|&
name|__y
operator|)
block|{
return|return
name|__x
operator|.
name|_M_cur
operator|==
name|__y
operator|.
name|_M_cur
return|;
block|}
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__cache
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|&
name|__y
operator|)
block|{
return|return
name|__x
operator|.
name|_M_cur
operator|!=
name|__y
operator|.
name|_M_cur
return|;
block|}
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__constant_iterators
operator|,
name|bool
name|__cache
operator|>
expr|struct
name|_Node_iterator
operator|:
name|public
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
block|{
typedef|typedef
name|_Value
name|value_type
typedef|;
typedef|typedef
name|typename
name|__gnu_cxx
operator|::
name|__conditional_type
operator|<
name|__constant_iterators
operator|,
specifier|const
name|_Value
operator|*
operator|,
name|_Value
operator|*
operator|>
operator|::
name|__type
name|pointer
expr_stmt|;
typedef|typedef
name|typename
name|__gnu_cxx
operator|::
name|__conditional_type
operator|<
name|__constant_iterators
operator|,
specifier|const
name|_Value
operator|&
operator|,
name|_Value
operator|&
operator|>
operator|::
name|__type
name|reference
expr_stmt|;
typedef|typedef
name|std
operator|::
name|ptrdiff_t
name|difference_type
expr_stmt|;
typedef|typedef
name|std
operator|::
name|forward_iterator_tag
name|iterator_category
expr_stmt|;
name|_Node_iterator
argument_list|()
operator|:
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
literal|0
operator|)
block|{ }
name|explicit
name|_Node_iterator
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
name|__p
argument_list|)
operator|:
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
name|__p
operator|)
block|{ }
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|_M_cur
operator|->
name|_M_v
return|;
block|}
name|pointer
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
operator|&
name|this
operator|->
name|_M_cur
operator|->
name|_M_v
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|_Node_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|this
operator|->
name|_M_incr
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Node_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|_Node_iterator
name|__tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|this
operator|->
name|_M_incr
argument_list|()
block|;
return|return
name|__tmp
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__constant_iterators
operator|,
name|bool
name|__cache
operator|>
expr|struct
name|_Node_const_iterator
operator|:
name|public
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
block|{
typedef|typedef
name|_Value
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
specifier|const
name|_Value
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_Value
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|ptrdiff_t
name|difference_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|forward_iterator_tag
name|iterator_category
expr_stmt|;
end_typedef

begin_expr_stmt
name|_Node_const_iterator
argument_list|()
operator|:
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
literal|0
operator|)
block|{ }
name|explicit
name|_Node_const_iterator
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
name|__p
argument_list|)
operator|:
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
name|__p
operator|)
block|{ }
name|_Node_const_iterator
argument_list|(
specifier|const
name|_Node_iterator
operator|<
name|_Value
argument_list|,
name|__constant_iterators
argument_list|,
name|__cache
operator|>
operator|&
name|__x
argument_list|)
operator|:
name|_Node_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
name|__x
operator|.
name|_M_cur
operator|)
block|{ }
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|_M_cur
operator|->
name|_M_v
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
operator|&
name|this
operator|->
name|_M_cur
operator|->
name|_M_v
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Node_const_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|this
operator|->
name|_M_incr
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Node_const_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|_Node_const_iterator
name|__tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|this
operator|->
name|_M_incr
argument_list|()
block|;
return|return
name|__tmp
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__cache
operator|>
expr|struct
name|_Hashtable_iterator_base
block|{
name|_Hashtable_iterator_base
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
name|__node
argument_list|,
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
operator|*
name|__bucket
argument_list|)
operator|:
name|_M_cur_node
argument_list|(
name|__node
argument_list|)
block|,
name|_M_cur_bucket
argument_list|(
argument|__bucket
argument_list|)
block|{ }
name|void
name|_M_incr
argument_list|()
block|{
name|_M_cur_node
operator|=
name|_M_cur_node
operator|->
name|_M_next
block|;
if|if
condition|(
operator|!
name|_M_cur_node
condition|)
name|_M_incr_bucket
argument_list|()
expr_stmt|;
block|}
name|void
name|_M_incr_bucket
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Hash_node
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|*
name|_M_cur_node
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Hash_node
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|*
operator|*
name|_M_cur_bucket
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// Global iterators, used for arbitrary iteration within a hash
end_comment

begin_comment
comment|// table.  Larger and more expensive than local iterators.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__cache
operator|>
name|void
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|::
name|_M_incr_bucket
argument_list|()
block|{
operator|++
name|_M_cur_bucket
block|;
comment|// This loop requires the bucket array to have a non-null sentinel.
while|while
condition|(
operator|!
operator|*
name|_M_cur_bucket
condition|)
operator|++
name|_M_cur_bucket
expr_stmt|;
name|_M_cur_node
operator|=
operator|*
name|_M_cur_bucket
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__cache
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|&
name|__y
operator|)
block|{
return|return
name|__x
operator|.
name|_M_cur_node
operator|==
name|__y
operator|.
name|_M_cur_node
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__cache
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|&
name|__y
operator|)
block|{
return|return
name|__x
operator|.
name|_M_cur_node
operator|!=
name|__y
operator|.
name|_M_cur_node
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__constant_iterators
operator|,
name|bool
name|__cache
operator|>
expr|struct
name|_Hashtable_iterator
operator|:
name|public
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
block|{
typedef|typedef
name|_Value
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|__gnu_cxx
operator|::
name|__conditional_type
operator|<
name|__constant_iterators
operator|,
specifier|const
name|_Value
operator|*
operator|,
name|_Value
operator|*
operator|>
operator|::
name|__type
name|pointer
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|__gnu_cxx
operator|::
name|__conditional_type
operator|<
name|__constant_iterators
operator|,
specifier|const
name|_Value
operator|&
operator|,
name|_Value
operator|&
operator|>
operator|::
name|__type
name|reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|ptrdiff_t
name|difference_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|forward_iterator_tag
name|iterator_category
expr_stmt|;
end_typedef

begin_expr_stmt
name|_Hashtable_iterator
argument_list|()
operator|:
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
literal|0
operator|,
literal|0
operator|)
block|{ }
name|_Hashtable_iterator
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
name|__p
argument_list|,
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
operator|*
name|__b
argument_list|)
operator|:
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
name|__p
operator|,
name|__b
operator|)
block|{ }
name|explicit
name|_Hashtable_iterator
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
operator|*
name|__b
argument_list|)
operator|:
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
operator|*
name|__b
operator|,
name|__b
operator|)
block|{ }
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|_M_cur_node
operator|->
name|_M_v
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
operator|&
name|this
operator|->
name|_M_cur_node
operator|->
name|_M_v
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Hashtable_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|this
operator|->
name|_M_incr
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Hashtable_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|_Hashtable_iterator
name|__tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|this
operator|->
name|_M_incr
argument_list|()
block|;
return|return
name|__tmp
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Value
operator|,
name|bool
name|__constant_iterators
operator|,
name|bool
name|__cache
operator|>
expr|struct
name|_Hashtable_const_iterator
operator|:
name|public
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
block|{
typedef|typedef
name|_Value
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
specifier|const
name|_Value
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_Value
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|ptrdiff_t
name|difference_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|forward_iterator_tag
name|iterator_category
expr_stmt|;
end_typedef

begin_expr_stmt
name|_Hashtable_const_iterator
argument_list|()
operator|:
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
literal|0
operator|,
literal|0
operator|)
block|{ }
name|_Hashtable_const_iterator
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
name|__p
argument_list|,
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
operator|*
name|__b
argument_list|)
operator|:
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
name|__p
operator|,
name|__b
operator|)
block|{ }
name|explicit
name|_Hashtable_const_iterator
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|__cache
operator|>
operator|*
operator|*
name|__b
argument_list|)
operator|:
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
operator|*
name|__b
operator|,
name|__b
operator|)
block|{ }
name|_Hashtable_const_iterator
argument_list|(
specifier|const
name|_Hashtable_iterator
operator|<
name|_Value
argument_list|,
name|__constant_iterators
argument_list|,
name|__cache
operator|>
operator|&
name|__x
argument_list|)
operator|:
name|_Hashtable_iterator_base
operator|<
name|_Value
operator|,
name|__cache
operator|>
operator|(
name|__x
operator|.
name|_M_cur_node
operator|,
name|__x
operator|.
name|_M_cur_bucket
operator|)
block|{ }
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|_M_cur_node
operator|->
name|_M_v
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
block|{
return|return
operator|&
name|this
operator|->
name|_M_cur_node
operator|->
name|_M_v
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Hashtable_const_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|this
operator|->
name|_M_incr
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Hashtable_const_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|_Hashtable_const_iterator
name|__tmp
argument_list|(
operator|*
name|this
argument_list|)
block|;
name|this
operator|->
name|_M_incr
argument_list|()
block|;
return|return
name|__tmp
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Many of class template _Hashtable's template parameters are policy
end_comment

begin_comment
comment|// classes.  These are defaults for the policies.
end_comment

begin_comment
comment|// Default range hashing function: use division to fold a large number
end_comment

begin_comment
comment|// into the range [0, N).
end_comment

begin_struct
struct|struct
name|_Mod_range_hashing
block|{
typedef|typedef
name|std
operator|::
name|size_t
name|first_argument_type
expr_stmt|;
typedef|typedef
name|std
operator|::
name|size_t
name|second_argument_type
expr_stmt|;
typedef|typedef
name|std
operator|::
name|size_t
name|result_type
expr_stmt|;
name|result_type
name|operator
argument_list|()
operator|(
name|first_argument_type
name|__num
operator|,
name|second_argument_type
name|__den
operator|)
specifier|const
block|{
return|return
name|__num
operator|%
name|__den
return|;
block|}
block|}
struct|;
end_struct

begin_comment
comment|// Default ranged hash function H.  In principle it should be a
end_comment

begin_comment
comment|// function object composed from objects of type H1 and H2 such that
end_comment

begin_comment
comment|// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
end_comment

begin_comment
comment|// h1 and h2.  So instead we'll just use a tag to tell class template
end_comment

begin_comment
comment|// hashtable to do that composition.
end_comment

begin_struct
struct|struct
name|_Default_ranged_hash
block|{ }
struct|;
end_struct

begin_comment
comment|// Default value for rehash policy.  Bucket size is (usually) the
end_comment

begin_comment
comment|// smallest prime that keeps the load factor small enough.
end_comment

begin_struct
struct|struct
name|_Prime_rehash_policy
block|{
name|_Prime_rehash_policy
argument_list|(
argument|float __z =
literal|1.0
argument_list|)
empty_stmt|;
name|float
name|max_load_factor
argument_list|()
specifier|const
expr_stmt|;
comment|// Return a bucket size no smaller than n.
name|std
operator|::
name|size_t
name|_M_next_bkt
argument_list|(
argument|std::size_t __n
argument_list|)
specifier|const
expr_stmt|;
comment|// Return a bucket count appropriate for n elements
name|std
operator|::
name|size_t
name|_M_bkt_for_elements
argument_list|(
argument|std::size_t __n
argument_list|)
specifier|const
expr_stmt|;
comment|// __n_bkt is current bucket count, __n_elt is current element count,
comment|// and __n_ins is number of elements to be inserted.  Do we need to
comment|// increase bucket count?  If so, return make_pair(true, n), where n
comment|// is the new bucket count.  If not, return make_pair(false, 0).
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|std
operator|::
name|size_t
operator|>
name|_M_need_rehash
argument_list|(
argument|std::size_t __n_bkt
argument_list|,
argument|std::size_t __n_elt
argument_list|,
argument|std::size_t __n_ins
argument_list|)
specifier|const
expr_stmt|;
name|float
name|_M_max_load_factor
decl_stmt|;
name|float
name|_M_growth_factor
decl_stmt|;
name|mutable
name|std
operator|::
name|size_t
name|_M_next_resize
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|inline
name|_Prime_rehash_policy
operator|::
name|_Prime_rehash_policy
argument_list|(
argument|float __z
argument_list|)
operator|:
name|_M_max_load_factor
argument_list|(
name|__z
argument_list|)
operator|,
name|_M_growth_factor
argument_list|(
literal|2.f
argument_list|)
operator|,
name|_M_next_resize
argument_list|(
literal|0
argument_list|)
block|{ }
specifier|inline
name|float
name|_Prime_rehash_policy
operator|::
name|max_load_factor
argument_list|()
specifier|const
block|{
return|return
name|_M_max_load_factor
return|;
block|}
end_expr_stmt

begin_comment
comment|// Return a prime no smaller than n.
end_comment

begin_expr_stmt
specifier|inline
name|std
operator|::
name|size_t
name|_Prime_rehash_policy
operator|::
name|_M_next_bkt
argument_list|(
argument|std::size_t __n
argument_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|long
operator|*
specifier|const
name|__last
operator|=
operator|(
name|_Primes
operator|<
operator|>
operator|::
name|__primes
operator|+
name|_Primes
operator|<
operator|>
operator|::
name|__n_primes
operator|)
block|;
specifier|const
name|unsigned
name|long
operator|*
name|__p
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|_Primes
operator|<
operator|>
operator|::
name|__primes
argument_list|,
name|__last
argument_list|,
name|__n
argument_list|)
block|;
name|_M_next_resize
operator|=
name|static_cast
operator|<
name|std
operator|::
name|size_t
operator|>
operator|(
name|std
operator|::
name|ceil
argument_list|(
operator|*
name|__p
operator|*
name|_M_max_load_factor
argument_list|)
operator|)
block|;
return|return
operator|*
name|__p
return|;
block|}
end_expr_stmt

begin_comment
comment|// Return the smallest prime p such that alpha p>= n, where alpha
end_comment

begin_comment
comment|// is the load factor.
end_comment

begin_expr_stmt
specifier|inline
name|std
operator|::
name|size_t
name|_Prime_rehash_policy
operator|::
name|_M_bkt_for_elements
argument_list|(
argument|std::size_t __n
argument_list|)
specifier|const
block|{
specifier|const
name|unsigned
name|long
operator|*
specifier|const
name|__last
operator|=
operator|(
name|_Primes
operator|<
operator|>
operator|::
name|__primes
operator|+
name|_Primes
operator|<
operator|>
operator|::
name|__n_primes
operator|)
block|;
specifier|const
name|float
name|__min_bkts
operator|=
name|__n
operator|/
name|_M_max_load_factor
block|;
specifier|const
name|unsigned
name|long
operator|*
name|__p
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|_Primes
operator|<
operator|>
operator|::
name|__primes
argument_list|,
name|__last
argument_list|,
name|__min_bkts
argument_list|,
name|_LessThan
argument_list|()
argument_list|)
block|;
name|_M_next_resize
operator|=
name|static_cast
operator|<
name|std
operator|::
name|size_t
operator|>
operator|(
name|std
operator|::
name|ceil
argument_list|(
operator|*
name|__p
operator|*
name|_M_max_load_factor
argument_list|)
operator|)
block|;
return|return
operator|*
name|__p
return|;
block|}
end_expr_stmt

begin_comment
comment|// Finds the smallest prime p such that alpha p> __n_elt + __n_ins.
end_comment

begin_comment
comment|// If p> __n_bkt, return make_pair(true, p); otherwise return
end_comment

begin_comment
comment|// make_pair(false, 0).  In principle this isn't very different from
end_comment

begin_comment
comment|// _M_bkt_for_elements.
end_comment

begin_comment
comment|// The only tricky part is that we're caching the element count at
end_comment

begin_comment
comment|// which we need to rehash, so we don't have to do a floating-point
end_comment

begin_comment
comment|// multiply for every insertion.
end_comment

begin_expr_stmt
specifier|inline
name|std
operator|::
name|pair
operator|<
name|bool
operator|,
name|std
operator|::
name|size_t
operator|>
name|_Prime_rehash_policy
operator|::
name|_M_need_rehash
argument_list|(
argument|std::size_t __n_bkt
argument_list|,
argument|std::size_t __n_elt
argument_list|,
argument|std::size_t __n_ins
argument_list|)
specifier|const
block|{
if|if
condition|(
name|__n_elt
operator|+
name|__n_ins
operator|>
name|_M_next_resize
condition|)
block|{
name|float
name|__min_bkts
init|=
operator|(
operator|(
name|float
argument_list|(
name|__n_ins
argument_list|)
operator|+
name|float
argument_list|(
name|__n_elt
argument_list|)
operator|)
operator|/
name|_M_max_load_factor
operator|)
decl_stmt|;
if|if
condition|(
name|__min_bkts
operator|>
name|__n_bkt
condition|)
block|{
name|__min_bkts
operator|=
name|std
operator|::
name|max
argument_list|(
name|__min_bkts
argument_list|,
name|_M_growth_factor
operator|*
name|__n_bkt
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|long
modifier|*
specifier|const
name|__last
init|=
operator|(
name|_Primes
operator|<
operator|>
operator|::
name|__primes
operator|+
name|_Primes
operator|<
operator|>
operator|::
name|__n_primes
operator|)
decl_stmt|;
specifier|const
name|unsigned
name|long
modifier|*
name|__p
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|_Primes
operator|<
operator|>
operator|::
name|__primes
argument_list|,
name|__last
argument_list|,
name|__min_bkts
argument_list|,
name|_LessThan
argument_list|()
argument_list|)
decl_stmt|;
name|_M_next_resize
operator|=
name|static_cast
operator|<
name|std
operator|::
name|size_t
operator|>
operator|(
name|std
operator|::
name|ceil
argument_list|(
operator|*
name|__p
operator|*
name|_M_max_load_factor
argument_list|)
operator|)
expr_stmt|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|true
argument_list|,
operator|*
name|__p
argument_list|)
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|_M_next_resize
operator|=
name|static_cast
operator|<
name|std
operator|::
name|size_t
operator|>
operator|(
name|std
operator|::
name|ceil
argument_list|(
name|__n_bkt
operator|*
name|_M_max_load_factor
argument_list|)
operator|)
expr_stmt|;
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_else

begin_return
unit|}     else
return|return
name|std
operator|::
name|make_pair
argument_list|(
name|false
argument_list|,
literal|0
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// Base classes for std::tr1::_Hashtable.  We define these base
end_comment

begin_comment
comment|// classes because in some cases we want to do different things
end_comment

begin_comment
comment|// depending on the value of a policy class.  In some cases the
end_comment

begin_comment
comment|// policy class affects which member functions and nested typedefs
end_comment

begin_comment
comment|// are defined; we handle that by specializing base class templates.
end_comment

begin_comment
comment|// Several of the base class templates need to access other members
end_comment

begin_comment
comment|// of class template _Hashtable, so we use the "curiously recurring
end_comment

begin_comment
comment|// template pattern" for them.
end_comment

begin_comment
comment|// class template _Map_base.  If the hashtable has a value type of the
end_comment

begin_comment
comment|// form pair<T1, T2> and a key extraction policy that returns the
end_comment

begin_comment
comment|// first part of the pair, the hashtable gets a mapped_type typedef.
end_comment

begin_comment
comment|// If it satisfies those criteria and also has unique keys, then it
end_comment

begin_comment
comment|// also gets an operator[].
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_Key
operator|,
name|typename
name|_Value
operator|,
name|typename
name|_Ex
operator|,
name|bool
name|__unique
operator|,
name|typename
name|_Hashtable
operator|>
expr|struct
name|_Map_base
block|{ }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Key
operator|,
name|typename
name|_Pair
operator|,
name|typename
name|_Hashtable
operator|>
expr|struct
name|_Map_base
operator|<
name|_Key
operator|,
name|_Pair
operator|,
name|std
operator|::
name|_Select1st
operator|<
name|_Pair
operator|>
operator|,
name|false
operator|,
name|_Hashtable
operator|>
block|{
typedef|typedef
name|typename
name|_Pair
operator|::
name|second_type
name|mapped_type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Key
operator|,
name|typename
name|_Pair
operator|,
name|typename
name|_Hashtable
operator|>
expr|struct
name|_Map_base
operator|<
name|_Key
operator|,
name|_Pair
operator|,
name|std
operator|::
name|_Select1st
operator|<
name|_Pair
operator|>
operator|,
name|true
operator|,
name|_Hashtable
operator|>
block|{
typedef|typedef
name|typename
name|_Pair
operator|::
name|second_type
name|mapped_type
expr_stmt|;
name|mapped_type
operator|&
name|operator
index|[]
operator|(
specifier|const
name|_Key
operator|&
name|__k
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Key
operator|,
name|typename
name|_Pair
operator|,
name|typename
name|_Hashtable
operator|>
name|typename
name|_Map_base
operator|<
name|_Key
operator|,
name|_Pair
operator|,
name|std
operator|::
name|_Select1st
operator|<
name|_Pair
operator|>
operator|,
name|true
operator|,
name|_Hashtable
operator|>
operator|::
name|mapped_type
operator|&
name|_Map_base
operator|<
name|_Key
operator|,
name|_Pair
operator|,
name|std
operator|::
name|_Select1st
operator|<
name|_Pair
operator|>
operator|,
name|true
operator|,
name|_Hashtable
operator|>
operator|::
name|operator
index|[]
operator|(
specifier|const
name|_Key
operator|&
name|__k
operator|)
block|{
name|_Hashtable
operator|*
name|__h
operator|=
name|static_cast
operator|<
name|_Hashtable
operator|*
operator|>
operator|(
name|this
operator|)
block|;
name|typename
name|_Hashtable
operator|::
name|_Hash_code_type
name|__code
operator|=
name|__h
operator|->
name|_M_hash_code
argument_list|(
name|__k
argument_list|)
block|;
name|std
operator|::
name|size_t
name|__n
operator|=
name|__h
operator|->
name|_M_bucket_index
argument_list|(
name|__k
argument_list|,
name|__code
argument_list|,
name|__h
operator|->
name|_M_bucket_count
argument_list|)
block|;
name|typename
name|_Hashtable
operator|::
name|_Node
operator|*
name|__p
operator|=
name|__h
operator|->
name|_M_find_node
argument_list|(
name|__h
operator|->
name|_M_buckets
index|[
name|__n
index|]
argument_list|,
name|__k
argument_list|,
name|__code
argument_list|)
block|;
if|if
condition|(
operator|!
name|__p
condition|)
return|return
name|__h
operator|->
name|_M_insert_bucket
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|__k
argument_list|,
name|mapped_type
argument_list|()
argument_list|)
argument_list|,
name|__n
argument_list|,
name|__code
argument_list|)
operator|->
name|second
return|;
end_expr_stmt

begin_return
return|return
operator|(
name|__p
operator|->
name|_M_v
operator|)
operator|.
name|second
return|;
end_return

begin_comment
unit|}
comment|// class template _Rehash_base.  Give hashtable the max_load_factor
end_comment

begin_comment
comment|// functions iff the rehash policy is _Prime_rehash_policy.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RehashPolicy
operator|,
name|typename
name|_Hashtable
operator|>
expr|struct
name|_Rehash_base
block|{ }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Hashtable
operator|>
expr|struct
name|_Rehash_base
operator|<
name|_Prime_rehash_policy
operator|,
name|_Hashtable
operator|>
block|{
name|float
name|max_load_factor
argument_list|()
specifier|const
block|{
specifier|const
name|_Hashtable
operator|*
name|__this
operator|=
name|static_cast
operator|<
specifier|const
name|_Hashtable
operator|*
operator|>
operator|(
name|this
operator|)
block|;
return|return
name|__this
operator|->
name|__rehash_policy
argument_list|()
operator|.
name|max_load_factor
argument_list|()
return|;
block|}
name|void
name|max_load_factor
argument_list|(
argument|float __z
argument_list|)
block|{
name|_Hashtable
operator|*
name|__this
operator|=
name|static_cast
operator|<
name|_Hashtable
operator|*
operator|>
operator|(
name|this
operator|)
block|;
name|__this
operator|->
name|__rehash_policy
argument_list|(
name|_Prime_rehash_policy
argument_list|(
name|__z
argument_list|)
argument_list|)
block|;       }
end_expr_stmt

begin_comment
unit|};
comment|// Class template _Hash_code_base.  Encapsulates two policy issues that
end_comment

begin_comment
comment|// aren't quite orthogonal.
end_comment

begin_comment
comment|//   (1) the difference between using a ranged hash function and using
end_comment

begin_comment
comment|//       the combination of a hash function and a range-hashing function.
end_comment

begin_comment
comment|//       In the former case we don't have such things as hash codes, so
end_comment

begin_comment
comment|//       we have a dummy type as placeholder.
end_comment

begin_comment
comment|//   (2) Whether or not we cache hash codes.  Caching hash codes is
end_comment

begin_comment
comment|//       meaningless if we have a ranged hash function.
end_comment

begin_comment
comment|// We also put the key extraction and equality comparison function
end_comment

begin_comment
comment|// objects here, for convenience.
end_comment

begin_comment
comment|// Primary template: unused except as a hook for specializations.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Key
operator|,
name|typename
name|_Value
operator|,
name|typename
name|_ExtractKey
operator|,
name|typename
name|_Equal
operator|,
name|typename
name|_H1
operator|,
name|typename
name|_H2
operator|,
name|typename
name|_Hash
operator|,
name|bool
name|__cache_hash_code
operator|>
expr|struct
name|_Hash_code_base
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Specialization: ranged hash function, no caching hash codes.  H1
end_comment

begin_comment
comment|// and H2 are provided but ignored.  We define a dummy hash code type.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Key
operator|,
name|typename
name|_Value
operator|,
name|typename
name|_ExtractKey
operator|,
name|typename
name|_Equal
operator|,
name|typename
name|_H1
operator|,
name|typename
name|_H2
operator|,
name|typename
name|_Hash
operator|>
expr|struct
name|_Hash_code_base
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_ExtractKey
operator|,
name|_Equal
operator|,
name|_H1
operator|,
name|_H2
operator|,
name|_Hash
operator|,
name|false
operator|>
block|{
name|protected
operator|:
name|_Hash_code_base
argument_list|(
specifier|const
name|_ExtractKey
operator|&
name|__ex
argument_list|,
specifier|const
name|_Equal
operator|&
name|__eq
argument_list|,
specifier|const
name|_H1
operator|&
argument_list|,
specifier|const
name|_H2
operator|&
argument_list|,
specifier|const
name|_Hash
operator|&
name|__h
argument_list|)
operator|:
name|_M_extract
argument_list|(
name|__ex
argument_list|)
block|,
name|_M_eq
argument_list|(
name|__eq
argument_list|)
block|,
name|_M_ranged_hash
argument_list|(
argument|__h
argument_list|)
block|{ }
typedef|typedef
name|void
modifier|*
name|_Hash_code_type
typedef|;
name|_Hash_code_type
name|_M_hash_code
argument_list|(
argument|const _Key& __key
argument_list|)
specifier|const
block|{
return|return
literal|0
return|;
block|}
name|std
operator|::
name|size_t
name|_M_bucket_index
argument_list|(
argument|const _Key& __k
argument_list|,
argument|_Hash_code_type
argument_list|,
argument|std::size_t __n
argument_list|)
specifier|const
block|{
return|return
name|_M_ranged_hash
argument_list|(
name|__k
argument_list|,
name|__n
argument_list|)
return|;
block|}
name|std
operator|::
name|size_t
name|_M_bucket_index
argument_list|(
argument|const _Hash_node<_Value
argument_list|,
argument|false>* __p
argument_list|,
argument|std::size_t __n
argument_list|)
specifier|const
block|{
return|return
name|_M_ranged_hash
argument_list|(
name|_M_extract
argument_list|(
name|__p
operator|->
name|_M_v
argument_list|)
argument_list|,
name|__n
argument_list|)
return|;
block|}
name|bool
name|_M_compare
argument_list|(
argument|const _Key& __k
argument_list|,
argument|_Hash_code_type
argument_list|,
argument|_Hash_node<_Value
argument_list|,
argument|false>* __n
argument_list|)
specifier|const
block|{
return|return
name|_M_eq
argument_list|(
name|__k
argument_list|,
name|_M_extract
argument_list|(
name|__n
operator|->
name|_M_v
argument_list|)
argument_list|)
return|;
block|}
name|void
name|_M_store_code
argument_list|(
argument|_Hash_node<_Value
argument_list|,
argument|false>*
argument_list|,
argument|_Hash_code_type
argument_list|)
specifier|const
block|{ }
name|void
name|_M_copy_code
argument_list|(
argument|_Hash_node<_Value
argument_list|,
argument|false>*
argument_list|,
argument|const _Hash_node<_Value
argument_list|,
argument|false>*
argument_list|)
specifier|const
block|{ }
name|void
name|_M_swap
argument_list|(
argument|_Hash_code_base& __x
argument_list|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|_M_extract
argument_list|,
name|__x
operator|.
name|_M_extract
argument_list|)
block|;
name|std
operator|::
name|swap
argument_list|(
name|_M_eq
argument_list|,
name|__x
operator|.
name|_M_eq
argument_list|)
block|;
name|std
operator|::
name|swap
argument_list|(
name|_M_ranged_hash
argument_list|,
name|__x
operator|.
name|_M_ranged_hash
argument_list|)
block|;       }
name|protected
operator|:
name|_ExtractKey
name|_M_extract
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_Equal
name|_M_eq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Hash
name|_M_ranged_hash
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// No specialization for ranged hash function while caching hash codes.
end_comment

begin_comment
comment|// That combination is meaningless, and trying to do it is an error.
end_comment

begin_comment
comment|// Specialization: ranged hash function, cache hash codes.  This
end_comment

begin_comment
comment|// combination is meaningless, so we provide only a declaration
end_comment

begin_comment
comment|// and no definition.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Key
operator|,
name|typename
name|_Value
operator|,
name|typename
name|_ExtractKey
operator|,
name|typename
name|_Equal
operator|,
name|typename
name|_H1
operator|,
name|typename
name|_H2
operator|,
name|typename
name|_Hash
operator|>
expr|struct
name|_Hash_code_base
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_ExtractKey
operator|,
name|_Equal
operator|,
name|_H1
operator|,
name|_H2
operator|,
name|_Hash
operator|,
name|true
operator|>
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Specialization: hash function and range-hashing function, no
end_comment

begin_comment
comment|// caching of hash codes.  H is provided but ignored.  Provides
end_comment

begin_comment
comment|// typedef and accessor required by TR1.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Key
operator|,
name|typename
name|_Value
operator|,
name|typename
name|_ExtractKey
operator|,
name|typename
name|_Equal
operator|,
name|typename
name|_H1
operator|,
name|typename
name|_H2
operator|>
expr|struct
name|_Hash_code_base
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_ExtractKey
operator|,
name|_Equal
operator|,
name|_H1
operator|,
name|_H2
operator|,
name|_Default_ranged_hash
operator|,
name|false
operator|>
block|{
typedef|typedef
name|_H1
name|hasher
typedef|;
name|hasher
name|hash_function
argument_list|()
specifier|const
block|{
return|return
name|_M_h1
return|;
block|}
name|protected
operator|:
name|_Hash_code_base
argument_list|(
specifier|const
name|_ExtractKey
operator|&
name|__ex
argument_list|,
specifier|const
name|_Equal
operator|&
name|__eq
argument_list|,
specifier|const
name|_H1
operator|&
name|__h1
argument_list|,
specifier|const
name|_H2
operator|&
name|__h2
argument_list|,
specifier|const
name|_Default_ranged_hash
operator|&
argument_list|)
operator|:
name|_M_extract
argument_list|(
name|__ex
argument_list|)
operator|,
name|_M_eq
argument_list|(
name|__eq
argument_list|)
operator|,
name|_M_h1
argument_list|(
name|__h1
argument_list|)
operator|,
name|_M_h2
argument_list|(
argument|__h2
argument_list|)
block|{ }
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|size_t
name|_Hash_code_type
expr_stmt|;
end_typedef

begin_decl_stmt
name|_Hash_code_type
name|_M_hash_code
argument_list|(
specifier|const
name|_Key
operator|&
name|__k
argument_list|)
decl|const
block|{
return|return
name|_M_h1
argument_list|(
name|__k
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_M_bucket_index
argument_list|(
argument|const _Key&
argument_list|,
argument|_Hash_code_type __c
argument_list|,
argument|std::size_t __n
argument_list|)
specifier|const
block|{
return|return
name|_M_h2
argument_list|(
name|__c
argument_list|,
name|__n
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_M_bucket_index
argument_list|(
argument|const _Hash_node<_Value
argument_list|,
argument|false>* __p
argument_list|,
argument|std::size_t __n
argument_list|)
specifier|const
block|{
return|return
name|_M_h2
argument_list|(
name|_M_h1
argument_list|(
name|_M_extract
argument_list|(
name|__p
operator|->
name|_M_v
argument_list|)
argument_list|)
argument_list|,
name|__n
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|bool
name|_M_compare
argument_list|(
specifier|const
name|_Key
operator|&
name|__k
argument_list|,
name|_Hash_code_type
argument_list|,
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|false
operator|>
operator|*
name|__n
argument_list|)
decl|const
block|{
return|return
name|_M_eq
argument_list|(
name|__k
argument_list|,
name|_M_extract
argument_list|(
name|__n
operator|->
name|_M_v
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|_M_store_code
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|false
operator|>
operator|*
argument_list|,
name|_Hash_code_type
argument_list|)
decl|const
block|{ }
end_decl_stmt

begin_decl_stmt
name|void
name|_M_copy_code
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|false
operator|>
operator|*
argument_list|,
specifier|const
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|false
operator|>
operator|*
argument_list|)
decl|const
block|{ }
end_decl_stmt

begin_function
name|void
name|_M_swap
parameter_list|(
name|_Hash_code_base
modifier|&
name|__x
parameter_list|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|_M_extract
argument_list|,
name|__x
operator|.
name|_M_extract
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|_M_eq
argument_list|,
name|__x
operator|.
name|_M_eq
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|_M_h1
argument_list|,
name|__x
operator|.
name|_M_h1
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|_M_h2
argument_list|,
name|__x
operator|.
name|_M_h2
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|_ExtractKey
name|_M_extract
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Equal
name|_M_eq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_H1
name|_M_h1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_H2
name|_M_h2
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Specialization: hash function and range-hashing function,
end_comment

begin_comment
comment|// caching hash codes.  H is provided but ignored.  Provides
end_comment

begin_comment
comment|// typedef and accessor required by TR1.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Key
operator|,
name|typename
name|_Value
operator|,
name|typename
name|_ExtractKey
operator|,
name|typename
name|_Equal
operator|,
name|typename
name|_H1
operator|,
name|typename
name|_H2
operator|>
expr|struct
name|_Hash_code_base
operator|<
name|_Key
operator|,
name|_Value
operator|,
name|_ExtractKey
operator|,
name|_Equal
operator|,
name|_H1
operator|,
name|_H2
operator|,
name|_Default_ranged_hash
operator|,
name|true
operator|>
block|{
typedef|typedef
name|_H1
name|hasher
typedef|;
name|hasher
name|hash_function
argument_list|()
specifier|const
block|{
return|return
name|_M_h1
return|;
block|}
name|protected
operator|:
name|_Hash_code_base
argument_list|(
specifier|const
name|_ExtractKey
operator|&
name|__ex
argument_list|,
specifier|const
name|_Equal
operator|&
name|__eq
argument_list|,
specifier|const
name|_H1
operator|&
name|__h1
argument_list|,
specifier|const
name|_H2
operator|&
name|__h2
argument_list|,
specifier|const
name|_Default_ranged_hash
operator|&
argument_list|)
operator|:
name|_M_extract
argument_list|(
name|__ex
argument_list|)
operator|,
name|_M_eq
argument_list|(
name|__eq
argument_list|)
operator|,
name|_M_h1
argument_list|(
name|__h1
argument_list|)
operator|,
name|_M_h2
argument_list|(
argument|__h2
argument_list|)
block|{ }
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|size_t
name|_Hash_code_type
expr_stmt|;
end_typedef

begin_decl_stmt
name|_Hash_code_type
name|_M_hash_code
argument_list|(
specifier|const
name|_Key
operator|&
name|__k
argument_list|)
decl|const
block|{
return|return
name|_M_h1
argument_list|(
name|__k
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_M_bucket_index
argument_list|(
argument|const _Key&
argument_list|,
argument|_Hash_code_type __c
argument_list|,
argument|std::size_t __n
argument_list|)
specifier|const
block|{
return|return
name|_M_h2
argument_list|(
name|__c
argument_list|,
name|__n
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_M_bucket_index
argument_list|(
argument|const _Hash_node<_Value
argument_list|,
argument|true>* __p
argument_list|,
argument|std::size_t __n
argument_list|)
specifier|const
block|{
return|return
name|_M_h2
argument_list|(
name|__p
operator|->
name|_M_hash_code
argument_list|,
name|__n
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|bool
name|_M_compare
argument_list|(
specifier|const
name|_Key
operator|&
name|__k
argument_list|,
name|_Hash_code_type
name|__c
argument_list|,
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|true
operator|>
operator|*
name|__n
argument_list|)
decl|const
block|{
return|return
name|__c
operator|==
name|__n
operator|->
name|_M_hash_code
operator|&&
name|_M_eq
argument_list|(
name|__k
argument_list|,
name|_M_extract
argument_list|(
name|__n
operator|->
name|_M_v
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|_M_store_code
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|true
operator|>
operator|*
name|__n
argument_list|,
name|_Hash_code_type
name|__c
argument_list|)
decl|const
block|{
name|__n
operator|->
name|_M_hash_code
operator|=
name|__c
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|_M_copy_code
argument_list|(
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|true
operator|>
operator|*
name|__to
argument_list|,
specifier|const
name|_Hash_node
operator|<
name|_Value
argument_list|,
name|true
operator|>
operator|*
name|__from
argument_list|)
decl|const
block|{
name|__to
operator|->
name|_M_hash_code
operator|=
name|__from
operator|->
name|_M_hash_code
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|_M_swap
parameter_list|(
name|_Hash_code_base
modifier|&
name|__x
parameter_list|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|_M_extract
argument_list|,
name|__x
operator|.
name|_M_extract
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|_M_eq
argument_list|,
name|__x
operator|.
name|_M_eq
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|_M_h1
argument_list|,
name|__x
operator|.
name|_M_h1
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|_M_h2
argument_list|,
name|__x
operator|.
name|_M_h2
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|_ExtractKey
name|_M_extract
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Equal
name|_M_eq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_H1
name|_M_h1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_H2
name|_M_h2
decl_stmt|;
end_decl_stmt

begin_comment
unit|}; }
comment|// namespace __detail
end_comment

begin_comment
unit|_GLIBCXX_END_NAMESPACE }
comment|// namespace std::tr1
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// _TR1_HASHTABLE_POLICY_H
end_comment

end_unit

