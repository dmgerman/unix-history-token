begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// Allocators -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|/*  * Copyright (c) 1996-1997  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/** @file stl_alloc.h  *  This is an internal header file, included by other library headers.  *  You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GLIBCPP_INTERNAL_ALLOC_H
end_ifndef

begin_define
define|#
directive|define
name|__GLIBCPP_INTERNAL_ALLOC_H
end_define

begin_comment
comment|/**  *  @defgroup Allocators Memory Allocators  *  @if maint  *  stl_alloc.h implements some node allocators.  These are NOT the same as  *  allocators in the C++ standard, nor in the original H-P STL.  They do not  *  encapsulate different pointer types; we assume that there is only one  *  pointer type.  The C++ standard allocators are intended to allocate  *  individual objects, not pools or arenas.  *  *  In this file allocators are of two different styles:  "standard" and  *  "SGI" (quotes included).  "Standard" allocators conform to 20.4.  "SGI"  *  allocators differ in AT LEAST the following ways (add to this list as you  *  discover them):  *  *   - "Standard" allocate() takes two parameters (n_count,hint=0) but "SGI"  *     allocate() takes one paramter (n_size).  *   - Likewise, "standard" deallocate()'s argument is a count, but in "SGI"  *     is a byte size.  *   - max_size(), construct(), and destroy() are missing in "SGI" allocators.  *   - reallocate(p,oldsz,newsz) is added in "SGI", and behaves as  *     if p=realloc(p,newsz).  *  *  "SGI" allocators may be wrapped in __allocator to convert the interface  *  into a "standard" one.  *  @endif  *  *  @note The @c reallocate member functions have been deprecated for 3.2  *        and will be removed in 3.4.  You must define @c _GLIBCPP_DEPRECATED  *        to make this visible in 3.2; see c++config.h.  *  *  The canonical description of these classes is in docs/html/ext/howto.html  *  or online at http://gcc.gnu.org/onlinedocs/libstdc++/ext/howto.html#3 */
end_comment

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<bits/functexcept.h>
end_include

begin_comment
comment|// For __throw_bad_alloc
end_comment

begin_include
include|#
directive|include
file|<bits/stl_threads.h>
end_include

begin_include
include|#
directive|include
file|<bits/atomicity.h>
end_include

begin_decl_stmt
name|namespace
name|std
block|{
comment|/**    *  @if maint    *  A new-based allocator, as required by the standard.  Allocation and    *  deallocation forward to global new and delete.  "SGI" style, minus    *  reallocate().    *  @endif    *  (See @link Allocators allocators info @endlink for more.)    */
name|class
name|__new_alloc
block|{
name|public
label|:
specifier|static
name|void
modifier|*
name|allocate
parameter_list|(
name|size_t
name|__n
parameter_list|)
block|{
return|return
operator|::
name|operator
name|new
argument_list|(
name|__n
argument_list|)
return|;
block|}
specifier|static
name|void
name|deallocate
parameter_list|(
name|void
modifier|*
name|__p
parameter_list|,
name|size_t
parameter_list|)
block|{
operator|::
name|operator
name|delete
argument_list|(
name|__p
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/**    *  @if maint    *  A malloc-based allocator.  Typically slower than the    *  __default_alloc_template (below).  Typically thread-safe and more    *  storage efficient.  The template argument is unused and is only present    *  to permit multiple instantiations (but see __default_alloc_template    *  for caveats).  "SGI" style, plus __set_malloc_handler for OOM conditions.    *  @endif    *  (See @link Allocators allocators info @endlink for more.)    */
name|template
operator|<
name|int
name|__inst
operator|>
name|class
name|__malloc_alloc_template
block|{
name|private
operator|:
specifier|static
name|void
operator|*
name|_S_oom_malloc
argument_list|(
name|size_t
argument_list|)
block|;
comment|// _GLIBCPP_DEPRECATED
specifier|static
name|void
operator|*
name|_S_oom_realloc
argument_list|(
name|void
operator|*
argument_list|,
name|size_t
argument_list|)
block|;
specifier|static
name|void
argument_list|(
operator|*
name|__malloc_alloc_oom_handler
argument_list|)
argument_list|()
block|;
name|public
operator|:
specifier|static
name|void
operator|*
name|allocate
argument_list|(
argument|size_t __n
argument_list|)
block|{
name|void
operator|*
name|__result
operator|=
name|malloc
argument_list|(
name|__n
argument_list|)
block|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__result
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|__result
operator|=
name|_S_oom_malloc
argument_list|(
name|__n
argument_list|)
expr_stmt|;
return|return
name|__result
return|;
block|}
specifier|static
name|void
name|deallocate
parameter_list|(
name|void
modifier|*
name|__p
parameter_list|,
name|size_t
comment|/* __n */
parameter_list|)
block|{
name|free
argument_list|(
name|__p
argument_list|)
expr_stmt|;
block|}
comment|// _GLIBCPP_DEPRECATED
specifier|static
name|void
modifier|*
name|reallocate
parameter_list|(
name|void
modifier|*
name|__p
parameter_list|,
name|size_t
comment|/* old_sz */
parameter_list|,
name|size_t
name|__new_sz
parameter_list|)
block|{
name|void
modifier|*
name|__result
init|=
name|realloc
argument_list|(
name|__p
argument_list|,
name|__new_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__result
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|__result
operator|=
name|_S_oom_realloc
argument_list|(
name|__p
argument_list|,
name|__new_sz
argument_list|)
expr_stmt|;
return|return
name|__result
return|;
block|}
specifier|static
name|void
argument_list|(
argument|* __set_malloc_handler(void (*__f)())
argument_list|)
operator|(
operator|)
block|{
name|void
argument_list|(
operator|*
name|__old
argument_list|)
argument_list|()
operator|=
name|__malloc_alloc_oom_handler
block|;
name|__malloc_alloc_oom_handler
operator|=
name|__f
block|;
return|return
name|__old
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// malloc_alloc out-of-memory handling
end_comment

begin_expr_stmt
name|template
operator|<
name|int
name|__inst
operator|>
name|void
argument_list|(
operator|*
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
operator|::
name|__malloc_alloc_oom_handler
argument_list|)
argument_list|()
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|__inst
operator|>
name|void
operator|*
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
operator|::
name|_S_oom_malloc
argument_list|(
argument|size_t __n
argument_list|)
block|{
name|void
argument_list|(
operator|*
name|__my_malloc_handler
argument_list|)
argument_list|()
block|;
name|void
operator|*
name|__result
block|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|__my_malloc_handler
operator|=
name|__malloc_alloc_oom_handler
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__my_malloc_handler
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|__throw_bad_alloc
argument_list|()
expr_stmt|;
call|(
modifier|*
name|__my_malloc_handler
call|)
argument_list|()
expr_stmt|;
name|__result
operator|=
name|malloc
argument_list|(
name|__n
argument_list|)
expr_stmt|;
if|if
condition|(
name|__result
condition|)
return|return
name|__result
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// _GLIBCPP_DEPRECATED
end_comment

begin_expr_stmt
unit|template
operator|<
name|int
name|__inst
operator|>
name|void
operator|*
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
operator|::
name|_S_oom_realloc
argument_list|(
argument|void* __p
argument_list|,
argument|size_t __n
argument_list|)
block|{
name|void
argument_list|(
operator|*
name|__my_malloc_handler
argument_list|)
argument_list|()
block|;
name|void
operator|*
name|__result
block|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|__my_malloc_handler
operator|=
name|__malloc_alloc_oom_handler
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__my_malloc_handler
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|__throw_bad_alloc
argument_list|()
expr_stmt|;
call|(
modifier|*
name|__my_malloc_handler
call|)
argument_list|()
expr_stmt|;
name|__result
operator|=
name|realloc
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|)
expr_stmt|;
if|if
condition|(
name|__result
condition|)
return|return
name|__result
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// Should not be referenced within the library anymore.
end_comment

begin_decl_stmt
unit|typedef
name|__new_alloc
name|__mem_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    *  @if maint    *  This is used primarily (only?) in _Alloc_traits and other places to    *  help provide the _Alloc_type typedef.  All it does is forward the    *  requests after some minimal checking.    *    *  This is neither "standard"-conforming nor "SGI".  The _Alloc parameter    *  must be "SGI" style.    *  @endif    *  (See @link Allocators allocators info @endlink for more.)    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Alloc
operator|>
name|class
name|__simple_alloc
block|{
name|public
operator|:
specifier|static
name|_Tp
operator|*
name|allocate
argument_list|(
argument|size_t __n
argument_list|)
block|{
name|_Tp
operator|*
name|__ret
operator|=
literal|0
block|;
if|if
condition|(
name|__n
condition|)
name|__ret
operator|=
name|static_cast
operator|<
name|_Tp
operator|*
operator|>
operator|(
name|_Alloc
operator|::
name|allocate
argument_list|(
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|__ret
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|_Tp
modifier|*
name|allocate
parameter_list|()
block|{
return|return
operator|(
name|_Tp
operator|*
operator|)
name|_Alloc
operator|::
name|allocate
argument_list|(
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|deallocate
parameter_list|(
name|_Tp
modifier|*
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|!=
name|__n
condition|)
name|_Alloc
operator|::
name|deallocate
argument_list|(
name|__p
argument_list|,
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|deallocate
parameter_list|(
name|_Tp
modifier|*
name|__p
parameter_list|)
block|{
name|_Alloc
operator|::
name|deallocate
argument_list|(
name|__p
argument_list|,
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|/**    *  @if maint    *  An adaptor for an underlying allocator (_Alloc) to check the size    *  arguments for debugging.  Errors are reported using assert; these    *  checks can be disabled via NDEBUG, but the space penalty is still    *  paid, therefore it is far better to just use the underlying allocator    *  by itelf when no checking is desired.    *    *  "There is some evidence that this can confuse Purify." - SGI comment    *    *  This adaptor is "SGI" style.  The _Alloc parameter must also be "SGI".    *  @endif    *  (See @link Allocators allocators info @endlink for more.)    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Alloc
operator|>
name|class
name|__debug_alloc
block|{
name|private
operator|:
comment|// Size of space used to store size.  Note that this must be
comment|// large enough to preserve alignment.
expr|enum
block|{
name|_S_extra
operator|=
literal|8
block|}
block|;
name|public
operator|:
specifier|static
name|void
operator|*
name|allocate
argument_list|(
argument|size_t __n
argument_list|)
block|{
name|char
operator|*
name|__result
operator|=
operator|(
name|char
operator|*
operator|)
name|_Alloc
operator|::
name|allocate
argument_list|(
name|__n
operator|+
operator|(
name|int
operator|)
name|_S_extra
argument_list|)
block|;
operator|*
operator|(
name|size_t
operator|*
operator|)
name|__result
operator|=
name|__n
block|;
return|return
name|__result
operator|+
operator|(
name|int
operator|)
name|_S_extra
return|;
block|}
specifier|static
name|void
name|deallocate
argument_list|(
argument|void* __p
argument_list|,
argument|size_t __n
argument_list|)
block|{
name|char
operator|*
name|__real_p
operator|=
operator|(
name|char
operator|*
operator|)
name|__p
operator|-
operator|(
name|int
operator|)
name|_S_extra
block|;
name|assert
argument_list|(
operator|*
operator|(
name|size_t
operator|*
operator|)
name|__real_p
operator|==
name|__n
argument_list|)
block|;
name|_Alloc
operator|::
name|deallocate
argument_list|(
name|__real_p
argument_list|,
name|__n
operator|+
operator|(
name|int
operator|)
name|_S_extra
argument_list|)
block|;       }
comment|// _GLIBCPP_DEPRECATED
specifier|static
name|void
operator|*
name|reallocate
argument_list|(
argument|void* __p
argument_list|,
argument|size_t __old_sz
argument_list|,
argument|size_t __new_sz
argument_list|)
block|{
name|char
operator|*
name|__real_p
operator|=
operator|(
name|char
operator|*
operator|)
name|__p
operator|-
operator|(
name|int
operator|)
name|_S_extra
block|;
name|assert
argument_list|(
operator|*
operator|(
name|size_t
operator|*
operator|)
name|__real_p
operator|==
name|__old_sz
argument_list|)
block|;
name|char
operator|*
name|__result
operator|=
operator|(
name|char
operator|*
operator|)
name|_Alloc
operator|::
name|reallocate
argument_list|(
name|__real_p
argument_list|,
name|__old_sz
operator|+
operator|(
name|int
operator|)
name|_S_extra
argument_list|,
name|__new_sz
operator|+
operator|(
name|int
operator|)
name|_S_extra
argument_list|)
block|;
operator|*
operator|(
name|size_t
operator|*
operator|)
name|__result
operator|=
name|__new_sz
block|;
return|return
name|__result
operator|+
operator|(
name|int
operator|)
name|_S_extra
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/**    *  @if maint    *  Default node allocator.  "SGI" style.  Uses various allocators to    *  fulfill underlying requests (and makes as few requests as possible    *  when in default high-speed pool mode).    *    *  Important implementation properties:    *  0. If globally mandated, then allocate objects from __new_alloc    *  1. If the clients request an object of size> _MAX_BYTES, the resulting    *     object will be obtained directly from __new_alloc    *  2. In all other cases, we allocate an object of size exactly    *     _S_round_up(requested_size).  Thus the client has enough size    *     information that we can return the object to the proper free list    *     without permanently losing part of the object.    *    *  The first template parameter specifies whether more than one thread may    *  use this allocator.  It is safe to allocate an object from one instance    *  of a default_alloc and deallocate it with another one.  This effectively    *  transfers its ownership to the second one.  This may have undesirable    *  effects on reference locality.    *    *  The second parameter is unused and serves only to allow the creation of    *  multiple default_alloc instances.  Note that containers built on different    *  allocator instances have different types, limiting the utility of this    *  approach.  If you do not wish to share the free lists with the main    *  default_alloc instance, instantiate this with a non-zero __inst.    *    *  @endif    *  (See @link Allocators allocators info @endlink for more.)    */
end_comment

begin_expr_stmt
name|template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
name|class
name|__default_alloc_template
block|{
name|private
operator|:
expr|enum
block|{
name|_ALIGN
operator|=
literal|8
block|}
block|;       enum
block|{
name|_MAX_BYTES
operator|=
literal|128
block|}
block|;       enum
block|{
name|_NFREELISTS
operator|=
name|_MAX_BYTES
operator|/
name|_ALIGN
block|}
block|;
expr|union
name|_Obj
block|{
expr|union
name|_Obj
operator|*
name|_M_free_list_link
block|;
name|char
name|_M_client_data
index|[
literal|1
index|]
block|;
comment|// The client sees this.
block|}
block|;
specifier|static
name|_Obj
operator|*
specifier|volatile
name|_S_free_list
index|[
name|_NFREELISTS
index|]
block|;
comment|// Chunk allocation state.
specifier|static
name|char
operator|*
name|_S_start_free
block|;
specifier|static
name|char
operator|*
name|_S_end_free
block|;
specifier|static
name|size_t
name|_S_heap_size
block|;
specifier|static
name|_STL_mutex_lock
name|_S_node_allocator_lock
block|;
specifier|static
name|size_t
name|_S_round_up
argument_list|(
argument|size_t __bytes
argument_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|__bytes
operator|)
operator|+
operator|(
name|size_t
operator|)
name|_ALIGN
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|size_t
operator|)
name|_ALIGN
operator|-
literal|1
operator|)
operator|)
return|;
block|}
specifier|static
name|size_t
name|_S_freelist_index
argument_list|(
argument|size_t __bytes
argument_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|__bytes
operator|)
operator|+
operator|(
name|size_t
operator|)
name|_ALIGN
operator|-
literal|1
operator|)
operator|/
operator|(
name|size_t
operator|)
name|_ALIGN
operator|-
literal|1
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Returns an object of size __n, and optionally adds to size __n
end_comment

begin_comment
comment|// free list.
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|_S_refill
parameter_list|(
name|size_t
name|__n
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Allocates a chunk for nobjs of size size.  nobjs may be reduced
end_comment

begin_comment
comment|// if it is inconvenient to allocate the requested number.
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|_S_chunk_alloc
parameter_list|(
name|size_t
name|__size
parameter_list|,
name|int
modifier|&
name|__nobjs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// It would be nice to use _STL_auto_lock here.  But we need a
end_comment

begin_comment
comment|// test whether threads are in use.
end_comment

begin_struct
struct|struct
name|_Lock
block|{
name|_Lock
argument_list|()
block|{
if|if
condition|(
name|__threads
condition|)
name|_S_node_allocator_lock
operator|.
name|_M_acquire_lock
argument_list|()
expr_stmt|;
block|}
operator|~
name|_Lock
argument_list|()
block|{
if|if
condition|(
name|__threads
condition|)
name|_S_node_allocator_lock
operator|.
name|_M_release_lock
argument_list|()
expr_stmt|;
block|}
block|}
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
struct|;
end_struct

begin_macro
name|friend
end_macro

begin_struct_decl
struct_decl|struct
name|_Lock
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|_Atomic_word
name|_S_force_new
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|// __n must be> 0
end_comment

begin_function
specifier|static
name|void
modifier|*
name|allocate
parameter_list|(
name|size_t
name|__n
parameter_list|)
block|{
name|void
modifier|*
name|__ret
init|=
literal|0
decl_stmt|;
comment|// If there is a race through here, assume answer from getenv
comment|// will resolve in same direction.  Inspired by techniques
comment|// to efficiently support threading found in basic_string.h.
if|if
condition|(
name|_S_force_new
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|getenv
argument_list|(
literal|"GLIBCPP_FORCE_NEW"
argument_list|)
condition|)
name|__atomic_add
argument_list|(
operator|&
name|_S_force_new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|__atomic_add
argument_list|(
operator|&
name|_S_force_new
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Trust but verify...
name|assert
argument_list|(
name|_S_force_new
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|__n
operator|>
operator|(
name|size_t
operator|)
name|_MAX_BYTES
operator|)
operator|||
operator|(
name|_S_force_new
operator|>
literal|0
operator|)
condition|)
name|__ret
operator|=
name|__new_alloc
operator|::
name|allocate
argument_list|(
name|__n
argument_list|)
expr_stmt|;
else|else
block|{
name|_Obj
modifier|*
specifier|volatile
modifier|*
name|__my_free_list
init|=
name|_S_free_list
operator|+
name|_S_freelist_index
argument_list|(
name|__n
argument_list|)
decl_stmt|;
comment|// Acquire the lock here with a constructor call.  This
comment|// ensures that it is released in exit or during stack
comment|// unwinding.
name|_Lock
name|__lock_instance
decl_stmt|;
name|_Obj
modifier|*
name|__restrict__
name|__result
init|=
operator|*
name|__my_free_list
decl_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__result
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|__ret
operator|=
name|_S_refill
argument_list|(
name|_S_round_up
argument_list|(
name|__n
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|__my_free_list
operator|=
name|__result
operator|->
name|_M_free_list_link
expr_stmt|;
name|__ret
operator|=
name|__result
expr_stmt|;
block|}
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__ret
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|__throw_bad_alloc
argument_list|()
expr_stmt|;
block|}
return|return
name|__ret
return|;
block|}
end_function

begin_comment
comment|// __p may not be 0
end_comment

begin_function
specifier|static
name|void
name|deallocate
parameter_list|(
name|void
modifier|*
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|)
block|{
if|if
condition|(
operator|(
name|__n
operator|>
operator|(
name|size_t
operator|)
name|_MAX_BYTES
operator|)
operator|||
operator|(
name|_S_force_new
operator|>
literal|0
operator|)
condition|)
name|__new_alloc
operator|::
name|deallocate
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|)
expr_stmt|;
else|else
block|{
name|_Obj
modifier|*
specifier|volatile
modifier|*
name|__my_free_list
init|=
name|_S_free_list
operator|+
name|_S_freelist_index
argument_list|(
name|__n
argument_list|)
decl_stmt|;
name|_Obj
modifier|*
name|__q
init|=
operator|(
name|_Obj
operator|*
operator|)
name|__p
decl_stmt|;
comment|// Acquire the lock here with a constructor call.  This
comment|// ensures that it is released in exit or during stack
comment|// unwinding.
name|_Lock
name|__lock_instance
decl_stmt|;
name|__q
operator|->
name|_M_free_list_link
operator|=
operator|*
name|__my_free_list
expr_stmt|;
operator|*
name|__my_free_list
operator|=
name|__q
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// _GLIBCPP_DEPRECATED
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|reallocate
parameter_list|(
name|void
modifier|*
name|__p
parameter_list|,
name|size_t
name|__old_sz
parameter_list|,
name|size_t
name|__new_sz
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
unit|};
name|template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
name|_Atomic_word
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|::
name|_S_force_new
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|&
operator|,
specifier|const
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|&
operator|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|&
operator|,
specifier|const
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|&
operator|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_comment
comment|// We allocate memory in large chunks in order to avoid fragmenting the
end_comment

begin_comment
comment|// heap too much.  We assume that __size is properly aligned.  We hold
end_comment

begin_comment
comment|// the allocation lock.
end_comment

begin_expr_stmt
name|template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
name|char
operator|*
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|::
name|_S_chunk_alloc
argument_list|(
argument|size_t __size
argument_list|,
argument|int& __nobjs
argument_list|)
block|{
name|char
operator|*
name|__result
block|;
name|size_t
name|__total_bytes
operator|=
name|__size
operator|*
name|__nobjs
block|;
name|size_t
name|__bytes_left
operator|=
name|_S_end_free
operator|-
name|_S_start_free
block|;
if|if
condition|(
name|__bytes_left
operator|>=
name|__total_bytes
condition|)
block|{
name|__result
operator|=
name|_S_start_free
expr_stmt|;
name|_S_start_free
operator|+=
name|__total_bytes
expr_stmt|;
return|return
name|__result
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|__bytes_left
operator|>=
name|__size
condition|)
block|{
name|__nobjs
operator|=
call|(
name|int
call|)
argument_list|(
name|__bytes_left
operator|/
name|__size
argument_list|)
expr_stmt|;
name|__total_bytes
operator|=
name|__size
operator|*
name|__nobjs
expr_stmt|;
name|__result
operator|=
name|_S_start_free
expr_stmt|;
name|_S_start_free
operator|+=
name|__total_bytes
expr_stmt|;
return|return
name|__result
return|;
block|}
end_elseif

begin_else
else|else
block|{
name|size_t
name|__bytes_to_get
init|=
literal|2
operator|*
name|__total_bytes
operator|+
name|_S_round_up
argument_list|(
name|_S_heap_size
operator|>>
literal|4
argument_list|)
decl_stmt|;
comment|// Try to make use of the left-over piece.
if|if
condition|(
name|__bytes_left
operator|>
literal|0
condition|)
block|{
name|_Obj
modifier|*
specifier|volatile
modifier|*
name|__my_free_list
init|=
name|_S_free_list
operator|+
name|_S_freelist_index
argument_list|(
name|__bytes_left
argument_list|)
decl_stmt|;
operator|(
operator|(
name|_Obj
operator|*
operator|)
name|_S_start_free
operator|)
operator|->
name|_M_free_list_link
operator|=
operator|*
name|__my_free_list
expr_stmt|;
operator|*
name|__my_free_list
operator|=
operator|(
name|_Obj
operator|*
operator|)
name|_S_start_free
expr_stmt|;
block|}
name|_S_start_free
operator|=
operator|(
name|char
operator|*
operator|)
name|__new_alloc
operator|::
name|allocate
argument_list|(
name|__bytes_to_get
argument_list|)
expr_stmt|;
if|if
condition|(
name|_S_start_free
operator|==
literal|0
condition|)
block|{
name|size_t
name|__i
decl_stmt|;
name|_Obj
modifier|*
specifier|volatile
modifier|*
name|__my_free_list
decl_stmt|;
name|_Obj
modifier|*
name|__p
decl_stmt|;
comment|// Try to make do with what we have.  That can't hurt.  We
comment|// do not try smaller requests, since that tends to result
comment|// in disaster on multi-process machines.
name|__i
operator|=
name|__size
expr_stmt|;
for|for
control|(
init|;
name|__i
operator|<=
operator|(
name|size_t
operator|)
name|_MAX_BYTES
condition|;
name|__i
operator|+=
operator|(
name|size_t
operator|)
name|_ALIGN
control|)
block|{
name|__my_free_list
operator|=
name|_S_free_list
operator|+
name|_S_freelist_index
argument_list|(
name|__i
argument_list|)
expr_stmt|;
name|__p
operator|=
operator|*
name|__my_free_list
expr_stmt|;
if|if
condition|(
name|__p
operator|!=
literal|0
condition|)
block|{
operator|*
name|__my_free_list
operator|=
name|__p
operator|->
name|_M_free_list_link
expr_stmt|;
name|_S_start_free
operator|=
operator|(
name|char
operator|*
operator|)
name|__p
expr_stmt|;
name|_S_end_free
operator|=
name|_S_start_free
operator|+
name|__i
expr_stmt|;
return|return
name|_S_chunk_alloc
argument_list|(
name|__size
argument_list|,
name|__nobjs
argument_list|)
return|;
comment|// Any leftover piece will eventually make it to the
comment|// right free list.
block|}
block|}
name|_S_end_free
operator|=
literal|0
expr_stmt|;
comment|// In case of exception.
name|_S_start_free
operator|=
operator|(
name|char
operator|*
operator|)
name|__new_alloc
operator|::
name|allocate
argument_list|(
name|__bytes_to_get
argument_list|)
expr_stmt|;
comment|// This should either throw an exception or remedy the situation.
comment|// Thus we assume it succeeded.
block|}
name|_S_heap_size
operator|+=
name|__bytes_to_get
expr_stmt|;
name|_S_end_free
operator|=
name|_S_start_free
operator|+
name|__bytes_to_get
expr_stmt|;
return|return
name|_S_chunk_alloc
argument_list|(
name|__size
argument_list|,
name|__nobjs
argument_list|)
return|;
block|}
end_else

begin_comment
unit|}
comment|// Returns an object of size __n, and optionally adds to "size
end_comment

begin_comment
comment|// __n"'s free list.  We assume that __n is properly aligned.  We
end_comment

begin_comment
comment|// hold the allocation lock.
end_comment

begin_expr_stmt
unit|template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
name|void
operator|*
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|::
name|_S_refill
argument_list|(
argument|size_t __n
argument_list|)
block|{
name|int
name|__nobjs
operator|=
literal|20
block|;
name|char
operator|*
name|__chunk
operator|=
name|_S_chunk_alloc
argument_list|(
name|__n
argument_list|,
name|__nobjs
argument_list|)
block|;
name|_Obj
operator|*
specifier|volatile
operator|*
name|__my_free_list
block|;
name|_Obj
operator|*
name|__result
block|;
name|_Obj
operator|*
name|__current_obj
block|;
name|_Obj
operator|*
name|__next_obj
block|;
name|int
name|__i
block|;
if|if
condition|(
literal|1
operator|==
name|__nobjs
condition|)
return|return
name|__chunk
return|;
name|__my_free_list
operator|=
name|_S_free_list
operator|+
name|_S_freelist_index
argument_list|(
name|__n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Build free list in chunk.
end_comment

begin_expr_stmt
name|__result
operator|=
operator|(
name|_Obj
operator|*
operator|)
name|__chunk
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|__my_free_list
operator|=
name|__next_obj
operator|=
operator|(
name|_Obj
operator|*
operator|)
operator|(
name|__chunk
operator|+
name|__n
operator|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|__i
operator|=
literal|1
init|;
condition|;
name|__i
operator|++
control|)
block|{
name|__current_obj
operator|=
name|__next_obj
expr_stmt|;
name|__next_obj
operator|=
operator|(
name|_Obj
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|__next_obj
operator|+
name|__n
operator|)
expr_stmt|;
if|if
condition|(
name|__nobjs
operator|-
literal|1
operator|==
name|__i
condition|)
block|{
name|__current_obj
operator|->
name|_M_free_list_link
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
name|__current_obj
operator|->
name|_M_free_list_link
operator|=
name|__next_obj
expr_stmt|;
block|}
end_for

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|// _GLIBCPP_DEPRECATED
end_comment

begin_expr_stmt
unit|template
operator|<
name|bool
name|threads
operator|,
name|int
name|inst
operator|>
name|void
operator|*
name|__default_alloc_template
operator|<
name|threads
operator|,
name|inst
operator|>
operator|::
name|reallocate
argument_list|(
argument|void* __p
argument_list|,
argument|size_t __old_sz
argument_list|,
argument|size_t __new_sz
argument_list|)
block|{
name|void
operator|*
name|__result
block|;
name|size_t
name|__copy_sz
block|;
if|if
condition|(
name|__old_sz
operator|>
operator|(
name|size_t
operator|)
name|_MAX_BYTES
operator|&&
name|__new_sz
operator|>
operator|(
name|size_t
operator|)
name|_MAX_BYTES
condition|)
return|return
operator|(
name|realloc
argument_list|(
name|__p
argument_list|,
name|__new_sz
argument_list|)
operator|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|_S_round_up
argument_list|(
name|__old_sz
argument_list|)
operator|==
name|_S_round_up
argument_list|(
name|__new_sz
argument_list|)
condition|)
return|return
operator|(
name|__p
operator|)
return|;
end_if

begin_expr_stmt
name|__result
operator|=
name|allocate
argument_list|(
name|__new_sz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__copy_sz
operator|=
name|__new_sz
operator|>
name|__old_sz
condition|?
name|__old_sz
else|:
name|__new_sz
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|memcpy
argument_list|(
name|__result
argument_list|,
name|__p
argument_list|,
name|__copy_sz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|deallocate
argument_list|(
name|__p
argument_list|,
name|__old_sz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__result
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
name|_STL_mutex_lock
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|::
name|_S_node_allocator_lock
name|__STL_MUTEX_INITIALIZER
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
name|char
operator|*
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|::
name|_S_start_free
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
name|char
operator|*
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|::
name|_S_end_free
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
name|size_t
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|::
name|_S_heap_size
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
name|typename
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|::
name|_Obj
operator|*
specifier|volatile
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
operator|::
name|_S_free_list
index|[
name|_NFREELISTS
index|]
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|__default_alloc_template
operator|<
name|true
operator|,
literal|0
operator|>
name|__alloc
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__default_alloc_template
operator|<
name|false
operator|,
literal|0
operator|>
name|__single_client_alloc
expr_stmt|;
end_typedef

begin_comment
comment|/**    *  @brief  The "standard" allocator, as per [20.4].    *    *  The private _Alloc is "SGI" style.  (See comments at the top    *  of stl_alloc.h.)    *    *  The underlying allocator behaves as follows.    *    - __default_alloc_template is used via two typedefs    *    - "__single_client_alloc" typedef does no locking for threads    *    - "__alloc" typedef is threadsafe via the locks    *    - __new_alloc is used for memory requests    *    *  (See @link Allocators allocators info @endlink for more.)    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|allocator
block|{
typedef|typedef
name|__alloc
name|_Alloc
typedef|;
comment|// The underlying allocator.
name|public
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|size_t
name|size_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_Tp
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_Tp
modifier|&
name|const_reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
name|value_type
typedef|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|allocator
operator|<
name|_Tp1
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|allocator
argument_list|()
end_macro

begin_macro
name|throw
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|allocator
argument_list|(
argument|const allocator&
argument_list|)
end_macro

begin_macro
name|throw
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|allocator
argument_list|(
argument|const allocator<_Tp1>&
argument_list|)
name|throw
argument_list|()
block|{}
operator|~
name|allocator
argument_list|()
name|throw
argument_list|()
block|{}
name|pointer
name|address
argument_list|(
argument|reference __x
argument_list|)
specifier|const
block|{
return|return
operator|&
name|__x
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|const_pointer
name|address
argument_list|(
name|const_reference
name|__x
argument_list|)
decl|const
block|{
return|return
operator|&
name|__x
return|;
block|}
end_decl_stmt

begin_comment
comment|// NB: __n is permitted to be 0.  The C++ standard says nothing
end_comment

begin_comment
comment|// about what the return value is when __n == 0.
end_comment

begin_function
name|_Tp
modifier|*
name|allocate
parameter_list|(
name|size_type
name|__n
parameter_list|,
specifier|const
name|void
modifier|*
init|=
literal|0
parameter_list|)
block|{
name|_Tp
modifier|*
name|__ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__n
condition|)
block|{
if|if
condition|(
name|__n
operator|<=
name|this
operator|->
name|max_size
argument_list|()
condition|)
name|__ret
operator|=
name|static_cast
operator|<
name|_Tp
operator|*
operator|>
operator|(
name|_Alloc
operator|::
name|allocate
argument_list|(
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
name|__throw_bad_alloc
argument_list|()
expr_stmt|;
block|}
return|return
name|__ret
return|;
block|}
end_function

begin_comment
comment|// __p is not permitted to be a null pointer.
end_comment

begin_function
name|void
name|deallocate
parameter_list|(
name|pointer
name|__p
parameter_list|,
name|size_type
name|__n
parameter_list|)
block|{
name|_Alloc
operator|::
name|deallocate
argument_list|(
name|__p
argument_list|,
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|size_t
argument_list|(
operator|-
literal|1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|construct
parameter_list|(
name|pointer
name|__p
parameter_list|,
specifier|const
name|_Tp
modifier|&
name|__val
parameter_list|)
block|{
name|new
argument_list|(
argument|__p
argument_list|)
name|_Tp
argument_list|(
name|__val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|destroy
parameter_list|(
name|pointer
name|__p
parameter_list|)
block|{
name|__p
operator|->
expr|~
name|_Tp
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
name|class
name|allocator
operator|<
name|void
operator|>
block|{
name|public
operator|:
typedef|typedef
name|size_t
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|void
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
name|value_type
typedef|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|allocator
operator|<
name|_Tp1
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_T1
operator|,
name|typename
name|_T2
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|allocator
operator|<
name|_T1
operator|>
operator|&
operator|,
specifier|const
name|allocator
operator|<
name|_T2
operator|>
operator|&
operator|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_T1
operator|,
name|typename
name|_T2
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|allocator
operator|<
name|_T1
operator|>
operator|&
operator|,
specifier|const
name|allocator
operator|<
name|_T2
operator|>
operator|&
operator|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @if maint    *  Allocator adaptor to turn an "SGI" style allocator (e.g.,    *  __alloc, __malloc_alloc_template) into a "standard" conforming    *  allocator.  Note that this adaptor does *not* assume that all    *  objects of the underlying alloc class are identical, nor does it    *  assume that all of the underlying alloc's member functions are    *  static member functions.  Note, also, that __allocator<_Tp,    *  __alloc> is essentially the same thing as allocator<_Tp>.    *  @endif    *  (See @link Allocators allocators info @endlink for more.)    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Alloc
operator|>
expr|struct
name|__allocator
block|{
name|_Alloc
name|__underlying_alloc
block|;
typedef|typedef
name|size_t
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_Tp
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_Tp
modifier|&
name|const_reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
name|value_type
typedef|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|__allocator
operator|<
name|_Tp1
operator|,
name|_Alloc
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|__allocator
argument_list|()
end_macro

begin_macro
name|throw
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|__allocator
argument_list|(
argument|const __allocator& __a
argument_list|)
end_macro

begin_expr_stmt
name|throw
argument_list|()
operator|:
name|__underlying_alloc
argument_list|(
argument|__a.__underlying_alloc
argument_list|)
block|{}
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__allocator
argument_list|(
argument|const __allocator<_Tp1
argument_list|,
argument|_Alloc>& __a
argument_list|)
name|throw
argument_list|()
operator|:
name|__underlying_alloc
argument_list|(
argument|__a.__underlying_alloc
argument_list|)
block|{}
operator|~
name|__allocator
argument_list|()
name|throw
argument_list|()
block|{}
name|pointer
name|address
argument_list|(
argument|reference __x
argument_list|)
specifier|const
block|{
return|return
operator|&
name|__x
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|const_pointer
name|address
argument_list|(
name|const_reference
name|__x
argument_list|)
decl|const
block|{
return|return
operator|&
name|__x
return|;
block|}
end_decl_stmt

begin_comment
comment|// NB: __n is permitted to be 0.  The C++ standard says nothing
end_comment

begin_comment
comment|// about what the return value is when __n == 0.
end_comment

begin_function
name|_Tp
modifier|*
name|allocate
parameter_list|(
name|size_type
name|__n
parameter_list|,
specifier|const
name|void
modifier|*
init|=
literal|0
parameter_list|)
block|{
name|_Tp
modifier|*
name|__ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__n
condition|)
name|__ret
operator|=
name|static_cast
operator|<
name|_Tp
operator|*
operator|>
operator|(
name|_Alloc
operator|::
name|allocate
argument_list|(
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|__ret
return|;
block|}
end_function

begin_comment
comment|// __p is not permitted to be a null pointer.
end_comment

begin_function
name|void
name|deallocate
parameter_list|(
name|pointer
name|__p
parameter_list|,
name|size_type
name|__n
parameter_list|)
block|{
name|__underlying_alloc
operator|.
name|deallocate
argument_list|(
name|__p
argument_list|,
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|size_t
argument_list|(
operator|-
literal|1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|construct
parameter_list|(
name|pointer
name|__p
parameter_list|,
specifier|const
name|_Tp
modifier|&
name|__val
parameter_list|)
block|{
name|new
argument_list|(
argument|__p
argument_list|)
name|_Tp
argument_list|(
name|__val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|destroy
parameter_list|(
name|pointer
name|__p
parameter_list|)
block|{
name|__p
operator|->
expr|~
name|_Tp
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Alloc
operator|>
expr|struct
name|__allocator
operator|<
name|void
operator|,
name|_Alloc
operator|>
block|{
typedef|typedef
name|size_t
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|void
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
name|value_type
typedef|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|__allocator
operator|<
name|_Tp1
operator|,
name|_Alloc
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__allocator
operator|<
name|_Tp
operator|,
name|_Alloc
operator|>
operator|&
name|__a1
operator|,
specifier|const
name|__allocator
operator|<
name|_Tp
operator|,
name|_Alloc
operator|>
operator|&
name|__a2
operator|)
block|{
return|return
name|__a1
operator|.
name|__underlying_alloc
operator|==
name|__a2
operator|.
name|__underlying_alloc
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|__allocator
operator|<
name|_Tp
operator|,
name|_Alloc
operator|>
operator|&
name|__a1
operator|,
specifier|const
name|__allocator
operator|<
name|_Tp
operator|,
name|_Alloc
operator|>
operator|&
name|__a2
operator|)
block|{
return|return
name|__a1
operator|.
name|__underlying_alloc
operator|!=
name|__a2
operator|.
name|__underlying_alloc
return|;
block|}
end_expr_stmt

begin_comment
comment|//@{
end_comment

begin_comment
comment|/** Comparison operators for all of the predifined SGI-style allocators.    *  This ensures that __allocator<malloc_alloc> (for example) will work    *  correctly.  As required, all allocators compare equal.    */
end_comment

begin_expr_stmt
name|template
operator|<
name|int
name|inst
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__malloc_alloc_template
operator|<
name|inst
operator|>
operator|&
operator|,
specifier|const
name|__malloc_alloc_template
operator|<
name|inst
operator|>
operator|&
operator|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|__inst
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
operator|&
operator|,
specifier|const
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
operator|&
operator|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__debug_alloc
operator|<
name|_Alloc
operator|>
operator|&
operator|,
specifier|const
name|__debug_alloc
operator|<
name|_Alloc
operator|>
operator|&
operator|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|__debug_alloc
operator|<
name|_Alloc
operator|>
operator|&
operator|,
specifier|const
name|__debug_alloc
operator|<
name|_Alloc
operator|>
operator|&
operator|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_comment
comment|//@}
end_comment

begin_comment
comment|/**    *  @if maint    *  Another allocator adaptor:  _Alloc_traits.  This serves two purposes.    *  First, make it possible to write containers that can use either "SGI"    *  style allocators or "standard" allocators.  Second, provide a mechanism    *  so that containers can query whether or not the allocator has distinct    *  instances.  If not, the container can avoid wasting a word of memory to    *  store an empty object.  For examples of use, see stl_vector.h, etc, or    *  any of the other classes derived from this one.    *    *  This adaptor uses partial specialization.  The general case of    *  _Alloc_traits<_Tp, _Alloc> assumes that _Alloc is a    *  standard-conforming allocator, possibly with non-equal instances and    *  non-static members.  (It still behaves correctly even if _Alloc has    *  static member and if all instances are equal.  Refinements affect    *  performance, not correctness.)    *    *  There are always two members:  allocator_type, which is a standard-    *  conforming allocator type for allocating objects of type _Tp, and    *  _S_instanceless, a static const member of type bool.  If    *  _S_instanceless is true, this means that there is no difference    *  between any two instances of type allocator_type.  Furthermore, if    *  _S_instanceless is true, then _Alloc_traits has one additional    *  member:  _Alloc_type.  This type encapsulates allocation and    *  deallocation of objects of type _Tp through a static interface; it    *  has two member functions, whose signatures are    *    *  -  static _Tp* allocate(size_t)    *  -  static void deallocate(_Tp*, size_t)    *    *  The size_t parameters are "standard" style (see top of stl_alloc.h) in    *  that they take counts, not sizes.    *    *  @endif    *  (See @link Allocators allocators info @endlink for more.)    */
end_comment

begin_comment
comment|//@{
end_comment

begin_comment
comment|// The fully general version.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Allocator
operator|>
expr|struct
name|_Alloc_traits
block|{
specifier|static
specifier|const
name|bool
name|_S_instanceless
operator|=
name|false
block|;
typedef|typedef
name|typename
name|_Allocator
operator|::
name|template
name|rebind
operator|<
name|_Tp
operator|>
operator|::
name|other
name|allocator_type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Allocator
operator|>
specifier|const
name|bool
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|_Allocator
operator|>
operator|::
name|_S_instanceless
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// The version for the default allocator.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Tp1
operator|>
expr|struct
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|allocator
operator|<
name|_Tp1
operator|>
expr|>
block|{
specifier|static
specifier|const
name|bool
name|_S_instanceless
operator|=
name|true
block|;
typedef|typedef
name|__simple_alloc
operator|<
name|_Tp
operator|,
name|__alloc
operator|>
name|_Alloc_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|allocator
operator|<
name|_Tp
operator|>
name|allocator_type
expr_stmt|;
end_typedef

begin_comment
unit|};
comment|//@}
end_comment

begin_comment
comment|//@{
end_comment

begin_comment
comment|/// Versions for the predefined "SGI" style allocators.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|int
name|__inst
operator|>
expr|struct
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
expr|>
block|{
specifier|static
specifier|const
name|bool
name|_S_instanceless
operator|=
name|true
block|;
typedef|typedef
name|__simple_alloc
operator|<
name|_Tp
operator|,
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
expr|>
name|_Alloc_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|__allocator
operator|<
name|_Tp
operator|,
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
expr|>
name|allocator_type
expr_stmt|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp
operator|,
name|bool
name|__threads
operator|,
name|int
name|__inst
operator|>
expr|struct
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
expr|>
block|{
specifier|static
specifier|const
name|bool
name|_S_instanceless
operator|=
name|true
block|;
typedef|typedef
name|__simple_alloc
operator|<
name|_Tp
operator|,
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
expr|>
name|_Alloc_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|__allocator
operator|<
name|_Tp
operator|,
name|__default_alloc_template
operator|<
name|__threads
operator|,
name|__inst
operator|>
expr|>
name|allocator_type
expr_stmt|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Alloc
operator|>
expr|struct
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|__debug_alloc
operator|<
name|_Alloc
operator|>
expr|>
block|{
specifier|static
specifier|const
name|bool
name|_S_instanceless
operator|=
name|true
block|;
typedef|typedef
name|__simple_alloc
operator|<
name|_Tp
operator|,
name|__debug_alloc
operator|<
name|_Alloc
operator|>
expr|>
name|_Alloc_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|__allocator
operator|<
name|_Tp
operator|,
name|__debug_alloc
operator|<
name|_Alloc
operator|>
expr|>
name|allocator_type
expr_stmt|;
end_typedef

begin_comment
unit|};
comment|//@}
end_comment

begin_comment
comment|//@{
end_comment

begin_comment
comment|/// Versions for the __allocator adaptor used with the predefined
end_comment

begin_comment
comment|/// "SGI" style allocators.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Tp1
operator|,
name|int
name|__inst
operator|>
expr|struct
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|__allocator
operator|<
name|_Tp1
operator|,
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
expr|>
operator|>
block|{
specifier|static
specifier|const
name|bool
name|_S_instanceless
operator|=
name|true
block|;
typedef|typedef
name|__simple_alloc
operator|<
name|_Tp
operator|,
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
expr|>
name|_Alloc_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|__allocator
operator|<
name|_Tp
operator|,
name|__malloc_alloc_template
operator|<
name|__inst
operator|>
expr|>
name|allocator_type
expr_stmt|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Tp1
operator|,
name|bool
name|__thr
operator|,
name|int
name|__inst
operator|>
expr|struct
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|__allocator
operator|<
name|_Tp1
operator|,
name|__default_alloc_template
operator|<
name|__thr
operator|,
name|__inst
operator|>
expr|>
operator|>
block|{
specifier|static
specifier|const
name|bool
name|_S_instanceless
operator|=
name|true
block|;
typedef|typedef
name|__simple_alloc
operator|<
name|_Tp
operator|,
name|__default_alloc_template
operator|<
name|__thr
operator|,
name|__inst
operator|>
expr|>
name|_Alloc_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|__allocator
operator|<
name|_Tp
operator|,
name|__default_alloc_template
operator|<
name|__thr
operator|,
name|__inst
operator|>
expr|>
name|allocator_type
expr_stmt|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Tp1
operator|,
name|typename
name|_Alloc
operator|>
expr|struct
name|_Alloc_traits
operator|<
name|_Tp
operator|,
name|__allocator
operator|<
name|_Tp1
operator|,
name|__debug_alloc
operator|<
name|_Alloc
operator|>
expr|>
operator|>
block|{
specifier|static
specifier|const
name|bool
name|_S_instanceless
operator|=
name|true
block|;
typedef|typedef
name|__simple_alloc
operator|<
name|_Tp
operator|,
name|__debug_alloc
operator|<
name|_Alloc
operator|>
expr|>
name|_Alloc_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|__allocator
operator|<
name|_Tp
operator|,
name|__debug_alloc
operator|<
name|_Alloc
operator|>
expr|>
name|allocator_type
expr_stmt|;
end_typedef

begin_comment
unit|};
comment|//@}
end_comment

begin_comment
comment|// Inhibit implicit instantiations for required instantiations,
end_comment

begin_comment
comment|// which are defined via explicit instantiations elsewhere.
end_comment

begin_comment
comment|// NB: This syntax is a GNU extension.
end_comment

begin_extern
extern|extern template class allocator<char>;
end_extern

begin_extern
extern|extern template class allocator<wchar_t>;
end_extern

begin_extern
extern|extern template class __default_alloc_template<true
operator|,
extern|0>;
end_extern

begin_comment
unit|}
comment|// namespace std
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

