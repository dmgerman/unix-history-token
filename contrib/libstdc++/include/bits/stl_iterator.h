begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// Iterators -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|/*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1996-1998  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/** @file stl_iterator.h  *  This is an internal header file, included by other library headers.  *  You should not attempt to use it directly.  *  *  This file implements reverse_iterator, back_insert_iterator,  *  front_insert_iterator, insert_iterator, __normal_iterator, and their  *  supporting functions and overloaded operators.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GLIBCPP_INTERNAL_ITERATOR_H
end_ifndef

begin_define
define|#
directive|define
name|__GLIBCPP_INTERNAL_ITERATOR_H
end_define

begin_decl_stmt
name|namespace
name|std
block|{
comment|// 24.4.1 Reverse iterators
comment|/**    *  "Bidirectional and random access iterators have corresponding reverse    *  %iterator adaptors that iterate through the data structure in the    *  opposite direction.  They have the same signatures as the corresponding    *  iterators.  The fundamental relation between a reverse %iterator and its    *  corresponding %iterator @c i is established by the identity:    *  @code    *&*(reverse_iterator(i)) ==&*(i - 1)    *  @endcode    *    *  This mapping is dictated by the fact that while there is always a    *  pointer past the end of an array, there might not be a valid pointer    *  before the beginning of an array." [24.4.1]/1,2    *    *  Reverse iterators can be tricky and surprising at first.  Their    *  semantics make sense, however, and the trickiness is a side effect of    *  the requirement that the iterators must be safe.   */
name|template
operator|<
name|typename
name|_Iterator
operator|>
name|class
name|reverse_iterator
operator|:
name|public
name|iterator
operator|<
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|iterator_category
operator|,
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|value_type
operator|,
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|difference_type
operator|,
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|pointer
operator|,
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|reference
operator|>
block|{
name|protected
operator|:
name|_Iterator
name|current
block|;
name|public
operator|:
typedef|typedef
name|_Iterator
name|iterator_type
typedef|;
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|difference_type
name|difference_type
expr_stmt|;
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|reference
name|reference
expr_stmt|;
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|pointer
name|pointer
expr_stmt|;
name|public
label|:
comment|/**        *  The default constructor default-initializes member @p current.        *  If it is a pointer, that means it is zero-initialized.       */
comment|// _GLIBCPP_RESOLVE_LIB_DEFECTS
comment|// 235 No specification of default ctor for reverse_iterator
name|reverse_iterator
argument_list|()
operator|:
name|current
argument_list|()
block|{ }
comment|/**        *  This %iterator will move in the opposite direction that @p x does.       */
name|explicit
name|reverse_iterator
argument_list|(
argument|iterator_type __x
argument_list|)
operator|:
name|current
argument_list|(
argument|__x
argument_list|)
block|{ }
comment|/**        *  The copy constructor is normal.       */
name|reverse_iterator
argument_list|(
specifier|const
name|reverse_iterator
operator|&
name|__x
argument_list|)
operator|:
name|current
argument_list|(
argument|__x.current
argument_list|)
block|{ }
comment|/**        *  A reverse_iterator across other types can be copied in the normal        *  fashion.       */
name|template
operator|<
name|typename
name|_Iter
operator|>
name|reverse_iterator
argument_list|(
specifier|const
name|reverse_iterator
operator|<
name|_Iter
operator|>
operator|&
name|__x
argument_list|)
operator|:
name|current
argument_list|(
argument|__x.base()
argument_list|)
block|{ }
comment|/**        *  @return  @c current, the %iterator used for underlying work.       */
name|iterator_type
name|base
argument_list|()
specifier|const
block|{
return|return
name|current
return|;
block|}
comment|/**        *  @return  TODO        *        *  @doctodo       */
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
name|_Iterator
name|__tmp
operator|=
name|current
block|;
return|return
operator|*
operator|--
name|__tmp
return|;
block|}
comment|/**        *  @return  TODO        *        *  @doctodo       */
name|pointer
name|operator
operator|->
expr|(
block|)
decl|const
block|{
return|return
operator|&
operator|(
name|operator
operator|*
operator|(
operator|)
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/**        *  @return  TODO        *        *  @doctodo       */
end_comment

begin_expr_stmt
name|reverse_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|--
name|current
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/**        *  @return  TODO        *        *  @doctodo       */
end_comment

begin_expr_stmt
name|reverse_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|reverse_iterator
name|__tmp
operator|=
operator|*
name|this
block|;
operator|--
name|current
block|;
return|return
name|__tmp
return|;
block|}
end_expr_stmt

begin_comment
comment|/**        *  @return  TODO        *        *  @doctodo       */
end_comment

begin_expr_stmt
name|reverse_iterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
operator|++
name|current
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/**        *  @return  TODO        *        *  @doctodo       */
end_comment

begin_expr_stmt
name|reverse_iterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|reverse_iterator
name|__tmp
operator|=
operator|*
name|this
block|;
operator|++
name|current
block|;
return|return
name|__tmp
return|;
block|}
end_expr_stmt

begin_comment
comment|/**        *  @return  TODO        *        *  @doctodo       */
end_comment

begin_expr_stmt
name|reverse_iterator
name|operator
operator|+
operator|(
name|difference_type
name|__n
operator|)
specifier|const
block|{
return|return
name|reverse_iterator
argument_list|(
name|current
operator|-
name|__n
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**        *  @return  TODO        *        *  @doctodo       */
end_comment

begin_expr_stmt
name|reverse_iterator
operator|&
name|operator
operator|+=
operator|(
name|difference_type
name|__n
operator|)
block|{
name|current
operator|-=
name|__n
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/**        *  @return  TODO        *        *  @doctodo       */
end_comment

begin_expr_stmt
name|reverse_iterator
name|operator
operator|-
operator|(
name|difference_type
name|__n
operator|)
specifier|const
block|{
return|return
name|reverse_iterator
argument_list|(
name|current
operator|+
name|__n
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**        *  @return  TODO        *        *  @doctodo       */
end_comment

begin_expr_stmt
name|reverse_iterator
operator|&
name|operator
operator|-=
operator|(
name|difference_type
name|__n
operator|)
block|{
name|current
operator|+=
name|__n
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/**        *  @return  TODO        *        *  @doctodo       */
end_comment

begin_decl_stmt
name|reference
name|operator
index|[]
argument_list|(
name|difference_type
name|__n
argument_list|)
decl|const
block|{
return|return
operator|*
operator|(
operator|*
name|this
operator|+
name|__n
operator|)
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|//@{
end_comment

begin_comment
comment|/**    *  @param  x  A %reverse_iterator.    *  @param  y  A %reverse_iterator.    *  @return  A simple bool.    *    *  Reverse iterators forward many operations to their underlying base()    *  iterators.  Others are implemented in terms of one another.    *   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__x
operator|,
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__y
operator|)
block|{
return|return
name|__x
operator|.
name|base
argument_list|()
operator|==
name|__y
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__x
operator|,
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__y
operator|)
block|{
return|return
name|__y
operator|.
name|base
argument_list|()
operator|<
name|__x
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__x
operator|,
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__y
operator|)
block|{
return|return
operator|!
operator|(
name|__x
operator|==
name|__y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|>
specifier|inline
name|bool
name|operator
operator|>
operator|(
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__x
operator|,
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__y
operator|)
block|{
return|return
name|__y
operator|<
name|__x
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|>
specifier|inline
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__x
operator|,
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__y
operator|)
block|{
return|return
operator|!
operator|(
name|__y
operator|<
name|__x
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|>
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__x
operator|,
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__y
operator|)
block|{
return|return
operator|!
operator|(
name|__x
operator|<
name|__y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|>
specifier|inline
name|typename
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|::
name|difference_type
name|operator
operator|-
operator|(
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__x
operator|,
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__y
operator|)
block|{
return|return
name|__y
operator|.
name|base
argument_list|()
operator|-
name|__x
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|>
specifier|inline
name|reverse_iterator
operator|<
name|_Iterator
operator|>
name|operator
operator|+
operator|(
name|typename
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|::
name|difference_type
name|__n
operator|,
specifier|const
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|&
name|__x
operator|)
block|{
return|return
name|reverse_iterator
operator|<
name|_Iterator
operator|>
operator|(
name|__x
operator|.
name|base
argument_list|()
operator|-
name|__n
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//@}
end_comment

begin_comment
comment|// 24.4.2.2.1 back_insert_iterator
end_comment

begin_comment
comment|/**    *  @brief  Turns assignment into insertion.    *    *  These are output iterators, constructed from a container-of-T.    *  Assigning a T to the iterator appends it to the container using    *  push_back.    *    *  Tip:  Using the back_inserter function to create these iterators can    *  save typing.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Container
operator|>
name|class
name|back_insert_iterator
operator|:
name|public
name|iterator
operator|<
name|output_iterator_tag
operator|,
name|void
operator|,
name|void
operator|,
name|void
operator|,
name|void
operator|>
block|{
name|protected
operator|:
name|_Container
operator|*
name|container
block|;
name|public
operator|:
comment|/// A nested typedef for the type of whatever container you used.
typedef|typedef
name|_Container
name|container_type
typedef|;
comment|/// The only way to create this %iterator is with a container.
name|explicit
name|back_insert_iterator
argument_list|(
name|_Container
operator|&
name|__x
argument_list|)
operator|:
name|container
argument_list|(
argument|&__x
argument_list|)
block|{ }
comment|/**        *  @param  value  An instance of whatever type        *                 container_type::const_reference is; presumably a        *                 reference-to-const T for container<T>.        *  @return  This %iterator, for chained operations.        *        *  This kind of %iterator doesn't really have a "position" in the        *  container (you can think of the position as being permanently at        *  the end, if you like).  Assigning a value to the %iterator will        *  always append the value to the end of the container.       */
name|back_insert_iterator
operator|&
name|operator
operator|=
operator|(
name|typename
name|_Container
operator|::
name|const_reference
name|__value
operator|)
block|{
name|container
operator|->
name|push_back
argument_list|(
name|__value
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Simply returns *this.
end_comment

begin_function
name|back_insert_iterator
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
return|return
operator|*
name|this
return|;
block|}
end_function

begin_comment
comment|/// Simply returns *this.  (This %iterator does not "move".)
end_comment

begin_expr_stmt
name|back_insert_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Simply returns *this.  (This %iterator does not "move".)
end_comment

begin_expr_stmt
name|back_insert_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/**    *  @param  x  A container of arbitrary type.    *  @return  An instance of back_insert_iterator working on @p x.    *    *  This wrapper function helps in creating back_insert_iterator instances.    *  Typing the name of the %iterator requires knowing the precise full    *  type of the container, which can be tedious and impedes generic    *  programming.  Using this function lets you take advantage of automatic    *  template parameter deduction, making the compiler match the correct    *  types for you.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Container
operator|>
specifier|inline
name|back_insert_iterator
operator|<
name|_Container
operator|>
name|back_inserter
argument_list|(
argument|_Container& __x
argument_list|)
block|{
return|return
name|back_insert_iterator
operator|<
name|_Container
operator|>
operator|(
name|__x
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief  Turns assignment into insertion.    *    *  These are output iterators, constructed from a container-of-T.    *  Assigning a T to the iterator prepends it to the container using    *  push_front.    *    *  Tip:  Using the front_inserter function to create these iterators can    *  save typing.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Container
operator|>
name|class
name|front_insert_iterator
operator|:
name|public
name|iterator
operator|<
name|output_iterator_tag
operator|,
name|void
operator|,
name|void
operator|,
name|void
operator|,
name|void
operator|>
block|{
name|protected
operator|:
name|_Container
operator|*
name|container
block|;
name|public
operator|:
comment|/// A nested typedef for the type of whatever container you used.
typedef|typedef
name|_Container
name|container_type
typedef|;
comment|/// The only way to create this %iterator is with a container.
name|explicit
name|front_insert_iterator
argument_list|(
name|_Container
operator|&
name|__x
argument_list|)
operator|:
name|container
argument_list|(
argument|&__x
argument_list|)
block|{ }
comment|/**        *  @param  value  An instance of whatever type        *                 container_type::const_reference is; presumably a        *                 reference-to-const T for container<T>.        *  @return  This %iterator, for chained operations.        *        *  This kind of %iterator doesn't really have a "position" in the        *  container (you can think of the position as being permanently at        *  the front, if you like).  Assigning a value to the %iterator will        *  always prepend the value to the front of the container.       */
name|front_insert_iterator
operator|&
name|operator
operator|=
operator|(
name|typename
name|_Container
operator|::
name|const_reference
name|__value
operator|)
block|{
name|container
operator|->
name|push_front
argument_list|(
name|__value
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Simply returns *this.
end_comment

begin_function
name|front_insert_iterator
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
return|return
operator|*
name|this
return|;
block|}
end_function

begin_comment
comment|/// Simply returns *this.  (This %iterator does not "move".)
end_comment

begin_expr_stmt
name|front_insert_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Simply returns *this.  (This %iterator does not "move".)
end_comment

begin_expr_stmt
name|front_insert_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/**    *  @param  x  A container of arbitrary type.    *  @return  An instance of front_insert_iterator working on @p x.    *    *  This wrapper function helps in creating front_insert_iterator instances.    *  Typing the name of the %iterator requires knowing the precise full    *  type of the container, which can be tedious and impedes generic    *  programming.  Using this function lets you take advantage of automatic    *  template parameter deduction, making the compiler match the correct    *  types for you.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Container
operator|>
specifier|inline
name|front_insert_iterator
operator|<
name|_Container
operator|>
name|front_inserter
argument_list|(
argument|_Container& __x
argument_list|)
block|{
return|return
name|front_insert_iterator
operator|<
name|_Container
operator|>
operator|(
name|__x
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief  Turns assignment into insertion.    *    *  These are output iterators, constructed from a container-of-T.    *  Assigning a T to the iterator inserts it in the container at the    *  %iterator's position, rather than overwriting the value at that    *  position.    *    *  (Sequences will actually insert a @e copy of the value before the    *  %iterator's position.)    *    *  Tip:  Using the inserter function to create these iterators can    *  save typing.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Container
operator|>
name|class
name|insert_iterator
operator|:
name|public
name|iterator
operator|<
name|output_iterator_tag
operator|,
name|void
operator|,
name|void
operator|,
name|void
operator|,
name|void
operator|>
block|{
name|protected
operator|:
name|_Container
operator|*
name|container
block|;
name|typename
name|_Container
operator|::
name|iterator
name|iter
block|;
name|public
operator|:
comment|/// A nested typedef for the type of whatever container you used.
typedef|typedef
name|_Container
name|container_type
typedef|;
comment|/**        *  The only way to create this %iterator is with a container and an        *  initial position (a normal %iterator into the container).       */
name|insert_iterator
argument_list|(
argument|_Container& __x
argument_list|,
argument|typename _Container::iterator __i
argument_list|)
operator|:
name|container
argument_list|(
operator|&
name|__x
argument_list|)
operator|,
name|iter
argument_list|(
argument|__i
argument_list|)
block|{}
comment|/**        *  @param  value  An instance of whatever type        *                 container_type::const_reference is; presumably a        *                 reference-to-const T for container<T>.        *  @return  This %iterator, for chained operations.        *        *  This kind of %iterator maintains its own position in the        *  container.  Assigning a value to the %iterator will insert the        *  value into the container at the place before the %iterator.        *        *  The position is maintained such that subsequent assignments will        *  insert values immediately after one another.  For example,        *  @code        *     // vector v contains A and Z        *        *     insert_iterator i (v, ++v.begin());        *     i = 1;        *     i = 2;        *     i = 3;        *        *     // vector v contains A, 1, 2, 3, and Z        *  @endcode       */
name|insert_iterator
operator|&
name|operator
operator|=
operator|(
specifier|const
name|typename
name|_Container
operator|::
name|const_reference
name|__value
operator|)
block|{
name|iter
operator|=
name|container
operator|->
name|insert
argument_list|(
name|iter
argument_list|,
name|__value
argument_list|)
block|;
operator|++
name|iter
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Simply returns *this.
end_comment

begin_function
name|insert_iterator
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
return|return
operator|*
name|this
return|;
block|}
end_function

begin_comment
comment|/// Simply returns *this.  (This %iterator does not "move".)
end_comment

begin_expr_stmt
name|insert_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Simply returns *this.  (This %iterator does not "move".)
end_comment

begin_expr_stmt
name|insert_iterator
operator|&
name|operator
operator|++
operator|(
name|int
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/**    *  @param  x  A container of arbitrary type.    *  @return  An instance of insert_iterator working on @p x.    *    *  This wrapper function helps in creating insert_iterator instances.    *  Typing the name of the %iterator requires knowing the precise full    *  type of the container, which can be tedious and impedes generic    *  programming.  Using this function lets you take advantage of automatic    *  template parameter deduction, making the compiler match the correct    *  types for you.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Container
operator|,
name|typename
name|_Iterator
operator|>
specifier|inline
name|insert_iterator
operator|<
name|_Container
operator|>
name|inserter
argument_list|(
argument|_Container& __x
argument_list|,
argument|_Iterator __i
argument_list|)
block|{
return|return
name|insert_iterator
operator|<
name|_Container
operator|>
operator|(
name|__x
operator|,
name|typename
name|_Container
operator|::
name|iterator
argument_list|(
name|__i
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace std
end_comment

begin_macro
unit|namespace
name|__gnu_cxx
end_macro

begin_block
block|{
comment|// This iterator adapter is 'normal' in the sense that it does not
comment|// change the semantics of any of the operators of its iterator
comment|// parameter.  Its primary purpose is to convert an iterator that is
comment|// not a class, e.g. a pointer, into an iterator that is a class.
comment|// The _Container parameter exists solely so that different containers
comment|// using this template can instantiate different types, even if the
comment|// _Iterator parameter is the same.
name|using
name|std
operator|::
name|iterator_traits
expr_stmt|;
name|using
name|std
operator|::
name|iterator
expr_stmt|;
name|template
operator|<
name|typename
name|_Iterator
operator|,
name|typename
name|_Container
operator|>
name|class
name|__normal_iterator
operator|:
name|public
name|iterator
operator|<
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|iterator_category
operator|,
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|value_type
operator|,
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|difference_type
operator|,
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|pointer
operator|,
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|reference
operator|>
block|{
name|protected
operator|:
name|_Iterator
name|_M_current
block|;
name|public
operator|:
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|difference_type
name|difference_type
expr_stmt|;
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|reference
name|reference
expr_stmt|;
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_Iterator
operator|>
operator|::
name|pointer
name|pointer
expr_stmt|;
name|__normal_iterator
argument_list|()
operator|:
name|_M_current
argument_list|(
argument|_Iterator()
argument_list|)
block|{ }
name|explicit
name|__normal_iterator
argument_list|(
specifier|const
name|_Iterator
operator|&
name|__i
argument_list|)
operator|:
name|_M_current
argument_list|(
argument|__i
argument_list|)
block|{ }
comment|// Allow iterator to const_iterator conversion
name|template
operator|<
name|typename
name|_Iter
operator|>
specifier|inline
name|__normal_iterator
argument_list|(
specifier|const
name|__normal_iterator
operator|<
name|_Iter
argument_list|,
name|_Container
operator|>
operator|&
name|__i
argument_list|)
operator|:
name|_M_current
argument_list|(
argument|__i.base()
argument_list|)
block|{ }
comment|// Forward iterator requirements
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
operator|*
name|_M_current
return|;
block|}
name|pointer
name|operator
operator|->
expr|(
block|)
end_block

begin_expr_stmt
specifier|const
block|{
return|return
name|_M_current
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__normal_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|_M_current
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__normal_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
return|return
name|__normal_iterator
argument_list|(
name|_M_current
operator|++
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Bidirectional iterator requirements
end_comment

begin_expr_stmt
name|__normal_iterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
operator|--
name|_M_current
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__normal_iterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
return|return
name|__normal_iterator
argument_list|(
name|_M_current
operator|--
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Random access iterator requirements
end_comment

begin_decl_stmt
name|reference
name|operator
index|[]
argument_list|(
specifier|const
name|difference_type
operator|&
name|__n
argument_list|)
decl|const
block|{
return|return
name|_M_current
index|[
name|__n
index|]
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|__normal_iterator
operator|&
name|operator
operator|+=
operator|(
specifier|const
name|difference_type
operator|&
name|__n
operator|)
block|{
name|_M_current
operator|+=
name|__n
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__normal_iterator
name|operator
operator|+
operator|(
specifier|const
name|difference_type
operator|&
name|__n
operator|)
specifier|const
block|{
return|return
name|__normal_iterator
argument_list|(
name|_M_current
operator|+
name|__n
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__normal_iterator
operator|&
name|operator
operator|-=
operator|(
specifier|const
name|difference_type
operator|&
name|__n
operator|)
block|{
name|_M_current
operator|-=
name|__n
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__normal_iterator
name|operator
operator|-
operator|(
specifier|const
name|difference_type
operator|&
name|__n
operator|)
specifier|const
block|{
return|return
name|__normal_iterator
argument_list|(
name|_M_current
operator|-
name|__n
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|_Iterator
operator|&
name|base
argument_list|()
specifier|const
block|{
return|return
name|_M_current
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Note: In what follows, the left- and right-hand-side iterators are
end_comment

begin_comment
comment|// allowed to vary in types (conceptually in cv-qualification) so that
end_comment

begin_comment
comment|// comparaison between cv-qualified and non-cv-qualified iterators be
end_comment

begin_comment
comment|// valid.  However, the greedy and unfriendly operators in std::rel_ops
end_comment

begin_comment
comment|// will make overload resolution ambiguous (when in scope) if we don't
end_comment

begin_comment
comment|// provide overloads whose operands are of the same type.  Can someone
end_comment

begin_comment
comment|// remind me what generic programming is about? -- Gaby
end_comment

begin_comment
comment|// Forward iterator requirements
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_IteratorL
operator|,
name|typename
name|_IteratorR
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_IteratorL
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_IteratorR
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|==
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|==
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_IteratorL
operator|,
name|typename
name|_IteratorR
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_IteratorL
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_IteratorR
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|!=
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|!=
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Random access iterator requirements
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_IteratorL
operator|,
name|typename
name|_IteratorR
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_IteratorL
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_IteratorR
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|<
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|<
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_IteratorL
operator|,
name|typename
name|_IteratorR
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|>
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_IteratorL
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_IteratorR
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|>
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|>
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|>
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_IteratorL
operator|,
name|typename
name|_IteratorR
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_IteratorL
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_IteratorR
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|<=
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|<=
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_IteratorL
operator|,
name|typename
name|_IteratorR
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_IteratorL
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_IteratorR
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|>=
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|>=
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// _GLIBCPP_RESOLVE_LIB_DEFECTS
end_comment

begin_comment
comment|// According to the resolution of DR179 not only the various comparison
end_comment

begin_comment
comment|// operators but also operator- must accept mixed iterator/const_iterator
end_comment

begin_comment
comment|// parameters.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_IteratorL
operator|,
name|typename
name|_IteratorR
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|typename
name|__normal_iterator
operator|<
name|_IteratorL
operator|,
name|_Container
operator|>
operator|::
name|difference_type
name|operator
operator|-
operator|(
specifier|const
name|__normal_iterator
operator|<
name|_IteratorL
operator|,
name|_Container
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_IteratorR
operator|,
name|_Container
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|base
argument_list|()
operator|-
name|__rhs
operator|.
name|base
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Iterator
operator|,
name|typename
name|_Container
operator|>
specifier|inline
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
name|operator
operator|+
operator|(
name|typename
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|::
name|difference_type
name|__n
operator|,
specifier|const
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|&
name|__i
operator|)
block|{
return|return
name|__normal_iterator
operator|<
name|_Iterator
operator|,
name|_Container
operator|>
operator|(
name|__i
operator|.
name|base
argument_list|()
operator|+
name|__n
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace __gnu_cxx
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// Local Variables:
end_comment

begin_comment
comment|// mode:C++
end_comment

begin_comment
comment|// End:
end_comment

end_unit

