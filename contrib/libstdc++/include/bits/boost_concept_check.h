begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// Copyright (C) 2004 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|// (C) Copyright Jeremy Siek 2000. Permission to copy, use, modify,
end_comment

begin_comment
comment|// sell and distribute this software is granted provided this
end_comment

begin_comment
comment|// copyright notice appears in all copies. This software is provided
end_comment

begin_comment
comment|// "as is" without express or implied warranty, and with no claim as
end_comment

begin_comment
comment|// to its suitability for any purpose.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// GCC Note:  based on version 1.12.0 of the Boost library.
end_comment

begin_comment
comment|/** @file boost_concept_check.h  *  This is an internal header file, included by other library headers.  *  You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_BOOST_CONCEPT_CHECK_H
end_ifndef

begin_define
define|#
directive|define
name|_BOOST_CONCEPT_CHECK_H
value|1
end_define

begin_pragma
pragma|#
directive|pragma
name|GCC
name|system_header
end_pragma

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_comment
comment|// for ptrdiff_t, used next
end_comment

begin_include
include|#
directive|include
file|<bits/stl_iterator_base_types.h>
end_include

begin_comment
comment|// for traits and tags
end_comment

begin_include
include|#
directive|include
file|<utility>
end_include

begin_comment
comment|// for pair<>
end_comment

begin_decl_stmt
name|namespace
name|__gnu_cxx
block|{
define|#
directive|define
name|_IsUnused
value|__attribute__ ((__unused__))
comment|// When the C-C code is in use, we would like this function to do as little
comment|// as possible at runtime, use as few resources as possible, and hopefully
comment|// be elided out of existence... hmmm.
name|template
operator|<
name|class
name|_Concept
operator|>
specifier|inline
name|void
name|__function_requires
argument_list|()
block|{
name|void
argument_list|(
argument|_Concept::*__x
argument_list|)
operator|(
operator|)
name|_IsUnused
operator|=
operator|&
name|_Concept
operator|::
name|__constraints
block|; }
comment|// No definition: if this is referenced, there's a problem with
comment|// the instantiating type not being one of the required integer types.
comment|// Unfortunately, this results in a link-time error, not a compile-time error.
name|void
name|__error_type_must_be_an_integer_type
argument_list|()
expr_stmt|;
name|void
name|__error_type_must_be_an_unsigned_integer_type
parameter_list|()
function_decl|;
name|void
name|__error_type_must_be_a_signed_integer_type
parameter_list|()
function_decl|;
comment|// ??? Should the "concept_checking*" structs begin with more than _ ?
define|#
directive|define
name|_GLIBCXX_CLASS_REQUIRES
parameter_list|(
name|_type_var
parameter_list|,
name|_ns
parameter_list|,
name|_concept
parameter_list|)
define|\
value|typedef void (_ns::_concept<_type_var>::* _func##_type_var##_concept)(); \   template<_func##_type_var##_concept _Tp1> \   struct _concept_checking##_type_var##_concept { }; \   typedef _concept_checking##_type_var##_concept< \&_ns::_concept<_type_var>::__constraints> \     _concept_checking_typedef##_type_var##_concept
define|#
directive|define
name|_GLIBCXX_CLASS_REQUIRES2
parameter_list|(
name|_type_var1
parameter_list|,
name|_type_var2
parameter_list|,
name|_ns
parameter_list|,
name|_concept
parameter_list|)
define|\
value|typedef void (_ns::_concept<_type_var1,_type_var2>::* _func##_type_var1##_type_var2##_concept)(); \   template<_func##_type_var1##_type_var2##_concept _Tp1> \   struct _concept_checking##_type_var1##_type_var2##_concept { }; \   typedef _concept_checking##_type_var1##_type_var2##_concept< \&_ns::_concept<_type_var1,_type_var2>::__constraints> \     _concept_checking_typedef##_type_var1##_type_var2##_concept
define|#
directive|define
name|_GLIBCXX_CLASS_REQUIRES3
parameter_list|(
name|_type_var1
parameter_list|,
name|_type_var2
parameter_list|,
name|_type_var3
parameter_list|,
name|_ns
parameter_list|,
name|_concept
parameter_list|)
define|\
value|typedef void (_ns::_concept<_type_var1,_type_var2,_type_var3>::* _func##_type_var1##_type_var2##_type_var3##_concept)(); \   template<_func##_type_var1##_type_var2##_type_var3##_concept _Tp1> \   struct _concept_checking##_type_var1##_type_var2##_type_var3##_concept { }; \   typedef _concept_checking##_type_var1##_type_var2##_type_var3##_concept< \&_ns::_concept<_type_var1,_type_var2,_type_var3>::__constraints>  \   _concept_checking_typedef##_type_var1##_type_var2##_type_var3##_concept
define|#
directive|define
name|_GLIBCXX_CLASS_REQUIRES4
parameter_list|(
name|_type_var1
parameter_list|,
name|_type_var2
parameter_list|,
name|_type_var3
parameter_list|,
name|_type_var4
parameter_list|,
name|_ns
parameter_list|,
name|_concept
parameter_list|)
define|\
value|typedef void (_ns::_concept<_type_var1,_type_var2,_type_var3,_type_var4>::* _func##_type_var1##_type_var2##_type_var3##_type_var4##_concept)(); \   template<_func##_type_var1##_type_var2##_type_var3##_type_var4##_concept _Tp1> \   struct _concept_checking##_type_var1##_type_var2##_type_var3##_type_var4##_concept { }; \   typedef _concept_checking##_type_var1##_type_var2##_type_var3##_type_var4##_concept< \&_ns::_concept<_type_var1,_type_var2,_type_var3,_type_var4>::__constraints> \     _concept_checking_typedef##_type_var1##_type_var2##_type_var3##_type_var4##_concept
name|template
operator|<
name|class
name|_Tp1
operator|,
name|class
name|_Tp2
operator|>
expr|struct
name|_Aux_require_same
block|{ }
expr_stmt|;
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_Aux_require_same
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
block|{
typedef|typedef
name|_Tp
name|_Type
typedef|;
block|}
empty_stmt|;
name|template
operator|<
name|class
name|_Tp1
operator|,
name|class
name|_Tp2
operator|>
expr|struct
name|_SameTypeConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
typedef|typedef
name|typename
name|_Aux_require_same
operator|<
name|_Tp1
operator|,
name|_Tp2
operator|>
operator|::
name|_Type
name|_Required
expr_stmt|;
block|}
expr|}
block|;
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_IntegerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__error_type_must_be_an_integer_type
argument_list|()
block|;     }
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_IntegerConcept
operator|<
name|short
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_IntegerConcept
operator|<
name|unsigned
name|short
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_IntegerConcept
operator|<
name|int
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_IntegerConcept
operator|<
name|unsigned
name|int
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_IntegerConcept
operator|<
name|long
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_IntegerConcept
operator|<
name|unsigned
name|long
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_IntegerConcept
operator|<
name|long
name|long
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_IntegerConcept
operator|<
name|unsigned
name|long
name|long
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_SignedIntegerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__error_type_must_be_a_signed_integer_type
argument_list|()
block|;     }
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_SignedIntegerConcept
operator|<
name|short
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_SignedIntegerConcept
operator|<
name|int
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_SignedIntegerConcept
operator|<
name|long
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_SignedIntegerConcept
operator|<
name|long
name|long
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_UnsignedIntegerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__error_type_must_be_an_unsigned_integer_type
argument_list|()
block|;     }
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_UnsignedIntegerConcept
operator|<
name|unsigned
name|short
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_UnsignedIntegerConcept
operator|<
name|unsigned
name|int
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_UnsignedIntegerConcept
operator|<
name|unsigned
name|long
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
name|template
operator|<
operator|>
expr|struct
name|_UnsignedIntegerConcept
operator|<
name|unsigned
name|long
name|long
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{}
block|}
block|;
comment|//===========================================================================
comment|// Basic Concepts
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_DefaultConstructibleConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|_Tp
name|__a
name|_IsUnused
block|;
comment|// require default constructor
block|}
block|}
block|;
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_AssignableConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__a
operator|=
name|__a
block|;
comment|// require assignment operator
name|__const_constraints
argument_list|(
name|__a
argument_list|)
block|;     }
name|void
name|__const_constraints
argument_list|(
argument|const _Tp& __b
argument_list|)
block|{
name|__a
operator|=
name|__b
block|;
comment|// const required for argument to assignment
block|}
name|_Tp
name|__a
block|;
comment|// possibly should be "Tp* a;" and then dereference "a" in constraint
comment|// functions?  present way would require a default ctor, i think...
block|}
block|;
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_CopyConstructibleConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|_Tp
name|__a
argument_list|(
name|__b
argument_list|)
block|;
comment|// require copy constructor
name|_Tp
operator|*
name|__ptr
name|_IsUnused
operator|=
operator|&
name|__a
block|;
comment|// require address of operator
name|__const_constraints
argument_list|(
name|__a
argument_list|)
block|;     }
name|void
name|__const_constraints
argument_list|(
argument|const _Tp& __a
argument_list|)
block|{
name|_Tp
name|__c
name|_IsUnused
argument_list|(
name|__a
argument_list|)
block|;
comment|// require const copy constructor
specifier|const
name|_Tp
operator|*
name|__ptr
name|_IsUnused
operator|=
operator|&
name|__a
block|;
comment|// require const address of operator
block|}
name|_Tp
name|__b
block|;   }
block|;
comment|// The SGI STL version of Assignable requires copy constructor and operator=
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_SGIAssignableConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|_Tp
name|__b
name|_IsUnused
argument_list|(
name|__a
argument_list|)
block|;
name|__a
operator|=
name|__a
block|;
comment|// require assignment operator
name|__const_constraints
argument_list|(
name|__a
argument_list|)
block|;     }
name|void
name|__const_constraints
argument_list|(
argument|const _Tp& __b
argument_list|)
block|{
name|_Tp
name|__c
name|_IsUnused
argument_list|(
name|__b
argument_list|)
block|;
name|__a
operator|=
name|__b
block|;
comment|// const required for argument to assignment
block|}
name|_Tp
name|__a
block|;   }
block|;
name|template
operator|<
name|class
name|_From
block|,
name|class
name|_To
operator|>
expr|struct
name|_ConvertibleConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|_To
name|__y
name|_IsUnused
operator|=
name|__x
block|;     }
name|_From
name|__x
block|;   }
block|;
comment|// The C++ standard requirements for many concepts talk about return
comment|// types that must be "convertible to bool".  The problem with this
comment|// requirement is that it leaves the door open for evil proxies that
comment|// define things like operator|| with strange return types.  Two
comment|// possible solutions are:
comment|// 1) require the return type to be exactly bool
comment|// 2) stay with convertible to bool, and also
comment|//    specify stuff about all the logical operators.
comment|// For now we just test for convertible to bool.
name|template
operator|<
name|class
name|_Tp
operator|>
name|void
name|__aux_require_boolean_expr
argument_list|(
argument|const _Tp& __t
argument_list|)
block|{
name|bool
name|__x
name|_IsUnused
operator|=
name|__t
block|;   }
comment|// FIXME
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_EqualityComparableConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__aux_require_boolean_expr
argument_list|(
name|__a
operator|==
name|__b
argument_list|)
block|;     }
name|_Tp
name|__a
block|,
name|__b
block|;   }
block|;
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_LessThanComparableConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__aux_require_boolean_expr
argument_list|(
name|__a
operator|<
name|__b
argument_list|)
block|;     }
name|_Tp
name|__a
block|,
name|__b
block|;   }
block|;
comment|// This is equivalent to SGI STL's LessThanComparable.
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_ComparableConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__aux_require_boolean_expr
argument_list|(
name|__a
operator|<
name|__b
argument_list|)
block|;
name|__aux_require_boolean_expr
argument_list|(
name|__a
operator|>
name|__b
argument_list|)
block|;
name|__aux_require_boolean_expr
argument_list|(
name|__a
operator|<=
name|__b
argument_list|)
block|;
name|__aux_require_boolean_expr
argument_list|(
name|__a
operator|>=
name|__b
argument_list|)
block|;     }
name|_Tp
name|__a
block|,
name|__b
block|;   }
block|;
define|#
directive|define
name|_GLIBCXX_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT
parameter_list|(
name|_OP
parameter_list|,
name|_NAME
parameter_list|)
define|\
value|template<class _First, class _Second> \   struct _NAME { \     void __constraints() { (void)__constraints_(); } \     bool __constraints_() {  \       return  __a _OP __b; \     } \     _First __a; \     _Second __b; \   }
define|#
directive|define
name|_GLIBCXX_DEFINE_BINARY_OPERATOR_CONSTRAINT
parameter_list|(
name|_OP
parameter_list|,
name|_NAME
parameter_list|)
define|\
value|template<class _Ret, class _First, class _Second> \   struct _NAME { \     void __constraints() { (void)__constraints_(); } \     _Ret __constraints_() {  \       return __a _OP __b; \     } \     _First __a; \     _Second __b; \   }
name|_GLIBCXX_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT
argument_list|(
operator|==
argument_list|,
name|_EqualOpConcept
argument_list|)
block|;
name|_GLIBCXX_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT
argument_list|(
operator|!=
argument_list|,
name|_NotEqualOpConcept
argument_list|)
block|;
name|_GLIBCXX_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT
argument_list|(
operator|<
argument_list|,
name|_LessThanOpConcept
argument_list|)
block|;
name|_GLIBCXX_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT
argument_list|(
operator|<=
argument_list|,
name|_LessEqualOpConcept
argument_list|)
block|;
name|_GLIBCXX_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT
argument_list|(
operator|>
argument_list|,
name|_GreaterThanOpConcept
argument_list|)
block|;
name|_GLIBCXX_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT
argument_list|(
operator|>=
argument_list|,
name|_GreaterEqualOpConcept
argument_list|)
block|;
name|_GLIBCXX_DEFINE_BINARY_OPERATOR_CONSTRAINT
argument_list|(
operator|+
argument_list|,
name|_PlusOpConcept
argument_list|)
block|;
name|_GLIBCXX_DEFINE_BINARY_OPERATOR_CONSTRAINT
argument_list|(
operator|*
argument_list|,
name|_TimesOpConcept
argument_list|)
block|;
name|_GLIBCXX_DEFINE_BINARY_OPERATOR_CONSTRAINT
argument_list|(
operator|/
argument_list|,
name|_DivideOpConcept
argument_list|)
block|;
name|_GLIBCXX_DEFINE_BINARY_OPERATOR_CONSTRAINT
argument_list|(
operator|-
argument_list|,
name|_SubtractOpConcept
argument_list|)
block|;
name|_GLIBCXX_DEFINE_BINARY_OPERATOR_CONSTRAINT
argument_list|(
operator|%
argument_list|,
name|_ModOpConcept
argument_list|)
block|;
undef|#
directive|undef
name|_GLIBCXX_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT
undef|#
directive|undef
name|_GLIBCXX_DEFINE_BINARY_OPERATOR_CONSTRAINT
comment|//===========================================================================
comment|// Function Object Concepts
name|template
operator|<
name|class
name|_Func
block|,
name|class
name|_Return
operator|>
expr|struct
name|_GeneratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
specifier|const
name|_Return
operator|&
name|__r
name|_IsUnused
operator|=
name|__f
argument_list|()
block|;
comment|// require operator() member function
block|}
name|_Func
name|__f
block|;   }
block|;
name|template
operator|<
name|class
name|_Func
operator|>
expr|struct
name|_GeneratorConcept
operator|<
name|_Func
block|,
name|void
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__f
argument_list|()
block|;
comment|// require operator() member function
block|}
name|_Func
name|__f
block|;   }
block|;
name|template
operator|<
name|class
name|_Func
block|,
name|class
name|_Return
block|,
name|class
name|_Arg
operator|>
expr|struct
name|_UnaryFunctionConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__r
operator|=
name|__f
argument_list|(
name|__arg
argument_list|)
block|;
comment|// require operator()
block|}
name|_Func
name|__f
block|;
name|_Arg
name|__arg
block|;
name|_Return
name|__r
block|;   }
block|;
name|template
operator|<
name|class
name|_Func
block|,
name|class
name|_Arg
operator|>
expr|struct
name|_UnaryFunctionConcept
operator|<
name|_Func
block|,
name|void
block|,
name|_Arg
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__f
argument_list|(
name|__arg
argument_list|)
block|;
comment|// require operator()
block|}
name|_Func
name|__f
block|;
name|_Arg
name|__arg
block|;   }
block|;
name|template
operator|<
name|class
name|_Func
block|,
name|class
name|_Return
block|,
name|class
name|_First
block|,
name|class
name|_Second
operator|>
expr|struct
name|_BinaryFunctionConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__r
operator|=
name|__f
argument_list|(
name|__first
argument_list|,
name|__second
argument_list|)
block|;
comment|// require operator()
block|}
name|_Func
name|__f
block|;
name|_First
name|__first
block|;
name|_Second
name|__second
block|;
name|_Return
name|__r
block|;   }
block|;
name|template
operator|<
name|class
name|_Func
block|,
name|class
name|_First
block|,
name|class
name|_Second
operator|>
expr|struct
name|_BinaryFunctionConcept
operator|<
name|_Func
block|,
name|void
block|,
name|_First
block|,
name|_Second
operator|>
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__f
argument_list|(
name|__first
argument_list|,
name|__second
argument_list|)
block|;
comment|// require operator()
block|}
name|_Func
name|__f
block|;
name|_First
name|__first
block|;
name|_Second
name|__second
block|;   }
block|;
name|template
operator|<
name|class
name|_Func
block|,
name|class
name|_Arg
operator|>
expr|struct
name|_UnaryPredicateConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__aux_require_boolean_expr
argument_list|(
name|__f
argument_list|(
name|__arg
argument_list|)
argument_list|)
block|;
comment|// require op() returning bool
block|}
name|_Func
name|__f
block|;
name|_Arg
name|__arg
block|;   }
block|;
name|template
operator|<
name|class
name|_Func
block|,
name|class
name|_First
block|,
name|class
name|_Second
operator|>
expr|struct
name|_BinaryPredicateConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__aux_require_boolean_expr
argument_list|(
name|__f
argument_list|(
name|__a
argument_list|,
name|__b
argument_list|)
argument_list|)
block|;
comment|// require op() returning bool
block|}
name|_Func
name|__f
block|;
name|_First
name|__a
block|;
name|_Second
name|__b
block|;   }
block|;
comment|// use this when functor is used inside a container class like std::set
name|template
operator|<
name|class
name|_Func
block|,
name|class
name|_First
block|,
name|class
name|_Second
operator|>
expr|struct
name|_Const_BinaryPredicateConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__const_constraints
argument_list|(
name|__f
argument_list|)
block|;     }
name|void
name|__const_constraints
argument_list|(
argument|const _Func& __fun
argument_list|)
block|{
name|__function_requires
operator|<
name|_BinaryPredicateConcept
operator|<
name|_Func
block|,
name|_First
block|,
name|_Second
operator|>
expr|>
operator|(
operator|)
block|;
comment|// operator() must be a const member function
name|__aux_require_boolean_expr
argument_list|(
name|__fun
argument_list|(
name|__a
argument_list|,
name|__b
argument_list|)
argument_list|)
block|;     }
name|_Func
name|__f
block|;
name|_First
name|__a
block|;
name|_Second
name|__b
block|;   }
block|;
comment|//===========================================================================
comment|// Iterator Concepts
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_TrivialIteratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
comment|//    __function_requires< _DefaultConstructibleConcept<_Tp>>();
name|__function_requires
operator|<
name|_AssignableConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_EqualityComparableConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
comment|//      typedef typename std::iterator_traits<_Tp>::value_type _V;
operator|(
name|void
operator|)
operator|*
name|__i
block|;
comment|// require dereference operator
block|}
name|_Tp
name|__i
block|;   }
block|;
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_Mutable_TrivialIteratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_TrivialIteratorConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
operator|*
name|__i
operator|=
operator|*
name|__j
block|;
comment|// require dereference and assignment
block|}
name|_Tp
name|__i
block|,
name|__j
block|;   }
block|;
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_InputIteratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_TrivialIteratorConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
comment|// require iterator_traits typedef's
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|difference_type
name|_Diff
expr_stmt|;
comment|//      __function_requires< _SignedIntegerConcept<_Diff>>();
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|reference
name|_Ref
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|pointer
name|_Pt
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|iterator_category
name|_Cat
expr_stmt|;
name|__function_requires
operator|<
name|_ConvertibleConcept
operator|<
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|iterator_category
operator|,
name|std
operator|::
name|input_iterator_tag
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
operator|++
name|__i
expr_stmt|;
comment|// require preincrement operator
name|__i
operator|++
expr_stmt|;
comment|// require postincrement operator
block|}
end_decl_stmt

begin_decl_stmt
name|_Tp
name|__i
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_ValueT
operator|>
expr|struct
name|_OutputIteratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_AssignableConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
operator|++
name|__i
block|;
comment|// require preincrement operator
name|__i
operator|++
block|;
comment|// require postincrement operator
operator|*
name|__i
operator|++
operator|=
name|__t
block|;
comment|// require postincrement and assignment
block|}
name|_Tp
name|__i
block|;
name|_ValueT
name|__t
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_ForwardIteratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_InputIteratorConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_DefaultConstructibleConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_ConvertibleConcept
operator|<
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|iterator_category
block|,
name|std
operator|::
name|forward_iterator_tag
operator|>
expr|>
operator|(
operator|)
block|;
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|reference
name|_Ref
expr_stmt|;
name|_Ref
name|__r
name|_IsUnused
operator|=
operator|*
name|__i
block|;     }
name|_Tp
name|__i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_Mutable_ForwardIteratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_ForwardIteratorConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
operator|*
name|__i
operator|++
operator|=
operator|*
name|__i
block|;
comment|// require postincrement and assignment
block|}
name|_Tp
name|__i
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_BidirectionalIteratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_ForwardIteratorConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_ConvertibleConcept
operator|<
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|iterator_category
block|,
name|std
operator|::
name|bidirectional_iterator_tag
operator|>
expr|>
operator|(
operator|)
block|;
operator|--
name|__i
block|;
comment|// require predecrement operator
name|__i
operator|--
block|;
comment|// require postdecrement operator
block|}
name|_Tp
name|__i
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_Mutable_BidirectionalIteratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_BidirectionalIteratorConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_Mutable_ForwardIteratorConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
operator|*
name|__i
operator|--
operator|=
operator|*
name|__i
block|;
comment|// require postdecrement and assignment
block|}
name|_Tp
name|__i
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_RandomAccessIteratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_BidirectionalIteratorConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_ComparableConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_ConvertibleConcept
operator|<
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|iterator_category
block|,
name|std
operator|::
name|random_access_iterator_tag
operator|>
expr|>
operator|(
operator|)
block|;
comment|// ??? We don't use _Ref, are we just checking for "referenceability"?
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|reference
name|_Ref
expr_stmt|;
name|__i
operator|+=
name|__n
block|;
comment|// require assignment addition operator
name|__i
operator|=
name|__i
operator|+
name|__n
block|;
name|__i
operator|=
name|__n
operator|+
name|__i
block|;
comment|// require addition with difference type
name|__i
operator|-=
name|__n
block|;
comment|// require assignment subtraction op
name|__i
operator|=
name|__i
operator|-
name|__n
block|;
comment|// require subtraction with
comment|//            difference type
name|__n
operator|=
name|__i
operator|-
name|__j
block|;
comment|// require difference operator
operator|(
name|void
operator|)
name|__i
index|[
name|__n
index|]
block|;
comment|// require element access operator
block|}
name|_Tp
name|__a
operator|,
name|__b
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_Tp
name|__i
decl_stmt|,
name|__j
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|difference_type
name|__n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_Mutable_RandomAccessIteratorConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_RandomAccessIteratorConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_Mutable_BidirectionalIteratorConcept
operator|<
name|_Tp
operator|>
expr|>
operator|(
operator|)
block|;
name|__i
index|[
name|__n
index|]
operator|=
operator|*
name|__i
block|;
comment|// require element access and assignment
block|}
name|_Tp
name|__i
block|;
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_Tp
operator|>
operator|::
name|difference_type
name|__n
block|;   }
expr_stmt|;
end_expr_stmt

begin_comment
comment|//===========================================================================
end_comment

begin_comment
comment|// Container Concepts
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Container
operator|>
expr|struct
name|_ContainerConcept
block|{
typedef|typedef
name|typename
name|_Container
operator|::
name|value_type
name|_Value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Container
operator|::
name|difference_type
name|_Difference_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_Container
operator|::
name|size_type
name|_Size_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_Container
operator|::
name|const_reference
name|_Const_reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_Container
operator|::
name|const_pointer
name|_Const_pointer
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_Container
operator|::
name|const_iterator
name|_Const_iterator
expr_stmt|;
end_typedef

begin_function
name|void
name|__constraints
parameter_list|()
block|{
name|__function_requires
operator|<
name|_InputIteratorConcept
operator|<
name|_Const_iterator
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_AssignableConcept
operator|<
name|_Container
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
specifier|const
name|_Container
name|__c
decl_stmt|;
name|__i
operator|=
name|__c
operator|.
name|begin
argument_list|()
expr_stmt|;
name|__i
operator|=
name|__c
operator|.
name|end
argument_list|()
expr_stmt|;
name|__n
operator|=
name|__c
operator|.
name|size
argument_list|()
expr_stmt|;
name|__n
operator|=
name|__c
operator|.
name|max_size
argument_list|()
expr_stmt|;
name|__b
operator|=
name|__c
operator|.
name|empty
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|bool
name|__b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Const_iterator
name|__i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Size_type
name|__n
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Container
operator|>
expr|struct
name|_Mutable_ContainerConcept
block|{
typedef|typedef
name|typename
name|_Container
operator|::
name|value_type
name|_Value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Container
operator|::
name|reference
name|_Reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_Container
operator|::
name|iterator
name|_Iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_Container
operator|::
name|pointer
name|_Pointer
expr_stmt|;
end_typedef

begin_function
name|void
name|__constraints
parameter_list|()
block|{
name|__function_requires
operator|<
name|_ContainerConcept
operator|<
name|_Container
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_AssignableConcept
operator|<
name|_Value_type
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_InputIteratorConcept
operator|<
name|_Iterator
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__i
operator|=
name|__c
operator|.
name|begin
argument_list|()
expr_stmt|;
name|__i
operator|=
name|__c
operator|.
name|end
argument_list|()
expr_stmt|;
name|__c
operator|.
name|swap
argument_list|(
name|__c2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|_Iterator
name|__i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Container
name|__c
decl_stmt|,
name|__c2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_ForwardContainer
operator|>
expr|struct
name|_ForwardContainerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_ContainerConcept
operator|<
name|_ForwardContainer
operator|>
expr|>
operator|(
operator|)
block|;
typedef|typedef
name|typename
name|_ForwardContainer
operator|::
name|const_iterator
name|_Const_iterator
expr_stmt|;
name|__function_requires
operator|<
name|_ForwardIteratorConcept
operator|<
name|_Const_iterator
operator|>
block|>
operator|(
operator|)
block|;     }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_ForwardContainer
operator|>
expr|struct
name|_Mutable_ForwardContainerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_ForwardContainerConcept
operator|<
name|_ForwardContainer
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_Mutable_ContainerConcept
operator|<
name|_ForwardContainer
operator|>
expr|>
operator|(
operator|)
block|;
typedef|typedef
name|typename
name|_ForwardContainer
operator|::
name|iterator
name|_Iterator
expr_stmt|;
name|__function_requires
operator|<
name|_Mutable_ForwardIteratorConcept
operator|<
name|_Iterator
operator|>
block|>
operator|(
operator|)
block|;     }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_ReversibleContainer
operator|>
expr|struct
name|_ReversibleContainerConcept
block|{
typedef|typedef
name|typename
name|_ReversibleContainer
operator|::
name|const_iterator
name|_Const_iterator
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_ReversibleContainer
operator|::
name|const_reverse_iterator
name|_Const_reverse_iterator
expr_stmt|;
end_typedef

begin_function
name|void
name|__constraints
parameter_list|()
block|{
name|__function_requires
operator|<
name|_ForwardContainerConcept
operator|<
name|_ReversibleContainer
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_BidirectionalIteratorConcept
operator|<
name|_Const_iterator
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_BidirectionalIteratorConcept
operator|<
name|_Const_reverse_iterator
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
specifier|const
name|_ReversibleContainer
name|__c
decl_stmt|;
name|_Const_reverse_iterator
name|__i
init|=
name|__c
operator|.
name|rbegin
argument_list|()
decl_stmt|;
name|__i
operator|=
name|__c
operator|.
name|rend
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_ReversibleContainer
operator|>
expr|struct
name|_Mutable_ReversibleContainerConcept
block|{
typedef|typedef
name|typename
name|_ReversibleContainer
operator|::
name|iterator
name|_Iterator
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_ReversibleContainer
operator|::
name|reverse_iterator
name|_Reverse_iterator
expr_stmt|;
end_typedef

begin_function
name|void
name|__constraints
parameter_list|()
block|{
name|__function_requires
operator|<
name|_ReversibleContainerConcept
operator|<
name|_ReversibleContainer
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_Mutable_ForwardContainerConcept
operator|<
name|_ReversibleContainer
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_Mutable_BidirectionalIteratorConcept
operator|<
name|_Iterator
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_Mutable_BidirectionalIteratorConcept
operator|<
name|_Reverse_iterator
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|_Reverse_iterator
name|__i
init|=
name|__c
operator|.
name|rbegin
argument_list|()
decl_stmt|;
name|__i
operator|=
name|__c
operator|.
name|rend
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|_ReversibleContainer
name|__c
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_RandomAccessContainer
operator|>
expr|struct
name|_RandomAccessContainerConcept
block|{
typedef|typedef
name|typename
name|_RandomAccessContainer
operator|::
name|size_type
name|_Size_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_RandomAccessContainer
operator|::
name|const_reference
name|_Const_reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_RandomAccessContainer
operator|::
name|const_iterator
name|_Const_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_RandomAccessContainer
operator|::
name|const_reverse_iterator
name|_Const_reverse_iterator
expr_stmt|;
end_typedef

begin_function
name|void
name|__constraints
parameter_list|()
block|{
name|__function_requires
operator|<
name|_ReversibleContainerConcept
operator|<
name|_RandomAccessContainer
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_RandomAccessIteratorConcept
operator|<
name|_Const_iterator
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_RandomAccessIteratorConcept
operator|<
name|_Const_reverse_iterator
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
specifier|const
name|_RandomAccessContainer
name|__c
decl_stmt|;
name|_Const_reference
name|__r
name|_IsUnused
init|=
name|__c
index|[
name|__n
index|]
decl_stmt|;
block|}
end_function

begin_decl_stmt
name|_Size_type
name|__n
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_RandomAccessContainer
operator|>
expr|struct
name|_Mutable_RandomAccessContainerConcept
block|{
typedef|typedef
name|typename
name|_RandomAccessContainer
operator|::
name|size_type
name|_Size_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_RandomAccessContainer
operator|::
name|reference
name|_Reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_RandomAccessContainer
operator|::
name|iterator
name|_Iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_RandomAccessContainer
operator|::
name|reverse_iterator
name|_Reverse_iterator
expr_stmt|;
end_typedef

begin_function
name|void
name|__constraints
parameter_list|()
block|{
name|__function_requires
operator|<
name|_RandomAccessContainerConcept
operator|<
name|_RandomAccessContainer
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_Mutable_ReversibleContainerConcept
operator|<
name|_RandomAccessContainer
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_Mutable_RandomAccessIteratorConcept
operator|<
name|_Iterator
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_Mutable_RandomAccessIteratorConcept
operator|<
name|_Reverse_iterator
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|_Reference
name|__r
name|_IsUnused
init|=
name|__c
index|[
name|__i
index|]
decl_stmt|;
block|}
end_function

begin_decl_stmt
name|_Size_type
name|__i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_RandomAccessContainer
name|__c
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// A Sequence is inherently mutable
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Sequence
operator|>
expr|struct
name|_SequenceConcept
block|{
typedef|typedef
name|typename
name|_Sequence
operator|::
name|reference
name|_Reference
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Sequence
operator|::
name|const_reference
name|_Const_reference
expr_stmt|;
end_typedef

begin_function
name|void
name|__constraints
parameter_list|()
block|{
comment|// Matt Austern's book puts DefaultConstructible here, the C++
comment|// standard places it in Container
comment|//    function_requires< DefaultConstructible<Sequence>>();
name|__function_requires
operator|<
name|_Mutable_ForwardContainerConcept
operator|<
name|_Sequence
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__function_requires
operator|<
name|_DefaultConstructibleConcept
operator|<
name|_Sequence
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|_Sequence
name|__c
name|_IsUnused
argument_list|(
name|__n
argument_list|)
decl_stmt|,
name|__c2
name|_IsUnused
argument_list|(
name|__n
argument_list|,
name|__t
argument_list|)
decl_stmt|,
name|__c3
name|_IsUnused
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
decl_stmt|;
name|__c
operator|.
name|insert
argument_list|(
name|__p
argument_list|,
name|__t
argument_list|)
expr_stmt|;
name|__c
operator|.
name|insert
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|,
name|__t
argument_list|)
expr_stmt|;
name|__c
operator|.
name|insert
argument_list|(
name|__p
argument_list|,
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
name|__c
operator|.
name|erase
argument_list|(
name|__p
argument_list|)
expr_stmt|;
name|__c
operator|.
name|erase
argument_list|(
name|__p
argument_list|,
name|__q
argument_list|)
expr_stmt|;
name|_Reference
name|__r
name|_IsUnused
init|=
name|__c
operator|.
name|front
argument_list|()
decl_stmt|;
name|__const_constraints
argument_list|(
name|__c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__const_constraints
parameter_list|(
specifier|const
name|_Sequence
modifier|&
name|__c
parameter_list|)
block|{
name|_Const_reference
name|__r
name|_IsUnused
init|=
name|__c
operator|.
name|front
argument_list|()
decl_stmt|;
block|}
end_function

begin_expr_stmt
name|typename
name|_Sequence
operator|::
name|value_type
name|__t
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typename
name|_Sequence
operator|::
name|size_type
name|__n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typename
name|_Sequence
operator|::
name|value_type
operator|*
name|__first
operator|,
operator|*
name|__last
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typename
name|_Sequence
operator|::
name|iterator
name|__p
operator|,
name|__q
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_FrontInsertionSequence
operator|>
expr|struct
name|_FrontInsertionSequenceConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_SequenceConcept
operator|<
name|_FrontInsertionSequence
operator|>
expr|>
operator|(
operator|)
block|;
name|__c
operator|.
name|push_front
argument_list|(
name|__t
argument_list|)
block|;
name|__c
operator|.
name|pop_front
argument_list|()
block|;     }
name|_FrontInsertionSequence
name|__c
block|;
name|typename
name|_FrontInsertionSequence
operator|::
name|value_type
name|__t
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_BackInsertionSequence
operator|>
expr|struct
name|_BackInsertionSequenceConcept
block|{
typedef|typedef
name|typename
name|_BackInsertionSequence
operator|::
name|reference
name|_Reference
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_BackInsertionSequence
operator|::
name|const_reference
name|_Const_reference
expr_stmt|;
end_typedef

begin_function
name|void
name|__constraints
parameter_list|()
block|{
name|__function_requires
operator|<
name|_SequenceConcept
operator|<
name|_BackInsertionSequence
operator|>
expr|>
operator|(
operator|)
expr_stmt|;
name|__c
operator|.
name|push_back
argument_list|(
name|__t
argument_list|)
expr_stmt|;
name|__c
operator|.
name|pop_back
argument_list|()
expr_stmt|;
name|_Reference
name|__r
name|_IsUnused
init|=
name|__c
operator|.
name|back
argument_list|()
decl_stmt|;
block|}
end_function

begin_function
name|void
name|__const_constraints
parameter_list|(
specifier|const
name|_BackInsertionSequence
modifier|&
name|__c
parameter_list|)
block|{
name|_Const_reference
name|__r
name|_IsUnused
init|=
name|__c
operator|.
name|back
argument_list|()
decl_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|_BackInsertionSequence
name|__c
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|typename
name|_BackInsertionSequence
operator|::
name|value_type
name|__t
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_AssociativeContainer
operator|>
expr|struct
name|_AssociativeContainerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_ForwardContainerConcept
operator|<
name|_AssociativeContainer
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_DefaultConstructibleConcept
operator|<
name|_AssociativeContainer
operator|>
expr|>
operator|(
operator|)
block|;
name|__i
operator|=
name|__c
operator|.
name|find
argument_list|(
name|__k
argument_list|)
block|;
name|__r
operator|=
name|__c
operator|.
name|equal_range
argument_list|(
name|__k
argument_list|)
block|;
name|__c
operator|.
name|erase
argument_list|(
name|__k
argument_list|)
block|;
name|__c
operator|.
name|erase
argument_list|(
name|__i
argument_list|)
block|;
name|__c
operator|.
name|erase
argument_list|(
name|__r
operator|.
name|first
argument_list|,
name|__r
operator|.
name|second
argument_list|)
block|;
name|__const_constraints
argument_list|(
name|__c
argument_list|)
block|;     }
name|void
name|__const_constraints
argument_list|(
argument|const _AssociativeContainer& __c
argument_list|)
block|{
name|__ci
operator|=
name|__c
operator|.
name|find
argument_list|(
name|__k
argument_list|)
block|;
name|__n
operator|=
name|__c
operator|.
name|count
argument_list|(
name|__k
argument_list|)
block|;
name|__cr
operator|=
name|__c
operator|.
name|equal_range
argument_list|(
name|__k
argument_list|)
block|;     }
typedef|typedef
name|typename
name|_AssociativeContainer
operator|::
name|iterator
name|_Iterator
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_AssociativeContainer
operator|::
name|const_iterator
name|_Const_iterator
expr_stmt|;
end_typedef

begin_decl_stmt
name|_AssociativeContainer
name|__c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Iterator
name|__i
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|pair
operator|<
name|_Iterator
operator|,
name|_Iterator
operator|>
name|__r
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_Const_iterator
name|__ci
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|pair
operator|<
name|_Const_iterator
operator|,
name|_Const_iterator
operator|>
name|__cr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typename
name|_AssociativeContainer
operator|::
name|key_type
name|__k
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typename
name|_AssociativeContainer
operator|::
name|size_type
name|__n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_UniqueAssociativeContainer
operator|>
expr|struct
name|_UniqueAssociativeContainerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_AssociativeContainerConcept
operator|<
name|_UniqueAssociativeContainer
operator|>
expr|>
operator|(
operator|)
block|;
name|_UniqueAssociativeContainer
name|__c
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
name|__pos_flag
operator|=
name|__c
operator|.
name|insert
argument_list|(
name|__t
argument_list|)
block|;
name|__c
operator|.
name|insert
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;     }
name|std
operator|::
name|pair
operator|<
name|typename
name|_UniqueAssociativeContainer
operator|::
name|iterator
block|,
name|bool
operator|>
name|__pos_flag
block|;
name|typename
name|_UniqueAssociativeContainer
operator|::
name|value_type
name|__t
block|;
name|typename
name|_UniqueAssociativeContainer
operator|::
name|value_type
operator|*
name|__first
block|,
operator|*
name|__last
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_MultipleAssociativeContainer
operator|>
expr|struct
name|_MultipleAssociativeContainerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_AssociativeContainerConcept
operator|<
name|_MultipleAssociativeContainer
operator|>
expr|>
operator|(
operator|)
block|;
name|_MultipleAssociativeContainer
name|__c
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
name|__pos
operator|=
name|__c
operator|.
name|insert
argument_list|(
name|__t
argument_list|)
block|;
name|__c
operator|.
name|insert
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;      }
name|typename
name|_MultipleAssociativeContainer
operator|::
name|iterator
name|__pos
block|;
name|typename
name|_MultipleAssociativeContainer
operator|::
name|value_type
name|__t
block|;
name|typename
name|_MultipleAssociativeContainer
operator|::
name|value_type
operator|*
name|__first
block|,
operator|*
name|__last
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_SimpleAssociativeContainer
operator|>
expr|struct
name|_SimpleAssociativeContainerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_AssociativeContainerConcept
operator|<
name|_SimpleAssociativeContainer
operator|>
expr|>
operator|(
operator|)
block|;
typedef|typedef
name|typename
name|_SimpleAssociativeContainer
operator|::
name|key_type
name|_Key_type
expr_stmt|;
typedef|typedef
name|typename
name|_SimpleAssociativeContainer
operator|::
name|value_type
name|_Value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Aux_require_same
operator|<
name|_Key_type
operator|,
name|_Value_type
operator|>
operator|::
name|_Type
name|_Required
expr_stmt|;
end_typedef

begin_empty_stmt
unit|}   }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_SimpleAssociativeContainer
operator|>
expr|struct
name|_PairAssociativeContainerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_AssociativeContainerConcept
operator|<
name|_SimpleAssociativeContainer
operator|>
expr|>
operator|(
operator|)
block|;
typedef|typedef
name|typename
name|_SimpleAssociativeContainer
operator|::
name|key_type
name|_Key_type
expr_stmt|;
typedef|typedef
name|typename
name|_SimpleAssociativeContainer
operator|::
name|value_type
name|_Value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_SimpleAssociativeContainer
operator|::
name|mapped_type
name|_Mapped_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|pair
operator|<
specifier|const
name|_Key_type
operator|,
name|_Mapped_type
operator|>
name|_Required_value_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_Aux_require_same
operator|<
name|_Value_type
operator|,
name|_Required_value_type
operator|>
operator|::
name|_Type
name|_Required
expr_stmt|;
end_typedef

begin_empty_stmt
unit|}   }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_SortedAssociativeContainer
operator|>
expr|struct
name|_SortedAssociativeContainerConcept
block|{
name|void
name|__constraints
argument_list|()
block|{
name|__function_requires
operator|<
name|_AssociativeContainerConcept
operator|<
name|_SortedAssociativeContainer
operator|>
expr|>
operator|(
operator|)
block|;
name|__function_requires
operator|<
name|_ReversibleContainerConcept
operator|<
name|_SortedAssociativeContainer
operator|>
expr|>
operator|(
operator|)
block|;
name|_SortedAssociativeContainer
name|__c
name|_IsUnused
argument_list|(
name|__kc
argument_list|)
block|,
name|__c2
name|_IsUnused
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|,
name|__c3
name|_IsUnused
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__kc
argument_list|)
block|;
name|__p
operator|=
name|__c
operator|.
name|upper_bound
argument_list|(
name|__k
argument_list|)
block|;
name|__p
operator|=
name|__c
operator|.
name|lower_bound
argument_list|(
name|__k
argument_list|)
block|;
name|__r
operator|=
name|__c
operator|.
name|equal_range
argument_list|(
name|__k
argument_list|)
block|;
name|__c
operator|.
name|insert
argument_list|(
name|__p
argument_list|,
name|__t
argument_list|)
block|;     }
name|void
name|__const_constraints
argument_list|(
argument|const _SortedAssociativeContainer& __c
argument_list|)
block|{
name|__kc
operator|=
name|__c
operator|.
name|key_comp
argument_list|()
block|;
name|__vc
operator|=
name|__c
operator|.
name|value_comp
argument_list|()
block|;
name|__cp
operator|=
name|__c
operator|.
name|upper_bound
argument_list|(
name|__k
argument_list|)
block|;
name|__cp
operator|=
name|__c
operator|.
name|lower_bound
argument_list|(
name|__k
argument_list|)
block|;
name|__cr
operator|=
name|__c
operator|.
name|equal_range
argument_list|(
name|__k
argument_list|)
block|;     }
name|typename
name|_SortedAssociativeContainer
operator|::
name|key_compare
name|__kc
block|;
name|typename
name|_SortedAssociativeContainer
operator|::
name|value_compare
name|__vc
block|;
name|typename
name|_SortedAssociativeContainer
operator|::
name|value_type
name|__t
block|;
name|typename
name|_SortedAssociativeContainer
operator|::
name|key_type
name|__k
block|;
typedef|typedef
name|typename
name|_SortedAssociativeContainer
operator|::
name|iterator
name|_Iterator
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_SortedAssociativeContainer
operator|::
name|const_iterator
name|_Const_iterator
expr_stmt|;
end_typedef

begin_decl_stmt
name|_Iterator
name|__p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Const_iterator
name|__cp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|pair
operator|<
name|_Iterator
operator|,
name|_Iterator
operator|>
name|__r
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|pair
operator|<
name|_Const_iterator
operator|,
name|_Const_iterator
operator|>
name|__cr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typename
name|_SortedAssociativeContainer
operator|::
name|value_type
operator|*
name|__first
operator|,
operator|*
name|__last
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// HashedAssociativeContainer
end_comment

begin_comment
unit|}
comment|// namespace __gnu_cxx
end_comment

begin_undef
undef|#
directive|undef
name|_IsUnused
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// _GLIBCXX_BOOST_CONCEPT_CHECK
end_comment

end_unit

