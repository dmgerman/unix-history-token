begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// Functor implementations -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|/*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1996-1998  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/** @file stl_function.h  *  This is an internal header file, included by other library headers.  *  You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_FUNCTION_H
end_ifndef

begin_define
define|#
directive|define
name|_FUNCTION_H
value|1
end_define

begin_decl_stmt
name|namespace
name|std
block|{
comment|// 20.3.1 base classes
comment|/** @defgroup s20_3_1_base Functor Base Classes    *  Function objects, or @e functors, are objects with an @c operator()    *  defined and accessible.  They can be passed as arguments to algorithm    *  templates and used in place of a function pointer.  Not only is the    *  resulting expressiveness of the library increased, but the generated    *  code can be more efficient than what you might write by hand.  When we    *  refer to "functors," then, generally we include function pointers in    *  the description as well.    *    *  Often, functors are only created as temporaries passed to algorithm    *  calls, rather than being created as named variables.    *    *  Two examples taken from the standard itself follow.  To perform a    *  by-element addition of two vectors @c a and @c b containing @c double,    *  and put the result in @c a, use    *  \code    *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());    *  \endcode    *  To negate every element in @c a, use    *  \code    *  transform(a.begin(), a.end(), a.begin(), negate<double>());    *  \endcode    *  The addition and negation functions will be inlined directly.    *    *  The standard functiors are derived from structs named @c unary_function    *  and @c binary_function.  These two classes contain nothing but typedefs,    *  to aid in generic (template) programming.  If you write your own    *  functors, you might consider doing the same.    *    *  @{    */
comment|/**    *  This is one of the @link s20_3_1_base functor base classes@endlink.    */
name|template
operator|<
name|class
name|_Arg
operator|,
name|class
name|_Result
operator|>
expr|struct
name|unary_function
block|{
typedef|typedef
name|_Arg
name|argument_type
typedef|;
comment|///< @c argument_type is the type of the
comment|///     argument (no surprises here)
typedef|typedef
name|_Result
name|result_type
typedef|;
comment|///< @c result_type is the return type
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**    *  This is one of the @link s20_3_1_base functor base classes@endlink.    */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|,
name|class
name|_Result
operator|>
expr|struct
name|binary_function
block|{
typedef|typedef
name|_Arg1
name|first_argument_type
typedef|;
end_expr_stmt

begin_comment
comment|///< the type of the first argument
end_comment

begin_comment
comment|///  (no surprises here)
end_comment

begin_typedef
typedef|typedef
name|_Arg2
name|second_argument_type
typedef|;
end_typedef

begin_comment
comment|///< the type of the second argument
end_comment

begin_typedef
typedef|typedef
name|_Result
name|result_type
typedef|;
end_typedef

begin_comment
comment|///< type of the return type
end_comment

begin_comment
unit|};
comment|/** @}  */
end_comment

begin_comment
comment|// 20.3.2 arithmetic
end_comment

begin_comment
comment|/** @defgroup s20_3_2_arithmetic Arithmetic Classes    *  Because basic math often needs to be done during an algorithm, the library    *  provides functors for those operations.  See the documentation for    *  @link s20_3_1_base the base classes@endlink for examples of their use.    *    *  @{    */
end_comment

begin_comment
comment|/// One of the @link s20_3_2_arithmetic math functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|plus
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|+
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_2_arithmetic math functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|minus
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|-
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_2_arithmetic math functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|multiplies
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|*
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_2_arithmetic math functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|divides
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|/
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_2_arithmetic math functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|modulus
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|%
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_2_arithmetic math functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|negate
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
operator|-
name|__x
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/** @}  */
end_comment

begin_comment
comment|// 20.3.3 comparisons
end_comment

begin_comment
comment|/** @defgroup s20_3_3_comparisons Comparison Classes    *  The library provides six wrapper functors for all the basic comparisons    *  in C++, like @c<.    *    *  @{    */
end_comment

begin_comment
comment|/// One of the @link s20_3_3_comparisons comparison functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|equal_to
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|==
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_3_comparisons comparison functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|not_equal_to
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|!=
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_3_comparisons comparison functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|greater
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|>
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_3_comparisons comparison functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|less
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|<
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_3_comparisons comparison functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|greater_equal
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|>=
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_3_comparisons comparison functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|less_equal
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|<=
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/** @}  */
end_comment

begin_comment
comment|// 20.3.4 logical operations
end_comment

begin_comment
comment|/** @defgroup s20_3_4_logical Boolean Operations Classes    *  Here are wrapper functors for Boolean operations:  @c&&, @c ||, and @c !.    *    *  @{    */
end_comment

begin_comment
comment|/// One of the @link s20_3_4_logical Boolean operations functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|logical_and
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|&&
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_4_logical Boolean operations functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|logical_or
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|||
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_4_logical Boolean operations functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|logical_not
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
operator|!
name|__x
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/** @}  */
end_comment

begin_comment
comment|// 20.3.5 negators
end_comment

begin_comment
comment|/** @defgroup s20_3_5_negators Negators    *  The functions @c not1 and @c not2 each take a predicate functor    *  and return an instance of @c unary_negate or    *  @c binary_negate, respectively.  These classes are functors whose    *  @c operator() performs the stored predicate function and then returns    *  the negation of the result.    *    *  For example, given a vector of integers and a trivial predicate,    *  \code    *  struct IntGreaterThanThree    *    : public std::unary_function<int, bool>    *  {    *      bool operator() (int x) { return x> 3; }    *  };    *    *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));    *  \endcode    *  The call to @c find_if will locate the first index (i) of @c v for which    *  "!(v[i]> 3)" is true.    *    *  The not1/unary_negate combination works on predicates taking a single    *  argument.  The not2/binary_negate combination works on predicates which    *  take two arguments.    *    *  @{    */
end_comment

begin_comment
comment|/// One of the @link s20_3_5_negators negation functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Predicate
operator|>
name|class
name|unary_negate
operator|:
name|public
name|unary_function
operator|<
name|typename
name|_Predicate
operator|::
name|argument_type
operator|,
name|bool
operator|>
block|{
name|protected
operator|:
name|_Predicate
name|_M_pred
block|;
name|public
operator|:
name|explicit
name|unary_negate
argument_list|(
specifier|const
name|_Predicate
operator|&
name|__x
argument_list|)
operator|:
name|_M_pred
argument_list|(
argument|__x
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|_Predicate
operator|::
name|argument_type
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
operator|!
name|_M_pred
argument_list|(
name|__x
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_5_negators negation functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Predicate
operator|>
specifier|inline
name|unary_negate
operator|<
name|_Predicate
operator|>
name|not1
argument_list|(
argument|const _Predicate& __pred
argument_list|)
block|{
return|return
name|unary_negate
operator|<
name|_Predicate
operator|>
operator|(
name|__pred
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// One of the @link s20_3_5_negators negation functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Predicate
operator|>
name|class
name|binary_negate
operator|:
name|public
name|binary_function
operator|<
name|typename
name|_Predicate
operator|::
name|first_argument_type
operator|,
name|typename
name|_Predicate
operator|::
name|second_argument_type
operator|,
name|bool
operator|>
block|{
name|protected
operator|:
name|_Predicate
name|_M_pred
block|;
name|public
operator|:
name|explicit
name|binary_negate
argument_list|(
specifier|const
name|_Predicate
operator|&
name|__x
argument_list|)
operator|:
name|_M_pred
argument_list|(
argument|__x
argument_list|)
block|{ }
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|_Predicate
operator|::
name|first_argument_type
operator|&
name|__x
operator|,
specifier|const
name|typename
name|_Predicate
operator|::
name|second_argument_type
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
operator|!
name|_M_pred
argument_list|(
name|__x
argument_list|,
name|__y
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_5_negators negation functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Predicate
operator|>
specifier|inline
name|binary_negate
operator|<
name|_Predicate
operator|>
name|not2
argument_list|(
argument|const _Predicate& __pred
argument_list|)
block|{
return|return
name|binary_negate
operator|<
name|_Predicate
operator|>
operator|(
name|__pred
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/** @}  */
end_comment

begin_comment
comment|// 20.3.6 binders
end_comment

begin_comment
comment|/** @defgroup s20_3_6_binder Binder Classes    *  Binders turn functions/functors with two arguments into functors with    *  a single argument, storing an argument to be applied later.  For    *  example, an variable @c B of type @c binder1st is constructed from a    *  functor @c f and an argument @c x.  Later, B's @c operator() is called    *  with a single argument @c y.  The return value is the value of @c f(x,y).    *  @c B can be "called" with various arguments (y1, y2, ...) and will in    *  turn call @c f(x,y1), @c f(x,y2), ...    *    *  The function @c bind1st is provided to save some typing.  It takes the    *  function and an argument as parameters, and returns an instance of    *  @c binder1st.    *    *  The type @c binder2nd and its creator function @c bind2nd do the same    *  thing, but the stored argument is passed as the second parameter instead    *  of the first, e.g., @c bind2nd(std::minus<float>,1.3) will create a    *  functor whose @c operator() accepts a floating-point number, subtracts    *  1.3 from it, and returns the result.  (If @c bind1st had been used,    *  the functor would perform "1.3 - x" instead.    *    *  Creator-wrapper functions like @c bind1st are intended to be used in    *  calling algorithms.  Their return values will be temporary objects.    *  (The goal is to not require you to type names like    *  @c std::binder1st<std::plus<int>> for declaring a variable to hold the    *  return value from @c bind1st(std::plus<int>,5).    *    *  These become more useful when combined with the composition functions.    *    *  @{    */
end_comment

begin_comment
comment|/// One of the @link s20_3_6_binder binder functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Operation
operator|>
name|class
name|binder1st
operator|:
name|public
name|unary_function
operator|<
name|typename
name|_Operation
operator|::
name|second_argument_type
operator|,
name|typename
name|_Operation
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|_Operation
name|op
block|;
name|typename
name|_Operation
operator|::
name|first_argument_type
name|value
block|;
name|public
operator|:
name|binder1st
argument_list|(
argument|const _Operation& __x
argument_list|,
argument|const typename _Operation::first_argument_type& __y
argument_list|)
operator|:
name|op
argument_list|(
name|__x
argument_list|)
block|,
name|value
argument_list|(
argument|__y
argument_list|)
block|{}
name|typename
name|_Operation
operator|::
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|_Operation
operator|::
name|second_argument_type
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|op
argument_list|(
name|value
argument_list|,
name|__x
argument_list|)
return|;
block|}
comment|// _GLIBCXX_RESOLVE_LIB_DEFECTS
comment|// 109.  Missing binders for non-const sequence elements
name|typename
name|_Operation
operator|::
name|result_type
name|operator
argument_list|()
operator|(
name|typename
name|_Operation
operator|::
name|second_argument_type
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|op
argument_list|(
name|value
argument_list|,
name|__x
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_6_binder binder functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Operation
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|binder1st
operator|<
name|_Operation
operator|>
name|bind1st
argument_list|(
argument|const _Operation& __fn
argument_list|,
argument|const _Tp& __x
argument_list|)
block|{
typedef|typedef
name|typename
name|_Operation
operator|::
name|first_argument_type
name|_Arg1_type
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|binder1st
operator|<
name|_Operation
operator|>
operator|(
name|__fn
operator|,
name|_Arg1_type
argument_list|(
name|__x
argument_list|)
operator|)
return|;
end_return

begin_comment
unit|}
comment|/// One of the @link s20_3_6_binder binder functors@endlink.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_Operation
operator|>
name|class
name|binder2nd
operator|:
name|public
name|unary_function
operator|<
name|typename
name|_Operation
operator|::
name|first_argument_type
operator|,
name|typename
name|_Operation
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|_Operation
name|op
block|;
name|typename
name|_Operation
operator|::
name|second_argument_type
name|value
block|;
name|public
operator|:
name|binder2nd
argument_list|(
argument|const _Operation& __x
argument_list|,
argument|const typename _Operation::second_argument_type& __y
argument_list|)
operator|:
name|op
argument_list|(
name|__x
argument_list|)
block|,
name|value
argument_list|(
argument|__y
argument_list|)
block|{}
name|typename
name|_Operation
operator|::
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|_Operation
operator|::
name|first_argument_type
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|op
argument_list|(
name|__x
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|// _GLIBCXX_RESOLVE_LIB_DEFECTS
comment|// 109.  Missing binders for non-const sequence elements
name|typename
name|_Operation
operator|::
name|result_type
name|operator
argument_list|()
operator|(
name|typename
name|_Operation
operator|::
name|first_argument_type
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|op
argument_list|(
name|__x
argument_list|,
name|value
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_6_binder binder functors@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Operation
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|binder2nd
operator|<
name|_Operation
operator|>
name|bind2nd
argument_list|(
argument|const _Operation& __fn
argument_list|,
argument|const _Tp& __x
argument_list|)
block|{
typedef|typedef
name|typename
name|_Operation
operator|::
name|second_argument_type
name|_Arg2_type
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|binder2nd
operator|<
name|_Operation
operator|>
operator|(
name|__fn
operator|,
name|_Arg2_type
argument_list|(
name|__x
argument_list|)
operator|)
return|;
end_return

begin_comment
unit|}
comment|/** @}  */
end_comment

begin_comment
comment|// 20.3.7 adaptors pointers functions
end_comment

begin_comment
comment|/** @defgroup s20_3_7_adaptors Adaptors for pointers to functions    *  The advantage of function objects over pointers to functions is that    *  the objects in the standard library declare nested typedefs describing    *  their argument and result types with uniform names (e.g., @c result_type    *  from the base classes @c unary_function and @c binary_function).    *  Sometimes those typedefs are required, not just optional.    *    *  Adaptors are provided to turn pointers to unary (single-argument) and    *  binary (double-argument) functions into function objects.  The    *  long-winded functor @c pointer_to_unary_function is constructed with a    *  function pointer @c f, and its @c operator() called with argument @c x    *  returns @c f(x).  The functor @c pointer_to_binary_function does the same    *  thing, but with a double-argument @c f and @c operator().    *    *  The function @c ptr_fun takes a pointer-to-function @c f and constructs    *  an instance of the appropriate functor.    *    *  @{    */
end_comment

begin_comment
comment|/// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_Arg
operator|,
name|class
name|_Result
operator|>
name|class
name|pointer_to_unary_function
operator|:
name|public
name|unary_function
operator|<
name|_Arg
operator|,
name|_Result
operator|>
block|{
name|protected
operator|:
name|_Result
argument_list|(
operator|*
name|_M_ptr
argument_list|)
argument_list|(
name|_Arg
argument_list|)
block|;
name|public
operator|:
name|pointer_to_unary_function
argument_list|()
block|{}
name|explicit
name|pointer_to_unary_function
argument_list|(
name|_Result
argument_list|(
operator|*
name|__x
argument_list|)
argument_list|(
name|_Arg
argument_list|)
argument_list|)
operator|:
name|_M_ptr
argument_list|(
argument|__x
argument_list|)
block|{}
name|_Result
name|operator
argument_list|()
operator|(
name|_Arg
name|__x
operator|)
specifier|const
block|{
return|return
name|_M_ptr
argument_list|(
name|__x
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Arg
operator|,
name|class
name|_Result
operator|>
specifier|inline
name|pointer_to_unary_function
operator|<
name|_Arg
operator|,
name|_Result
operator|>
name|ptr_fun
argument_list|(
argument|_Result (*__x)(_Arg)
argument_list|)
block|{
return|return
name|pointer_to_unary_function
operator|<
name|_Arg
operator|,
name|_Result
operator|>
operator|(
name|__x
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|,
name|class
name|_Result
operator|>
name|class
name|pointer_to_binary_function
operator|:
name|public
name|binary_function
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|,
name|_Result
operator|>
block|{
name|protected
operator|:
name|_Result
argument_list|(
operator|*
name|_M_ptr
argument_list|)
argument_list|(
name|_Arg1
argument_list|,
name|_Arg2
argument_list|)
block|;
name|public
operator|:
name|pointer_to_binary_function
argument_list|()
block|{}
name|explicit
name|pointer_to_binary_function
argument_list|(
name|_Result
argument_list|(
operator|*
name|__x
argument_list|)
argument_list|(
name|_Arg1
argument_list|,
name|_Arg2
argument_list|)
argument_list|)
operator|:
name|_M_ptr
argument_list|(
argument|__x
argument_list|)
block|{}
name|_Result
name|operator
argument_list|()
operator|(
name|_Arg1
name|__x
operator|,
name|_Arg2
name|__y
operator|)
specifier|const
block|{
return|return
name|_M_ptr
argument_list|(
name|__x
argument_list|,
name|__y
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|,
name|class
name|_Result
operator|>
specifier|inline
name|pointer_to_binary_function
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|,
name|_Result
operator|>
name|ptr_fun
argument_list|(
argument|_Result (*__x)(_Arg1, _Arg2)
argument_list|)
block|{
return|return
name|pointer_to_binary_function
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|,
name|_Result
operator|>
operator|(
name|__x
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/** @}  */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_Identity
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
operator|&
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|__x
return|;
block|}
specifier|const
name|_Tp
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|__x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Pair
operator|>
expr|struct
name|_Select1st
operator|:
name|public
name|unary_function
operator|<
name|_Pair
operator|,
name|typename
name|_Pair
operator|::
name|first_type
operator|>
block|{
name|typename
name|_Pair
operator|::
name|first_type
operator|&
name|operator
argument_list|()
operator|(
name|_Pair
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|__x
operator|.
name|first
return|;
block|}
specifier|const
name|typename
name|_Pair
operator|::
name|first_type
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|_Pair
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|__x
operator|.
name|first
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Pair
operator|>
expr|struct
name|_Select2nd
operator|:
name|public
name|unary_function
operator|<
name|_Pair
operator|,
name|typename
name|_Pair
operator|::
name|second_type
operator|>
block|{
name|typename
name|_Pair
operator|::
name|second_type
operator|&
name|operator
argument_list|()
operator|(
name|_Pair
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|__x
operator|.
name|second
return|;
block|}
specifier|const
name|typename
name|_Pair
operator|::
name|second_type
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|_Pair
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|__x
operator|.
name|second
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// 20.3.8 adaptors pointers members
end_comment

begin_comment
comment|/** @defgroup s20_3_8_memadaptors Adaptors for pointers to members    *  There are a total of 16 = 2^4 function objects in this family.    *   (1) Member functions taking no arguments vs member functions taking    *        one argument.    *   (2) Call through pointer vs call through reference.    *   (3) Member function with void return type vs member function with    *       non-void return type.    *   (4) Const vs non-const member function.    *    *  Note that choice (3) is nothing more than a workaround: according    *   to the draft, compilers should handle void and non-void the same way.    *   This feature is not yet widely implemented, though.  You can only use    *   member functions returning void if your compiler supports partial    *   specialization.    *    *  All of this complexity is in the function objects themselves.  You can    *   ignore it by using the helper function mem_fun and mem_fun_ref,    *   which create whichever type of adaptor is appropriate.    *    *  @{    */
end_comment

begin_comment
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
name|class
name|mem_fun_t
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|*
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_t
argument_list|(
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
name|_Tp
operator|*
name|__p
operator|)
specifier|const
block|{
return|return
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
name|class
name|const_mem_fun_t
operator|:
name|public
name|unary_function
operator|<
specifier|const
name|_Tp
operator|*
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_t
argument_list|(
name|_Ret
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|*
name|__p
operator|)
specifier|const
block|{
return|return
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
name|class
name|mem_fun_ref_t
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_ref_t
argument_list|(
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__r
operator|)
specifier|const
block|{
return|return
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
name|class
name|const_mem_fun_ref_t
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_ref_t
argument_list|(
name|_Ret
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__r
operator|)
specifier|const
block|{
return|return
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|mem_fun1_t
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|*
operator|,
name|_Arg
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_t
argument_list|(
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|(
name|_Arg
argument_list|)
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
name|_Tp
operator|*
name|__p
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
return|return
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
name|__x
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|(
name|_Arg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|const_mem_fun1_t
operator|:
name|public
name|binary_function
operator|<
specifier|const
name|_Tp
operator|*
operator|,
name|_Arg
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_t
argument_list|(
name|_Ret
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|*
name|__p
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
return|return
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
name|__x
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|mem_fun1_ref_t
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Arg
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_ref_t
argument_list|(
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|(
name|_Arg
argument_list|)
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__r
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
return|return
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
name|__x
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|(
name|_Arg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|const_mem_fun1_ref_t
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Arg
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_ref_t
argument_list|(
name|_Ret
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__r
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
return|return
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
name|__x
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
name|class
name|mem_fun_t
operator|<
name|void
operator|,
name|_Tp
operator|>
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|*
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_t
argument_list|(
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|_Tp
operator|*
name|__p
operator|)
specifier|const
block|{
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|()
block|;     }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
name|class
name|const_mem_fun_t
operator|<
name|void
operator|,
name|_Tp
operator|>
operator|:
name|public
name|unary_function
operator|<
specifier|const
name|_Tp
operator|*
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_t
argument_list|(
name|void
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|*
name|__p
operator|)
specifier|const
block|{
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
operator|)
specifier|const
block|;     }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
name|class
name|mem_fun_ref_t
operator|<
name|void
operator|,
name|_Tp
operator|>
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_ref_t
argument_list|(
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__r
operator|)
specifier|const
block|{
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|()
block|;     }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
name|class
name|const_mem_fun_ref_t
operator|<
name|void
operator|,
name|_Tp
operator|>
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_ref_t
argument_list|(
name|void
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__r
operator|)
specifier|const
block|{
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
operator|)
specifier|const
block|;     }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|mem_fun1_t
operator|<
name|void
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|*
operator|,
name|_Arg
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_t
argument_list|(
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|(
name|_Arg
argument_list|)
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|_Tp
operator|*
name|__p
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
name|__x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|(
name|_Arg
argument_list|)
block|;     }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|const_mem_fun1_t
operator|<
name|void
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|:
name|public
name|binary_function
operator|<
specifier|const
name|_Tp
operator|*
operator|,
name|_Arg
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_t
argument_list|(
name|void
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|*
name|__p
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
name|__x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
block|;     }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|mem_fun1_ref_t
operator|<
name|void
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Arg
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_ref_t
argument_list|(
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|(
name|_Arg
argument_list|)
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__r
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
name|__x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|(
name|_Arg
argument_list|)
block|;     }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|const_mem_fun1_ref_t
operator|<
name|void
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Arg
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_ref_t
argument_list|(
name|void
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__r
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
name|__x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
block|;     }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Mem_fun adaptor helper functions.  There are only two:
end_comment

begin_comment
comment|// mem_fun and mem_fun_ref.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|mem_fun_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
name|mem_fun
argument_list|(
argument|_Ret (_Tp::*__f)()
argument_list|)
block|{
return|return
name|mem_fun_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|const_mem_fun_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
name|mem_fun
argument_list|(
argument|_Ret (_Tp::*__f)() const
argument_list|)
block|{
return|return
name|const_mem_fun_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|mem_fun_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
name|mem_fun_ref
argument_list|(
argument|_Ret (_Tp::*__f)()
argument_list|)
block|{
return|return
name|mem_fun_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|const_mem_fun_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
name|mem_fun_ref
argument_list|(
argument|_Ret (_Tp::*__f)() const
argument_list|)
block|{
return|return
name|const_mem_fun_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg)
argument_list|)
block|{
return|return
name|mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|const_mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg) const
argument_list|)
block|{
return|return
name|const_mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun_ref
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg)
argument_list|)
block|{
return|return
name|mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|const_mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun_ref
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg) const
argument_list|)
block|{
return|return
name|const_mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/** @}  */
end_comment

begin_comment
unit|}
comment|// namespace std
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FUNCTION_H */
end_comment

begin_comment
comment|// Local Variables:
end_comment

begin_comment
comment|// mode:C++
end_comment

begin_comment
comment|// End:
end_comment

end_unit

