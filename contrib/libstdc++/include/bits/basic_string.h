begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// Components for manipulating sequences of characters -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002
end_comment

begin_comment
comment|// Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// ISO C++ 14882: 21 Strings library
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/** @file basic_string.h  *  This is an internal header file, included by other library headers.  *  You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_CPP_BITS_STRING_H
end_ifndef

begin_define
define|#
directive|define
name|_CPP_BITS_STRING_H
value|1
end_define

begin_pragma
pragma|#
directive|pragma
name|GCC
name|system_header
end_pragma

begin_include
include|#
directive|include
file|<bits/atomicity.h>
end_include

begin_decl_stmt
name|namespace
name|std
block|{
comment|// Documentation?  What's that?
comment|// Nathan Myers<ncm@cantrip.org>.
comment|//
comment|// A string looks like this:
comment|//
comment|//                               	[_Rep]
comment|//                               	_M_length
comment|//  [basic_string<char_type>]		_M_capacity
comment|//  _M_dataplus                	_M_state
comment|//  _M_p ---------------->   		unnamed array of char_type
comment|// Where the _M_p points to the first character in the string, and
comment|// you cast it to a pointer-to-_Rep and subtract 1 to get a
comment|// pointer to the header.
comment|// This approach has the enormous advantage that a string object
comment|// requires only one allocation.  All the ugliness is confined
comment|// within a single pair of inline functions, which each compile to
comment|// a single "add" instruction: _Rep::_M_data(), and
comment|// string::_M_rep(); and the allocation function which gets a
comment|// block of raw bytes and with room enough and constructs a _Rep
comment|// object at the front.
comment|// The reason you want _M_data pointing to the character array and
comment|// not the _Rep is so that the debugger can see the string
comment|// contents. (Probably we should add a non-inline member to get
comment|// the _Rep for the debugger to use, so users can check the actual
comment|// string length.)
comment|// Note that the _Rep object is a POD so that you can have a
comment|// static "empty string" _Rep object already "constructed" before
comment|// static constructors have run.  The reference-count encoding is
comment|// chosen so that a 0 indicates one reference, so you never try to
comment|// destroy the empty-string _Rep object.
comment|// All but the last paragraph is considered pretty conventional
comment|// for a C++ string implementation.
comment|// 21.3  Template class basic_string
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
name|class
name|basic_string
block|{
comment|// Types:
name|public
operator|:
typedef|typedef
name|_Traits
name|traits_type
typedef|;
typedef|typedef
name|typename
name|_Traits
operator|::
name|char_type
name|value_type
expr_stmt|;
typedef|typedef
name|_Alloc
name|allocator_type
typedef|;
typedef|typedef
name|typename
name|_Alloc
operator|::
name|size_type
name|size_type
expr_stmt|;
typedef|typedef
name|typename
name|_Alloc
operator|::
name|difference_type
name|difference_type
expr_stmt|;
typedef|typedef
name|typename
name|_Alloc
operator|::
name|reference
name|reference
expr_stmt|;
typedef|typedef
name|typename
name|_Alloc
operator|::
name|const_reference
name|const_reference
expr_stmt|;
typedef|typedef
name|typename
name|_Alloc
operator|::
name|pointer
name|pointer
expr_stmt|;
typedef|typedef
name|typename
name|_Alloc
operator|::
name|const_pointer
name|const_pointer
expr_stmt|;
typedef|typedef
name|__gnu_cxx
operator|::
name|__normal_iterator
operator|<
name|pointer
operator|,
name|basic_string
operator|>
name|iterator
expr_stmt|;
typedef|typedef
name|__gnu_cxx
operator|::
name|__normal_iterator
operator|<
name|const_pointer
operator|,
name|basic_string
operator|>
name|const_iterator
expr_stmt|;
typedef|typedef
name|reverse_iterator
operator|<
name|const_iterator
operator|>
name|const_reverse_iterator
expr_stmt|;
typedef|typedef
name|reverse_iterator
operator|<
name|iterator
operator|>
name|reverse_iterator
expr_stmt|;
name|private
label|:
comment|// _Rep: string representation
comment|//   Invariants:
comment|//   1. String really contains _M_length + 1 characters; last is set
comment|//      to 0 only on call to c_str().  We avoid instantiating
comment|//      _CharT() where the interface does not require it.
comment|//   2. _M_capacity>= _M_length
comment|//      Allocated memory is always _M_capacity + (1 * sizeof(_CharT)).
comment|//   3. _M_references has three states:
comment|//      -1: leaked, one reference, no ref-copies allowed, non-const.
comment|//       0: one reference, non-const.
comment|//     n>0: n + 1 references, operations require a lock, const.
comment|//   4. All fields==0 is an empty string, given the extra storage
comment|//      beyond-the-end for a null terminator; thus, the shared
comment|//      empty string representation needs no constructor.
struct|struct
name|_Rep
block|{
comment|// Types:
typedef|typedef
name|typename
name|_Alloc
operator|::
name|template
name|rebind
operator|<
name|char
operator|>
operator|::
name|other
name|_Raw_bytes_alloc
expr_stmt|;
comment|// (Public) Data members:
comment|// The maximum number of individual char_type elements of an
comment|// individual string is determined by _S_max_size. This is the
comment|// value that will be returned by max_size().  (Whereas npos
comment|// is the maximum number of bytes the allocator can allocate.)
comment|// If one was to divvy up the theoretical largest size string,
comment|// with a terminating character and m _CharT elements, it'd
comment|// look like this:
comment|// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)
comment|// Solving for m:
comment|// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1
comment|// In addition, this implementation quarters this ammount.
specifier|static
specifier|const
name|size_type
name|_S_max_size
decl_stmt|;
specifier|static
specifier|const
name|_CharT
name|_S_terminal
decl_stmt|;
name|size_type
name|_M_length
decl_stmt|;
name|size_type
name|_M_capacity
decl_stmt|;
name|_Atomic_word
name|_M_references
decl_stmt|;
name|bool
name|_M_is_leaked
argument_list|()
specifier|const
block|{
return|return
name|_M_references
operator|<
literal|0
return|;
block|}
name|bool
name|_M_is_shared
argument_list|()
specifier|const
block|{
return|return
name|_M_references
operator|>
literal|0
return|;
block|}
name|void
name|_M_set_leaked
parameter_list|()
block|{
name|_M_references
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|void
name|_M_set_sharable
parameter_list|()
block|{
name|_M_references
operator|=
literal|0
expr_stmt|;
block|}
name|_CharT
modifier|*
name|_M_refdata
parameter_list|()
function|throw
parameter_list|()
block|{
return|return
name|reinterpret_cast
operator|<
name|_CharT
operator|*
operator|>
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
name|_CharT
modifier|&
name|operator
function|[]
parameter_list|(
name|size_t
name|__s
parameter_list|)
function|throw
parameter_list|()
block|{
return|return
name|_M_refdata
argument_list|()
index|[
name|__s
index|]
return|;
block|}
name|_CharT
modifier|*
name|_M_grab
parameter_list|(
specifier|const
name|_Alloc
modifier|&
name|__alloc1
parameter_list|,
specifier|const
name|_Alloc
modifier|&
name|__alloc2
parameter_list|)
block|{
return|return
operator|(
operator|!
name|_M_is_leaked
argument_list|()
operator|&&
name|__alloc1
operator|==
name|__alloc2
operator|)
condition|?
name|_M_refcopy
argument_list|()
else|:
name|_M_clone
argument_list|(
name|__alloc1
argument_list|)
return|;
block|}
comment|// Create& Destroy
specifier|static
name|_Rep
modifier|*
name|_S_create
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|_Alloc
modifier|&
parameter_list|)
function_decl|;
name|void
name|_M_dispose
parameter_list|(
specifier|const
name|_Alloc
modifier|&
name|__a
parameter_list|)
block|{
if|if
condition|(
name|__exchange_and_add
argument_list|(
operator|&
name|_M_references
argument_list|,
operator|-
literal|1
argument_list|)
operator|<=
literal|0
condition|)
name|_M_destroy
argument_list|(
name|__a
argument_list|)
expr_stmt|;
block|}
comment|// XXX MT
name|void
name|_M_destroy
parameter_list|(
specifier|const
name|_Alloc
modifier|&
parameter_list|)
function_decl|throw
parameter_list|()
function_decl|;
name|_CharT
modifier|*
name|_M_refcopy
parameter_list|()
function|throw
parameter_list|()
block|{
name|__atomic_add
argument_list|(
operator|&
name|_M_references
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|_M_refdata
argument_list|()
return|;
block|}
comment|// XXX MT
name|_CharT
modifier|*
name|_M_clone
parameter_list|(
specifier|const
name|_Alloc
modifier|&
parameter_list|,
name|size_type
name|__res
init|=
literal|0
parameter_list|)
function_decl|;
block|}
struct|;
comment|// Use empty-base optimization: http://www.cantrip.org/emptyopt.html
name|struct
name|_Alloc_hider
range|:
name|_Alloc
block|{
name|_Alloc_hider
argument_list|(
name|_CharT
operator|*
name|__dat
argument_list|,
specifier|const
name|_Alloc
operator|&
name|__a
argument_list|)
operator|:
name|_Alloc
argument_list|(
name|__a
argument_list|)
block|,
name|_M_p
argument_list|(
argument|__dat
argument_list|)
block|{ }
name|_CharT
operator|*
name|_M_p
block|;
comment|// The actual data.
block|}
decl_stmt|;
name|public
label|:
comment|// Data Members (public):
comment|// NB: This is an unsigned type, and thus represents the maximum
comment|// size that the allocator can hold.
specifier|static
specifier|const
name|size_type
name|npos
init|=
name|static_cast
operator|<
name|size_type
operator|>
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
name|private
label|:
comment|// Data Members (private):
name|mutable
name|_Alloc_hider
name|_M_dataplus
decl_stmt|;
comment|// The following storage is init'd to 0 by the linker, resulting
comment|// (carefully) in an empty string with one reference.
specifier|static
name|size_type
name|_S_empty_rep_storage
index|[
operator|(
sizeof|sizeof
argument_list|(
name|_Rep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|_CharT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|size_type
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|size_type
argument_list|)
index|]
decl_stmt|;
name|_CharT
operator|*
name|_M_data
argument_list|()
specifier|const
block|{
return|return
name|_M_dataplus
operator|.
name|_M_p
return|;
block|}
name|_CharT
modifier|*
name|_M_data
parameter_list|(
name|_CharT
modifier|*
name|__p
parameter_list|)
block|{
return|return
operator|(
name|_M_dataplus
operator|.
name|_M_p
operator|=
name|__p
operator|)
return|;
block|}
name|_Rep
operator|*
name|_M_rep
argument_list|()
specifier|const
block|{
return|return
operator|&
operator|(
operator|(
name|reinterpret_cast
operator|<
name|_Rep
operator|*
operator|>
operator|(
name|_M_data
argument_list|()
operator|)
operator|)
index|[
operator|-
literal|1
index|]
operator|)
return|;
block|}
comment|// For the internal use we have functions similar to `begin'/`end'
comment|// but they do not call _M_leak.
name|iterator
name|_M_ibegin
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|_M_data
argument_list|()
argument_list|)
return|;
block|}
name|iterator
name|_M_iend
argument_list|()
specifier|const
block|{
return|return
name|iterator
argument_list|(
name|_M_data
argument_list|()
operator|+
name|this
operator|->
name|size
argument_list|()
argument_list|)
return|;
block|}
name|void
name|_M_leak
parameter_list|()
comment|// for use in begin()& non-const op[]
block|{
if|if
condition|(
operator|!
name|_M_rep
argument_list|()
operator|->
name|_M_is_leaked
argument_list|()
condition|)
name|_M_leak_hard
argument_list|()
expr_stmt|;
block|}
name|iterator
name|_M_check
argument_list|(
name|size_type
name|__pos
argument_list|)
decl|const
block|{
if|if
condition|(
name|__pos
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
name|__throw_out_of_range
argument_list|(
literal|"basic_string::_M_check"
argument_list|)
expr_stmt|;
return|return
name|_M_ibegin
argument_list|()
operator|+
name|__pos
return|;
block|}
comment|// NB: _M_fold doesn't check for a bad __pos1 value.
name|iterator
name|_M_fold
argument_list|(
name|size_type
name|__pos
argument_list|,
name|size_type
name|__off
argument_list|)
decl|const
block|{
name|bool
name|__testoff
init|=
name|__off
operator|<
name|this
operator|->
name|size
argument_list|()
operator|-
name|__pos
decl_stmt|;
name|size_type
name|__newoff
init|=
name|__testoff
condition|?
name|__off
else|:
name|this
operator|->
name|size
argument_list|()
operator|-
name|__pos
decl_stmt|;
return|return
operator|(
name|_M_ibegin
argument_list|()
operator|+
name|__pos
operator|+
name|__newoff
operator|)
return|;
block|}
comment|// _S_copy_chars is a separate template to permit specialization
comment|// to optimize for the common case of pointers as iterators.
name|template
operator|<
name|class
name|_Iterator
operator|>
specifier|static
name|void
name|_S_copy_chars
argument_list|(
argument|_CharT* __p
argument_list|,
argument|_Iterator __k1
argument_list|,
argument|_Iterator __k2
argument_list|)
block|{
for|for
control|(
init|;
name|__k1
operator|!=
name|__k2
condition|;
operator|++
name|__k1
operator|,
operator|++
name|__p
control|)
name|traits_type
operator|::
name|assign
argument_list|(
operator|*
name|__p
argument_list|,
operator|*
name|__k1
argument_list|)
expr_stmt|;
comment|// These types are off.
block|}
specifier|static
name|void
name|_S_copy_chars
parameter_list|(
name|_CharT
modifier|*
name|__p
parameter_list|,
name|iterator
name|__k1
parameter_list|,
name|iterator
name|__k2
parameter_list|)
block|{
name|_S_copy_chars
argument_list|(
name|__p
argument_list|,
name|__k1
operator|.
name|base
argument_list|()
argument_list|,
name|__k2
operator|.
name|base
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|_S_copy_chars
parameter_list|(
name|_CharT
modifier|*
name|__p
parameter_list|,
name|const_iterator
name|__k1
parameter_list|,
name|const_iterator
name|__k2
parameter_list|)
block|{
name|_S_copy_chars
argument_list|(
name|__p
argument_list|,
name|__k1
operator|.
name|base
argument_list|()
argument_list|,
name|__k2
operator|.
name|base
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|_S_copy_chars
parameter_list|(
name|_CharT
modifier|*
name|__p
parameter_list|,
name|_CharT
modifier|*
name|__k1
parameter_list|,
name|_CharT
modifier|*
name|__k2
parameter_list|)
block|{
name|traits_type
operator|::
name|copy
argument_list|(
name|__p
argument_list|,
name|__k1
argument_list|,
name|__k2
operator|-
name|__k1
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|_S_copy_chars
parameter_list|(
name|_CharT
modifier|*
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__k1
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__k2
parameter_list|)
block|{
name|traits_type
operator|::
name|copy
argument_list|(
name|__p
argument_list|,
name|__k1
argument_list|,
name|__k2
operator|-
name|__k1
argument_list|)
expr_stmt|;
block|}
name|void
name|_M_mutate
parameter_list|(
name|size_type
name|__pos
parameter_list|,
name|size_type
name|__len1
parameter_list|,
name|size_type
name|__len2
parameter_list|)
function_decl|;
name|void
name|_M_leak_hard
parameter_list|()
function_decl|;
specifier|static
name|_Rep
modifier|&
name|_S_empty_rep
parameter_list|()
block|{
return|return
operator|*
name|reinterpret_cast
operator|<
name|_Rep
operator|*
operator|>
operator|(
operator|&
name|_S_empty_rep_storage
operator|)
return|;
block|}
name|public
label|:
comment|// Construct/copy/destroy:
comment|// NB: We overload ctors in some cases instead of using default
comment|// arguments, per 17.4.4.4 para. 2 item 2.
specifier|inline
name|basic_string
argument_list|()
expr_stmt|;
name|explicit
name|basic_string
parameter_list|(
specifier|const
name|_Alloc
modifier|&
name|__a
parameter_list|)
function_decl|;
comment|// NB: per LWG issue 42, semantics different from IS:
name|basic_string
argument_list|(
specifier|const
name|basic_string
operator|&
name|__str
argument_list|)
expr_stmt|;
name|basic_string
argument_list|(
argument|const basic_string& __str
argument_list|,
argument|size_type __pos
argument_list|,
argument|size_type __n = npos
argument_list|)
empty_stmt|;
name|basic_string
argument_list|(
argument|const basic_string& __str
argument_list|,
argument|size_type __pos
argument_list|,
argument|size_type __n
argument_list|,
argument|const _Alloc& __a
argument_list|)
empty_stmt|;
name|basic_string
argument_list|(
argument|const _CharT* __s
argument_list|,
argument|size_type __n
argument_list|,
argument|const _Alloc& __a = _Alloc()
argument_list|)
empty_stmt|;
name|basic_string
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
specifier|const
name|_Alloc
operator|&
name|__a
operator|=
name|_Alloc
argument_list|()
argument_list|)
expr_stmt|;
name|basic_string
argument_list|(
argument|size_type __n
argument_list|,
argument|_CharT __c
argument_list|,
argument|const _Alloc& __a = _Alloc()
argument_list|)
empty_stmt|;
name|template
operator|<
name|class
name|_InputIterator
operator|>
name|basic_string
argument_list|(
argument|_InputIterator __beg
argument_list|,
argument|_InputIterator __end
argument_list|,
argument|const _Alloc& __a = _Alloc()
argument_list|)
expr_stmt|;
operator|~
name|basic_string
argument_list|()
block|{
name|_M_rep
argument_list|()
operator|->
name|_M_dispose
argument_list|(
name|this
operator|->
name|get_allocator
argument_list|()
argument_list|)
block|; }
name|basic_string
operator|&
name|operator
operator|=
operator|(
specifier|const
name|basic_string
operator|&
name|__str
operator|)
block|{
return|return
name|this
operator|->
name|assign
argument_list|(
name|__str
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|operator
init|=
operator|(
specifier|const
name|_CharT
operator|*
name|__s
operator|)
block|{
return|return
name|this
operator|->
name|assign
argument_list|(
name|__s
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|operator
init|=
operator|(
name|_CharT
name|__c
operator|)
block|{
return|return
name|this
operator|->
name|assign
argument_list|(
literal|1
argument_list|,
name|__c
argument_list|)
return|;
block|}
comment|// Iterators:
name|iterator
name|begin
parameter_list|()
block|{
name|_M_leak
argument_list|()
expr_stmt|;
return|return
name|iterator
argument_list|(
name|_M_data
argument_list|()
argument_list|)
return|;
block|}
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|const_iterator
argument_list|(
name|_M_data
argument_list|()
argument_list|)
return|;
block|}
name|iterator
name|end
parameter_list|()
block|{
name|_M_leak
argument_list|()
expr_stmt|;
return|return
name|iterator
argument_list|(
name|_M_data
argument_list|()
operator|+
name|this
operator|->
name|size
argument_list|()
argument_list|)
return|;
block|}
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|const_iterator
argument_list|(
name|_M_data
argument_list|()
operator|+
name|this
operator|->
name|size
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|)
return|;
block|}
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|this
operator|->
name|begin
argument_list|()
argument_list|)
return|;
block|}
name|public
label|:
comment|// Capacity:
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|_M_rep
argument_list|()
operator|->
name|_M_length
return|;
block|}
name|size_type
name|length
argument_list|()
specifier|const
block|{
return|return
name|_M_rep
argument_list|()
operator|->
name|_M_length
return|;
block|}
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|_Rep
operator|::
name|_S_max_size
return|;
block|}
name|void
name|resize
parameter_list|(
name|size_type
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
function_decl|;
name|void
name|resize
parameter_list|(
name|size_type
name|__n
parameter_list|)
block|{
name|this
operator|->
name|resize
argument_list|(
name|__n
argument_list|,
name|_CharT
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|size_type
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|_M_rep
argument_list|()
operator|->
name|_M_capacity
return|;
block|}
name|void
name|reserve
parameter_list|(
name|size_type
name|__res_arg
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|clear
parameter_list|()
block|{
name|_M_mutate
argument_list|(
literal|0
argument_list|,
name|this
operator|->
name|size
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|// Element access:
name|const_reference
name|operator
index|[]
argument_list|(
name|size_type
name|__pos
argument_list|)
decl|const
block|{
return|return
name|_M_data
argument_list|()
index|[
name|__pos
index|]
return|;
block|}
name|reference
name|operator
function|[]
parameter_list|(
name|size_type
name|__pos
parameter_list|)
block|{
name|_M_leak
argument_list|()
expr_stmt|;
return|return
name|_M_data
argument_list|()
index|[
name|__pos
index|]
return|;
block|}
name|const_reference
name|at
argument_list|(
name|size_type
name|__n
argument_list|)
decl|const
block|{
if|if
condition|(
name|__n
operator|>=
name|this
operator|->
name|size
argument_list|()
condition|)
name|__throw_out_of_range
argument_list|(
literal|"basic_string::at"
argument_list|)
expr_stmt|;
return|return
name|_M_data
argument_list|()
index|[
name|__n
index|]
return|;
block|}
name|reference
name|at
parameter_list|(
name|size_type
name|__n
parameter_list|)
block|{
if|if
condition|(
name|__n
operator|>=
name|size
argument_list|()
condition|)
name|__throw_out_of_range
argument_list|(
literal|"basic_string::at"
argument_list|)
expr_stmt|;
name|_M_leak
argument_list|()
expr_stmt|;
return|return
name|_M_data
argument_list|()
index|[
name|__n
index|]
return|;
block|}
comment|// Modifiers:
name|basic_string
operator|&
name|operator
operator|+=
operator|(
specifier|const
name|basic_string
operator|&
name|__str
operator|)
block|{
return|return
name|this
operator|->
name|append
argument_list|(
name|__str
argument_list|)
return|;
block|}
name|basic_string
operator|&
name|operator
operator|+=
operator|(
specifier|const
name|_CharT
operator|*
name|__s
operator|)
block|{
return|return
name|this
operator|->
name|append
argument_list|(
name|__s
argument_list|)
return|;
block|}
name|basic_string
operator|&
name|operator
operator|+=
operator|(
name|_CharT
name|__c
operator|)
block|{
return|return
name|this
operator|->
name|append
argument_list|(
name|size_type
argument_list|(
literal|1
argument_list|)
argument_list|,
name|__c
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|append
parameter_list|(
specifier|const
name|basic_string
modifier|&
name|__str
parameter_list|)
function_decl|;
name|basic_string
modifier|&
name|append
parameter_list|(
specifier|const
name|basic_string
modifier|&
name|__str
parameter_list|,
name|size_type
name|__pos
parameter_list|,
name|size_type
name|__n
parameter_list|)
function_decl|;
name|basic_string
modifier|&
name|append
parameter_list|(
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|,
name|size_type
name|__n
parameter_list|)
function_decl|;
name|basic_string
modifier|&
name|append
parameter_list|(
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|)
block|{
return|return
name|this
operator|->
name|append
argument_list|(
name|__s
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|append
parameter_list|(
name|size_type
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
function_decl|;
name|template
operator|<
name|class
name|_InputIterator
operator|>
name|basic_string
operator|&
name|append
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|)
block|{
return|return
name|this
operator|->
name|replace
argument_list|(
name|_M_iend
argument_list|()
argument_list|,
name|_M_iend
argument_list|()
argument_list|,
name|__first
argument_list|,
name|__last
argument_list|)
return|;
block|}
name|void
name|push_back
parameter_list|(
name|_CharT
name|__c
parameter_list|)
block|{
name|this
operator|->
name|replace
argument_list|(
name|_M_iend
argument_list|()
argument_list|,
name|_M_iend
argument_list|()
argument_list|,
literal|1
argument_list|,
name|__c
argument_list|)
expr_stmt|;
block|}
name|basic_string
modifier|&
name|assign
parameter_list|(
specifier|const
name|basic_string
modifier|&
name|__str
parameter_list|)
function_decl|;
name|basic_string
modifier|&
name|assign
parameter_list|(
specifier|const
name|basic_string
modifier|&
name|__str
parameter_list|,
name|size_type
name|__pos
parameter_list|,
name|size_type
name|__n
parameter_list|)
block|{
specifier|const
name|size_type
name|__strsize
init|=
name|__str
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|__pos
operator|>
name|__strsize
condition|)
name|__throw_out_of_range
argument_list|(
literal|"basic_string::assign"
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|__testn
init|=
name|__n
operator|<
name|__strsize
operator|-
name|__pos
decl_stmt|;
specifier|const
name|size_type
name|__newsize
init|=
name|__testn
condition|?
name|__n
else|:
name|__strsize
operator|-
name|__pos
decl_stmt|;
return|return
name|this
operator|->
name|assign
argument_list|(
name|__str
operator|.
name|_M_data
argument_list|()
operator|+
name|__pos
argument_list|,
name|__newsize
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|assign
parameter_list|(
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|,
name|size_type
name|__n
parameter_list|)
block|{
if|if
condition|(
name|__n
operator|>
name|this
operator|->
name|max_size
argument_list|()
condition|)
name|__throw_length_error
argument_list|(
literal|"basic_string::assign"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_M_rep
argument_list|()
operator|->
name|_M_is_shared
argument_list|()
operator|||
name|less
operator|<
specifier|const
name|_CharT
operator|*
operator|>
operator|(
operator|)
operator|(
name|__s
operator|,
name|_M_data
argument_list|()
operator|)
operator|||
name|less
operator|<
specifier|const
name|_CharT
operator|*
operator|>
operator|(
operator|)
operator|(
name|_M_data
argument_list|()
operator|+
name|this
operator|->
name|size
argument_list|()
operator|,
name|__s
operator|)
condition|)
return|return
name|_M_replace_safe
argument_list|(
name|_M_ibegin
argument_list|()
argument_list|,
name|_M_iend
argument_list|()
argument_list|,
name|__s
argument_list|,
name|__s
operator|+
name|__n
argument_list|)
return|;
else|else
block|{
comment|// Work in-place
specifier|const
name|size_type
name|__pos
init|=
name|__s
operator|-
name|_M_data
argument_list|()
decl_stmt|;
if|if
condition|(
name|__pos
operator|>=
name|__n
condition|)
name|traits_type
operator|::
name|copy
argument_list|(
name|_M_data
argument_list|()
argument_list|,
name|__s
argument_list|,
name|__n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|__pos
condition|)
name|traits_type
operator|::
name|move
argument_list|(
name|_M_data
argument_list|()
argument_list|,
name|__s
argument_list|,
name|__n
argument_list|)
expr_stmt|;
name|_M_rep
argument_list|()
operator|->
name|_M_length
operator|=
name|__n
expr_stmt|;
name|_M_data
argument_list|()
index|[
name|__n
index|]
operator|=
name|_Rep
operator|::
name|_S_terminal
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
block|}
name|basic_string
modifier|&
name|assign
parameter_list|(
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|)
block|{
return|return
name|this
operator|->
name|assign
argument_list|(
name|__s
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|assign
parameter_list|(
name|size_type
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
return|return
name|this
operator|->
name|replace
argument_list|(
name|_M_ibegin
argument_list|()
argument_list|,
name|_M_iend
argument_list|()
argument_list|,
name|__n
argument_list|,
name|__c
argument_list|)
return|;
block|}
name|template
operator|<
name|class
name|_InputIterator
operator|>
name|basic_string
operator|&
name|assign
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|)
block|{
return|return
name|this
operator|->
name|replace
argument_list|(
name|_M_ibegin
argument_list|()
argument_list|,
name|_M_iend
argument_list|()
argument_list|,
name|__first
argument_list|,
name|__last
argument_list|)
return|;
block|}
name|void
name|insert
parameter_list|(
name|iterator
name|__p
parameter_list|,
name|size_type
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|this
operator|->
name|replace
argument_list|(
name|__p
argument_list|,
name|__p
argument_list|,
name|__n
argument_list|,
name|__c
argument_list|)
expr_stmt|;
block|}
name|template
operator|<
name|class
name|_InputIterator
operator|>
name|void
name|insert
argument_list|(
argument|iterator __p
argument_list|,
argument|_InputIterator __beg
argument_list|,
argument|_InputIterator __end
argument_list|)
block|{
name|this
operator|->
name|replace
argument_list|(
name|__p
argument_list|,
name|__p
argument_list|,
name|__beg
argument_list|,
name|__end
argument_list|)
block|; }
name|basic_string
operator|&
name|insert
argument_list|(
argument|size_type __pos1
argument_list|,
argument|const basic_string& __str
argument_list|)
block|{
return|return
name|this
operator|->
name|insert
argument_list|(
name|__pos1
argument_list|,
name|__str
argument_list|,
literal|0
argument_list|,
name|__str
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|insert
parameter_list|(
name|size_type
name|__pos1
parameter_list|,
specifier|const
name|basic_string
modifier|&
name|__str
parameter_list|,
name|size_type
name|__pos2
parameter_list|,
name|size_type
name|__n
parameter_list|)
block|{
specifier|const
name|size_type
name|__strsize
init|=
name|__str
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|__pos2
operator|>
name|__strsize
condition|)
name|__throw_out_of_range
argument_list|(
literal|"basic_string::insert"
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|__testn
init|=
name|__n
operator|<
name|__strsize
operator|-
name|__pos2
decl_stmt|;
specifier|const
name|size_type
name|__newsize
init|=
name|__testn
condition|?
name|__n
else|:
name|__strsize
operator|-
name|__pos2
decl_stmt|;
return|return
name|this
operator|->
name|insert
argument_list|(
name|__pos1
argument_list|,
name|__str
operator|.
name|_M_data
argument_list|()
operator|+
name|__pos2
argument_list|,
name|__newsize
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|insert
parameter_list|(
name|size_type
name|__pos
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|,
name|size_type
name|__n
parameter_list|)
block|{
specifier|const
name|size_type
name|__size
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|__pos
operator|>
name|__size
condition|)
name|__throw_out_of_range
argument_list|(
literal|"basic_string::insert"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__size
operator|>
name|this
operator|->
name|max_size
argument_list|()
operator|-
name|__n
condition|)
name|__throw_length_error
argument_list|(
literal|"basic_string::insert"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_M_rep
argument_list|()
operator|->
name|_M_is_shared
argument_list|()
operator|||
name|less
operator|<
specifier|const
name|_CharT
operator|*
operator|>
operator|(
operator|)
operator|(
name|__s
operator|,
name|_M_data
argument_list|()
operator|)
operator|||
name|less
operator|<
specifier|const
name|_CharT
operator|*
operator|>
operator|(
operator|)
operator|(
name|_M_data
argument_list|()
operator|+
name|__size
operator|,
name|__s
operator|)
condition|)
return|return
name|_M_replace_safe
argument_list|(
name|_M_ibegin
argument_list|()
operator|+
name|__pos
argument_list|,
name|_M_ibegin
argument_list|()
operator|+
name|__pos
argument_list|,
name|__s
argument_list|,
name|__s
operator|+
name|__n
argument_list|)
return|;
else|else
block|{
comment|// Work in-place. If _M_mutate reallocates the string, __s
comment|// does not point anymore to valid data, therefore we save its
comment|// offset, then we restore it.
specifier|const
name|size_type
name|__off
init|=
name|__s
operator|-
name|_M_data
argument_list|()
decl_stmt|;
name|_M_mutate
argument_list|(
name|__pos
argument_list|,
literal|0
argument_list|,
name|__n
argument_list|)
expr_stmt|;
name|__s
operator|=
name|_M_data
argument_list|()
operator|+
name|__off
expr_stmt|;
name|_CharT
modifier|*
name|__p
init|=
name|_M_data
argument_list|()
operator|+
name|__pos
decl_stmt|;
if|if
condition|(
name|__s
operator|+
name|__n
operator|<=
name|__p
condition|)
name|traits_type
operator|::
name|copy
argument_list|(
name|__p
argument_list|,
name|__s
argument_list|,
name|__n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|__s
operator|>=
name|__p
condition|)
name|traits_type
operator|::
name|copy
argument_list|(
name|__p
argument_list|,
name|__s
operator|+
name|__n
argument_list|,
name|__n
argument_list|)
expr_stmt|;
else|else
block|{
name|traits_type
operator|::
name|copy
argument_list|(
name|__p
argument_list|,
name|__s
argument_list|,
name|__p
operator|-
name|__s
argument_list|)
expr_stmt|;
name|traits_type
operator|::
name|copy
argument_list|(
name|__p
operator|+
operator|(
name|__p
operator|-
name|__s
operator|)
argument_list|,
name|__p
operator|+
name|__n
argument_list|,
name|__n
operator|-
operator|(
name|__p
operator|-
name|__s
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
block|}
name|basic_string
modifier|&
name|insert
parameter_list|(
name|size_type
name|__pos
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|)
block|{
return|return
name|this
operator|->
name|insert
argument_list|(
name|__pos
argument_list|,
name|__s
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|insert
parameter_list|(
name|size_type
name|__pos
parameter_list|,
name|size_type
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|this
operator|->
name|insert
argument_list|(
name|_M_check
argument_list|(
name|__pos
argument_list|)
argument_list|,
name|__n
argument_list|,
name|__c
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|iterator
name|insert
parameter_list|(
name|iterator
name|__p
parameter_list|,
name|_CharT
name|__c
init|=
name|_CharT
argument_list|()
parameter_list|)
block|{
name|size_type
name|__pos
init|=
name|__p
operator|-
name|_M_ibegin
argument_list|()
decl_stmt|;
name|this
operator|->
name|insert
argument_list|(
name|_M_check
argument_list|(
name|__pos
argument_list|)
argument_list|,
name|size_type
argument_list|(
literal|1
argument_list|)
argument_list|,
name|__c
argument_list|)
expr_stmt|;
name|_M_rep
argument_list|()
operator|->
name|_M_set_leaked
argument_list|()
expr_stmt|;
return|return
name|this
operator|->
name|_M_ibegin
argument_list|()
operator|+
name|__pos
return|;
block|}
name|basic_string
modifier|&
name|erase
parameter_list|(
name|size_type
name|__pos
init|=
literal|0
parameter_list|,
name|size_type
name|__n
init|=
name|npos
parameter_list|)
block|{
return|return
name|this
operator|->
name|replace
argument_list|(
name|_M_check
argument_list|(
name|__pos
argument_list|)
argument_list|,
name|_M_fold
argument_list|(
name|__pos
argument_list|,
name|__n
argument_list|)
argument_list|,
name|_M_data
argument_list|()
argument_list|,
name|_M_data
argument_list|()
argument_list|)
return|;
block|}
name|iterator
name|erase
parameter_list|(
name|iterator
name|__position
parameter_list|)
block|{
name|size_type
name|__i
init|=
name|__position
operator|-
name|_M_ibegin
argument_list|()
decl_stmt|;
name|this
operator|->
name|replace
argument_list|(
name|__position
argument_list|,
name|__position
operator|+
literal|1
argument_list|,
name|_M_data
argument_list|()
argument_list|,
name|_M_data
argument_list|()
argument_list|)
expr_stmt|;
name|_M_rep
argument_list|()
operator|->
name|_M_set_leaked
argument_list|()
expr_stmt|;
return|return
name|_M_ibegin
argument_list|()
operator|+
name|__i
return|;
block|}
name|iterator
name|erase
parameter_list|(
name|iterator
name|__first
parameter_list|,
name|iterator
name|__last
parameter_list|)
block|{
name|size_type
name|__i
init|=
name|__first
operator|-
name|_M_ibegin
argument_list|()
decl_stmt|;
name|this
operator|->
name|replace
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|_M_data
argument_list|()
argument_list|,
name|_M_data
argument_list|()
argument_list|)
expr_stmt|;
name|_M_rep
argument_list|()
operator|->
name|_M_set_leaked
argument_list|()
expr_stmt|;
return|return
name|_M_ibegin
argument_list|()
operator|+
name|__i
return|;
block|}
name|basic_string
modifier|&
name|replace
parameter_list|(
name|size_type
name|__pos
parameter_list|,
name|size_type
name|__n
parameter_list|,
specifier|const
name|basic_string
modifier|&
name|__str
parameter_list|)
block|{
return|return
name|this
operator|->
name|replace
argument_list|(
name|__pos
argument_list|,
name|__n
argument_list|,
name|__str
operator|.
name|_M_data
argument_list|()
argument_list|,
name|__str
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|replace
parameter_list|(
name|size_type
name|__pos1
parameter_list|,
name|size_type
name|__n1
parameter_list|,
specifier|const
name|basic_string
modifier|&
name|__str
parameter_list|,
name|size_type
name|__pos2
parameter_list|,
name|size_type
name|__n2
parameter_list|)
function_decl|;
name|basic_string
modifier|&
name|replace
parameter_list|(
name|size_type
name|__pos
parameter_list|,
name|size_type
name|__n1
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|,
name|size_type
name|__n2
parameter_list|)
block|{
specifier|const
name|size_type
name|__size
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|__pos
operator|>
name|__size
condition|)
name|__throw_out_of_range
argument_list|(
literal|"basic_string::replace"
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|__testn1
init|=
name|__n1
operator|<
name|__size
operator|-
name|__pos
decl_stmt|;
specifier|const
name|size_type
name|__foldn1
init|=
name|__testn1
condition|?
name|__n1
else|:
name|__size
operator|-
name|__pos
decl_stmt|;
if|if
condition|(
name|__size
operator|-
name|__foldn1
operator|>
name|this
operator|->
name|max_size
argument_list|()
operator|-
name|__n2
condition|)
name|__throw_length_error
argument_list|(
literal|"basic_string::replace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_M_rep
argument_list|()
operator|->
name|_M_is_shared
argument_list|()
operator|||
name|less
operator|<
specifier|const
name|_CharT
operator|*
operator|>
operator|(
operator|)
operator|(
name|__s
operator|,
name|_M_data
argument_list|()
operator|)
operator|||
name|less
operator|<
specifier|const
name|_CharT
operator|*
operator|>
operator|(
operator|)
operator|(
name|_M_data
argument_list|()
operator|+
name|__size
operator|,
name|__s
operator|)
condition|)
return|return
name|_M_replace_safe
argument_list|(
name|_M_ibegin
argument_list|()
operator|+
name|__pos
argument_list|,
name|_M_ibegin
argument_list|()
operator|+
name|__pos
operator|+
name|__foldn1
argument_list|,
name|__s
argument_list|,
name|__s
operator|+
name|__n2
argument_list|)
return|;
else|else
return|return
name|this
operator|->
name|replace
argument_list|(
name|_M_check
argument_list|(
name|__pos
argument_list|)
argument_list|,
name|_M_fold
argument_list|(
name|__pos
argument_list|,
name|__n1
argument_list|)
argument_list|,
name|__s
argument_list|,
name|__s
operator|+
name|__n2
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|replace
parameter_list|(
name|size_type
name|__pos
parameter_list|,
name|size_type
name|__n1
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|)
block|{
return|return
name|this
operator|->
name|replace
argument_list|(
name|__pos
argument_list|,
name|__n1
argument_list|,
name|__s
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|replace
parameter_list|(
name|size_type
name|__pos
parameter_list|,
name|size_type
name|__n1
parameter_list|,
name|size_type
name|__n2
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
return|return
name|this
operator|->
name|replace
argument_list|(
name|_M_check
argument_list|(
name|__pos
argument_list|)
argument_list|,
name|_M_fold
argument_list|(
name|__pos
argument_list|,
name|__n1
argument_list|)
argument_list|,
name|__n2
argument_list|,
name|__c
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|replace
parameter_list|(
name|iterator
name|__i1
parameter_list|,
name|iterator
name|__i2
parameter_list|,
specifier|const
name|basic_string
modifier|&
name|__str
parameter_list|)
block|{
return|return
name|this
operator|->
name|replace
argument_list|(
name|__i1
argument_list|,
name|__i2
argument_list|,
name|__str
operator|.
name|_M_data
argument_list|()
argument_list|,
name|__str
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|replace
parameter_list|(
name|iterator
name|__i1
parameter_list|,
name|iterator
name|__i2
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|,
name|size_type
name|__n
parameter_list|)
block|{
return|return
name|this
operator|->
name|replace
argument_list|(
name|__i1
operator|-
name|_M_ibegin
argument_list|()
argument_list|,
name|__i2
operator|-
name|__i1
argument_list|,
name|__s
argument_list|,
name|__n
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|replace
parameter_list|(
name|iterator
name|__i1
parameter_list|,
name|iterator
name|__i2
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|)
block|{
return|return
name|this
operator|->
name|replace
argument_list|(
name|__i1
argument_list|,
name|__i2
argument_list|,
name|__s
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
name|basic_string
modifier|&
name|replace
parameter_list|(
name|iterator
name|__i1
parameter_list|,
name|iterator
name|__i2
parameter_list|,
name|size_type
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
function_decl|;
name|template
operator|<
name|class
name|_InputIterator
operator|>
name|basic_string
operator|&
name|replace
argument_list|(
argument|iterator __i1
argument_list|,
argument|iterator __i2
argument_list|,
argument|_InputIterator __k1
argument_list|,
argument|_InputIterator __k2
argument_list|)
block|{
return|return
name|_M_replace
argument_list|(
argument|__i1
argument_list|,
argument|__i2
argument_list|,
argument|__k1
argument_list|,
argument|__k2
argument_list|,
argument|typename iterator_traits<_InputIterator>::iterator_category()
argument_list|)
return|;
block|}
name|private
label|:
name|template
operator|<
name|class
name|_InputIterator
operator|>
name|basic_string
operator|&
name|_M_replace
argument_list|(
argument|iterator __i1
argument_list|,
argument|iterator __i2
argument_list|,
argument|_InputIterator __k1
argument_list|,
argument|_InputIterator __k2
argument_list|,
argument|input_iterator_tag
argument_list|)
expr_stmt|;
name|template
operator|<
name|class
name|_ForwardIterator
operator|>
name|basic_string
operator|&
name|_M_replace_safe
argument_list|(
argument|iterator __i1
argument_list|,
argument|iterator __i2
argument_list|,
argument|_ForwardIterator __k1
argument_list|,
argument|_ForwardIterator __k2
argument_list|)
expr_stmt|;
comment|// _S_construct_aux is used to implement the 21.3.1 para 15 which
comment|// requires special behaviour if _InIter is an integral type
name|template
operator|<
name|class
name|_InIter
operator|>
specifier|static
name|_CharT
operator|*
name|_S_construct_aux
argument_list|(
argument|_InIter __beg
argument_list|,
argument|_InIter __end
argument_list|,
argument|const _Alloc& __a
argument_list|,
argument|__false_type
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InIter
operator|>
operator|::
name|iterator_category
name|_Tag
expr_stmt|;
return|return
name|_S_construct
argument_list|(
name|__beg
argument_list|,
name|__end
argument_list|,
name|__a
argument_list|,
name|_Tag
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_InIter
operator|>
specifier|static
name|_CharT
operator|*
name|_S_construct_aux
argument_list|(
argument|_InIter __beg
argument_list|,
argument|_InIter __end
argument_list|,
argument|const _Alloc& __a
argument_list|,
argument|__true_type
argument_list|)
block|{
return|return
name|_S_construct
argument_list|(
name|static_cast
operator|<
name|size_type
operator|>
operator|(
name|__beg
operator|)
argument_list|,
name|static_cast
operator|<
name|value_type
operator|>
operator|(
name|__end
operator|)
argument_list|,
name|__a
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_InIter
operator|>
specifier|static
name|_CharT
operator|*
name|_S_construct
argument_list|(
argument|_InIter __beg
argument_list|,
argument|_InIter __end
argument_list|,
argument|const _Alloc& __a
argument_list|)
block|{
typedef|typedef
name|typename
name|_Is_integer
operator|<
name|_InIter
operator|>
operator|::
name|_Integral
name|_Integral
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|_S_construct_aux
argument_list|(
name|__beg
argument_list|,
name|__end
argument_list|,
name|__a
argument_list|,
name|_Integral
argument_list|()
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// For Input Iterators, used in istreambuf_iterators, etc.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_InIter
operator|>
specifier|static
name|_CharT
operator|*
name|_S_construct
argument_list|(
argument|_InIter __beg
argument_list|,
argument|_InIter __end
argument_list|,
argument|const _Alloc& __a
argument_list|,
argument|input_iterator_tag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// For forward_iterators up to random_access_iterators, used for
end_comment

begin_comment
comment|// string::iterator, _CharT*, etc.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_FwdIter
operator|>
specifier|static
name|_CharT
operator|*
name|_S_construct
argument_list|(
argument|_FwdIter __beg
argument_list|,
argument|_FwdIter __end
argument_list|,
argument|const _Alloc& __a
argument_list|,
argument|forward_iterator_tag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|_CharT
modifier|*
name|_S_construct
parameter_list|(
name|size_type
name|__req
parameter_list|,
name|_CharT
name|__c
parameter_list|,
specifier|const
name|_Alloc
modifier|&
name|__a
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|public
label|:
end_label

begin_decl_stmt
name|size_type
name|copy
argument_list|(
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__n
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|swap
argument_list|(
name|basic_string
operator|<
name|_CharT
argument_list|,
name|_Traits
argument_list|,
name|_Alloc
operator|>
operator|&
name|__s
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// String operations:
end_comment

begin_expr_stmt
specifier|const
name|_CharT
operator|*
name|c_str
argument_list|()
specifier|const
block|{
comment|// MT: This assumes concurrent writes are OK.
name|size_type
name|__n
operator|=
name|this
operator|->
name|size
argument_list|()
block|;
name|traits_type
operator|::
name|assign
argument_list|(
name|_M_data
argument_list|()
index|[
name|__n
index|]
argument_list|,
name|_Rep
operator|::
name|_S_terminal
argument_list|)
block|;
return|return
name|_M_data
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|_CharT
operator|*
name|data
argument_list|()
specifier|const
block|{
return|return
name|_M_data
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|allocator_type
name|get_allocator
argument_list|()
specifier|const
block|{
return|return
name|_M_dataplus
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|size_type
name|find
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
argument_list|,
name|size_type
name|__n
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|find
argument_list|(
specifier|const
name|basic_string
operator|&
name|__str
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find
argument_list|(
name|__str
operator|.
name|data
argument_list|()
argument_list|,
name|__pos
argument_list|,
name|__str
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find
argument_list|(
name|__s
argument_list|,
name|__pos
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find
argument_list|(
name|_CharT
name|__c
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|rfind
argument_list|(
specifier|const
name|basic_string
operator|&
name|__str
argument_list|,
name|size_type
name|__pos
operator|=
name|npos
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|rfind
argument_list|(
name|__str
operator|.
name|data
argument_list|()
argument_list|,
name|__pos
argument_list|,
name|__str
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|rfind
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
argument_list|,
name|size_type
name|__n
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|rfind
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
operator|=
name|npos
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|rfind
argument_list|(
name|__s
argument_list|,
name|__pos
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|rfind
argument_list|(
name|_CharT
name|__c
argument_list|,
name|size_type
name|__pos
operator|=
name|npos
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_first_of
argument_list|(
specifier|const
name|basic_string
operator|&
name|__str
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find_first_of
argument_list|(
name|__str
operator|.
name|data
argument_list|()
argument_list|,
name|__pos
argument_list|,
name|__str
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_first_of
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
argument_list|,
name|size_type
name|__n
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_first_of
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find_first_of
argument_list|(
name|__s
argument_list|,
name|__pos
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_first_of
argument_list|(
name|_CharT
name|__c
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find
argument_list|(
name|__c
argument_list|,
name|__pos
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_last_of
argument_list|(
specifier|const
name|basic_string
operator|&
name|__str
argument_list|,
name|size_type
name|__pos
operator|=
name|npos
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find_last_of
argument_list|(
name|__str
operator|.
name|data
argument_list|()
argument_list|,
name|__pos
argument_list|,
name|__str
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_last_of
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
argument_list|,
name|size_type
name|__n
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_last_of
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
operator|=
name|npos
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find_last_of
argument_list|(
name|__s
argument_list|,
name|__pos
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_last_of
argument_list|(
name|_CharT
name|__c
argument_list|,
name|size_type
name|__pos
operator|=
name|npos
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|rfind
argument_list|(
name|__c
argument_list|,
name|__pos
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_first_not_of
argument_list|(
specifier|const
name|basic_string
operator|&
name|__str
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find_first_not_of
argument_list|(
name|__str
operator|.
name|data
argument_list|()
argument_list|,
name|__pos
argument_list|,
name|__str
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_first_not_of
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
argument_list|,
name|size_type
name|__n
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_first_not_of
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find_first_not_of
argument_list|(
name|__s
argument_list|,
name|__pos
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_first_not_of
argument_list|(
name|_CharT
name|__c
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_last_not_of
argument_list|(
specifier|const
name|basic_string
operator|&
name|__str
argument_list|,
name|size_type
name|__pos
operator|=
name|npos
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find_last_not_of
argument_list|(
name|__str
operator|.
name|data
argument_list|()
argument_list|,
name|__pos
argument_list|,
name|__str
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_last_not_of
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
argument_list|,
name|size_type
name|__n
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_last_not_of
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
operator|=
name|npos
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|find_last_not_of
argument_list|(
name|__s
argument_list|,
name|__pos
argument_list|,
name|traits_type
operator|::
name|length
argument_list|(
name|__s
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|find_last_not_of
argument_list|(
name|_CharT
name|__c
argument_list|,
name|size_type
name|__pos
operator|=
name|npos
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|basic_string
name|substr
argument_list|(
name|size_type
name|__pos
operator|=
literal|0
argument_list|,
name|size_type
name|__n
operator|=
name|npos
argument_list|)
decl|const
block|{
if|if
condition|(
name|__pos
operator|>
name|this
operator|->
name|size
argument_list|()
condition|)
name|__throw_out_of_range
argument_list|(
literal|"basic_string::substr"
argument_list|)
expr_stmt|;
return|return
name|basic_string
argument_list|(
operator|*
name|this
argument_list|,
name|__pos
argument_list|,
name|__n
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|compare
argument_list|(
specifier|const
name|basic_string
operator|&
name|__str
argument_list|)
decl|const
block|{
name|size_type
name|__size
init|=
name|this
operator|->
name|size
argument_list|()
decl_stmt|;
name|size_type
name|__osize
init|=
name|__str
operator|.
name|size
argument_list|()
decl_stmt|;
name|size_type
name|__len
init|=
name|min
argument_list|(
name|__size
argument_list|,
name|__osize
argument_list|)
decl_stmt|;
name|int
name|__r
init|=
name|traits_type
operator|::
name|compare
argument_list|(
name|_M_data
argument_list|()
argument_list|,
name|__str
operator|.
name|data
argument_list|()
argument_list|,
name|__len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|__r
condition|)
name|__r
operator|=
name|__size
operator|-
name|__osize
expr_stmt|;
return|return
name|__r
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|compare
argument_list|(
name|size_type
name|__pos
argument_list|,
name|size_type
name|__n
argument_list|,
specifier|const
name|basic_string
operator|&
name|__str
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|compare
argument_list|(
name|size_type
name|__pos1
argument_list|,
name|size_type
name|__n1
argument_list|,
specifier|const
name|basic_string
operator|&
name|__str
argument_list|,
name|size_type
name|__pos2
argument_list|,
name|size_type
name|__n2
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|compare
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|// _GLIBCPP_RESOLVE_LIB_DEFECTS
end_comment

begin_comment
comment|// 5. String::compare specification questionable
end_comment

begin_decl_stmt
name|int
name|compare
argument_list|(
name|size_type
name|__pos
argument_list|,
name|size_type
name|__n1
argument_list|,
specifier|const
name|_CharT
operator|*
name|__s
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|compare
argument_list|(
name|size_type
name|__pos
argument_list|,
name|size_type
name|__n1
argument_list|,
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__n2
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|::
name|basic_string
argument_list|()
operator|:
name|_M_dataplus
argument_list|(
argument|_S_empty_rep()._M_refcopy()
argument_list|,
argument|_Alloc()
argument_list|)
block|{ }
comment|// operator+
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
name|basic_string
operator|<
name|_CharT
block|,
name|_Traits
block|,
name|_Alloc
operator|>
name|__str
argument_list|(
name|__lhs
argument_list|)
block|;
name|__str
operator|.
name|append
argument_list|(
name|__rhs
argument_list|)
block|;
return|return
name|__str
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|_CharT
operator|*
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
name|_CharT
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|_CharT
operator|*
name|__rhs
operator|)
block|{
name|basic_string
operator|<
name|_CharT
block|,
name|_Traits
block|,
name|_Alloc
operator|>
name|__str
argument_list|(
name|__lhs
argument_list|)
block|;
name|__str
operator|.
name|append
argument_list|(
name|__rhs
argument_list|)
block|;
return|return
name|__str
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
name|_CharT
name|__rhs
operator|)
block|{
typedef|typedef
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
name|__string_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|__string_type
operator|::
name|size_type
name|__size_type
expr_stmt|;
end_typedef

begin_function_decl
name|__string_type
name|__str
parameter_list|(
name|__lhs
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|__str
operator|.
name|append
argument_list|(
name|__size_type
argument_list|(
literal|1
argument_list|)
argument_list|,
name|__rhs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__str
return|;
end_return

begin_comment
unit|}
comment|// operator ==
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_CharT
operator|*
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__rhs
operator|.
name|compare
argument_list|(
name|__lhs
argument_list|)
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|_CharT
operator|*
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|// operator !=
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__rhs
operator|.
name|compare
argument_list|(
name|__lhs
argument_list|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|_CharT
operator|*
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__rhs
operator|.
name|compare
argument_list|(
name|__lhs
argument_list|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|_CharT
operator|*
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|// operator<
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|<
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|_CharT
operator|*
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|<
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|_CharT
operator|*
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__rhs
operator|.
name|compare
argument_list|(
name|__lhs
argument_list|)
operator|>
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|// operator>
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|>
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|>
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|>
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|_CharT
operator|*
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|>
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|>
operator|(
specifier|const
name|_CharT
operator|*
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__rhs
operator|.
name|compare
argument_list|(
name|__lhs
argument_list|)
operator|<
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|// operator<=
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|<=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|_CharT
operator|*
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|<=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|_CharT
operator|*
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__rhs
operator|.
name|compare
argument_list|(
name|__lhs
argument_list|)
operator|>=
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|// operator>=
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|>=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__lhs
operator|,
specifier|const
name|_CharT
operator|*
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|compare
argument_list|(
name|__rhs
argument_list|)
operator|>=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|_CharT
operator|*
name|__lhs
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__rhs
operator|.
name|compare
argument_list|(
name|__lhs
argument_list|)
operator|<=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|basic_string<_CharT
argument_list|,
argument|_Traits
argument_list|,
argument|_Alloc>& __lhs
argument_list|,
argument|basic_string<_CharT
argument_list|,
argument|_Traits
argument_list|,
argument|_Alloc>& __rhs
argument_list|)
block|{
name|__lhs
operator|.
name|swap
argument_list|(
name|__rhs
argument_list|)
block|; }
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
name|basic_istream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|&
name|operator
operator|>>
operator|(
name|basic_istream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|&
name|__is
operator|,
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__str
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
name|basic_ostream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|&
name|operator
operator|<<
operator|(
name|basic_ostream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|&
name|__os
operator|,
specifier|const
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
operator|&
name|__str
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
name|basic_istream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|&
name|getline
argument_list|(
argument|basic_istream<_CharT
argument_list|,
argument|_Traits>& __is
argument_list|,
argument|basic_string<_CharT
argument_list|,
argument|_Traits
argument_list|,
argument|_Alloc>& __str
argument_list|,
argument|_CharT __delim
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_CharT
operator|,
name|typename
name|_Traits
operator|,
name|typename
name|_Alloc
operator|>
specifier|inline
name|basic_istream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|&
name|getline
argument_list|(
name|basic_istream
operator|<
name|_CharT
argument_list|,
name|_Traits
operator|>
operator|&
name|__is
argument_list|,
name|basic_string
operator|<
name|_CharT
argument_list|,
name|_Traits
argument_list|,
name|_Alloc
operator|>
operator|&
name|__str
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// namespace std
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _CPP_BITS_STRING_H */
end_comment

end_unit

