begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// Bitmapped Allocator. -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2004 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|_BITMAP_ALLOCATOR_H
end_if

begin_define
define|#
directive|define
name|_BITMAP_ALLOCATOR_H
value|1
end_define

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_comment
comment|//For std::size_t, and ptrdiff_t.
end_comment

begin_include
include|#
directive|include
file|<utility>
end_include

begin_comment
comment|//For std::pair.
end_comment

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_comment
comment|//std::find_if, and std::lower_bound.
end_comment

begin_include
include|#
directive|include
file|<vector>
end_include

begin_comment
comment|//For the free list of exponentially growing memory blocks. At max,
end_comment

begin_comment
comment|//size of the vector should be  not more than the number of bits in an
end_comment

begin_comment
comment|//integer or an unsigned integer.
end_comment

begin_include
include|#
directive|include
file|<functional>
end_include

begin_comment
comment|//For greater_equal, and less_equal.
end_comment

begin_include
include|#
directive|include
file|<new>
end_include

begin_comment
comment|//For operator new.
end_comment

begin_include
include|#
directive|include
file|<bits/gthr.h>
end_include

begin_comment
comment|//For __gthread_mutex_t, __gthread_mutex_lock and __gthread_mutex_unlock.
end_comment

begin_include
include|#
directive|include
file|<ext/new_allocator.h>
end_include

begin_comment
comment|//For __gnu_cxx::new_allocator for std::vector.
end_comment

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_define
define|#
directive|define
name|NDEBUG
end_define

begin_comment
comment|//#define CHECK_FOR_ERRORS
end_comment

begin_comment
comment|//#define __CPU_HAS_BACKWARD_BRANCH_PREDICTION
end_comment

begin_decl_stmt
name|namespace
name|__gnu_cxx
block|{
name|namespace
block|{
if|#
directive|if
name|defined
name|__GTHREADS
name|bool
specifier|const
name|__threads_enabled
init|=
name|__gthread_active_p
argument_list|()
decl_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
name|__GTHREADS
name|class
name|_Mutex
block|{
name|__gthread_mutex_t
name|_M_mut
decl_stmt|;
comment|//Prevent Copying and assignment.
name|_Mutex
argument_list|(
name|_Mutex
specifier|const
operator|&
argument_list|)
expr_stmt|;
name|_Mutex
modifier|&
name|operator
init|=
operator|(
name|_Mutex
specifier|const
operator|&
operator|)
decl_stmt|;
name|public
label|:
name|_Mutex
argument_list|()
block|{
if|if
condition|(
name|__threads_enabled
condition|)
block|{
if|#
directive|if
operator|!
name|defined
name|__GTHREAD_MUTEX_INIT
name|__GTHREAD_MUTEX_INIT_FUNCTION
argument_list|(
operator|&
name|_M_mut
argument_list|)
expr_stmt|;
else|#
directive|else
name|__gthread_mutex_t
name|__mtemp
init|=
name|__GTHREAD_MUTEX_INIT
decl_stmt|;
name|_M_mut
operator|=
name|__mtemp
expr_stmt|;
endif|#
directive|endif
block|}
block|}
operator|~
name|_Mutex
argument_list|()
block|{
comment|//Gthreads does not define a Mutex Destruction Function.
block|}
name|__gthread_mutex_t
operator|*
name|_M_get
argument_list|()
block|{
return|return
operator|&
name|_M_mut
return|;
block|}
block|}
empty_stmt|;
name|class
name|_Lock
block|{
name|_Mutex
modifier|*
name|_M_pmt
decl_stmt|;
name|bool
name|_M_locked
decl_stmt|;
comment|//Prevent Copying and assignment.
name|_Lock
argument_list|(
name|_Lock
specifier|const
operator|&
argument_list|)
expr_stmt|;
name|_Lock
modifier|&
name|operator
init|=
operator|(
name|_Lock
specifier|const
operator|&
operator|)
decl_stmt|;
name|public
label|:
name|_Lock
argument_list|(
name|_Mutex
operator|*
name|__mptr
argument_list|)
operator|:
name|_M_pmt
argument_list|(
name|__mptr
argument_list|)
operator|,
name|_M_locked
argument_list|(
argument|false
argument_list|)
block|{
name|this
operator|->
name|_M_lock
argument_list|()
block|; }
name|void
name|_M_lock
argument_list|()
block|{
if|if
condition|(
name|__threads_enabled
condition|)
block|{
name|_M_locked
operator|=
name|true
expr_stmt|;
name|__gthread_mutex_lock
argument_list|(
name|_M_pmt
operator|->
name|_M_get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|_M_unlock
argument_list|()
block|{
if|if
condition|(
name|__threads_enabled
condition|)
block|{
if|if
condition|(
name|__builtin_expect
argument_list|(
name|_M_locked
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|__gthread_mutex_unlock
argument_list|(
name|_M_pmt
operator|->
name|_M_get
argument_list|()
argument_list|)
expr_stmt|;
name|_M_locked
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
operator|~
name|_Lock
argument_list|()
block|{
name|this
operator|->
name|_M_unlock
argument_list|()
block|; }
block|}
empty_stmt|;
endif|#
directive|endif
name|namespace
name|__aux_balloc
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|_Bits_Per_Byte
init|=
literal|8
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|_Bits_Per_Block
init|=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|*
name|_Bits_Per_Byte
decl_stmt|;
name|template
operator|<
name|typename
name|_Addr_Pair_t
operator|>
specifier|inline
name|size_t
name|__balloc_num_blocks
argument_list|(
argument|_Addr_Pair_t __ap
argument_list|)
block|{
return|return
operator|(
name|__ap
operator|.
name|second
operator|-
name|__ap
operator|.
name|first
operator|)
operator|+
literal|1
return|;
block|}
name|template
operator|<
name|typename
name|_Addr_Pair_t
operator|>
specifier|inline
name|size_t
name|__balloc_num_bit_maps
argument_list|(
argument|_Addr_Pair_t __ap
argument_list|)
block|{
return|return
name|__balloc_num_blocks
argument_list|(
name|__ap
argument_list|)
operator|/
name|_Bits_Per_Block
return|;
block|}
comment|//T should be a pointer type.
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|_Inclusive_between
operator|:
name|public
name|std
operator|::
name|unary_function
operator|<
name|typename
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
operator|,
name|bool
operator|>
block|{
typedef|typedef
name|_Tp
name|pointer
typedef|;
name|pointer
name|_M_ptr_value
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
name|_Block_pair
expr_stmt|;
name|public
label|:
name|_Inclusive_between
argument_list|(
argument|pointer __ptr
argument_list|)
block|:
name|_M_ptr_value
argument_list|(
argument|__ptr
argument_list|)
block|{ }
name|bool
name|operator
argument_list|()
operator|(
name|_Block_pair
name|__bp
operator|)
specifier|const
name|throw
argument_list|()
block|{
if|if
condition|(
name|std
operator|::
name|less_equal
operator|<
name|pointer
operator|>
operator|(
operator|)
operator|(
name|_M_ptr_value
operator|,
name|__bp
operator|.
name|second
operator|)
operator|&&
name|std
operator|::
name|greater_equal
operator|<
name|pointer
operator|>
operator|(
operator|)
operator|(
name|_M_ptr_value
operator|,
name|__bp
operator|.
name|first
operator|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
block|}
empty_stmt|;
comment|//Used to pass a Functor to functions by reference.
name|template
operator|<
name|typename
name|_Functor
operator|>
name|class
name|_Functor_Ref
operator|:
name|public
name|std
operator|::
name|unary_function
operator|<
name|typename
name|_Functor
operator|::
name|argument_type
operator|,
name|typename
name|_Functor
operator|::
name|result_type
operator|>
block|{
name|_Functor
operator|&
name|_M_fref
block|;
name|public
operator|:
typedef|typedef
name|typename
name|_Functor
operator|::
name|argument_type
name|argument_type
expr_stmt|;
typedef|typedef
name|typename
name|_Functor
operator|::
name|result_type
name|result_type
expr_stmt|;
name|_Functor_Ref
argument_list|(
name|_Functor
operator|&
name|__fref
argument_list|)
operator|:
name|_M_fref
argument_list|(
argument|__fref
argument_list|)
block|{ }
name|result_type
name|operator
argument_list|()
operator|(
name|argument_type
name|__arg
operator|)
block|{
return|return
name|_M_fref
argument_list|(
name|__arg
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//T should be a pointer type, and A is the Allocator for the vector.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Alloc
operator|>
name|class
name|_Ffit_finder
operator|:
name|public
name|std
operator|::
name|unary_function
operator|<
name|typename
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
operator|,
name|bool
operator|>
block|{
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
operator|,
name|_Alloc
operator|>
name|_BPVector
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_BPVector
operator|::
name|difference_type
name|_Counter_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
name|_Block_pair
expr_stmt|;
end_typedef

begin_decl_stmt
name|unsigned
name|int
modifier|*
name|_M_pbitmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|_M_data_offset
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|_Ffit_finder
argument_list|()
operator|:
name|_M_pbitmap
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_data_offset
argument_list|(
literal|0
argument_list|)
block|{ }
name|bool
name|operator
argument_list|()
operator|(
name|_Block_pair
name|__bp
operator|)
name|throw
argument_list|()
block|{
comment|//Set the _rover to the last unsigned integer, which is the
comment|//bitmap to the first free block. Thus, the bitmaps are in exact
comment|//reverse order of the actual memory layout. So, we count down
comment|//the bimaps, which is the same as moving up the memory.
comment|//If the used count stored at the start of the Bit Map headers
comment|//is equal to the number of Objects that the current Block can
comment|//store, then there is definitely no space for another single
comment|//object, so just return false.
name|_Counter_type
name|__diff
operator|=
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|__balloc_num_bit_maps
argument_list|(
name|__bp
argument_list|)
block|;
name|assert
argument_list|(
operator|*
operator|(
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|__bp
operator|.
name|first
operator|)
operator|-
operator|(
name|__diff
operator|+
literal|1
operator|)
operator|)
operator|<=
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|__balloc_num_blocks
argument_list|(
name|__bp
argument_list|)
argument_list|)
block|;
if|if
condition|(
operator|*
operator|(
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|__bp
operator|.
name|first
operator|)
operator|-
operator|(
name|__diff
operator|+
literal|1
operator|)
operator|)
operator|==
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|__balloc_num_blocks
argument_list|(
name|__bp
argument_list|)
condition|)
return|return
name|false
return|;
name|unsigned
name|int
operator|*
name|__rover
operator|=
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|__bp
operator|.
name|first
operator|)
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|_Counter_type
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|__diff
condition|;
operator|++
name|__i
control|)
block|{
name|_M_data_offset
operator|=
name|__i
expr_stmt|;
if|if
condition|(
operator|*
name|__rover
condition|)
block|{
name|_M_pbitmap
operator|=
name|__rover
expr_stmt|;
return|return
name|true
return|;
block|}
operator|--
name|__rover
expr_stmt|;
block|}
end_for

begin_return
return|return
name|false
return|;
end_return

begin_function
unit|}            unsigned
name|int
modifier|*
name|_M_get
parameter_list|()
block|{
return|return
name|_M_pbitmap
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|_M_offset
parameter_list|()
block|{
return|return
name|_M_data_offset
operator|*
name|_Bits_Per_Block
return|;
block|}
end_function

begin_comment
unit|};
comment|//T should be a pointer type.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Alloc
operator|>
name|class
name|_Bit_map_counter
block|{
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
operator|,
name|_Alloc
operator|>
name|_BPVector
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_BPVector
operator|::
name|size_type
name|_Index_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
name|pointer
typedef|;
end_typedef

begin_decl_stmt
name|_BPVector
modifier|&
name|_M_vbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
modifier|*
name|_M_curr_bmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
modifier|*
name|_M_last_bmap_in_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Index_type
name|_M_curr_index
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|//Use the 2nd parameter with care. Make sure that such an entry
end_comment

begin_comment
comment|//exists in the vector before passing that particular index to
end_comment

begin_comment
comment|//this ctor.
end_comment

begin_macro
name|_Bit_map_counter
argument_list|(
argument|_BPVector& Rvbp
argument_list|,
argument|int __index = -
literal|1
argument_list|)
end_macro

begin_macro
unit|:
name|_M_vbp
argument_list|(
argument|Rvbp
argument_list|)
end_macro

begin_block
block|{
name|this
operator|->
name|_M_reset
argument_list|(
name|__index
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|_M_reset
parameter_list|(
name|int
name|__index
init|=
operator|-
literal|1
parameter_list|)
function|throw
parameter_list|()
block|{
if|if
condition|(
name|__index
operator|==
operator|-
literal|1
condition|)
block|{
name|_M_curr_bmap
operator|=
literal|0
expr_stmt|;
name|_M_curr_index
operator|=
operator|(
name|_Index_type
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|_M_curr_index
operator|=
name|__index
expr_stmt|;
name|_M_curr_bmap
operator|=
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|_M_vbp
index|[
name|_M_curr_index
index|]
operator|.
name|first
operator|)
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|__index
operator|<=
operator|(
name|int
operator|)
name|_M_vbp
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_M_last_bmap_in_block
operator|=
name|_M_curr_bmap
operator|-
operator|(
operator|(
name|_M_vbp
index|[
name|_M_curr_index
index|]
operator|.
name|second
operator|-
name|_M_vbp
index|[
name|_M_curr_index
index|]
operator|.
name|first
operator|+
literal|1
operator|)
operator|/
name|_Bits_Per_Block
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//Dangerous Function! Use with extreme care. Pass to this
end_comment

begin_comment
comment|//function ONLY those values that are known to be correct,
end_comment

begin_comment
comment|//otherwise this will mess up big time.
end_comment

begin_function
name|void
name|_M_set_internal_bit_map
parameter_list|(
name|unsigned
name|int
modifier|*
name|__new_internal_marker
parameter_list|)
function|throw
parameter_list|()
block|{
name|_M_curr_bmap
operator|=
name|__new_internal_marker
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|_M_finished
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
operator|(
name|_M_curr_bmap
operator|==
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Bit_map_counter
operator|&
name|operator
operator|++
operator|(
operator|)
name|throw
argument_list|()
block|{
if|if
condition|(
name|_M_curr_bmap
operator|==
name|_M_last_bmap_in_block
condition|)
block|{
if|if
condition|(
operator|++
name|_M_curr_index
operator|==
name|_M_vbp
operator|.
name|size
argument_list|()
condition|)
block|{
name|_M_curr_bmap
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|this
operator|->
name|_M_reset
argument_list|(
name|_M_curr_index
argument_list|)
expr_stmt|;
block|}
end_else

begin_block
unit|} 	else
block|{
operator|--
name|_M_curr_bmap
expr_stmt|;
block|}
end_block

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_function
unit|}            unsigned
name|int
modifier|*
name|_M_get
parameter_list|()
block|{
return|return
name|_M_curr_bmap
return|;
block|}
end_function

begin_function
name|pointer
name|_M_base
parameter_list|()
block|{
return|return
name|_M_vbp
index|[
name|_M_curr_index
index|]
operator|.
name|first
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|_M_offset
parameter_list|()
block|{
return|return
name|_Bits_Per_Block
operator|*
operator|(
operator|(
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|this
operator|->
name|_M_base
argument_list|()
operator|)
operator|-
name|_M_curr_bmap
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|_M_where
parameter_list|()
block|{
return|return
name|_M_curr_index
return|;
block|}
end_function

begin_comment
unit|};   }
comment|//Generic Version of the bsf instruction.
end_comment

begin_decl_stmt
unit|typedef
name|unsigned
name|int
name|_Bit_map_type
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|_Bit_scan_forward
parameter_list|(
specifier|register
name|_Bit_map_type
name|__num
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
name|__builtin_ctz
argument_list|(
name|__num
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|_OOM_handler
block|{
specifier|static
name|std
operator|::
name|new_handler
name|_S_old_handler
expr_stmt|;
specifier|static
name|bool
name|_S_handled_oom
decl_stmt|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|_FL_clear_proc
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|static
name|_FL_clear_proc
name|_S_oom_fcp
decl_stmt|;
name|_OOM_handler
argument_list|(
argument|_FL_clear_proc __fcp
argument_list|)
block|{
name|_S_oom_fcp
operator|=
name|__fcp
expr_stmt|;
name|_S_old_handler
operator|=
name|std
operator|::
name|set_new_handler
argument_list|(
name|_S_handle_oom_proc
argument_list|)
expr_stmt|;
name|_S_handled_oom
operator|=
name|false
expr_stmt|;
block|}
specifier|static
name|void
name|_S_handle_oom_proc
parameter_list|()
block|{
name|_S_oom_fcp
argument_list|()
expr_stmt|;
name|std
operator|::
name|set_new_handler
argument_list|(
name|_S_old_handler
argument_list|)
expr_stmt|;
name|_S_handled_oom
operator|=
name|true
expr_stmt|;
block|}
operator|~
name|_OOM_handler
argument_list|()
block|{
if|if
condition|(
operator|!
name|_S_handled_oom
condition|)
name|std
operator|::
name|set_new_handler
argument_list|(
name|_S_old_handler
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|std
operator|::
name|new_handler
name|_OOM_handler
operator|::
name|_S_old_handler
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bool
name|_OOM_handler
operator|::
name|_S_handled_oom
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_OOM_handler
operator|::
name|_FL_clear_proc
name|_OOM_handler
operator|::
name|_S_oom_fcp
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|class
name|_BA_free_list_store
block|{
struct|struct
name|_LT_pointer_compare
block|{
name|template
operator|<
name|typename
name|_Tp
operator|>
name|bool
name|operator
argument_list|()
operator|(
name|_Tp
operator|*
name|__pt
operator|,
name|_Tp
specifier|const
operator|&
name|__crt
operator|)
specifier|const
name|throw
argument_list|()
block|{
return|return
operator|*
name|__pt
operator|<
name|__crt
return|;
block|}
block|}
struct|;
if|#
directive|if
name|defined
name|__GTHREADS
specifier|static
name|_Mutex
name|_S_bfl_mutex
decl_stmt|;
endif|#
directive|endif
specifier|static
name|std
operator|::
name|vector
operator|<
name|unsigned
name|int
operator|*
operator|>
name|_S_free_list
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|::
name|iterator
name|_FLIter
expr_stmt|;
specifier|static
name|void
name|_S_validate_free_list
parameter_list|(
name|unsigned
name|int
modifier|*
name|__addr
parameter_list|)
function|throw
parameter_list|()
block|{
specifier|const
name|unsigned
name|int
name|__max_size
init|=
literal|64
decl_stmt|;
if|if
condition|(
name|_S_free_list
operator|.
name|size
argument_list|()
operator|>=
name|__max_size
condition|)
block|{
comment|//Ok, the threshold value has been reached.
comment|//We determine which block to remove from the list of free
comment|//blocks.
if|if
condition|(
operator|*
name|__addr
operator|>=
operator|*
name|_S_free_list
operator|.
name|back
argument_list|()
condition|)
block|{
comment|//Ok, the new block is greater than or equal to the last
comment|//block in the list of free blocks. We just free the new
comment|//block.
name|operator
name|delete
argument_list|(
operator|(
name|void
operator|*
operator|)
name|__addr
argument_list|)
decl_stmt|;
return|return;
block|}
else|else
block|{
comment|//Deallocate the last block in the list of free lists, and
comment|//insert the new one in it's correct position.
name|operator
name|delete
argument_list|(
operator|(
name|void
operator|*
operator|)
name|_S_free_list
operator|.
name|back
argument_list|()
argument_list|)
decl_stmt|;
name|_S_free_list
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
comment|//Just add the block to the list of free lists
comment|//unconditionally.
name|_FLIter
name|__temp
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|_S_free_list
operator|.
name|begin
argument_list|()
argument_list|,
name|_S_free_list
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|__addr
argument_list|,
name|_LT_pointer_compare
argument_list|()
argument_list|)
decl_stmt|;
comment|//We may insert the new free list before _temp;
name|_S_free_list
operator|.
name|insert
argument_list|(
name|__temp
argument_list|,
name|__addr
argument_list|)
expr_stmt|;
block|}
specifier|static
name|bool
name|_S_should_i_give
parameter_list|(
name|unsigned
name|int
name|__block_size
parameter_list|,
name|unsigned
name|int
name|__required_size
parameter_list|)
function|throw
parameter_list|()
block|{
specifier|const
name|unsigned
name|int
name|__max_wastage_percentage
init|=
literal|36
decl_stmt|;
if|if
condition|(
name|__block_size
operator|>=
name|__required_size
operator|&&
operator|(
operator|(
operator|(
name|__block_size
operator|-
name|__required_size
operator|)
operator|*
literal|100
operator|/
name|__block_size
operator|)
operator|<
name|__max_wastage_percentage
operator|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
name|public
label|:
typedef|typedef
name|_BA_free_list_store
name|_BFL_type
typedef|;
specifier|static
specifier|inline
name|void
name|_S_insert_free_list
parameter_list|(
name|unsigned
name|int
modifier|*
name|__addr
parameter_list|)
function|throw
parameter_list|()
block|{
if|#
directive|if
name|defined
name|__GTHREADS
name|_Lock
name|__bfl_lock
argument_list|(
operator|&
name|_S_bfl_mutex
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|//Call _S_validate_free_list to decide what should be done with this
comment|//particular free list.
name|_S_validate_free_list
argument_list|(
operator|--
name|__addr
argument_list|)
expr_stmt|;
block|}
specifier|static
name|unsigned
name|int
modifier|*
name|_S_get_free_list
parameter_list|(
name|unsigned
name|int
name|__sz
parameter_list|)
function|throw
parameter_list|(
function|std::bad_alloc
block|)
block|{
if|#
directive|if
name|defined
name|__GTHREADS
name|_Lock
name|__bfl_lock
argument_list|(
operator|&
name|_S_bfl_mutex
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|_FLIter
name|__temp
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|_S_free_list
operator|.
name|begin
argument_list|()
argument_list|,
name|_S_free_list
operator|.
name|end
argument_list|()
argument_list|,
name|__sz
argument_list|,
name|_LT_pointer_compare
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|__temp
operator|==
name|_S_free_list
operator|.
name|end
argument_list|()
operator|||
operator|!
name|_S_should_i_give
argument_list|(
operator|*
operator|*
name|__temp
argument_list|,
name|__sz
argument_list|)
condition|)
block|{
comment|//We hold the lock because the OOM_Handler is a stateless
comment|//entity.
name|_OOM_handler
name|__set_handler
argument_list|(
name|_BFL_type
operator|::
name|_S_clear
argument_list|)
decl_stmt|;
name|unsigned
name|int
modifier|*
name|__ret_val
init|=
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|operator
name|new
argument_list|(
name|__sz
operator|+
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
operator|)
decl_stmt|;
operator|*
name|__ret_val
operator|=
name|__sz
expr_stmt|;
return|return
operator|++
name|__ret_val
return|;
block|}
else|else
block|{
name|unsigned
name|int
modifier|*
name|__ret_val
init|=
operator|*
name|__temp
decl_stmt|;
name|_S_free_list
operator|.
name|erase
argument_list|(
name|__temp
argument_list|)
expr_stmt|;
return|return
operator|++
name|__ret_val
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|//This function just clears the internal Free List, and gives back
end_comment

begin_comment
comment|//all the memory to the OS.
end_comment

begin_function
specifier|static
name|void
name|_S_clear
parameter_list|()
block|{
if|#
directive|if
name|defined
name|__GTHREADS
name|_Lock
name|__bfl_lock
argument_list|(
operator|&
name|_S_bfl_mutex
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|_FLIter
name|__iter
init|=
name|_S_free_list
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|__iter
operator|!=
name|_S_free_list
operator|.
name|end
argument_list|()
condition|)
block|{
name|operator
name|delete
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|__iter
argument_list|)
decl_stmt|;
operator|++
name|__iter
expr_stmt|;
block|}
name|_S_free_list
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
unit|};
if|#
directive|if
name|defined
name|__GTHREADS
end_if

begin_expr_stmt
name|_Mutex
name|_BA_free_list_store
operator|::
name|_S_bfl_mutex
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|unsigned
name|int
operator|*
operator|>
name|_BA_free_list_store
operator|::
name|_S_free_list
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|bitmap_allocator
expr_stmt|;
end_expr_stmt

begin_comment
comment|// specialize for void:
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|bitmap_allocator
operator|<
name|void
operator|>
block|{
name|public
operator|:
typedef|typedef
name|void
modifier|*
name|pointer
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
specifier|const
name|void
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_comment
comment|//  reference-to-void members are impossible.
end_comment

begin_typedef
typedef|typedef
name|void
name|value_type
typedef|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|bitmap_allocator
operator|<
name|_Tp1
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|bitmap_allocator
operator|:
name|private
name|_BA_free_list_store
block|{
name|public
operator|:
typedef|typedef
name|size_t
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_Tp
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_Tp
modifier|&
name|const_reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
name|value_type
typedef|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|bitmap_allocator
operator|<
name|_Tp1
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|_Bits_Per_Byte
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|_Bits_Per_Block
init|=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|*
name|_Bits_Per_Byte
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|_S_bit_allocate
parameter_list|(
name|unsigned
name|int
modifier|*
name|__pbmap
parameter_list|,
name|unsigned
name|int
name|__pos
parameter_list|)
function|throw
parameter_list|()
block|{
name|unsigned
name|int
name|__mask
init|=
literal|1
operator|<<
name|__pos
decl_stmt|;
name|__mask
operator|=
operator|~
name|__mask
expr_stmt|;
operator|*
name|__pbmap
operator|&=
name|__mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|_S_bit_free
parameter_list|(
name|unsigned
name|int
modifier|*
name|__pbmap
parameter_list|,
name|unsigned
name|int
name|__pos
parameter_list|)
function|throw
parameter_list|()
block|{
name|unsigned
name|int
name|__mask
init|=
literal|1
operator|<<
name|__pos
decl_stmt|;
operator|*
name|__pbmap
operator||=
name|__mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|_S_memory_get
parameter_list|(
name|size_t
name|__sz
parameter_list|)
function|throw
parameter_list|(
function|std::bad_alloc
end_function

begin_block
unit|)
block|{
return|return
name|operator
name|new
argument_list|(
name|__sz
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
specifier|inline
name|void
name|_S_memory_put
parameter_list|(
name|void
modifier|*
name|__vptr
parameter_list|)
function|throw
parameter_list|()
block|{
name|operator
name|delete
argument_list|(
name|__vptr
argument_list|)
decl_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|pair
operator|<
name|pointer
operator|,
name|pointer
operator|>
name|_Block_pair
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|__gnu_cxx
operator|::
name|new_allocator
operator|<
name|_Block_pair
operator|>
name|_BPVec_allocator_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|_Block_pair
operator|,
name|_BPVec_allocator_type
operator|>
name|_BPVector
expr_stmt|;
end_typedef

begin_if
if|#
directive|if
name|defined
name|CHECK_FOR_ERRORS
end_if

begin_comment
comment|//Complexity: O(lg(N)). Where, N is the number of block of size
end_comment

begin_comment
comment|//sizeof(value_type).
end_comment

begin_function
specifier|static
name|void
name|_S_check_for_free_blocks
parameter_list|()
function|throw
parameter_list|()
block|{
typedef|typedef
name|typename
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|_Ffit_finder
operator|<
name|pointer
operator|,
name|_BPVec_allocator_type
operator|>
name|_FFF
expr_stmt|;
name|_FFF
name|__fff
decl_stmt|;
typedef|typedef
name|typename
name|_BPVector
operator|::
name|iterator
name|_BPiter
expr_stmt|;
name|_BPiter
name|__bpi
init|=
name|std
operator|::
name|find_if
argument_list|(
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
argument_list|,
name|_S_mem_blocks
operator|.
name|end
argument_list|()
argument_list|,
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|_Functor_Ref
operator|<
name|_FFF
operator|>
operator|(
name|__fff
operator|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|__bpi
operator|==
name|_S_mem_blocks
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//Complexity: O(1), but internally depends upon the complexity of
end_comment

begin_comment
comment|//the function _BA_free_list_store::_S_get_free_list. The part
end_comment

begin_comment
comment|//where the bitmap headers are written is of worst case complexity:
end_comment

begin_comment
comment|//O(X),where X is the number of blocks of size sizeof(value_type)
end_comment

begin_comment
comment|//within the newly acquired block. Having a tight bound.
end_comment

begin_function
specifier|static
name|void
name|_S_refill_pool
parameter_list|()
function|throw
parameter_list|(
function|std::bad_alloc
end_function

begin_block
unit|)
block|{
if|#
directive|if
name|defined
name|CHECK_FOR_ERRORS
name|_S_check_for_free_blocks
argument_list|()
expr_stmt|;
endif|#
directive|endif
specifier|const
name|unsigned
name|int
name|__num_bit_maps
init|=
name|_S_block_size
operator|/
name|_Bits_Per_Block
decl_stmt|;
specifier|const
name|unsigned
name|int
name|__size_to_allocate
init|=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|+
name|_S_block_size
operator|*
sizeof|sizeof
argument_list|(
name|value_type
argument_list|)
operator|+
name|__num_bit_maps
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
decl_stmt|;
name|unsigned
name|int
modifier|*
name|__temp
init|=
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|_BA_free_list_store
operator|::
name|_S_get_free_list
argument_list|(
name|__size_to_allocate
argument_list|)
operator|)
decl_stmt|;
operator|*
name|__temp
operator|=
literal|0
expr_stmt|;
operator|++
name|__temp
expr_stmt|;
comment|//The Header information goes at the Beginning of the Block.
name|_Block_pair
name|__bp
init|=
name|std
operator|::
name|make_pair
argument_list|(
name|reinterpret_cast
operator|<
name|pointer
operator|>
operator|(
name|__temp
operator|+
name|__num_bit_maps
operator|)
argument_list|,
name|reinterpret_cast
operator|<
name|pointer
operator|>
operator|(
name|__temp
operator|+
name|__num_bit_maps
operator|)
operator|+
name|_S_block_size
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|//Fill the Vector with this information.
name|_S_mem_blocks
operator|.
name|push_back
argument_list|(
name|__bp
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|__bit_mask
init|=
literal|0
decl_stmt|;
comment|//0 Indicates all Allocated.
name|__bit_mask
operator|=
operator|~
name|__bit_mask
expr_stmt|;
comment|//1 Indicates all Free.
for|for
control|(
name|unsigned
name|int
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|__num_bit_maps
condition|;
operator|++
name|__i
control|)
name|__temp
index|[
name|__i
index|]
operator|=
name|__bit_mask
expr_stmt|;
comment|//On some implementations, operator new might throw bad_alloc, or
comment|//malloc might fail if the size passed is too large, therefore, we
comment|//limit the size passed to malloc or operator new.
name|_S_block_size
operator|*=
literal|2
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|_BPVector
name|_S_mem_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|_S_block_size
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|_Bit_map_counter
operator|<
name|pointer
operator|,
name|_BPVec_allocator_type
operator|>
name|_S_last_request
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|typename
name|_BPVector
operator|::
name|size_type
name|_S_last_dealloc_index
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
name|__GTHREADS
end_if

begin_decl_stmt
specifier|static
name|_Mutex
name|_S_mut
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//Complexity: Worst case complexity is O(N), but that is hardly ever
end_comment

begin_comment
comment|//hit. if and when this particular case is encountered, the next few
end_comment

begin_comment
comment|//cases are guaranteed to have a worst case complexity of O(1)!
end_comment

begin_comment
comment|//That's why this function performs very well on the average. you
end_comment

begin_comment
comment|//can consider this function to be having a complexity refrred to
end_comment

begin_comment
comment|//commonly as: Amortized Constant time.
end_comment

begin_function
specifier|static
name|pointer
name|_S_allocate_single_object
parameter_list|()
block|{
if|#
directive|if
name|defined
name|__GTHREADS
name|_Lock
name|__bit_lock
argument_list|(
operator|&
name|_S_mut
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|//The algorithm is something like this: The last_requst variable
comment|//points to the last accessed Bit Map. When such a condition
comment|//occurs, we try to find a free block in the current bitmap, or
comment|//succeeding bitmaps until the last bitmap is reached. If no free
comment|//block turns up, we resort to First Fit method.
comment|//WARNING: Do not re-order the condition in the while statement
comment|//below, because it relies on C++'s short-circuit
comment|//evaluation. The return from _S_last_request->_M_get() will NOT
comment|//be dereferenceable if _S_last_request->_M_finished() returns
comment|//true. This would inevitibly lead to a NULL pointer dereference
comment|//if tinkered with.
while|while
condition|(
name|_S_last_request
operator|.
name|_M_finished
argument_list|()
operator|==
name|false
operator|&&
operator|(
operator|*
operator|(
name|_S_last_request
operator|.
name|_M_get
argument_list|()
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|_S_last_request
operator|.
name|operator
operator|++
operator|(
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|__builtin_expect
argument_list|(
name|_S_last_request
operator|.
name|_M_finished
argument_list|()
operator|==
name|true
argument_list|,
name|false
argument_list|)
condition|)
block|{
comment|//Fall Back to First Fit algorithm.
typedef|typedef
name|typename
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|_Ffit_finder
operator|<
name|pointer
operator|,
name|_BPVec_allocator_type
operator|>
name|_FFF
expr_stmt|;
name|_FFF
name|__fff
decl_stmt|;
typedef|typedef
name|typename
name|_BPVector
operator|::
name|iterator
name|_BPiter
expr_stmt|;
name|_BPiter
name|__bpi
init|=
name|std
operator|::
name|find_if
argument_list|(
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
argument_list|,
name|_S_mem_blocks
operator|.
name|end
argument_list|()
argument_list|,
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|_Functor_Ref
operator|<
name|_FFF
operator|>
operator|(
name|__fff
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|__bpi
operator|!=
name|_S_mem_blocks
operator|.
name|end
argument_list|()
condition|)
block|{
comment|//Search was successful. Ok, now mark the first bit from
comment|//the right as 0, meaning Allocated. This bit is obtained
comment|//by calling _M_get() on __fff.
name|unsigned
name|int
name|__nz_bit
init|=
name|_Bit_scan_forward
argument_list|(
operator|*
name|__fff
operator|.
name|_M_get
argument_list|()
argument_list|)
decl_stmt|;
name|_S_bit_allocate
argument_list|(
name|__fff
operator|.
name|_M_get
argument_list|()
argument_list|,
name|__nz_bit
argument_list|)
expr_stmt|;
name|_S_last_request
operator|.
name|_M_reset
argument_list|(
name|__bpi
operator|-
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
comment|//Now, get the address of the bit we marked as allocated.
name|pointer
name|__ret_val
init|=
name|__bpi
operator|->
name|first
operator|+
name|__fff
operator|.
name|_M_offset
argument_list|()
operator|+
name|__nz_bit
decl_stmt|;
name|unsigned
name|int
modifier|*
name|__puse_count
init|=
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|__bpi
operator|->
name|first
operator|)
operator|-
operator|(
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|__balloc_num_bit_maps
argument_list|(
operator|*
name|__bpi
argument_list|)
operator|+
literal|1
operator|)
decl_stmt|;
operator|++
operator|(
operator|*
name|__puse_count
operator|)
expr_stmt|;
return|return
name|__ret_val
return|;
block|}
else|else
block|{
comment|//Search was unsuccessful. We Add more memory to the pool
comment|//by calling _S_refill_pool().
name|_S_refill_pool
argument_list|()
expr_stmt|;
comment|//_M_Reset the _S_last_request structure to the first free
comment|//block's bit map.
name|_S_last_request
operator|.
name|_M_reset
argument_list|(
name|_S_mem_blocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//Now, mark that bit as allocated.
block|}
block|}
comment|//_S_last_request holds a pointer to a valid bit map, that points
comment|//to a free block in memory.
name|unsigned
name|int
name|__nz_bit
init|=
name|_Bit_scan_forward
argument_list|(
operator|*
name|_S_last_request
operator|.
name|_M_get
argument_list|()
argument_list|)
decl_stmt|;
name|_S_bit_allocate
argument_list|(
name|_S_last_request
operator|.
name|_M_get
argument_list|()
argument_list|,
name|__nz_bit
argument_list|)
expr_stmt|;
name|pointer
name|__ret_val
init|=
name|_S_last_request
operator|.
name|_M_base
argument_list|()
operator|+
name|_S_last_request
operator|.
name|_M_offset
argument_list|()
operator|+
name|__nz_bit
decl_stmt|;
name|unsigned
name|int
modifier|*
name|__puse_count
init|=
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|_S_mem_blocks
index|[
name|_S_last_request
operator|.
name|_M_where
argument_list|()
index|]
operator|.
name|first
operator|)
operator|-
operator|(
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|__balloc_num_bit_maps
argument_list|(
name|_S_mem_blocks
index|[
name|_S_last_request
operator|.
name|_M_where
argument_list|()
index|]
argument_list|)
operator|+
literal|1
operator|)
decl_stmt|;
operator|++
operator|(
operator|*
name|__puse_count
operator|)
expr_stmt|;
return|return
name|__ret_val
return|;
block|}
end_function

begin_comment
comment|//Complexity: O(lg(N)), but the worst case is hit quite often! I
end_comment

begin_comment
comment|//need to do something about this. I'll be able to work on it, only
end_comment

begin_comment
comment|//when I have some solid figures from a few real apps.
end_comment

begin_function
specifier|static
name|void
name|_S_deallocate_single_object
parameter_list|(
name|pointer
name|__p
parameter_list|)
function|throw
parameter_list|()
block|{
if|#
directive|if
name|defined
name|__GTHREADS
name|_Lock
name|__bit_lock
argument_list|(
operator|&
name|_S_mut
argument_list|)
decl_stmt|;
endif|#
directive|endif
typedef|typedef
name|typename
name|_BPVector
operator|::
name|iterator
name|_Iterator
expr_stmt|;
typedef|typedef
name|typename
name|_BPVector
operator|::
name|difference_type
name|_Difference_type
expr_stmt|;
name|_Difference_type
name|__diff
decl_stmt|;
name|int
name|__displacement
decl_stmt|;
name|assert
argument_list|(
name|_S_last_dealloc_index
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|_Inclusive_between
operator|<
name|pointer
operator|>
call|(
name|__p
call|)
argument_list|(
name|_S_mem_blocks
index|[
name|_S_last_dealloc_index
index|]
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|_S_last_dealloc_index
operator|<=
name|_S_mem_blocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//Initial Assumption was correct!
name|__diff
operator|=
name|_S_last_dealloc_index
expr_stmt|;
name|__displacement
operator|=
name|__p
operator|-
name|_S_mem_blocks
index|[
name|__diff
index|]
operator|.
name|first
expr_stmt|;
block|}
else|else
block|{
name|_Iterator
name|_iter
init|=
operator|(
name|std
operator|::
name|find_if
argument_list|(
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
argument_list|,
name|_S_mem_blocks
operator|.
name|end
argument_list|()
argument_list|,
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|_Inclusive_between
operator|<
name|pointer
operator|>
operator|(
name|__p
operator|)
argument_list|)
operator|)
decl_stmt|;
name|assert
argument_list|(
name|_iter
operator|!=
name|_S_mem_blocks
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|__diff
operator|=
name|_iter
operator|-
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
expr_stmt|;
name|__displacement
operator|=
name|__p
operator|-
name|_S_mem_blocks
index|[
name|__diff
index|]
operator|.
name|first
expr_stmt|;
name|_S_last_dealloc_index
operator|=
name|__diff
expr_stmt|;
block|}
comment|//Get the position of the iterator that has been found.
specifier|const
name|unsigned
name|int
name|__rotate
init|=
name|__displacement
operator|%
name|_Bits_Per_Block
decl_stmt|;
name|unsigned
name|int
modifier|*
name|__bit_mapC
init|=
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|_S_mem_blocks
index|[
name|__diff
index|]
operator|.
name|first
operator|)
operator|-
literal|1
decl_stmt|;
name|__bit_mapC
operator|-=
operator|(
name|__displacement
operator|/
name|_Bits_Per_Block
operator|)
expr_stmt|;
name|_S_bit_free
argument_list|(
name|__bit_mapC
argument_list|,
name|__rotate
argument_list|)
expr_stmt|;
name|unsigned
name|int
modifier|*
name|__puse_count
init|=
name|reinterpret_cast
operator|<
name|unsigned
name|int
operator|*
operator|>
operator|(
name|_S_mem_blocks
index|[
name|__diff
index|]
operator|.
name|first
operator|)
operator|-
operator|(
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|__balloc_num_bit_maps
argument_list|(
name|_S_mem_blocks
index|[
name|__diff
index|]
argument_list|)
operator|+
literal|1
operator|)
decl_stmt|;
name|assert
argument_list|(
operator|*
name|__puse_count
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|--
operator|(
operator|*
name|__puse_count
operator|)
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
operator|*
name|__puse_count
operator|==
literal|0
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|_S_block_size
operator|/=
literal|2
expr_stmt|;
comment|//We may safely remove this block.
name|_Block_pair
name|__bp
init|=
name|_S_mem_blocks
index|[
name|__diff
index|]
decl_stmt|;
name|_S_insert_free_list
argument_list|(
name|__puse_count
argument_list|)
expr_stmt|;
name|_S_mem_blocks
operator|.
name|erase
argument_list|(
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
operator|+
name|__diff
argument_list|)
expr_stmt|;
comment|//We reset the _S_last_request variable to reflect the erased
comment|//block. We do this to protect future requests after the last
comment|//block has been removed from a particular memory Chunk,
comment|//which in turn has been returned to the free list, and
comment|//hence had been erased from the vector, so the size of the
comment|//vector gets reduced by 1.
if|if
condition|(
operator|(
name|_Difference_type
operator|)
name|_S_last_request
operator|.
name|_M_where
argument_list|()
operator|>=
name|__diff
operator|--
condition|)
block|{
name|_S_last_request
operator|.
name|_M_reset
argument_list|(
name|__diff
argument_list|)
expr_stmt|;
comment|//	      assert(__diff>= 0);
block|}
comment|//If the Index into the vector of the region of memory that
comment|//might hold the next address that will be passed to
comment|//deallocated may have been invalidated due to the above
comment|//erase procedure being called on the vector, hence we try
comment|//to restore this invariant too.
if|if
condition|(
name|_S_last_dealloc_index
operator|>=
name|_S_mem_blocks
operator|.
name|size
argument_list|()
condition|)
block|{
name|_S_last_dealloc_index
operator|=
operator|(
name|__diff
operator|!=
operator|-
literal|1
condition|?
name|__diff
else|:
literal|0
operator|)
expr_stmt|;
name|assert
argument_list|(
name|_S_last_dealloc_index
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_label
name|public
label|:
end_label

begin_macro
name|bitmap_allocator
argument_list|()
end_macro

begin_macro
name|throw
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_macro
name|bitmap_allocator
argument_list|(
argument|const bitmap_allocator&
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|bitmap_allocator
argument_list|(
argument|const bitmap_allocator<_Tp1>&
argument_list|)
name|throw
argument_list|()
block|{ }
operator|~
name|bitmap_allocator
argument_list|()
name|throw
argument_list|()
block|{ }
comment|//Complexity: O(1), but internally the complexity depends upon the
comment|//complexity of the function(s) _S_allocate_single_object and
comment|//_S_memory_get.
name|pointer
name|allocate
argument_list|(
argument|size_type __n
argument_list|)
block|{
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__n
operator|==
literal|1
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|_S_allocate_single_object
argument_list|()
return|;
else|else
return|return
name|reinterpret_cast
operator|<
name|pointer
operator|>
operator|(
name|_S_memory_get
argument_list|(
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|value_type
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//Complexity: Worst case complexity is O(N) where N is the number of
end_comment

begin_comment
comment|//blocks of size sizeof(value_type) within the free lists that the
end_comment

begin_comment
comment|//allocator holds. However, this worst case is hit only when the
end_comment

begin_comment
comment|//user supplies a bogus argument to hint. If the hint argument is
end_comment

begin_comment
comment|//sensible, then the complexity drops to O(lg(N)), and in extreme
end_comment

begin_comment
comment|//cases, even drops to as low as O(1). So, if the user supplied
end_comment

begin_comment
comment|//argument is good, then this function performs very well.
end_comment

begin_decl_stmt
name|pointer
name|allocate
argument_list|(
name|size_type
name|__n
argument_list|,
name|typename
name|bitmap_allocator
operator|<
name|void
operator|>
operator|::
name|const_pointer
argument_list|)
block|{
return|return
name|allocate
argument_list|(
name|__n
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|void
name|deallocate
parameter_list|(
name|pointer
name|__p
parameter_list|,
name|size_type
name|__n
parameter_list|)
function|throw
parameter_list|()
block|{
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__n
operator|==
literal|1
argument_list|,
name|true
argument_list|)
condition|)
name|_S_deallocate_single_object
argument_list|(
name|__p
argument_list|)
expr_stmt|;
else|else
name|_S_memory_put
argument_list|(
name|__p
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|pointer
name|address
argument_list|(
name|reference
name|r
argument_list|)
decl|const
block|{
return|return
operator|&
name|r
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|const_pointer
name|address
argument_list|(
name|const_reference
name|r
argument_list|)
decl|const
block|{
return|return
operator|&
name|r
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|size_type
name|max_size
argument_list|(
name|void
argument_list|)
decl|const
name|throw
argument_list|()
block|{
return|return
operator|(
name|size_type
argument_list|()
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|value_type
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|void
name|construct
parameter_list|(
name|pointer
name|p
parameter_list|,
name|const_reference
name|__data
parameter_list|)
block|{
operator|::
name|new
argument_list|(
argument|p
argument_list|)
name|value_type
argument_list|(
name|__data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|destroy
parameter_list|(
name|pointer
name|p
parameter_list|)
block|{
name|p
operator|->
expr|~
name|value_type
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp
operator|>
name|typename
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_BPVector
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_S_mem_blocks
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|unsigned
name|int
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_S_block_size
operator|=
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_Bits_Per_Block
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|typename
name|__gnu_cxx
operator|::
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_BPVector
operator|::
name|size_type
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_S_last_dealloc_index
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|__gnu_cxx
operator|::
name|__aux_balloc
operator|::
name|_Bit_map_counter
operator|<
name|typename
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|pointer
operator|,
name|typename
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_BPVec_allocator_type
operator|>
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_S_last_request
argument_list|(
name|_S_mem_blocks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
name|__GTHREADS
end_if

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|__gnu_cxx
operator|::
name|_Mutex
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_S_mut
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|typename
name|_Tp2
operator|>
name|bool
name|operator
operator|==
operator|(
specifier|const
name|bitmap_allocator
operator|<
name|_Tp1
operator|>
operator|&
operator|,
specifier|const
name|bitmap_allocator
operator|<
name|_Tp2
operator|>
operator|&
operator|)
name|throw
argument_list|()
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|typename
name|_Tp2
operator|>
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|bitmap_allocator
operator|<
name|_Tp1
operator|>
operator|&
operator|,
specifier|const
name|bitmap_allocator
operator|<
name|_Tp2
operator|>
operator|&
operator|)
name|throw
argument_list|()
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|//_BITMAP_ALLOCATOR_H
end_comment

end_unit

