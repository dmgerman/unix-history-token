begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//<bitset> -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|/*  * Copyright (c) 1998  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/** @file bitset  *  This is a Standard C++ Library header.  You should @c #include this header  *  in your programs, rather than any of the "st[dl]_*.h" implementation files.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GLIBCPP_BITSET_H
end_ifndef

begin_define
define|#
directive|define
name|_GLIBCPP_BITSET_H
end_define

begin_pragma
pragma|#
directive|pragma
name|GCC
name|system_header
end_pragma

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_comment
comment|// for size_t
end_comment

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_comment
comment|// for memset
end_comment

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<bits/functexcept.h>
end_include

begin_comment
comment|// for invalid_argument, out_of_range,
end_comment

begin_comment
comment|// overflow_error
end_comment

begin_include
include|#
directive|include
file|<ostream>
end_include

begin_comment
comment|// for ostream (operator<<)
end_comment

begin_include
include|#
directive|include
file|<istream>
end_include

begin_comment
comment|// for istream (operator>>)
end_comment

begin_define
define|#
directive|define
name|_GLIBCPP_BITSET_BITS_PER_WORD
value|(CHAR_BIT*sizeof(unsigned long))
end_define

begin_define
define|#
directive|define
name|_GLIBCPP_BITSET_WORDS
parameter_list|(
name|__n
parameter_list|)
define|\
value|((__n)< 1 ? 1 : ((__n) + _GLIBCPP_BITSET_BITS_PER_WORD - 1)/_GLIBCPP_BITSET_BITS_PER_WORD)
end_define

begin_decl_stmt
name|namespace
name|std
block|{
specifier|extern
name|unsigned
name|char
name|_S_bit_count
index|[
literal|256
index|]
decl_stmt|;
specifier|extern
name|unsigned
name|char
name|_S_first_one
index|[
literal|256
index|]
decl_stmt|;
comment|/**    *  @if maint    *  Base class, general case.  It is a class inveriant that _Nw will be    *  nonnegative.    *    *  See documentation for bitset.    *  @endif   */
name|template
operator|<
name|size_t
name|_Nw
operator|>
expr|struct
name|_Base_bitset
block|{
typedef|typedef
name|unsigned
name|long
name|_WordT
typedef|;
comment|/// 0 is the least significant word.
name|_WordT
name|_M_w
index|[
name|_Nw
index|]
expr_stmt|;
name|_Base_bitset
argument_list|()
block|{
name|_M_do_reset
argument_list|()
expr_stmt|;
block|}
name|_Base_bitset
argument_list|(
argument|unsigned long __val
argument_list|)
block|{
name|_M_do_reset
argument_list|()
expr_stmt|;
name|_M_w
index|[
literal|0
index|]
operator|=
name|__val
expr_stmt|;
block|}
specifier|static
name|size_t
name|_S_whichword
parameter_list|(
name|size_t
name|__pos
parameter_list|)
block|{
return|return
name|__pos
operator|/
name|_GLIBCPP_BITSET_BITS_PER_WORD
return|;
block|}
specifier|static
name|size_t
name|_S_whichbyte
parameter_list|(
name|size_t
name|__pos
parameter_list|)
block|{
return|return
operator|(
name|__pos
operator|%
name|_GLIBCPP_BITSET_BITS_PER_WORD
operator|)
operator|/
name|CHAR_BIT
return|;
block|}
specifier|static
name|size_t
name|_S_whichbit
parameter_list|(
name|size_t
name|__pos
parameter_list|)
block|{
return|return
name|__pos
operator|%
name|_GLIBCPP_BITSET_BITS_PER_WORD
return|;
block|}
specifier|static
name|_WordT
name|_S_maskbit
parameter_list|(
name|size_t
name|__pos
parameter_list|)
block|{
return|return
operator|(
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|1
operator|)
operator|)
operator|<<
name|_S_whichbit
argument_list|(
name|__pos
argument_list|)
return|;
block|}
name|_WordT
modifier|&
name|_M_getword
parameter_list|(
name|size_t
name|__pos
parameter_list|)
block|{
return|return
name|_M_w
index|[
name|_S_whichword
argument_list|(
name|__pos
argument_list|)
index|]
return|;
block|}
name|_WordT
name|_M_getword
argument_list|(
name|size_t
name|__pos
argument_list|)
decl|const
block|{
return|return
name|_M_w
index|[
name|_S_whichword
argument_list|(
name|__pos
argument_list|)
index|]
return|;
block|}
name|_WordT
modifier|&
name|_M_hiword
parameter_list|()
block|{
return|return
name|_M_w
index|[
name|_Nw
operator|-
literal|1
index|]
return|;
block|}
name|_WordT
name|_M_hiword
argument_list|()
specifier|const
block|{
return|return
name|_M_w
index|[
name|_Nw
operator|-
literal|1
index|]
return|;
block|}
name|void
name|_M_do_and
argument_list|(
specifier|const
name|_Base_bitset
operator|<
name|_Nw
operator|>
operator|&
name|__x
argument_list|)
block|{
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|_Nw
condition|;
name|__i
operator|++
control|)
name|_M_w
index|[
name|__i
index|]
operator|&=
name|__x
operator|.
name|_M_w
index|[
name|__i
index|]
expr_stmt|;
block|}
name|void
name|_M_do_or
argument_list|(
specifier|const
name|_Base_bitset
operator|<
name|_Nw
operator|>
operator|&
name|__x
argument_list|)
block|{
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|_Nw
condition|;
name|__i
operator|++
control|)
name|_M_w
index|[
name|__i
index|]
operator||=
name|__x
operator|.
name|_M_w
index|[
name|__i
index|]
expr_stmt|;
block|}
name|void
name|_M_do_xor
argument_list|(
specifier|const
name|_Base_bitset
operator|<
name|_Nw
operator|>
operator|&
name|__x
argument_list|)
block|{
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|_Nw
condition|;
name|__i
operator|++
control|)
name|_M_w
index|[
name|__i
index|]
operator|^=
name|__x
operator|.
name|_M_w
index|[
name|__i
index|]
expr_stmt|;
block|}
name|void
name|_M_do_left_shift
parameter_list|(
name|size_t
name|__shift
parameter_list|)
function_decl|;
name|void
name|_M_do_right_shift
parameter_list|(
name|size_t
name|__shift
parameter_list|)
function_decl|;
name|void
name|_M_do_flip
parameter_list|()
block|{
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|_Nw
condition|;
name|__i
operator|++
control|)
name|_M_w
index|[
name|__i
index|]
operator|=
operator|~
name|_M_w
index|[
name|__i
index|]
expr_stmt|;
block|}
name|void
name|_M_do_set
parameter_list|()
block|{
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|_Nw
condition|;
name|__i
operator|++
control|)
name|_M_w
index|[
name|__i
index|]
operator|=
operator|~
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|0
operator|)
expr_stmt|;
block|}
name|void
name|_M_do_reset
parameter_list|()
block|{
name|memset
argument_list|(
name|_M_w
argument_list|,
literal|0
argument_list|,
name|_Nw
operator|*
sizeof|sizeof
argument_list|(
name|_WordT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bool
name|_M_is_equal
argument_list|(
specifier|const
name|_Base_bitset
operator|<
name|_Nw
operator|>
operator|&
name|__x
argument_list|)
decl|const
block|{
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|_Nw
condition|;
operator|++
name|__i
control|)
block|{
if|if
condition|(
name|_M_w
index|[
name|__i
index|]
operator|!=
name|__x
operator|.
name|_M_w
index|[
name|__i
index|]
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
name|bool
name|_M_is_any
argument_list|()
specifier|const
block|{
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|_Nw
condition|;
name|__i
operator|++
control|)
block|{
if|if
condition|(
name|_M_w
index|[
name|__i
index|]
operator|!=
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|0
operator|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|size_t
name|_M_do_count
argument_list|()
specifier|const
block|{
name|size_t
name|__result
operator|=
literal|0
block|;
specifier|const
name|unsigned
name|char
operator|*
name|__byte_ptr
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_M_w
block|;
specifier|const
name|unsigned
name|char
operator|*
name|__end_ptr
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|_M_w
operator|+
name|_Nw
operator|)
block|;
while|while
condition|(
name|__byte_ptr
operator|<
name|__end_ptr
condition|)
block|{
name|__result
operator|+=
name|_S_bit_count
index|[
operator|*
name|__byte_ptr
index|]
expr_stmt|;
name|__byte_ptr
operator|++
expr_stmt|;
block|}
return|return
name|__result
return|;
block|}
name|unsigned
name|long
name|_M_do_to_ulong
argument_list|()
specifier|const
expr_stmt|;
comment|// find first "on" bit
name|size_t
name|_M_do_find_first
argument_list|(
name|size_t
name|__not_found
argument_list|)
decl|const
decl_stmt|;
comment|// find the next "on" bit that follows "prev"
name|size_t
name|_M_do_find_next
argument_list|(
name|size_t
name|__prev
argument_list|,
name|size_t
name|__not_found
argument_list|)
decl|const
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Definitions of non-inline functions from _Base_bitset.
end_comment

begin_expr_stmt
name|template
operator|<
name|size_t
name|_Nw
operator|>
name|void
name|_Base_bitset
operator|<
name|_Nw
operator|>
operator|::
name|_M_do_left_shift
argument_list|(
argument|size_t __shift
argument_list|)
block|{
if|if
condition|(
name|__shift
operator|!=
literal|0
condition|)
block|{
specifier|const
name|size_t
name|__wshift
init|=
name|__shift
operator|/
name|_GLIBCPP_BITSET_BITS_PER_WORD
decl_stmt|;
specifier|const
name|size_t
name|__offset
init|=
name|__shift
operator|%
name|_GLIBCPP_BITSET_BITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|__offset
operator|==
literal|0
condition|)
for|for
control|(
name|size_t
name|__n
init|=
name|_Nw
operator|-
literal|1
init|;
name|__n
operator|>=
name|__wshift
condition|;
operator|--
name|__n
control|)
name|_M_w
index|[
name|__n
index|]
operator|=
name|_M_w
index|[
name|__n
operator|-
name|__wshift
index|]
expr_stmt|;
else|else
block|{
specifier|const
name|size_t
name|__sub_offset
init|=
name|_GLIBCPP_BITSET_BITS_PER_WORD
operator|-
name|__offset
decl_stmt|;
for|for
control|(
name|size_t
name|__n
init|=
name|_Nw
operator|-
literal|1
init|;
name|__n
operator|>
name|__wshift
condition|;
operator|--
name|__n
control|)
name|_M_w
index|[
name|__n
index|]
operator|=
operator|(
name|_M_w
index|[
name|__n
operator|-
name|__wshift
index|]
operator|<<
name|__offset
operator|)
operator||
operator|(
name|_M_w
index|[
name|__n
operator|-
name|__wshift
operator|-
literal|1
index|]
operator|>>
name|__sub_offset
operator|)
expr_stmt|;
name|_M_w
index|[
name|__wshift
index|]
operator|=
name|_M_w
index|[
literal|0
index|]
operator|<<
name|__offset
expr_stmt|;
block|}
name|fill
argument_list|(
name|_M_w
operator|+
literal|0
argument_list|,
name|_M_w
operator|+
name|__wshift
argument_list|,
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|0
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     }
name|template
operator|<
name|size_t
name|_Nw
operator|>
name|void
name|_Base_bitset
operator|<
name|_Nw
operator|>
operator|::
name|_M_do_right_shift
argument_list|(
argument|size_t __shift
argument_list|)
block|{
if|if
condition|(
name|__shift
operator|!=
literal|0
condition|)
block|{
specifier|const
name|size_t
name|__wshift
init|=
name|__shift
operator|/
name|_GLIBCPP_BITSET_BITS_PER_WORD
decl_stmt|;
specifier|const
name|size_t
name|__offset
init|=
name|__shift
operator|%
name|_GLIBCPP_BITSET_BITS_PER_WORD
decl_stmt|;
specifier|const
name|size_t
name|__limit
init|=
name|_Nw
operator|-
name|__wshift
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|__offset
operator|==
literal|0
condition|)
for|for
control|(
name|size_t
name|__n
init|=
literal|0
init|;
name|__n
operator|<=
name|__limit
condition|;
operator|++
name|__n
control|)
name|_M_w
index|[
name|__n
index|]
operator|=
name|_M_w
index|[
name|__n
operator|+
name|__wshift
index|]
expr_stmt|;
else|else
block|{
specifier|const
name|size_t
name|__sub_offset
init|=
name|_GLIBCPP_BITSET_BITS_PER_WORD
operator|-
name|__offset
decl_stmt|;
for|for
control|(
name|size_t
name|__n
init|=
literal|0
init|;
name|__n
operator|<
name|__limit
condition|;
operator|++
name|__n
control|)
name|_M_w
index|[
name|__n
index|]
operator|=
operator|(
name|_M_w
index|[
name|__n
operator|+
name|__wshift
index|]
operator|>>
name|__offset
operator|)
operator||
operator|(
name|_M_w
index|[
name|__n
operator|+
name|__wshift
operator|+
literal|1
index|]
operator|<<
name|__sub_offset
operator|)
expr_stmt|;
name|_M_w
index|[
name|__limit
index|]
operator|=
name|_M_w
index|[
name|_Nw
operator|-
literal|1
index|]
operator|>>
name|__offset
expr_stmt|;
block|}
name|fill
argument_list|(
name|_M_w
operator|+
name|__limit
operator|+
literal|1
argument_list|,
name|_M_w
operator|+
name|_Nw
argument_list|,
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|0
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     }
name|template
operator|<
name|size_t
name|_Nw
operator|>
name|unsigned
name|long
name|_Base_bitset
operator|<
name|_Nw
operator|>
operator|::
name|_M_do_to_ulong
argument_list|()
specifier|const
block|{
for|for
control|(
name|size_t
name|__i
init|=
literal|1
init|;
name|__i
operator|<
name|_Nw
condition|;
operator|++
name|__i
control|)
if|if
condition|(
name|_M_w
index|[
name|__i
index|]
condition|)
name|__throw_overflow_error
argument_list|(
literal|"bitset -- too large to fit in unsigned long"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|_M_w
index|[
literal|0
index|]
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|size_t
name|_Nw
operator|>
name|size_t
name|_Base_bitset
operator|<
name|_Nw
operator|>
operator|::
name|_M_do_find_first
argument_list|(
argument|size_t __not_found
argument_list|)
specifier|const
block|{
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|_Nw
condition|;
name|__i
operator|++
control|)
block|{
name|_WordT
name|__thisword
init|=
name|_M_w
index|[
name|__i
index|]
decl_stmt|;
if|if
condition|(
name|__thisword
operator|!=
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|0
operator|)
condition|)
block|{
comment|// find byte within word
for|for
control|(
name|size_t
name|__j
init|=
literal|0
init|;
name|__j
operator|<
sizeof|sizeof
argument_list|(
name|_WordT
argument_list|)
condition|;
name|__j
operator|++
control|)
block|{
name|unsigned
name|char
name|__this_byte
init|=
name|static_cast
operator|<
name|unsigned
name|char
operator|>
operator|(
name|__thisword
operator|&
operator|(
operator|~
operator|(
name|unsigned
name|char
operator|)
literal|0
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|__this_byte
condition|)
return|return
name|__i
operator|*
name|_GLIBCPP_BITSET_BITS_PER_WORD
operator|+
name|__j
operator|*
name|CHAR_BIT
operator|+
name|_S_first_one
index|[
name|__this_byte
index|]
return|;
name|__thisword
operator|>>=
name|CHAR_BIT
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|} 	}
comment|// not found, so return an indication of failure.
end_comment

begin_return
return|return
name|__not_found
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|size_t
name|_Nw
operator|>
name|size_t
name|_Base_bitset
operator|<
name|_Nw
operator|>
operator|::
name|_M_do_find_next
argument_list|(
argument|size_t __prev
argument_list|,
argument|size_t __not_found
argument_list|)
specifier|const
block|{
comment|// make bound inclusive
operator|++
name|__prev
block|;
comment|// check out of bounds
if|if
condition|(
name|__prev
operator|>=
name|_Nw
operator|*
name|_GLIBCPP_BITSET_BITS_PER_WORD
condition|)
return|return
name|__not_found
return|;
comment|// search first word
name|size_t
name|__i
operator|=
name|_S_whichword
argument_list|(
name|__prev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_WordT
name|__thisword
init|=
name|_M_w
index|[
name|__i
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|// mask off bits below bound
end_comment

begin_expr_stmt
name|__thisword
operator|&=
operator|(
operator|~
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|0
operator|)
operator|)
operator|<<
name|_S_whichbit
argument_list|(
name|__prev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__thisword
operator|!=
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|0
operator|)
condition|)
block|{
comment|// find byte within word
comment|// get first byte into place
name|__thisword
operator|>>=
name|_S_whichbyte
argument_list|(
name|__prev
argument_list|)
operator|*
name|CHAR_BIT
expr_stmt|;
for|for
control|(
name|size_t
name|__j
init|=
name|_S_whichbyte
argument_list|(
name|__prev
argument_list|)
init|;
name|__j
operator|<
sizeof|sizeof
argument_list|(
name|_WordT
argument_list|)
condition|;
name|__j
operator|++
control|)
block|{
name|unsigned
name|char
name|__this_byte
init|=
name|static_cast
operator|<
name|unsigned
name|char
operator|>
operator|(
name|__thisword
operator|&
operator|(
operator|~
operator|(
name|unsigned
name|char
operator|)
literal|0
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|__this_byte
condition|)
return|return
name|__i
operator|*
name|_GLIBCPP_BITSET_BITS_PER_WORD
operator|+
name|__j
operator|*
name|CHAR_BIT
operator|+
name|_S_first_one
index|[
name|__this_byte
index|]
return|;
name|__thisword
operator|>>=
name|CHAR_BIT
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|// check subsequent words
end_comment

begin_expr_stmt
name|__i
operator|++
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
name|__i
operator|<
name|_Nw
condition|;
name|__i
operator|++
control|)
block|{
name|__thisword
operator|=
name|_M_w
index|[
name|__i
index|]
expr_stmt|;
if|if
condition|(
name|__thisword
operator|!=
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|0
operator|)
condition|)
block|{
comment|// find byte within word
for|for
control|(
name|size_t
name|__j
init|=
literal|0
init|;
name|__j
operator|<
sizeof|sizeof
argument_list|(
name|_WordT
argument_list|)
condition|;
name|__j
operator|++
control|)
block|{
name|unsigned
name|char
name|__this_byte
init|=
name|static_cast
operator|<
name|unsigned
name|char
operator|>
operator|(
name|__thisword
operator|&
operator|(
operator|~
operator|(
name|unsigned
name|char
operator|)
literal|0
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|__this_byte
condition|)
return|return
name|__i
operator|*
name|_GLIBCPP_BITSET_BITS_PER_WORD
operator|+
name|__j
operator|*
name|CHAR_BIT
operator|+
name|_S_first_one
index|[
name|__this_byte
index|]
return|;
name|__thisword
operator|>>=
name|CHAR_BIT
expr_stmt|;
block|}
block|}
block|}
end_for

begin_comment
comment|// not found, so return an indication of failure.
end_comment

begin_return
return|return
name|__not_found
return|;
end_return

begin_comment
unit|}
comment|// end _M_do_find_next
end_comment

begin_comment
comment|/**    *  @if maint    *  Base class, specialization for a single word.    *    *  See documentation for bitset.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
operator|>
expr|struct
name|_Base_bitset
operator|<
literal|1
operator|>
block|{
typedef|typedef
name|unsigned
name|long
name|_WordT
typedef|;
name|_WordT
name|_M_w
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Base_bitset
argument_list|(
name|void
argument_list|)
operator|:
name|_M_w
argument_list|(
literal|0
argument_list|)
block|{}
name|_Base_bitset
argument_list|(
argument|unsigned long __val
argument_list|)
operator|:
name|_M_w
argument_list|(
argument|__val
argument_list|)
block|{}
specifier|static
name|size_t
name|_S_whichword
argument_list|(
argument|size_t __pos
argument_list|)
block|{
return|return
name|__pos
operator|/
name|_GLIBCPP_BITSET_BITS_PER_WORD
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|size_t
name|_S_whichbyte
parameter_list|(
name|size_t
name|__pos
parameter_list|)
block|{
return|return
operator|(
name|__pos
operator|%
name|_GLIBCPP_BITSET_BITS_PER_WORD
operator|)
operator|/
name|CHAR_BIT
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|_S_whichbit
parameter_list|(
name|size_t
name|__pos
parameter_list|)
block|{
return|return
name|__pos
operator|%
name|_GLIBCPP_BITSET_BITS_PER_WORD
return|;
block|}
end_function

begin_function
specifier|static
name|_WordT
name|_S_maskbit
parameter_list|(
name|size_t
name|__pos
parameter_list|)
block|{
return|return
operator|(
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|1
operator|)
operator|)
operator|<<
name|_S_whichbit
argument_list|(
name|__pos
argument_list|)
return|;
block|}
end_function

begin_function
name|_WordT
modifier|&
name|_M_getword
parameter_list|(
name|size_t
parameter_list|)
block|{
return|return
name|_M_w
return|;
block|}
end_function

begin_decl_stmt
name|_WordT
name|_M_getword
argument_list|(
name|size_t
argument_list|)
decl|const
block|{
return|return
name|_M_w
return|;
block|}
end_decl_stmt

begin_function
name|_WordT
modifier|&
name|_M_hiword
parameter_list|()
block|{
return|return
name|_M_w
return|;
block|}
end_function

begin_expr_stmt
name|_WordT
name|_M_hiword
argument_list|()
specifier|const
block|{
return|return
name|_M_w
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|_M_do_and
argument_list|(
specifier|const
name|_Base_bitset
operator|<
literal|1
operator|>
operator|&
name|__x
argument_list|)
block|{
name|_M_w
operator|&=
name|__x
operator|.
name|_M_w
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|_M_do_or
argument_list|(
specifier|const
name|_Base_bitset
operator|<
literal|1
operator|>
operator|&
name|__x
argument_list|)
block|{
name|_M_w
operator||=
name|__x
operator|.
name|_M_w
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|_M_do_xor
argument_list|(
specifier|const
name|_Base_bitset
operator|<
literal|1
operator|>
operator|&
name|__x
argument_list|)
block|{
name|_M_w
operator|^=
name|__x
operator|.
name|_M_w
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|_M_do_left_shift
parameter_list|(
name|size_t
name|__shift
parameter_list|)
block|{
name|_M_w
operator|<<=
name|__shift
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_M_do_right_shift
parameter_list|(
name|size_t
name|__shift
parameter_list|)
block|{
name|_M_w
operator|>>=
name|__shift
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_M_do_flip
parameter_list|()
block|{
name|_M_w
operator|=
operator|~
name|_M_w
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_M_do_set
parameter_list|()
block|{
name|_M_w
operator|=
operator|~
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_M_do_reset
parameter_list|()
block|{
name|_M_w
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|bool
name|_M_is_equal
argument_list|(
specifier|const
name|_Base_bitset
operator|<
literal|1
operator|>
operator|&
name|__x
argument_list|)
decl|const
block|{
return|return
name|_M_w
operator|==
name|__x
operator|.
name|_M_w
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|bool
name|_M_is_any
argument_list|()
specifier|const
block|{
return|return
name|_M_w
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_t
name|_M_do_count
argument_list|()
specifier|const
block|{
name|size_t
name|__result
operator|=
literal|0
block|;
specifier|const
name|unsigned
name|char
operator|*
name|__byte_ptr
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|_M_w
block|;
specifier|const
name|unsigned
name|char
operator|*
name|__end_ptr
operator|=
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|_M_w
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|_M_w
argument_list|)
block|;
while|while
condition|(
name|__byte_ptr
operator|<
name|__end_ptr
condition|)
block|{
name|__result
operator|+=
name|_S_bit_count
index|[
operator|*
name|__byte_ptr
index|]
expr_stmt|;
name|__byte_ptr
operator|++
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|__result
return|;
end_return

begin_expr_stmt
unit|}        unsigned
name|long
name|_M_do_to_ulong
argument_list|()
specifier|const
block|{
return|return
name|_M_w
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|size_t
name|_M_do_find_first
argument_list|(
name|size_t
name|__not_found
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
comment|// find the next "on" bit that follows "prev"
end_comment

begin_decl_stmt
name|size_t
name|_M_do_find_next
argument_list|(
name|size_t
name|__prev
argument_list|,
name|size_t
name|__not_found
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Helper class to zero out the unused high-order bits in the highest word.
end_comment

begin_expr_stmt
name|template
operator|<
name|size_t
name|_Extrabits
operator|>
expr|struct
name|_Sanitize
block|{
specifier|static
name|void
name|_S_do_sanitize
argument_list|(
argument|unsigned long& __val
argument_list|)
block|{
name|__val
operator|&=
operator|~
operator|(
operator|(
operator|~
name|static_cast
operator|<
name|unsigned
name|long
operator|>
operator|(
literal|0
operator|)
operator|)
operator|<<
name|_Extrabits
operator|)
block|; }
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|_Sanitize
operator|<
literal|0
operator|>
block|{
specifier|static
name|void
name|_S_do_sanitize
argument_list|(
argument|unsigned long
argument_list|)
block|{ }
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**    *  @brief  The %bitset class represents a @e fixed-size sequence of bits.    *    *  @ingroup Containers    *    *  (Note that %bitset does @e not meet the formal requirements of a    *<a href="tables.html#65">container</a>.  Mainly, it lacks iterators.)    *    *  The template argument, @a _Nb, may be any nonzero number of type    *  size_t.    *    *  A %bitset of size N has N % (sizeof(unsigned long) * CHAR_BIT) unused    *  bits.  (They are the high-order bits in the highest word.)  It is    *  a class invariant that those unused bits are always zero.    *    *  If you think of %bitset as "a simple array of bits," be aware that    *  your mental picture is reversed:  a %bitset behaves the same way as    *  bits in integers do, with the bit at index 0 in the "least significant    *  / right-hand" position, and the bit at index N-1 in the "most    *  significant / left-hand" position.  Thus, unlike other containers, a    *  %bitset's index "counts from right to left," to put it very loosely.    *    *  This behavior is preserved when translating to and from strings.  For    *  example, the first line of the following program probably prints    *  "b('a') is 0001100001" on a modern ASCII system.    *    *  @code    *     #include<bitset>    *     #include<iostream>    *     #include<sstream>    *    *     using namespace std;    *    *     int main()    *     {    *         long         a = 'a';    *         bitset<10>   b(a);    *    *         cout<< "b('a') is "<< b<< endl;    *    *         ostringstream s;    *         s<< b;    *         string  str = s.str();    *         cout<< "index 3 in the string is "<< str[3]<< " but\n"    *<< "index 3 in the bitset is "<< b[3]<< endl;    *     }    *  @endcode    *    *  Also see http://gcc.gnu.org/onlinedocs/libstdc++/ext/sgiexts.html#ch23    *    *  @if maint    *  Most of the actual code isn't contained in %bitset<> itself, but in the    *  base class _Base_bitset.  The base class works with whole words, not with    *  individual bits.  This allows us to specialize _Base_bitset for the    *  important special case where the %bitset is only a single word.    *    *  Extra confusion can result due to the fact that the storage for    *  _Base_bitset @e is a regular array, and is indexed as such.  This is    *  carefully encapsulated.    *  @endif   */
end_comment

begin_expr_stmt
name|template
operator|<
name|size_t
name|_Nb
operator|>
name|class
name|bitset
operator|:
name|private
name|_Base_bitset
operator|<
name|_GLIBCPP_BITSET_WORDS
argument_list|(
name|_Nb
argument_list|)
operator|>
block|{
name|private
operator|:
typedef|typedef
name|_Base_bitset
operator|<
name|_GLIBCPP_BITSET_WORDS
argument_list|(
name|_Nb
argument_list|)
operator|>
name|_Base
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|unsigned
name|long
name|_WordT
typedef|;
end_typedef

begin_function
name|void
name|_M_do_sanitize
parameter_list|()
block|{
name|_Sanitize
operator|<
name|_Nb
operator|%
name|_GLIBCPP_BITSET_BITS_PER_WORD
operator|>
operator|::
name|_S_do_sanitize
argument_list|(
name|this
operator|->
name|_M_hiword
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|/**      *  This encapsulates the concept of a single bit.  An instance of this      *  class is a proxy for an actual bit; this way the individual bit      *  operations are done as faster word-size bitwise instructions.      *      *  Most users will never need to use this class directly; conversions      *  to and from bool are automatic and should be transparent.  Overloaded      *  operators help to preserve the illusion.      *      *  (On a typical system, this "bit %reference" is 64 times the size of      *  an actual bit.  Ha.)     */
end_comment

begin_decl_stmt
name|class
name|reference
block|{
name|friend
name|class
name|bitset
decl_stmt|;
name|_WordT
modifier|*
name|_M_wp
decl_stmt|;
name|size_t
name|_M_bpos
decl_stmt|;
comment|// left undefined
name|reference
argument_list|()
expr_stmt|;
name|public
label|:
name|reference
argument_list|(
argument|bitset& __b
argument_list|,
argument|size_t __pos
argument_list|)
block|{
name|_M_wp
operator|=
operator|&
name|__b
operator|.
name|_M_getword
argument_list|(
name|__pos
argument_list|)
expr_stmt|;
name|_M_bpos
operator|=
name|_Base
operator|::
name|_S_whichbit
argument_list|(
name|__pos
argument_list|)
expr_stmt|;
block|}
operator|~
name|reference
argument_list|()
block|{ }
comment|// for b[i] = __x;
name|reference
operator|&
name|operator
operator|=
operator|(
name|bool
name|__x
operator|)
block|{
if|if
condition|(
name|__x
condition|)
operator|*
name|_M_wp
operator||=
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|_M_bpos
argument_list|)
expr_stmt|;
else|else
operator|*
name|_M_wp
operator|&=
operator|~
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|_M_bpos
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
comment|// for b[i] = b[__j];
end_comment

begin_decl_stmt
name|reference
modifier|&
name|operator
init|=
operator|(
specifier|const
name|reference
operator|&
name|__j
operator|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|__j
operator|.
name|_M_wp
operator|)
operator|&
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|__j
operator|.
name|_M_bpos
argument_list|)
operator|)
condition|)
operator|*
name|_M_wp
operator||=
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|_M_bpos
argument_list|)
expr_stmt|;
else|else
operator|*
name|_M_wp
operator|&=
operator|~
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|_M_bpos
argument_list|)
expr_stmt|;
end_decl_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_comment
unit|}
comment|// flips the bit
end_comment

begin_expr_stmt
unit|bool
name|operator
operator|~
operator|(
operator|)
specifier|const
block|{
return|return
operator|(
operator|*
operator|(
name|_M_wp
operator|)
operator|&
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|_M_bpos
argument_list|)
operator|)
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|// for __x = b[i];
end_comment

begin_expr_stmt
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
operator|(
operator|*
operator|(
name|_M_wp
operator|)
operator|&
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|_M_bpos
argument_list|)
operator|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_comment
comment|// for b[i].flip();
end_comment

begin_function
name|reference
modifier|&
name|flip
parameter_list|()
block|{
operator|*
name|_M_wp
operator|^=
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|_M_bpos
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_decl_stmt
unit|};
name|friend
name|class
name|reference
decl_stmt|;
end_decl_stmt

begin_comment
comment|// 23.3.5.1 constructors:
end_comment

begin_comment
comment|/// All bits set to zero.
end_comment

begin_macro
name|bitset
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/// Initial bits bitwise-copied from a single word (others set to zero).
end_comment

begin_macro
name|bitset
argument_list|(
argument|unsigned long __val
argument_list|)
end_macro

begin_macro
unit|:
name|_Base
argument_list|(
argument|__val
argument_list|)
end_macro

begin_block
block|{
name|_M_do_sanitize
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/**      *  @brief  Use a subset of a string.      *  @param  s  A string of '0' and '1' characters.      *  @param  pos  Index of the first character in @a s to use; defaults      *               to zero.      *  @throw  std::out_of_range  If @a pos is bigger the size of @a s.      *  @throw  std::invalid_argument  If a character appears in the string      *                                 which is neither '0' nor '1'.     */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Traits
operator|,
name|class
name|_Alloc
operator|>
name|explicit
name|bitset
argument_list|(
argument|const basic_string<_CharT
argument_list|,
argument|_Traits
argument_list|,
argument|_Alloc>& __s
argument_list|,
argument|size_t __pos =
literal|0
argument_list|)
operator|:
name|_Base
argument_list|()
block|{
if|if
condition|(
name|__pos
operator|>
name|__s
operator|.
name|size
argument_list|()
condition|)
name|__throw_out_of_range
argument_list|(
literal|"bitset -- initial position is larger than "
literal|"the string itself"
argument_list|)
expr_stmt|;
name|_M_copy_from_string
argument_list|(
name|__s
argument_list|,
name|__pos
argument_list|,
name|basic_string
operator|<
name|_CharT
argument_list|,
name|_Traits
argument_list|,
name|_Alloc
operator|>
operator|::
name|npos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**      *  @brief  Use a subset of a string.      *  @param  s  A string of '0' and '1' characters.      *  @param  pos  Index of the first character in @a s to use.      *  @param  n    The number of characters to copy.      *  @throw  std::out_of_range  If @a pos is bigger the size of @a s.      *  @throw  std::invalid_argument  If a character appears in the string      *                                 which is neither '0' nor '1'.     */
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Traits
operator|,
name|class
name|_Alloc
operator|>
name|bitset
argument_list|(
argument|const basic_string<_CharT
argument_list|,
argument|_Traits
argument_list|,
argument|_Alloc>& __s
argument_list|,
argument|size_t __pos
argument_list|,
argument|size_t __n
argument_list|)
operator|:
name|_Base
argument_list|()
block|{
if|if
condition|(
name|__pos
operator|>
name|__s
operator|.
name|size
argument_list|()
condition|)
name|__throw_out_of_range
argument_list|(
literal|"bitset -- initial position is larger than "
literal|"the string itself"
argument_list|)
expr_stmt|;
name|_M_copy_from_string
argument_list|(
name|__s
argument_list|,
name|__pos
argument_list|,
name|__n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// 23.3.5.2 bitset operations:
end_comment

begin_comment
comment|//@{
end_comment

begin_comment
comment|/**      *  @brief  Operations on bitsets.      *  @param  rhs  A same-sized bitset.      *      *  These should be self-explanatory.     */
end_comment

begin_expr_stmt
unit|bitset
operator|<
name|_Nb
operator|>
operator|&
name|operator
operator|&=
operator|(
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__rhs
operator|)
block|{
name|this
operator|->
name|_M_do_and
argument_list|(
name|__rhs
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|operator
operator||=
operator|(
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__rhs
operator|)
block|{
name|this
operator|->
name|_M_do_or
argument_list|(
name|__rhs
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|operator
operator|^=
operator|(
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__rhs
operator|)
block|{
name|this
operator|->
name|_M_do_xor
argument_list|(
name|__rhs
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|//@}
end_comment

begin_comment
comment|//@{
end_comment

begin_comment
comment|/**      *  @brief  Operations on bitsets.      *  @param  pos  The number of places to shift.      *      *  These should be self-explanatory.     */
end_comment

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|operator
operator|<<=
operator|(
name|size_t
name|__pos
operator|)
block|{
name|this
operator|->
name|_M_do_left_shift
argument_list|(
name|__pos
argument_list|)
block|;
name|this
operator|->
name|_M_do_sanitize
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|operator
operator|>>=
operator|(
name|size_t
name|__pos
operator|)
block|{
name|this
operator|->
name|_M_do_right_shift
argument_list|(
name|__pos
argument_list|)
block|;
name|this
operator|->
name|_M_do_sanitize
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|//@}
end_comment

begin_comment
comment|//@{
end_comment

begin_comment
comment|/**      *  These versions of single-bit set, reset, flip, and test are      *  extensions from the SGI version.  They do no range checking.      *  @ingroup SGIextensions     */
end_comment

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|_Unchecked_set
argument_list|(
argument|size_t __pos
argument_list|)
block|{
name|this
operator|->
name|_M_getword
argument_list|(
name|__pos
argument_list|)
operator||=
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|__pos
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|_Unchecked_set
argument_list|(
argument|size_t __pos
argument_list|,
argument|int __val
argument_list|)
block|{
if|if
condition|(
name|__val
condition|)
name|this
operator|->
name|_M_getword
argument_list|(
name|__pos
argument_list|)
operator||=
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|__pos
argument_list|)
expr_stmt|;
else|else
name|this
operator|->
name|_M_getword
argument_list|(
name|__pos
argument_list|)
operator|&=
operator|~
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|__pos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}      bitset
operator|<
name|_Nb
operator|>
operator|&
name|_Unchecked_reset
argument_list|(
argument|size_t __pos
argument_list|)
block|{
name|this
operator|->
name|_M_getword
argument_list|(
name|__pos
argument_list|)
operator|&=
operator|~
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|__pos
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|_Unchecked_flip
argument_list|(
argument|size_t __pos
argument_list|)
block|{
name|this
operator|->
name|_M_getword
argument_list|(
name|__pos
argument_list|)
operator|^=
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|__pos
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|bool
name|_Unchecked_test
argument_list|(
name|size_t
name|__pos
argument_list|)
decl|const
block|{
return|return
operator|(
name|this
operator|->
name|_M_getword
argument_list|(
name|__pos
argument_list|)
operator|&
name|_Base
operator|::
name|_S_maskbit
argument_list|(
name|__pos
argument_list|)
operator|)
operator|!=
name|static_cast
operator|<
name|_WordT
operator|>
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|//@}
end_comment

begin_comment
comment|// Set, reset, and flip.
end_comment

begin_comment
comment|/**      *  @brief Sets every bit to true.     */
end_comment

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|set
argument_list|()
block|{
name|this
operator|->
name|_M_do_set
argument_list|()
block|;
name|this
operator|->
name|_M_do_sanitize
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/**      *  @brief Sets a given bit to a particular value.      *  @param  pos  The index of the bit.      *  @param  val  Either true or false, defaults to true.      *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.     */
end_comment

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|set
argument_list|(
argument|size_t __pos
argument_list|,
argument|bool __val = true
argument_list|)
block|{
if|if
condition|(
name|__pos
operator|>=
name|_Nb
condition|)
name|__throw_out_of_range
argument_list|(
literal|"bitset -- set() argument too large"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|_Unchecked_set
argument_list|(
name|__pos
argument_list|,
name|__val
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**      *  @brief Sets every bit to false.     */
end_comment

begin_expr_stmt
unit|bitset
operator|<
name|_Nb
operator|>
operator|&
name|reset
argument_list|()
block|{
name|this
operator|->
name|_M_do_reset
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/**      *  @brief Sets a given bit to false.      *  @param  pos  The index of the bit.      *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.      *      *  Same as writing @c set(pos,false).     */
end_comment

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|reset
argument_list|(
argument|size_t __pos
argument_list|)
block|{
if|if
condition|(
name|__pos
operator|>=
name|_Nb
condition|)
name|__throw_out_of_range
argument_list|(
literal|"bitset -- reset() argument too large"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|_Unchecked_reset
argument_list|(
name|__pos
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**      *  @brief Toggles every bit to its opposite value.     */
end_comment

begin_expr_stmt
unit|bitset
operator|<
name|_Nb
operator|>
operator|&
name|flip
argument_list|()
block|{
name|this
operator|->
name|_M_do_flip
argument_list|()
block|;
name|this
operator|->
name|_M_do_sanitize
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/**      *  @brief Toggles a given bit to its opposite value.      *  @param  pos  The index of the bit.      *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.     */
end_comment

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|flip
argument_list|(
argument|size_t __pos
argument_list|)
block|{
if|if
condition|(
name|__pos
operator|>=
name|_Nb
condition|)
name|__throw_out_of_range
argument_list|(
literal|"bitset -- flip() argument too large"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|_Unchecked_flip
argument_list|(
name|__pos
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// See the no-argument flip().
end_comment

begin_expr_stmt
unit|bitset
operator|<
name|_Nb
operator|>
name|operator
operator|~
operator|(
operator|)
specifier|const
block|{
return|return
name|bitset
operator|<
name|_Nb
operator|>
operator|(
operator|*
name|this
operator|)
operator|.
name|flip
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|//@{
end_comment

begin_comment
comment|/**      *  @brief  Array-indexing support.      *  @param  pos  Index into the %bitset.      *  @return  A bool for a 'const %bitset'.  For non-const bitsets, an      *           instance of the reference proxy class.      *  @note  These operators do no range checking and throw no exceptions,      *         as required by DR 11 to the standard.      *      *  @if maint      *  _GLIBCPP_RESOLVE_LIB_DEFECTS Note that this implementation already      *  resolves DR 11 (items 1 and 2), but does not do the range-checking      *  required by that DR's resolution.  -pme      *  The DR has since been changed:  range-checking is a precondition      *  (users' responsibility), and these functions must not throw.  -pme      *  @endif     */
end_comment

begin_function
name|reference
name|operator
function|[]
parameter_list|(
name|size_t
name|__pos
parameter_list|)
block|{
return|return
name|reference
argument_list|(
operator|*
name|this
argument_list|,
name|__pos
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|bool
name|operator
index|[]
argument_list|(
name|size_t
name|__pos
argument_list|)
decl|const
block|{
return|return
name|_Unchecked_test
argument_list|(
name|__pos
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|//@}
end_comment

begin_comment
comment|/**      *  @brief Retuns a numerical interpretation of the %bitset.      *  @return  The integral equivalent of the bits.      *  @throw  std::overflow_error  If there are too many bits to be      *                               represented in an @c unsigned @c long.     */
end_comment

begin_expr_stmt
name|unsigned
name|long
name|to_ulong
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|_M_do_to_ulong
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/**      *  @brief Retuns a character interpretation of the %bitset.      *  @return  The string equivalent of the bits.      *      *  Note the ordering of the bits:  decreasing character positions      *  correspond to increasing bit positions (see the main class notes for      *  an example).      *      *  Also note that you must specify the string's template parameters      *  explicitly.  Given a bitset @c bs and a string @s:      *  @code      *     s = bs.to_string<char,char_traits<char>,allocator<char>>();      *  @endcode     */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Traits
operator|,
name|class
name|_Alloc
operator|>
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|,
name|_Alloc
operator|>
name|to_string
argument_list|()
specifier|const
block|{
name|basic_string
operator|<
name|_CharT
block|,
name|_Traits
block|,
name|_Alloc
operator|>
name|__result
block|;
name|_M_copy_to_string
argument_list|(
name|__result
argument_list|)
block|;
return|return
name|__result
return|;
block|}
end_expr_stmt

begin_comment
comment|// Helper functions for string operations.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Traits
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_M_copy_from_string
argument_list|(
specifier|const
name|basic_string
operator|<
name|_CharT
argument_list|,
name|_Traits
argument_list|,
name|_Alloc
operator|>
operator|&
name|__s
argument_list|,
name|size_t
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Traits
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_M_copy_to_string
argument_list|(
argument|basic_string<_CharT
argument_list|,
argument|_Traits
argument_list|,
argument|_Alloc>&
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Returns the number of bits which are set.
end_comment

begin_expr_stmt
name|size_t
name|count
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|_M_do_count
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Returns the total number of bits.
end_comment

begin_expr_stmt
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|_Nb
return|;
block|}
end_expr_stmt

begin_comment
comment|//@{
end_comment

begin_comment
comment|/// These comparisons for equality/inequality are, well, @e bitwise.
end_comment

begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__rhs
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|_M_is_equal
argument_list|(
name|__rhs
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__rhs
operator|)
specifier|const
block|{
return|return
operator|!
name|this
operator|->
name|_M_is_equal
argument_list|(
name|__rhs
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//@}
end_comment

begin_comment
comment|/**      *  @brief Tests the value of a bit.      *  @param  pos  The index of a bit.      *  @return  The value at @a pos.      *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.     */
end_comment

begin_decl_stmt
name|bool
name|test
argument_list|(
name|size_t
name|__pos
argument_list|)
decl|const
block|{
if|if
condition|(
name|__pos
operator|>=
name|_Nb
condition|)
name|__throw_out_of_range
argument_list|(
literal|"bitset -- test() argument too large"
argument_list|)
expr_stmt|;
return|return
name|_Unchecked_test
argument_list|(
name|__pos
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/**      *  @brief Tests whether any of the bits are on.      *  @return  True if at least one bit is set.     */
end_comment

begin_expr_stmt
name|bool
name|any
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|_M_is_any
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/**      *  @brief Tests whether any of the bits are on.      *  @return  True if none of the bits are set.     */
end_comment

begin_expr_stmt
name|bool
name|none
argument_list|()
specifier|const
block|{
return|return
operator|!
name|this
operator|->
name|_M_is_any
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|//@{
end_comment

begin_comment
comment|/// Self-explanatory.
end_comment

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
name|operator
operator|<<
operator|(
name|size_t
name|__pos
operator|)
specifier|const
block|{
return|return
name|bitset
operator|<
name|_Nb
operator|>
operator|(
operator|*
name|this
operator|)
operator|<<=
name|__pos
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bitset
operator|<
name|_Nb
operator|>
name|operator
operator|>>
operator|(
name|size_t
name|__pos
operator|)
specifier|const
block|{
return|return
name|bitset
operator|<
name|_Nb
operator|>
operator|(
operator|*
name|this
operator|)
operator|>>=
name|__pos
return|;
block|}
end_expr_stmt

begin_comment
comment|//@}
end_comment

begin_comment
comment|/**      *  @brief  Finds the index of the first "on" bit.      *  @return  The index of the first bit set, or size() if not found.      *  @ingroup SGIextensions      *  @sa  _Find_next     */
end_comment

begin_expr_stmt
name|size_t
name|_Find_first
argument_list|()
specifier|const
block|{
return|return
name|this
operator|->
name|_M_do_find_first
argument_list|(
name|_Nb
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**      *  @brief  Finds the index of the next "on" bit after prev.      *  @return  The index of the next bit set, or size() if not found.      *  @param  prev  Where to start searching.      *  @ingroup SGIextensions      *  @sa  _Find_first     */
end_comment

begin_decl_stmt
name|size_t
name|_Find_next
argument_list|(
name|size_t
name|__prev
argument_list|)
decl|const
block|{
return|return
name|this
operator|->
name|_M_do_find_next
argument_list|(
name|__prev
argument_list|,
name|_Nb
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|// Definitions of non-inline member functions.
end_comment

begin_expr_stmt
name|template
operator|<
name|size_t
name|_Nb
operator|>
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Traits
operator|,
name|class
name|_Alloc
operator|>
name|void
name|bitset
operator|<
name|_Nb
operator|>
operator|::
name|_M_copy_from_string
argument_list|(
argument|const basic_string<_CharT
argument_list|,
argument|_Traits
argument_list|,
argument|_Alloc>& __s
argument_list|,
argument|size_t __pos
argument_list|,
argument|size_t __n
argument_list|)
block|{
name|reset
argument_list|()
block|;
specifier|const
name|size_t
name|__nbits
operator|=
name|min
argument_list|(
name|_Nb
argument_list|,
name|min
argument_list|(
name|__n
argument_list|,
name|__s
operator|.
name|size
argument_list|()
operator|-
name|__pos
argument_list|)
argument_list|)
block|;
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|__nbits
condition|;
operator|++
name|__i
control|)
block|{
switch|switch
condition|(
name|__s
index|[
name|__pos
operator|+
name|__nbits
operator|-
name|__i
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'0'
case|:
break|break;
case|case
literal|'1'
case|:
name|set
argument_list|(
name|__i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|__throw_invalid_argument
argument_list|(
literal|"bitset -- string contains characters "
literal|"which are neither 0 nor 1"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}     }
name|template
operator|<
name|size_t
name|_Nb
operator|>
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Traits
operator|,
name|class
name|_Alloc
operator|>
name|void
name|bitset
operator|<
name|_Nb
operator|>
operator|::
name|_M_copy_to_string
argument_list|(
argument|basic_string<_CharT
argument_list|,
argument|_Traits
argument_list|,
argument|_Alloc>& __s
argument_list|)
specifier|const
block|{
name|__s
operator|.
name|assign
argument_list|(
name|_Nb
argument_list|,
literal|'0'
argument_list|)
block|;
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|_Nb
condition|;
operator|++
name|__i
control|)
if|if
condition|(
name|_Unchecked_test
argument_list|(
name|__i
argument_list|)
condition|)
name|__s
index|[
name|_Nb
operator|-
literal|1
operator|-
name|__i
index|]
operator|=
literal|'1'
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// 23.3.5.3 bitset operations:
end_comment

begin_comment
comment|//@{
end_comment

begin_comment
comment|/**    *  @brief  Global bitwise operations on bitsets.    *  @param  x  A bitset.    *  @param  y  A bitset of the same size as @a x.    *  @return  A new bitset.    *    *  These should be self-explanatory.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|size_t
name|_Nb
operator|>
specifier|inline
name|bitset
operator|<
name|_Nb
operator|>
name|operator
operator|&
operator|(
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__x
operator|,
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__y
operator|)
block|{
name|bitset
operator|<
name|_Nb
operator|>
name|__result
argument_list|(
name|__x
argument_list|)
block|;
name|__result
operator|&=
name|__y
block|;
return|return
name|__result
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|size_t
name|_Nb
operator|>
specifier|inline
name|bitset
operator|<
name|_Nb
operator|>
name|operator
operator||
operator|(
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__x
operator|,
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__y
operator|)
block|{
name|bitset
operator|<
name|_Nb
operator|>
name|__result
argument_list|(
name|__x
argument_list|)
block|;
name|__result
operator||=
name|__y
block|;
return|return
name|__result
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|size_t
name|_Nb
operator|>
specifier|inline
name|bitset
operator|<
name|_Nb
operator|>
name|operator
lambda|^
parameter_list|(
lambda|const bitset<_Nb>& __x
operator|,
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__y
end_expr_stmt

begin_block
unit|)
block|{
name|bitset
operator|<
name|_Nb
operator|>
name|__result
argument_list|(
name|__x
argument_list|)
expr_stmt|;
name|__result
operator|^=
name|__y
expr_stmt|;
return|return
name|__result
return|;
block|}
end_block

begin_comment
comment|//@}
end_comment

begin_comment
comment|//@{
end_comment

begin_comment
comment|/**    *  @brief Global I/O operators for bitsets.    *    *  Direct I/O between streams and bitsets is supported.  Output is    *  straightforward.  Input will skip whitespace, only accept '0' and '1'    *  characters, and will only extract as many digits as the %bitset will    *  hold.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Traits
operator|,
name|size_t
name|_Nb
operator|>
name|basic_istream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|&
name|operator
operator|>>
operator|(
name|basic_istream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|&
name|__is
operator|,
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__x
operator|)
block|{
typedef|typedef
name|typename
name|_Traits
operator|::
name|char_type
name|char_type
expr_stmt|;
name|basic_string
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
name|__tmp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__tmp
operator|.
name|reserve
argument_list|(
name|_Nb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Skip whitespace
end_comment

begin_expr_stmt
name|typename
name|basic_istream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|::
name|sentry
name|__sentry
argument_list|(
name|__is
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__sentry
condition|)
block|{
name|basic_streambuf
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|*
name|__buf
operator|=
name|__is
operator|.
name|rdbuf
argument_list|()
expr_stmt|;
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|_Nb
condition|;
operator|++
name|__i
control|)
block|{
specifier|static
name|typename
name|_Traits
operator|::
name|int_type
name|__eof
operator|=
name|_Traits
operator|::
name|eof
argument_list|()
expr_stmt|;
name|typename
name|_Traits
operator|::
name|int_type
name|__c1
operator|=
name|__buf
operator|->
name|sbumpc
argument_list|()
expr_stmt|;
if|if
condition|(
name|_Traits
operator|::
name|eq_int_type
argument_list|(
name|__c1
argument_list|,
name|__eof
argument_list|)
condition|)
block|{
name|__is
operator|.
name|setstate
argument_list|(
name|ios_base
operator|::
name|eofbit
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|char_type
name|__c2
init|=
name|_Traits
operator|::
name|to_char_type
argument_list|(
name|__c1
argument_list|)
decl_stmt|;
name|char_type
name|__c
init|=
name|__is
operator|.
name|narrow
argument_list|(
name|__c2
argument_list|,
literal|'*'
argument_list|)
decl_stmt|;
if|if
condition|(
name|__c
operator|==
literal|'0'
operator|||
name|__c
operator|==
literal|'1'
condition|)
name|__tmp
operator|.
name|push_back
argument_list|(
name|__c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_Traits
operator|::
name|eq_int_type
argument_list|(
name|__buf
operator|->
name|sputbackc
argument_list|(
name|__c2
argument_list|)
argument_list|,
name|__eof
argument_list|)
condition|)
block|{
name|__is
operator|.
name|setstate
argument_list|(
name|ios_base
operator|::
name|failbit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|__tmp
operator|.
name|empty
argument_list|()
condition|)
name|__is
operator|.
name|setstate
argument_list|(
name|ios_base
operator|::
name|failbit
argument_list|)
expr_stmt|;
else|else
name|__x
operator|.
name|_M_copy_from_string
argument_list|(
name|__tmp
argument_list|,
name|static_cast
operator|<
name|size_t
operator|>
operator|(
literal|0
operator|)
argument_list|,
name|_Nb
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|__is
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Traits
operator|,
name|size_t
name|_Nb
operator|>
name|basic_ostream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|&
name|operator
operator|<<
operator|(
name|basic_ostream
operator|<
name|_CharT
operator|,
name|_Traits
operator|>
operator|&
name|__os
operator|,
specifier|const
name|bitset
operator|<
name|_Nb
operator|>
operator|&
name|__x
operator|)
block|{
name|basic_string
operator|<
name|_CharT
block|,
name|_Traits
operator|>
name|__tmp
block|;
name|__x
operator|.
name|_M_copy_to_string
argument_list|(
name|__tmp
argument_list|)
block|;
return|return
name|__os
operator|<<
name|__tmp
return|;
block|}
end_expr_stmt

begin_comment
comment|//@}
end_comment

begin_comment
unit|}
comment|// namespace std
end_comment

begin_undef
undef|#
directive|undef
name|_GLIBCPP_BITSET_WORDS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _GLIBCPP_BITSET_H */
end_comment

end_unit

