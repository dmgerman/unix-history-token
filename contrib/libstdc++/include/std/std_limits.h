begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// The template and inlines for the -*- C++ -*- numeric_limits classes.
end_comment

begin_comment
comment|// Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|// Note: this is not a conforming implementation.
end_comment

begin_comment
comment|// Written by Gabriel Dos Reis<gdr@codesourcery.com>
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// ISO 14882:1998
end_comment

begin_comment
comment|// 18.2.1
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/** @file limits  *  This is a Standard C++ Library header.  You should @c #include this header  *  in your programs, rather than any of the "st[dl]_*.h" implementation files.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_CPP_NUMERIC_LIMITS
end_ifndef

begin_define
define|#
directive|define
name|_CPP_NUMERIC_LIMITS
value|1
end_define

begin_pragma
pragma|#
directive|pragma
name|GCC
name|system_header
end_pragma

begin_include
include|#
directive|include
file|<bits/c++config.h>
end_include

begin_comment
comment|//
end_comment

begin_comment
comment|// The numeric_limits<> traits document implementation-defined aspects
end_comment

begin_comment
comment|// of fundamental arithmetic data types (integers and floating points).
end_comment

begin_comment
comment|// From Standard C++ point of view, there are 13 such types:
end_comment

begin_comment
comment|//   * integers
end_comment

begin_comment
comment|//         bool						        (1)
end_comment

begin_comment
comment|//         char, signed char, unsigned char			(3)
end_comment

begin_comment
comment|//         short, unsigned short				(2)
end_comment

begin_comment
comment|//         int, unsigned					(2)
end_comment

begin_comment
comment|//         long, unsigned long					(2)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   * floating points
end_comment

begin_comment
comment|//         float						(1)
end_comment

begin_comment
comment|//         double						(1)
end_comment

begin_comment
comment|//         long double						(1)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// GNU C++ undertstands (where supported by the host C-library)
end_comment

begin_comment
comment|//   * integer
end_comment

begin_comment
comment|//         long long, unsigned long long			(2)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// which brings us to 15 fundamental arithmetic data types in GNU C++.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Since a numeric_limits<> is a bit tricky to get right, we rely on
end_comment

begin_comment
comment|// an interface composed of macros which should be defined in config/os
end_comment

begin_comment
comment|// or config/cpu when they differ from the generic (read arbitrary)
end_comment

begin_comment
comment|// definitions given here.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// These values can be overridden in the target configuration file.
end_comment

begin_comment
comment|// The default values are appropriate for many 32-bit targets.
end_comment

begin_comment
comment|// GCC only intrinsicly supports modulo integral types.  The only remaining
end_comment

begin_comment
comment|// integral exceptional values is division by zero.  Only targets that do not
end_comment

begin_comment
comment|// signal division by zero in some "hard to ignore" way should use false.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__glibcpp_integral_traps
end_ifndef

begin_define
define|#
directive|define
name|__glibcpp_integral_traps
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// float
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Default values.  Should be overriden in configuration files if necessary.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__glibcpp_float_has_denorm_loss
end_ifndef

begin_define
define|#
directive|define
name|__glibcpp_float_has_denorm_loss
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__glibcpp_float_traps
end_ifndef

begin_define
define|#
directive|define
name|__glibcpp_float_traps
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__glibcpp_float_tinyness_before
end_ifndef

begin_define
define|#
directive|define
name|__glibcpp_float_tinyness_before
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// double
end_comment

begin_comment
comment|// Default values.  Should be overriden in configuration files if necessary.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__glibcpp_double_has_denorm_loss
end_ifndef

begin_define
define|#
directive|define
name|__glibcpp_double_has_denorm_loss
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__glibcpp_double_traps
end_ifndef

begin_define
define|#
directive|define
name|__glibcpp_double_traps
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__glibcpp_double_tinyness_before
end_ifndef

begin_define
define|#
directive|define
name|__glibcpp_double_tinyness_before
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// long double
end_comment

begin_comment
comment|// Default values.  Should be overriden in configuration files if necessary.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__glibcpp_long_double_has_denorm_loss
end_ifndef

begin_define
define|#
directive|define
name|__glibcpp_long_double_has_denorm_loss
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__glibcpp_long_double_traps
end_ifndef

begin_define
define|#
directive|define
name|__glibcpp_long_double_traps
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__glibcpp_long_double_tinyness_before
end_ifndef

begin_define
define|#
directive|define
name|__glibcpp_long_double_tinyness_before
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// You should not need to define any macros below this point.
end_comment

begin_define
define|#
directive|define
name|__glibcpp_signed
parameter_list|(
name|T
parameter_list|)
value|((T)(-1)< 0)
end_define

begin_define
define|#
directive|define
name|__glibcpp_min
parameter_list|(
name|T
parameter_list|)
define|\
value|(__glibcpp_signed (T) ? (T)1<< __glibcpp_digits (T) : (T)0)
end_define

begin_define
define|#
directive|define
name|__glibcpp_max
parameter_list|(
name|T
parameter_list|)
define|\
value|(__glibcpp_signed (T) ? ((T)1<< __glibcpp_digits (T)) - 1 : ~(T)0)
end_define

begin_define
define|#
directive|define
name|__glibcpp_digits
parameter_list|(
name|T
parameter_list|)
define|\
value|(sizeof(T) * __CHAR_BIT__ - __glibcpp_signed (T))
end_define

begin_comment
comment|// The fraction 643/2136 approximates log10(2) to 7 significant digits.
end_comment

begin_define
define|#
directive|define
name|__glibcpp_digits10
parameter_list|(
name|T
parameter_list|)
define|\
value|(__glibcpp_digits (T) * 643 / 2136)
end_define

begin_decl_stmt
name|namespace
name|std
block|{
enum|enum
name|float_round_style
block|{
name|round_indeterminate
init|=
operator|-
literal|1
block|,
name|round_toward_zero
init|=
literal|0
block|,
name|round_to_nearest
init|=
literal|1
block|,
name|round_toward_infinity
init|=
literal|2
block|,
name|round_toward_neg_infinity
init|=
literal|3
block|}
enum|;
enum|enum
name|float_denorm_style
block|{
name|denorm_indeterminate
init|=
operator|-
literal|1
block|,
name|denorm_absent
init|=
literal|0
block|,
name|denorm_present
init|=
literal|1
block|}
enum|;
comment|//
comment|// The primary class traits
comment|//
struct|struct
name|__numeric_limits_base
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|int
name|digits
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|int
name|digits10
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|bool
name|is_signed
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|bool
name|is_integer
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|bool
name|is_exact
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|int
name|radix
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|int
name|min_exponent
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|int
name|min_exponent10
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|int
name|max_exponent
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|int
name|max_exponent10
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|bool
name|has_infinity
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
init|=
name|denorm_absent
decl_stmt|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|bool
name|is_iec559
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|bool
name|is_bounded
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|bool
name|is_modulo
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|bool
name|traps
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|bool
name|tinyness_before
init|=
name|false
decl_stmt|;
specifier|static
specifier|const
name|float_round_style
name|round_style
init|=
name|round_toward_zero
decl_stmt|;
block|}
struct|;
name|template
operator|<
name|typename
name|_Tp
operator|>
expr|struct
name|numeric_limits
operator|:
name|public
name|__numeric_limits_base
block|{
specifier|static
name|_Tp
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|_Tp
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|_Tp
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|_Tp
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|_Tp
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|_Tp
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|_Tp
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|_Tp
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|_Tp
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|_Tp
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|_Tp
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|_Tp
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|_Tp
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|_Tp
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|_Tp
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|_Tp
operator|>
operator|(
literal|0
operator|)
return|;
block|}
expr|}
block|;
comment|// Now there follow 15 explicit specializations.  Yes, 15.  Make sure
comment|// you get the count right.
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|bool
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|bool
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|false
return|;
block|}
specifier|static
name|bool
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
literal|1
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|bool
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|false
return|;
block|}
specifier|static
name|bool
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|false
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|bool
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|false
return|;
block|}
specifier|static
name|bool
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|false
return|;
block|}
specifier|static
name|bool
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|false
return|;
block|}
specifier|static
name|bool
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|false
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|false
block|;
comment|// It is not clear what it means for a boolean type to trap.
comment|// This is a DR on the LWG issue list.  Here, I use integer
comment|// promotion semantics.
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|char
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|char
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__glibcpp_min
argument_list|(
name|char
argument_list|)
return|;
block|}
specifier|static
name|char
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__glibcpp_max
argument_list|(
name|char
argument_list|)
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
name|char
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
name|char
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|__glibcpp_signed
argument_list|(
name|char
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|char
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|char
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|char
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|char
argument_list|()
return|;
block|}
specifier|static
name|char
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|char
argument_list|()
return|;
block|}
specifier|static
name|char
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|char
argument_list|()
return|;
block|}
specifier|static
name|char
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|char
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|signed
name|char
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|signed
name|char
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
operator|-
name|__SCHAR_MAX__
operator|-
literal|1
return|;
block|}
specifier|static
name|signed
name|char
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__SCHAR_MAX__
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
argument|signed char
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
argument|signed char
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|signed
name|char
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|signed
name|char
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|signed
name|char
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|signed
name|char
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|signed
name|char
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|signed
name|char
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|signed
name|char
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|signed
name|char
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|signed
name|char
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|signed
name|char
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|unsigned
name|char
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|unsigned
name|char
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|unsigned
name|char
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__SCHAR_MAX__
operator|*
literal|2U
operator|+
literal|1
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
argument|unsigned char
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
argument|unsigned char
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|unsigned
name|char
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|unsigned
name|char
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|unsigned
name|char
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|char
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|char
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|char
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|char
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|char
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|char
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|char
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|wchar_t
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|wchar_t
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__glibcpp_min
argument_list|(
name|wchar_t
argument_list|)
return|;
block|}
specifier|static
name|wchar_t
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__glibcpp_max
argument_list|(
name|wchar_t
argument_list|)
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
name|wchar_t
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
name|wchar_t
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|__glibcpp_signed
argument_list|(
name|wchar_t
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|wchar_t
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|wchar_t
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|wchar_t
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|wchar_t
argument_list|()
return|;
block|}
specifier|static
name|wchar_t
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|wchar_t
argument_list|()
return|;
block|}
specifier|static
name|wchar_t
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|wchar_t
argument_list|()
return|;
block|}
specifier|static
name|wchar_t
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|wchar_t
argument_list|()
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|short
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|short
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
operator|-
name|__SHRT_MAX__
operator|-
literal|1
return|;
block|}
specifier|static
name|short
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__SHRT_MAX__
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
name|short
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
name|short
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|short
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|short
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|short
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|short
argument_list|()
return|;
block|}
specifier|static
name|short
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|short
argument_list|()
return|;
block|}
specifier|static
name|short
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|short
argument_list|()
return|;
block|}
specifier|static
name|short
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|short
argument_list|()
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|unsigned
name|short
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|unsigned
name|short
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|unsigned
name|short
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__SHRT_MAX__
operator|*
literal|2U
operator|+
literal|1
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
argument|unsigned short
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
argument|unsigned short
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|unsigned
name|short
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|unsigned
name|short
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|unsigned
name|short
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|short
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|short
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|short
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|short
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|short
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|short
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|short
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|int
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|int
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
operator|-
name|__INT_MAX__
operator|-
literal|1
return|;
block|}
specifier|static
name|int
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__INT_MAX__
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
name|int
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
name|int
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|int
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|int
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|int
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|int
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|int
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|int
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|unsigned
name|int
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|unsigned
name|int
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|unsigned
name|int
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__INT_MAX__
operator|*
literal|2U
operator|+
literal|1
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
argument|unsigned int
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
argument|unsigned int
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|unsigned
name|int
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|unsigned
name|int
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|unsigned
name|int
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|int
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|int
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|int
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|int
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|long
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|long
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
operator|-
name|__LONG_MAX__
operator|-
literal|1
return|;
block|}
specifier|static
name|long
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__LONG_MAX__
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
name|long
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
name|long
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|long
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|long
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|long
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|long
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|long
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|long
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|unsigned
name|long
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|unsigned
name|long
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|unsigned
name|long
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__LONG_MAX__
operator|*
literal|2UL
operator|+
literal|1
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
argument|unsigned long
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
argument|unsigned long
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|unsigned
name|long
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|unsigned
name|long
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|unsigned
name|long
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|long
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|long
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|long
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|long
name|long
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|long
name|long
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
operator|-
name|__LONG_LONG_MAX__
operator|-
literal|1
return|;
block|}
specifier|static
name|long
name|long
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__LONG_LONG_MAX__
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
argument|long long
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
argument|long long
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|long
name|long
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|long
name|long
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|long
name|long
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|long
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|long
name|long
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|long
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|long
name|long
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|long
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|long
name|long
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|long
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|unsigned
name|long
name|long
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|unsigned
name|long
name|long
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|unsigned
name|long
name|long
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__LONG_LONG_MAX__
operator|*
literal|2ULL
operator|+
literal|1
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__glibcpp_digits
argument_list|(
argument|unsigned long long
argument_list|)
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__glibcpp_digits10
argument_list|(
argument|unsigned long long
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|true
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
literal|2
block|;
specifier|static
name|unsigned
name|long
name|long
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
name|unsigned
name|long
name|long
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
literal|0
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
literal|0
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|false
block|;
specifier|static
name|unsigned
name|long
name|long
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|long
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|long
name|long
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|long
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|long
name|long
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|long
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|unsigned
name|long
name|long
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|unsigned
name|long
name|long
operator|>
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_integral_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|false
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_toward_zero
block|;     }
block|;
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|float
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|float
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__FLT_MIN__
return|;
block|}
specifier|static
name|float
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__FLT_MAX__
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__FLT_MANT_DIG__
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__FLT_DIG__
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|false
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
name|__FLT_RADIX__
block|;
specifier|static
name|float
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__FLT_EPSILON__
return|;
block|}
specifier|static
name|float
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0.5F
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
name|__FLT_MIN_EXP__
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
name|__FLT_MIN_10_EXP__
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
name|__FLT_MAX_EXP__
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
name|__FLT_MAX_10_EXP__
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|__builtin_huge_valf
argument_list|()
operator|/
literal|2
operator|==
name|__builtin_huge_valf
argument_list|()
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|__builtin_nanf
argument_list|(
literal|""
argument_list|)
operator|!=
name|__builtin_nanf
argument_list|(
literal|""
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|has_quiet_NaN
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|__FLT_DENORM_MIN__
condition|?
name|denorm_present
else|:
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|__glibcpp_float_has_denorm_loss
block|;
specifier|static
name|float
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__builtin_huge_valf
argument_list|()
return|;
block|}
specifier|static
name|float
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__builtin_nanf
argument_list|(
literal|""
argument_list|)
return|;
block|}
specifier|static
name|float
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__builtin_nansf
argument_list|(
literal|""
argument_list|)
return|;
block|}
specifier|static
name|float
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__FLT_DENORM_MIN__
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|has_infinity
operator|&&
name|has_quiet_NaN
operator|&&
name|has_denorm
operator|==
name|denorm_present
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_float_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|__glibcpp_float_tinyness_before
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_to_nearest
block|;     }
block|;
undef|#
directive|undef
name|__glibcpp_float_has_denorm_loss
undef|#
directive|undef
name|__glibcpp_float_traps
undef|#
directive|undef
name|__glibcpp_float_tinyness_before
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|double
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|double
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__DBL_MIN__
return|;
block|}
specifier|static
name|double
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__DBL_MAX__
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__DBL_MANT_DIG__
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__DBL_DIG__
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|false
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
name|__FLT_RADIX__
block|;
specifier|static
name|double
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__DBL_EPSILON__
return|;
block|}
specifier|static
name|double
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0.5
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
name|__DBL_MIN_EXP__
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
name|__DBL_MIN_10_EXP__
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
name|__DBL_MAX_EXP__
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
name|__DBL_MAX_10_EXP__
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|__builtin_huge_val
argument_list|()
operator|/
literal|2
operator|==
name|__builtin_huge_val
argument_list|()
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|__builtin_nan
argument_list|(
literal|""
argument_list|)
operator|!=
name|__builtin_nan
argument_list|(
literal|""
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|has_quiet_NaN
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|__DBL_DENORM_MIN__
condition|?
name|denorm_present
else|:
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|__glibcpp_double_has_denorm_loss
block|;
specifier|static
name|double
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__builtin_huge_val
argument_list|()
return|;
block|}
specifier|static
name|double
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__builtin_nan
argument_list|(
literal|""
argument_list|)
return|;
block|}
specifier|static
name|double
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__builtin_nans
argument_list|(
literal|""
argument_list|)
return|;
block|}
specifier|static
name|double
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__DBL_DENORM_MIN__
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|has_infinity
operator|&&
name|has_quiet_NaN
operator|&&
name|has_denorm
operator|==
name|denorm_present
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_double_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|__glibcpp_double_tinyness_before
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_to_nearest
block|;     }
block|;
undef|#
directive|undef
name|__glibcpp_double_has_denorm_loss
undef|#
directive|undef
name|__glibcpp_double_traps
undef|#
directive|undef
name|__glibcpp_double_tinyness_before
name|template
operator|<
operator|>
expr|struct
name|numeric_limits
operator|<
name|long
name|double
operator|>
block|{
specifier|static
specifier|const
name|bool
name|is_specialized
operator|=
name|true
block|;
specifier|static
name|long
name|double
name|min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__LDBL_MIN__
return|;
block|}
specifier|static
name|long
name|double
name|max
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__LDBL_MAX__
return|;
block|}
specifier|static
specifier|const
name|int
name|digits
operator|=
name|__LDBL_MANT_DIG__
block|;
specifier|static
specifier|const
name|int
name|digits10
operator|=
name|__LDBL_DIG__
block|;
specifier|static
specifier|const
name|bool
name|is_signed
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_integer
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|is_exact
operator|=
name|false
block|;
specifier|static
specifier|const
name|int
name|radix
operator|=
name|__FLT_RADIX__
block|;
specifier|static
name|long
name|double
name|epsilon
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__LDBL_EPSILON__
return|;
block|}
specifier|static
name|long
name|double
name|round_error
argument_list|()
name|throw
argument_list|()
block|{
return|return
literal|0.5L
return|;
block|}
specifier|static
specifier|const
name|int
name|min_exponent
operator|=
name|__LDBL_MIN_EXP__
block|;
specifier|static
specifier|const
name|int
name|min_exponent10
operator|=
name|__LDBL_MIN_10_EXP__
block|;
specifier|static
specifier|const
name|int
name|max_exponent
operator|=
name|__LDBL_MAX_EXP__
block|;
specifier|static
specifier|const
name|int
name|max_exponent10
operator|=
name|__LDBL_MAX_10_EXP__
block|;
specifier|static
specifier|const
name|bool
name|has_infinity
operator|=
name|__builtin_huge_vall
argument_list|()
operator|/
literal|2
operator|==
name|__builtin_huge_vall
argument_list|()
block|;
specifier|static
specifier|const
name|bool
name|has_quiet_NaN
operator|=
name|__builtin_nanl
argument_list|(
literal|""
argument_list|)
operator|!=
name|__builtin_nanl
argument_list|(
literal|""
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|has_signaling_NaN
operator|=
name|has_quiet_NaN
block|;
specifier|static
specifier|const
name|float_denorm_style
name|has_denorm
operator|=
name|__LDBL_DENORM_MIN__
condition|?
name|denorm_present
else|:
name|denorm_absent
block|;
specifier|static
specifier|const
name|bool
name|has_denorm_loss
operator|=
name|__glibcpp_long_double_has_denorm_loss
block|;
specifier|static
name|long
name|double
name|infinity
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__builtin_huge_vall
argument_list|()
return|;
block|}
specifier|static
name|long
name|double
name|quiet_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__builtin_nanl
argument_list|(
literal|""
argument_list|)
return|;
block|}
specifier|static
name|long
name|double
name|signaling_NaN
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__builtin_nansl
argument_list|(
literal|""
argument_list|)
return|;
block|}
specifier|static
name|long
name|double
name|denorm_min
argument_list|()
name|throw
argument_list|()
block|{
return|return
name|__LDBL_DENORM_MIN__
return|;
block|}
specifier|static
specifier|const
name|bool
name|is_iec559
operator|=
name|has_infinity
operator|&&
name|has_quiet_NaN
operator|&&
name|has_denorm
operator|==
name|denorm_present
block|;
specifier|static
specifier|const
name|bool
name|is_bounded
operator|=
name|true
block|;
specifier|static
specifier|const
name|bool
name|is_modulo
operator|=
name|false
block|;
specifier|static
specifier|const
name|bool
name|traps
operator|=
name|__glibcpp_long_double_traps
block|;
specifier|static
specifier|const
name|bool
name|tinyness_before
operator|=
name|__glibcpp_long_double_tinyness_before
block|;
specifier|static
specifier|const
name|float_round_style
name|round_style
operator|=
name|round_to_nearest
block|;     }
block|;
undef|#
directive|undef
name|__glibcpp_long_double_has_denorm_loss
undef|#
directive|undef
name|__glibcpp_long_double_traps
undef|#
directive|undef
name|__glibcpp_long_double_tinyness_before
block|}
end_decl_stmt

begin_comment
comment|// namespace std
end_comment

begin_undef
undef|#
directive|undef
name|__glibcpp_signed
end_undef

begin_undef
undef|#
directive|undef
name|__glibcpp_min
end_undef

begin_undef
undef|#
directive|undef
name|__glibcpp_max
end_undef

begin_undef
undef|#
directive|undef
name|__glibcpp_digits
end_undef

begin_undef
undef|#
directive|undef
name|__glibcpp_digits10
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// _CPP_NUMERIC_LIMITS
end_comment

end_unit

