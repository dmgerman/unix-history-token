begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1996  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/* NOTE: This is an internal header file, included by other STL headers.  *   You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__SGI_STL_INTERNAL_FUNCTION_H
end_ifndef

begin_define
define|#
directive|define
name|__SGI_STL_INTERNAL_FUNCTION_H
end_define

begin_expr_stmt
name|__STL_BEGIN_NAMESPACE
name|template
operator|<
name|class
name|Arg
operator|,
name|class
name|Result
operator|>
expr|struct
name|unary_function
block|{
typedef|typedef
name|Arg
name|argument_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|Result
name|result_type
typedef|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Result
operator|>
expr|struct
name|binary_function
block|{
typedef|typedef
name|Arg1
name|first_argument_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|Arg2
name|second_argument_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Result
name|result_type
typedef|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|plus
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|+
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|minus
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|-
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|multiplies
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|*
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|divides
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|/
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|T
name|identity_element
argument_list|(
argument|plus<T>
argument_list|)
block|{
return|return
name|T
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|T
name|identity_element
argument_list|(
argument|multiplies<T>
argument_list|)
block|{
return|return
name|T
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|modulus
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|%
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|negate
operator|:
name|public
name|unary_function
operator|<
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|-
name|x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|equal_to
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|==
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|not_equal_to
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|!=
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|greater
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|>
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|less
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|<
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|greater_equal
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|>=
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|less_equal
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|<=
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|logical_and
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|&&
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|logical_or
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|||
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|logical_not
operator|:
name|public
name|unary_function
operator|<
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Predicate
operator|>
name|class
name|unary_negate
operator|:
name|public
name|unary_function
operator|<
name|typename
name|Predicate
operator|::
name|argument_type
operator|,
name|bool
operator|>
block|{
name|protected
operator|:
name|Predicate
name|pred
block|;
name|public
operator|:
name|explicit
name|unary_negate
argument_list|(
specifier|const
name|Predicate
operator|&
name|x
argument_list|)
operator|:
name|pred
argument_list|(
argument|x
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|Predicate
operator|::
name|argument_type
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|pred
argument_list|(
name|x
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Predicate
operator|>
specifier|inline
name|unary_negate
operator|<
name|Predicate
operator|>
name|not1
argument_list|(
argument|const Predicate& pred
argument_list|)
block|{
return|return
name|unary_negate
operator|<
name|Predicate
operator|>
operator|(
name|pred
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Predicate
operator|>
name|class
name|binary_negate
operator|:
name|public
name|binary_function
operator|<
name|typename
name|Predicate
operator|::
name|first_argument_type
operator|,
name|typename
name|Predicate
operator|::
name|second_argument_type
operator|,
name|bool
operator|>
block|{
name|protected
operator|:
name|Predicate
name|pred
block|;
name|public
operator|:
name|explicit
name|binary_negate
argument_list|(
specifier|const
name|Predicate
operator|&
name|x
argument_list|)
operator|:
name|pred
argument_list|(
argument|x
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|Predicate
operator|::
name|first_argument_type
operator|&
name|x
operator|,
specifier|const
name|typename
name|Predicate
operator|::
name|second_argument_type
operator|&
name|y
operator|)
specifier|const
block|{
return|return
operator|!
name|pred
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Predicate
operator|>
specifier|inline
name|binary_negate
operator|<
name|Predicate
operator|>
name|not2
argument_list|(
argument|const Predicate& pred
argument_list|)
block|{
return|return
name|binary_negate
operator|<
name|Predicate
operator|>
operator|(
name|pred
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Operation
operator|>
name|class
name|binder1st
operator|:
name|public
name|unary_function
operator|<
name|typename
name|Operation
operator|::
name|second_argument_type
operator|,
name|typename
name|Operation
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|Operation
name|op
block|;
name|typename
name|Operation
operator|::
name|first_argument_type
name|value
block|;
name|public
operator|:
name|binder1st
argument_list|(
argument|const Operation& x
argument_list|,
argument|const typename Operation::first_argument_type& y
argument_list|)
operator|:
name|op
argument_list|(
name|x
argument_list|)
block|,
name|value
argument_list|(
argument|y
argument_list|)
block|{}
name|typename
name|Operation
operator|::
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|Operation
operator|::
name|second_argument_type
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|op
argument_list|(
name|value
argument_list|,
name|x
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Operation
operator|,
name|class
name|T
operator|>
specifier|inline
name|binder1st
operator|<
name|Operation
operator|>
name|bind1st
argument_list|(
argument|const Operation& op
argument_list|,
argument|const T& x
argument_list|)
block|{
typedef|typedef
name|typename
name|Operation
operator|::
name|first_argument_type
name|arg1_type
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|binder1st
operator|<
name|Operation
operator|>
operator|(
name|op
operator|,
name|arg1_type
argument_list|(
name|x
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Operation
operator|>
name|class
name|binder2nd
operator|:
name|public
name|unary_function
operator|<
name|typename
name|Operation
operator|::
name|first_argument_type
operator|,
name|typename
name|Operation
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|Operation
name|op
block|;
name|typename
name|Operation
operator|::
name|second_argument_type
name|value
block|;
name|public
operator|:
name|binder2nd
argument_list|(
argument|const Operation& x
argument_list|,
argument|const typename Operation::second_argument_type& y
argument_list|)
operator|:
name|op
argument_list|(
name|x
argument_list|)
block|,
name|value
argument_list|(
argument|y
argument_list|)
block|{}
name|typename
name|Operation
operator|::
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|Operation
operator|::
name|first_argument_type
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|op
argument_list|(
name|x
argument_list|,
name|value
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Operation
operator|,
name|class
name|T
operator|>
specifier|inline
name|binder2nd
operator|<
name|Operation
operator|>
name|bind2nd
argument_list|(
argument|const Operation& op
argument_list|,
argument|const T& x
argument_list|)
block|{
typedef|typedef
name|typename
name|Operation
operator|::
name|second_argument_type
name|arg2_type
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|binder2nd
operator|<
name|Operation
operator|>
operator|(
name|op
operator|,
name|arg2_type
argument_list|(
name|x
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Operation1
operator|,
name|class
name|Operation2
operator|>
name|class
name|unary_compose
operator|:
name|public
name|unary_function
operator|<
name|typename
name|Operation2
operator|::
name|argument_type
operator|,
name|typename
name|Operation1
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|Operation1
name|op1
block|;
name|Operation2
name|op2
block|;
name|public
operator|:
name|unary_compose
argument_list|(
specifier|const
name|Operation1
operator|&
name|x
argument_list|,
specifier|const
name|Operation2
operator|&
name|y
argument_list|)
operator|:
name|op1
argument_list|(
name|x
argument_list|)
block|,
name|op2
argument_list|(
argument|y
argument_list|)
block|{}
name|typename
name|Operation1
operator|::
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|Operation2
operator|::
name|argument_type
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|op1
argument_list|(
name|op2
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Operation1
operator|,
name|class
name|Operation2
operator|>
specifier|inline
name|unary_compose
operator|<
name|Operation1
operator|,
name|Operation2
operator|>
name|compose1
argument_list|(
argument|const Operation1& op1
argument_list|,
argument|const Operation2& op2
argument_list|)
block|{
return|return
name|unary_compose
operator|<
name|Operation1
operator|,
name|Operation2
operator|>
operator|(
name|op1
operator|,
name|op2
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Operation1
operator|,
name|class
name|Operation2
operator|,
name|class
name|Operation3
operator|>
name|class
name|binary_compose
operator|:
name|public
name|unary_function
operator|<
name|typename
name|Operation2
operator|::
name|argument_type
operator|,
name|typename
name|Operation1
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|Operation1
name|op1
block|;
name|Operation2
name|op2
block|;
name|Operation3
name|op3
block|;
name|public
operator|:
name|binary_compose
argument_list|(
specifier|const
name|Operation1
operator|&
name|x
argument_list|,
specifier|const
name|Operation2
operator|&
name|y
argument_list|,
specifier|const
name|Operation3
operator|&
name|z
argument_list|)
operator|:
name|op1
argument_list|(
name|x
argument_list|)
block|,
name|op2
argument_list|(
name|y
argument_list|)
block|,
name|op3
argument_list|(
argument|z
argument_list|)
block|{ }
name|typename
name|Operation1
operator|::
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|Operation2
operator|::
name|argument_type
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|op1
argument_list|(
name|op2
argument_list|(
name|x
argument_list|)
argument_list|,
name|op3
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Operation1
operator|,
name|class
name|Operation2
operator|,
name|class
name|Operation3
operator|>
specifier|inline
name|binary_compose
operator|<
name|Operation1
operator|,
name|Operation2
operator|,
name|Operation3
operator|>
name|compose2
argument_list|(
argument|const Operation1& op1
argument_list|,
argument|const Operation2& op2
argument_list|,
argument|const Operation3& op3
argument_list|)
block|{
return|return
name|binary_compose
operator|<
name|Operation1
operator|,
name|Operation2
operator|,
name|Operation3
operator|>
operator|(
name|op1
operator|,
name|op2
operator|,
name|op3
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Arg
operator|,
name|class
name|Result
operator|>
name|class
name|pointer_to_unary_function
operator|:
name|public
name|unary_function
operator|<
name|Arg
operator|,
name|Result
operator|>
block|{
name|protected
operator|:
name|Result
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|(
name|Arg
argument_list|)
block|;
name|public
operator|:
name|pointer_to_unary_function
argument_list|()
block|{}
name|explicit
name|pointer_to_unary_function
argument_list|(
name|Result
argument_list|(
operator|*
name|x
argument_list|)
argument_list|(
name|Arg
argument_list|)
argument_list|)
operator|:
name|ptr
argument_list|(
argument|x
argument_list|)
block|{}
name|Result
name|operator
argument_list|()
operator|(
name|Arg
name|x
operator|)
specifier|const
block|{
return|return
name|ptr
argument_list|(
name|x
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Arg
operator|,
name|class
name|Result
operator|>
specifier|inline
name|pointer_to_unary_function
operator|<
name|Arg
operator|,
name|Result
operator|>
name|ptr_fun
argument_list|(
argument|Result (*x)(Arg)
argument_list|)
block|{
return|return
name|pointer_to_unary_function
operator|<
name|Arg
operator|,
name|Result
operator|>
operator|(
name|x
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Result
operator|>
name|class
name|pointer_to_binary_function
operator|:
name|public
name|binary_function
operator|<
name|Arg1
operator|,
name|Arg2
operator|,
name|Result
operator|>
block|{
name|protected
operator|:
name|Result
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|(
name|Arg1
argument_list|,
name|Arg2
argument_list|)
block|;
name|public
operator|:
name|pointer_to_binary_function
argument_list|()
block|{}
name|explicit
name|pointer_to_binary_function
argument_list|(
name|Result
argument_list|(
operator|*
name|x
argument_list|)
argument_list|(
name|Arg1
argument_list|,
name|Arg2
argument_list|)
argument_list|)
operator|:
name|ptr
argument_list|(
argument|x
argument_list|)
block|{}
name|Result
name|operator
argument_list|()
operator|(
name|Arg1
name|x
operator|,
name|Arg2
name|y
operator|)
specifier|const
block|{
return|return
name|ptr
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Result
operator|>
specifier|inline
name|pointer_to_binary_function
operator|<
name|Arg1
operator|,
name|Arg2
operator|,
name|Result
operator|>
name|ptr_fun
argument_list|(
argument|Result (*x)(Arg1, Arg2)
argument_list|)
block|{
return|return
name|pointer_to_binary_function
operator|<
name|Arg1
operator|,
name|Arg2
operator|,
name|Result
operator|>
operator|(
name|x
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|identity
operator|:
name|public
name|unary_function
operator|<
name|T
operator|,
name|T
operator|>
block|{
specifier|const
name|T
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Pair
operator|>
expr|struct
name|select1st
operator|:
name|public
name|unary_function
operator|<
name|Pair
operator|,
name|typename
name|Pair
operator|::
name|first_type
operator|>
block|{
specifier|const
name|typename
name|Pair
operator|::
name|first_type
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|Pair
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|x
operator|.
name|first
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Pair
operator|>
expr|struct
name|select2nd
operator|:
name|public
name|unary_function
operator|<
name|Pair
operator|,
name|typename
name|Pair
operator|::
name|second_type
operator|>
block|{
specifier|const
name|typename
name|Pair
operator|::
name|second_type
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|Pair
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|x
operator|.
name|second
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|>
expr|struct
name|project1st
operator|:
name|public
name|binary_function
operator|<
name|Arg1
operator|,
name|Arg2
operator|,
name|Arg1
operator|>
block|{
name|Arg1
name|operator
argument_list|()
operator|(
specifier|const
name|Arg1
operator|&
name|x
operator|,
specifier|const
name|Arg2
operator|&
operator|)
specifier|const
block|{
return|return
name|x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|>
expr|struct
name|project2nd
operator|:
name|public
name|binary_function
operator|<
name|Arg1
operator|,
name|Arg2
operator|,
name|Arg2
operator|>
block|{
name|Arg2
name|operator
argument_list|()
operator|(
specifier|const
name|Arg1
operator|&
operator|,
specifier|const
name|Arg2
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Result
operator|>
expr|struct
name|constant_void_fun
block|{
typedef|typedef
name|Result
name|result_type
typedef|;
name|result_type
name|val
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|constant_void_fun
argument_list|(
specifier|const
name|result_type
operator|&
name|v
argument_list|)
operator|:
name|val
argument_list|(
argument|v
argument_list|)
block|{}
specifier|const
name|result_type
operator|&
name|operator
argument_list|()
operator|(
operator|)
specifier|const
block|{
return|return
name|val
return|;
block|}
end_expr_stmt

begin_ifndef
unit|};
ifndef|#
directive|ifndef
name|__STL_LIMITED_DEFAULT_TEMPLATES
end_ifndef

begin_expr_stmt
name|template
operator|<
name|class
name|Result
operator|,
name|class
name|Argument
operator|=
name|Result
operator|>
else|#
directive|else
name|template
operator|<
name|class
name|Result
operator|,
name|class
name|Argument
operator|>
endif|#
directive|endif
expr|struct
name|constant_unary_fun
operator|:
name|public
name|unary_function
operator|<
name|Argument
operator|,
name|Result
operator|>
block|{
name|Result
name|val
block|;
name|constant_unary_fun
argument_list|(
specifier|const
name|Result
operator|&
name|v
argument_list|)
operator|:
name|val
argument_list|(
argument|v
argument_list|)
block|{}
specifier|const
name|Result
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|Argument
operator|&
operator|)
specifier|const
block|{
return|return
name|val
return|;
block|}
end_expr_stmt

begin_ifndef
unit|};
ifndef|#
directive|ifndef
name|__STL_LIMITED_DEFAULT_TEMPLATES
end_ifndef

begin_expr_stmt
name|template
operator|<
name|class
name|Result
operator|,
name|class
name|Arg1
operator|=
name|Result
operator|,
name|class
name|Arg2
operator|=
name|Arg1
operator|>
else|#
directive|else
name|template
operator|<
name|class
name|Result
operator|,
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|>
endif|#
directive|endif
expr|struct
name|constant_binary_fun
operator|:
name|public
name|binary_function
operator|<
name|Arg1
operator|,
name|Arg2
operator|,
name|Result
operator|>
block|{
name|Result
name|val
block|;
name|constant_binary_fun
argument_list|(
specifier|const
name|Result
operator|&
name|v
argument_list|)
operator|:
name|val
argument_list|(
argument|v
argument_list|)
block|{}
specifier|const
name|Result
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|Arg1
operator|&
operator|,
specifier|const
name|Arg2
operator|&
operator|)
specifier|const
block|{
return|return
name|val
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Result
operator|>
specifier|inline
name|constant_void_fun
operator|<
name|Result
operator|>
name|constant0
argument_list|(
argument|const Result& val
argument_list|)
block|{
return|return
name|constant_void_fun
operator|<
name|Result
operator|>
operator|(
name|val
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Result
operator|>
specifier|inline
name|constant_unary_fun
operator|<
name|Result
operator|,
name|Result
operator|>
name|constant1
argument_list|(
argument|const Result& val
argument_list|)
block|{
return|return
name|constant_unary_fun
operator|<
name|Result
operator|,
name|Result
operator|>
operator|(
name|val
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Result
operator|>
specifier|inline
name|constant_binary_fun
operator|<
name|Result
operator|,
name|Result
operator|,
name|Result
operator|>
name|constant2
argument_list|(
argument|const Result& val
argument_list|)
block|{
return|return
name|constant_binary_fun
operator|<
name|Result
operator|,
name|Result
operator|,
name|Result
operator|>
operator|(
name|val
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Note: this code assumes that int is 32 bits.
end_comment

begin_decl_stmt
name|class
name|subtractive_rng
range|:
name|public
name|unary_function
operator|<
name|unsigned
name|int
decl_stmt|,
name|unsigned
name|int
decl|>
block|{
name|private
label|:
name|unsigned
name|int
name|table
index|[
literal|55
index|]
decl_stmt|;
name|size_t
name|index1
decl_stmt|;
name|size_t
name|index2
decl_stmt|;
name|public
label|:
name|unsigned
name|int
name|operator
argument_list|()
operator|(
name|unsigned
name|int
name|limit
operator|)
block|{
name|index1
operator|=
operator|(
name|index1
operator|+
literal|1
operator|)
operator|%
literal|55
block|;
name|index2
operator|=
operator|(
name|index2
operator|+
literal|1
operator|)
operator|%
literal|55
block|;
name|table
index|[
name|index1
index|]
operator|=
name|table
index|[
name|index1
index|]
operator|-
name|table
index|[
name|index2
index|]
block|;
return|return
name|table
index|[
name|index1
index|]
operator|%
name|limit
return|;
block|}
name|void
name|initialize
parameter_list|(
name|unsigned
name|int
name|seed
parameter_list|)
block|{
name|unsigned
name|int
name|k
init|=
literal|1
decl_stmt|;
name|table
index|[
literal|54
index|]
operator|=
name|seed
expr_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|54
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|ii
init|=
operator|(
literal|21
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|55
operator|)
operator|-
literal|1
decl_stmt|;
name|table
index|[
name|ii
index|]
operator|=
name|k
expr_stmt|;
name|k
operator|=
name|seed
operator|-
name|k
expr_stmt|;
name|seed
operator|=
name|table
index|[
name|ii
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|loop
init|=
literal|0
init|;
name|loop
operator|<
literal|4
condition|;
name|loop
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|55
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
name|table
index|[
name|i
index|]
operator|-
name|table
index|[
operator|(
literal|1
operator|+
name|i
operator|+
literal|30
operator|)
operator|%
literal|55
index|]
expr_stmt|;
block|}
name|index1
operator|=
literal|0
expr_stmt|;
name|index2
operator|=
literal|31
expr_stmt|;
block|}
name|subtractive_rng
argument_list|(
argument|unsigned int seed
argument_list|)
block|{
name|initialize
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
name|subtractive_rng
argument_list|()
block|{
name|initialize
argument_list|(
literal|161803398u
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Adaptor function objects: pointers to member functions.
end_comment

begin_comment
comment|// There are a total of 16 = 2^4 function objects in this family.
end_comment

begin_comment
comment|//  (1) Member functions taking no arguments vs member functions taking
end_comment

begin_comment
comment|//       one argument.
end_comment

begin_comment
comment|//  (2) Call through pointer vs call through reference.
end_comment

begin_comment
comment|//  (3) Member function with void return type vs member function with
end_comment

begin_comment
comment|//      non-void return type.
end_comment

begin_comment
comment|//  (4) Const vs non-const member function.
end_comment

begin_comment
comment|// Note that choice (4) is not present in the 8/97 draft C++ standard,
end_comment

begin_comment
comment|//  which only allows these adaptors to be used with non-const functions.
end_comment

begin_comment
comment|//  This is likely to be recified before the standard becomes final.
end_comment

begin_comment
comment|// Note also that choice (3) is nothing more than a workaround: according
end_comment

begin_comment
comment|//  to the draft, compilers should handle void and non-void the same way.
end_comment

begin_comment
comment|//  This feature is not yet widely implemented, though.  You can only use
end_comment

begin_comment
comment|//  member functions returning void if your compiler supports partial
end_comment

begin_comment
comment|//  specialization.
end_comment

begin_comment
comment|// All of this complexity is in the function objects themselves.  You can
end_comment

begin_comment
comment|//  ignore it by using the helper function mem_fun, mem_fun_ref,
end_comment

begin_comment
comment|//  mem_fun1, and mem_fun1_ref, which create whichever type of adaptor
end_comment

begin_comment
comment|//  is appropriate.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|>
name|class
name|mem_fun_t
operator|:
name|public
name|unary_function
operator|<
name|T
operator|*
operator|,
name|S
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_t
argument_list|(
name|S
argument_list|(
name|T
operator|::
operator|*
name|pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|S
name|operator
argument_list|()
operator|(
name|T
operator|*
name|p
operator|)
specifier|const
block|{
return|return
operator|(
name|p
operator|->*
name|f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|S
argument_list|(
name|T
operator|::
operator|*
name|f
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|>
name|class
name|const_mem_fun_t
operator|:
name|public
name|unary_function
operator|<
specifier|const
name|T
operator|*
operator|,
name|S
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_t
argument_list|(
name|S
argument_list|(
argument|T::*pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|S
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|*
name|p
operator|)
specifier|const
block|{
return|return
operator|(
name|p
operator|->*
name|f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|S
argument_list|(
argument|T::*f
argument_list|)
operator|(
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|>
name|class
name|mem_fun_ref_t
operator|:
name|public
name|unary_function
operator|<
name|T
operator|,
name|S
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_ref_t
argument_list|(
name|S
argument_list|(
name|T
operator|::
operator|*
name|pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|S
name|operator
argument_list|()
operator|(
name|T
operator|&
name|r
operator|)
specifier|const
block|{
return|return
operator|(
name|r
operator|.*
name|f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|S
argument_list|(
name|T
operator|::
operator|*
name|f
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|>
name|class
name|const_mem_fun_ref_t
operator|:
name|public
name|unary_function
operator|<
name|T
operator|,
name|S
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_ref_t
argument_list|(
name|S
argument_list|(
argument|T::*pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|S
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|r
operator|)
specifier|const
block|{
return|return
operator|(
name|r
operator|.*
name|f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|S
argument_list|(
argument|T::*f
argument_list|)
operator|(
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|,
name|class
name|A
operator|>
name|class
name|mem_fun1_t
operator|:
name|public
name|binary_function
operator|<
name|T
operator|*
operator|,
name|A
operator|,
name|S
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_t
argument_list|(
name|S
argument_list|(
name|T
operator|::
operator|*
name|pf
argument_list|)
argument_list|(
name|A
argument_list|)
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|S
name|operator
argument_list|()
operator|(
name|T
operator|*
name|p
operator|,
name|A
name|x
operator|)
specifier|const
block|{
return|return
operator|(
name|p
operator|->*
name|f
operator|)
operator|(
name|x
operator|)
return|;
block|}
name|private
operator|:
name|S
argument_list|(
name|T
operator|::
operator|*
name|f
argument_list|)
argument_list|(
name|A
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|,
name|class
name|A
operator|>
name|class
name|const_mem_fun1_t
operator|:
name|public
name|binary_function
operator|<
specifier|const
name|T
operator|*
operator|,
name|A
operator|,
name|S
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_t
argument_list|(
name|S
argument_list|(
argument|T::*pf
argument_list|)
operator|(
name|A
operator|)
specifier|const
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|S
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|*
name|p
operator|,
name|A
name|x
operator|)
specifier|const
block|{
return|return
operator|(
name|p
operator|->*
name|f
operator|)
operator|(
name|x
operator|)
return|;
block|}
name|private
operator|:
name|S
argument_list|(
argument|T::*f
argument_list|)
operator|(
name|A
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|,
name|class
name|A
operator|>
name|class
name|mem_fun1_ref_t
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|A
operator|,
name|S
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_ref_t
argument_list|(
name|S
argument_list|(
name|T
operator|::
operator|*
name|pf
argument_list|)
argument_list|(
name|A
argument_list|)
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|S
name|operator
argument_list|()
operator|(
name|T
operator|&
name|r
operator|,
name|A
name|x
operator|)
specifier|const
block|{
return|return
operator|(
name|r
operator|.*
name|f
operator|)
operator|(
name|x
operator|)
return|;
block|}
name|private
operator|:
name|S
argument_list|(
name|T
operator|::
operator|*
name|f
argument_list|)
argument_list|(
name|A
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|,
name|class
name|A
operator|>
name|class
name|const_mem_fun1_ref_t
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|A
operator|,
name|S
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_ref_t
argument_list|(
name|S
argument_list|(
argument|T::*pf
argument_list|)
operator|(
name|A
operator|)
specifier|const
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|S
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|r
operator|,
name|A
name|x
operator|)
specifier|const
block|{
return|return
operator|(
name|r
operator|.*
name|f
operator|)
operator|(
name|x
operator|)
return|;
block|}
name|private
operator|:
name|S
argument_list|(
argument|T::*f
argument_list|)
operator|(
name|A
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_ifdef
unit|};
ifdef|#
directive|ifdef
name|__STL_CLASS_PARTIAL_SPECIALIZATION
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|class
name|mem_fun_t
operator|<
name|void
operator|,
name|T
operator|>
operator|:
name|public
name|unary_function
operator|<
name|T
operator|*
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_t
argument_list|(
name|void
argument_list|(
name|T
operator|::
operator|*
name|pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|T
operator|*
name|p
operator|)
specifier|const
block|{
operator|(
name|p
operator|->*
name|f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|T
operator|::
operator|*
name|f
argument_list|)
argument_list|()
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|class
name|const_mem_fun_t
operator|<
name|void
operator|,
name|T
operator|>
operator|:
name|public
name|unary_function
operator|<
specifier|const
name|T
operator|*
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_t
argument_list|(
name|void
argument_list|(
argument|T::*pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|*
name|p
operator|)
specifier|const
block|{
operator|(
name|p
operator|->*
name|f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|T::*f
argument_list|)
operator|(
operator|)
specifier|const
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|class
name|mem_fun_ref_t
operator|<
name|void
operator|,
name|T
operator|>
operator|:
name|public
name|unary_function
operator|<
name|T
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_ref_t
argument_list|(
name|void
argument_list|(
name|T
operator|::
operator|*
name|pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|T
operator|&
name|r
operator|)
specifier|const
block|{
operator|(
name|r
operator|.*
name|f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|T
operator|::
operator|*
name|f
argument_list|)
argument_list|()
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
name|class
name|const_mem_fun_ref_t
operator|<
name|void
operator|,
name|T
operator|>
operator|:
name|public
name|unary_function
operator|<
name|T
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_ref_t
argument_list|(
name|void
argument_list|(
argument|T::*pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|r
operator|)
specifier|const
block|{
operator|(
name|r
operator|.*
name|f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|T::*f
argument_list|)
operator|(
operator|)
specifier|const
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|A
operator|>
name|class
name|mem_fun1_t
operator|<
name|void
operator|,
name|T
operator|,
name|A
operator|>
operator|:
name|public
name|binary_function
operator|<
name|T
operator|*
operator|,
name|A
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_t
argument_list|(
name|void
argument_list|(
name|T
operator|::
operator|*
name|pf
argument_list|)
argument_list|(
name|A
argument_list|)
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|T
operator|*
name|p
operator|,
name|A
name|x
operator|)
specifier|const
block|{
operator|(
name|p
operator|->*
name|f
operator|)
operator|(
name|x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|T
operator|::
operator|*
name|f
argument_list|)
argument_list|(
name|A
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|A
operator|>
name|class
name|const_mem_fun1_t
operator|<
name|void
operator|,
name|T
operator|,
name|A
operator|>
operator|:
name|public
name|binary_function
operator|<
specifier|const
name|T
operator|*
operator|,
name|A
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_t
argument_list|(
name|void
argument_list|(
argument|T::*pf
argument_list|)
operator|(
name|A
operator|)
specifier|const
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|*
name|p
operator|,
name|A
name|x
operator|)
specifier|const
block|{
operator|(
name|p
operator|->*
name|f
operator|)
operator|(
name|x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|T::*f
argument_list|)
operator|(
name|A
operator|)
specifier|const
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|A
operator|>
name|class
name|mem_fun1_ref_t
operator|<
name|void
operator|,
name|T
operator|,
name|A
operator|>
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|A
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_ref_t
argument_list|(
name|void
argument_list|(
name|T
operator|::
operator|*
name|pf
argument_list|)
argument_list|(
name|A
argument_list|)
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|T
operator|&
name|r
operator|,
name|A
name|x
operator|)
specifier|const
block|{
operator|(
name|r
operator|.*
name|f
operator|)
operator|(
name|x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|T
operator|::
operator|*
name|f
argument_list|)
argument_list|(
name|A
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|A
operator|>
name|class
name|const_mem_fun1_ref_t
operator|<
name|void
operator|,
name|T
operator|,
name|A
operator|>
operator|:
name|public
name|binary_function
operator|<
name|T
operator|,
name|A
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_ref_t
argument_list|(
name|void
argument_list|(
argument|T::*pf
argument_list|)
operator|(
name|A
operator|)
specifier|const
argument_list|)
operator|:
name|f
argument_list|(
argument|pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|r
operator|,
name|A
name|x
operator|)
specifier|const
block|{
operator|(
name|r
operator|.*
name|f
operator|)
operator|(
name|x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|T::*f
argument_list|)
operator|(
name|A
operator|)
specifier|const
block|; }
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_comment
comment|// Mem_fun adaptor helper functions.  There are only four:
end_comment

begin_comment
comment|//  mem_fun, mem_fun_ref, mem_fun1, mem_fun1_ref.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|>
specifier|inline
name|mem_fun_t
operator|<
name|S
operator|,
name|T
operator|>
name|mem_fun
argument_list|(
argument|S (T::*f)()
argument_list|)
block|{
return|return
name|mem_fun_t
operator|<
name|S
operator|,
name|T
operator|>
operator|(
name|f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|>
specifier|inline
name|const_mem_fun_t
operator|<
name|S
operator|,
name|T
operator|>
name|mem_fun
argument_list|(
argument|S (T::*f)() const
argument_list|)
block|{
return|return
name|const_mem_fun_t
operator|<
name|S
operator|,
name|T
operator|>
operator|(
name|f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|>
specifier|inline
name|mem_fun_ref_t
operator|<
name|S
operator|,
name|T
operator|>
name|mem_fun_ref
argument_list|(
argument|S (T::*f)()
argument_list|)
block|{
return|return
name|mem_fun_ref_t
operator|<
name|S
operator|,
name|T
operator|>
operator|(
name|f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|>
specifier|inline
name|const_mem_fun_ref_t
operator|<
name|S
operator|,
name|T
operator|>
name|mem_fun_ref
argument_list|(
argument|S (T::*f)() const
argument_list|)
block|{
return|return
name|const_mem_fun_ref_t
operator|<
name|S
operator|,
name|T
operator|>
operator|(
name|f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|,
name|class
name|A
operator|>
specifier|inline
name|mem_fun1_t
operator|<
name|S
operator|,
name|T
operator|,
name|A
operator|>
name|mem_fun1
argument_list|(
argument|S (T::*f)(A)
argument_list|)
block|{
return|return
name|mem_fun1_t
operator|<
name|S
operator|,
name|T
operator|,
name|A
operator|>
operator|(
name|f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|,
name|class
name|A
operator|>
specifier|inline
name|const_mem_fun1_t
operator|<
name|S
operator|,
name|T
operator|,
name|A
operator|>
name|mem_fun1
argument_list|(
argument|S (T::*f)(A) const
argument_list|)
block|{
return|return
name|const_mem_fun1_t
operator|<
name|S
operator|,
name|T
operator|,
name|A
operator|>
operator|(
name|f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|,
name|class
name|A
operator|>
specifier|inline
name|mem_fun1_ref_t
operator|<
name|S
operator|,
name|T
operator|,
name|A
operator|>
name|mem_fun1_ref
argument_list|(
argument|S (T::*f)(A)
argument_list|)
block|{
return|return
name|mem_fun1_ref_t
operator|<
name|S
operator|,
name|T
operator|,
name|A
operator|>
operator|(
name|f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|S
operator|,
name|class
name|T
operator|,
name|class
name|A
operator|>
specifier|inline
name|const_mem_fun1_ref_t
operator|<
name|S
operator|,
name|T
operator|,
name|A
operator|>
name|mem_fun1_ref
argument_list|(
argument|S (T::*f)(A) const
argument_list|)
block|{
return|return
name|const_mem_fun1_ref_t
operator|<
name|S
operator|,
name|T
operator|,
name|A
operator|>
operator|(
name|f
operator|)
return|;
block|}
end_expr_stmt

begin_macro
name|__STL_END_NAMESPACE
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SGI_STL_INTERNAL_FUNCTION_H */
end_comment

begin_comment
comment|// Local Variables:
end_comment

begin_comment
comment|// mode:C++
end_comment

begin_comment
comment|// End:
end_comment

end_unit

