begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1996-1998  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/* NOTE: This is an internal header file, included by other STL headers.  *   You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__SGI_STL_INTERNAL_FUNCTION_H
end_ifndef

begin_define
define|#
directive|define
name|__SGI_STL_INTERNAL_FUNCTION_H
end_define

begin_expr_stmt
name|__STL_BEGIN_NAMESPACE
name|template
operator|<
name|class
name|_Arg
operator|,
name|class
name|_Result
operator|>
expr|struct
name|unary_function
block|{
typedef|typedef
name|_Arg
name|argument_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|_Result
name|result_type
typedef|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|,
name|class
name|_Result
operator|>
expr|struct
name|binary_function
block|{
typedef|typedef
name|_Arg1
name|first_argument_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|_Arg2
name|second_argument_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Result
name|result_type
typedef|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|plus
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|+
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|minus
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|-
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|multiplies
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|*
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|divides
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|/
name|__y
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// identity_element (not part of the C++ standard).
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
specifier|inline
name|_Tp
name|identity_element
argument_list|(
argument|plus<_Tp>
argument_list|)
block|{
return|return
name|_Tp
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
specifier|inline
name|_Tp
name|identity_element
argument_list|(
argument|multiplies<_Tp>
argument_list|)
block|{
return|return
name|_Tp
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|modulus
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|%
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|negate
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
block|{
name|_Tp
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
operator|-
name|__x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|equal_to
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|==
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|not_equal_to
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|!=
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|greater
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|>
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|less
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|<
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|greater_equal
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|>=
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|less_equal
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|<=
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|logical_and
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|&&
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|logical_or
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|,
specifier|const
name|_Tp
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__x
operator|||
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|logical_not
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
operator|!
name|__x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Predicate
operator|>
name|class
name|unary_negate
operator|:
name|public
name|unary_function
operator|<
name|typename
name|_Predicate
operator|::
name|argument_type
operator|,
name|bool
operator|>
block|{
name|protected
operator|:
name|_Predicate
name|_M_pred
block|;
name|public
operator|:
name|explicit
name|unary_negate
argument_list|(
specifier|const
name|_Predicate
operator|&
name|__x
argument_list|)
operator|:
name|_M_pred
argument_list|(
argument|__x
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|_Predicate
operator|::
name|argument_type
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
operator|!
name|_M_pred
argument_list|(
name|__x
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Predicate
operator|>
specifier|inline
name|unary_negate
operator|<
name|_Predicate
operator|>
name|not1
argument_list|(
argument|const _Predicate& __pred
argument_list|)
block|{
return|return
name|unary_negate
operator|<
name|_Predicate
operator|>
operator|(
name|__pred
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Predicate
operator|>
name|class
name|binary_negate
operator|:
name|public
name|binary_function
operator|<
name|typename
name|_Predicate
operator|::
name|first_argument_type
operator|,
name|typename
name|_Predicate
operator|::
name|second_argument_type
operator|,
name|bool
operator|>
block|{
name|protected
operator|:
name|_Predicate
name|_M_pred
block|;
name|public
operator|:
name|explicit
name|binary_negate
argument_list|(
specifier|const
name|_Predicate
operator|&
name|__x
argument_list|)
operator|:
name|_M_pred
argument_list|(
argument|__x
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|_Predicate
operator|::
name|first_argument_type
operator|&
name|__x
operator|,
specifier|const
name|typename
name|_Predicate
operator|::
name|second_argument_type
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
operator|!
name|_M_pred
argument_list|(
name|__x
argument_list|,
name|__y
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Predicate
operator|>
specifier|inline
name|binary_negate
operator|<
name|_Predicate
operator|>
name|not2
argument_list|(
argument|const _Predicate& __pred
argument_list|)
block|{
return|return
name|binary_negate
operator|<
name|_Predicate
operator|>
operator|(
name|__pred
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Operation
operator|>
name|class
name|binder1st
operator|:
name|public
name|unary_function
operator|<
name|typename
name|_Operation
operator|::
name|second_argument_type
operator|,
name|typename
name|_Operation
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|_Operation
name|op
block|;
name|typename
name|_Operation
operator|::
name|first_argument_type
name|value
block|;
name|public
operator|:
name|binder1st
argument_list|(
argument|const _Operation& __x
argument_list|,
argument|const typename _Operation::first_argument_type& __y
argument_list|)
operator|:
name|op
argument_list|(
name|__x
argument_list|)
block|,
name|value
argument_list|(
argument|__y
argument_list|)
block|{}
name|typename
name|_Operation
operator|::
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|_Operation
operator|::
name|second_argument_type
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|op
argument_list|(
name|value
argument_list|,
name|__x
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Operation
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|binder1st
operator|<
name|_Operation
operator|>
name|bind1st
argument_list|(
argument|const _Operation& __oper
argument_list|,
argument|const _Tp& __x
argument_list|)
block|{
typedef|typedef
name|typename
name|_Operation
operator|::
name|first_argument_type
name|_Arg1_type
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|binder1st
operator|<
name|_Operation
operator|>
operator|(
name|__oper
operator|,
name|_Arg1_type
argument_list|(
name|__x
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_Operation
operator|>
name|class
name|binder2nd
operator|:
name|public
name|unary_function
operator|<
name|typename
name|_Operation
operator|::
name|first_argument_type
operator|,
name|typename
name|_Operation
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|_Operation
name|op
block|;
name|typename
name|_Operation
operator|::
name|second_argument_type
name|value
block|;
name|public
operator|:
name|binder2nd
argument_list|(
argument|const _Operation& __x
argument_list|,
argument|const typename _Operation::second_argument_type& __y
argument_list|)
operator|:
name|op
argument_list|(
name|__x
argument_list|)
block|,
name|value
argument_list|(
argument|__y
argument_list|)
block|{}
name|typename
name|_Operation
operator|::
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|_Operation
operator|::
name|first_argument_type
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|op
argument_list|(
name|__x
argument_list|,
name|value
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Operation
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|binder2nd
operator|<
name|_Operation
operator|>
name|bind2nd
argument_list|(
argument|const _Operation& __oper
argument_list|,
argument|const _Tp& __x
argument_list|)
block|{
typedef|typedef
name|typename
name|_Operation
operator|::
name|second_argument_type
name|_Arg2_type
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|binder2nd
operator|<
name|_Operation
operator|>
operator|(
name|__oper
operator|,
name|_Arg2_type
argument_list|(
name|__x
argument_list|)
operator|)
return|;
end_return

begin_comment
unit|}
comment|// unary_compose and binary_compose (extensions, not part of the standard).
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_Operation1
operator|,
name|class
name|_Operation2
operator|>
name|class
name|unary_compose
operator|:
name|public
name|unary_function
operator|<
name|typename
name|_Operation2
operator|::
name|argument_type
operator|,
name|typename
name|_Operation1
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|_Operation1
name|__op1
block|;
name|_Operation2
name|__op2
block|;
name|public
operator|:
name|unary_compose
argument_list|(
specifier|const
name|_Operation1
operator|&
name|__x
argument_list|,
specifier|const
name|_Operation2
operator|&
name|__y
argument_list|)
operator|:
name|__op1
argument_list|(
name|__x
argument_list|)
block|,
name|__op2
argument_list|(
argument|__y
argument_list|)
block|{}
name|typename
name|_Operation1
operator|::
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|_Operation2
operator|::
name|argument_type
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|__op1
argument_list|(
name|__op2
argument_list|(
name|__x
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Operation1
operator|,
name|class
name|_Operation2
operator|>
specifier|inline
name|unary_compose
operator|<
name|_Operation1
operator|,
name|_Operation2
operator|>
name|compose1
argument_list|(
argument|const _Operation1& __op1
argument_list|,
argument|const _Operation2& __op2
argument_list|)
block|{
return|return
name|unary_compose
operator|<
name|_Operation1
operator|,
name|_Operation2
operator|>
operator|(
name|__op1
operator|,
name|__op2
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Operation1
operator|,
name|class
name|_Operation2
operator|,
name|class
name|_Operation3
operator|>
name|class
name|binary_compose
operator|:
name|public
name|unary_function
operator|<
name|typename
name|_Operation2
operator|::
name|argument_type
operator|,
name|typename
name|_Operation1
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|_Operation1
name|_M_op1
block|;
name|_Operation2
name|_M_op2
block|;
name|_Operation3
name|_M_op3
block|;
name|public
operator|:
name|binary_compose
argument_list|(
specifier|const
name|_Operation1
operator|&
name|__x
argument_list|,
specifier|const
name|_Operation2
operator|&
name|__y
argument_list|,
specifier|const
name|_Operation3
operator|&
name|__z
argument_list|)
operator|:
name|_M_op1
argument_list|(
name|__x
argument_list|)
block|,
name|_M_op2
argument_list|(
name|__y
argument_list|)
block|,
name|_M_op3
argument_list|(
argument|__z
argument_list|)
block|{ }
name|typename
name|_Operation1
operator|::
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|typename
name|_Operation2
operator|::
name|argument_type
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|_M_op1
argument_list|(
name|_M_op2
argument_list|(
name|__x
argument_list|)
argument_list|,
name|_M_op3
argument_list|(
name|__x
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Operation1
operator|,
name|class
name|_Operation2
operator|,
name|class
name|_Operation3
operator|>
specifier|inline
name|binary_compose
operator|<
name|_Operation1
operator|,
name|_Operation2
operator|,
name|_Operation3
operator|>
name|compose2
argument_list|(
argument|const _Operation1& __op1
argument_list|,
argument|const _Operation2& __op2
argument_list|,
argument|const _Operation3& __op3
argument_list|)
block|{
return|return
name|binary_compose
operator|<
name|_Operation1
operator|,
name|_Operation2
operator|,
name|_Operation3
operator|>
operator|(
name|__op1
operator|,
name|__op2
operator|,
name|__op3
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Arg
operator|,
name|class
name|_Result
operator|>
name|class
name|pointer_to_unary_function
operator|:
name|public
name|unary_function
operator|<
name|_Arg
operator|,
name|_Result
operator|>
block|{
name|protected
operator|:
name|_Result
argument_list|(
operator|*
name|_M_ptr
argument_list|)
argument_list|(
name|_Arg
argument_list|)
block|;
name|public
operator|:
name|pointer_to_unary_function
argument_list|()
block|{}
name|explicit
name|pointer_to_unary_function
argument_list|(
name|_Result
argument_list|(
operator|*
name|__x
argument_list|)
argument_list|(
name|_Arg
argument_list|)
argument_list|)
operator|:
name|_M_ptr
argument_list|(
argument|__x
argument_list|)
block|{}
name|_Result
name|operator
argument_list|()
operator|(
name|_Arg
name|__x
operator|)
specifier|const
block|{
return|return
name|_M_ptr
argument_list|(
name|__x
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Arg
operator|,
name|class
name|_Result
operator|>
specifier|inline
name|pointer_to_unary_function
operator|<
name|_Arg
operator|,
name|_Result
operator|>
name|ptr_fun
argument_list|(
argument|_Result (*__x)(_Arg)
argument_list|)
block|{
return|return
name|pointer_to_unary_function
operator|<
name|_Arg
operator|,
name|_Result
operator|>
operator|(
name|__x
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|,
name|class
name|_Result
operator|>
name|class
name|pointer_to_binary_function
operator|:
name|public
name|binary_function
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|,
name|_Result
operator|>
block|{
name|protected
operator|:
name|_Result
argument_list|(
operator|*
name|_M_ptr
argument_list|)
argument_list|(
name|_Arg1
argument_list|,
name|_Arg2
argument_list|)
block|;
name|public
operator|:
name|pointer_to_binary_function
argument_list|()
block|{}
name|explicit
name|pointer_to_binary_function
argument_list|(
name|_Result
argument_list|(
operator|*
name|__x
argument_list|)
argument_list|(
name|_Arg1
argument_list|,
name|_Arg2
argument_list|)
argument_list|)
operator|:
name|_M_ptr
argument_list|(
argument|__x
argument_list|)
block|{}
name|_Result
name|operator
argument_list|()
operator|(
name|_Arg1
name|__x
operator|,
name|_Arg2
name|__y
operator|)
specifier|const
block|{
return|return
name|_M_ptr
argument_list|(
name|__x
argument_list|,
name|__y
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|,
name|class
name|_Result
operator|>
specifier|inline
name|pointer_to_binary_function
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|,
name|_Result
operator|>
name|ptr_fun
argument_list|(
argument|_Result (*__x)(_Arg1, _Arg2)
argument_list|)
block|{
return|return
name|pointer_to_binary_function
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|,
name|_Result
operator|>
operator|(
name|__x
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// identity is an extensions: it is not part of the standard.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|_Identity
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
block|{
specifier|const
name|_Tp
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|__x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Tp
operator|>
expr|struct
name|identity
operator|:
name|public
name|_Identity
operator|<
name|_Tp
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// select1st and select2nd are extensions: they are not part of the standard.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Pair
operator|>
expr|struct
name|_Select1st
operator|:
name|public
name|unary_function
operator|<
name|_Pair
operator|,
name|typename
name|_Pair
operator|::
name|first_type
operator|>
block|{
specifier|const
name|typename
name|_Pair
operator|::
name|first_type
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|_Pair
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|__x
operator|.
name|first
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Pair
operator|>
expr|struct
name|_Select2nd
operator|:
name|public
name|unary_function
operator|<
name|_Pair
operator|,
name|typename
name|_Pair
operator|::
name|second_type
operator|>
block|{
specifier|const
name|typename
name|_Pair
operator|::
name|second_type
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|_Pair
operator|&
name|__x
operator|)
specifier|const
block|{
return|return
name|__x
operator|.
name|second
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Pair
operator|>
expr|struct
name|select1st
operator|:
name|public
name|_Select1st
operator|<
name|_Pair
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Pair
operator|>
expr|struct
name|select2nd
operator|:
name|public
name|_Select2nd
operator|<
name|_Pair
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// project1st and project2nd are extensions: they are not part of the standard
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|>
expr|struct
name|_Project1st
operator|:
name|public
name|binary_function
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|,
name|_Arg1
operator|>
block|{
name|_Arg1
name|operator
argument_list|()
operator|(
specifier|const
name|_Arg1
operator|&
name|__x
operator|,
specifier|const
name|_Arg2
operator|&
operator|)
specifier|const
block|{
return|return
name|__x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|>
expr|struct
name|_Project2nd
operator|:
name|public
name|binary_function
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|,
name|_Arg2
operator|>
block|{
name|_Arg2
name|operator
argument_list|()
operator|(
specifier|const
name|_Arg1
operator|&
operator|,
specifier|const
name|_Arg2
operator|&
name|__y
operator|)
specifier|const
block|{
return|return
name|__y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|>
expr|struct
name|project1st
operator|:
name|public
name|_Project1st
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|>
expr|struct
name|project2nd
operator|:
name|public
name|_Project2nd
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|>
block|{}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// constant_void_fun, constant_unary_fun, and constant_binary_fun are
end_comment

begin_comment
comment|// extensions: they are not part of the standard.  (The same, of course,
end_comment

begin_comment
comment|// is true of the helper functions constant0, constant1, and constant2.)
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Result
operator|>
expr|struct
name|constant_void_fun
block|{
typedef|typedef
name|_Result
name|result_type
typedef|;
name|result_type
name|__val
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|constant_void_fun
argument_list|(
specifier|const
name|result_type
operator|&
name|__v
argument_list|)
operator|:
name|__val
argument_list|(
argument|__v
argument_list|)
block|{}
specifier|const
name|result_type
operator|&
name|operator
argument_list|()
operator|(
operator|)
specifier|const
block|{
return|return
name|__val
return|;
block|}
end_expr_stmt

begin_ifndef
unit|};
ifndef|#
directive|ifndef
name|__STL_LIMITED_DEFAULT_TEMPLATES
end_ifndef

begin_expr_stmt
name|template
operator|<
name|class
name|_Result
operator|,
name|class
name|_Argument
operator|=
name|_Result
operator|>
else|#
directive|else
name|template
operator|<
name|class
name|_Result
operator|,
name|class
name|_Argument
operator|>
endif|#
directive|endif
expr|struct
name|constant_unary_fun
operator|:
name|public
name|unary_function
operator|<
name|_Argument
operator|,
name|_Result
operator|>
block|{
name|_Result
name|_M_val
block|;
name|constant_unary_fun
argument_list|(
specifier|const
name|_Result
operator|&
name|__v
argument_list|)
operator|:
name|_M_val
argument_list|(
argument|__v
argument_list|)
block|{}
specifier|const
name|_Result
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|_Argument
operator|&
operator|)
specifier|const
block|{
return|return
name|_M_val
return|;
block|}
end_expr_stmt

begin_ifndef
unit|};
ifndef|#
directive|ifndef
name|__STL_LIMITED_DEFAULT_TEMPLATES
end_ifndef

begin_expr_stmt
name|template
operator|<
name|class
name|_Result
operator|,
name|class
name|_Arg1
operator|=
name|_Result
operator|,
name|class
name|_Arg2
operator|=
name|_Arg1
operator|>
else|#
directive|else
name|template
operator|<
name|class
name|_Result
operator|,
name|class
name|_Arg1
operator|,
name|class
name|_Arg2
operator|>
endif|#
directive|endif
expr|struct
name|constant_binary_fun
operator|:
name|public
name|binary_function
operator|<
name|_Arg1
operator|,
name|_Arg2
operator|,
name|_Result
operator|>
block|{
name|_Result
name|_M_val
block|;
name|constant_binary_fun
argument_list|(
specifier|const
name|_Result
operator|&
name|__v
argument_list|)
operator|:
name|_M_val
argument_list|(
argument|__v
argument_list|)
block|{}
specifier|const
name|_Result
operator|&
name|operator
argument_list|()
operator|(
specifier|const
name|_Arg1
operator|&
operator|,
specifier|const
name|_Arg2
operator|&
operator|)
specifier|const
block|{
return|return
name|_M_val
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Result
operator|>
specifier|inline
name|constant_void_fun
operator|<
name|_Result
operator|>
name|constant0
argument_list|(
argument|const _Result& __val
argument_list|)
block|{
return|return
name|constant_void_fun
operator|<
name|_Result
operator|>
operator|(
name|__val
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Result
operator|>
specifier|inline
name|constant_unary_fun
operator|<
name|_Result
operator|,
name|_Result
operator|>
name|constant1
argument_list|(
argument|const _Result& __val
argument_list|)
block|{
return|return
name|constant_unary_fun
operator|<
name|_Result
operator|,
name|_Result
operator|>
operator|(
name|__val
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Result
operator|>
specifier|inline
name|constant_binary_fun
operator|<
name|_Result
operator|,
name|_Result
operator|,
name|_Result
operator|>
name|constant2
argument_list|(
argument|const _Result& __val
argument_list|)
block|{
return|return
name|constant_binary_fun
operator|<
name|_Result
operator|,
name|_Result
operator|,
name|_Result
operator|>
operator|(
name|__val
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// subtractive_rng is an extension: it is not part of the standard.
end_comment

begin_comment
comment|// Note: this code assumes that int is 32 bits.
end_comment

begin_decl_stmt
name|class
name|subtractive_rng
range|:
name|public
name|unary_function
operator|<
name|unsigned
name|int
decl_stmt|,
name|unsigned
name|int
decl|>
block|{
name|private
label|:
name|unsigned
name|int
name|_M_table
index|[
literal|55
index|]
decl_stmt|;
name|size_t
name|_M_index1
decl_stmt|;
name|size_t
name|_M_index2
decl_stmt|;
name|public
label|:
name|unsigned
name|int
name|operator
argument_list|()
operator|(
name|unsigned
name|int
name|__limit
operator|)
block|{
name|_M_index1
operator|=
operator|(
name|_M_index1
operator|+
literal|1
operator|)
operator|%
literal|55
block|;
name|_M_index2
operator|=
operator|(
name|_M_index2
operator|+
literal|1
operator|)
operator|%
literal|55
block|;
name|_M_table
index|[
name|_M_index1
index|]
operator|=
name|_M_table
index|[
name|_M_index1
index|]
operator|-
name|_M_table
index|[
name|_M_index2
index|]
block|;
return|return
name|_M_table
index|[
name|_M_index1
index|]
operator|%
name|__limit
return|;
block|}
name|void
name|_M_initialize
parameter_list|(
name|unsigned
name|int
name|__seed
parameter_list|)
block|{
name|unsigned
name|int
name|__k
init|=
literal|1
decl_stmt|;
name|_M_table
index|[
literal|54
index|]
operator|=
name|__seed
expr_stmt|;
name|size_t
name|__i
decl_stmt|;
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__i
operator|<
literal|54
condition|;
name|__i
operator|++
control|)
block|{
name|size_t
name|__ii
init|=
operator|(
literal|21
operator|*
operator|(
name|__i
operator|+
literal|1
operator|)
operator|%
literal|55
operator|)
operator|-
literal|1
decl_stmt|;
name|_M_table
index|[
name|__ii
index|]
operator|=
name|__k
expr_stmt|;
name|__k
operator|=
name|__seed
operator|-
name|__k
expr_stmt|;
name|__seed
operator|=
name|_M_table
index|[
name|__ii
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|__loop
init|=
literal|0
init|;
name|__loop
operator|<
literal|4
condition|;
name|__loop
operator|++
control|)
block|{
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__i
operator|<
literal|55
condition|;
name|__i
operator|++
control|)
name|_M_table
index|[
name|__i
index|]
operator|=
name|_M_table
index|[
name|__i
index|]
operator|-
name|_M_table
index|[
operator|(
literal|1
operator|+
name|__i
operator|+
literal|30
operator|)
operator|%
literal|55
index|]
expr_stmt|;
block|}
name|_M_index1
operator|=
literal|0
expr_stmt|;
name|_M_index2
operator|=
literal|31
expr_stmt|;
block|}
name|subtractive_rng
argument_list|(
argument|unsigned int __seed
argument_list|)
block|{
name|_M_initialize
argument_list|(
name|__seed
argument_list|)
expr_stmt|;
block|}
name|subtractive_rng
argument_list|()
block|{
name|_M_initialize
argument_list|(
literal|161803398u
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Adaptor function objects: pointers to member functions.
end_comment

begin_comment
comment|// There are a total of 16 = 2^4 function objects in this family.
end_comment

begin_comment
comment|//  (1) Member functions taking no arguments vs member functions taking
end_comment

begin_comment
comment|//       one argument.
end_comment

begin_comment
comment|//  (2) Call through pointer vs call through reference.
end_comment

begin_comment
comment|//  (3) Member function with void return type vs member function with
end_comment

begin_comment
comment|//      non-void return type.
end_comment

begin_comment
comment|//  (4) Const vs non-const member function.
end_comment

begin_comment
comment|// Note that choice (3) is nothing more than a workaround: according
end_comment

begin_comment
comment|//  to the draft, compilers should handle void and non-void the same way.
end_comment

begin_comment
comment|//  This feature is not yet widely implemented, though.  You can only use
end_comment

begin_comment
comment|//  member functions returning void if your compiler supports partial
end_comment

begin_comment
comment|//  specialization.
end_comment

begin_comment
comment|// All of this complexity is in the function objects themselves.  You can
end_comment

begin_comment
comment|//  ignore it by using the helper function mem_fun and mem_fun_ref,
end_comment

begin_comment
comment|//  which create whichever type of adaptor is appropriate.
end_comment

begin_comment
comment|//  (mem_fun1 and mem_fun1_ref are no longer part of the C++ standard,
end_comment

begin_comment
comment|//  but they are provided for backward compatibility.)
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
name|class
name|mem_fun_t
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|*
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_t
argument_list|(
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
name|_Tp
operator|*
name|__p
operator|)
specifier|const
block|{
return|return
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
name|class
name|const_mem_fun_t
operator|:
name|public
name|unary_function
operator|<
specifier|const
name|_Tp
operator|*
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_t
argument_list|(
name|_Ret
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|*
name|__p
operator|)
specifier|const
block|{
return|return
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
name|class
name|mem_fun_ref_t
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_ref_t
argument_list|(
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__r
operator|)
specifier|const
block|{
return|return
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
name|class
name|const_mem_fun_ref_t
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_ref_t
argument_list|(
name|_Ret
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__r
operator|)
specifier|const
block|{
return|return
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|mem_fun1_t
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|*
operator|,
name|_Arg
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_t
argument_list|(
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|(
name|_Arg
argument_list|)
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
name|_Tp
operator|*
name|__p
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
return|return
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
name|__x
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|(
name|_Arg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|const_mem_fun1_t
operator|:
name|public
name|binary_function
operator|<
specifier|const
name|_Tp
operator|*
operator|,
name|_Arg
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_t
argument_list|(
name|_Ret
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|*
name|__p
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
return|return
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
name|__x
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|mem_fun1_ref_t
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Arg
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_ref_t
argument_list|(
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|(
name|_Arg
argument_list|)
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__r
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
return|return
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
name|__x
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|(
name|_Arg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|const_mem_fun1_ref_t
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Arg
operator|,
name|_Ret
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_ref_t
argument_list|(
name|_Ret
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|_Ret
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__r
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
return|return
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
name|__x
operator|)
return|;
block|}
name|private
operator|:
name|_Ret
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_ifdef
unit|};
ifdef|#
directive|ifdef
name|__STL_CLASS_PARTIAL_SPECIALIZATION
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
name|class
name|mem_fun_t
operator|<
name|void
operator|,
name|_Tp
operator|>
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|*
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_t
argument_list|(
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|_Tp
operator|*
name|__p
operator|)
specifier|const
block|{
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|()
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
name|class
name|const_mem_fun_t
operator|<
name|void
operator|,
name|_Tp
operator|>
operator|:
name|public
name|unary_function
operator|<
specifier|const
name|_Tp
operator|*
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_t
argument_list|(
name|void
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|*
name|__p
operator|)
specifier|const
block|{
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
operator|)
specifier|const
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
name|class
name|mem_fun_ref_t
operator|<
name|void
operator|,
name|_Tp
operator|>
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun_ref_t
argument_list|(
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|()
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__r
operator|)
specifier|const
block|{
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|()
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|>
name|class
name|const_mem_fun_ref_t
operator|<
name|void
operator|,
name|_Tp
operator|>
operator|:
name|public
name|unary_function
operator|<
name|_Tp
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun_ref_t
argument_list|(
name|void
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__r
operator|)
specifier|const
block|{
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
operator|)
specifier|const
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|mem_fun1_t
operator|<
name|void
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|*
operator|,
name|_Arg
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_t
argument_list|(
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|(
name|_Arg
argument_list|)
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|_Tp
operator|*
name|__p
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
name|__x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|(
name|_Arg
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|const_mem_fun1_t
operator|<
name|void
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|:
name|public
name|binary_function
operator|<
specifier|const
name|_Tp
operator|*
operator|,
name|_Arg
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_t
argument_list|(
name|void
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|*
name|__p
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
operator|(
name|__p
operator|->*
name|_M_f
operator|)
operator|(
name|__x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|mem_fun1_ref_t
operator|<
name|void
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Arg
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|mem_fun1_ref_t
argument_list|(
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|__pf
argument_list|)
argument_list|(
name|_Arg
argument_list|)
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__r
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
name|__x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
name|_Tp
operator|::
operator|*
name|_M_f
argument_list|)
argument_list|(
name|_Arg
argument_list|)
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
name|class
name|const_mem_fun1_ref_t
operator|<
name|void
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|:
name|public
name|binary_function
operator|<
name|_Tp
operator|,
name|_Arg
operator|,
name|void
operator|>
block|{
name|public
operator|:
name|explicit
name|const_mem_fun1_ref_t
argument_list|(
name|void
argument_list|(
argument|_Tp::*__pf
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__pf
argument_list|)
block|{}
name|void
name|operator
argument_list|()
operator|(
specifier|const
name|_Tp
operator|&
name|__r
operator|,
name|_Arg
name|__x
operator|)
specifier|const
block|{
operator|(
name|__r
operator|.*
name|_M_f
operator|)
operator|(
name|__x
operator|)
block|; }
name|private
operator|:
name|void
argument_list|(
argument|_Tp::*_M_f
argument_list|)
operator|(
name|_Arg
operator|)
specifier|const
block|; }
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_comment
comment|// Mem_fun adaptor helper functions.  There are only two:
end_comment

begin_comment
comment|//  mem_fun and mem_fun_ref.  (mem_fun1 and mem_fun1_ref
end_comment

begin_comment
comment|//  are provided for backward compatibility, but they are no longer
end_comment

begin_comment
comment|//  part of the C++ standard.)
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|mem_fun_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
name|mem_fun
argument_list|(
argument|_Ret (_Tp::*__f)()
argument_list|)
block|{
return|return
name|mem_fun_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|const_mem_fun_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
name|mem_fun
argument_list|(
argument|_Ret (_Tp::*__f)() const
argument_list|)
block|{
return|return
name|const_mem_fun_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|mem_fun_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
name|mem_fun_ref
argument_list|(
argument|_Ret (_Tp::*__f)()
argument_list|)
block|{
return|return
name|mem_fun_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|>
specifier|inline
name|const_mem_fun_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
name|mem_fun_ref
argument_list|(
argument|_Ret (_Tp::*__f)() const
argument_list|)
block|{
return|return
name|const_mem_fun_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg)
argument_list|)
block|{
return|return
name|mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|const_mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg) const
argument_list|)
block|{
return|return
name|const_mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun_ref
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg)
argument_list|)
block|{
return|return
name|mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|const_mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun_ref
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg) const
argument_list|)
block|{
return|return
name|const_mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun1
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg)
argument_list|)
block|{
return|return
name|mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|const_mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun1
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg) const
argument_list|)
block|{
return|return
name|const_mem_fun1_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun1_ref
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg)
argument_list|)
block|{
return|return
name|mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_Ret
operator|,
name|class
name|_Tp
operator|,
name|class
name|_Arg
operator|>
specifier|inline
name|const_mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
name|mem_fun1_ref
argument_list|(
argument|_Ret (_Tp::*__f)(_Arg) const
argument_list|)
block|{
return|return
name|const_mem_fun1_ref_t
operator|<
name|_Ret
operator|,
name|_Tp
operator|,
name|_Arg
operator|>
operator|(
name|__f
operator|)
return|;
block|}
end_expr_stmt

begin_macro
name|__STL_END_NAMESPACE
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SGI_STL_INTERNAL_FUNCTION_H */
end_comment

begin_comment
comment|// Local Variables:
end_comment

begin_comment
comment|// mode:C++
end_comment

begin_comment
comment|// End:
end_comment

end_unit

