begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/* NOTE: This is an internal header file, included by other STL headers.  *   You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__SGI_STL_INTERNAL_ROPE_H
end_ifndef

begin_define
define|#
directive|define
name|__SGI_STL_INTERNAL_ROPE_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GC
end_ifdef

begin_define
define|#
directive|define
name|__GC_CONST
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__GC_CONST
end_define

begin_comment
comment|// constant except for deallocation
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_SGI_THREADS
end_ifdef

begin_include
include|#
directive|include
file|<mutex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|__STL_BEGIN_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
pragma|#
directive|pragma
name|set
name|woff
name|1174
endif|#
directive|endif
comment|// The end-of-C-string character.
comment|// This is what the draft standard says it should be.
name|template
operator|<
name|class
name|charT
operator|>
specifier|inline
name|charT
name|__eos
argument_list|(
argument|charT*
argument_list|)
block|{
return|return
name|charT
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Test for basic character types.
end_comment

begin_comment
comment|// For basic character types leaves having a trailing eos.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|>
specifier|inline
name|bool
name|__is_basic_char_type
argument_list|(
argument|charT *
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|>
specifier|inline
name|bool
name|__is_one_byte_char_type
argument_list|(
argument|charT *
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_function
specifier|inline
name|bool
name|__is_basic_char_type
parameter_list|(
name|char
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|__is_one_byte_char_type
parameter_list|(
name|char
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|__is_basic_char_type
parameter_list|(
name|wchar_t
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// Store an eos iff charT is a basic character type.
end_comment

begin_comment
comment|// Do not reference __eos if it isn't.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|>
specifier|inline
name|void
name|__cond_store_eos
argument_list|(
argument|charT&
argument_list|)
block|{}
specifier|inline
name|void
name|__cond_store_eos
argument_list|(
argument|char& c
argument_list|)
block|{
name|c
operator|=
literal|0
block|; }
specifier|inline
name|void
name|__cond_store_eos
argument_list|(
argument|wchar_t& c
argument_list|)
block|{
name|c
operator|=
literal|0
block|; }
comment|// rope<charT,Alloc> is a sequence of charT.
comment|// Ropes appear to be mutable, but update operations
comment|// really copy enough of the data structure to leave the original
comment|// valid.  Thus ropes can be logically copied by just copying
comment|// a pointer value.
comment|// The __eos function is used for those functions that
comment|// convert to/from C-like strings to detect the end of the string.
comment|// __compare is used as the character comparison function.
name|template
operator|<
name|class
name|charT
operator|>
name|class
name|char_producer
block|{
name|public
operator|:
name|virtual
operator|~
name|char_producer
argument_list|()
block|{}
block|;
name|virtual
name|void
name|operator
argument_list|()
operator|(
name|size_t
name|start_pos
operator|,
name|size_t
name|len
operator|,
name|charT
operator|*
name|buffer
operator|)
operator|=
literal|0
block|;
comment|// Buffer should really be an arbitrary output iterator.
comment|// That way we could flatten directly into an ostream, etc.
comment|// This is thoroughly impossible, since iterator types don't
comment|// have runtime descriptions.
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Sequence buffers:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Sequence must provide an append operation that appends an
end_comment

begin_comment
comment|// array to the sequence.  Sequence buffers are useful only if
end_comment

begin_comment
comment|// appending an entire array is cheaper than appending element by element.
end_comment

begin_comment
comment|// This is true for many string representations.
end_comment

begin_comment
comment|// This should  perhaps inherit from ostream<sequence::value_type>
end_comment

begin_comment
comment|// and be implemented correspondingly, so that they can be used
end_comment

begin_comment
comment|// for formatted.  For the sake of portability, we don't do this yet.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// For now, sequence buffers behave as output iterators.  But they also
end_comment

begin_comment
comment|// behave a little like basic_ostringstream<sequence::value_type> and a
end_comment

begin_comment
comment|// little like containers.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|sequence
operator|,
name|size_t
name|buf_sz
operator|=
literal|100
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|__TYPEDEF_WORKAROUND
operator|,
name|class
name|v
operator|=
name|typename
name|sequence
operator|::
name|value_type
endif|#
directive|endif
operator|>
comment|// The 3rd parameter works around a common compiler bug.
name|class
name|sequence_buffer
operator|:
name|public
name|output_iterator
block|{
name|public
operator|:
ifndef|#
directive|ifndef
name|__TYPEDEF_WORKAROUND
typedef|typedef
name|typename
name|sequence
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|v
name|value_type
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|sequence
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value_type
name|buffer
index|[
name|buf_sz
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|buf_count
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_function
name|void
name|flush
parameter_list|()
block|{
name|prefix
operator|->
name|append
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|+
name|buf_count
argument_list|)
expr_stmt|;
name|buf_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_expr_stmt
operator|~
name|sequence_buffer
argument_list|()
block|{
name|flush
argument_list|()
block|; }
name|sequence_buffer
argument_list|()
operator|:
name|prefix
argument_list|(
literal|0
argument_list|)
operator|,
name|buf_count
argument_list|(
literal|0
argument_list|)
block|{}
name|sequence_buffer
argument_list|(
argument|const sequence_buffer& x
argument_list|)
block|{
name|prefix
operator|=
name|x
operator|.
name|prefix
block|;
name|buf_count
operator|=
name|x
operator|.
name|buf_count
block|;
name|copy
argument_list|(
name|x
operator|.
name|buffer
argument_list|,
name|x
operator|.
name|buffer
operator|+
name|x
operator|.
name|buf_count
argument_list|,
name|buffer
argument_list|)
block|; 	}
name|sequence_buffer
argument_list|(
argument|sequence_buffer& x
argument_list|)
block|{
name|x
operator|.
name|flush
argument_list|()
block|;
name|prefix
operator|=
name|x
operator|.
name|prefix
block|;
name|buf_count
operator|=
literal|0
block|; 	}
name|sequence_buffer
argument_list|(
name|sequence
operator|&
name|s
argument_list|)
operator|:
name|prefix
argument_list|(
operator|&
name|s
argument_list|)
operator|,
name|buf_count
argument_list|(
literal|0
argument_list|)
block|{}
name|sequence_buffer
operator|&
name|operator
operator|=
operator|(
name|sequence_buffer
operator|&
name|x
operator|)
block|{
name|x
operator|.
name|flush
argument_list|()
block|;
name|prefix
operator|=
name|x
operator|.
name|prefix
block|;
name|buf_count
operator|=
literal|0
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|sequence_buffer
modifier|&
name|operator
init|=
operator|(
specifier|const
name|sequence_buffer
operator|&
name|x
operator|)
block|{
name|prefix
operator|=
name|x
operator|.
name|prefix
block|;
name|buf_count
operator|=
name|x
operator|.
name|buf_count
block|;
name|copy
argument_list|(
name|x
operator|.
name|buffer
argument_list|,
name|x
operator|.
name|buffer
operator|+
name|x
operator|.
name|buf_count
argument_list|,
name|buffer
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_function
name|void
name|push_back
parameter_list|(
name|value_type
name|x
parameter_list|)
block|{
if|if
condition|(
name|buf_count
operator|<
name|buf_sz
condition|)
block|{
name|buffer
index|[
name|buf_count
index|]
operator|=
name|x
expr_stmt|;
operator|++
name|buf_count
expr_stmt|;
block|}
else|else
block|{
name|flush
argument_list|()
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|buf_count
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|append
parameter_list|(
name|value_type
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|+
name|buf_count
operator|<=
name|buf_sz
condition|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|buf_count
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|s
index|[
name|j
index|]
expr_stmt|;
block|}
name|buf_count
operator|+=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|buf_count
condition|)
block|{
name|prefix
operator|->
name|append
argument_list|(
name|s
argument_list|,
name|s
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flush
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|sequence_buffer
modifier|&
name|write
parameter_list|(
name|value_type
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|append
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|sequence_buffer
modifier|&
name|put
parameter_list|(
name|value_type
name|x
parameter_list|)
block|{
name|push_back
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_decl_stmt
name|sequence_buffer
modifier|&
name|operator
init|=
operator|(
specifier|const
name|value_type
operator|&
name|rhs
operator|)
block|{
name|push_back
argument_list|(
name|rhs
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_function
name|sequence_buffer
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
return|return
operator|*
name|this
return|;
block|}
end_function

begin_expr_stmt
name|sequence_buffer
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|sequence_buffer
operator|&
name|operator
operator|++
operator|(
name|int
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// The following should be treated as private, at least for now.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|>
name|class
name|__rope_char_consumer
block|{
name|public
operator|:
comment|// If we had member templates, these should not be virtual.
comment|// For now we need to use run-time parametrization where
comment|// compile-time would do.  Hence this should all be private
comment|// for now.
comment|// The symmetry with char_producer is accidental and temporary.
name|virtual
operator|~
name|__rope_char_consumer
argument_list|()
block|{}
block|;
name|virtual
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|charT
operator|*
name|buffer
operator|,
name|size_t
name|len
operator|)
operator|=
literal|0
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|//
end_comment

begin_comment
comment|// What follows should really be local to rope.  Unfortunately,
end_comment

begin_comment
comment|// that doesn't work, since it makes it impossible to define generic
end_comment

begin_comment
comment|// equality on rope iterators.  According to the draft standard, the
end_comment

begin_comment
comment|// template parameters for such an equality operator cannot be inferred
end_comment

begin_comment
comment|// from the occurence of a member class as a parameter.
end_comment

begin_comment
comment|// (SGI compilers in fact allow this, but the result wouldn't be
end_comment

begin_comment
comment|// portable.)
end_comment

begin_comment
comment|// Similarly, some of the static member functions are member functions
end_comment

begin_comment
comment|// only to avoid polluting the global namespace, and to circumvent
end_comment

begin_comment
comment|// restrictions on type inference for template functions.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|CharT
operator|,
name|class
name|Alloc
operator|=
name|__ALLOC
operator|>
name|class
name|rope
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|CharT
operator|,
name|class
name|Alloc
operator|>
expr|struct
name|__rope_RopeConcatenation
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|CharT
operator|,
name|class
name|Alloc
operator|>
expr|struct
name|__rope_RopeLeaf
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|CharT
operator|,
name|class
name|Alloc
operator|>
expr|struct
name|__rope_RopeFunction
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|CharT
operator|,
name|class
name|Alloc
operator|>
expr|struct
name|__rope_RopeSubstring
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|CharT
operator|,
name|class
name|Alloc
operator|>
name|class
name|__rope_iterator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|CharT
operator|,
name|class
name|Alloc
operator|>
name|class
name|__rope_const_iterator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|CharT
operator|,
name|class
name|Alloc
operator|>
name|class
name|__rope_charT_ref_proxy
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|CharT
operator|,
name|class
name|Alloc
operator|>
name|class
name|__rope_charT_ptr_proxy
expr_stmt|;
end_expr_stmt

begin_comment
comment|//
end_comment

begin_comment
comment|// The internal data structure for representing a rope.  This is
end_comment

begin_comment
comment|// private to the implementation.  A rope is really just a pointer
end_comment

begin_comment
comment|// to one of these.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A few basic functions for manipulating this data structure
end_comment

begin_comment
comment|// are members of RopeBase.  Most of the more complex algorithms
end_comment

begin_comment
comment|// are implemented as rope members.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Some of the static member functions of RopeBase have identically
end_comment

begin_comment
comment|// named functions in rope that simply invoke the RopeBase versions.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
expr|struct
name|__rope_RopeBase
block|{
typedef|typedef
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|my_rope
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|DataAlloc
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|__rope_RopeConcatenation
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|,
name|Alloc
operator|>
name|CAlloc
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|__rope_RopeLeaf
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|,
name|Alloc
operator|>
name|LAlloc
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|__rope_RopeFunction
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|,
name|Alloc
operator|>
name|FAlloc
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|__rope_RopeSubstring
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|,
name|Alloc
operator|>
name|SAlloc
expr_stmt|;
end_typedef

begin_label
name|public
label|:
end_label

begin_enum
enum|enum
block|{
name|max_rope_depth
init|=
literal|45
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|leaf
block|,
name|concat
block|,
name|substringfn
block|,
name|function
block|}
name|tag
range|:
literal|8
enum|;
end_enum

begin_decl_stmt
name|bool
name|is_balanced
range|:
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__GC_CONST
name|charT
modifier|*
name|c_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flattened version of string, if needed.  */
end_comment

begin_comment
comment|/* typically 0.                             */
end_comment

begin_comment
comment|/* If it's not 0, then the memory is owned  */
end_comment

begin_comment
comment|/* by this node.                            */
end_comment

begin_comment
comment|/* In the case of a leaf, this may point to */
end_comment

begin_comment
comment|/* the same memory as the data field.	    */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STL_WIN32THREADS
argument_list|)
end_if

begin_decl_stmt
name|long
name|refcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|// InterlockedIncrement wants a long *
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|size_t
name|refcount
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// We count references from rope instances
end_comment

begin_comment
comment|// and references from other rope nodes.  We
end_comment

begin_comment
comment|// do not count const_iterator references.
end_comment

begin_comment
comment|// Iterator references are counted so that rope modifications
end_comment

begin_comment
comment|// can be detected after the fact.
end_comment

begin_comment
comment|// Generally function results are counted, i.e.
end_comment

begin_comment
comment|// a pointer returned by a function is included at the
end_comment

begin_comment
comment|// point at which the pointer is returned.
end_comment

begin_comment
comment|// The recipient should decrement the count if the
end_comment

begin_comment
comment|// result is not needed.
end_comment

begin_comment
comment|// Generally function arguments are not reflected
end_comment

begin_comment
comment|// in the reference count.  The callee should increment
end_comment

begin_comment
comment|// the count before saving the argument someplace that
end_comment

begin_comment
comment|// will outlive the call.
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_SGI_THREADS
end_ifdef

begin_comment
comment|// Reference counting with multiple threads and no
end_comment

begin_comment
comment|// hardware or thread package support is pretty awful.
end_comment

begin_comment
comment|// Mutexes are normally too expensive.
end_comment

begin_comment
comment|// We'll assume a COMPARE_AND_SWAP(destp, old, new)
end_comment

begin_comment
comment|// operation, which might be cheaper.
end_comment

begin_if
if|#
directive|if
name|__mips
operator|<
literal|3
operator|||
operator|!
operator|(
name|defined
argument_list|(
name|_ABIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_ABI64
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|__add_and_fetch
parameter_list|(
name|l
parameter_list|,
name|v
parameter_list|)
value|add_then_test((unsigned long *)l,v)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|init_refcount_lock
parameter_list|()
block|{}
end_function

begin_function
name|void
name|incr_refcount
parameter_list|()
block|{
name|__add_and_fetch
argument_list|(
operator|&
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|decr_refcount
parameter_list|()
block|{
return|return
name|__add_and_fetch
argument_list|(
operator|&
name|refcount
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__STL_WIN32THREADS
argument_list|)
end_elif

begin_function
name|void
name|init_refcount_lock
parameter_list|()
block|{}
end_function

begin_function
name|void
name|incr_refcount
parameter_list|()
block|{
name|InterlockedIncrement
argument_list|(
operator|&
name|refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|decr_refcount
parameter_list|()
block|{
return|return
name|InterlockedDecrement
argument_list|(
operator|&
name|refcount
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__STL_PTHREADS
argument_list|)
end_elif

begin_comment
comment|// This should be portable, but performance is expected
end_comment

begin_comment
comment|// to be quite awful.  This really needs platform specific
end_comment

begin_comment
comment|// code.
end_comment

begin_decl_stmt
name|pthread_mutex_t
name|refcount_lock
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_refcount_lock
parameter_list|()
block|{
name|pthread_mutex_init
argument_list|(
operator|&
name|refcount_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|incr_refcount
parameter_list|()
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|refcount_lock
argument_list|)
expr_stmt|;
operator|++
name|refcount
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|refcount_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|decr_refcount
parameter_list|()
block|{
name|size_t
name|result
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|refcount_lock
argument_list|)
expr_stmt|;
name|result
operator|=
operator|--
name|refcount
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|refcount_lock
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|init_refcount_lock
parameter_list|()
block|{}
end_function

begin_function
name|void
name|incr_refcount
parameter_list|()
block|{
operator|++
name|refcount
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|decr_refcount
parameter_list|()
block|{
operator|--
name|refcount
expr_stmt|;
return|return
name|refcount
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|incr_refcount
parameter_list|()
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|free_string
parameter_list|(
name|charT
modifier|*
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Deallocate data section of a leaf.
end_comment

begin_comment
comment|// This shouldn't be a member function.
end_comment

begin_comment
comment|// But its hard to do anything else at the
end_comment

begin_comment
comment|// moment, because it's templatized w.r.t.
end_comment

begin_comment
comment|// an allocator.
end_comment

begin_comment
comment|// Does nothing if __GC is defined.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_function_decl
name|void
name|free_c_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free_tree
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Deallocate t. Assumes t is not 0.
end_comment

begin_function
name|void
name|unref_nonnil
parameter_list|()
block|{
if|if
condition|(
literal|0
operator|==
name|decr_refcount
argument_list|()
condition|)
name|free_tree
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ref_nonnil
parameter_list|()
block|{
name|incr_refcount
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unref
parameter_list|(
name|__rope_RopeBase
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|!=
name|t
condition|)
block|{
name|t
operator|->
name|unref_nonnil
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ref
parameter_list|(
name|__rope_RopeBase
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|!=
name|t
condition|)
name|t
operator|->
name|incr_refcount
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_if_unref
parameter_list|(
name|__rope_RopeBase
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|!=
name|t
operator|&&
literal|0
operator|==
name|t
operator|->
name|refcount
condition|)
name|t
operator|->
name|free_tree
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __GC */
end_comment

begin_function
name|void
name|unref_nonnil
parameter_list|()
block|{}
end_function

begin_function
name|void
name|ref_nonnil
parameter_list|()
block|{}
end_function

begin_function
specifier|static
name|void
name|unref
parameter_list|(
name|__rope_RopeBase
modifier|*
name|t
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|ref
parameter_list|(
name|__rope_RopeBase
modifier|*
name|t
parameter_list|)
block|{}
end_function

begin_function_decl
specifier|static
name|void
name|fn_finalization_proc
parameter_list|(
name|void
modifier|*
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|free_if_unref
parameter_list|(
name|__rope_RopeBase
modifier|*
name|t
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// The data fields of leaves are allocated with some
end_comment

begin_comment
comment|// extra space, to accomodate future growth and for basic
end_comment

begin_comment
comment|// character types, to hold a trailing eos character.
end_comment

begin_enum
enum|enum
block|{
name|alloc_granularity
init|=
literal|8
block|}
enum|;
end_enum

begin_function
specifier|static
name|size_t
name|rounded_up_size
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|size_t
name|size_with_eos
decl_stmt|;
if|if
condition|(
name|__is_basic_char_type
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|size_with_eos
operator|=
name|n
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|size_with_eos
operator|=
name|n
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__GC
return|return
name|size_with_eos
return|;
else|#
directive|else
comment|// Allow slop for in-place expansion.
return|return
operator|(
name|size_with_eos
operator|+
name|alloc_granularity
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|alloc_granularity
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
expr|struct
name|__rope_RopeLeaf
operator|:
name|public
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
block|{
name|public
operator|:
comment|// Apparently needed by VC++
name|__GC_CONST
name|charT
operator|*
name|data
block|;
comment|/* Not necessarily 0 terminated. */
comment|/* The allocated size is	 */
comment|/* rounded_up_size(size), except */
comment|/* in the GC case, in which it	 */
comment|/* doesn't matter.		 */
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
expr|struct
name|__rope_RopeConcatenation
operator|:
name|public
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
block|{
name|public
operator|:
name|__rope_RopeBase
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|*
name|left
block|;
name|__rope_RopeBase
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|*
name|right
block|; }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
expr|struct
name|__rope_RopeFunction
operator|:
name|public
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
block|{
name|public
operator|:
name|char_producer
operator|<
name|charT
operator|>
operator|*
name|fn
block|;
ifndef|#
directive|ifndef
name|__GC
name|bool
name|delete_when_done
block|;
comment|// Char_producer is owned by the
comment|// rope and should be explicitly
comment|// deleted when the rope becomes
comment|// inaccessible.
else|#
directive|else
comment|// In the GC case, we either register the rope for
comment|// finalization, or not.  Thus the field is unnecessary;
comment|// the information is stored in the collector data structures.
endif|#
directive|endif
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Substring results are usually represented using just
end_comment

begin_comment
comment|// concatenation nodes.  But in the case of very long flat ropes
end_comment

begin_comment
comment|// or ropes with a functional representation that isn't practical.
end_comment

begin_comment
comment|// In that case, we represent the result as a special case of
end_comment

begin_comment
comment|// RopeFunction, whose char_producer points back to the rope itself.
end_comment

begin_comment
comment|// In all cases except repeated substring operations and
end_comment

begin_comment
comment|// deallocation, we treat the result as a RopeFunction.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
expr|struct
name|__rope_RopeSubstring
operator|:
name|public
name|__rope_RopeFunction
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|,
name|public
name|char_producer
operator|<
name|charT
operator|>
block|{
name|public
operator|:
name|__rope_RopeBase
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|*
name|base
block|;
comment|// not 0
name|size_t
name|start
block|;
name|virtual
operator|~
name|__rope_RopeSubstring
argument_list|()
block|{}
name|virtual
name|void
name|operator
argument_list|()
operator|(
name|size_t
name|start_pos
operator|,
name|size_t
name|req_len
operator|,
name|charT
operator|*
name|buffer
operator|)
block|{
switch|switch
condition|(
name|base
operator|->
name|tag
condition|)
block|{
case|case
name|function
case|:
case|case
name|substringfn
case|:
block|{
name|char_producer
operator|<
name|charT
operator|>
operator|*
name|fn
operator|=
operator|(
operator|(
name|__rope_RopeFunction
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|)
name|base
operator|)
operator|->
name|fn
expr_stmt|;
name|__stl_assert
argument_list|(
name|start_pos
operator|+
name|req_len
operator|<=
name|size
argument_list|)
expr_stmt|;
name|__stl_assert
argument_list|(
name|start
operator|+
name|size
operator|<=
name|base
operator|->
name|size
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|start_pos
operator|+
name|start
argument_list|,
name|req_len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
break|break;
end_expr_stmt

begin_case
case|case
name|leaf
case|:
end_case

begin_block
block|{
name|__GC_CONST
name|charT
modifier|*
name|s
init|=
operator|(
operator|(
name|__rope_RopeLeaf
operator|<
name|charT
expr|,
name|Alloc
operator|>
operator|*
operator|)
name|base
operator|)
operator|->
name|data
decl_stmt|;
name|uninitialized_copy_n
argument_list|(
name|s
operator|+
name|start_pos
operator|+
name|start
argument_list|,
name|req_len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_expr_stmt
name|__stl_assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
unit|}     }
name|__rope_RopeSubstring
argument_list|(
argument|__rope_RopeBase<charT
argument_list|,
argument|Alloc> * b
argument_list|,
argument|size_t s
argument_list|,
argument|size_t l
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|base
argument_list|(
name|b
argument_list|)
operator|,
name|start
argument_list|(
argument|s
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__GC
name|refcount
operator|=
literal|1
block|;
name|init_refcount_lock
argument_list|()
block|;
name|base
operator|->
name|ref_nonnil
argument_list|()
block|;
endif|#
directive|endif
name|size
operator|=
name|l
block|;
name|tag
operator|=
name|substringfn
block|;
name|depth
operator|=
literal|0
block|;
name|c_string
operator|=
literal|0
block|;
name|fn
operator|=
name|this
block|;     }
end_expr_stmt

begin_comment
unit|};
comment|// Self-destructing pointers to RopeBase.
end_comment

begin_comment
comment|// These are not conventional smart pointers.  Their
end_comment

begin_comment
comment|// only purpose in life is to ensure that unref is called
end_comment

begin_comment
comment|// on the pointer either at normal exit or if an exception
end_comment

begin_comment
comment|// is raised.  It is the caller's responsibility to
end_comment

begin_comment
comment|// adjust reference counts when these pointers are initialized
end_comment

begin_comment
comment|// or assigned to.  (This convention significantly reduces
end_comment

begin_comment
comment|// the number of potentially expensive reference count
end_comment

begin_comment
comment|// updates.)
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
expr|struct
name|__rope_self_destruct_ptr
block|{
name|__rope_RopeBase
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|*
name|ptr
block|;
operator|~
name|__rope_self_destruct_ptr
argument_list|()
block|{
name|__rope_RopeBase
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|::
name|unref
argument_list|(
name|ptr
argument_list|)
block|; }
ifdef|#
directive|ifdef
name|__STL_USE_EXCEPTIONS
name|__rope_self_destruct_ptr
argument_list|()
operator|:
name|ptr
argument_list|(
literal|0
argument_list|)
block|{}
block|;
else|#
directive|else
name|__rope_self_destruct_ptr
argument_list|()
block|{}
block|;
endif|#
directive|endif
name|__rope_self_destruct_ptr
argument_list|(
name|__rope_RopeBase
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|*
name|p
argument_list|)
operator|:
name|ptr
argument_list|(
argument|p
argument_list|)
block|{}
name|__rope_RopeBase
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|&
name|operator
operator|*
operator|(
operator|)
block|{
return|return
operator|*
name|ptr
return|;
block|}
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_block
unit|)
block|{
return|return
name|ptr
return|;
block|}
end_block

begin_expr_stmt
name|operator
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
operator|(
operator|)
block|{
return|return
name|ptr
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|__rope_self_destruct_ptr
modifier|&
name|operator
init|=
operator|(
name|__rope_RopeBase
operator|<
name|charT
expr|,
name|Alloc
operator|>
operator|*
name|x
operator|)
block|{
name|ptr
operator|=
name|x
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|// Dereferencing a nonconst iterator has to return something
end_comment

begin_comment
comment|// that behaves almost like a reference.  It's not possible to
end_comment

begin_comment
comment|// return an actual reference since assignment requires extra
end_comment

begin_comment
comment|// work.  And we would get into the same problems as with the
end_comment

begin_comment
comment|// CD2 version of basic_string.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|class
name|__rope_charT_ref_proxy
block|{
name|friend
name|class
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
block|;
name|friend
name|class
name|__rope_iterator
operator|<
name|charT
block|,
name|Alloc
operator|>
block|;
name|friend
name|class
name|__rope_charT_ptr_proxy
operator|<
name|charT
block|,
name|Alloc
operator|>
block|;
ifdef|#
directive|ifdef
name|__GC
typedef|typedef
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
name|self_destruct_ptr
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|__rope_self_destruct_ptr
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|self_destruct_ptr
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|RopeBase
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|my_rope
expr_stmt|;
end_typedef

begin_decl_stmt
name|size_t
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|charT
name|current
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|current_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|my_rope
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The whole rope.
end_comment

begin_label
name|public
label|:
end_label

begin_macro
name|__rope_charT_ref_proxy
argument_list|(
argument|my_rope * r
argument_list|,
argument|size_t p
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|pos
argument_list|(
name|p
argument_list|)
operator|,
name|root
argument_list|(
name|r
argument_list|)
operator|,
name|current_valid
argument_list|(
argument|false
argument_list|)
block|{}
name|__rope_charT_ref_proxy
argument_list|(
argument|my_rope * r
argument_list|,
argument|size_t p
argument_list|,
argument|charT c
argument_list|)
operator|:
name|pos
argument_list|(
name|p
argument_list|)
operator|,
name|root
argument_list|(
name|r
argument_list|)
operator|,
name|current
argument_list|(
name|c
argument_list|)
operator|,
name|current_valid
argument_list|(
argument|true
argument_list|)
block|{}
name|operator
name|charT
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|__rope_charT_ref_proxy
modifier|&
name|operator
init|=
operator|(
name|charT
name|c
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__rope_charT_ptr_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|&
operator|(
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|__rope_charT_ref_proxy
modifier|&
name|operator
init|=
operator|(
specifier|const
name|__rope_charT_ref_proxy
operator|&
name|c
operator|)
block|{
return|return
name|operator
operator|=
operator|(
operator|(
name|charT
operator|)
name|c
operator|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|class
name|__rope_charT_ptr_proxy
block|{
name|friend
name|class
name|__rope_charT_ref_proxy
operator|<
name|charT
block|,
name|Alloc
operator|>
block|;
name|size_t
name|pos
block|;
name|charT
name|current
block|;
name|bool
name|current_valid
block|;
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|*
name|root
block|;
comment|// The whole rope.
name|public
operator|:
name|__rope_charT_ptr_proxy
argument_list|(
specifier|const
name|__rope_charT_ref_proxy
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|)
operator|:
name|pos
argument_list|(
name|x
operator|.
name|pos
argument_list|)
block|,
name|root
argument_list|(
name|x
operator|.
name|root
argument_list|)
block|,
name|current_valid
argument_list|(
name|x
operator|.
name|current_valid
argument_list|)
block|,
name|current
argument_list|(
argument|x.current
argument_list|)
block|{}
name|__rope_charT_ptr_proxy
argument_list|(
specifier|const
name|__rope_charT_ptr_proxy
operator|&
name|x
argument_list|)
operator|:
name|pos
argument_list|(
name|x
operator|.
name|pos
argument_list|)
block|,
name|root
argument_list|(
name|x
operator|.
name|root
argument_list|)
block|,
name|current_valid
argument_list|(
name|x
operator|.
name|current_valid
argument_list|)
block|,
name|current
argument_list|(
argument|x.current
argument_list|)
block|{}
name|__rope_charT_ptr_proxy
argument_list|()
block|{}
name|__rope_charT_ptr_proxy
argument_list|(
name|charT
operator|*
name|x
argument_list|)
operator|:
name|root
argument_list|(
literal|0
argument_list|)
block|,
name|pos
argument_list|(
literal|0
argument_list|)
block|{
name|__stl_assert
argument_list|(
literal|0
operator|==
name|x
argument_list|)
block|;     }
name|__rope_charT_ptr_proxy
operator|&
name|operator
operator|=
operator|(
specifier|const
name|__rope_charT_ptr_proxy
operator|&
name|x
operator|)
block|{
name|pos
operator|=
name|x
operator|.
name|pos
block|;
name|current
operator|=
name|x
operator|.
name|current
block|;
name|current_valid
operator|=
name|x
operator|.
name|current_valid
block|;
name|root
operator|=
name|x
operator|.
name|root
block|;
return|return
operator|*
name|this
return|;
block|}
name|friend
name|bool
name|operator
operator|==
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|__rope_charT_ptr_proxy
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|,
specifier|const
name|__rope_charT_ptr_proxy
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
if|if
condition|(
name|current_valid
condition|)
block|{
return|return
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|root
operator|,
name|pos
operator|,
name|current
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|root
operator|,
name|pos
operator|)
return|;
block|}
end_else

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Rope iterators:
end_comment

begin_comment
comment|// Unlike in the C version, we cache only part of the stack
end_comment

begin_comment
comment|// for rope iterators, since they must be efficiently copyable.
end_comment

begin_comment
comment|// When we run out of cache, we have to reconstruct the iterator
end_comment

begin_comment
comment|// value.
end_comment

begin_comment
comment|// Pointers from iterators are not included in reference counts.
end_comment

begin_comment
comment|// Iterators are assumed to be thread private.  Ropes can
end_comment

begin_comment
comment|// be shared.
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
end_if

begin_pragma
pragma|#
directive|pragma
name|set
name|woff
name|1375
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|class
name|__rope_iterator_base
operator|:
name|public
name|random_access_iterator
operator|<
name|charT
operator|,
name|ptrdiff_t
operator|>
block|{
name|friend
name|class
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
block|;
name|public
operator|:
typedef|typedef
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|RopeBase
expr_stmt|;
comment|// Borland doesnt want this to be protected.
name|protected
operator|:
block|enum
block|{
name|path_cache_len
operator|=
literal|4
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Must be<= 9.
end_comment

begin_enum
enum|enum
block|{
name|iterator_buf_len
init|=
literal|15
block|}
enum|;
end_enum

begin_decl_stmt
name|size_t
name|current_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RopeBase
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The whole rope.
end_comment

begin_decl_stmt
name|size_t
name|leaf_pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Starting position for current leaf
end_comment

begin_decl_stmt
name|__GC_CONST
name|charT
modifier|*
name|buf_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Buffer possibly
end_comment

begin_comment
comment|// containing current char.
end_comment

begin_decl_stmt
name|__GC_CONST
name|charT
modifier|*
name|buf_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Pointer to current char in buffer.
end_comment

begin_comment
comment|// != 0 ==> buffer valid.
end_comment

begin_decl_stmt
name|__GC_CONST
name|charT
modifier|*
name|buf_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|// One past last valid char in buffer.
end_comment

begin_comment
comment|// What follows is the path cache.  We go out of our
end_comment

begin_comment
comment|// way to make this compact.
end_comment

begin_comment
comment|// Path_end contains the bottom section of the path from
end_comment

begin_comment
comment|// the root to the current leaf.
end_comment

begin_decl_stmt
specifier|const
name|RopeBase
modifier|*
name|path_end
index|[
name|path_cache_len
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|leaf_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Last valid pos in path_end;
end_comment

begin_comment
comment|// path_end[0] ... path_end[leaf_index-1]
end_comment

begin_comment
comment|// point to concatenation nodes.
end_comment

begin_decl_stmt
name|unsigned
name|char
name|path_directions
decl_stmt|;
end_decl_stmt

begin_comment
comment|// (path_directions>> i)& 1 is 1
end_comment

begin_comment
comment|// iff we got from path_end[leaf_index - i - 1]
end_comment

begin_comment
comment|// to path_end[leaf_index - i] by going to the
end_comment

begin_comment
comment|// right. Assumes path_cache_len<= 9.
end_comment

begin_decl_stmt
name|charT
name|tmp_buf
index|[
name|iterator_buf_len
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Short buffer for surrounding chars.
end_comment

begin_comment
comment|// This is useful primarily for
end_comment

begin_comment
comment|// RopeFunctions.  We put the buffer
end_comment

begin_comment
comment|// here to avoid locking in the
end_comment

begin_comment
comment|// multithreaded case.
end_comment

begin_comment
comment|// The cached path is generally assumed to be valid
end_comment

begin_comment
comment|// only if the buffer is valid.
end_comment

begin_function_decl
specifier|static
name|void
name|setbuf
parameter_list|(
name|__rope_iterator_base
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Set buffer contents given
end_comment

begin_comment
comment|// path cache.
end_comment

begin_function_decl
specifier|static
name|void
name|setcache
parameter_list|(
name|__rope_iterator_base
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Set buffer contents and
end_comment

begin_comment
comment|// path cache.
end_comment

begin_function_decl
specifier|static
name|void
name|setcache_for_incr
parameter_list|(
name|__rope_iterator_base
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// As above, but assumes path
end_comment

begin_comment
comment|// cache is valid for previous posn.
end_comment

begin_macro
name|__rope_iterator_base
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|__rope_iterator_base
argument_list|(
argument|RopeBase * root
argument_list|,
argument|size_t pos
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|root
argument_list|(
name|root
argument_list|)
operator|,
name|current_pos
argument_list|(
name|pos
argument_list|)
operator|,
name|buf_ptr
argument_list|(
literal|0
argument_list|)
block|{}
name|__rope_iterator_base
argument_list|(
argument|const __rope_iterator_base& x
argument_list|)
block|{
if|if
condition|(
literal|0
operator|!=
name|x
operator|.
name|buf_ptr
condition|)
block|{
operator|*
name|this
operator|=
name|x
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|current_pos
operator|=
name|x
operator|.
name|current_pos
expr_stmt|;
name|root
operator|=
name|x
operator|.
name|root
expr_stmt|;
name|buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_macro
unit|}     void
name|incr
argument_list|(
argument|size_t n
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|decr
parameter_list|(
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|size_t
name|index
argument_list|()
specifier|const
block|{
return|return
name|current_pos
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|class
name|__rope_iterator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|class
name|__rope_const_iterator
operator|:
name|public
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
block|{
name|friend
name|class
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
block|;
name|protected
operator|:
name|__rope_const_iterator
argument_list|(
argument|const RopeBase * root
argument_list|,
argument|size_t pos
argument_list|)
operator|:
name|__rope_iterator_base
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|(
name|const_cast
operator|<
name|RopeBase
operator|*
operator|>
operator|(
name|root
operator|)
operator|,
name|pos
operator|)
comment|// Only nonconst iterators modify root ref count
block|{}
name|public
operator|:
typedef|typedef
name|charT
name|reference
typedef|;
end_expr_stmt

begin_comment
comment|// Really a value.  Returning a reference
end_comment

begin_comment
comment|// Would be a mess, since it would have
end_comment

begin_comment
comment|// to be included in refcount.
end_comment

begin_typedef
typedef|typedef
specifier|const
name|charT
modifier|*
name|pointer
typedef|;
end_typedef

begin_label
name|public
label|:
end_label

begin_macro
name|__rope_const_iterator
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|__rope_const_iterator
argument_list|(
specifier|const
name|__rope_const_iterator
operator|&
name|x
argument_list|)
operator|:
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|x
operator|)
block|{ }
name|__rope_const_iterator
argument_list|(
specifier|const
name|__rope_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|__rope_const_iterator
argument_list|(
argument|const rope<charT
argument_list|,
argument|Alloc>&r
argument_list|,
argument|size_t pos
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|r
operator|.
name|tree_ptr
operator|,
name|pos
operator|)
block|{}
name|__rope_const_iterator
operator|&
name|operator
operator|=
operator|(
specifier|const
name|__rope_const_iterator
operator|&
name|x
operator|)
block|{
if|if
condition|(
literal|0
operator|!=
name|x
operator|.
name|buf_ptr
condition|)
block|{
operator|*
name|this
operator|=
name|x
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|current_pos
operator|=
name|x
operator|.
name|current_pos
expr_stmt|;
name|root
operator|=
name|x
operator|.
name|root
expr_stmt|;
name|buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|(
operator|*
name|this
operator|)
return|;
end_return

begin_macro
unit|}     reference
name|operator
end_macro

begin_expr_stmt
operator|*
operator|(
operator|)
block|{
if|if
condition|(
literal|0
operator|==
name|buf_ptr
condition|)
name|setcache
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|buf_ptr
return|;
end_return

begin_expr_stmt
unit|}     __rope_const_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|__GC_CONST
name|charT
operator|*
name|next
block|;
if|if
condition|(
literal|0
operator|!=
name|buf_ptr
operator|&&
operator|(
name|next
operator|=
name|buf_ptr
operator|+
literal|1
operator|)
operator|<
name|buf_end
condition|)
block|{
name|buf_ptr
operator|=
name|next
expr_stmt|;
operator|++
name|current_pos
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|incr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}     __rope_const_iterator
operator|&
name|operator
operator|+=
operator|(
name|ptrdiff_t
name|n
operator|)
block|{
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|incr
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|decr
argument_list|(
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}     __rope_const_iterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
name|decr
argument_list|(
literal|1
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__rope_const_iterator
operator|&
name|operator
operator|-=
operator|(
name|ptrdiff_t
name|n
operator|)
block|{
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|decr
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|incr
argument_list|(
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}     __rope_const_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|size_t
name|old_pos
operator|=
name|current_pos
block|;
name|incr
argument_list|(
literal|1
argument_list|)
block|;
return|return
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|root
operator|,
name|old_pos
operator|)
return|;
comment|// This makes a subsequent dereference expensive.
comment|// Perhaps we should instead copy the iterator
comment|// if it has a valid cache?
block|}
end_expr_stmt

begin_expr_stmt
name|__rope_const_iterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|size_t
name|old_pos
operator|=
name|current_pos
block|;
name|decr
argument_list|(
literal|1
argument_list|)
block|;
return|return
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|root
operator|,
name|old_pos
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|-
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|const __rope_const_iterator<charT
argument_list|,
argument|Alloc>& x
argument_list|,
argument|ptrdiff_t n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|const __rope_const_iterator<charT
argument_list|,
argument|Alloc>& x
argument_list|,
argument|ptrdiff_t n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|ptrdiff_t n
argument_list|,
argument|const __rope_const_iterator<charT
argument_list|,
argument|Alloc>& x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|reference
name|operator
function|[]
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
return|return
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|fetch
argument_list|(
name|root
argument_list|,
name|current_pos
operator|+
name|n
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|__rope_const_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|,
specifier|const
name|__rope_const_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|<
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|__rope_const_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|,
specifier|const
name|__rope_const_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|ptrdiff_t
name|operator
operator|-
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|__rope_const_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|,
specifier|const
name|__rope_const_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|class
name|__rope_iterator
operator|:
name|public
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
block|{
name|friend
name|class
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
block|;
name|protected
operator|:
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|*
name|root_rope
block|;
comment|// root is treated as a cached version of this,
comment|// and is used to detect changes to the underlying
comment|// rope.
comment|// Root is included in the reference count.
comment|// This is necessary so that we can detect changes reliably.
comment|// Unfortunately, it requires careful bookkeeping for the
comment|// nonGC case.
name|__rope_iterator
argument_list|(
argument|rope<charT
argument_list|,
argument|Alloc> * r
argument_list|,
argument|size_t pos
argument_list|)
operator|:
name|__rope_iterator_base
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|(
name|r
operator|->
name|tree_ptr
operator|,
name|pos
operator|)
block|,
name|root_rope
argument_list|(
argument|r
argument_list|)
block|{
name|RopeBase
operator|::
name|ref
argument_list|(
name|root
argument_list|)
block|; 	     }
name|void
name|check
argument_list|()
block|;
name|public
operator|:
typedef|typedef
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|reference
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
name|pointer
expr_stmt|;
end_typedef

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|container
argument_list|()
block|{
return|return
operator|*
name|root_rope
return|;
block|}
end_expr_stmt

begin_macro
name|__rope_iterator
argument_list|()
end_macro

begin_block
block|{
name|root
operator|=
literal|0
expr_stmt|;
comment|// Needed for reference counting.
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|__rope_iterator
argument_list|(
specifier|const
name|__rope_iterator
operator|&
name|x
argument_list|)
operator|:
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|x
operator|)
block|{
name|root_rope
operator|=
name|x
operator|.
name|root_rope
block|;
name|RopeBase
operator|::
name|ref
argument_list|(
name|root
argument_list|)
block|;     }
name|__rope_iterator
argument_list|(
argument|rope<charT
argument_list|,
argument|Alloc>& r
argument_list|,
argument|size_t pos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|__rope_iterator
argument_list|()
block|{
name|RopeBase
operator|::
name|unref
argument_list|(
name|root
argument_list|)
block|;     }
name|__rope_iterator
operator|&
name|operator
operator|=
operator|(
specifier|const
name|__rope_iterator
operator|&
name|x
operator|)
block|{
name|RopeBase
operator|*
name|old
operator|=
name|root
block|;
name|RopeBase
operator|::
name|ref
argument_list|(
name|x
operator|.
name|root
argument_list|)
block|;
if|if
condition|(
literal|0
operator|!=
name|x
operator|.
name|buf_ptr
condition|)
block|{
operator|*
name|this
operator|=
name|x
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|current_pos
operator|=
name|x
operator|.
name|current_pos
expr_stmt|;
name|root
operator|=
name|x
operator|.
name|root
expr_stmt|;
name|root_rope
operator|=
name|x
operator|.
name|root_rope
expr_stmt|;
name|buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|RopeBase
operator|::
name|unref
argument_list|(
name|old
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|*
name|this
operator|)
return|;
end_return

begin_macro
unit|}     reference
name|operator
end_macro

begin_expr_stmt
operator|*
operator|(
operator|)
block|{
name|check
argument_list|()
block|;
if|if
condition|(
literal|0
operator|==
name|buf_ptr
condition|)
block|{
return|return
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|root_rope
operator|,
name|current_pos
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|root_rope
operator|,
name|current_pos
operator|,
operator|*
name|buf_ptr
operator|)
return|;
block|}
end_else

begin_expr_stmt
unit|}     __rope_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|incr
argument_list|(
literal|1
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__rope_iterator
operator|&
name|operator
operator|+=
operator|(
name|difference_type
name|n
operator|)
block|{
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|incr
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|decr
argument_list|(
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}     __rope_iterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
name|decr
argument_list|(
literal|1
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__rope_iterator
operator|&
name|operator
operator|-=
operator|(
name|difference_type
name|n
operator|)
block|{
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|decr
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|incr
argument_list|(
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}     __rope_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|size_t
name|old_pos
operator|=
name|current_pos
block|;
name|incr
argument_list|(
literal|1
argument_list|)
block|;
return|return
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|root_rope
operator|,
name|old_pos
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__rope_iterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|size_t
name|old_pos
operator|=
name|current_pos
block|;
name|decr
argument_list|(
literal|1
argument_list|)
block|;
return|return
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|root_rope
operator|,
name|old_pos
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|reference
name|operator
function|[]
parameter_list|(
name|ptrdiff_t
name|n
parameter_list|)
block|{
return|return
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|root_rope
operator|,
name|current_pos
operator|+
name|n
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|__rope_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|,
specifier|const
name|__rope_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|<
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|__rope_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|,
specifier|const
name|__rope_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|ptrdiff_t
name|operator
operator|-
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|__rope_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|x
argument_list|,
specifier|const
name|__rope_iterator
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|-
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|const __rope_iterator<charT
argument_list|,
argument|Alloc>& x
argument_list|,
argument|ptrdiff_t n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|const __rope_iterator<charT
argument_list|,
argument|Alloc>& x
argument_list|,
argument|ptrdiff_t n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|ptrdiff_t n
argument_list|,
argument|const __rope_iterator<charT
argument_list|,
argument|Alloc>& x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
unit|};
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
end_if

begin_pragma
pragma|#
directive|pragma
name|reset
name|woff
name|1375
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|class
name|rope
block|{
name|public
operator|:
typedef|typedef
name|charT
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|size_t
name|size_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|charT
name|const_reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|charT
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|const_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rope_charT_ptr_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|pointer
expr_stmt|;
end_typedef

begin_expr_stmt
name|friend
name|class
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_macro
name|friend
end_macro

begin_expr_stmt
unit|struct
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|__rope_iterator_base
operator|<
name|charT
operator|,
name|Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|__rope_charT_ptr_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|__rope_charT_ref_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_macro
name|friend
end_macro

begin_expr_stmt
unit|struct
name|__rope_RopeSubstring
operator|<
name|charT
operator|,
name|Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_typedef
typedef|typedef
name|__GC_CONST
name|charT
modifier|*
name|cstrptr
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_SGI_THREADS
end_ifdef

begin_function
specifier|static
name|cstrptr
name|atomic_swap
parameter_list|(
name|cstrptr
modifier|*
name|p
parameter_list|,
name|cstrptr
name|q
parameter_list|)
block|{
if|#
directive|if
name|__mips
operator|<
literal|3
operator|||
operator|!
operator|(
name|defined
argument_list|(
name|_ABIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_ABI64
argument_list|)
operator|)
return|return
operator|(
name|cstrptr
operator|)
name|test_and_set
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|p
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|q
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
name|cstrptr
operator|)
name|__test_and_set
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|p
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|q
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__STL_WIN32THREADS
argument_list|)
end_elif

begin_function
specifier|static
name|cstrptr
name|atomic_swap
parameter_list|(
name|cstrptr
modifier|*
name|p
parameter_list|,
name|cstrptr
name|q
parameter_list|)
block|{
return|return
operator|(
name|cstrptr
operator|)
name|InterlockedExchange
argument_list|(
operator|(
name|LPLONG
operator|)
name|p
argument_list|,
operator|(
name|LONG
operator|)
name|q
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__STL_PTHREADS
argument_list|)
end_elif

begin_comment
comment|// This should be portable, but performance is expected
end_comment

begin_comment
comment|// to be quite awful.  This really needs platform specific
end_comment

begin_comment
comment|// code.
end_comment

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|swap_lock
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|cstrptr
name|atomic_swap
parameter_list|(
name|cstrptr
modifier|*
name|p
parameter_list|,
name|cstrptr
name|q
parameter_list|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|swap_lock
argument_list|)
expr_stmt|;
name|cstrptr
name|result
init|=
operator|*
name|p
decl_stmt|;
operator|*
name|p
operator|=
name|q
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|swap_lock
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|cstrptr
name|atomic_swap
parameter_list|(
name|cstrptr
modifier|*
name|p
parameter_list|,
name|cstrptr
name|q
parameter_list|)
block|{
name|cstrptr
name|result
init|=
operator|*
name|p
decl_stmt|;
operator|*
name|p
operator|=
name|q
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|charT
name|empty_c_str
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|DataAlloc
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|__rope_RopeConcatenation
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|,
name|Alloc
operator|>
name|CAlloc
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|__rope_RopeLeaf
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|,
name|Alloc
operator|>
name|LAlloc
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|__rope_RopeFunction
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|,
name|Alloc
operator|>
name|FAlloc
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|simple_alloc
operator|<
name|__rope_RopeSubstring
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|,
name|Alloc
operator|>
name|SAlloc
expr_stmt|;
end_typedef

begin_function
specifier|static
name|bool
name|is0
parameter_list|(
name|charT
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
name|__eos
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|copy_max
init|=
literal|23
block|}
enum|;
end_enum

begin_comment
comment|// For strings shorter than copy_max, we copy to
end_comment

begin_comment
comment|// concatenate.
end_comment

begin_typedef
typedef|typedef
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|RopeBase
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rope_RopeConcatenation
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|RopeConcatenation
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rope_RopeLeaf
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|RopeLeaf
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rope_RopeFunction
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|RopeFunction
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|__rope_RopeSubstring
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|RopeSubstring
expr_stmt|;
end_typedef

begin_comment
comment|// The only data member of a rope:
end_comment

begin_decl_stmt
name|RopeBase
modifier|*
name|tree_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Retrieve a character at the indicated position.
end_comment

begin_function_decl
specifier|static
name|charT
name|fetch
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|,
name|size_type
name|pos
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_comment
comment|// Obtain a pointer to the character at the indicated position.
end_comment

begin_comment
comment|// The pointer can be used to change the character.
end_comment

begin_comment
comment|// If such a pointer cannot be produced, as is frequently the
end_comment

begin_comment
comment|// case, 0 is returned instead.
end_comment

begin_comment
comment|// (Returns nonzero only if all nodes in the path have a refcount
end_comment

begin_comment
comment|// of 1.)
end_comment

begin_function_decl
specifier|static
name|charT
modifier|*
name|fetch_ptr
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|,
name|size_type
name|pos
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bool
name|apply_to_pieces
argument_list|(
comment|// should be template parameter
name|__rope_char_consumer
operator|<
name|charT
operator|>
operator|&
name|c
argument_list|,
specifier|const
name|RopeBase
operator|*
name|r
argument_list|,
name|size_t
name|begin
argument_list|,
name|size_t
name|end
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// begin and end are assumed to be in range.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_function
specifier|static
name|void
name|unref
parameter_list|(
name|RopeBase
modifier|*
name|t
parameter_list|)
block|{
name|RopeBase
operator|::
name|unref
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ref
parameter_list|(
name|RopeBase
modifier|*
name|t
parameter_list|)
block|{
name|RopeBase
operator|::
name|ref
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __GC */
end_comment

begin_function
specifier|static
name|void
name|unref
parameter_list|(
name|RopeBase
modifier|*
name|t
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|ref
parameter_list|(
name|RopeBase
modifier|*
name|t
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__GC
end_ifdef

begin_typedef
typedef|typedef
name|__rope_RopeBase
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|*
name|self_destruct_ptr
expr_stmt|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|__rope_self_destruct_ptr
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|self_destruct_ptr
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// Result is counted in refcount.
end_comment

begin_function_decl
specifier|static
name|RopeBase
modifier|*
name|substring
parameter_list|(
name|RopeBase
modifier|*
name|base
parameter_list|,
name|size_t
name|start
parameter_list|,
name|size_t
name|endp1
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RopeBase
modifier|*
name|concat_char_iter
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|,
specifier|const
name|charT
modifier|*
name|iter
parameter_list|,
name|size_t
name|slen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Concatenate rope and char ptr, copying s.
end_comment

begin_comment
comment|// Should really take an arbitrary iterator.
end_comment

begin_comment
comment|// Result is counted in refcount.
end_comment

begin_function
specifier|static
name|RopeBase
modifier|*
name|destr_concat_char_iter
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|,
specifier|const
name|charT
modifier|*
name|iter
parameter_list|,
name|size_t
name|slen
parameter_list|)
comment|// As above, but one reference to r is about to be
comment|// destroyed.  Thus the pieces may be recycled if all
comment|// relevent reference counts are 1.
ifdef|#
directive|ifdef
name|__GC
comment|// We can't really do anything since refcounts are unavailable.
block|{
return|return
name|concat_char_iter
argument_list|(
name|r
argument_list|,
name|iter
argument_list|,
name|slen
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|RopeBase
modifier|*
name|concat
parameter_list|(
name|RopeBase
modifier|*
name|left
parameter_list|,
name|RopeBase
modifier|*
name|right
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// General concatenation on RopeBase.  Result
end_comment

begin_comment
comment|// has refcount of 1.  Adjusts argument refcounts.
end_comment

begin_label
name|public
label|:
end_label

begin_decl_stmt
name|void
name|apply_to_pieces
argument_list|(
name|size_t
name|begin
argument_list|,
name|size_t
name|end
argument_list|,
name|__rope_char_consumer
operator|<
name|charT
operator|>
operator|&
name|c
argument_list|)
decl|const
block|{
name|apply_to_pieces
argument_list|(
name|c
argument_list|,
name|tree_ptr
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_function
specifier|static
name|size_t
name|rounded_up_size
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
return|return
name|RopeBase
operator|::
name|rounded_up_size
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|allocated_capacity
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
if|if
condition|(
name|__is_basic_char_type
argument_list|(
operator|(
name|charT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
return|return
name|rounded_up_size
argument_list|(
name|n
argument_list|)
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|rounded_up_size
argument_list|(
name|n
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|// s should really be an arbitrary input iterator.
end_comment

begin_comment
comment|// Adds a trailing NULL for basic char types.
end_comment

begin_function
specifier|static
name|charT
modifier|*
name|alloc_copy
parameter_list|(
specifier|const
name|charT
modifier|*
name|s
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|charT
modifier|*
name|result
init|=
name|DataAlloc
operator|::
name|allocate
argument_list|(
name|rounded_up_size
argument_list|(
name|size
argument_list|)
argument_list|)
decl_stmt|;
name|uninitialized_copy_n
argument_list|(
name|s
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|__cond_store_eos
argument_list|(
name|result
index|[
name|size
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|// Basic constructors for rope tree nodes.
end_comment

begin_comment
comment|// These return tree nodes with a 0 reference count.
end_comment

begin_function_decl
specifier|static
name|RopeLeaf
modifier|*
name|RopeLeaf_from_char_ptr
parameter_list|(
name|__GC_CONST
name|charT
modifier|*
name|s
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Takes ownership of its argument.
end_comment

begin_comment
comment|// Result has refcount 1.
end_comment

begin_comment
comment|// In the nonGC, basic_char_type  case it assumes that s
end_comment

begin_comment
comment|// is eos-terminated.
end_comment

begin_comment
comment|// In the nonGC case, it was allocated from Alloc with
end_comment

begin_comment
comment|// rounded_up_size(size).
end_comment

begin_function
specifier|static
name|RopeLeaf
modifier|*
name|RopeLeaf_from_unowned_char_ptr
parameter_list|(
specifier|const
name|charT
modifier|*
name|s
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|charT
modifier|*
name|buf
init|=
name|alloc_copy
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|__STL_TRY
block|{
return|return
name|RopeLeaf_from_char_ptr
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
return|;
block|}
name|__STL_UNWIND
argument_list|(
argument|RopeBase::free_string(buf, size)
argument_list|)
block|}
end_function

begin_comment
comment|// Concatenation of nonempty strings.
end_comment

begin_comment
comment|// Always builds a concatenation node.
end_comment

begin_comment
comment|// Rebalances if the result is too deep.
end_comment

begin_comment
comment|// Result has refcount 1.
end_comment

begin_comment
comment|// Does not increment left and right ref counts even though
end_comment

begin_comment
comment|// they are referenced.
end_comment

begin_function_decl
specifier|static
name|RopeBase
modifier|*
name|tree_concat
parameter_list|(
name|RopeBase
modifier|*
name|left
parameter_list|,
name|RopeBase
modifier|*
name|right
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Result has refcount 1.
end_comment

begin_comment
comment|// If delete_fn is true, then fn is deleted when the rope
end_comment

begin_comment
comment|// becomes inaccessible.
end_comment

begin_decl_stmt
specifier|static
name|RopeFunction
modifier|*
name|RopeFunction_from_fn
argument_list|(
name|char_producer
operator|<
name|charT
operator|>
operator|*
name|fn
argument_list|,
name|size_t
name|size
argument_list|,
name|bool
name|delete_fn
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Concatenation helper functions
end_comment

begin_function_decl
specifier|static
name|RopeLeaf
modifier|*
name|leaf_concat_char_iter
parameter_list|(
name|RopeLeaf
modifier|*
name|r
parameter_list|,
specifier|const
name|charT
modifier|*
name|iter
parameter_list|,
name|size_t
name|slen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Concatenate by copying leaf.
end_comment

begin_comment
comment|// should take an arbitrary iterator
end_comment

begin_comment
comment|// result has refcount 1.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_function_decl
specifier|static
name|RopeLeaf
modifier|*
name|destr_leaf_concat_char_iter
parameter_list|(
name|RopeLeaf
modifier|*
name|r
parameter_list|,
specifier|const
name|charT
modifier|*
name|iter
parameter_list|,
name|size_t
name|slen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// A version that potentially clobbers r if r -> refcount == 1.
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// A helper function for exponentiating strings.
end_comment

begin_comment
comment|// This uses a nonstandard refcount convention.
end_comment

begin_comment
comment|// The result has refcount 0.
end_comment

begin_struct_decl
struct_decl|struct
name|concat_fn
struct_decl|;
end_struct_decl

begin_macro
name|friend
end_macro

begin_expr_stmt
unit|struct
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|concat_fn
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|concat_fn
range|:
name|public
name|binary_function
operator|<
name|rope
operator|<
name|charT
decl_stmt|,
name|Alloc
decl|>
decl_stmt|,
name|rope
decl|<
name|charT
decl_stmt|,
name|Alloc
decl|>
decl_stmt|,
name|rope
decl|<
name|charT
decl_stmt|,
name|Alloc
decl|>>
block|{
name|rope
name|operator
argument_list|()
operator|(
specifier|const
name|rope
operator|&
name|x
operator|,
specifier|const
name|rope
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|+
name|y
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|friend
name|rope
name|identity_element
parameter_list|(
name|concat_fn
parameter_list|)
block|{
return|return
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|size_t
name|char_ptr_len
parameter_list|(
specifier|const
name|charT
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// slightly generalized strlen
end_comment

begin_expr_stmt
name|rope
argument_list|(
name|RopeBase
operator|*
name|t
argument_list|)
operator|:
name|tree_ptr
argument_list|(
argument|t
argument_list|)
block|{ }
comment|// Copy r to the CharT buffer.
comment|// Returns buffer + r -> size.
comment|// Assumes that buffer is uninitialized.
specifier|static
name|charT
operator|*
name|flatten
argument_list|(
name|RopeBase
operator|*
name|r
argument_list|,
name|charT
operator|*
name|buffer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Again, with explicit starting position and length.
end_comment

begin_comment
comment|// Assumes that buffer is uninitialized.
end_comment

begin_function_decl
specifier|static
name|charT
modifier|*
name|flatten
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|,
name|size_t
name|start
parameter_list|,
name|size_t
name|len
parameter_list|,
name|charT
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|long
name|min_len
index|[
name|RopeBase
operator|::
name|max_rope_depth
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|is_balanced
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|size
operator|>=
name|min_len
index|[
name|r
operator|->
name|depth
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_almost_balanced
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|depth
operator|==
literal|0
operator|||
name|r
operator|->
name|size
operator|>=
name|min_len
index|[
name|r
operator|->
name|depth
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_roughly_balanced
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|depth
operator|<=
literal|1
operator|||
name|r
operator|->
name|size
operator|>=
name|min_len
index|[
name|r
operator|->
name|depth
operator|-
literal|2
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|// Assumes the result is not empty.
end_comment

begin_function
specifier|static
name|RopeBase
modifier|*
name|concat_and_set_balanced
parameter_list|(
name|RopeBase
modifier|*
name|left
parameter_list|,
name|RopeBase
modifier|*
name|right
parameter_list|)
block|{
name|RopeBase
modifier|*
name|result
init|=
name|concat
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_balanced
argument_list|(
name|result
argument_list|)
condition|)
name|result
operator|->
name|is_balanced
operator|=
name|true
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|// The basic rebalancing operation.  Logically copies the
end_comment

begin_comment
comment|// rope.  The result has refcount of 1.  The client will
end_comment

begin_comment
comment|// usually decrement the reference count of r.
end_comment

begin_comment
comment|// The result isd within height 2 of balanced by the above
end_comment

begin_comment
comment|// definition.
end_comment

begin_function_decl
specifier|static
name|RopeBase
modifier|*
name|balance
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Add all unbalanced subtrees to the forest of balanceed trees.
end_comment

begin_comment
comment|// Used only by balance.
end_comment

begin_function_decl
specifier|static
name|void
name|add_to_forest
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|,
name|RopeBase
modifier|*
modifier|*
name|forest
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Add r to forest, assuming r is already balanced.
end_comment

begin_function_decl
specifier|static
name|void
name|add_leaf_to_forest
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|,
name|RopeBase
modifier|*
modifier|*
name|forest
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Print to stdout, exposing structure
end_comment

begin_function_decl
specifier|static
name|void
name|dump
parameter_list|(
name|RopeBase
modifier|*
name|r
parameter_list|,
name|int
name|indent
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Return -1, 0, or 1 if x< y, x == y, or x> y resp.
end_comment

begin_function_decl
specifier|static
name|int
name|compare
parameter_list|(
specifier|const
name|RopeBase
modifier|*
name|x
parameter_list|,
specifier|const
name|RopeBase
modifier|*
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
literal|0
operator|==
name|tree_ptr
return|;
block|}
end_expr_stmt

begin_comment
comment|// Comparison member function.  This is public only for those
end_comment

begin_comment
comment|// clients that need a ternary comparison.  Others
end_comment

begin_comment
comment|// should use the comparison operators below.
end_comment

begin_decl_stmt
name|int
name|compare
argument_list|(
specifier|const
name|rope
operator|&
name|y
argument_list|)
decl|const
block|{
return|return
name|compare
argument_list|(
name|tree_ptr
argument_list|,
name|y
operator|.
name|tree_ptr
argument_list|)
return|;
block|}
end_decl_stmt

begin_macro
name|rope
argument_list|(
argument|const charT *s
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|len
init|=
name|char_ptr_len
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|len
condition|)
block|{
name|tree_ptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tree_ptr
operator|=
name|RopeLeaf_from_unowned_char_ptr
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__GC
name|__stl_assert
argument_list|(
literal|1
operator|==
name|tree_ptr
operator|->
name|refcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|rope
argument_list|(
argument|const charT *s
argument_list|,
argument|size_t len
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
literal|0
operator|==
name|len
condition|)
block|{
name|tree_ptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tree_ptr
operator|=
name|RopeLeaf_from_unowned_char_ptr
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rope
argument_list|(
argument|const charT *s
argument_list|,
argument|charT *e
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|len
init|=
name|e
operator|-
name|s
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|len
condition|)
block|{
name|tree_ptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tree_ptr
operator|=
name|RopeLeaf_from_unowned_char_ptr
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rope
argument_list|(
argument|const const_iterator& s
argument_list|,
argument|const const_iterator& e
argument_list|)
end_macro

begin_block
block|{
name|tree_ptr
operator|=
name|substring
argument_list|(
name|s
operator|.
name|root
argument_list|,
name|s
operator|.
name|current_pos
argument_list|,
name|e
operator|.
name|current_pos
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rope
argument_list|(
argument|const iterator& s
argument_list|,
argument|const iterator& e
argument_list|)
end_macro

begin_block
block|{
name|tree_ptr
operator|=
name|substring
argument_list|(
name|s
operator|.
name|root
argument_list|,
name|s
operator|.
name|current_pos
argument_list|,
name|e
operator|.
name|current_pos
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rope
argument_list|(
argument|charT c
argument_list|)
end_macro

begin_block
block|{
name|charT
modifier|*
name|buf
init|=
name|DataAlloc
operator|::
name|allocate
argument_list|(
name|rounded_up_size
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|construct
argument_list|(
name|buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|__STL_TRY
block|{
name|tree_ptr
operator|=
name|RopeLeaf_from_char_ptr
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|RopeBase::free_string(buf,
literal|1
argument|)
argument_list|)
block|}
end_block

begin_macro
name|rope
argument_list|(
argument|size_t n
argument_list|,
argument|charT c
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Should really be templatized with respect to the iterator type
end_comment

begin_comment
comment|// and use sequence_buffer.  (It should perhaps use sequence_buffer
end_comment

begin_comment
comment|// even now.)
end_comment

begin_macro
name|rope
argument_list|(
argument|const charT *i
argument_list|,
argument|const charT *j
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|i
operator|==
name|j
condition|)
block|{
name|tree_ptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|len
init|=
name|j
operator|-
name|i
decl_stmt|;
name|tree_ptr
operator|=
name|RopeLeaf_from_unowned_char_ptr
argument_list|(
name|i
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rope
argument_list|()
end_macro

begin_block
block|{
name|tree_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|// Construct a rope from a function that can compute its members
end_comment

begin_macro
name|rope
argument_list|(
argument|char_producer<charT> *fn
argument_list|,
argument|size_t len
argument_list|,
argument|bool delete_fn
argument_list|)
end_macro

begin_block
block|{
name|tree_ptr
operator|=
name|RopeFunction_from_fn
argument_list|(
name|fn
argument_list|,
name|len
argument_list|,
name|delete_fn
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rope
argument_list|(
argument|const rope&x
argument_list|)
end_macro

begin_block
block|{
name|tree_ptr
operator|=
name|x
operator|.
name|tree_ptr
expr_stmt|;
name|ref
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
operator|~
name|rope
argument_list|()
block|{
name|unref
argument_list|(
name|tree_ptr
argument_list|)
block|; 	}
name|rope
operator|&
name|operator
operator|=
operator|(
specifier|const
name|rope
operator|&
name|x
operator|)
block|{
name|RopeBase
operator|*
name|old
operator|=
name|tree_ptr
block|;
name|tree_ptr
operator|=
name|x
operator|.
name|tree_ptr
block|;
name|ref
argument_list|(
name|tree_ptr
argument_list|)
block|;
name|unref
argument_list|(
name|old
argument_list|)
block|;
return|return
operator|(
operator|*
name|this
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|push_back
parameter_list|(
name|charT
name|x
parameter_list|)
block|{
name|RopeBase
modifier|*
name|old
init|=
name|tree_ptr
decl_stmt|;
name|tree_ptr
operator|=
name|concat_char_iter
argument_list|(
name|tree_ptr
argument_list|,
operator|&
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_back
parameter_list|()
block|{
name|RopeBase
modifier|*
name|old
init|=
name|tree_ptr
decl_stmt|;
name|tree_ptr
operator|=
name|substring
argument_list|(
name|tree_ptr
argument_list|,
literal|0
argument_list|,
name|tree_ptr
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|charT
name|back
argument_list|()
specifier|const
block|{
return|return
name|fetch
argument_list|(
name|tree_ptr
argument_list|,
name|tree_ptr
operator|->
name|size
operator|-
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|push_front
parameter_list|(
name|charT
name|x
parameter_list|)
block|{
name|RopeBase
modifier|*
name|old
init|=
name|tree_ptr
decl_stmt|;
name|RopeBase
modifier|*
name|left
decl_stmt|;
name|left
operator|=
name|RopeLeaf_from_unowned_char_ptr
argument_list|(
operator|&
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__STL_TRY
block|{
name|tree_ptr
operator|=
name|concat
argument_list|(
name|left
argument_list|,
name|tree_ptr
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|left
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|unref(left)
argument_list|)
block|}
end_function

begin_function
name|void
name|pop_front
parameter_list|()
block|{
name|RopeBase
modifier|*
name|old
init|=
name|tree_ptr
decl_stmt|;
name|tree_ptr
operator|=
name|substring
argument_list|(
name|tree_ptr
argument_list|,
literal|1
argument_list|,
name|tree_ptr
operator|->
name|size
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|charT
name|front
argument_list|()
specifier|const
block|{
return|return
name|fetch
argument_list|(
name|tree_ptr
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|balance
parameter_list|()
block|{
name|RopeBase
modifier|*
name|old
init|=
name|tree_ptr
decl_stmt|;
name|tree_ptr
operator|=
name|balance
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|copy
argument_list|(
name|charT
operator|*
name|buffer
argument_list|)
decl|const
block|{
name|destroy
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|+
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|flatten
argument_list|(
name|tree_ptr
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// This is the copy function from the standard, but
end_comment

begin_comment
comment|// with the arguments reordered to make it consistent with the
end_comment

begin_comment
comment|// rest of the interface.
end_comment

begin_comment
comment|// Note that this guaranteed not to compile if the draft standard
end_comment

begin_comment
comment|// order is assumed.
end_comment

begin_decl_stmt
name|size_type
name|copy
argument_list|(
name|size_type
name|pos
argument_list|,
name|size_type
name|n
argument_list|,
name|charT
operator|*
name|buffer
argument_list|)
decl|const
block|{
name|size_t
name|sz
init|=
name|size
argument_list|()
decl_stmt|;
name|size_t
name|len
init|=
operator|(
name|pos
operator|+
name|n
operator|>
name|sz
condition|?
name|sz
operator|-
name|pos
else|:
name|n
operator|)
decl_stmt|;
name|destroy
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|+
name|len
argument_list|)
expr_stmt|;
name|flatten
argument_list|(
name|tree_ptr
argument_list|,
name|pos
argument_list|,
name|len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_decl_stmt

begin_comment
comment|// Print to stdout, exposing structure.  May be useful for
end_comment

begin_comment
comment|// performance debugging.
end_comment

begin_function
name|void
name|dump
parameter_list|()
block|{
name|dump
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Convert to 0 terminated string in new allocated memory.
end_comment

begin_comment
comment|// Embedded 0s in the input do not terminate the copy.
end_comment

begin_expr_stmt
specifier|const
name|charT
operator|*
name|c_str
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|// As above, but lso use the flattened representation as the
end_comment

begin_comment
comment|// the new rope representation.
end_comment

begin_function_decl
specifier|const
name|charT
modifier|*
name|replace_with_c_str
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Reclaim memory for the c_str generated flattened string.
end_comment

begin_comment
comment|// Intentionally undocumented, since it's hard to say when this
end_comment

begin_comment
comment|// is safe for multiple threads.
end_comment

begin_function
name|void
name|delete_c_str
parameter_list|()
block|{
if|if
condition|(
literal|0
operator|==
name|tree_ptr
condition|)
return|return;
if|if
condition|(
name|RopeBase
operator|::
name|leaf
operator|==
name|tree_ptr
operator|->
name|tag
operator|&&
operator|(
operator|(
name|RopeLeaf
operator|*
operator|)
name|tree_ptr
operator|)
operator|->
name|data
operator|==
name|tree_ptr
operator|->
name|c_string
condition|)
block|{
comment|// Representation shared
return|return;
block|}
ifndef|#
directive|ifndef
name|__GC
name|tree_ptr
operator|->
name|free_c_string
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tree_ptr
operator|->
name|c_string
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|charT
name|operator
index|[]
argument_list|(
name|size_type
name|pos
argument_list|)
decl|const
block|{
return|return
name|fetch
argument_list|(
name|tree_ptr
argument_list|,
name|pos
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|charT
name|at
argument_list|(
name|size_type
name|pos
argument_list|)
decl|const
block|{
comment|// if (pos>= size()) throw out_of_range;
return|return
operator|(
operator|*
name|this
operator|)
index|[
name|pos
index|]
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
argument_list|(
name|tree_ptr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// An easy way to get a const iterator from a non-const container.
end_comment

begin_expr_stmt
name|const_iterator
name|const_begin
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
argument_list|(
name|tree_ptr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
argument_list|(
name|tree_ptr
argument_list|,
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_iterator
name|const_end
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
argument_list|(
name|tree_ptr
argument_list|,
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
operator|(
literal|0
operator|==
name|tree_ptr
operator|?
literal|0
operator|:
name|tree_ptr
operator|->
name|size
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|length
argument_list|()
specifier|const
block|{
return|return
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|min_len
index|[
name|RopeBase
operator|::
name|max_rope_depth
operator|-
literal|1
index|]
operator|-
literal|1
return|;
comment|//  Guarantees that the result can be sufficirntly
comment|//  balanced.  Longer ropes will probably still work,
comment|//  but it's harder to make guarantees.
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_CLASS_PARTIAL_SPECIALIZATION
end_ifdef

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|const_iterator
operator|>
name|const_reverse_iterator
expr_stmt|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|const_iterator
operator|,
name|value_type
operator|,
name|const_reference
operator|,
name|difference_type
operator|>
name|const_reverse_iterator
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_expr_stmt
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_reverse_iterator
name|const_rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_reverse_iterator
name|const_rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|rope
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|left
argument_list|,
specifier|const
name|rope
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|right
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|rope
operator|<
name|charT
argument_list|,
name|Alloc
operator|>
operator|&
name|left
argument_list|,
specifier|const
name|charT
operator|*
name|right
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|const rope<charT
argument_list|,
argument|Alloc>&left
argument_list|,
argument|charT right
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// The symmetric cases are intentionally omitted, since they're presumed
end_comment

begin_comment
comment|// to be less common, and we don't handle them as well.
end_comment

begin_comment
comment|// The following should really be templatized.
end_comment

begin_comment
comment|// The first argument should be an input iterator or
end_comment

begin_comment
comment|// forward iterator with value_type charT.
end_comment

begin_function
name|rope
modifier|&
name|append
parameter_list|(
specifier|const
name|charT
modifier|*
name|iter
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|RopeBase
modifier|*
name|result
init|=
name|destr_concat_char_iter
argument_list|(
name|tree_ptr
argument_list|,
name|iter
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|unref
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
name|tree_ptr
operator|=
name|result
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
specifier|const
name|charT
modifier|*
name|c_string
parameter_list|)
block|{
name|size_t
name|len
init|=
name|char_ptr_len
argument_list|(
name|c_string
argument_list|)
decl_stmt|;
name|append
argument_list|(
name|c_string
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|this
operator|)
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
specifier|const
name|charT
modifier|*
name|s
parameter_list|,
specifier|const
name|charT
modifier|*
name|e
parameter_list|)
block|{
name|RopeBase
modifier|*
name|result
init|=
name|destr_concat_char_iter
argument_list|(
name|tree_ptr
argument_list|,
name|s
argument_list|,
name|e
operator|-
name|s
argument_list|)
decl_stmt|;
name|unref
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
name|tree_ptr
operator|=
name|result
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
name|const_iterator
name|s
parameter_list|,
name|const_iterator
name|e
parameter_list|)
block|{
name|__stl_assert
argument_list|(
name|s
operator|.
name|root
operator|==
name|e
operator|.
name|root
argument_list|)
expr_stmt|;
name|self_destruct_ptr
name|appendee
argument_list|(
name|substring
argument_list|(
name|s
operator|.
name|root
argument_list|,
name|s
operator|.
name|current_pos
argument_list|,
name|e
operator|.
name|current_pos
argument_list|)
argument_list|)
decl_stmt|;
name|RopeBase
modifier|*
name|result
init|=
name|concat
argument_list|(
name|tree_ptr
argument_list|,
operator|(
name|RopeBase
operator|*
operator|)
name|appendee
argument_list|)
decl_stmt|;
name|unref
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
name|tree_ptr
operator|=
name|result
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
name|charT
name|c
parameter_list|)
block|{
name|RopeBase
modifier|*
name|result
init|=
name|destr_concat_char_iter
argument_list|(
name|tree_ptr
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unref
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
name|tree_ptr
operator|=
name|result
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|()
block|{
return|return
name|append
argument_list|(
name|charT
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
specifier|const
name|rope
modifier|&
name|y
parameter_list|)
block|{
name|RopeBase
modifier|*
name|result
init|=
name|concat
argument_list|(
name|tree_ptr
argument_list|,
name|y
operator|.
name|tree_ptr
argument_list|)
decl_stmt|;
name|unref
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
name|tree_ptr
operator|=
name|result
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
name|size_t
name|n
parameter_list|,
name|charT
name|c
parameter_list|)
block|{
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|last
argument_list|(
name|n
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|append
argument_list|(
name|last
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|swap
parameter_list|(
name|rope
modifier|&
name|b
parameter_list|)
block|{
name|RopeBase
modifier|*
name|tmp
init|=
name|tree_ptr
decl_stmt|;
name|tree_ptr
operator|=
name|b
operator|.
name|tree_ptr
expr_stmt|;
name|b
operator|.
name|tree_ptr
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_comment
comment|// Result is included in refcount.
end_comment

begin_function
specifier|static
name|RopeBase
modifier|*
name|replace
parameter_list|(
name|RopeBase
modifier|*
name|old
parameter_list|,
name|size_t
name|pos1
parameter_list|,
name|size_t
name|pos2
parameter_list|,
name|RopeBase
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|old
condition|)
block|{
name|ref
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|self_destruct_ptr
name|left
argument_list|(
name|substring
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|pos1
argument_list|)
argument_list|)
decl_stmt|;
name|self_destruct_ptr
name|right
argument_list|(
name|substring
argument_list|(
name|old
argument_list|,
name|pos2
argument_list|,
name|old
operator|->
name|size
argument_list|)
argument_list|)
decl_stmt|;
name|RopeBase
modifier|*
name|result
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|r
condition|)
block|{
name|result
operator|=
name|concat
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|self_destruct_ptr
name|left_result
argument_list|(
name|concat
argument_list|(
name|left
argument_list|,
name|r
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|=
name|concat
argument_list|(
name|left_result
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|rope
modifier|&
name|r
parameter_list|)
block|{
name|RopeBase
modifier|*
name|result
init|=
name|replace
argument_list|(
name|tree_ptr
argument_list|,
name|p
argument_list|,
name|p
argument_list|,
name|r
operator|.
name|tree_ptr
argument_list|)
decl_stmt|;
name|unref
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
name|tree_ptr
operator|=
name|result
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|charT
name|c
parameter_list|)
block|{
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|r
argument_list|(
name|n
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|self_destruct_ptr
name|left
argument_list|(
name|substring
argument_list|(
name|tree_ptr
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|self_destruct_ptr
name|right
argument_list|(
name|substring
argument_list|(
name|tree_ptr
argument_list|,
name|p
argument_list|,
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|self_destruct_ptr
name|left_result
argument_list|(
name|concat_char_iter
argument_list|(
name|left
argument_list|,
name|i
argument_list|,
name|n
argument_list|)
argument_list|)
decl_stmt|;
name|RopeBase
modifier|*
name|result
init|=
name|concat
argument_list|(
name|left_result
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|unref
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
name|tree_ptr
operator|=
name|result
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|c_string
parameter_list|)
block|{
name|insert
argument_list|(
name|p
argument_list|,
name|c_string
argument_list|,
name|char_ptr_len
argument_list|(
name|c_string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|p
parameter_list|,
name|charT
name|c
parameter_list|)
block|{
name|insert
argument_list|(
name|p
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|p
parameter_list|)
block|{
name|charT
name|c
init|=
name|charT
argument_list|()
decl_stmt|;
name|insert
argument_list|(
name|p
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
specifier|const
name|charT
modifier|*
name|j
parameter_list|)
block|{
name|rope
name|r
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|insert
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|i
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|j
parameter_list|)
block|{
name|rope
name|r
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|insert
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|i
parameter_list|,
specifier|const
name|iterator
modifier|&
name|j
parameter_list|)
block|{
name|rope
name|r
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|insert
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// (position, length) versions of replace operations:
end_comment

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|rope
modifier|&
name|r
parameter_list|)
block|{
name|RopeBase
modifier|*
name|result
init|=
name|replace
argument_list|(
name|tree_ptr
argument_list|,
name|p
argument_list|,
name|p
operator|+
name|n
argument_list|,
name|r
operator|.
name|tree_ptr
argument_list|)
decl_stmt|;
name|unref
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
name|tree_ptr
operator|=
name|result
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
name|size_t
name|i_len
parameter_list|)
block|{
name|rope
name|r
argument_list|(
name|i
argument_list|,
name|i_len
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|charT
name|c
parameter_list|)
block|{
name|rope
name|r
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|charT
modifier|*
name|c_string
parameter_list|)
block|{
name|rope
name|r
argument_list|(
name|c_string
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
specifier|const
name|charT
modifier|*
name|j
parameter_list|)
block|{
name|rope
name|r
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|i
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|j
parameter_list|)
block|{
name|rope
name|r
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|iterator
modifier|&
name|i
parameter_list|,
specifier|const
name|iterator
modifier|&
name|j
parameter_list|)
block|{
name|rope
name|r
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Single character variants:
end_comment

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
name|charT
name|c
parameter_list|)
block|{
name|iterator
name|i
argument_list|(
name|this
argument_list|,
name|p
argument_list|)
decl_stmt|;
operator|*
name|i
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|rope
modifier|&
name|r
parameter_list|)
block|{
name|replace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
name|size_t
name|i_len
parameter_list|)
block|{
name|replace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|i_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|c_string
parameter_list|)
block|{
name|replace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|c_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
specifier|const
name|charT
modifier|*
name|j
parameter_list|)
block|{
name|replace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|i
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|j
parameter_list|)
block|{
name|replace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|i
parameter_list|,
specifier|const
name|iterator
modifier|&
name|j
parameter_list|)
block|{
name|replace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Erase, (position, size) variant.
end_comment

begin_function
name|void
name|erase
parameter_list|(
name|size_t
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|RopeBase
modifier|*
name|result
init|=
name|replace
argument_list|(
name|tree_ptr
argument_list|,
name|p
argument_list|,
name|p
operator|+
name|n
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unref
argument_list|(
name|tree_ptr
argument_list|)
expr_stmt|;
name|tree_ptr
operator|=
name|result
expr_stmt|;
block|}
end_function

begin_comment
comment|// Erase, single character
end_comment

begin_function
name|void
name|erase
parameter_list|(
name|size_t
name|p
parameter_list|)
block|{
name|erase
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Insert, iterator variants.
end_comment

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|rope
modifier|&
name|r
parameter_list|)
block|{
name|insert
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|charT
name|c
parameter_list|)
block|{
name|insert
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|n
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
name|charT
name|c
parameter_list|)
block|{
name|insert
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|)
block|{
name|insert
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|c_string
parameter_list|)
block|{
name|insert
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|c_string
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|insert
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
specifier|const
name|charT
modifier|*
name|j
parameter_list|)
block|{
name|insert
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|i
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|j
parameter_list|)
block|{
name|insert
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|i
parameter_list|,
specifier|const
name|iterator
modifier|&
name|j
parameter_list|)
block|{
name|insert
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|// Replace, range variants.
end_comment

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|q
parameter_list|,
specifier|const
name|rope
modifier|&
name|r
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|q
operator|.
name|index
argument_list|()
operator|-
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|q
parameter_list|,
name|charT
name|c
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|q
operator|.
name|index
argument_list|()
operator|-
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|q
parameter_list|,
specifier|const
name|charT
modifier|*
name|c_string
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|q
operator|.
name|index
argument_list|()
operator|-
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|c_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|q
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|q
operator|.
name|index
argument_list|()
operator|-
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|q
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
specifier|const
name|charT
modifier|*
name|j
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|q
operator|.
name|index
argument_list|()
operator|-
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|q
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|i
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|j
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|q
operator|.
name|index
argument_list|()
operator|-
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|q
parameter_list|,
specifier|const
name|iterator
modifier|&
name|i
parameter_list|,
specifier|const
name|iterator
modifier|&
name|j
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|q
operator|.
name|index
argument_list|()
operator|-
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Replace, iterator variants.
end_comment

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|rope
modifier|&
name|r
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
name|charT
name|c
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|c_string
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|c_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|charT
modifier|*
name|i
parameter_list|,
specifier|const
name|charT
modifier|*
name|j
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
name|const_iterator
name|i
parameter_list|,
name|const_iterator
name|j
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
name|iterator
name|i
parameter_list|,
name|iterator
name|j
parameter_list|)
block|{
name|replace
argument_list|(
name|p
operator|.
name|index
argument_list|()
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Iterator and range variants of erase
end_comment

begin_function
name|iterator
name|erase
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|q
parameter_list|)
block|{
name|size_t
name|p_index
init|=
name|p
operator|.
name|index
argument_list|()
decl_stmt|;
name|erase
argument_list|(
name|p_index
argument_list|,
name|q
operator|.
name|index
argument_list|()
operator|-
name|p_index
argument_list|)
expr_stmt|;
return|return
name|iterator
argument_list|(
name|this
argument_list|,
name|p_index
argument_list|)
return|;
block|}
end_function

begin_function
name|iterator
name|erase
parameter_list|(
specifier|const
name|iterator
modifier|&
name|p
parameter_list|)
block|{
name|size_t
name|p_index
init|=
name|p
operator|.
name|index
argument_list|()
decl_stmt|;
name|erase
argument_list|(
name|p_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|iterator
argument_list|(
name|this
argument_list|,
name|p_index
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|rope
name|substr
argument_list|(
name|size_t
name|start
argument_list|,
name|size_t
name|len
operator|=
literal|1
argument_list|)
decl|const
block|{
return|return
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|substring
argument_list|(
name|tree_ptr
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|len
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|rope
name|substr
argument_list|(
name|iterator
name|start
argument_list|,
name|iterator
name|end
argument_list|)
decl|const
block|{
return|return
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|substring
argument_list|(
name|tree_ptr
argument_list|,
name|start
operator|.
name|index
argument_list|()
argument_list|,
name|end
operator|.
name|index
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|rope
name|substr
argument_list|(
name|iterator
name|start
argument_list|)
decl|const
block|{
name|size_t
name|pos
init|=
name|start
operator|.
name|index
argument_list|()
decl_stmt|;
return|return
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|substring
argument_list|(
name|tree_ptr
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|rope
name|substr
argument_list|(
name|const_iterator
name|start
argument_list|,
name|const_iterator
name|end
argument_list|)
decl|const
block|{
comment|// This might eventually take advantage of the cache in the
comment|// iterator.
return|return
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|substring
argument_list|(
name|tree_ptr
argument_list|,
name|start
operator|.
name|index
argument_list|()
argument_list|,
name|end
operator|.
name|index
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|substr
argument_list|(
argument|const_iterator start
argument_list|)
block|{
name|size_t
name|pos
operator|=
name|start
operator|.
name|index
argument_list|()
block|;
return|return
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|substring
argument_list|(
name|tree_ptr
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|size_type
name|find
argument_list|(
name|charT
name|c
argument_list|,
name|size_type
name|pos
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|find
argument_list|(
name|charT
operator|*
name|s
argument_list|,
name|size_type
name|pos
operator|=
literal|0
argument_list|)
decl|const
block|{
name|const_iterator
name|result
init|=
name|search
argument_list|(
name|const_begin
argument_list|()
operator|+
name|pos
argument_list|,
name|const_end
argument_list|()
argument_list|,
name|s
argument_list|,
name|s
operator|+
name|char_ptr_len
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|result
operator|.
name|index
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|iterator
name|mutable_begin
parameter_list|()
block|{
return|return
operator|(
name|iterator
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|iterator
name|mutable_end
parameter_list|()
block|{
return|return
operator|(
name|iterator
argument_list|(
name|this
argument_list|,
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_CLASS_PARTIAL_SPECIALIZATION
end_ifdef

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|iterator
operator|>
name|reverse_iterator
expr_stmt|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|iterator
operator|,
name|value_type
operator|,
name|reference
operator|,
name|difference_type
operator|>
name|reverse_iterator
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_function
name|reverse_iterator
name|mutable_rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|mutable_end
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|reverse_iterator
name|mutable_rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|mutable_begin
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|reference
name|mutable_reference_at
parameter_list|(
name|size_type
name|pos
parameter_list|)
block|{
return|return
name|reference
argument_list|(
name|this
argument_list|,
name|pos
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STD_STUFF
end_ifdef

begin_function
name|reference
name|operator
function|[]
parameter_list|(
name|size_type
name|pos
parameter_list|)
block|{
return|return
name|charT_ref_proxy
argument_list|(
name|this
argument_list|,
name|pos
argument_list|)
return|;
block|}
end_function

begin_function
name|reference
name|at
parameter_list|(
name|size_type
name|pos
parameter_list|)
block|{
comment|// if (pos>= size()) throw out_of_range;
return|return
operator|(
operator|*
name|this
operator|)
index|[
name|pos
index|]
return|;
block|}
end_function

begin_function
name|void
name|resize
parameter_list|(
name|size_type
name|n
parameter_list|,
name|charT
name|c
parameter_list|)
block|{}
end_function

begin_function
name|void
name|resize
parameter_list|(
name|size_type
name|n
parameter_list|)
block|{}
end_function

begin_function
name|void
name|reserve
parameter_list|(
name|size_type
name|res_arg
init|=
literal|0
parameter_list|)
block|{}
end_function

begin_expr_stmt
name|size_type
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|max_size
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Stuff below this line is dangerous because it's error prone.
end_comment

begin_comment
comment|// I would really like to get rid of it.
end_comment

begin_comment
comment|// copy function with funny arg ordering.
end_comment

begin_decl_stmt
name|size_type
name|copy
argument_list|(
name|charT
operator|*
name|buffer
argument_list|,
name|size_type
name|n
argument_list|,
name|size_type
name|pos
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|copy
argument_list|(
name|pos
argument_list|,
name|n
argument_list|,
name|buffer
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|iterator
name|end
parameter_list|()
block|{
return|return
name|mutable_end
argument_list|()
return|;
block|}
end_function

begin_function
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|mutable_begin
argument_list|()
return|;
block|}
end_function

begin_function
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|mutable_rend
argument_list|()
return|;
block|}
end_function

begin_function
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|mutable_rbegin
argument_list|()
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|const_iterator
name|end
parameter_list|()
block|{
return|return
name|const_end
argument_list|()
return|;
block|}
end_function

begin_function
name|const_iterator
name|begin
parameter_list|()
block|{
return|return
name|const_begin
argument_list|()
return|;
block|}
end_function

begin_function
name|const_reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|const_rend
argument_list|()
return|;
block|}
end_function

begin_function
name|const_reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|const_rbegin
argument_list|()
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
specifier|const
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|y
operator|)
block|{
return|return
operator|(
name|x
operator|.
name|current_pos
operator|==
name|y
operator|.
name|current_pos
operator|&&
name|x
operator|.
name|root
operator|==
name|y
operator|.
name|root
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
specifier|const
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|y
operator|)
block|{
return|return
operator|(
name|x
operator|.
name|current_pos
operator|<
name|y
operator|.
name|current_pos
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|ptrdiff_t
name|operator
operator|-
operator|(
specifier|const
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
specifier|const
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|current_pos
operator|-
name|y
operator|.
name|current_pos
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|-
operator|(
specifier|const
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
name|ptrdiff_t
name|n
operator|)
block|{
return|return
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|x
operator|.
name|root
operator|,
name|x
operator|.
name|current_pos
operator|-
name|n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
name|ptrdiff_t
name|n
operator|)
block|{
return|return
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|x
operator|.
name|root
operator|,
name|x
operator|.
name|current_pos
operator|+
name|n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
operator|(
name|ptrdiff_t
name|n
operator|,
specifier|const
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|)
block|{
return|return
name|__rope_const_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|x
operator|.
name|root
operator|,
name|x
operator|.
name|current_pos
operator|+
name|n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
specifier|const
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|y
operator|)
block|{
return|return
operator|(
name|x
operator|.
name|current_pos
operator|==
name|y
operator|.
name|current_pos
operator|&&
name|x
operator|.
name|root_rope
operator|==
name|y
operator|.
name|root_rope
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
specifier|const
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|y
operator|)
block|{
return|return
operator|(
name|x
operator|.
name|current_pos
operator|<
name|y
operator|.
name|current_pos
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|ptrdiff_t
name|operator
operator|-
operator|(
specifier|const
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
specifier|const
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|current_pos
operator|-
name|y
operator|.
name|current_pos
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|-
operator|(
specifier|const
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
name|ptrdiff_t
name|n
operator|)
block|{
return|return
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|x
operator|.
name|root_rope
operator|,
name|x
operator|.
name|current_pos
operator|-
name|n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
name|ptrdiff_t
name|n
operator|)
block|{
return|return
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|x
operator|.
name|root_rope
operator|,
name|x
operator|.
name|current_pos
operator|+
name|n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
operator|(
name|ptrdiff_t
name|n
operator|,
specifier|const
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|)
block|{
return|return
name|__rope_iterator
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|x
operator|.
name|root_rope
operator|,
name|x
operator|.
name|current_pos
operator|+
name|n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|left
operator|,
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|right
operator|)
block|{
return|return
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|concat
argument_list|(
name|left
operator|.
name|tree_ptr
argument_list|,
name|right
operator|.
name|tree_ptr
argument_list|)
operator|)
return|;
comment|// Inlining this should make it possible to keep left and
comment|// right in registers.
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|operator
operator|+=
operator|(
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|left
operator|,
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|right
operator|)
block|{
name|left
operator|.
name|append
argument_list|(
name|right
argument_list|)
block|;
return|return
name|left
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|left
operator|,
specifier|const
name|charT
operator|*
name|right
operator|)
block|{
name|size_t
name|rlen
operator|=
name|rope
operator|<
name|charT
block|,
name|Alloc
operator|>
operator|::
name|char_ptr_len
argument_list|(
name|right
argument_list|)
block|;
return|return
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|concat_char_iter
argument_list|(
name|left
operator|.
name|tree_ptr
argument_list|,
name|right
argument_list|,
name|rlen
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|operator
operator|+=
operator|(
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|left
operator|,
specifier|const
name|charT
operator|*
name|right
operator|)
block|{
name|left
operator|.
name|append
argument_list|(
name|right
argument_list|)
block|;
return|return
name|left
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|left
operator|,
name|charT
name|right
operator|)
block|{
return|return
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|(
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|::
name|concat_char_iter
argument_list|(
name|left
operator|.
name|tree_ptr
argument_list|,
operator|&
name|right
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|operator
operator|+=
operator|(
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|left
operator|,
name|charT
name|right
operator|)
block|{
name|left
operator|.
name|append
argument_list|(
name|right
argument_list|)
block|;
return|return
name|left
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|bool
name|operator
operator|<
operator|(
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|left
operator|,
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|right
operator|)
block|{
return|return
name|left
operator|.
name|compare
argument_list|(
name|right
argument_list|)
operator|<
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|bool
name|operator
operator|==
operator|(
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|left
operator|,
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|right
operator|)
block|{
return|return
name|left
operator|.
name|compare
argument_list|(
name|right
argument_list|)
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__rope_charT_ptr_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|x
operator|,
specifier|const
name|__rope_charT_ptr_proxy
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|y
operator|)
block|{
return|return
operator|(
name|x
operator|.
name|pos
operator|==
name|y
operator|.
name|pos
operator|&&
name|x
operator|.
name|root
operator|==
name|y
operator|.
name|root
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
name|ostream
operator|&
name|operator
operator|<<
operator|(
name|ostream
operator|&
name|o
operator|,
specifier|const
name|rope
operator|<
name|charT
operator|,
name|Alloc
operator|>
operator|&
name|r
operator|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|rope
operator|<
name|char
operator|,
name|__ALLOC
operator|>
name|crope
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|rope
operator|<
name|wchar_t
operator|,
name|__ALLOC
operator|>
name|wrope
expr_stmt|;
end_typedef

begin_expr_stmt
specifier|inline
name|crope
operator|::
name|reference
name|__mutable_reference_at
argument_list|(
argument|crope& c
argument_list|,
argument|size_t i
argument_list|)
block|{
return|return
name|c
operator|.
name|mutable_reference_at
argument_list|(
name|i
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|wrope
operator|::
name|reference
name|__mutable_reference_at
argument_list|(
argument|wrope& c
argument_list|,
argument|size_t i
argument_list|)
block|{
return|return
name|c
operator|.
name|mutable_reference_at
argument_list|(
name|i
argument_list|)
return|;
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_FUNCTION_TMPL_PARTIAL_ORDER
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|charT
operator|,
name|class
name|Alloc
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|rope<charT
argument_list|,
argument|Alloc>& x
argument_list|,
argument|rope<charT
argument_list|,
argument|Alloc>& y
argument_list|)
block|{
name|x
operator|.
name|swap
argument_list|(
name|y
argument_list|)
block|; }
else|#
directive|else
specifier|inline
name|void
name|swap
argument_list|(
argument|crope x
argument_list|,
argument|crope y
argument_list|)
block|{
name|x
operator|.
name|swap
argument_list|(
name|y
argument_list|)
block|; }
specifier|inline
name|void
name|swap
argument_list|(
argument|wrope x
argument_list|,
argument|wrope y
argument_list|)
block|{
name|x
operator|.
name|swap
argument_list|(
name|y
argument_list|)
block|; }
endif|#
directive|endif
comment|/* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
comment|// Hash functions should probably be revisited later:
name|__STL_TEMPLATE_NULL
expr|struct
name|hash
operator|<
name|crope
operator|>
block|{
name|size_t
name|operator
argument_list|()
operator|(
specifier|const
name|crope
operator|&
name|str
operator|)
specifier|const
block|{
name|size_t
name|sz
operator|=
name|str
operator|.
name|size
argument_list|()
block|;
if|if
condition|(
literal|0
operator|==
name|sz
condition|)
return|return
literal|0
return|;
return|return
literal|13
operator|*
name|str
index|[
literal|0
index|]
operator|+
literal|5
operator|*
name|str
index|[
name|sz
operator|-
literal|1
index|]
operator|+
name|sz
return|;
block|}
end_expr_stmt

begin_macro
unit|};
name|__STL_TEMPLATE_NULL
end_macro

begin_expr_stmt
unit|struct
name|hash
operator|<
name|wrope
operator|>
block|{
name|size_t
name|operator
argument_list|()
operator|(
specifier|const
name|wrope
operator|&
name|str
operator|)
specifier|const
block|{
name|size_t
name|sz
operator|=
name|str
operator|.
name|size
argument_list|()
block|;
if|if
condition|(
literal|0
operator|==
name|sz
condition|)
return|return
literal|0
return|;
return|return
literal|13
operator|*
name|str
index|[
literal|0
index|]
operator|+
literal|5
operator|*
name|str
index|[
name|sz
operator|-
literal|1
index|]
operator|+
name|sz
return|;
block|}
end_expr_stmt

begin_if
unit|};
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
end_if

begin_pragma
pragma|#
directive|pragma
name|reset
name|woff
name|1174
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|__STL_END_NAMESPACE
end_macro

begin_include
include|#
directive|include
file|<ropeimpl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SGI_STL_INTERNAL_ROPE_H */
end_comment

begin_comment
comment|// Local Variables:
end_comment

begin_comment
comment|// mode:C++
end_comment

begin_comment
comment|// End:
end_comment

end_unit

