begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/* NOTE: This is an internal header file, included by other STL headers.  *   You should not attempt to use it directly.  */
end_comment

begin_comment
comment|// rope<_CharT,_Alloc> is a sequence of _CharT.
end_comment

begin_comment
comment|// Ropes appear to be mutable, but update operations
end_comment

begin_comment
comment|// really copy enough of the data structure to leave the original
end_comment

begin_comment
comment|// valid.  Thus ropes can be logically copied by just copying
end_comment

begin_comment
comment|// a pointer value.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__SGI_STL_INTERNAL_ROPE_H
end_ifndef

begin_define
define|#
directive|define
name|__SGI_STL_INTERNAL_ROPE_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GC
end_ifdef

begin_define
define|#
directive|define
name|__GC_CONST
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__GC_CONST
end_define

begin_comment
comment|// constant except for deallocation
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_SGI_THREADS
end_ifdef

begin_include
include|#
directive|include
file|<mutex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|__STL_BEGIN_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
pragma|#
directive|pragma
name|set
name|woff
name|1174
endif|#
directive|endif
comment|// The _S_eos function is used for those functions that
comment|// convert to/from C-like strings to detect the end of the string.
comment|// The end-of-C-string character.
comment|// This is what the draft standard says it should be.
name|template
operator|<
name|class
name|_CharT
operator|>
specifier|inline
name|_CharT
name|_S_eos
argument_list|(
argument|_CharT*
argument_list|)
block|{
return|return
name|_CharT
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Test for basic character types.
end_comment

begin_comment
comment|// For basic character types leaves having a trailing eos.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|>
specifier|inline
name|bool
name|_S_is_basic_char_type
argument_list|(
argument|_CharT*
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|>
specifier|inline
name|bool
name|_S_is_one_byte_char_type
argument_list|(
argument|_CharT*
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_function
specifier|inline
name|bool
name|_S_is_basic_char_type
parameter_list|(
name|char
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|_S_is_one_byte_char_type
parameter_list|(
name|char
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|_S_is_basic_char_type
parameter_list|(
name|wchar_t
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// Store an eos iff _CharT is a basic character type.
end_comment

begin_comment
comment|// Do not reference _S_eos if it isn't.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|>
specifier|inline
name|void
name|_S_cond_store_eos
argument_list|(
argument|_CharT&
argument_list|)
block|{}
specifier|inline
name|void
name|_S_cond_store_eos
argument_list|(
argument|char& __c
argument_list|)
block|{
name|__c
operator|=
literal|0
block|; }
specifier|inline
name|void
name|_S_cond_store_eos
argument_list|(
argument|wchar_t& __c
argument_list|)
block|{
name|__c
operator|=
literal|0
block|; }
comment|// char_producers are logically functions that generate a section of
comment|// a string.  These can be convereted to ropes.  The resulting rope
comment|// invokes the char_producer on demand.  This allows, for example,
comment|// files to be viewed as ropes without reading the entire file.
name|template
operator|<
name|class
name|_CharT
operator|>
name|class
name|char_producer
block|{
name|public
operator|:
name|virtual
operator|~
name|char_producer
argument_list|()
block|{}
block|;
name|virtual
name|void
name|operator
argument_list|()
operator|(
name|size_t
name|__start_pos
operator|,
name|size_t
name|__len
operator|,
name|_CharT
operator|*
name|__buffer
operator|)
operator|=
literal|0
block|;
comment|// Buffer should really be an arbitrary output iterator.
comment|// That way we could flatten directly into an ostream, etc.
comment|// This is thoroughly impossible, since iterator types don't
comment|// have runtime descriptions.
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Sequence buffers:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Sequence must provide an append operation that appends an
end_comment

begin_comment
comment|// array to the sequence.  Sequence buffers are useful only if
end_comment

begin_comment
comment|// appending an entire array is cheaper than appending element by element.
end_comment

begin_comment
comment|// This is true for many string representations.
end_comment

begin_comment
comment|// This should  perhaps inherit from ostream<sequence::value_type>
end_comment

begin_comment
comment|// and be implemented correspondingly, so that they can be used
end_comment

begin_comment
comment|// for formatted.  For the sake of portability, we don't do this yet.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// For now, sequence buffers behave as output iterators.  But they also
end_comment

begin_comment
comment|// behave a little like basic_ostringstream<sequence::value_type> and a
end_comment

begin_comment
comment|// little like containers.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_Sequence
operator|,
name|size_t
name|_Buf_sz
operator|=
literal|100
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|__TYPEDEF_WORKAROUND
operator|,
name|class
name|_V
operator|=
name|typename
name|_Sequence
operator|::
name|value_type
endif|#
directive|endif
operator|>
comment|// The 3rd parameter works around a common compiler bug.
name|class
name|sequence_buffer
operator|:
name|public
name|output_iterator
block|{
name|public
operator|:
ifndef|#
directive|ifndef
name|__TYPEDEF_WORKAROUND
typedef|typedef
name|typename
name|_Sequence
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|_V
name|value_type
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|_Sequence
modifier|*
name|_M_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value_type
name|_M_buffer
index|[
name|_Buf_sz
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|_M_buf_count
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_function
name|void
name|flush
parameter_list|()
block|{
name|_M_prefix
operator|->
name|append
argument_list|(
name|_M_buffer
argument_list|,
name|_M_buffer
operator|+
name|_M_buf_count
argument_list|)
expr_stmt|;
name|_M_buf_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_expr_stmt
operator|~
name|sequence_buffer
argument_list|()
block|{
name|flush
argument_list|()
block|; }
name|sequence_buffer
argument_list|()
operator|:
name|_M_prefix
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_buf_count
argument_list|(
literal|0
argument_list|)
block|{}
name|sequence_buffer
argument_list|(
argument|const sequence_buffer& __x
argument_list|)
block|{
name|_M_prefix
operator|=
name|__x
operator|.
name|_M_prefix
block|;
name|_M_buf_count
operator|=
name|__x
operator|.
name|_M_buf_count
block|;
name|copy
argument_list|(
name|__x
operator|.
name|_M_buffer
argument_list|,
name|__x
operator|.
name|_M_buffer
operator|+
name|__x
operator|.
name|_M_buf_count
argument_list|,
name|_M_buffer
argument_list|)
block|;         }
name|sequence_buffer
argument_list|(
argument|sequence_buffer& __x
argument_list|)
block|{
name|__x
operator|.
name|flush
argument_list|()
block|;
name|_M_prefix
operator|=
name|__x
operator|.
name|_M_prefix
block|;
name|_M_buf_count
operator|=
literal|0
block|;         }
name|sequence_buffer
argument_list|(
name|_Sequence
operator|&
name|__s
argument_list|)
operator|:
name|_M_prefix
argument_list|(
operator|&
name|__s
argument_list|)
operator|,
name|_M_buf_count
argument_list|(
literal|0
argument_list|)
block|{}
name|sequence_buffer
operator|&
name|operator
operator|=
operator|(
name|sequence_buffer
operator|&
name|__x
operator|)
block|{
name|__x
operator|.
name|flush
argument_list|()
block|;
name|_M_prefix
operator|=
name|__x
operator|.
name|_M_prefix
block|;
name|_M_buf_count
operator|=
literal|0
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|sequence_buffer
modifier|&
name|operator
init|=
operator|(
specifier|const
name|sequence_buffer
operator|&
name|__x
operator|)
block|{
name|_M_prefix
operator|=
name|__x
operator|.
name|_M_prefix
block|;
name|_M_buf_count
operator|=
name|__x
operator|.
name|_M_buf_count
block|;
name|copy
argument_list|(
name|__x
operator|.
name|_M_buffer
argument_list|,
name|__x
operator|.
name|_M_buffer
operator|+
name|__x
operator|.
name|_M_buf_count
argument_list|,
name|_M_buffer
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_function
name|void
name|push_back
parameter_list|(
name|value_type
name|__x
parameter_list|)
block|{
if|if
condition|(
name|_M_buf_count
operator|<
name|_Buf_sz
condition|)
block|{
name|_M_buffer
index|[
name|_M_buf_count
index|]
operator|=
name|__x
expr_stmt|;
operator|++
name|_M_buf_count
expr_stmt|;
block|}
else|else
block|{
name|flush
argument_list|()
expr_stmt|;
name|_M_buffer
index|[
literal|0
index|]
operator|=
name|__x
expr_stmt|;
name|_M_buf_count
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|append
parameter_list|(
name|value_type
modifier|*
name|__s
parameter_list|,
name|size_t
name|__len
parameter_list|)
block|{
if|if
condition|(
name|__len
operator|+
name|_M_buf_count
operator|<=
name|_Buf_sz
condition|)
block|{
name|size_t
name|__i
init|=
name|_M_buf_count
decl_stmt|;
name|size_t
name|__j
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|__j
operator|<
name|__len
condition|;
name|__i
operator|++
operator|,
name|__j
operator|++
control|)
block|{
name|_M_buffer
index|[
name|__i
index|]
operator|=
name|__s
index|[
name|__j
index|]
expr_stmt|;
block|}
name|_M_buf_count
operator|+=
name|__len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|_M_buf_count
condition|)
block|{
name|_M_prefix
operator|->
name|append
argument_list|(
name|__s
argument_list|,
name|__s
operator|+
name|__len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flush
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|__s
argument_list|,
name|__len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|sequence_buffer
modifier|&
name|write
parameter_list|(
name|value_type
modifier|*
name|__s
parameter_list|,
name|size_t
name|__len
parameter_list|)
block|{
name|append
argument_list|(
name|__s
argument_list|,
name|__len
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|sequence_buffer
modifier|&
name|put
parameter_list|(
name|value_type
name|__x
parameter_list|)
block|{
name|push_back
argument_list|(
name|__x
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_decl_stmt
name|sequence_buffer
modifier|&
name|operator
init|=
operator|(
specifier|const
name|value_type
operator|&
name|__rhs
operator|)
block|{
name|push_back
argument_list|(
name|__rhs
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_function
name|sequence_buffer
modifier|&
name|operator
modifier|*
parameter_list|()
block|{
return|return
operator|*
name|this
return|;
block|}
end_function

begin_expr_stmt
name|sequence_buffer
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|sequence_buffer
operator|&
name|operator
operator|++
operator|(
name|int
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// The following should be treated as private, at least for now.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|>
name|class
name|_Rope_char_consumer
block|{
name|public
operator|:
comment|// If we had member templates, these should not be virtual.
comment|// For now we need to use run-time parametrization where
comment|// compile-time would do.  _Hence this should all be private
comment|// for now.
comment|// The symmetry with char_producer is accidental and temporary.
name|virtual
operator|~
name|_Rope_char_consumer
argument_list|()
block|{}
block|;
name|virtual
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_CharT
operator|*
name|__buffer
operator|,
name|size_t
name|__len
operator|)
operator|=
literal|0
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|//
end_comment

begin_comment
comment|// What follows should really be local to rope.  Unfortunately,
end_comment

begin_comment
comment|// that doesn't work, since it makes it impossible to define generic
end_comment

begin_comment
comment|// equality on rope iterators.  According to the draft standard, the
end_comment

begin_comment
comment|// template parameters for such an equality operator cannot be inferred
end_comment

begin_comment
comment|// from the occurence of a member class as a parameter.
end_comment

begin_comment
comment|// (SGI compilers in fact allow this, but the __result wouldn't be
end_comment

begin_comment
comment|// portable.)
end_comment

begin_comment
comment|// Similarly, some of the static member functions are member functions
end_comment

begin_comment
comment|// only to avoid polluting the global namespace, and to circumvent
end_comment

begin_comment
comment|// restrictions on type inference for template functions.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|=
name|__STL_DEFAULT_ALLOCATOR
argument_list|(
name|_CharT
argument_list|)
operator|>
name|class
name|rope
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_RopeConcatenation
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_RopeLeaf
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_RopeFunction
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_RopeSubstring
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_iterator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_const_iterator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_char_ref_proxy
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_char_ptr_proxy
expr_stmt|;
end_expr_stmt

begin_comment
comment|//
end_comment

begin_comment
comment|// The internal data structure for representing a rope.  This is
end_comment

begin_comment
comment|// private to the implementation.  A rope is really just a pointer
end_comment

begin_comment
comment|// to one of these.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A few basic functions for manipulating this data structure
end_comment

begin_comment
comment|// are members of _RopeRep.  Most of the more complex algorithms
end_comment

begin_comment
comment|// are implemented as rope members.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Some of the static member functions of _RopeRep have identically
end_comment

begin_comment
comment|// named functions in rope that simply invoke the _RopeRep versions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A macro to introduce various allocation and deallocation functions
end_comment

begin_comment
comment|// These need to be defined differently depending on whether or not
end_comment

begin_comment
comment|// we are using standard conforming allocators, and whether the allocator
end_comment

begin_comment
comment|// instances have real state.  Thus this macro is invoked repeatedly
end_comment

begin_comment
comment|// with different definitions of __ROPE_DEFINE_ALLOC.
end_comment

begin_comment
comment|// __ROPE_DEFINE_ALLOC(type,name) defines
end_comment

begin_comment
comment|//   type * name_allocate(size_t) and
end_comment

begin_comment
comment|//   void name_deallocate(tipe *, size_t)
end_comment

begin_comment
comment|// Both functions may or may not be static.
end_comment

begin_define
define|#
directive|define
name|__ROPE_DEFINE_ALLOCS
parameter_list|(
name|__a
parameter_list|)
define|\
value|__ROPE_DEFINE_ALLOC(_CharT,_Data)
comment|/* character data */
value|\         typedef _Rope_RopeConcatenation<_CharT,__a> __C; \         __ROPE_DEFINE_ALLOC(__C,_C) \         typedef _Rope_RopeLeaf<_CharT,__a> __L; \         __ROPE_DEFINE_ALLOC(__L,_L) \         typedef _Rope_RopeFunction<_CharT,__a> __F; \         __ROPE_DEFINE_ALLOC(__F,_F) \         typedef _Rope_RopeSubstring<_CharT,__a> __S; \         __ROPE_DEFINE_ALLOC(__S,_S)
end_define

begin_comment
comment|//  Internal rope nodes potentially store a copy of the allocator
end_comment

begin_comment
comment|//  instance used to allocate them.  This is mostly redundant.
end_comment

begin_comment
comment|//  But the alternative would be to pass allocator instances around
end_comment

begin_comment
comment|//  in some form to nearly all internal functions, since any pointer
end_comment

begin_comment
comment|//  assignment may result in a zero reference count and thus require
end_comment

begin_comment
comment|//  deallocation.
end_comment

begin_comment
comment|//  The _Rope_rep_base class encapsulates
end_comment

begin_comment
comment|//  the differences between SGI-style allocators and standard-conforming
end_comment

begin_comment
comment|//  allocators.
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
end_ifdef

begin_define
define|#
directive|define
name|__STATIC_IF_SGI_ALLOC
end_define

begin_comment
comment|/* not static */
end_comment

begin_comment
comment|// Base class for ordinary allocators.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Allocator
operator|,
name|bool
name|_IsStatic
operator|>
name|class
name|_Rope_rep_alloc_base
block|{
name|public
operator|:
typedef|typedef
name|typename
name|_Alloc_traits
operator|<
name|_CharT
operator|,
name|_Allocator
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
name|allocator_type
name|get_allocator
argument_list|()
specifier|const
block|{
return|return
name|_M_data_allocator
return|;
block|}
name|_Rope_rep_alloc_base
argument_list|(
argument|size_t __size
argument_list|,
argument|const allocator_type& __a
argument_list|)
operator|:
name|_M_size
argument_list|(
name|__size
argument_list|)
operator|,
name|_M_data_allocator
argument_list|(
argument|__a
argument_list|)
block|{}
name|size_t
name|_M_size
expr_stmt|;
end_expr_stmt

begin_comment
comment|// This is here only to avoid wasting space
end_comment

begin_comment
comment|// for an otherwise empty base class.
end_comment

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|allocator_type
name|_M_data_allocator
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|__ROPE_DEFINE_ALLOC
parameter_list|(
name|_Tp
parameter_list|,
name|__name
parameter_list|)
define|\
value|typedef typename \           _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \
comment|/*static*/
value|_Tp * __name##_allocate(size_t __n) \           { return __name##Allocator(_M_data_allocator).allocate(__n); } \         void __name##_deallocate(_Tp* __p, size_t __n) \           { __name##Allocator(_M_data_allocator).deallocate(__p, __n); }
end_define

begin_expr_stmt
name|__ROPE_DEFINE_ALLOCS
argument_list|(
name|_Allocator
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|__ROPE_DEFINE_ALLOC
end_undef

begin_comment
unit|};
comment|// Specialization for allocators that have the property that we don't
end_comment

begin_comment
comment|//  actually have to store an allocator object.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Allocator
operator|>
name|class
name|_Rope_rep_alloc_base
operator|<
name|_CharT
operator|,
name|_Allocator
operator|,
name|true
operator|>
block|{
name|public
operator|:
typedef|typedef
name|typename
name|_Alloc_traits
operator|<
name|_CharT
operator|,
name|_Allocator
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
name|allocator_type
name|get_allocator
argument_list|()
specifier|const
block|{
return|return
name|allocator_type
argument_list|()
return|;
block|}
name|_Rope_rep_alloc_base
argument_list|(
argument|size_t __size
argument_list|,
argument|const allocator_type&
argument_list|)
operator|:
name|_M_size
argument_list|(
argument|__size
argument_list|)
block|{}
name|size_t
name|_M_size
expr_stmt|;
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_define
define|#
directive|define
name|__ROPE_DEFINE_ALLOC
parameter_list|(
name|_Tp
parameter_list|,
name|__name
parameter_list|)
define|\
value|typedef typename \           _Alloc_traits<_Tp,_Allocator>::_Alloc_type __name##Alloc; \         typedef typename \           _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \         static _Tp* __name##_allocate(size_t __n) \                 { return __name##Alloc::allocate(__n); } \         void __name##_deallocate(_Tp *__p, size_t __n) \                 { __name##Alloc::deallocate(__p, __n); }
end_define

begin_expr_stmt
name|__ROPE_DEFINE_ALLOCS
argument_list|(
name|_Allocator
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|__ROPE_DEFINE_ALLOC
end_undef

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_rep_base
operator|:
name|public
name|_Rope_rep_alloc_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|,
name|_Alloc_traits
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_instanceless
operator|>
block|{
typedef|typedef
name|_Rope_rep_alloc_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|,
name|_Alloc_traits
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_instanceless
operator|>
name|_Base
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Base
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
end_typedef

begin_macro
name|_Rope_rep_base
argument_list|(
argument|size_t __size
argument_list|,
argument|const allocator_type& __a
argument_list|)
end_macro

begin_macro
unit|:
name|_Base
argument_list|(
argument|__size
argument_list|,
argument|__a
argument_list|)
end_macro

begin_block
block|{}
end_block

begin_else
unit|};
else|#
directive|else
end_else

begin_comment
comment|/* !__STL_USE_STD_ALLOCATORS */
end_comment

begin_define
define|#
directive|define
name|__STATIC_IF_SGI_ALLOC
value|static
end_define

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_rep_base
block|{
name|public
operator|:
typedef|typedef
name|_Alloc
name|allocator_type
typedef|;
specifier|static
name|allocator_type
name|get_allocator
argument_list|()
block|{
return|return
name|allocator_type
argument_list|()
return|;
block|}
name|_Rope_rep_base
argument_list|(
argument|size_t __size
argument_list|,
argument|const allocator_type&
argument_list|)
operator|:
name|_M_size
argument_list|(
argument|__size
argument_list|)
block|{}
name|size_t
name|_M_size
expr_stmt|;
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_define
define|#
directive|define
name|__ROPE_DEFINE_ALLOC
parameter_list|(
name|_Tp
parameter_list|,
name|__name
parameter_list|)
define|\
value|typedef simple_alloc<_Tp, _Alloc> __name##Alloc; \         static _Tp* __name##_allocate(size_t __n) \                 { return __name##Alloc::allocate(__n); } \         static void __name##_deallocate(_Tp* __p, size_t __n) \                 { __name##Alloc::deallocate(__p, __n); }
end_define

begin_expr_stmt
name|__ROPE_DEFINE_ALLOCS
argument_list|(
name|_Alloc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|__ROPE_DEFINE_ALLOC
end_undef

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_USE_STD_ALLOCATORS */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_RopeRep
operator|:
name|public
name|_Rope_rep_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
block|{
name|public
operator|:
expr|enum
block|{
name|_S_max_rope_depth
operator|=
literal|45
block|}
block|;     enum
name|_Tag
block|{
name|_S_leaf
block|,
name|_S_concat
block|,
name|_S_substringfn
block|,
name|_S_function
block|}
block|;
name|_Tag
name|_M_tag
operator|:
literal|8
block|;
name|bool
name|_M_is_balanced
operator|:
literal|8
block|;
name|unsigned
name|char
name|_M_depth
block|;
name|__GC_CONST
name|_CharT
operator|*
name|_M_c_string
block|;
comment|/* Flattened version of string, if needed.  */
comment|/* typically 0.                             */
comment|/* If it's not 0, then the memory is owned  */
comment|/* by this node.                            */
comment|/* In the case of a leaf, this may point to */
comment|/* the same memory as the data field.       */
typedef|typedef
name|_Rope_rep_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
name|_Rope_RopeRep
argument_list|(
argument|_Tag __t
argument_list|,
argument|int __d
argument_list|,
argument|bool __b
argument_list|,
argument|size_t __size
argument_list|,
argument|allocator_type __a
argument_list|)
operator|:
name|_Rope_rep_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__size
operator|,
name|__a
operator|)
operator|,
name|_M_tag
argument_list|(
name|__t
argument_list|)
operator|,
name|_M_depth
argument_list|(
name|__d
argument_list|)
operator|,
name|_M_is_balanced
argument_list|(
name|__b
argument_list|)
operator|,
name|_M_c_string
argument_list|(
literal|0
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__GC
name|_M_refcount
operator|=
literal|1
block|;
name|_M_init_refcount_lock
argument_list|()
block|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|__GC
if|#
directive|if
name|defined
argument_list|(
name|__STL_WIN32THREADS
argument_list|)
name|long
name|_M_refcount
expr_stmt|;
end_expr_stmt

begin_comment
comment|// InterlockedIncrement wants a long *
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|size_t
name|_M_refcount
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// We count references from rope instances
end_comment

begin_comment
comment|// and references from other rope nodes.  We
end_comment

begin_comment
comment|// do not count const_iterator references.
end_comment

begin_comment
comment|// Iterator references are counted so that rope modifications
end_comment

begin_comment
comment|// can be detected after the fact.
end_comment

begin_comment
comment|// Generally function results are counted, i.__e.
end_comment

begin_comment
comment|// a pointer returned by a function is included at the
end_comment

begin_comment
comment|// point at which the pointer is returned.
end_comment

begin_comment
comment|// The recipient should decrement the count if the
end_comment

begin_comment
comment|// __result is not needed.
end_comment

begin_comment
comment|// Generally function arguments are not reflected
end_comment

begin_comment
comment|// in the reference count.  The callee should increment
end_comment

begin_comment
comment|// the count before saving the argument someplace that
end_comment

begin_comment
comment|// will outlive the call.
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_SGI_THREADS
end_ifdef

begin_comment
comment|// Reference counting with multiple threads and no
end_comment

begin_comment
comment|// hardware or thread package support is pretty awful.
end_comment

begin_comment
comment|// Mutexes are normally too expensive.
end_comment

begin_comment
comment|// We'll assume a COMPARE_AND_SWAP(destp, __old, new)
end_comment

begin_comment
comment|// operation, which might be cheaper.
end_comment

begin_if
if|#
directive|if
name|__mips
operator|<
literal|3
operator|||
operator|!
operator|(
name|defined
argument_list|(
name|_ABIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_ABI64
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|__add_and_fetch
parameter_list|(
name|l
parameter_list|,
name|v
parameter_list|)
value|add_then_test((unsigned long*)l,v)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|_M_init_refcount_lock
parameter_list|()
block|{}
end_function

begin_function
name|void
name|_M_incr_refcount
parameter_list|()
block|{
name|__add_and_fetch
argument_list|(
operator|&
name|_M_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|_M_decr_refcount
parameter_list|()
block|{
return|return
name|__add_and_fetch
argument_list|(
operator|&
name|_M_refcount
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__STL_WIN32THREADS
argument_list|)
end_elif

begin_function
name|void
name|_M_init_refcount_lock
parameter_list|()
block|{}
end_function

begin_function
name|void
name|_M_incr_refcount
parameter_list|()
block|{
name|InterlockedIncrement
argument_list|(
operator|&
name|_M_refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|_M_decr_refcount
parameter_list|()
block|{
return|return
name|InterlockedDecrement
argument_list|(
operator|&
name|_M_refcount
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__STL_PTHREADS
argument_list|)
end_elif

begin_comment
comment|// This should be portable, but performance is expected
end_comment

begin_comment
comment|// to be quite awful.  This really needs platform specific
end_comment

begin_comment
comment|// code.
end_comment

begin_decl_stmt
name|pthread_mutex_t
name|_M_refcount_lock
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_M_init_refcount_lock
parameter_list|()
block|{
name|pthread_mutex_init
argument_list|(
operator|&
name|_M_refcount_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_M_incr_refcount
parameter_list|()
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|_M_refcount_lock
argument_list|)
expr_stmt|;
operator|++
name|_M_refcount
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|_M_refcount_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|_M_decr_refcount
parameter_list|()
block|{
name|size_t
name|__result
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|_M_refcount_lock
argument_list|)
expr_stmt|;
name|__result
operator|=
operator|--
name|_M_refcount
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|_M_refcount_lock
argument_list|)
expr_stmt|;
return|return
name|__result
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|_M_init_refcount_lock
parameter_list|()
block|{}
end_function

begin_function
name|void
name|_M_incr_refcount
parameter_list|()
block|{
operator|++
name|_M_refcount
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|_M_decr_refcount
parameter_list|()
block|{
operator|--
name|_M_refcount
expr_stmt|;
return|return
name|_M_refcount
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|_M_incr_refcount
parameter_list|()
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
end_ifdef

begin_function_decl
specifier|static
name|void
name|_S_free_string
parameter_list|(
name|__GC_CONST
name|_CharT
modifier|*
parameter_list|,
name|size_t
name|__len
parameter_list|,
name|allocator_type
name|__a
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|__STL_FREE_STRING
parameter_list|(
name|__s
parameter_list|,
name|__l
parameter_list|,
name|__a
parameter_list|)
value|_S_free_string(__s, __l, __a);
end_define

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|_S_free_string
parameter_list|(
name|__GC_CONST
name|_CharT
modifier|*
parameter_list|,
name|size_t
name|__len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|__STL_FREE_STRING
parameter_list|(
name|__s
parameter_list|,
name|__l
parameter_list|,
name|__a
parameter_list|)
value|_S_free_string(__s, __l);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// Deallocate data section of a leaf.
end_comment

begin_comment
comment|// This shouldn't be a member function.
end_comment

begin_comment
comment|// But its hard to do anything else at the
end_comment

begin_comment
comment|// moment, because it's templatized w.r.t.
end_comment

begin_comment
comment|// an allocator.
end_comment

begin_comment
comment|// Does nothing if __GC is defined.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_function_decl
name|void
name|_M_free_c_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_M_free_tree
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Deallocate t. Assumes t is not 0.
end_comment

begin_function
name|void
name|_M_unref_nonnil
parameter_list|()
block|{
if|if
condition|(
literal|0
operator|==
name|_M_decr_refcount
argument_list|()
condition|)
name|_M_free_tree
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_M_ref_nonnil
parameter_list|()
block|{
name|_M_incr_refcount
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_S_unref
parameter_list|(
name|_Rope_RopeRep
modifier|*
name|__t
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|!=
name|__t
condition|)
block|{
name|__t
operator|->
name|_M_unref_nonnil
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_S_ref
parameter_list|(
name|_Rope_RopeRep
modifier|*
name|__t
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|!=
name|__t
condition|)
name|__t
operator|->
name|_M_incr_refcount
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_S_free_if_unref
parameter_list|(
name|_Rope_RopeRep
modifier|*
name|__t
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|!=
name|__t
operator|&&
literal|0
operator|==
name|__t
operator|->
name|_M_refcount
condition|)
name|__t
operator|->
name|_M_free_tree
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __GC */
end_comment

begin_function
name|void
name|_M_unref_nonnil
parameter_list|()
block|{}
end_function

begin_function
name|void
name|_M_ref_nonnil
parameter_list|()
block|{}
end_function

begin_function
specifier|static
name|void
name|_S_unref
parameter_list|(
name|_Rope_RopeRep
modifier|*
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|_S_ref
parameter_list|(
name|_Rope_RopeRep
modifier|*
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|_S_free_if_unref
parameter_list|(
name|_Rope_RopeRep
modifier|*
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_RopeLeaf
operator|:
name|public
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
block|{
name|public
operator|:
comment|// Apparently needed by VC++
comment|// The data fields of leaves are allocated with some
comment|// extra space, to accomodate future growth and for basic
comment|// character types, to hold a trailing eos character.
expr|enum
block|{
name|_S_alloc_granularity
operator|=
literal|8
block|}
block|;
specifier|static
name|size_t
name|_S_rounded_up_size
argument_list|(
argument|size_t __n
argument_list|)
block|{
name|size_t
name|__size_with_eos
block|;
if|if
condition|(
name|_S_is_basic_char_type
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|__size_with_eos
operator|=
name|__n
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|__size_with_eos
operator|=
name|__n
expr_stmt|;
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GC
end_ifdef

begin_return
return|return
name|__size_with_eos
return|;
end_return

begin_else
else|#
directive|else
end_else

begin_comment
comment|// Allow slop for in-place expansion.
end_comment

begin_return
return|return
operator|(
name|__size_with_eos
operator|+
name|_S_alloc_granularity
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|_S_alloc_granularity
operator|-
literal|1
operator|)
return|;
end_return

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
unit|}     __GC_CONST
name|_CharT
modifier|*
name|_M_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Not necessarily 0 terminated. */
end_comment

begin_comment
comment|/* The allocated size is         */
end_comment

begin_comment
comment|/* _S_rounded_up_size(size), except */
end_comment

begin_comment
comment|/* in the GC case, in which it   */
end_comment

begin_comment
comment|/* doesn't matter.               */
end_comment

begin_typedef
typedef|typedef
name|_Rope_rep_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
end_typedef

begin_macro
name|_Rope_RopeLeaf
argument_list|(
argument|__GC_CONST _CharT* __d
argument_list|,
argument|size_t __size
argument_list|,
argument|allocator_type __a
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_S_leaf
operator|,
literal|0
operator|,
name|true
operator|,
name|__size
operator|,
name|__a
operator|)
operator|,
name|_M_data
argument_list|(
argument|__d
argument_list|)
block|{
name|__stl_assert
argument_list|(
name|__size
operator|>
literal|0
argument_list|)
block|;
if|if
condition|(
name|_S_is_basic_char_type
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
comment|// already eos terminated.
name|_M_c_string
operator|=
name|__d
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// The constructor assumes that d has been allocated with
end_comment

begin_comment
comment|// the proper allocator and the properly padded size.
end_comment

begin_comment
comment|// In contrast, the destructor deallocates the data:
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_macro
unit|~
name|_Rope_RopeLeaf
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|_M_data
operator|!=
name|_M_c_string
condition|)
block|{
name|_M_free_c_string
argument_list|()
expr_stmt|;
block|}
name|__STL_FREE_STRING
argument_list|(
name|_M_data
argument_list|,
name|_M_size
argument_list|,
name|get_allocator
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_RopeConcatenation
operator|:
name|public
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
block|{
name|public
operator|:
name|_Rope_RopeRep
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|*
name|_M_left
block|;
name|_Rope_RopeRep
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|*
name|_M_right
block|;
typedef|typedef
name|_Rope_rep_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
name|_Rope_RopeConcatenation
argument_list|(
argument|_Rope_RopeRep<_CharT
argument_list|,
argument|_Alloc>* __l
argument_list|,
argument|_Rope_RopeRep<_CharT
argument_list|,
argument|_Alloc>* __r
argument_list|,
argument|allocator_type __a
argument_list|)
operator|:
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_S_concat
operator|,
name|max
argument_list|(
name|__l
operator|->
name|_M_depth
argument_list|,
name|__r
operator|->
name|_M_depth
argument_list|)
operator|+
literal|1
operator|,
name|false
operator|,
name|__l
operator|->
name|_M_size
operator|+
name|__r
operator|->
name|_M_size
operator|,
name|__a
operator|)
operator|,
name|_M_left
argument_list|(
name|__l
argument_list|)
operator|,
name|_M_right
argument_list|(
argument|__r
argument_list|)
block|{}
ifndef|#
directive|ifndef
name|__GC
operator|~
name|_Rope_RopeConcatenation
argument_list|()
block|{
name|_M_free_c_string
argument_list|()
block|;
name|_M_left
operator|->
name|_M_unref_nonnil
argument_list|()
block|;
name|_M_right
operator|->
name|_M_unref_nonnil
argument_list|()
block|;     }
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_RopeFunction
operator|:
name|public
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
block|{
name|public
operator|:
name|char_producer
operator|<
name|_CharT
operator|>
operator|*
name|_M_fn
block|;
ifndef|#
directive|ifndef
name|__GC
name|bool
name|_M_delete_when_done
block|;
comment|// Char_producer is owned by the
comment|// rope and should be explicitly
comment|// deleted when the rope becomes
comment|// inaccessible.
else|#
directive|else
comment|// In the GC case, we either register the rope for
comment|// finalization, or not.  Thus the field is unnecessary;
comment|// the information is stored in the collector data structures.
comment|// We do need a finalization procedure to be invoked by the
comment|// collector.
specifier|static
name|void
name|_S_fn_finalization_proc
argument_list|(
argument|void * __tree
argument_list|,
argument|void *
argument_list|)
block|{
name|delete
argument_list|(
operator|(
name|_Rope_RopeFunction
operator|*
operator|)
name|__tree
argument_list|)
operator|->
name|_M_fn
block|;       }
endif|#
directive|endif
typedef|typedef
name|_Rope_rep_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
name|_Rope_RopeFunction
argument_list|(
argument|char_producer<_CharT>* __f
argument_list|,
argument|size_t __size
argument_list|,
argument|bool __d
argument_list|,
argument|allocator_type __a
argument_list|)
operator|:
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_S_function
operator|,
literal|0
operator|,
name|true
operator|,
name|__size
operator|,
name|__a
operator|)
operator|,
name|_M_fn
argument_list|(
name|__f
argument_list|)
ifndef|#
directive|ifndef
name|__GC
operator|,
name|_M_delete_when_done
argument_list|(
argument|__d
argument_list|)
endif|#
directive|endif
block|{
name|__stl_assert
argument_list|(
name|__size
operator|>
literal|0
argument_list|)
block|;
ifdef|#
directive|ifdef
name|__GC
if|if
condition|(
name|__d
condition|)
block|{
name|GC_REGISTER_FINALIZER
argument_list|(
name|this
argument_list|,
name|_Rope_RopeFunction
operator|::
name|_S_fn_finalization_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_macro
unit|~
name|_Rope_RopeFunction
argument_list|()
end_macro

begin_block
block|{
name|_M_free_c_string
argument_list|()
expr_stmt|;
if|if
condition|(
name|_M_delete_when_done
condition|)
block|{
name|delete
name|_M_fn
decl_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|};
comment|// Substring results are usually represented using just
end_comment

begin_comment
comment|// concatenation nodes.  But in the case of very long flat ropes
end_comment

begin_comment
comment|// or ropes with a functional representation that isn't practical.
end_comment

begin_comment
comment|// In that case, we represent the __result as a special case of
end_comment

begin_comment
comment|// RopeFunction, whose char_producer points back to the rope itself.
end_comment

begin_comment
comment|// In all cases except repeated substring operations and
end_comment

begin_comment
comment|// deallocation, we treat the __result as a RopeFunction.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_RopeSubstring
operator|:
name|public
name|_Rope_RopeFunction
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|,
name|public
name|char_producer
operator|<
name|_CharT
operator|>
block|{
name|public
operator|:
comment|// XXX this whole class should be rewritten.
name|_Rope_RopeRep
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|*
name|_M_base
block|;
comment|// not 0
name|size_t
name|_M_start
block|;
name|virtual
name|void
name|operator
argument_list|()
operator|(
name|size_t
name|__start_pos
operator|,
name|size_t
name|__req_len
operator|,
name|_CharT
operator|*
name|__buffer
operator|)
block|{
switch|switch
condition|(
name|_M_base
operator|->
name|_M_tag
condition|)
block|{
case|case
name|_S_function
case|:
case|case
name|_S_substringfn
case|:
block|{
name|char_producer
operator|<
name|_CharT
operator|>
operator|*
name|__fn
operator|=
operator|(
operator|(
name|_Rope_RopeFunction
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|_M_base
operator|)
operator|->
name|_M_fn
expr_stmt|;
name|__stl_assert
argument_list|(
name|__start_pos
operator|+
name|__req_len
operator|<=
name|_M_size
argument_list|)
expr_stmt|;
name|__stl_assert
argument_list|(
name|_M_start
operator|+
name|_M_size
operator|<=
name|_M_base
operator|->
name|_M_size
argument_list|)
expr_stmt|;
call|(
modifier|*
name|__fn
call|)
argument_list|(
name|__start_pos
operator|+
name|_M_start
argument_list|,
name|__req_len
argument_list|,
name|__buffer
argument_list|)
expr_stmt|;
block|}
break|break;
end_expr_stmt

begin_case
case|case
name|_S_leaf
case|:
end_case

begin_block
block|{
name|__GC_CONST
name|_CharT
modifier|*
name|__s
init|=
operator|(
operator|(
name|_Rope_RopeLeaf
operator|<
name|_CharT
expr|,
name|_Alloc
operator|>
operator|*
operator|)
name|_M_base
operator|)
operator|->
name|_M_data
decl_stmt|;
name|uninitialized_copy_n
argument_list|(
name|__s
operator|+
name|__start_pos
operator|+
name|_M_start
argument_list|,
name|__req_len
argument_list|,
name|__buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_expr_stmt
name|__stl_assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
unit|}     }
typedef|typedef
name|_Rope_rep_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
end_typedef

begin_macro
name|_Rope_RopeSubstring
argument_list|(
argument|_Rope_RopeRep<_CharT
argument_list|,
argument|_Alloc>* __b
argument_list|,
argument|size_t __s
argument_list|,
argument|size_t __l
argument_list|,
argument|allocator_type __a
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|_Rope_RopeFunction
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|this
operator|,
name|__l
operator|,
name|false
operator|,
name|__a
operator|)
operator|,
name|_M_base
argument_list|(
name|__b
argument_list|)
operator|,
name|_M_start
argument_list|(
argument|__s
argument_list|)
block|{
name|__stl_assert
argument_list|(
name|__l
operator|>
literal|0
argument_list|)
block|;
name|__stl_assert
argument_list|(
name|__s
operator|+
name|__l
operator|<=
name|__b
operator|->
name|_M_size
argument_list|)
block|;
ifndef|#
directive|ifndef
name|__GC
name|_M_base
operator|->
name|_M_ref_nonnil
argument_list|()
block|;
endif|#
directive|endif
name|_M_tag
operator|=
name|_S_substringfn
block|;     }
name|virtual
operator|~
name|_Rope_RopeSubstring
argument_list|()
block|{
ifndef|#
directive|ifndef
name|__GC
name|_M_base
operator|->
name|_M_unref_nonnil
argument_list|()
block|;
comment|// _M_free_c_string();  -- done by parent class
endif|#
directive|endif
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Self-destructing pointers to Rope_rep.
end_comment

begin_comment
comment|// These are not conventional smart pointers.  Their
end_comment

begin_comment
comment|// only purpose in life is to ensure that unref is called
end_comment

begin_comment
comment|// on the pointer either at normal exit or if an exception
end_comment

begin_comment
comment|// is raised.  It is the caller's responsibility to
end_comment

begin_comment
comment|// adjust reference counts when these pointers are initialized
end_comment

begin_comment
comment|// or assigned to.  (This convention significantly reduces
end_comment

begin_comment
comment|// the number of potentially expensive reference count
end_comment

begin_comment
comment|// updates.)
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_self_destruct_ptr
block|{
name|_Rope_RopeRep
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|*
name|_M_ptr
block|;
operator|~
name|_Rope_self_destruct_ptr
argument_list|()
block|{
name|_Rope_RopeRep
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|::
name|_S_unref
argument_list|(
name|_M_ptr
argument_list|)
block|; }
ifdef|#
directive|ifdef
name|__STL_USE_EXCEPTIONS
name|_Rope_self_destruct_ptr
argument_list|()
operator|:
name|_M_ptr
argument_list|(
literal|0
argument_list|)
block|{}
block|;
else|#
directive|else
name|_Rope_self_destruct_ptr
argument_list|()
block|{}
block|;
endif|#
directive|endif
name|_Rope_self_destruct_ptr
argument_list|(
name|_Rope_RopeRep
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|*
name|__p
argument_list|)
operator|:
name|_M_ptr
argument_list|(
argument|__p
argument_list|)
block|{}
name|_Rope_RopeRep
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|&
name|operator
operator|*
operator|(
operator|)
block|{
return|return
operator|*
name|_M_ptr
return|;
block|}
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_block
unit|)
block|{
return|return
name|_M_ptr
return|;
block|}
end_block

begin_expr_stmt
name|operator
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|(
operator|)
block|{
return|return
name|_M_ptr
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|_Rope_self_destruct_ptr
modifier|&
name|operator
init|=
operator|(
name|_Rope_RopeRep
operator|<
name|_CharT
expr|,
name|_Alloc
operator|>
operator|*
name|__x
operator|)
block|{
name|_M_ptr
operator|=
name|__x
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|// Dereferencing a nonconst iterator has to return something
end_comment

begin_comment
comment|// that behaves almost like a reference.  It's not possible to
end_comment

begin_comment
comment|// return an actual reference since assignment requires extra
end_comment

begin_comment
comment|// work.  And we would get into the same problems as with the
end_comment

begin_comment
comment|// CD2 version of basic_string.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_char_ref_proxy
block|{
name|friend
name|class
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
block|;
name|friend
name|class
name|_Rope_iterator
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
block|;
name|friend
name|class
name|_Rope_char_ptr_proxy
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
block|;
ifdef|#
directive|ifdef
name|__GC
typedef|typedef
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
name|_Self_destruct_ptr
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|_Rope_self_destruct_ptr
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_Self_destruct_ptr
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_RopeRep
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_My_rope
expr_stmt|;
end_typedef

begin_decl_stmt
name|size_t
name|_M_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_CharT
name|_M_current
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|_M_current_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_My_rope
modifier|*
name|_M_root
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The whole rope.
end_comment

begin_label
name|public
label|:
end_label

begin_macro
name|_Rope_char_ref_proxy
argument_list|(
argument|_My_rope* __r
argument_list|,
argument|size_t __p
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|_M_pos
argument_list|(
name|__p
argument_list|)
operator|,
name|_M_current_valid
argument_list|(
name|false
argument_list|)
operator|,
name|_M_root
argument_list|(
argument|__r
argument_list|)
block|{}
name|_Rope_char_ref_proxy
argument_list|(
specifier|const
name|_Rope_char_ref_proxy
operator|&
name|__x
argument_list|)
operator|:
name|_M_pos
argument_list|(
name|__x
operator|.
name|_M_pos
argument_list|)
operator|,
name|_M_current_valid
argument_list|(
name|false
argument_list|)
operator|,
name|_M_root
argument_list|(
argument|__x._M_root
argument_list|)
block|{}
comment|// Don't preserve cache if the reference can outlive the
comment|// expression.  We claim that's not possible without calling
comment|// a copy constructor or generating reference to a proxy
comment|// reference.  We declare the latter to have undefined semantics.
name|_Rope_char_ref_proxy
argument_list|(
argument|_My_rope* __r
argument_list|,
argument|size_t __p
argument_list|,
argument|_CharT __c
argument_list|)
operator|:
name|_M_pos
argument_list|(
name|__p
argument_list|)
operator|,
name|_M_current
argument_list|(
name|__c
argument_list|)
operator|,
name|_M_current_valid
argument_list|(
name|true
argument_list|)
operator|,
name|_M_root
argument_list|(
argument|__r
argument_list|)
block|{}
specifier|inline
name|operator
name|_CharT
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_Rope_char_ref_proxy
modifier|&
name|operator
init|=
operator|(
name|_CharT
name|__c
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_Rope_char_ptr_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|&
operator|(
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_Rope_char_ref_proxy
modifier|&
name|operator
init|=
operator|(
specifier|const
name|_Rope_char_ref_proxy
operator|&
name|__c
operator|)
block|{
return|return
name|operator
operator|=
operator|(
operator|(
name|_CharT
operator|)
name|__c
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
unit|};
ifdef|#
directive|ifdef
name|__STL_FUNCTION_TMPL_PARTIAL_ORDER
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|__Alloc
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|_Rope_char_ref_proxy<_CharT
argument_list|,
argument|__Alloc> __a
argument_list|,
argument|_Rope_char_ref_proxy<_CharT
argument_list|,
argument|__Alloc> __b
argument_list|)
block|{
name|_CharT
name|__tmp
operator|=
name|__a
block|;
name|__a
operator|=
name|__b
block|;
name|__b
operator|=
name|__tmp
block|;     }
else|#
directive|else
comment|// There is no really acceptable way to handle this.  The default
comment|// definition of swap doesn't work for proxy references.
comment|// It can't really be made to work, even with ugly hacks, since
comment|// the only unusual operation it uses is the copy constructor, which
comment|// is needed for other purposes.  We provide a macro for
comment|// full specializations, and instantiate the most common case.
define|#
directive|define
name|_ROPE_SWAP_SPECIALIZATION
parameter_list|(
name|_CharT
parameter_list|,
name|__Alloc
parameter_list|)
define|\
value|inline void swap(_Rope_char_ref_proxy<_CharT, __Alloc> __a, \                      _Rope_char_ref_proxy<_CharT, __Alloc> __b) { \         _CharT __tmp = __a; \         __a = __b; \         __b = __tmp; \     }
name|_ROPE_SWAP_SPECIALIZATION
argument_list|(
argument|char
argument_list|,
argument|__STL_DEFAULT_ALLOCATOR(char)
argument_list|)
endif|#
directive|endif
comment|/* !__STL_FUNCTION_TMPL_PARTIAL_ORDER */
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_char_ptr_proxy
block|{
comment|// XXX this class should be rewritten.
name|friend
name|class
name|_Rope_char_ref_proxy
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
block|;
name|size_t
name|_M_pos
block|;
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|*
name|_M_root
block|;
comment|// The whole rope.
name|public
operator|:
name|_Rope_char_ptr_proxy
argument_list|(
specifier|const
name|_Rope_char_ref_proxy
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|)
operator|:
name|_M_pos
argument_list|(
name|__x
operator|.
name|_M_pos
argument_list|)
block|,
name|_M_root
argument_list|(
argument|__x._M_root
argument_list|)
block|{}
name|_Rope_char_ptr_proxy
argument_list|(
specifier|const
name|_Rope_char_ptr_proxy
operator|&
name|__x
argument_list|)
operator|:
name|_M_pos
argument_list|(
name|__x
operator|.
name|_M_pos
argument_list|)
block|,
name|_M_root
argument_list|(
argument|__x._M_root
argument_list|)
block|{}
name|_Rope_char_ptr_proxy
argument_list|()
block|{}
name|_Rope_char_ptr_proxy
argument_list|(
name|_CharT
operator|*
name|__x
argument_list|)
operator|:
name|_M_root
argument_list|(
literal|0
argument_list|)
block|,
name|_M_pos
argument_list|(
literal|0
argument_list|)
block|{
name|__stl_assert
argument_list|(
literal|0
operator|==
name|__x
argument_list|)
block|;     }
name|_Rope_char_ptr_proxy
operator|&
name|operator
operator|=
operator|(
specifier|const
name|_Rope_char_ptr_proxy
operator|&
name|__x
operator|)
block|{
name|_M_pos
operator|=
name|__x
operator|.
name|_M_pos
block|;
name|_M_root
operator|=
name|__x
operator|.
name|_M_root
block|;
return|return
operator|*
name|this
return|;
block|}
name|friend
name|bool
name|operator
operator|==
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|_Rope_char_ptr_proxy
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|,
specifier|const
name|_Rope_char_ptr_proxy
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_M_root
operator|,
name|_M_pos
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Rope iterators:
end_comment

begin_comment
comment|// Unlike in the C version, we cache only part of the stack
end_comment

begin_comment
comment|// for rope iterators, since they must be efficiently copyable.
end_comment

begin_comment
comment|// When we run out of cache, we have to reconstruct the iterator
end_comment

begin_comment
comment|// value.
end_comment

begin_comment
comment|// Pointers from iterators are not included in reference counts.
end_comment

begin_comment
comment|// Iterators are assumed to be thread private.  Ropes can
end_comment

begin_comment
comment|// be shared.
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
end_if

begin_pragma
pragma|#
directive|pragma
name|set
name|woff
name|1375
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_iterator_base
operator|:
name|public
name|random_access_iterator
operator|<
name|_CharT
operator|,
name|ptrdiff_t
operator|>
block|{
name|friend
name|class
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
block|;
name|public
operator|:
typedef|typedef
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_RopeRep
expr_stmt|;
comment|// Borland doesnt want this to be protected.
name|protected
operator|:
block|enum
block|{
name|_S_path_cache_len
operator|=
literal|4
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Must be<= 9.
end_comment

begin_enum
enum|enum
block|{
name|_S_iterator_buf_len
init|=
literal|15
block|}
enum|;
end_enum

begin_decl_stmt
name|size_t
name|_M_current_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_RopeRep
modifier|*
name|_M_root
decl_stmt|;
end_decl_stmt

begin_comment
comment|// The whole rope.
end_comment

begin_decl_stmt
name|size_t
name|_M_leaf_pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Starting position for current leaf
end_comment

begin_decl_stmt
name|__GC_CONST
name|_CharT
modifier|*
name|_M_buf_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Buffer possibly
end_comment

begin_comment
comment|// containing current char.
end_comment

begin_decl_stmt
name|__GC_CONST
name|_CharT
modifier|*
name|_M_buf_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Pointer to current char in buffer.
end_comment

begin_comment
comment|// != 0 ==> buffer valid.
end_comment

begin_decl_stmt
name|__GC_CONST
name|_CharT
modifier|*
name|_M_buf_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|// One past __last valid char in buffer.
end_comment

begin_comment
comment|// What follows is the path cache.  We go out of our
end_comment

begin_comment
comment|// way to make this compact.
end_comment

begin_comment
comment|// Path_end contains the bottom section of the path from
end_comment

begin_comment
comment|// the root to the current leaf.
end_comment

begin_decl_stmt
specifier|const
name|_RopeRep
modifier|*
name|_M_path_end
index|[
name|_S_path_cache_len
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_M_leaf_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Last valid __pos in path_end;
end_comment

begin_comment
comment|// _M_path_end[0] ... _M_path_end[leaf_index-1]
end_comment

begin_comment
comment|// point to concatenation nodes.
end_comment

begin_decl_stmt
name|unsigned
name|char
name|_M_path_directions
decl_stmt|;
end_decl_stmt

begin_comment
comment|// (path_directions>> __i)& 1 is 1
end_comment

begin_comment
comment|// iff we got from _M_path_end[leaf_index - __i - 1]
end_comment

begin_comment
comment|// to _M_path_end[leaf_index - __i] by going to the
end_comment

begin_comment
comment|// __right. Assumes path_cache_len<= 9.
end_comment

begin_decl_stmt
name|_CharT
name|_M_tmp_buf
index|[
name|_S_iterator_buf_len
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Short buffer for surrounding chars.
end_comment

begin_comment
comment|// This is useful primarily for
end_comment

begin_comment
comment|// RopeFunctions.  We put the buffer
end_comment

begin_comment
comment|// here to avoid locking in the
end_comment

begin_comment
comment|// multithreaded case.
end_comment

begin_comment
comment|// The cached path is generally assumed to be valid
end_comment

begin_comment
comment|// only if the buffer is valid.
end_comment

begin_function_decl
specifier|static
name|void
name|_S_setbuf
parameter_list|(
name|_Rope_iterator_base
modifier|&
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Set buffer contents given
end_comment

begin_comment
comment|// path cache.
end_comment

begin_function_decl
specifier|static
name|void
name|_S_setcache
parameter_list|(
name|_Rope_iterator_base
modifier|&
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Set buffer contents and
end_comment

begin_comment
comment|// path cache.
end_comment

begin_function_decl
specifier|static
name|void
name|_S_setcache_for_incr
parameter_list|(
name|_Rope_iterator_base
modifier|&
name|__x
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// As above, but assumes path
end_comment

begin_comment
comment|// cache is valid for previous posn.
end_comment

begin_macro
name|_Rope_iterator_base
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|_Rope_iterator_base
argument_list|(
argument|_RopeRep* __root
argument_list|,
argument|size_t __pos
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|_M_root
argument_list|(
name|__root
argument_list|)
operator|,
name|_M_current_pos
argument_list|(
name|__pos
argument_list|)
operator|,
name|_M_buf_ptr
argument_list|(
literal|0
argument_list|)
block|{}
name|void
name|_M_incr
argument_list|(
argument|size_t __n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
name|_M_decr
parameter_list|(
name|size_t
name|__n
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|size_t
name|index
argument_list|()
specifier|const
block|{
return|return
name|_M_current_pos
return|;
block|}
end_expr_stmt

begin_macro
name|_Rope_iterator_base
argument_list|(
argument|const _Rope_iterator_base& __x
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
literal|0
operator|!=
name|__x
operator|.
name|_M_buf_ptr
condition|)
block|{
operator|*
name|this
operator|=
name|__x
expr_stmt|;
block|}
else|else
block|{
name|_M_current_pos
operator|=
name|__x
operator|.
name|_M_current_pos
expr_stmt|;
name|_M_root
operator|=
name|__x
operator|.
name|_M_root
expr_stmt|;
name|_M_buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_iterator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_const_iterator
operator|:
name|public
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
block|{
name|friend
name|class
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
block|;
name|protected
operator|:
name|_Rope_const_iterator
argument_list|(
argument|const _RopeRep* __root
argument_list|,
argument|size_t __pos
argument_list|)
operator|:
name|_Rope_iterator_base
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|(
name|const_cast
operator|<
name|_RopeRep
operator|*
operator|>
operator|(
name|__root
operator|)
operator|,
name|__pos
operator|)
comment|// Only nonconst iterators modify root ref count
block|{}
name|public
operator|:
typedef|typedef
name|_CharT
name|reference
typedef|;
end_expr_stmt

begin_comment
comment|// Really a value.  Returning a reference
end_comment

begin_comment
comment|// Would be a mess, since it would have
end_comment

begin_comment
comment|// to be included in refcount.
end_comment

begin_typedef
typedef|typedef
specifier|const
name|_CharT
modifier|*
name|pointer
typedef|;
end_typedef

begin_label
name|public
label|:
end_label

begin_macro
name|_Rope_const_iterator
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|_Rope_const_iterator
argument_list|(
specifier|const
name|_Rope_const_iterator
operator|&
name|__x
argument_list|)
operator|:
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__x
operator|)
block|{ }
name|_Rope_const_iterator
argument_list|(
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|_Rope_const_iterator
argument_list|(
argument|const rope<_CharT
argument_list|,
argument|_Alloc>& __r
argument_list|,
argument|size_t __pos
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__r
operator|.
name|_M_tree_ptr
operator|,
name|__pos
operator|)
block|{}
name|_Rope_const_iterator
operator|&
name|operator
operator|=
operator|(
specifier|const
name|_Rope_const_iterator
operator|&
name|__x
operator|)
block|{
if|if
condition|(
literal|0
operator|!=
name|__x
operator|.
name|_M_buf_ptr
condition|)
block|{
operator|*
operator|(
name|static_cast
operator|<
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|>
operator|(
name|this
operator|)
operator|)
operator|=
name|__x
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|_M_current_pos
operator|=
name|__x
operator|.
name|_M_current_pos
expr_stmt|;
name|_M_root
operator|=
name|__x
operator|.
name|_M_root
expr_stmt|;
name|_M_buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|(
operator|*
name|this
operator|)
return|;
end_return

begin_macro
unit|}     reference
name|operator
end_macro

begin_expr_stmt
operator|*
operator|(
operator|)
block|{
if|if
condition|(
literal|0
operator|==
name|_M_buf_ptr
condition|)
name|_S_setcache
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|_M_buf_ptr
return|;
end_return

begin_expr_stmt
unit|}     _Rope_const_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|__GC_CONST
name|_CharT
operator|*
name|__next
block|;
if|if
condition|(
literal|0
operator|!=
name|_M_buf_ptr
operator|&&
operator|(
name|__next
operator|=
name|_M_buf_ptr
operator|+
literal|1
operator|)
operator|<
name|_M_buf_end
condition|)
block|{
name|_M_buf_ptr
operator|=
name|__next
expr_stmt|;
operator|++
name|_M_current_pos
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|_M_incr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}     _Rope_const_iterator
operator|&
name|operator
operator|+=
operator|(
name|ptrdiff_t
name|__n
operator|)
block|{
if|if
condition|(
name|__n
operator|>=
literal|0
condition|)
block|{
name|_M_incr
argument_list|(
name|__n
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|_M_decr
argument_list|(
operator|-
name|__n
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}     _Rope_const_iterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
name|_M_decr
argument_list|(
literal|1
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Rope_const_iterator
operator|&
name|operator
operator|-=
operator|(
name|ptrdiff_t
name|__n
operator|)
block|{
if|if
condition|(
name|__n
operator|>=
literal|0
condition|)
block|{
name|_M_decr
argument_list|(
name|__n
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|_M_incr
argument_list|(
operator|-
name|__n
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}     _Rope_const_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|size_t
name|__old_pos
operator|=
name|_M_current_pos
block|;
name|_M_incr
argument_list|(
literal|1
argument_list|)
block|;
return|return
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_M_root
operator|,
name|__old_pos
operator|)
return|;
comment|// This makes a subsequent dereference expensive.
comment|// Perhaps we should instead copy the iterator
comment|// if it has a valid cache?
block|}
end_expr_stmt

begin_expr_stmt
name|_Rope_const_iterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|size_t
name|__old_pos
operator|=
name|_M_current_pos
block|;
name|_M_decr
argument_list|(
literal|1
argument_list|)
block|;
return|return
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_M_root
operator|,
name|__old_pos
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|-
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|const _Rope_const_iterator<_CharT
argument_list|,
argument|_Alloc>& __x
argument_list|,
argument|ptrdiff_t __n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|const _Rope_const_iterator<_CharT
argument_list|,
argument|_Alloc>& __x
argument_list|,
argument|ptrdiff_t __n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|ptrdiff_t __n
argument_list|,
argument|const _Rope_const_iterator<_CharT
argument_list|,
argument|_Alloc>& __x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|reference
name|operator
function|[]
parameter_list|(
name|size_t
name|__n
parameter_list|)
block|{
return|return
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_fetch
argument_list|(
name|_M_root
argument_list|,
name|_M_current_pos
operator|+
name|__n
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|,
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|<
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|,
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|ptrdiff_t
name|operator
operator|-
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|,
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_iterator
operator|:
name|public
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
block|{
name|friend
name|class
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
block|;
name|protected
operator|:
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|*
name|_M_root_rope
block|;
comment|// root is treated as a cached version of this,
comment|// and is used to detect changes to the underlying
comment|// rope.
comment|// Root is included in the reference count.
comment|// This is necessary so that we can detect changes reliably.
comment|// Unfortunately, it requires careful bookkeeping for the
comment|// nonGC case.
name|_Rope_iterator
argument_list|(
argument|rope<_CharT
argument_list|,
argument|_Alloc>* __r
argument_list|,
argument|size_t __pos
argument_list|)
operator|:
name|_Rope_iterator_base
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|(
name|__r
operator|->
name|_M_tree_ptr
operator|,
name|__pos
operator|)
block|,
name|_M_root_rope
argument_list|(
argument|__r
argument_list|)
block|{
name|_RopeRep
operator|::
name|_S_ref
argument_list|(
name|_M_root
argument_list|)
block|; }
name|void
name|_M_check
argument_list|()
block|;
name|public
operator|:
typedef|typedef
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|reference
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
name|pointer
expr_stmt|;
end_typedef

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|container
argument_list|()
block|{
return|return
operator|*
name|_M_root_rope
return|;
block|}
end_expr_stmt

begin_macro
name|_Rope_iterator
argument_list|()
end_macro

begin_block
block|{
name|_M_root
operator|=
literal|0
expr_stmt|;
comment|// Needed for reference counting.
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|_Rope_iterator
argument_list|(
specifier|const
name|_Rope_iterator
operator|&
name|__x
argument_list|)
operator|:
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__x
operator|)
block|{
name|_M_root_rope
operator|=
name|__x
operator|.
name|_M_root_rope
block|;
name|_RopeRep
operator|::
name|_S_ref
argument_list|(
name|_M_root
argument_list|)
block|;     }
name|_Rope_iterator
argument_list|(
argument|rope<_CharT
argument_list|,
argument|_Alloc>& __r
argument_list|,
argument|size_t __pos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|_Rope_iterator
argument_list|()
block|{
name|_RopeRep
operator|::
name|_S_unref
argument_list|(
name|_M_root
argument_list|)
block|;     }
name|_Rope_iterator
operator|&
name|operator
operator|=
operator|(
specifier|const
name|_Rope_iterator
operator|&
name|__x
operator|)
block|{
name|_RopeRep
operator|*
name|__old
operator|=
name|_M_root
block|;
name|_RopeRep
operator|::
name|_S_ref
argument_list|(
name|__x
operator|.
name|_M_root
argument_list|)
block|;
if|if
condition|(
literal|0
operator|!=
name|__x
operator|.
name|_M_buf_ptr
condition|)
block|{
name|_M_root_rope
operator|=
name|__x
operator|.
name|_M_root_rope
expr_stmt|;
operator|*
operator|(
name|static_cast
operator|<
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|>
operator|(
name|this
operator|)
operator|)
operator|=
name|__x
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|_M_current_pos
operator|=
name|__x
operator|.
name|_M_current_pos
expr_stmt|;
name|_M_root
operator|=
name|__x
operator|.
name|_M_root
expr_stmt|;
name|_M_root_rope
operator|=
name|__x
operator|.
name|_M_root_rope
expr_stmt|;
name|_M_buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|_RopeRep
operator|::
name|_S_unref
argument_list|(
name|__old
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|*
name|this
operator|)
return|;
end_return

begin_macro
unit|}     reference
name|operator
end_macro

begin_expr_stmt
operator|*
operator|(
operator|)
block|{
name|_M_check
argument_list|()
block|;
if|if
condition|(
literal|0
operator|==
name|_M_buf_ptr
condition|)
block|{
return|return
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_M_root_rope
operator|,
name|_M_current_pos
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_M_root_rope
operator|,
name|_M_current_pos
operator|,
operator|*
name|_M_buf_ptr
operator|)
return|;
block|}
end_else

begin_expr_stmt
unit|}     _Rope_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
name|_M_incr
argument_list|(
literal|1
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Rope_iterator
operator|&
name|operator
operator|+=
operator|(
name|difference_type
name|__n
operator|)
block|{
if|if
condition|(
name|__n
operator|>=
literal|0
condition|)
block|{
name|_M_incr
argument_list|(
name|__n
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|_M_decr
argument_list|(
operator|-
name|__n
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}     _Rope_iterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
name|_M_decr
argument_list|(
literal|1
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Rope_iterator
operator|&
name|operator
operator|-=
operator|(
name|difference_type
name|__n
operator|)
block|{
if|if
condition|(
name|__n
operator|>=
literal|0
condition|)
block|{
name|_M_decr
argument_list|(
name|__n
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|_M_incr
argument_list|(
operator|-
name|__n
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}     _Rope_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|size_t
name|__old_pos
operator|=
name|_M_current_pos
block|;
name|_M_incr
argument_list|(
literal|1
argument_list|)
block|;
return|return
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_M_root_rope
operator|,
name|__old_pos
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Rope_iterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|size_t
name|__old_pos
operator|=
name|_M_current_pos
block|;
name|_M_decr
argument_list|(
literal|1
argument_list|)
block|;
return|return
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_M_root_rope
operator|,
name|__old_pos
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|reference
name|operator
function|[]
parameter_list|(
name|ptrdiff_t
name|__n
parameter_list|)
block|{
return|return
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_M_root_rope
operator|,
name|_M_current_pos
operator|+
name|__n
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|friend
name|bool
name|operator
operator|==
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|,
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|bool
name|operator
operator|<
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|,
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|ptrdiff_t
name|operator
operator|-
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|,
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|-
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|const _Rope_iterator<_CharT
argument_list|,
argument|_Alloc>& __x
argument_list|,
argument|ptrdiff_t __n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|const _Rope_iterator<_CharT
argument_list|,
argument|_Alloc>& __x
argument_list|,
argument|ptrdiff_t __n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|ptrdiff_t __n
argument_list|,
argument|const _Rope_iterator<_CharT
argument_list|,
argument|_Alloc>& __x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
unit|};
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
end_if

begin_pragma
pragma|#
directive|pragma
name|reset
name|woff
name|1375
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//  The rope base class encapsulates
end_comment

begin_comment
comment|//  the differences between SGI-style allocators and standard-conforming
end_comment

begin_comment
comment|//  allocators.
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
end_ifdef

begin_comment
comment|// Base class for ordinary allocators.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Allocator
operator|,
name|bool
name|_IsStatic
operator|>
name|class
name|_Rope_alloc_base
block|{
name|public
operator|:
typedef|typedef
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Allocator
operator|>
name|_RopeRep
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Alloc_traits
operator|<
name|_CharT
operator|,
name|_Allocator
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|allocator_type
name|get_allocator
argument_list|()
specifier|const
block|{
return|return
name|_M_data_allocator
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Rope_alloc_base
argument_list|(
name|_RopeRep
operator|*
name|__t
argument_list|,
specifier|const
name|allocator_type
operator|&
name|__a
argument_list|)
operator|:
name|_M_tree_ptr
argument_list|(
name|__t
argument_list|)
operator|,
name|_M_data_allocator
argument_list|(
argument|__a
argument_list|)
block|{}
name|_Rope_alloc_base
argument_list|(
specifier|const
name|allocator_type
operator|&
name|__a
argument_list|)
operator|:
name|_M_data_allocator
argument_list|(
argument|__a
argument_list|)
block|{}
name|protected
operator|:
comment|// The only data members of a rope:
name|allocator_type
name|_M_data_allocator
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_RopeRep
modifier|*
name|_M_tree_ptr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|__ROPE_DEFINE_ALLOC
parameter_list|(
name|_Tp
parameter_list|,
name|__name
parameter_list|)
define|\
value|typedef typename \           _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \         _Tp* __name##_allocate(size_t __n) const \           { return __name##Allocator(_M_data_allocator).allocate(__n); } \         void __name##_deallocate(_Tp *__p, size_t __n) const \                 { __name##Allocator(_M_data_allocator).deallocate(__p, __n); }
end_define

begin_macro
name|__ROPE_DEFINE_ALLOCS
argument_list|(
argument|_Allocator
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|__ROPE_DEFINE_ALLOC
end_undef

begin_comment
unit|};
comment|// Specialization for allocators that have the property that we don't
end_comment

begin_comment
comment|//  actually have to store an allocator object.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Allocator
operator|>
name|class
name|_Rope_alloc_base
operator|<
name|_CharT
operator|,
name|_Allocator
operator|,
name|true
operator|>
block|{
name|public
operator|:
typedef|typedef
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Allocator
operator|>
name|_RopeRep
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Alloc_traits
operator|<
name|_CharT
operator|,
name|_Allocator
operator|>
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|allocator_type
name|get_allocator
argument_list|()
specifier|const
block|{
return|return
name|allocator_type
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Rope_alloc_base
argument_list|(
name|_RopeRep
operator|*
name|__t
argument_list|,
specifier|const
name|allocator_type
operator|&
argument_list|)
operator|:
name|_M_tree_ptr
argument_list|(
argument|__t
argument_list|)
block|{}
name|_Rope_alloc_base
argument_list|(
argument|const allocator_type&
argument_list|)
block|{}
name|protected
operator|:
comment|// The only data member of a rope:
name|_RopeRep
operator|*
name|_M_tree_ptr
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|__ROPE_DEFINE_ALLOC
parameter_list|(
name|_Tp
parameter_list|,
name|__name
parameter_list|)
define|\
value|typedef typename \           _Alloc_traits<_Tp,_Allocator>::_Alloc_type __name##Alloc; \         typedef typename \           _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \         static _Tp* __name##_allocate(size_t __n) \           { return __name##Alloc::allocate(__n); } \         static void __name##_deallocate(_Tp *__p, size_t __n) \           { __name##Alloc::deallocate(__p, __n); }
end_define

begin_macro
name|__ROPE_DEFINE_ALLOCS
argument_list|(
argument|_Allocator
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|__ROPE_DEFINE_ALLOC
end_undef

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
expr|struct
name|_Rope_base
operator|:
name|public
name|_Rope_alloc_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|,
name|_Alloc_traits
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_instanceless
operator|>
block|{
typedef|typedef
name|_Rope_alloc_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|,
name|_Alloc_traits
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_instanceless
operator|>
name|_Base
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Base
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|_Rope_base
argument_list|(
name|_RopeRep
operator|*
name|__t
argument_list|,
specifier|const
name|allocator_type
operator|&
name|__a
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__t
argument_list|,
argument|__a
argument_list|)
block|{}
name|_Rope_base
argument_list|(
specifier|const
name|allocator_type
operator|&
name|__a
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__a
argument_list|)
block|{}
end_expr_stmt

begin_else
unit|};
else|#
directive|else
end_else

begin_comment
comment|/* !__STL_USE_STD_ALLOCATORS */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|_Rope_base
block|{
name|public
operator|:
typedef|typedef
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_RopeRep
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|_Alloc
name|allocator_type
typedef|;
end_typedef

begin_function
specifier|static
name|allocator_type
name|get_allocator
parameter_list|()
block|{
return|return
name|allocator_type
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|_Rope_base
argument_list|(
name|_RopeRep
operator|*
name|__t
argument_list|,
specifier|const
name|allocator_type
operator|&
argument_list|)
operator|:
name|_M_tree_ptr
argument_list|(
argument|__t
argument_list|)
block|{}
name|_Rope_base
argument_list|(
argument|const allocator_type&
argument_list|)
block|{}
name|protected
operator|:
comment|// The only data member of a rope:
name|_RopeRep
operator|*
name|_M_tree_ptr
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|__ROPE_DEFINE_ALLOC
parameter_list|(
name|_Tp
parameter_list|,
name|__name
parameter_list|)
define|\
value|typedef simple_alloc<_Tp, _Alloc> __name##Alloc; \         static _Tp* __name##_allocate(size_t __n) \                 { return __name##Alloc::allocate(__n); } \         static void __name##_deallocate(_Tp *__p, size_t __n) \                 { __name##Alloc::deallocate(__p, __n); }
end_define

begin_macro
name|__ROPE_DEFINE_ALLOCS
argument_list|(
argument|_Alloc
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|__ROPE_DEFINE_ALLOC
end_undef

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_USE_STD_ALLOCATORS */
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|class
name|rope
operator|:
name|public
name|_Rope_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
block|{
name|public
operator|:
typedef|typedef
name|_CharT
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|size_t
name|size_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_CharT
name|const_reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_CharT
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|const_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rope_char_ptr_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|pointer
expr_stmt|;
end_typedef

begin_expr_stmt
name|friend
name|class
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_macro
name|friend
end_macro

begin_expr_stmt
unit|struct
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|_Rope_char_ptr_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_macro
name|friend
end_macro

begin_expr_stmt
unit|struct
name|_Rope_RopeSubstring
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
expr_stmt|;
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_typedef
typedef|typedef
name|_Rope_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_Base
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_Base
operator|::
name|allocator_type
name|allocator_type
expr_stmt|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_USE_NAMESPACES
end_ifdef

begin_expr_stmt
name|using
name|_Base
operator|::
name|_M_tree_ptr
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|__GC_CONST
name|_CharT
modifier|*
name|_Cstrptr
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_SGI_THREADS
end_ifdef

begin_function
specifier|static
name|_Cstrptr
name|_S_atomic_swap
parameter_list|(
name|_Cstrptr
modifier|*
name|__p
parameter_list|,
name|_Cstrptr
name|__q
parameter_list|)
block|{
if|#
directive|if
name|__mips
operator|<
literal|3
operator|||
operator|!
operator|(
name|defined
argument_list|(
name|_ABIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_ABI64
argument_list|)
operator|)
return|return
operator|(
name|_Cstrptr
operator|)
name|test_and_set
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|__p
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|__q
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
name|_Cstrptr
operator|)
name|__test_and_set
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|__p
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|__q
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__STL_WIN32THREADS
argument_list|)
end_elif

begin_function
specifier|static
name|_Cstrptr
name|_S_atomic_swap
parameter_list|(
name|_Cstrptr
modifier|*
name|__p
parameter_list|,
name|_Cstrptr
name|__q
parameter_list|)
block|{
return|return
operator|(
name|_Cstrptr
operator|)
name|InterlockedExchange
argument_list|(
operator|(
name|LPLONG
operator|)
name|__p
argument_list|,
operator|(
name|LONG
operator|)
name|__q
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__STL_PTHREADS
argument_list|)
end_elif

begin_comment
comment|// This should be portable, but performance is expected
end_comment

begin_comment
comment|// to be quite awful.  This really needs platform specific
end_comment

begin_comment
comment|// code.
end_comment

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|_S_swap_lock
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|_Cstrptr
name|_S_atomic_swap
parameter_list|(
name|_Cstrptr
modifier|*
name|__p
parameter_list|,
name|_Cstrptr
name|__q
parameter_list|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|_S_swap_lock
argument_list|)
expr_stmt|;
name|_Cstrptr
name|__result
init|=
operator|*
name|__p
decl_stmt|;
operator|*
name|__p
operator|=
name|__q
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|_S_swap_lock
argument_list|)
expr_stmt|;
return|return
name|__result
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|_Cstrptr
name|_S_atomic_swap
parameter_list|(
name|_Cstrptr
modifier|*
name|__p
parameter_list|,
name|_Cstrptr
name|__q
parameter_list|)
block|{
name|_Cstrptr
name|__result
init|=
operator|*
name|__p
decl_stmt|;
operator|*
name|__p
operator|=
name|__q
expr_stmt|;
return|return
name|__result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|_CharT
name|_S_empty_c_str
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|_S_is0
parameter_list|(
name|_CharT
name|__c
parameter_list|)
block|{
return|return
name|__c
operator|==
name|_S_eos
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|_S_copy_max
init|=
literal|23
block|}
enum|;
end_enum

begin_comment
comment|// For strings shorter than _S_copy_max, we copy to
end_comment

begin_comment
comment|// concatenate.
end_comment

begin_typedef
typedef|typedef
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_RopeRep
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rope_RopeConcatenation
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_RopeConcatenation
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rope_RopeLeaf
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_RopeLeaf
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rope_RopeFunction
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_RopeFunction
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Rope_RopeSubstring
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_RopeSubstring
expr_stmt|;
end_typedef

begin_comment
comment|// Retrieve a character at the indicated position.
end_comment

begin_function_decl
specifier|static
name|_CharT
name|_S_fetch
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|,
name|size_type
name|__pos
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_comment
comment|// Obtain a pointer to the character at the indicated position.
end_comment

begin_comment
comment|// The pointer can be used to change the character.
end_comment

begin_comment
comment|// If such a pointer cannot be produced, as is frequently the
end_comment

begin_comment
comment|// case, 0 is returned instead.
end_comment

begin_comment
comment|// (Returns nonzero only if all nodes in the path have a refcount
end_comment

begin_comment
comment|// of 1.)
end_comment

begin_function_decl
specifier|static
name|_CharT
modifier|*
name|_S_fetch_ptr
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|,
name|size_type
name|__pos
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bool
name|_S_apply_to_pieces
argument_list|(
comment|// should be template parameter
name|_Rope_char_consumer
operator|<
name|_CharT
operator|>
operator|&
name|__c
argument_list|,
specifier|const
name|_RopeRep
operator|*
name|__r
argument_list|,
name|size_t
name|__begin
argument_list|,
name|size_t
name|__end
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// begin and end are assumed to be in range.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_function
specifier|static
name|void
name|_S_unref
parameter_list|(
name|_RopeRep
modifier|*
name|__t
parameter_list|)
block|{
name|_RopeRep
operator|::
name|_S_unref
argument_list|(
name|__t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_S_ref
parameter_list|(
name|_RopeRep
modifier|*
name|__t
parameter_list|)
block|{
name|_RopeRep
operator|::
name|_S_ref
argument_list|(
name|__t
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __GC */
end_comment

begin_function
specifier|static
name|void
name|_S_unref
parameter_list|(
name|_RopeRep
modifier|*
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|_S_ref
parameter_list|(
name|_RopeRep
modifier|*
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__GC
end_ifdef

begin_typedef
typedef|typedef
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
name|_Self_destruct_ptr
expr_stmt|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|_Rope_self_destruct_ptr
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_Self_destruct_ptr
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// _Result is counted in refcount.
end_comment

begin_function_decl
specifier|static
name|_RopeRep
modifier|*
name|_S_substring
parameter_list|(
name|_RopeRep
modifier|*
name|__base
parameter_list|,
name|size_t
name|__start
parameter_list|,
name|size_t
name|__endp1
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|_RopeRep
modifier|*
name|_S_concat_char_iter
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__iter
parameter_list|,
name|size_t
name|__slen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Concatenate rope and char ptr, copying __s.
end_comment

begin_comment
comment|// Should really take an arbitrary iterator.
end_comment

begin_comment
comment|// Result is counted in refcount.
end_comment

begin_function
specifier|static
name|_RopeRep
modifier|*
name|_S_destr_concat_char_iter
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__iter
parameter_list|,
name|size_t
name|__slen
parameter_list|)
comment|// As above, but one reference to __r is about to be
comment|// destroyed.  Thus the pieces may be recycled if all
comment|// relevent reference counts are 1.
ifdef|#
directive|ifdef
name|__GC
comment|// We can't really do anything since refcounts are unavailable.
block|{
return|return
name|_S_concat_char_iter
argument_list|(
name|__r
argument_list|,
name|__iter
argument_list|,
name|__slen
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|_RopeRep
modifier|*
name|_S_concat
parameter_list|(
name|_RopeRep
modifier|*
name|__left
parameter_list|,
name|_RopeRep
modifier|*
name|__right
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// General concatenation on _RopeRep.  _Result
end_comment

begin_comment
comment|// has refcount of 1.  Adjusts argument refcounts.
end_comment

begin_label
name|public
label|:
end_label

begin_decl_stmt
name|void
name|apply_to_pieces
argument_list|(
name|size_t
name|__begin
argument_list|,
name|size_t
name|__end
argument_list|,
name|_Rope_char_consumer
operator|<
name|_CharT
operator|>
operator|&
name|__c
argument_list|)
decl|const
block|{
name|_S_apply_to_pieces
argument_list|(
name|__c
argument_list|,
name|_M_tree_ptr
argument_list|,
name|__begin
argument_list|,
name|__end
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_function
specifier|static
name|size_t
name|_S_rounded_up_size
parameter_list|(
name|size_t
name|__n
parameter_list|)
block|{
return|return
name|_RopeLeaf
operator|::
name|_S_rounded_up_size
argument_list|(
name|__n
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|_S_allocated_capacity
parameter_list|(
name|size_t
name|__n
parameter_list|)
block|{
if|if
condition|(
name|_S_is_basic_char_type
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
return|return
name|_S_rounded_up_size
argument_list|(
name|__n
argument_list|)
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|_S_rounded_up_size
argument_list|(
name|__n
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|// Allocate and construct a RopeLeaf using the supplied allocator
end_comment

begin_comment
comment|// Takes ownership of s instead of copying.
end_comment

begin_function
specifier|static
name|_RopeLeaf
modifier|*
name|_S_new_RopeLeaf
parameter_list|(
name|__GC_CONST
name|_CharT
modifier|*
name|__s
parameter_list|,
name|size_t
name|__size
parameter_list|,
name|allocator_type
name|__a
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|_RopeLeaf
modifier|*
name|__space
init|=
name|_LAllocator
argument_list|(
name|__a
argument_list|)
operator|.
name|allocate
argument_list|(
literal|1
argument_list|)
decl_stmt|;
else|#
directive|else
name|_RopeLeaf
modifier|*
name|__space
init|=
name|_L_allocate
argument_list|(
literal|1
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return
name|new
argument_list|(
argument|__space
argument_list|)
name|_RopeLeaf
argument_list|(
name|__s
argument_list|,
name|__size
argument_list|,
name|__a
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|_RopeConcatenation
modifier|*
name|_S_new_RopeConcatenation
parameter_list|(
name|_RopeRep
modifier|*
name|__left
parameter_list|,
name|_RopeRep
modifier|*
name|__right
parameter_list|,
name|allocator_type
name|__a
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|_RopeConcatenation
modifier|*
name|__space
init|=
name|_CAllocator
argument_list|(
name|__a
argument_list|)
operator|.
name|allocate
argument_list|(
literal|1
argument_list|)
decl_stmt|;
else|#
directive|else
name|_RopeConcatenation
modifier|*
name|__space
init|=
name|_C_allocate
argument_list|(
literal|1
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return
name|new
argument_list|(
argument|__space
argument_list|)
name|_RopeConcatenation
argument_list|(
name|__left
argument_list|,
name|__right
argument_list|,
name|__a
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|_RopeFunction
modifier|*
name|_S_new_RopeFunction
argument_list|(
name|char_producer
operator|<
name|_CharT
operator|>
operator|*
name|__f
argument_list|,
name|size_t
name|__size
argument_list|,
name|bool
name|__d
argument_list|,
name|allocator_type
name|__a
argument_list|)
block|{
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|_RopeFunction
modifier|*
name|__space
init|=
name|_FAllocator
argument_list|(
name|__a
argument_list|)
operator|.
name|allocate
argument_list|(
literal|1
argument_list|)
decl_stmt|;
else|#
directive|else
name|_RopeFunction
modifier|*
name|__space
init|=
name|_F_allocate
argument_list|(
literal|1
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return
name|new
argument_list|(
argument|__space
argument_list|)
name|_RopeFunction
argument_list|(
name|__f
argument_list|,
name|__size
argument_list|,
name|__d
argument_list|,
name|__a
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|_RopeSubstring
modifier|*
name|_S_new_RopeSubstring
argument_list|(
name|_Rope_RopeRep
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|*
name|__b
argument_list|,
name|size_t
name|__s
argument_list|,
name|size_t
name|__l
argument_list|,
name|allocator_type
name|__a
argument_list|)
block|{
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|_RopeSubstring
modifier|*
name|__space
init|=
name|_SAllocator
argument_list|(
name|__a
argument_list|)
operator|.
name|allocate
argument_list|(
literal|1
argument_list|)
decl_stmt|;
else|#
directive|else
name|_RopeSubstring
modifier|*
name|__space
init|=
name|_S_allocate
argument_list|(
literal|1
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return
name|new
argument_list|(
argument|__space
argument_list|)
name|_RopeSubstring
argument_list|(
name|__b
argument_list|,
name|__s
argument_list|,
name|__l
argument_list|,
name|__a
argument_list|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
end_ifdef

begin_decl_stmt
specifier|static
name|_RopeLeaf
modifier|*
name|_S_RopeLeaf_from_unowned_char_ptr
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_t
name|__size
argument_list|,
name|allocator_type
name|__a
argument_list|)
define|#
directive|define
name|__STL_ROPE_FROM_UNOWNED_CHAR_PTR
parameter_list|(
name|__s
parameter_list|,
name|__size
parameter_list|,
name|__a
parameter_list|)
define|\
value|_S_RopeLeaf_from_unowned_char_ptr(__s, __size, __a)
else|#
directive|else
decl|static
name|_RopeLeaf
modifier|*
name|_S_RopeLeaf_from_unowned_char_ptr2
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
name|size_t
name|__size
argument_list|)
define|#
directive|define
name|__STL_ROPE_FROM_UNOWNED_CHAR_PTR
parameter_list|(
name|__s
parameter_list|,
name|__size
parameter_list|,
name|__a
parameter_list|)
define|\
value|_S_RopeLeaf_from_unowned_char_ptr2(__s, __size)
endif|#
directive|endif
block|{
if|if
condition|(
literal|0
operator|==
name|__size
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|_CharT
modifier|*
name|__buf
init|=
name|__a
operator|.
name|allocate
argument_list|(
name|_S_rounded_up_size
argument_list|(
name|__size
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|_CharT
modifier|*
name|__buf
init|=
name|_Data_allocate
argument_list|(
name|_S_rounded_up_size
argument_list|(
name|__size
argument_list|)
argument_list|)
decl_stmt|;
name|allocator_type
name|__a
init|=
name|allocator_type
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|uninitialized_copy_n
argument_list|(
name|__s
argument_list|,
name|__size
argument_list|,
name|__buf
argument_list|)
expr_stmt|;
name|_S_cond_store_eos
argument_list|(
name|__buf
index|[
name|__size
index|]
argument_list|)
expr_stmt|;
name|__STL_TRY
block|{
return|return
name|_S_new_RopeLeaf
argument_list|(
name|__buf
argument_list|,
name|__size
argument_list|,
name|__a
argument_list|)
return|;
block|}
name|__STL_UNWIND
argument_list|(
argument|_RopeRep::__STL_FREE_STRING(__buf, __size, __a)
argument_list|)
block|}
end_decl_stmt

begin_comment
comment|// Concatenation of nonempty strings.
end_comment

begin_comment
comment|// Always builds a concatenation node.
end_comment

begin_comment
comment|// Rebalances if the result is too deep.
end_comment

begin_comment
comment|// Result has refcount 1.
end_comment

begin_comment
comment|// Does not increment left and right ref counts even though
end_comment

begin_comment
comment|// they are referenced.
end_comment

begin_function_decl
specifier|static
name|_RopeRep
modifier|*
name|_S_tree_concat
parameter_list|(
name|_RopeRep
modifier|*
name|__left
parameter_list|,
name|_RopeRep
modifier|*
name|__right
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Concatenation helper functions
end_comment

begin_function_decl
specifier|static
name|_RopeLeaf
modifier|*
name|_S_leaf_concat_char_iter
parameter_list|(
name|_RopeLeaf
modifier|*
name|__r
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__iter
parameter_list|,
name|size_t
name|__slen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Concatenate by copying leaf.
end_comment

begin_comment
comment|// should take an arbitrary iterator
end_comment

begin_comment
comment|// result has refcount 1.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_function_decl
specifier|static
name|_RopeLeaf
modifier|*
name|_S_destr_leaf_concat_char_iter
parameter_list|(
name|_RopeLeaf
modifier|*
name|__r
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__iter
parameter_list|,
name|size_t
name|__slen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// A version that potentially clobbers __r if __r->_M_refcount == 1.
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// A helper function for exponentiating strings.
end_comment

begin_comment
comment|// This uses a nonstandard refcount convention.
end_comment

begin_comment
comment|// The result has refcount 0.
end_comment

begin_decl_stmt
name|struct
name|_Concat_fn
range|:
name|public
name|binary_function
operator|<
name|rope
operator|<
name|_CharT
decl_stmt|,
name|_Alloc
decl|>
decl_stmt|,
name|rope
decl|<
name|_CharT
decl_stmt|,
name|_Alloc
decl|>
decl_stmt|,
name|rope
decl|<
name|_CharT
decl_stmt|,
name|_Alloc
decl|>>
block|{
name|rope
name|operator
argument_list|()
operator|(
specifier|const
name|rope
operator|&
name|__x
operator|,
specifier|const
name|rope
operator|&
name|__y
operator|)
block|{
return|return
name|__x
operator|+
name|__y
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Needed by the call to "power" used to build ropes
end_comment

begin_comment
comment|// consisting of n copies of a character.
end_comment

begin_function
name|friend
name|rope
name|identity_element
parameter_list|(
name|_Concat_fn
parameter_list|)
block|{
return|return
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|size_t
name|_S_char_ptr_len
parameter_list|(
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// slightly generalized strlen
end_comment

begin_expr_stmt
name|rope
argument_list|(
name|_RopeRep
operator|*
name|__t
argument_list|,
specifier|const
name|allocator_type
operator|&
name|__a
operator|=
name|allocator_type
argument_list|()
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__t
argument_list|,
argument|__a
argument_list|)
block|{ }
comment|// Copy __r to the _CharT buffer.
comment|// Returns __buffer + __r->_M_size.
comment|// Assumes that buffer is uninitialized.
specifier|static
name|_CharT
operator|*
name|_S_flatten
argument_list|(
name|_RopeRep
operator|*
name|__r
argument_list|,
name|_CharT
operator|*
name|__buffer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Again, with explicit starting position and length.
end_comment

begin_comment
comment|// Assumes that buffer is uninitialized.
end_comment

begin_function_decl
specifier|static
name|_CharT
modifier|*
name|_S_flatten
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|,
name|size_t
name|__start
parameter_list|,
name|size_t
name|__len
parameter_list|,
name|_CharT
modifier|*
name|__buffer
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|long
name|_S_min_len
index|[
name|_RopeRep
operator|::
name|_S_max_rope_depth
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|_S_is_balanced
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|)
block|{
return|return
operator|(
name|__r
operator|->
name|_M_size
operator|>=
name|_S_min_len
index|[
name|__r
operator|->
name|_M_depth
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|_S_is_almost_balanced
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|)
block|{
return|return
operator|(
name|__r
operator|->
name|_M_depth
operator|==
literal|0
operator|||
name|__r
operator|->
name|_M_size
operator|>=
name|_S_min_len
index|[
name|__r
operator|->
name|_M_depth
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|_S_is_roughly_balanced
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|)
block|{
return|return
operator|(
name|__r
operator|->
name|_M_depth
operator|<=
literal|1
operator|||
name|__r
operator|->
name|_M_size
operator|>=
name|_S_min_len
index|[
name|__r
operator|->
name|_M_depth
operator|-
literal|2
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|// Assumes the result is not empty.
end_comment

begin_function
specifier|static
name|_RopeRep
modifier|*
name|_S_concat_and_set_balanced
parameter_list|(
name|_RopeRep
modifier|*
name|__left
parameter_list|,
name|_RopeRep
modifier|*
name|__right
parameter_list|)
block|{
name|_RopeRep
modifier|*
name|__result
init|=
name|_S_concat
argument_list|(
name|__left
argument_list|,
name|__right
argument_list|)
decl_stmt|;
if|if
condition|(
name|_S_is_balanced
argument_list|(
name|__result
argument_list|)
condition|)
name|__result
operator|->
name|_M_is_balanced
operator|=
name|true
expr_stmt|;
return|return
name|__result
return|;
block|}
end_function

begin_comment
comment|// The basic rebalancing operation.  Logically copies the
end_comment

begin_comment
comment|// rope.  The result has refcount of 1.  The client will
end_comment

begin_comment
comment|// usually decrement the reference count of __r.
end_comment

begin_comment
comment|// The result is within height 2 of balanced by the above
end_comment

begin_comment
comment|// definition.
end_comment

begin_function_decl
specifier|static
name|_RopeRep
modifier|*
name|_S_balance
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Add all unbalanced subtrees to the forest of balanceed trees.
end_comment

begin_comment
comment|// Used only by balance.
end_comment

begin_function_decl
specifier|static
name|void
name|_S_add_to_forest
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|,
name|_RopeRep
modifier|*
modifier|*
name|__forest
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Add __r to forest, assuming __r is already balanced.
end_comment

begin_function_decl
specifier|static
name|void
name|_S_add_leaf_to_forest
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|,
name|_RopeRep
modifier|*
modifier|*
name|__forest
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Print to stdout, exposing structure
end_comment

begin_function_decl
specifier|static
name|void
name|_S_dump
parameter_list|(
name|_RopeRep
modifier|*
name|__r
parameter_list|,
name|int
name|__indent
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Return -1, 0, or 1 if __x< __y, __x == __y, or __x> __y resp.
end_comment

begin_function_decl
specifier|static
name|int
name|_S_compare
parameter_list|(
specifier|const
name|_RopeRep
modifier|*
name|__x
parameter_list|,
specifier|const
name|_RopeRep
modifier|*
name|__y
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
literal|0
operator|==
name|_M_tree_ptr
return|;
block|}
end_expr_stmt

begin_comment
comment|// Comparison member function.  This is public only for those
end_comment

begin_comment
comment|// clients that need a ternary comparison.  Others
end_comment

begin_comment
comment|// should use the comparison operators below.
end_comment

begin_decl_stmt
name|int
name|compare
argument_list|(
specifier|const
name|rope
operator|&
name|__y
argument_list|)
decl|const
block|{
return|return
name|_S_compare
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__y
operator|.
name|_M_tree_ptr
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|rope
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
specifier|const
name|allocator_type
operator|&
name|__a
operator|=
name|allocator_type
argument_list|()
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, _S_char_ptr_len(__s),                                                  __a)
argument_list|,
argument|__a
argument_list|)
block|{ }
name|rope
argument_list|(
argument|const _CharT* __s
argument_list|,
argument|size_t __len
argument_list|,
argument|const allocator_type& __a = allocator_type()
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __len, __a)
argument_list|,
argument|__a
argument_list|)
block|{ }
comment|// Should perhaps be templatized with respect to the iterator type
comment|// and use Sequence_buffer.  (It should perhaps use sequence_buffer
comment|// even now.)
name|rope
argument_list|(
specifier|const
name|_CharT
operator|*
name|__s
argument_list|,
specifier|const
name|_CharT
operator|*
name|__e
argument_list|,
specifier|const
name|allocator_type
operator|&
name|__a
operator|=
name|allocator_type
argument_list|()
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __e - __s, __a)
argument_list|,
argument|__a
argument_list|)
block|{ }
name|rope
argument_list|(
specifier|const
name|const_iterator
operator|&
name|__s
argument_list|,
specifier|const
name|const_iterator
operator|&
name|__e
argument_list|,
specifier|const
name|allocator_type
operator|&
name|__a
operator|=
name|allocator_type
argument_list|()
argument_list|)
operator|:
name|_Base
argument_list|(
argument|_S_substring(__s._M_root, __s._M_current_pos,                              __e._M_current_pos)
argument_list|,
argument|__a
argument_list|)
block|{ }
name|rope
argument_list|(
specifier|const
name|iterator
operator|&
name|__s
argument_list|,
specifier|const
name|iterator
operator|&
name|__e
argument_list|,
specifier|const
name|allocator_type
operator|&
name|__a
operator|=
name|allocator_type
argument_list|()
argument_list|)
operator|:
name|_Base
argument_list|(
argument|_S_substring(__s._M_root, __s._M_current_pos,                              __e._M_current_pos)
argument_list|,
argument|__a
argument_list|)
block|{ }
name|rope
argument_list|(
argument|_CharT __c
argument_list|,
argument|const allocator_type& __a = allocator_type()
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__a
argument_list|)
block|{
name|_CharT
operator|*
name|__buf
operator|=
name|_Data_allocate
argument_list|(
name|_S_rounded_up_size
argument_list|(
literal|1
argument_list|)
argument_list|)
block|;
name|construct
argument_list|(
name|__buf
argument_list|,
name|__c
argument_list|)
block|;
name|__STL_TRY
block|{
name|_M_tree_ptr
operator|=
name|_S_new_RopeLeaf
argument_list|(
name|__buf
argument_list|,
literal|1
argument_list|,
name|__a
argument_list|)
block|;             }
name|__STL_UNWIND
argument_list|(
argument|_RopeRep::__STL_FREE_STRING(__buf,
literal|1
argument|, __a)
argument_list|)
block|}
name|rope
argument_list|(
argument|size_t __n
argument_list|,
argument|_CharT __c
argument_list|,
argument|const allocator_type& __a = allocator_type()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rope
argument_list|(
specifier|const
name|allocator_type
operator|&
name|__a
operator|=
name|allocator_type
argument_list|()
argument_list|)
operator|:
name|_Base
argument_list|(
literal|0
argument_list|,
argument|__a
argument_list|)
block|{}
comment|// Construct a rope from a function that can compute its members
name|rope
argument_list|(
argument|char_producer<_CharT> *__fn
argument_list|,
argument|size_t __len
argument_list|,
argument|bool __delete_fn
argument_list|,
argument|const allocator_type& __a = allocator_type()
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__a
argument_list|)
block|{
name|_M_tree_ptr
operator|=
operator|(
literal|0
operator|==
name|__len
operator|)
operator|?
literal|0
operator|:
name|_S_new_RopeFunction
argument_list|(
name|__fn
argument_list|,
name|__len
argument_list|,
name|__delete_fn
argument_list|,
name|__a
argument_list|)
block|;         }
name|rope
argument_list|(
specifier|const
name|rope
operator|&
name|__x
argument_list|,
specifier|const
name|allocator_type
operator|&
name|__a
operator|=
name|allocator_type
argument_list|()
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__x._M_tree_ptr
argument_list|,
argument|__a
argument_list|)
block|{
name|_S_ref
argument_list|(
name|_M_tree_ptr
argument_list|)
block|;         }
operator|~
name|rope
argument_list|()
block|{
name|_S_unref
argument_list|(
name|_M_tree_ptr
argument_list|)
block|;         }
name|rope
operator|&
name|operator
operator|=
operator|(
specifier|const
name|rope
operator|&
name|__x
operator|)
block|{
name|_RopeRep
operator|*
name|__old
operator|=
name|_M_tree_ptr
block|;
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|__stl_assert
argument_list|(
name|get_allocator
argument_list|()
operator|==
name|__x
operator|.
name|get_allocator
argument_list|()
argument_list|)
block|;
endif|#
directive|endif
name|_M_tree_ptr
operator|=
name|__x
operator|.
name|_M_tree_ptr
block|;
name|_S_ref
argument_list|(
name|_M_tree_ptr
argument_list|)
block|;
name|_S_unref
argument_list|(
name|__old
argument_list|)
block|;
return|return
operator|(
operator|*
name|this
operator|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|push_back
parameter_list|(
name|_CharT
name|__x
parameter_list|)
block|{
name|_RopeRep
modifier|*
name|__old
init|=
name|_M_tree_ptr
decl_stmt|;
name|_M_tree_ptr
operator|=
name|_S_concat_char_iter
argument_list|(
name|_M_tree_ptr
argument_list|,
operator|&
name|__x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_S_unref
argument_list|(
name|__old
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_back
parameter_list|()
block|{
name|_RopeRep
modifier|*
name|__old
init|=
name|_M_tree_ptr
decl_stmt|;
name|_M_tree_ptr
operator|=
name|_S_substring
argument_list|(
name|_M_tree_ptr
argument_list|,
literal|0
argument_list|,
name|_M_tree_ptr
operator|->
name|_M_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_S_unref
argument_list|(
name|__old
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|_CharT
name|back
argument_list|()
specifier|const
block|{
return|return
name|_S_fetch
argument_list|(
name|_M_tree_ptr
argument_list|,
name|_M_tree_ptr
operator|->
name|_M_size
operator|-
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|push_front
parameter_list|(
name|_CharT
name|__x
parameter_list|)
block|{
name|_RopeRep
modifier|*
name|__old
init|=
name|_M_tree_ptr
decl_stmt|;
name|_RopeRep
modifier|*
name|__left
init|=
name|__STL_ROPE_FROM_UNOWNED_CHAR_PTR
argument_list|(
operator|&
name|__x
argument_list|,
literal|1
argument_list|,
name|get_allocator
argument_list|()
argument_list|)
decl_stmt|;
name|__STL_TRY
block|{
name|_M_tree_ptr
operator|=
name|_S_concat
argument_list|(
name|__left
argument_list|,
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_S_unref
argument_list|(
name|__old
argument_list|)
expr_stmt|;
name|_S_unref
argument_list|(
name|__left
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|_S_unref(__left)
argument_list|)
block|}
end_function

begin_function
name|void
name|pop_front
parameter_list|()
block|{
name|_RopeRep
modifier|*
name|__old
init|=
name|_M_tree_ptr
decl_stmt|;
name|_M_tree_ptr
operator|=
name|_S_substring
argument_list|(
name|_M_tree_ptr
argument_list|,
literal|1
argument_list|,
name|_M_tree_ptr
operator|->
name|_M_size
argument_list|)
expr_stmt|;
name|_S_unref
argument_list|(
name|__old
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|_CharT
name|front
argument_list|()
specifier|const
block|{
return|return
name|_S_fetch
argument_list|(
name|_M_tree_ptr
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|balance
parameter_list|()
block|{
name|_RopeRep
modifier|*
name|__old
init|=
name|_M_tree_ptr
decl_stmt|;
name|_M_tree_ptr
operator|=
name|_S_balance
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_S_unref
argument_list|(
name|__old
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|copy
argument_list|(
name|_CharT
operator|*
name|__buffer
argument_list|)
decl|const
block|{
name|destroy
argument_list|(
name|__buffer
argument_list|,
name|__buffer
operator|+
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|_S_flatten
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__buffer
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// This is the copy function from the standard, but
end_comment

begin_comment
comment|// with the arguments reordered to make it consistent with the
end_comment

begin_comment
comment|// rest of the interface.
end_comment

begin_comment
comment|// Note that this guaranteed not to compile if the draft standard
end_comment

begin_comment
comment|// order is assumed.
end_comment

begin_decl_stmt
name|size_type
name|copy
argument_list|(
name|size_type
name|__pos
argument_list|,
name|size_type
name|__n
argument_list|,
name|_CharT
operator|*
name|__buffer
argument_list|)
decl|const
block|{
name|size_t
name|__size
init|=
name|size
argument_list|()
decl_stmt|;
name|size_t
name|__len
init|=
operator|(
name|__pos
operator|+
name|__n
operator|>
name|__size
condition|?
name|__size
operator|-
name|__pos
else|:
name|__n
operator|)
decl_stmt|;
name|destroy
argument_list|(
name|__buffer
argument_list|,
name|__buffer
operator|+
name|__len
argument_list|)
expr_stmt|;
name|_S_flatten
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__pos
argument_list|,
name|__len
argument_list|,
name|__buffer
argument_list|)
expr_stmt|;
return|return
name|__len
return|;
block|}
end_decl_stmt

begin_comment
comment|// Print to stdout, exposing structure.  May be useful for
end_comment

begin_comment
comment|// performance debugging.
end_comment

begin_function
name|void
name|dump
parameter_list|()
block|{
name|_S_dump
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Convert to 0 terminated string in new allocated memory.
end_comment

begin_comment
comment|// Embedded 0s in the input do not terminate the copy.
end_comment

begin_expr_stmt
specifier|const
name|_CharT
operator|*
name|c_str
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|// As above, but lso use the flattened representation as the
end_comment

begin_comment
comment|// the new rope representation.
end_comment

begin_function_decl
specifier|const
name|_CharT
modifier|*
name|replace_with_c_str
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Reclaim memory for the c_str generated flattened string.
end_comment

begin_comment
comment|// Intentionally undocumented, since it's hard to say when this
end_comment

begin_comment
comment|// is safe for multiple threads.
end_comment

begin_function
name|void
name|delete_c_str
parameter_list|()
block|{
if|if
condition|(
literal|0
operator|==
name|_M_tree_ptr
condition|)
return|return;
if|if
condition|(
name|_RopeRep
operator|::
name|_S_leaf
operator|==
name|_M_tree_ptr
operator|->
name|_M_tag
operator|&&
operator|(
operator|(
name|_RopeLeaf
operator|*
operator|)
name|_M_tree_ptr
operator|)
operator|->
name|_M_data
operator|==
name|_M_tree_ptr
operator|->
name|_M_c_string
condition|)
block|{
comment|// Representation shared
return|return;
block|}
ifndef|#
directive|ifndef
name|__GC
name|_M_tree_ptr
operator|->
name|_M_free_c_string
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|_M_tree_ptr
operator|->
name|_M_c_string
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|_CharT
name|operator
index|[]
argument_list|(
name|size_type
name|__pos
argument_list|)
decl|const
block|{
return|return
name|_S_fetch
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__pos
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|_CharT
name|at
argument_list|(
name|size_type
name|__pos
argument_list|)
decl|const
block|{
comment|// if (__pos>= size()) throw out_of_range;  // XXX
return|return
operator|(
operator|*
name|this
operator|)
index|[
name|__pos
index|]
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
argument_list|(
name|_M_tree_ptr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// An easy way to get a const iterator from a non-const container.
end_comment

begin_expr_stmt
name|const_iterator
name|const_begin
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
argument_list|(
name|_M_tree_ptr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
argument_list|(
name|_M_tree_ptr
argument_list|,
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_iterator
name|const_end
argument_list|()
specifier|const
block|{
return|return
operator|(
name|const_iterator
argument_list|(
name|_M_tree_ptr
argument_list|,
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
operator|(
literal|0
operator|==
name|_M_tree_ptr
operator|?
literal|0
operator|:
name|_M_tree_ptr
operator|->
name|_M_size
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|length
argument_list|()
specifier|const
block|{
return|return
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|_S_min_len
index|[
name|_RopeRep
operator|::
name|_S_max_rope_depth
operator|-
literal|1
index|]
operator|-
literal|1
return|;
comment|//  Guarantees that the result can be sufficirntly
comment|//  balanced.  Longer ropes will probably still work,
comment|//  but it's harder to make guarantees.
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_CLASS_PARTIAL_SPECIALIZATION
end_ifdef

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|const_iterator
operator|>
name|const_reverse_iterator
expr_stmt|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|const_iterator
operator|,
name|value_type
operator|,
name|const_reference
operator|,
name|difference_type
operator|>
name|const_reverse_iterator
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_expr_stmt
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_reverse_iterator
name|const_rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|const_reverse_iterator
name|const_rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|rope
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__left
argument_list|,
specifier|const
name|rope
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__right
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
specifier|const
name|rope
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__left
argument_list|,
specifier|const
name|_CharT
operator|*
name|__right
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
name|__STL_NULL_TMPL_ARGS
argument_list|(
argument|const rope<_CharT
argument_list|,
argument|_Alloc>& __left
argument_list|,
argument|_CharT __right
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// The symmetric cases are intentionally omitted, since they're presumed
end_comment

begin_comment
comment|// to be less common, and we don't handle them as well.
end_comment

begin_comment
comment|// The following should really be templatized.
end_comment

begin_comment
comment|// The first argument should be an input iterator or
end_comment

begin_comment
comment|// forward iterator with value_type _CharT.
end_comment

begin_function
name|rope
modifier|&
name|append
parameter_list|(
specifier|const
name|_CharT
modifier|*
name|__iter
parameter_list|,
name|size_t
name|__n
parameter_list|)
block|{
name|_RopeRep
modifier|*
name|__result
init|=
name|_S_destr_concat_char_iter
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__iter
argument_list|,
name|__n
argument_list|)
decl_stmt|;
name|_S_unref
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_M_tree_ptr
operator|=
name|__result
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
specifier|const
name|_CharT
modifier|*
name|__c_string
parameter_list|)
block|{
name|size_t
name|__len
init|=
name|_S_char_ptr_len
argument_list|(
name|__c_string
argument_list|)
decl_stmt|;
name|append
argument_list|(
name|__c_string
argument_list|,
name|__len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|this
operator|)
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
specifier|const
name|_CharT
modifier|*
name|__s
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__e
parameter_list|)
block|{
name|_RopeRep
modifier|*
name|__result
init|=
name|_S_destr_concat_char_iter
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__s
argument_list|,
name|__e
operator|-
name|__s
argument_list|)
decl_stmt|;
name|_S_unref
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_M_tree_ptr
operator|=
name|__result
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
name|const_iterator
name|__s
parameter_list|,
name|const_iterator
name|__e
parameter_list|)
block|{
name|__stl_assert
argument_list|(
name|__s
operator|.
name|_M_root
operator|==
name|__e
operator|.
name|_M_root
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|__stl_assert
argument_list|(
name|get_allocator
argument_list|()
operator|==
name|__s
operator|.
name|_M_root
operator|->
name|get_allocator
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_Self_destruct_ptr
name|__appendee
argument_list|(
name|_S_substring
argument_list|(
name|__s
operator|.
name|_M_root
argument_list|,
name|__s
operator|.
name|_M_current_pos
argument_list|,
name|__e
operator|.
name|_M_current_pos
argument_list|)
argument_list|)
decl_stmt|;
name|_RopeRep
modifier|*
name|__result
init|=
name|_S_concat
argument_list|(
name|_M_tree_ptr
argument_list|,
operator|(
name|_RopeRep
operator|*
operator|)
name|__appendee
argument_list|)
decl_stmt|;
name|_S_unref
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_M_tree_ptr
operator|=
name|__result
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
name|_CharT
name|__c
parameter_list|)
block|{
name|_RopeRep
modifier|*
name|__result
init|=
name|_S_destr_concat_char_iter
argument_list|(
name|_M_tree_ptr
argument_list|,
operator|&
name|__c
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|_S_unref
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_M_tree_ptr
operator|=
name|__result
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|()
block|{
return|return
name|append
argument_list|(
name|_CharT
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// XXX why?
end_comment

begin_function
name|rope
modifier|&
name|append
parameter_list|(
specifier|const
name|rope
modifier|&
name|__y
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|__stl_assert
argument_list|(
name|__y
operator|.
name|get_allocator
argument_list|()
operator|==
name|get_allocator
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_RopeRep
modifier|*
name|__result
init|=
name|_S_concat
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__y
operator|.
name|_M_tree_ptr
argument_list|)
decl_stmt|;
name|_S_unref
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_M_tree_ptr
operator|=
name|__result
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_function
name|rope
modifier|&
name|append
parameter_list|(
name|size_t
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|__last
argument_list|(
name|__n
argument_list|,
name|__c
argument_list|)
expr_stmt|;
return|return
name|append
argument_list|(
name|__last
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|swap
parameter_list|(
name|rope
modifier|&
name|__b
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|__stl_assert
argument_list|(
name|get_allocator
argument_list|()
operator|==
name|__b
operator|.
name|get_allocator
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_RopeRep
modifier|*
name|__tmp
init|=
name|_M_tree_ptr
decl_stmt|;
name|_M_tree_ptr
operator|=
name|__b
operator|.
name|_M_tree_ptr
expr_stmt|;
name|__b
operator|.
name|_M_tree_ptr
operator|=
name|__tmp
expr_stmt|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_comment
comment|// Result is included in refcount.
end_comment

begin_function
specifier|static
name|_RopeRep
modifier|*
name|replace
parameter_list|(
name|_RopeRep
modifier|*
name|__old
parameter_list|,
name|size_t
name|__pos1
parameter_list|,
name|size_t
name|__pos2
parameter_list|,
name|_RopeRep
modifier|*
name|__r
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|__old
condition|)
block|{
name|_S_ref
argument_list|(
name|__r
argument_list|)
expr_stmt|;
return|return
name|__r
return|;
block|}
name|_Self_destruct_ptr
name|__left
argument_list|(
name|_S_substring
argument_list|(
name|__old
argument_list|,
literal|0
argument_list|,
name|__pos1
argument_list|)
argument_list|)
decl_stmt|;
name|_Self_destruct_ptr
name|__right
argument_list|(
name|_S_substring
argument_list|(
name|__old
argument_list|,
name|__pos2
argument_list|,
name|__old
operator|->
name|_M_size
argument_list|)
argument_list|)
decl_stmt|;
name|_RopeRep
modifier|*
name|__result
decl_stmt|;
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|__stl_assert
argument_list|(
name|__old
operator|->
name|get_allocator
argument_list|()
operator|==
name|__r
operator|->
name|get_allocator
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
literal|0
operator|==
name|__r
condition|)
block|{
name|__result
operator|=
name|_S_concat
argument_list|(
name|__left
argument_list|,
name|__right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_Self_destruct_ptr
name|__left_result
argument_list|(
name|_S_concat
argument_list|(
name|__left
argument_list|,
name|__r
argument_list|)
argument_list|)
decl_stmt|;
name|__result
operator|=
name|_S_concat
argument_list|(
name|__left_result
argument_list|,
name|__right
argument_list|)
expr_stmt|;
block|}
return|return
name|__result
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|rope
modifier|&
name|__r
parameter_list|)
block|{
name|_RopeRep
modifier|*
name|__result
init|=
name|replace
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__p
argument_list|,
name|__p
argument_list|,
name|__r
operator|.
name|_M_tree_ptr
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|__stl_assert
argument_list|(
name|get_allocator
argument_list|()
operator|==
name|__r
operator|.
name|get_allocator
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_S_unref
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_M_tree_ptr
operator|=
name|__result
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|__r
argument_list|(
name|__n
argument_list|,
name|__c
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|__p
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
name|size_t
name|__n
parameter_list|)
block|{
name|_Self_destruct_ptr
name|__left
argument_list|(
name|_S_substring
argument_list|(
name|_M_tree_ptr
argument_list|,
literal|0
argument_list|,
name|__p
argument_list|)
argument_list|)
decl_stmt|;
name|_Self_destruct_ptr
name|__right
argument_list|(
name|_S_substring
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__p
argument_list|,
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|_Self_destruct_ptr
name|__left_result
argument_list|(
name|_S_concat_char_iter
argument_list|(
name|__left
argument_list|,
name|__i
argument_list|,
name|__n
argument_list|)
argument_list|)
decl_stmt|;
name|_RopeRep
modifier|*
name|__result
init|=
name|_S_concat
argument_list|(
name|__left_result
argument_list|,
name|__right
argument_list|)
decl_stmt|;
name|_S_unref
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_M_tree_ptr
operator|=
name|__result
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__c_string
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
argument_list|,
name|__c_string
argument_list|,
name|_S_char_ptr_len
argument_list|(
name|__c_string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
argument_list|,
operator|&
name|__c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|__p
parameter_list|)
block|{
name|_CharT
name|__c
init|=
name|_CharT
argument_list|()
decl_stmt|;
name|insert
argument_list|(
name|__p
argument_list|,
operator|&
name|__c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__j
parameter_list|)
block|{
name|rope
name|__r
argument_list|(
name|__i
argument_list|,
name|__j
argument_list|)
decl_stmt|;
name|insert
argument_list|(
name|__p
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|__i
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|__j
parameter_list|)
block|{
name|rope
name|__r
argument_list|(
name|__i
argument_list|,
name|__j
argument_list|)
decl_stmt|;
name|insert
argument_list|(
name|__p
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__i
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__j
parameter_list|)
block|{
name|rope
name|__r
argument_list|(
name|__i
argument_list|,
name|__j
argument_list|)
decl_stmt|;
name|insert
argument_list|(
name|__p
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// (position, length) versions of replace operations:
end_comment

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|,
specifier|const
name|rope
modifier|&
name|__r
parameter_list|)
block|{
name|_RopeRep
modifier|*
name|__result
init|=
name|replace
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__p
argument_list|,
name|__p
operator|+
name|__n
argument_list|,
name|__r
operator|.
name|_M_tree_ptr
argument_list|)
decl_stmt|;
name|_S_unref
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_M_tree_ptr
operator|=
name|__result
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
name|size_t
name|__i_len
parameter_list|)
block|{
name|rope
name|__r
argument_list|(
name|__i
argument_list|,
name|__i_len
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|rope
name|__r
argument_list|(
name|__c
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__c_string
parameter_list|)
block|{
name|rope
name|__r
argument_list|(
name|__c_string
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__j
parameter_list|)
block|{
name|rope
name|__r
argument_list|(
name|__i
argument_list|,
name|__j
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|__i
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|__j
parameter_list|)
block|{
name|rope
name|__r
argument_list|(
name|__i
argument_list|,
name|__j
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__i
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__j
parameter_list|)
block|{
name|rope
name|__r
argument_list|(
name|__i
argument_list|,
name|__j
argument_list|)
decl_stmt|;
name|replace
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Single character variants:
end_comment

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|iterator
name|__i
argument_list|(
name|this
argument_list|,
name|__p
argument_list|)
decl_stmt|;
operator|*
name|__i
operator|=
name|__c
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|rope
modifier|&
name|__r
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
argument_list|,
literal|1
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
name|size_t
name|__i_len
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
argument_list|,
literal|1
argument_list|,
name|__i
argument_list|,
name|__i_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__c_string
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
argument_list|,
literal|1
argument_list|,
name|__c_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__j
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
argument_list|,
literal|1
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|__i
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|__j
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
argument_list|,
literal|1
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
name|size_t
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__i
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__j
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
argument_list|,
literal|1
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Erase, (position, size) variant.
end_comment

begin_function
name|void
name|erase
parameter_list|(
name|size_t
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|)
block|{
name|_RopeRep
modifier|*
name|__result
init|=
name|replace
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__p
argument_list|,
name|__p
operator|+
name|__n
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|_S_unref
argument_list|(
name|_M_tree_ptr
argument_list|)
expr_stmt|;
name|_M_tree_ptr
operator|=
name|__result
expr_stmt|;
block|}
end_function

begin_comment
comment|// Erase, single character
end_comment

begin_function
name|void
name|erase
parameter_list|(
name|size_t
name|__p
parameter_list|)
block|{
name|erase
argument_list|(
name|__p
argument_list|,
name|__p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Insert, iterator variants.
end_comment

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|rope
modifier|&
name|__r
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__r
argument_list|)
expr_stmt|;
return|return
name|__p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
name|size_t
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__n
argument_list|,
name|__c
argument_list|)
expr_stmt|;
return|return
name|__p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__c
argument_list|)
expr_stmt|;
return|return
name|__p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|__p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|c_string
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|c_string
argument_list|)
expr_stmt|;
return|return
name|__p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
name|size_t
name|__n
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__n
argument_list|)
expr_stmt|;
return|return
name|__p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__j
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
return|return
name|__p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|__i
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|__j
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
return|return
name|__p
return|;
block|}
end_function

begin_function
name|iterator
name|insert
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__i
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__j
parameter_list|)
block|{
name|insert
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
return|return
name|__p
return|;
block|}
end_function

begin_comment
comment|// Replace, range variants.
end_comment

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__q
parameter_list|,
specifier|const
name|rope
modifier|&
name|__r
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__q
operator|.
name|index
argument_list|()
operator|-
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__q
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__q
operator|.
name|index
argument_list|()
operator|-
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__q
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__c_string
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__q
operator|.
name|index
argument_list|()
operator|-
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__c_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__q
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
name|size_t
name|__n
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__q
operator|.
name|index
argument_list|()
operator|-
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__q
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__j
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__q
operator|.
name|index
argument_list|()
operator|-
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__q
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|__i
parameter_list|,
specifier|const
name|const_iterator
modifier|&
name|__j
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__q
operator|.
name|index
argument_list|()
operator|-
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__q
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__i
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__j
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__q
operator|.
name|index
argument_list|()
operator|-
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Replace, iterator variants.
end_comment

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|rope
modifier|&
name|__r
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__c_string
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__c_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
name|size_t
name|__n
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__i
parameter_list|,
specifier|const
name|_CharT
modifier|*
name|__j
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
name|const_iterator
name|__i
parameter_list|,
name|const_iterator
name|__j
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
name|iterator
name|__i
parameter_list|,
name|iterator
name|__j
parameter_list|)
block|{
name|replace
argument_list|(
name|__p
operator|.
name|index
argument_list|()
argument_list|,
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Iterator and range variants of erase
end_comment

begin_function
name|iterator
name|erase
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|,
specifier|const
name|iterator
modifier|&
name|__q
parameter_list|)
block|{
name|size_t
name|__p_index
init|=
name|__p
operator|.
name|index
argument_list|()
decl_stmt|;
name|erase
argument_list|(
name|__p_index
argument_list|,
name|__q
operator|.
name|index
argument_list|()
operator|-
name|__p_index
argument_list|)
expr_stmt|;
return|return
name|iterator
argument_list|(
name|this
argument_list|,
name|__p_index
argument_list|)
return|;
block|}
end_function

begin_function
name|iterator
name|erase
parameter_list|(
specifier|const
name|iterator
modifier|&
name|__p
parameter_list|)
block|{
name|size_t
name|__p_index
init|=
name|__p
operator|.
name|index
argument_list|()
decl_stmt|;
name|erase
argument_list|(
name|__p_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|iterator
argument_list|(
name|this
argument_list|,
name|__p_index
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|rope
name|substr
argument_list|(
name|size_t
name|__start
argument_list|,
name|size_t
name|__len
operator|=
literal|1
argument_list|)
decl|const
block|{
return|return
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_S_substring
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__start
argument_list|,
name|__start
operator|+
name|__len
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|rope
name|substr
argument_list|(
name|iterator
name|__start
argument_list|,
name|iterator
name|__end
argument_list|)
decl|const
block|{
return|return
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_S_substring
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__start
operator|.
name|index
argument_list|()
argument_list|,
name|__end
operator|.
name|index
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|rope
name|substr
argument_list|(
name|iterator
name|__start
argument_list|)
decl|const
block|{
name|size_t
name|__pos
init|=
name|__start
operator|.
name|index
argument_list|()
decl_stmt|;
return|return
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_S_substring
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__pos
argument_list|,
name|__pos
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|rope
name|substr
argument_list|(
name|const_iterator
name|__start
argument_list|,
name|const_iterator
name|__end
argument_list|)
decl|const
block|{
comment|// This might eventually take advantage of the cache in the
comment|// iterator.
return|return
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_S_substring
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__start
operator|.
name|index
argument_list|()
argument_list|,
name|__end
operator|.
name|index
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|substr
argument_list|(
argument|const_iterator __start
argument_list|)
block|{
name|size_t
name|__pos
operator|=
name|__start
operator|.
name|index
argument_list|()
block|;
return|return
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|_S_substring
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__pos
argument_list|,
name|__pos
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|size_type
name|npos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|find
argument_list|(
name|_CharT
name|__c
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|find
argument_list|(
name|_CharT
operator|*
name|__s
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
block|{
name|size_type
name|__result_pos
decl_stmt|;
name|const_iterator
name|__result
init|=
name|search
argument_list|(
name|const_begin
argument_list|()
operator|+
name|__pos
argument_list|,
name|const_end
argument_list|()
argument_list|,
name|__s
argument_list|,
name|__s
operator|+
name|_S_char_ptr_len
argument_list|(
name|__s
argument_list|)
argument_list|)
decl_stmt|;
name|__result_pos
operator|=
name|__result
operator|.
name|index
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|__STL_OLD_ROPE_SEMANTICS
if|if
condition|(
name|__result_pos
operator|==
name|size
argument_list|()
condition|)
name|__result_pos
operator|=
name|npos
expr_stmt|;
endif|#
directive|endif
return|return
name|__result_pos
return|;
block|}
end_decl_stmt

begin_function
name|iterator
name|mutable_begin
parameter_list|()
block|{
return|return
operator|(
name|iterator
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|iterator
name|mutable_end
parameter_list|()
block|{
return|return
operator|(
name|iterator
argument_list|(
name|this
argument_list|,
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_CLASS_PARTIAL_SPECIALIZATION
end_ifdef

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|iterator
operator|>
name|reverse_iterator
expr_stmt|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|iterator
operator|,
name|value_type
operator|,
name|reference
operator|,
name|difference_type
operator|>
name|reverse_iterator
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STL_CLASS_PARTIAL_SPECIALIZATION */
end_comment

begin_function
name|reverse_iterator
name|mutable_rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|mutable_end
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|reverse_iterator
name|mutable_rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|mutable_begin
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|reference
name|mutable_reference_at
parameter_list|(
name|size_type
name|__pos
parameter_list|)
block|{
return|return
name|reference
argument_list|(
name|this
argument_list|,
name|__pos
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STD_STUFF
end_ifdef

begin_function
name|reference
name|operator
function|[]
parameter_list|(
name|size_type
name|__pos
parameter_list|)
block|{
return|return
name|_char_ref_proxy
argument_list|(
name|this
argument_list|,
name|__pos
argument_list|)
return|;
block|}
end_function

begin_function
name|reference
name|at
parameter_list|(
name|size_type
name|__pos
parameter_list|)
block|{
comment|// if (__pos>= size()) throw out_of_range;  // XXX
return|return
operator|(
operator|*
name|this
operator|)
index|[
name|__pos
index|]
return|;
block|}
end_function

begin_function
name|void
name|resize
parameter_list|(
name|size_type
name|__n
parameter_list|,
name|_CharT
name|__c
parameter_list|)
block|{}
end_function

begin_function
name|void
name|resize
parameter_list|(
name|size_type
name|__n
parameter_list|)
block|{}
end_function

begin_function
name|void
name|reserve
parameter_list|(
name|size_type
name|__res_arg
init|=
literal|0
parameter_list|)
block|{}
end_function

begin_expr_stmt
name|size_type
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|max_size
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Stuff below this line is dangerous because it's error prone.
end_comment

begin_comment
comment|// I would really like to get rid of it.
end_comment

begin_comment
comment|// copy function with funny arg ordering.
end_comment

begin_decl_stmt
name|size_type
name|copy
argument_list|(
name|_CharT
operator|*
name|__buffer
argument_list|,
name|size_type
name|__n
argument_list|,
name|size_type
name|__pos
operator|=
literal|0
argument_list|)
decl|const
block|{
return|return
name|copy
argument_list|(
name|__pos
argument_list|,
name|__n
argument_list|,
name|__buffer
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|iterator
name|end
parameter_list|()
block|{
return|return
name|mutable_end
argument_list|()
return|;
block|}
end_function

begin_function
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|mutable_begin
argument_list|()
return|;
block|}
end_function

begin_function
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|mutable_rend
argument_list|()
return|;
block|}
end_function

begin_function
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|mutable_rbegin
argument_list|()
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|const_iterator
name|end
parameter_list|()
block|{
return|return
name|const_end
argument_list|()
return|;
block|}
end_function

begin_function
name|const_iterator
name|begin
parameter_list|()
block|{
return|return
name|const_begin
argument_list|()
return|;
block|}
end_function

begin_function
name|const_reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|const_rend
argument_list|()
return|;
block|}
end_function

begin_function
name|const_reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|const_rbegin
argument_list|()
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|size_type
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|npos
operator|=
call|(
name|size_type
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__y
operator|)
block|{
return|return
operator|(
name|__x
operator|.
name|_M_current_pos
operator|==
name|__y
operator|.
name|_M_current_pos
operator|&&
name|__x
operator|.
name|_M_root
operator|==
name|__y
operator|.
name|_M_root
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__y
operator|)
block|{
return|return
operator|(
name|__x
operator|.
name|_M_current_pos
operator|<
name|__y
operator|.
name|_M_current_pos
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|ptrdiff_t
name|operator
operator|-
operator|(
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__y
operator|)
block|{
return|return
operator|(
name|ptrdiff_t
operator|)
name|__x
operator|.
name|_M_current_pos
operator|-
operator|(
name|ptrdiff_t
operator|)
name|__y
operator|.
name|_M_current_pos
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|-
operator|(
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
name|ptrdiff_t
name|__n
operator|)
block|{
return|return
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__x
operator|.
name|_M_root
operator|,
name|__x
operator|.
name|_M_current_pos
operator|-
name|__n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
name|ptrdiff_t
name|__n
operator|)
block|{
return|return
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__x
operator|.
name|_M_root
operator|,
name|__x
operator|.
name|_M_current_pos
operator|+
name|__n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
name|ptrdiff_t
name|__n
operator|,
specifier|const
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|)
block|{
return|return
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__x
operator|.
name|_M_root
operator|,
name|__x
operator|.
name|_M_current_pos
operator|+
name|__n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__y
operator|)
block|{
return|return
operator|(
name|__x
operator|.
name|_M_current_pos
operator|==
name|__y
operator|.
name|_M_current_pos
operator|&&
name|__x
operator|.
name|_M_root_rope
operator|==
name|__y
operator|.
name|_M_root_rope
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__y
operator|)
block|{
return|return
operator|(
name|__x
operator|.
name|_M_current_pos
operator|<
name|__y
operator|.
name|_M_current_pos
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|ptrdiff_t
name|operator
operator|-
operator|(
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__y
operator|)
block|{
return|return
operator|(
name|ptrdiff_t
operator|)
name|__x
operator|.
name|_M_current_pos
operator|-
operator|(
name|ptrdiff_t
operator|)
name|__y
operator|.
name|_M_current_pos
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|-
operator|(
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
name|ptrdiff_t
name|__n
operator|)
block|{
return|return
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__x
operator|.
name|_M_root_rope
operator|,
name|__x
operator|.
name|_M_current_pos
operator|-
name|__n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
name|ptrdiff_t
name|__n
operator|)
block|{
return|return
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__x
operator|.
name|_M_root_rope
operator|,
name|__x
operator|.
name|_M_current_pos
operator|+
name|__n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
name|ptrdiff_t
name|__n
operator|,
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|)
block|{
return|return
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__x
operator|.
name|_M_root_rope
operator|,
name|__x
operator|.
name|_M_current_pos
operator|+
name|__n
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__left
operator|,
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__right
operator|)
block|{
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|__stl_assert
argument_list|(
name|__left
operator|.
name|get_allocator
argument_list|()
operator|==
name|__right
operator|.
name|get_allocator
argument_list|()
argument_list|)
block|;
endif|#
directive|endif
return|return
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_concat
argument_list|(
name|__left
operator|.
name|_M_tree_ptr
argument_list|,
name|__right
operator|.
name|_M_tree_ptr
argument_list|)
operator|)
return|;
comment|// Inlining this should make it possible to keep __left and
comment|// __right in registers.
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|operator
operator|+=
operator|(
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__left
operator|,
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__right
operator|)
block|{
name|__left
operator|.
name|append
argument_list|(
name|__right
argument_list|)
block|;
return|return
name|__left
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__left
operator|,
specifier|const
name|_CharT
operator|*
name|__right
operator|)
block|{
name|size_t
name|__rlen
operator|=
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|::
name|_S_char_ptr_len
argument_list|(
name|__right
argument_list|)
block|;
return|return
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_concat_char_iter
argument_list|(
name|__left
operator|.
name|_M_tree_ptr
argument_list|,
name|__right
argument_list|,
name|__rlen
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|operator
operator|+=
operator|(
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__left
operator|,
specifier|const
name|_CharT
operator|*
name|__right
operator|)
block|{
name|__left
operator|.
name|append
argument_list|(
name|__right
argument_list|)
block|;
return|return
name|__left
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|operator
operator|+
operator|(
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__left
operator|,
name|_CharT
name|__right
operator|)
block|{
return|return
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_concat_char_iter
argument_list|(
name|__left
operator|.
name|_M_tree_ptr
argument_list|,
operator|&
name|__right
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|operator
operator|+=
operator|(
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__left
operator|,
name|_CharT
name|__right
operator|)
block|{
name|__left
operator|.
name|append
argument_list|(
name|__right
argument_list|)
block|;
return|return
name|__left
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|bool
name|operator
operator|<
operator|(
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__left
operator|,
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__right
operator|)
block|{
return|return
name|__left
operator|.
name|compare
argument_list|(
name|__right
argument_list|)
operator|<
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|bool
name|operator
operator|==
operator|(
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__left
operator|,
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__right
operator|)
block|{
return|return
name|__left
operator|.
name|compare
argument_list|(
name|__right
argument_list|)
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|_Rope_char_ptr_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__x
operator|,
specifier|const
name|_Rope_char_ptr_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__y
operator|)
block|{
return|return
operator|(
name|__x
operator|.
name|_M_pos
operator|==
name|__y
operator|.
name|_M_pos
operator|&&
name|__x
operator|.
name|_M_root
operator|==
name|__y
operator|.
name|_M_root
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|ostream
operator|&
name|operator
operator|<<
operator|(
name|ostream
operator|&
name|__o
operator|,
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__r
operator|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|rope
operator|<
name|char
operator|>
name|crope
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|rope
operator|<
name|wchar_t
operator|>
name|wrope
expr_stmt|;
end_typedef

begin_expr_stmt
specifier|inline
name|crope
operator|::
name|reference
name|__mutable_reference_at
argument_list|(
argument|crope& __c
argument_list|,
argument|size_t __i
argument_list|)
block|{
return|return
name|__c
operator|.
name|mutable_reference_at
argument_list|(
name|__i
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|wrope
operator|::
name|reference
name|__mutable_reference_at
argument_list|(
argument|wrope& __c
argument_list|,
argument|size_t __i
argument_list|)
block|{
return|return
name|__c
operator|.
name|mutable_reference_at
argument_list|(
name|__i
argument_list|)
return|;
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_FUNCTION_TMPL_PARTIAL_ORDER
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|rope<_CharT
argument_list|,
argument|_Alloc>& __x
argument_list|,
argument|rope<_CharT
argument_list|,
argument|_Alloc>& __y
argument_list|)
block|{
name|__x
operator|.
name|swap
argument_list|(
name|__y
argument_list|)
block|; }
else|#
directive|else
specifier|inline
name|void
name|swap
argument_list|(
argument|crope __x
argument_list|,
argument|crope __y
argument_list|)
block|{
name|__x
operator|.
name|swap
argument_list|(
name|__y
argument_list|)
block|; }
specifier|inline
name|void
name|swap
argument_list|(
argument|wrope __x
argument_list|,
argument|wrope __y
argument_list|)
block|{
name|__x
operator|.
name|swap
argument_list|(
name|__y
argument_list|)
block|; }
endif|#
directive|endif
comment|/* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
comment|// Hash functions should probably be revisited later:
name|__STL_TEMPLATE_NULL
expr|struct
name|hash
operator|<
name|crope
operator|>
block|{
name|size_t
name|operator
argument_list|()
operator|(
specifier|const
name|crope
operator|&
name|__str
operator|)
specifier|const
block|{
name|size_t
name|__size
operator|=
name|__str
operator|.
name|size
argument_list|()
block|;
if|if
condition|(
literal|0
operator|==
name|__size
condition|)
return|return
literal|0
return|;
return|return
literal|13
operator|*
name|__str
index|[
literal|0
index|]
operator|+
literal|5
operator|*
name|__str
index|[
name|__size
operator|-
literal|1
index|]
operator|+
name|__size
return|;
block|}
end_expr_stmt

begin_macro
unit|};
name|__STL_TEMPLATE_NULL
end_macro

begin_expr_stmt
unit|struct
name|hash
operator|<
name|wrope
operator|>
block|{
name|size_t
name|operator
argument_list|()
operator|(
specifier|const
name|wrope
operator|&
name|__str
operator|)
specifier|const
block|{
name|size_t
name|__size
operator|=
name|__str
operator|.
name|size
argument_list|()
block|;
if|if
condition|(
literal|0
operator|==
name|__size
condition|)
return|return
literal|0
return|;
return|return
literal|13
operator|*
name|__str
index|[
literal|0
index|]
operator|+
literal|5
operator|*
name|__str
index|[
name|__size
operator|-
literal|1
index|]
operator|+
name|__size
return|;
block|}
end_expr_stmt

begin_if
unit|};
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
end_if

begin_pragma
pragma|#
directive|pragma
name|reset
name|woff
name|1174
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|__STL_END_NAMESPACE
end_macro

begin_include
include|#
directive|include
file|<ropeimpl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SGI_STL_INTERNAL_ROPE_H */
end_comment

begin_comment
comment|// Local Variables:
end_comment

begin_comment
comment|// mode:C++
end_comment

begin_comment
comment|// End:
end_comment

end_unit

