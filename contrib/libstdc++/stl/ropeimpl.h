begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/* NOTE: This is an internal header file, included by other STL headers.  *   You should not attempt to use it directly.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* XXX should use<cstdio> */
end_comment

begin_include
include|#
directive|include
file|<iostream.h>
end_include

begin_comment
comment|/* XXX should use<iostream> */
end_comment

begin_expr_stmt
name|__STL_BEGIN_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
pragma|#
directive|pragma
name|set
name|woff
name|1174
endif|#
directive|endif
comment|// Set buf_start, buf_end, and buf_ptr appropriately, filling tmp_buf
comment|// if necessary.  Assumes _M_path_end[leaf_index] and leaf_pos are correct.
comment|// Results in a valid buf_ptr if the iterator can be legitimately
comment|// dereferenced.
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_setbuf
argument_list|(
argument|_Rope_iterator_base<_CharT
argument_list|,
argument|_Alloc>& __x
argument_list|)
block|{
specifier|const
name|_RopeRep
operator|*
name|__leaf
operator|=
name|__x
operator|.
name|_M_path_end
index|[
name|__x
operator|.
name|_M_leaf_index
index|]
block|;
name|size_t
name|__leaf_pos
operator|=
name|__x
operator|.
name|_M_leaf_pos
block|;
name|size_t
name|__pos
operator|=
name|__x
operator|.
name|_M_current_pos
block|;
switch|switch
condition|(
name|__leaf
operator|->
name|_M_tag
condition|)
block|{
case|case
name|_RopeRep
operator|::
name|_S_leaf
case|:
name|__x
operator|.
name|_M_buf_start
operator|=
operator|(
operator|(
name|_Rope_RopeLeaf
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|__leaf
operator|)
operator|->
name|_M_data
expr_stmt|;
name|__x
operator|.
name|_M_buf_ptr
operator|=
name|__x
operator|.
name|_M_buf_start
operator|+
operator|(
name|__pos
operator|-
name|__leaf_pos
operator|)
expr_stmt|;
name|__x
operator|.
name|_M_buf_end
operator|=
name|__x
operator|.
name|_M_buf_start
operator|+
name|__leaf
operator|->
name|_M_size
expr_stmt|;
break|break;
case|case
name|_RopeRep
operator|::
name|_S_function
case|:
case|case
name|_RopeRep
operator|::
name|_S_substringfn
case|:
block|{
name|size_t
name|__len
init|=
name|_S_iterator_buf_len
decl_stmt|;
name|size_t
name|__buf_start_pos
init|=
name|__leaf_pos
decl_stmt|;
name|size_t
name|__leaf_end
init|=
name|__leaf_pos
operator|+
name|__leaf
operator|->
name|_M_size
decl_stmt|;
name|char_producer
operator|<
name|_CharT
operator|>
operator|*
name|__fn
operator|=
operator|(
operator|(
name|_Rope_RopeFunction
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|__leaf
operator|)
operator|->
name|_M_fn
expr_stmt|;
if|if
condition|(
name|__buf_start_pos
operator|+
name|__len
operator|<=
name|__pos
condition|)
block|{
name|__buf_start_pos
operator|=
name|__pos
operator|-
name|__len
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|__buf_start_pos
operator|+
name|__len
operator|>
name|__leaf_end
condition|)
block|{
name|__buf_start_pos
operator|=
name|__leaf_end
operator|-
name|__len
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|} 		if
operator|(
name|__buf_start_pos
operator|+
name|__len
operator|>
name|__leaf_end
operator|)
block|{
name|__len
operator|=
name|__leaf_end
operator|-
name|__buf_start_pos
block|; 		}
call|(
modifier|*
name|__fn
call|)
argument_list|(
name|__buf_start_pos
operator|-
name|__leaf_pos
argument_list|,
name|__len
argument_list|,
name|__x
operator|.
name|_M_tmp_buf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__x
operator|.
name|_M_buf_ptr
operator|=
name|__x
operator|.
name|_M_tmp_buf
operator|+
operator|(
name|__pos
operator|-
name|__buf_start_pos
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__x
operator|.
name|_M_buf_start
operator|=
name|__x
operator|.
name|_M_tmp_buf
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__x
operator|.
name|_M_buf_end
operator|=
name|__x
operator|.
name|_M_tmp_buf
operator|+
name|__len
expr_stmt|;
end_expr_stmt

begin_empty_stmt
unit|} 	    break
empty_stmt|;
end_empty_stmt

begin_default
default|default:
end_default

begin_expr_stmt
name|__stl_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|} }
comment|// Set path and buffer inside a rope iterator.  We assume that
end_comment

begin_comment
comment|// pos and root are already set.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_setcache
argument_list|(
argument|_Rope_iterator_base<_CharT
argument_list|,
argument|_Alloc>& __x
argument_list|)
block|{
specifier|const
name|_RopeRep
operator|*
name|__path
index|[
name|_RopeRep
operator|::
name|_S_max_rope_depth
operator|+
literal|1
index|]
block|;
specifier|const
name|_RopeRep
operator|*
name|__curr_rope
block|;
name|int
name|__curr_depth
operator|=
operator|-
literal|1
block|;
comment|/* index into path    */
name|size_t
name|__curr_start_pos
operator|=
literal|0
block|;
name|size_t
name|__pos
operator|=
name|__x
operator|.
name|_M_current_pos
block|;
name|unsigned
name|char
name|__dirns
operator|=
literal|0
block|;
comment|// Bit vector marking right turns in the path
name|__stl_assert
argument_list|(
name|__pos
operator|<=
name|__x
operator|.
name|_M_root
operator|->
name|_M_size
argument_list|)
block|;
if|if
condition|(
name|__pos
operator|>=
name|__x
operator|.
name|_M_root
operator|->
name|_M_size
condition|)
block|{
name|__x
operator|.
name|_M_buf_ptr
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|__curr_rope
operator|=
name|__x
operator|.
name|_M_root
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|!=
name|__curr_rope
operator|->
name|_M_c_string
condition|)
block|{
comment|/* Treat the root as a leaf. */
name|__x
operator|.
name|_M_buf_start
operator|=
name|__curr_rope
operator|->
name|_M_c_string
expr_stmt|;
name|__x
operator|.
name|_M_buf_end
operator|=
name|__curr_rope
operator|->
name|_M_c_string
operator|+
name|__curr_rope
operator|->
name|_M_size
expr_stmt|;
name|__x
operator|.
name|_M_buf_ptr
operator|=
name|__curr_rope
operator|->
name|_M_c_string
operator|+
name|__pos
expr_stmt|;
name|__x
operator|.
name|_M_path_end
index|[
literal|0
index|]
operator|=
name|__curr_rope
expr_stmt|;
name|__x
operator|.
name|_M_leaf_index
operator|=
literal|0
expr_stmt|;
name|__x
operator|.
name|_M_leaf_pos
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_if

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
operator|++
name|__curr_depth
expr_stmt|;
name|__stl_assert
argument_list|(
name|__curr_depth
operator|<=
name|_RopeRep
operator|::
name|_S_max_rope_depth
argument_list|)
expr_stmt|;
name|__path
index|[
name|__curr_depth
index|]
operator|=
name|__curr_rope
expr_stmt|;
switch|switch
condition|(
name|__curr_rope
operator|->
name|_M_tag
condition|)
block|{
case|case
name|_RopeRep
operator|::
name|_S_leaf
case|:
case|case
name|_RopeRep
operator|::
name|_S_function
case|:
case|case
name|_RopeRep
operator|::
name|_S_substringfn
case|:
name|__x
operator|.
name|_M_leaf_pos
operator|=
name|__curr_start_pos
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|_RopeRep
operator|::
name|_S_concat
case|:
block|{
name|_Rope_RopeConcatenation
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
name|__c
operator|=
operator|(
name|_Rope_RopeConcatenation
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|__curr_rope
expr_stmt|;
name|_RopeRep
modifier|*
name|__left
init|=
name|__c
operator|->
name|_M_left
decl_stmt|;
name|size_t
name|__left_len
init|=
name|__left
operator|->
name|_M_size
decl_stmt|;
name|__dirns
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|__pos
operator|>=
name|__curr_start_pos
operator|+
name|__left_len
condition|)
block|{
name|__dirns
operator||=
literal|1
expr_stmt|;
name|__curr_rope
operator|=
name|__c
operator|->
name|_M_right
expr_stmt|;
name|__curr_start_pos
operator|+=
name|__left_len
expr_stmt|;
block|}
else|else
block|{
name|__curr_rope
operator|=
name|__left
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_for

begin_label
name|done
label|:
end_label

begin_comment
comment|// Copy last section of path into _M_path_end.
end_comment

begin_block
block|{
name|int
name|__i
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|__j
init|=
name|__curr_depth
operator|+
literal|1
operator|-
name|_S_path_cache_len
decl_stmt|;
if|if
condition|(
name|__j
operator|<
literal|0
condition|)
name|__j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|__j
operator|<=
name|__curr_depth
condition|)
block|{
name|__x
operator|.
name|_M_path_end
index|[
operator|++
name|__i
index|]
operator|=
name|__path
index|[
name|__j
operator|++
index|]
expr_stmt|;
block|}
name|__x
operator|.
name|_M_leaf_index
operator|=
name|__i
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|__x
operator|.
name|_M_path_directions
operator|=
name|__dirns
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_S_setbuf
argument_list|(
name|__x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Specialized version of the above.  Assumes that
end_comment

begin_comment
comment|// the path cache is valid for the previous position.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_setcache_for_incr
argument_list|(
argument|_Rope_iterator_base<_CharT
argument_list|,
argument|_Alloc>& __x
argument_list|)
block|{
name|int
name|__current_index
operator|=
name|__x
operator|.
name|_M_leaf_index
block|;
specifier|const
name|_RopeRep
operator|*
name|__current_node
operator|=
name|__x
operator|.
name|_M_path_end
index|[
name|__current_index
index|]
block|;
name|size_t
name|__len
operator|=
name|__current_node
operator|->
name|_M_size
block|;
name|size_t
name|__node_start_pos
operator|=
name|__x
operator|.
name|_M_leaf_pos
block|;
name|unsigned
name|char
name|__dirns
operator|=
name|__x
operator|.
name|_M_path_directions
block|;
name|_Rope_RopeConcatenation
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|*
name|__c
block|;
name|__stl_assert
argument_list|(
name|__x
operator|.
name|_M_current_pos
operator|<=
name|__x
operator|.
name|_M_root
operator|->
name|_M_size
argument_list|)
block|;
if|if
condition|(
name|__x
operator|.
name|_M_current_pos
operator|-
name|__node_start_pos
operator|<
name|__len
condition|)
block|{
comment|/* More stuff in this leaf, we just didn't cache it. */
name|_S_setbuf
argument_list|(
name|__x
argument_list|)
expr_stmt|;
return|return;
block|}
name|__stl_assert
argument_list|(
name|__node_start_pos
operator|+
name|__len
operator|==
name|__x
operator|.
name|_M_current_pos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|//  node_start_pos is starting position of last_node.
end_comment

begin_while
while|while
condition|(
operator|--
name|__current_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|__dirns
operator|&
literal|1
operator|)
comment|/* Path turned left */
condition|)
break|break;
name|__current_node
operator|=
name|__x
operator|.
name|_M_path_end
index|[
name|__current_index
index|]
expr_stmt|;
name|__c
operator|=
operator|(
name|_Rope_RopeConcatenation
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|__current_node
expr_stmt|;
comment|// Otherwise we were in the right child.  Thus we should pop
comment|// the concatenation node.
name|__node_start_pos
operator|-=
name|__c
operator|->
name|_M_left
operator|->
name|_M_size
expr_stmt|;
name|__dirns
operator|>>=
literal|1
expr_stmt|;
block|}
end_while

begin_if
if|if
condition|(
name|__current_index
operator|<
literal|0
condition|)
block|{
comment|// We underflowed the cache. Punt.
name|_S_setcache
argument_list|(
name|__x
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_expr_stmt
name|__current_node
operator|=
name|__x
operator|.
name|_M_path_end
index|[
name|__current_index
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__c
operator|=
operator|(
name|_Rope_RopeConcatenation
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|__current_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|// current_node is a concatenation node.  We are positioned on the first
end_comment

begin_comment
comment|// character in its right child.
end_comment

begin_comment
comment|// node_start_pos is starting position of current_node.
end_comment

begin_expr_stmt
name|__node_start_pos
operator|+=
name|__c
operator|->
name|_M_left
operator|->
name|_M_size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__current_node
operator|=
name|__c
operator|->
name|_M_right
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__x
operator|.
name|_M_path_end
index|[
operator|++
name|__current_index
index|]
operator|=
name|__current_node
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__dirns
operator||=
literal|1
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|_RopeRep
operator|::
name|_S_concat
operator|==
name|__current_node
operator|->
name|_M_tag
condition|)
block|{
operator|++
name|__current_index
expr_stmt|;
if|if
condition|(
name|_S_path_cache_len
operator|==
name|__current_index
condition|)
block|{
name|int
name|__i
decl_stmt|;
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__i
operator|<
name|_S_path_cache_len
operator|-
literal|1
condition|;
name|__i
operator|++
control|)
block|{
name|__x
operator|.
name|_M_path_end
index|[
name|__i
index|]
operator|=
name|__x
operator|.
name|_M_path_end
index|[
name|__i
operator|+
literal|1
index|]
expr_stmt|;
block|}
operator|--
name|__current_index
expr_stmt|;
block|}
name|__current_node
operator|=
operator|(
operator|(
name|_Rope_RopeConcatenation
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|__current_node
operator|)
operator|->
name|_M_left
expr_stmt|;
name|__x
operator|.
name|_M_path_end
index|[
name|__current_index
index|]
operator|=
name|__current_node
expr_stmt|;
name|__dirns
operator|<<=
literal|1
expr_stmt|;
comment|// node_start_pos is unchanged.
block|}
end_while

begin_expr_stmt
name|__x
operator|.
name|_M_leaf_index
operator|=
name|__current_index
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__x
operator|.
name|_M_leaf_pos
operator|=
name|__node_start_pos
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__x
operator|.
name|_M_path_directions
operator|=
name|__dirns
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_S_setbuf
argument_list|(
name|__x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_M_incr
argument_list|(
argument|size_t __n
argument_list|)
block|{
name|_M_current_pos
operator|+=
name|__n
block|;
if|if
condition|(
literal|0
operator|!=
name|_M_buf_ptr
condition|)
block|{
name|size_t
name|__chars_left
init|=
name|_M_buf_end
operator|-
name|_M_buf_ptr
decl_stmt|;
if|if
condition|(
name|__chars_left
operator|>
name|__n
condition|)
block|{
name|_M_buf_ptr
operator|+=
name|__n
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|__chars_left
operator|==
name|__n
condition|)
block|{
name|_M_buf_ptr
operator|+=
name|__n
expr_stmt|;
name|_S_setcache_for_incr
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
end_elseif

begin_else
else|else
block|{
name|_M_buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_M_decr
argument_list|(
argument|size_t __n
argument_list|)
block|{
if|if
condition|(
literal|0
operator|!=
name|_M_buf_ptr
condition|)
block|{
name|size_t
name|__chars_left
init|=
name|_M_buf_ptr
operator|-
name|_M_buf_start
decl_stmt|;
if|if
condition|(
name|__chars_left
operator|>=
name|__n
condition|)
block|{
name|_M_buf_ptr
operator|-=
name|__n
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|_M_buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}     _M_current_pos
operator|-=
name|__n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_M_check
argument_list|()
block|{
if|if
condition|(
name|_M_root_rope
operator|->
name|_M_tree_ptr
operator|!=
name|_M_root
condition|)
block|{
comment|// _Rope was modified.  Get things fixed up.
name|_RopeRep
operator|::
name|_S_unref
argument_list|(
name|_M_root
argument_list|)
expr_stmt|;
name|_M_root
operator|=
name|_M_root_rope
operator|->
name|_M_tree_ptr
expr_stmt|;
name|_RopeRep
operator|::
name|_S_ref
argument_list|(
name|_M_root
argument_list|)
expr_stmt|;
name|_M_buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|_Rope_const_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_Rope_const_iterator
argument_list|(
specifier|const
name|_Rope_iterator
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|&
name|__x
argument_list|)
operator|:
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__x
operator|)
block|{ }
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|_Rope_iterator
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_Rope_iterator
argument_list|(
argument|rope<_CharT
argument_list|,
argument|_Alloc>& __r
argument_list|,
argument|size_t __pos
argument_list|)
operator|:
name|_Rope_iterator_base
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
name|__r
operator|.
name|_M_tree_ptr
operator|,
name|__pos
operator|)
operator|,
name|_M_root_rope
argument_list|(
argument|&__r
argument_list|)
block|{
name|_RopeRep
operator|::
name|_S_ref
argument_list|(
name|_M_root
argument_list|)
block|; }
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|size_t
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_char_ptr_len
argument_list|(
argument|const _CharT* __s
argument_list|)
block|{
specifier|const
name|_CharT
operator|*
name|__p
operator|=
name|__s
block|;
while|while
condition|(
operator|!
name|_S_is0
argument_list|(
operator|*
name|__p
argument_list|)
condition|)
block|{
operator|++
name|__p
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|(
name|__p
operator|-
name|__s
operator|)
return|;
end_return

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|void
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_M_free_c_string
argument_list|()
block|{
name|_CharT
operator|*
name|__cstr
operator|=
name|_M_c_string
block|;
if|if
condition|(
literal|0
operator|!=
name|__cstr
condition|)
block|{
name|size_t
name|__size
init|=
name|_M_size
operator|+
literal|1
decl_stmt|;
name|destroy
argument_list|(
name|__cstr
argument_list|,
name|__cstr
operator|+
name|__size
argument_list|)
expr_stmt|;
name|_Data_deallocate
argument_list|(
name|__cstr
argument_list|,
name|__size
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
specifier|inline
name|void
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_free_string
argument_list|(
argument|_CharT* __s
argument_list|,
argument|size_t __n
argument_list|,
argument|allocator_type __a
argument_list|)
else|#
directive|else
specifier|inline
name|void
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_free_string
argument_list|(
argument|_CharT* __s
argument_list|,
argument|size_t __n
argument_list|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|_S_is_basic_char_type
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|destroy
argument_list|(
name|__s
argument_list|,
name|__s
operator|+
name|__n
argument_list|)
expr_stmt|;
block|}
comment|//  This has to be a static member, so this gets a bit messy
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|__a
operator|.
name|deallocate
argument_list|(
name|__s
argument_list|,
name|_Rope_RopeLeaf
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|::
name|_S_rounded_up_size
argument_list|(
name|__n
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|_Data_deallocate
argument_list|(
name|__s
argument_list|,
name|_Rope_RopeLeaf
operator|<
name|_CharT
argument_list|,
name|_Alloc
operator|>
operator|::
name|_S_rounded_up_size
argument_list|(
name|__n
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|//  There are several reasons for not doing this with virtual destructors
end_comment

begin_comment
comment|//  and a class specific delete operator:
end_comment

begin_comment
comment|//  - A class specific delete operator can't easily get access to
end_comment

begin_comment
comment|//    allocator instances if we need them.
end_comment

begin_comment
comment|//  - Any virtual function would need a 4 or byte vtable pointer;
end_comment

begin_comment
comment|//    this only requires a one byte tag per object.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_M_free_tree
argument_list|()
block|{
switch|switch
condition|(
name|_M_tag
condition|)
block|{
case|case
name|_S_leaf
case|:
block|{
name|_Rope_RopeLeaf
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
name|__l
operator|=
operator|(
name|_Rope_RopeLeaf
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|this
expr_stmt|;
name|__l
operator|->
name|_Rope_RopeLeaf
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
operator|~
name|_Rope_RopeLeaf
argument_list|()
expr_stmt|;
name|_L_deallocate
argument_list|(
name|__l
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_case
case|case
name|_S_concat
case|:
end_case

begin_block
block|{
name|_Rope_RopeConcatenation
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
name|__c
operator|=
operator|(
name|_Rope_RopeConcatenation
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|this
expr_stmt|;
name|__c
operator|->
name|_Rope_RopeConcatenation
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
operator|~
name|_Rope_RopeConcatenation
argument_list|()
expr_stmt|;
name|_C_deallocate
argument_list|(
name|__c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_case
case|case
name|_S_function
case|:
end_case

begin_block
block|{
name|_Rope_RopeFunction
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
name|__f
operator|=
operator|(
name|_Rope_RopeFunction
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|this
expr_stmt|;
name|__f
operator|->
name|_Rope_RopeFunction
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
operator|~
name|_Rope_RopeFunction
argument_list|()
expr_stmt|;
name|_F_deallocate
argument_list|(
name|__f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_case
case|case
name|_S_substringfn
case|:
end_case

begin_block
block|{
name|_Rope_RopeSubstring
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
name|__ss
operator|=
operator|(
name|_Rope_RopeSubstring
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|*
operator|)
name|this
expr_stmt|;
name|__ss
operator|->
name|_Rope_RopeSubstring
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
operator|~
name|_Rope_RopeSubstring
argument_list|()
expr_stmt|;
name|_S_deallocate
argument_list|(
name|__ss
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_else
unit|} }
else|#
directive|else
end_else

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
specifier|inline
name|void
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_free_string
argument_list|(
argument|const _CharT*
argument_list|,
argument|size_t
argument_list|,
argument|allocator_type
argument_list|)
else|#
directive|else
specifier|inline
name|void
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_free_string
argument_list|(
argument|const _CharT*
argument_list|,
argument|size_t
argument_list|)
endif|#
directive|endif
block|{}
endif|#
directive|endif
comment|// Concatenate a C string onto a leaf rope by copying the rope data.
comment|// Used for short ropes.
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_RopeLeaf
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_leaf_concat_char_iter
argument_list|(
argument|_RopeLeaf* __r
argument_list|,
argument|const _CharT* __iter
argument_list|,
argument|size_t __len
argument_list|)
block|{
name|size_t
name|__old_len
operator|=
name|__r
operator|->
name|_M_size
block|;
name|_CharT
operator|*
name|__new_data
operator|=
operator|(
name|_CharT
operator|*
operator|)
name|_Data_allocate
argument_list|(
name|_S_rounded_up_size
argument_list|(
name|__old_len
operator|+
name|__len
argument_list|)
argument_list|)
block|;
name|_RopeLeaf
operator|*
name|__result
block|;
name|uninitialized_copy_n
argument_list|(
name|__r
operator|->
name|_M_data
argument_list|,
name|__old_len
argument_list|,
name|__new_data
argument_list|)
block|;
name|uninitialized_copy_n
argument_list|(
name|__iter
argument_list|,
name|__len
argument_list|,
name|__new_data
operator|+
name|__old_len
argument_list|)
block|;
name|_S_cond_store_eos
argument_list|(
name|__new_data
index|[
name|__old_len
operator|+
name|__len
index|]
argument_list|)
block|;
name|__STL_TRY
block|{
name|__result
operator|=
name|_S_new_RopeLeaf
argument_list|(
name|__new_data
argument_list|,
name|__old_len
operator|+
name|__len
argument_list|,
name|__r
operator|->
name|get_allocator
argument_list|()
argument_list|)
block|;     }
name|__STL_UNWIND
argument_list|(
name|_RopeRep
operator|::
name|__STL_FREE_STRING
argument_list|(
name|__new_data
argument_list|,
name|__old_len
operator|+
name|__len
argument_list|,
name|__r
operator|->
name|get_allocator
argument_list|()
argument_list|)
argument_list|)
block|;
return|return
name|__result
return|;
block|}
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_comment
comment|// As above, but it's OK to clobber original if refcount is 1
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_RopeLeaf
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_destr_leaf_concat_char_iter
argument_list|(
argument|_RopeLeaf* __r
argument_list|,
argument|const _CharT* __iter
argument_list|,
argument|size_t __len
argument_list|)
block|{
name|__stl_assert
argument_list|(
name|__r
operator|->
name|_M_refcount
operator|>=
literal|1
argument_list|)
block|;
if|if
condition|(
name|__r
operator|->
name|_M_refcount
operator|>
literal|1
condition|)
return|return
name|_S_leaf_concat_char_iter
argument_list|(
name|__r
argument_list|,
name|__iter
argument_list|,
name|__len
argument_list|)
return|;
name|size_t
name|__old_len
operator|=
name|__r
operator|->
name|_M_size
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|_S_allocated_capacity
argument_list|(
name|__old_len
argument_list|)
operator|>=
name|__old_len
operator|+
name|__len
condition|)
block|{
comment|// The space has been partially initialized for the standard
comment|// character types.  But that doesn't matter for those types.
name|uninitialized_copy_n
argument_list|(
name|__iter
argument_list|,
name|__len
argument_list|,
name|__r
operator|->
name|_M_data
operator|+
name|__old_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|_S_is_basic_char_type
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|_S_cond_store_eos
argument_list|(
name|__r
operator|->
name|_M_data
index|[
name|__old_len
operator|+
name|__len
index|]
argument_list|)
expr_stmt|;
name|__stl_assert
argument_list|(
name|__r
operator|->
name|_M_c_string
operator|==
name|__r
operator|->
name|_M_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|__r
operator|->
name|_M_c_string
operator|!=
name|__r
operator|->
name|_M_data
operator|&&
literal|0
operator|!=
name|__r
operator|->
name|_M_c_string
condition|)
block|{
name|__r
operator|->
name|_M_free_c_string
argument_list|()
expr_stmt|;
name|__r
operator|->
name|_M_c_string
operator|=
literal|0
expr_stmt|;
block|}
name|__r
operator|->
name|_M_size
operator|=
name|__old_len
operator|+
name|__len
expr_stmt|;
name|__stl_assert
argument_list|(
name|__r
operator|->
name|_M_refcount
operator|==
literal|1
argument_list|)
expr_stmt|;
name|__r
operator|->
name|_M_refcount
operator|=
literal|2
expr_stmt|;
return|return
name|__r
return|;
block|}
else|else
block|{
name|_RopeLeaf
modifier|*
name|__result
init|=
name|_S_leaf_concat_char_iter
argument_list|(
name|__r
argument_list|,
name|__iter
argument_list|,
name|__len
argument_list|)
decl_stmt|;
name|__stl_assert
argument_list|(
name|__result
operator|->
name|_M_refcount
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
name|__result
return|;
block|}
end_if

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|// Assumes left and right are not 0.
end_comment

begin_comment
comment|// Does not increment (nor decrement on exception) child reference counts.
end_comment

begin_comment
comment|// Result has ref count 1.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_RopeRep
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_tree_concat
argument_list|(
argument|_RopeRep* __left
argument_list|,
argument|_RopeRep* __right
argument_list|)
block|{
name|_RopeConcatenation
operator|*
name|__result
operator|=
name|_S_new_RopeConcatenation
argument_list|(
name|__left
argument_list|,
name|__right
argument_list|,
name|__left
operator|->
name|get_allocator
argument_list|()
argument_list|)
block|;
name|size_t
name|__depth
operator|=
name|__result
operator|->
name|_M_depth
block|;
ifdef|#
directive|ifdef
name|__STL_USE_STD_ALLOCATORS
name|__stl_assert
argument_list|(
name|__left
operator|->
name|get_allocator
argument_list|()
operator|==
name|__right
operator|->
name|get_allocator
argument_list|()
argument_list|)
block|;
endif|#
directive|endif
if|if
condition|(
name|__depth
operator|>
literal|20
operator|&&
operator|(
name|__result
operator|->
name|_M_size
operator|<
literal|1000
operator|||
name|__depth
operator|>
name|_RopeRep
operator|::
name|_S_max_rope_depth
operator|)
condition|)
block|{
name|_RopeRep
modifier|*
name|__balanced
decl_stmt|;
name|__STL_TRY
block|{
name|__balanced
operator|=
name|_S_balance
argument_list|(
name|__result
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__GC
if|if
condition|(
name|__result
operator|!=
name|__balanced
condition|)
block|{
name|__stl_assert
argument_list|(
literal|1
operator|==
name|__result
operator|->
name|_M_refcount
operator|&&
literal|1
operator|==
name|__balanced
operator|->
name|_M_refcount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|__result
operator|->
name|_M_unref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} 	__STL_UNWIND
operator|(
operator|(
name|_C_deallocate
argument_list|(
name|__result
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// In case of exception, we need to deallocate
end_comment

begin_comment
comment|// otherwise dangling result node.  But caller
end_comment

begin_comment
comment|// still owns its children.  Thus unref is
end_comment

begin_comment
comment|// inappropriate.
end_comment

begin_return
return|return
name|__balanced
return|;
end_return

begin_block
unit|} else
block|{
return|return
name|__result
return|;
block|}
end_block

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_RopeRep
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_concat_char_iter
argument_list|(
argument|_RopeRep* __r
argument_list|,
argument|const _CharT*__s
argument_list|,
argument|size_t __slen
argument_list|)
block|{
name|_RopeRep
operator|*
name|__result
block|;
if|if
condition|(
literal|0
operator|==
name|__slen
condition|)
block|{
name|_S_ref
argument_list|(
name|__r
argument_list|)
expr_stmt|;
return|return
name|__r
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
name|__r
condition|)
return|return
name|__STL_ROPE_FROM_UNOWNED_CHAR_PTR
argument_list|(
name|__s
argument_list|,
name|__slen
argument_list|,
name|__r
operator|->
name|get_allocator
argument_list|()
argument_list|)
return|;
end_if

begin_if
if|if
condition|(
name|_RopeRep
operator|::
name|_S_leaf
operator|==
name|__r
operator|->
name|_M_tag
operator|&&
name|__r
operator|->
name|_M_size
operator|+
name|__slen
operator|<=
name|_S_copy_max
condition|)
block|{
name|__result
operator|=
name|_S_leaf_concat_char_iter
argument_list|(
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__r
argument_list|,
name|__s
argument_list|,
name|__slen
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__GC
name|__stl_assert
argument_list|(
literal|1
operator|==
name|__result
operator|->
name|_M_refcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|__result
return|;
block|}
end_if

begin_if
if|if
condition|(
name|_RopeRep
operator|::
name|_S_concat
operator|==
name|__r
operator|->
name|_M_tag
operator|&&
name|_RopeRep
operator|::
name|_S_leaf
operator|==
operator|(
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
operator|)
operator|->
name|_M_right
operator|->
name|_M_tag
condition|)
block|{
name|_RopeLeaf
modifier|*
name|__right
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
operator|(
operator|(
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
operator|)
operator|->
name|_M_right
operator|)
decl_stmt|;
if|if
condition|(
name|__right
operator|->
name|_M_size
operator|+
name|__slen
operator|<=
name|_S_copy_max
condition|)
block|{
name|_RopeRep
modifier|*
name|__left
init|=
operator|(
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
operator|)
operator|->
name|_M_left
decl_stmt|;
name|_RopeRep
modifier|*
name|__nright
init|=
name|_S_leaf_concat_char_iter
argument_list|(
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__right
argument_list|,
name|__s
argument_list|,
name|__slen
argument_list|)
decl_stmt|;
name|__left
operator|->
name|_M_ref_nonnil
argument_list|()
expr_stmt|;
name|__STL_TRY
block|{
name|__result
operator|=
name|_S_tree_concat
argument_list|(
name|__left
argument_list|,
name|__nright
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|_S_unref(__left); _S_unref(__nright)
argument_list|)
empty_stmt|;
ifndef|#
directive|ifndef
name|__GC
name|__stl_assert
argument_list|(
literal|1
operator|==
name|__result
operator|->
name|_M_refcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|__result
return|;
block|}
block|}
end_if

begin_decl_stmt
name|_RopeRep
modifier|*
name|__nright
init|=
name|__STL_ROPE_FROM_UNOWNED_CHAR_PTR
argument_list|(
name|__s
argument_list|,
name|__slen
argument_list|,
name|__r
operator|->
name|get_allocator
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|__STL_TRY
end_macro

begin_block
block|{
name|__r
operator|->
name|_M_ref_nonnil
argument_list|()
expr_stmt|;
name|__result
operator|=
name|_S_tree_concat
argument_list|(
name|__r
argument_list|,
name|__nright
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|__STL_UNWIND
argument_list|(
argument|_S_unref(__r); _S_unref(__nright)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
name|__stl_assert
argument_list|(
literal|1
operator|==
name|__result
operator|->
name|_M_refcount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|__result
return|;
end_return

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_RopeRep
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_destr_concat_char_iter
argument_list|(
argument|_RopeRep* __r
argument_list|,
argument|const _CharT* __s
argument_list|,
argument|size_t __slen
argument_list|)
block|{
name|_RopeRep
operator|*
name|__result
block|;
if|if
condition|(
literal|0
operator|==
name|__r
condition|)
return|return
name|__STL_ROPE_FROM_UNOWNED_CHAR_PTR
argument_list|(
name|__s
argument_list|,
name|__slen
argument_list|,
name|__r
operator|->
name|get_allocator
argument_list|()
argument_list|)
return|;
name|size_t
name|__count
operator|=
name|__r
operator|->
name|_M_refcount
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|__orig_size
init|=
name|__r
operator|->
name|_M_size
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__stl_assert
argument_list|(
name|__count
operator|>=
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__count
operator|>
literal|1
condition|)
return|return
name|_S_concat_char_iter
argument_list|(
name|__r
argument_list|,
name|__s
argument_list|,
name|__slen
argument_list|)
return|;
end_if

begin_if
if|if
condition|(
literal|0
operator|==
name|__slen
condition|)
block|{
name|__r
operator|->
name|_M_refcount
operator|=
literal|2
expr_stmt|;
comment|// One more than before
return|return
name|__r
return|;
block|}
end_if

begin_if
if|if
condition|(
name|__orig_size
operator|+
name|__slen
operator|<=
name|_S_copy_max
operator|&&
name|_RopeRep
operator|::
name|_S_leaf
operator|==
name|__r
operator|->
name|_M_tag
condition|)
block|{
name|__result
operator|=
name|_S_destr_leaf_concat_char_iter
argument_list|(
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__r
argument_list|,
name|__s
argument_list|,
name|__slen
argument_list|)
expr_stmt|;
return|return
name|__result
return|;
block|}
end_if

begin_if
if|if
condition|(
name|_RopeRep
operator|::
name|_S_concat
operator|==
name|__r
operator|->
name|_M_tag
condition|)
block|{
name|_RopeLeaf
modifier|*
name|__right
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
operator|(
operator|(
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
operator|)
operator|->
name|_M_right
operator|)
decl_stmt|;
if|if
condition|(
name|_RopeRep
operator|::
name|_S_leaf
operator|==
name|__right
operator|->
name|_M_tag
operator|&&
name|__right
operator|->
name|_M_size
operator|+
name|__slen
operator|<=
name|_S_copy_max
condition|)
block|{
name|_RopeRep
modifier|*
name|__new_right
init|=
name|_S_destr_leaf_concat_char_iter
argument_list|(
name|__right
argument_list|,
name|__s
argument_list|,
name|__slen
argument_list|)
decl_stmt|;
if|if
condition|(
name|__right
operator|==
name|__new_right
condition|)
block|{
name|__stl_assert
argument_list|(
name|__new_right
operator|->
name|_M_refcount
operator|==
literal|2
argument_list|)
expr_stmt|;
name|__new_right
operator|->
name|_M_refcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|__stl_assert
argument_list|(
name|__new_right
operator|->
name|_M_refcount
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|__right
operator|->
name|_M_unref_nonnil
argument_list|()
expr_stmt|;
block|}
name|__stl_assert
argument_list|(
name|__r
operator|->
name|_M_refcount
operator|==
literal|1
argument_list|)
expr_stmt|;
name|__r
operator|->
name|_M_refcount
operator|=
literal|2
expr_stmt|;
comment|// One more than before.
operator|(
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
operator|)
operator|->
name|_M_right
operator|=
name|__new_right
expr_stmt|;
name|__r
operator|->
name|_M_size
operator|=
name|__orig_size
operator|+
name|__slen
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|__r
operator|->
name|_M_c_string
condition|)
block|{
name|__r
operator|->
name|_M_free_c_string
argument_list|()
expr_stmt|;
name|__r
operator|->
name|_M_c_string
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|__r
return|;
block|}
block|}
end_if

begin_decl_stmt
name|_RopeRep
modifier|*
name|__right
init|=
name|__STL_ROPE_FROM_UNOWNED_CHAR_PTR
argument_list|(
name|__s
argument_list|,
name|__slen
argument_list|,
name|__r
operator|->
name|get_allocator
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__r
operator|->
name|_M_ref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|__STL_TRY
end_macro

begin_block
block|{
name|__result
operator|=
name|_S_tree_concat
argument_list|(
name|__r
argument_list|,
name|__right
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|__STL_UNWIND
argument_list|(
argument|_S_unref(__r); _S_unref(__right)
argument_list|)
end_macro

begin_expr_stmt
name|__stl_assert
argument_list|(
literal|1
operator|==
name|__result
operator|->
name|_M_refcount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__result
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__GC */
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_RopeRep
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_concat
argument_list|(
argument|_RopeRep* __left
argument_list|,
argument|_RopeRep* __right
argument_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|__left
condition|)
block|{
name|_S_ref
argument_list|(
name|__right
argument_list|)
expr_stmt|;
return|return
name|__right
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
name|__right
condition|)
block|{
name|__left
operator|->
name|_M_ref_nonnil
argument_list|()
expr_stmt|;
return|return
name|__left
return|;
block|}
end_if

begin_if
if|if
condition|(
name|_RopeRep
operator|::
name|_S_leaf
operator|==
name|__right
operator|->
name|_M_tag
condition|)
block|{
if|if
condition|(
name|_RopeRep
operator|::
name|_S_leaf
operator|==
name|__left
operator|->
name|_M_tag
condition|)
block|{
if|if
condition|(
name|__right
operator|->
name|_M_size
operator|+
name|__left
operator|->
name|_M_size
operator|<=
name|_S_copy_max
condition|)
block|{
return|return
name|_S_leaf_concat_char_iter
argument_list|(
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__left
argument_list|,
operator|(
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__right
operator|)
operator|->
name|_M_data
argument_list|,
name|__right
operator|->
name|_M_size
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|_RopeRep
operator|::
name|_S_concat
operator|==
name|__left
operator|->
name|_M_tag
operator|&&
name|_RopeRep
operator|::
name|_S_leaf
operator|==
operator|(
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__left
operator|)
operator|->
name|_M_right
operator|->
name|_M_tag
condition|)
block|{
name|_RopeLeaf
modifier|*
name|__leftright
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
operator|(
operator|(
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__left
operator|)
operator|->
name|_M_right
operator|)
decl_stmt|;
if|if
condition|(
name|__leftright
operator|->
name|_M_size
operator|+
name|__right
operator|->
name|_M_size
operator|<=
name|_S_copy_max
condition|)
block|{
name|_RopeRep
modifier|*
name|__leftleft
init|=
operator|(
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__left
operator|)
operator|->
name|_M_left
decl_stmt|;
name|_RopeRep
modifier|*
name|__rest
init|=
name|_S_leaf_concat_char_iter
argument_list|(
name|__leftright
argument_list|,
operator|(
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__right
operator|)
operator|->
name|_M_data
argument_list|,
name|__right
operator|->
name|_M_size
argument_list|)
decl_stmt|;
name|__leftleft
operator|->
name|_M_ref_nonnil
argument_list|()
expr_stmt|;
name|__STL_TRY
block|{
return|return
operator|(
name|_S_tree_concat
argument_list|(
name|__leftleft
argument_list|,
name|__rest
argument_list|)
operator|)
return|;
block|}
name|__STL_UNWIND
argument_list|(
argument|_S_unref(__leftleft); _S_unref(__rest)
argument_list|)
block|}
block|}
block|}
end_if

begin_expr_stmt
name|__left
operator|->
name|_M_ref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__right
operator|->
name|_M_ref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|__STL_TRY
end_macro

begin_block
block|{
return|return
operator|(
name|_S_tree_concat
argument_list|(
name|__left
argument_list|,
name|__right
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|__STL_UNWIND
argument_list|(
argument|_S_unref(__left); _S_unref(__right)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_RopeRep
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_substring
argument_list|(
argument|_RopeRep* __base
argument_list|,
argument|size_t __start
argument_list|,
argument|size_t __endp1
argument_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|__base
condition|)
return|return
literal|0
return|;
name|size_t
name|__len
operator|=
name|__base
operator|->
name|_M_size
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|size_t
name|__adj_endp1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|size_t
name|__lazy_threshold
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|__endp1
operator|>=
name|__len
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|__start
condition|)
block|{
name|__base
operator|->
name|_M_ref_nonnil
argument_list|()
expr_stmt|;
return|return
name|__base
return|;
block|}
else|else
block|{
name|__adj_endp1
operator|=
name|__len
expr_stmt|;
block|}
block|}
else|else
block|{
name|__adj_endp1
operator|=
name|__endp1
expr_stmt|;
block|}
end_if

begin_switch
switch|switch
condition|(
name|__base
operator|->
name|_M_tag
condition|)
block|{
case|case
name|_RopeRep
operator|::
name|_S_concat
case|:
block|{
name|_RopeConcatenation
modifier|*
name|__c
init|=
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__base
decl_stmt|;
name|_RopeRep
modifier|*
name|__left
init|=
name|__c
operator|->
name|_M_left
decl_stmt|;
name|_RopeRep
modifier|*
name|__right
init|=
name|__c
operator|->
name|_M_right
decl_stmt|;
name|size_t
name|__left_len
init|=
name|__left
operator|->
name|_M_size
decl_stmt|;
name|_RopeRep
modifier|*
name|__result
decl_stmt|;
if|if
condition|(
name|__adj_endp1
operator|<=
name|__left_len
condition|)
block|{
return|return
name|_S_substring
argument_list|(
name|__left
argument_list|,
name|__start
argument_list|,
name|__endp1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|__start
operator|>=
name|__left_len
condition|)
block|{
return|return
name|_S_substring
argument_list|(
name|__right
argument_list|,
name|__start
operator|-
name|__left_len
argument_list|,
name|__adj_endp1
operator|-
name|__left_len
argument_list|)
return|;
block|}
name|_Self_destruct_ptr
name|__left_result
argument_list|(
name|_S_substring
argument_list|(
name|__left
argument_list|,
name|__start
argument_list|,
name|__left_len
argument_list|)
argument_list|)
decl_stmt|;
name|_Self_destruct_ptr
name|__right_result
argument_list|(
name|_S_substring
argument_list|(
name|__right
argument_list|,
literal|0
argument_list|,
name|__endp1
operator|-
name|__left_len
argument_list|)
argument_list|)
decl_stmt|;
name|__result
operator|=
name|_S_concat
argument_list|(
name|__left_result
argument_list|,
name|__right_result
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__GC
name|__stl_assert
argument_list|(
literal|1
operator|==
name|__result
operator|->
name|_M_refcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|__result
return|;
block|}
case|case
name|_RopeRep
operator|::
name|_S_leaf
case|:
block|{
name|_RopeLeaf
modifier|*
name|__l
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__base
decl_stmt|;
name|_RopeLeaf
modifier|*
name|__result
decl_stmt|;
name|size_t
name|__result_len
decl_stmt|;
if|if
condition|(
name|__start
operator|>=
name|__adj_endp1
condition|)
return|return
literal|0
return|;
name|__result_len
operator|=
name|__adj_endp1
operator|-
name|__start
expr_stmt|;
if|if
condition|(
name|__result_len
operator|>
name|__lazy_threshold
condition|)
goto|goto
name|lazy
goto|;
ifdef|#
directive|ifdef
name|__GC
specifier|const
name|_CharT
modifier|*
name|__section
init|=
name|__l
operator|->
name|_M_data
operator|+
name|__start
decl_stmt|;
name|__result
operator|=
name|_S_new_RopeLeaf
argument_list|(
name|__section
argument_list|,
name|__result_len
argument_list|,
name|__base
operator|->
name|get_allocator
argument_list|()
argument_list|)
expr_stmt|;
name|__result
operator|->
name|_M_c_string
operator|=
literal|0
expr_stmt|;
comment|// Not eos terminated.
else|#
directive|else
comment|// We should sometimes create substring node instead.
name|__result
operator|=
name|__STL_ROPE_FROM_UNOWNED_CHAR_PTR
argument_list|(
name|__l
operator|->
name|_M_data
operator|+
name|__start
argument_list|,
name|__result_len
argument_list|,
name|__base
operator|->
name|get_allocator
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|__result
return|;
block|}
case|case
name|_RopeRep
operator|::
name|_S_substringfn
case|:
comment|// Avoid introducing multiple layers of substring nodes.
block|{
name|_RopeSubstring
modifier|*
name|__old
init|=
operator|(
name|_RopeSubstring
operator|*
operator|)
name|__base
decl_stmt|;
name|size_t
name|__result_len
decl_stmt|;
if|if
condition|(
name|__start
operator|>=
name|__adj_endp1
condition|)
return|return
literal|0
return|;
name|__result_len
operator|=
name|__adj_endp1
operator|-
name|__start
expr_stmt|;
if|if
condition|(
name|__result_len
operator|>
name|__lazy_threshold
condition|)
block|{
name|_RopeSubstring
modifier|*
name|__result
init|=
name|_S_new_RopeSubstring
argument_list|(
name|__old
operator|->
name|_M_base
argument_list|,
name|__start
operator|+
name|__old
operator|->
name|_M_start
argument_list|,
name|__adj_endp1
operator|-
name|__start
argument_list|,
name|__base
operator|->
name|get_allocator
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|__result
return|;
block|}
comment|// *** else fall through: ***
block|}
case|case
name|_RopeRep
operator|::
name|_S_function
case|:
block|{
name|_RopeFunction
modifier|*
name|__f
init|=
operator|(
name|_RopeFunction
operator|*
operator|)
name|__base
decl_stmt|;
name|_CharT
modifier|*
name|__section
decl_stmt|;
name|size_t
name|__result_len
decl_stmt|;
if|if
condition|(
name|__start
operator|>=
name|__adj_endp1
condition|)
return|return
literal|0
return|;
name|__result_len
operator|=
name|__adj_endp1
operator|-
name|__start
expr_stmt|;
if|if
condition|(
name|__result_len
operator|>
name|__lazy_threshold
condition|)
goto|goto
name|lazy
goto|;
name|__section
operator|=
operator|(
name|_CharT
operator|*
operator|)
name|_Data_allocate
argument_list|(
name|_S_rounded_up_size
argument_list|(
name|__result_len
argument_list|)
argument_list|)
expr_stmt|;
name|__STL_TRY
block|{
operator|(
operator|*
operator|(
name|__f
operator|->
name|_M_fn
operator|)
operator|)
operator|(
name|__start
operator|,
name|__result_len
operator|,
name|__section
operator|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
name|_RopeRep
operator|::
name|__STL_FREE_STRING
argument_list|(
name|__section
argument_list|,
name|__result_len
argument_list|,
name|__base
operator|->
name|get_allocator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|_S_cond_store_eos
argument_list|(
name|__section
index|[
name|__result_len
index|]
argument_list|)
expr_stmt|;
return|return
name|_S_new_RopeLeaf
argument_list|(
name|__section
argument_list|,
name|__result_len
argument_list|,
name|__base
operator|->
name|get_allocator
argument_list|()
argument_list|)
return|;
block|}
block|}
end_switch

begin_comment
comment|/*NOTREACHED*/
end_comment

begin_expr_stmt
name|__stl_assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|lazy
label|:
end_label

begin_block
block|{
comment|// Create substring node.
return|return
name|_S_new_RopeSubstring
argument_list|(
name|__base
argument_list|,
name|__start
argument_list|,
name|__adj_endp1
operator|-
name|__start
argument_list|,
name|__base
operator|->
name|get_allocator
argument_list|()
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|>
name|class
name|_Rope_flatten_char_consumer
operator|:
name|public
name|_Rope_char_consumer
operator|<
name|_CharT
operator|>
block|{
name|private
operator|:
name|_CharT
operator|*
name|_M_buf_ptr
block|;
name|public
operator|:
comment|//  _CharT* _M_buffer;  // XXX not used
name|_Rope_flatten_char_consumer
argument_list|(
argument|_CharT* __buffer
argument_list|)
block|{
name|_M_buf_ptr
operator|=
name|__buffer
block|; 	}
block|;
operator|~
name|_Rope_flatten_char_consumer
argument_list|()
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_CharT
operator|*
name|__leaf
operator|,
name|size_t
name|__n
operator|)
block|{
name|uninitialized_copy_n
argument_list|(
name|__leaf
argument_list|,
name|__n
argument_list|,
name|_M_buf_ptr
argument_list|)
block|;
name|_M_buf_ptr
operator|+=
name|__n
block|;
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_CharT
operator|>
name|class
name|_Rope_find_char_char_consumer
operator|:
name|public
name|_Rope_char_consumer
operator|<
name|_CharT
operator|>
block|{
name|private
operator|:
name|_CharT
name|_M_pattern
block|;
name|public
operator|:
name|size_t
name|_M_count
block|;
comment|// Number of nonmatching characters
name|_Rope_find_char_char_consumer
argument_list|(
argument|_CharT __p
argument_list|)
operator|:
name|_M_pattern
argument_list|(
name|__p
argument_list|)
block|,
name|_M_count
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|_Rope_find_char_char_consumer
argument_list|()
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_CharT
operator|*
name|__leaf
operator|,
name|size_t
name|__n
operator|)
block|{
name|size_t
name|__i
block|;
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__i
operator|<
name|__n
condition|;
name|__i
operator|++
control|)
block|{
if|if
condition|(
name|__leaf
index|[
name|__i
index|]
operator|==
name|_M_pattern
condition|)
block|{
name|_M_count
operator|+=
name|__i
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|_M_count
operator|+=
name|__n
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_empty_stmt
unit|} }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|>
name|class
name|_Rope_insert_char_consumer
operator|:
name|public
name|_Rope_char_consumer
operator|<
name|_CharT
operator|>
block|{
name|private
operator|:
typedef|typedef
name|ostream
name|_Insert_ostream
typedef|;
name|_Insert_ostream
operator|&
name|_M_o
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|// _CharT* buffer;    // XXX not used
end_comment

begin_expr_stmt
name|_Rope_insert_char_consumer
argument_list|(
name|_Insert_ostream
operator|&
name|__writer
argument_list|)
operator|:
name|_M_o
argument_list|(
argument|__writer
argument_list|)
block|{}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|~
name|_Rope_insert_char_consumer
argument_list|()
block|{ }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Caller is presumed to own the ostream
end_comment

begin_expr_stmt
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|_CharT
operator|*
name|__leaf
operator|,
name|size_t
name|__n
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Returns true to continue traversal.
end_comment

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|_CharT
operator|>
name|bool
name|_Rope_insert_char_consumer
operator|<
name|_CharT
operator|>
operator|::
name|operator
argument_list|()
operator|(
specifier|const
name|_CharT
operator|*
name|__leaf
operator|,
name|size_t
name|__n
operator|)
block|{
name|size_t
name|__i
block|;
comment|//  We assume that formatting is set up correctly for each element.
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__i
operator|<
name|__n
condition|;
name|__i
operator|++
control|)
name|_M_o
operator|<<
name|__leaf
index|[
name|__i
index|]
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_expr_stmt
unit|}  inline
name|bool
name|_Rope_insert_char_consumer
operator|<
name|char
operator|>
operator|::
name|operator
argument_list|()
operator|(
specifier|const
name|char
operator|*
name|__leaf
operator|,
name|size_t
name|__n
operator|)
block|{
name|size_t
name|__i
block|;
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__i
operator|<
name|__n
condition|;
name|__i
operator|++
control|)
name|_M_o
operator|.
name|put
argument_list|(
name|__leaf
index|[
name|__i
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_if
unit|}
if|#
directive|if
literal|0
end_if

begin_comment
comment|// I couldn't get this to work work with the VC++ version of basic_ostream.
end_comment

begin_comment
comment|// It also doesn't really do the right thing unless o is a wide stream.
end_comment

begin_comment
comment|// Given that wchar_t is often 4 bytes, its not clear to me how useful
end_comment

begin_comment
comment|// this stuff is anyway.
end_comment

begin_endif
unit|inline bool _Rope_insert_char_consumer<wchar_t>::operator() 					(const wchar_t* __leaf, size_t __n) {     size_t __i;     for (__i = 0; __i< __n; __i++) _M_o.put(__leaf[__i]);     return true; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_MSC_VER&& !BORLAND */
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|bool
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_apply_to_pieces
argument_list|(
argument|_Rope_char_consumer<_CharT>& __c
argument_list|,
argument|const _RopeRep* __r
argument_list|,
argument|size_t __begin
argument_list|,
argument|size_t __end
argument_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|__r
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|__r
operator|->
name|_M_tag
condition|)
block|{
case|case
name|_RopeRep
operator|::
name|_S_concat
case|:
block|{
name|_RopeConcatenation
modifier|*
name|__conc
init|=
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
decl_stmt|;
name|_RopeRep
modifier|*
name|__left
init|=
name|__conc
operator|->
name|_M_left
decl_stmt|;
name|size_t
name|__left_len
init|=
name|__left
operator|->
name|_M_size
decl_stmt|;
if|if
condition|(
name|__begin
operator|<
name|__left_len
condition|)
block|{
name|size_t
name|__left_end
init|=
name|min
argument_list|(
name|__left_len
argument_list|,
name|__end
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|_S_apply_to_pieces
argument_list|(
name|__c
argument_list|,
name|__left
argument_list|,
name|__begin
argument_list|,
name|__left_end
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|__end
operator|>
name|__left_len
condition|)
block|{
name|_RopeRep
modifier|*
name|__right
init|=
name|__conc
operator|->
name|_M_right
decl_stmt|;
name|size_t
name|__right_start
init|=
name|max
argument_list|(
name|__left_len
argument_list|,
name|__begin
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|_S_apply_to_pieces
argument_list|(
name|__c
argument_list|,
name|__right
argument_list|,
name|__right_start
operator|-
name|__left_len
argument_list|,
name|__end
operator|-
name|__left_len
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
case|case
name|_RopeRep
operator|::
name|_S_leaf
case|:
block|{
name|_RopeLeaf
modifier|*
name|__l
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__r
decl_stmt|;
return|return
name|__c
argument_list|(
name|__l
operator|->
name|_M_data
operator|+
name|__begin
argument_list|,
name|__end
operator|-
name|__begin
argument_list|)
return|;
block|}
case|case
name|_RopeRep
operator|::
name|_S_function
case|:
case|case
name|_RopeRep
operator|::
name|_S_substringfn
case|:
block|{
name|_RopeFunction
modifier|*
name|__f
init|=
operator|(
name|_RopeFunction
operator|*
operator|)
name|__r
decl_stmt|;
name|size_t
name|__len
init|=
name|__end
operator|-
name|__begin
decl_stmt|;
name|bool
name|__result
decl_stmt|;
name|_CharT
modifier|*
name|__buffer
init|=
operator|(
name|_CharT
operator|*
operator|)
name|alloc
operator|::
name|allocate
argument_list|(
name|__len
operator|*
sizeof|sizeof
argument_list|(
name|_CharT
argument_list|)
argument_list|)
decl_stmt|;
name|__STL_TRY
block|{
operator|(
operator|*
operator|(
name|__f
operator|->
name|_M_fn
operator|)
operator|)
operator|(
name|__begin
operator|,
name|__end
operator|,
name|__buffer
operator|)
expr_stmt|;
name|__result
operator|=
name|__c
argument_list|(
name|__buffer
argument_list|,
name|__len
argument_list|)
expr_stmt|;
name|alloc
operator|::
name|deallocate
argument_list|(
name|__buffer
argument_list|,
name|__len
operator|*
sizeof|sizeof
argument_list|(
name|_CharT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|(alloc::deallocate(__buffer, 						__len * sizeof(_CharT)))
argument_list|)
return|return
name|__result
return|;
block|}
default|default:
name|__stl_assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
name|false
return|;
block|}
end_switch

begin_function
unit|}  inline
name|void
name|_Rope_fill
parameter_list|(
name|ostream
modifier|&
name|__o
parameter_list|,
name|size_t
name|__n
parameter_list|)
block|{
name|char
name|__f
init|=
name|__o
operator|.
name|fill
argument_list|()
decl_stmt|;
name|size_t
name|__i
decl_stmt|;
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__i
operator|<
name|__n
condition|;
name|__i
operator|++
control|)
name|__o
operator|.
name|put
argument_list|(
name|__f
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|>
specifier|inline
name|bool
name|_Rope_is_simple
argument_list|(
argument|_CharT*
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_function
specifier|inline
name|bool
name|_Rope_is_simple
parameter_list|(
name|char
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|_Rope_is_simple
parameter_list|(
name|wchar_t
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|ostream
operator|&
name|operator
operator|<<
operator|(
name|ostream
operator|&
name|__o
operator|,
specifier|const
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|__r
operator|)
block|{
name|size_t
name|__w
operator|=
name|__o
operator|.
name|width
argument_list|()
block|;
name|bool
name|__left
operator|=
name|bool
argument_list|(
name|__o
operator|.
name|flags
argument_list|()
operator|&
name|ios
operator|::
name|left
argument_list|)
block|;
name|size_t
name|__pad_len
block|;
name|size_t
name|__rope_len
operator|=
name|__r
operator|.
name|size
argument_list|()
block|;
name|_Rope_insert_char_consumer
operator|<
name|_CharT
operator|>
name|__c
argument_list|(
name|__o
argument_list|)
block|;
name|bool
name|__is_simple
operator|=
name|_Rope_is_simple
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
block|;
if|if
condition|(
name|__rope_len
operator|<
name|__w
condition|)
block|{
name|__pad_len
operator|=
name|__w
operator|-
name|__rope_len
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|__pad_len
operator|=
literal|0
expr_stmt|;
block|}
end_else

begin_if
if|if
condition|(
operator|!
name|__is_simple
condition|)
name|__o
operator|.
name|width
argument_list|(
name|__w
operator|/
name|__rope_len
argument_list|)
expr_stmt|;
end_if

begin_macro
name|__STL_TRY
end_macro

begin_block
block|{
if|if
condition|(
name|__is_simple
operator|&&
operator|!
name|__left
operator|&&
name|__pad_len
operator|>
literal|0
condition|)
block|{
name|_Rope_fill
argument_list|(
name|__o
argument_list|,
name|__pad_len
argument_list|)
expr_stmt|;
block|}
name|__r
operator|.
name|apply_to_pieces
argument_list|(
literal|0
argument_list|,
name|__r
operator|.
name|size
argument_list|()
argument_list|,
name|__c
argument_list|)
expr_stmt|;
if|if
condition|(
name|__is_simple
operator|&&
name|__left
operator|&&
name|__pad_len
operator|>
literal|0
condition|)
block|{
name|_Rope_fill
argument_list|(
name|__o
argument_list|,
name|__pad_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|__is_simple
condition|)
name|__o
operator|.
name|width
argument_list|(
name|__w
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|__STL_UNWIND
argument_list|(
argument|if (!__is_simple) __o.width(__w)
argument_list|)
end_macro

begin_return
return|return
name|__o
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|_CharT
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_flatten
argument_list|(
argument|_RopeRep* __r
argument_list|,
argument|size_t __start
argument_list|,
argument|size_t __len
argument_list|,
argument|_CharT* __buffer
argument_list|)
block|{
name|_Rope_flatten_char_consumer
operator|<
name|_CharT
operator|>
name|__c
argument_list|(
name|__buffer
argument_list|)
block|;
name|_S_apply_to_pieces
argument_list|(
name|__c
argument_list|,
name|__r
argument_list|,
name|__start
argument_list|,
name|__start
operator|+
name|__len
argument_list|)
block|;
return|return
operator|(
name|__buffer
operator|+
name|__len
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|size_t
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|find
argument_list|(
argument|_CharT __pattern
argument_list|,
argument|size_t __start
argument_list|)
specifier|const
block|{
name|_Rope_find_char_char_consumer
operator|<
name|_CharT
operator|>
name|__c
argument_list|(
name|__pattern
argument_list|)
block|;
name|_S_apply_to_pieces
argument_list|(
name|__c
argument_list|,
name|_M_tree_ptr
argument_list|,
name|__start
argument_list|,
name|size
argument_list|()
argument_list|)
block|;
name|size_type
name|__result_pos
operator|=
name|__start
operator|+
name|__c
operator|.
name|_M_count
block|;
ifndef|#
directive|ifndef
name|__STL_OLD_ROPE_SEMANTICS
if|if
condition|(
name|__result_pos
operator|==
name|size
argument_list|()
condition|)
name|__result_pos
operator|=
name|npos
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|__result_pos
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|_CharT
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_flatten
argument_list|(
argument|_RopeRep* __r
argument_list|,
argument|_CharT* __buffer
argument_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|__r
condition|)
return|return
name|__buffer
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|__r
operator|->
name|_M_tag
condition|)
block|{
case|case
name|_RopeRep
operator|::
name|_S_concat
case|:
block|{
name|_RopeConcatenation
modifier|*
name|__c
init|=
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
decl_stmt|;
name|_RopeRep
modifier|*
name|__left
init|=
name|__c
operator|->
name|_M_left
decl_stmt|;
name|_RopeRep
modifier|*
name|__right
init|=
name|__c
operator|->
name|_M_right
decl_stmt|;
name|_CharT
modifier|*
name|__rest
init|=
name|_S_flatten
argument_list|(
name|__left
argument_list|,
name|__buffer
argument_list|)
decl_stmt|;
return|return
name|_S_flatten
argument_list|(
name|__right
argument_list|,
name|__rest
argument_list|)
return|;
block|}
case|case
name|_RopeRep
operator|::
name|_S_leaf
case|:
block|{
name|_RopeLeaf
modifier|*
name|__l
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__r
decl_stmt|;
return|return
name|copy_n
argument_list|(
name|__l
operator|->
name|_M_data
argument_list|,
name|__l
operator|->
name|_M_size
argument_list|,
name|__buffer
argument_list|)
operator|.
name|second
return|;
block|}
case|case
name|_RopeRep
operator|::
name|_S_function
case|:
case|case
name|_RopeRep
operator|::
name|_S_substringfn
case|:
comment|// We dont yet do anything with substring nodes.
comment|// This needs to be fixed before ropefiles will work well.
block|{
name|_RopeFunction
modifier|*
name|__f
init|=
operator|(
name|_RopeFunction
operator|*
operator|)
name|__r
decl_stmt|;
operator|(
operator|*
operator|(
name|__f
operator|->
name|_M_fn
operator|)
operator|)
operator|(
literal|0
operator|,
name|__f
operator|->
name|_M_size
operator|,
name|__buffer
operator|)
expr_stmt|;
return|return
name|__buffer
operator|+
name|__f
operator|->
name|_M_size
return|;
block|}
default|default:
name|__stl_assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
literal|0
return|;
block|}
end_switch

begin_comment
unit|}
comment|// This needs work for _CharT != char
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_dump
argument_list|(
argument|_RopeRep* __r
argument_list|,
argument|int __indent
argument_list|)
block|{
for|for
control|(
name|int
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|__indent
condition|;
name|__i
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
name|__r
condition|)
block|{
name|printf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_if
if|if
condition|(
name|_RopeRep
operator|::
name|_S_concat
operator|==
name|__r
operator|->
name|_M_tag
condition|)
block|{
name|_RopeConcatenation
modifier|*
name|__c
init|=
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
decl_stmt|;
name|_RopeRep
modifier|*
name|__left
init|=
name|__c
operator|->
name|_M_left
decl_stmt|;
name|_RopeRep
modifier|*
name|__right
init|=
name|__c
operator|->
name|_M_right
decl_stmt|;
ifdef|#
directive|ifdef
name|__GC
name|printf
argument_list|(
literal|"Concatenation %p (depth = %d, len = %ld, %s balanced)\n"
argument_list|,
name|__r
argument_list|,
name|__r
operator|->
name|_M_depth
argument_list|,
name|__r
operator|->
name|_M_size
argument_list|,
name|__r
operator|->
name|_M_is_balanced
condition|?
literal|""
else|:
literal|"not"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Concatenation %p (rc = %ld, depth = %d, "
literal|"len = %ld, %s balanced)\n"
argument_list|,
name|__r
argument_list|,
name|__r
operator|->
name|_M_refcount
argument_list|,
name|__r
operator|->
name|_M_depth
argument_list|,
name|__r
operator|->
name|_M_size
argument_list|,
name|__r
operator|->
name|_M_is_balanced
condition|?
literal|""
else|:
literal|"not"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_S_dump
argument_list|(
name|__left
argument_list|,
name|__indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|_S_dump
argument_list|(
name|__right
argument_list|,
name|__indent
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|char
modifier|*
name|__kind
decl_stmt|;
switch|switch
condition|(
name|__r
operator|->
name|_M_tag
condition|)
block|{
case|case
name|_RopeRep
operator|::
name|_S_leaf
case|:
name|__kind
operator|=
literal|"Leaf"
expr_stmt|;
break|break;
case|case
name|_RopeRep
operator|::
name|_S_function
case|:
name|__kind
operator|=
literal|"Function"
expr_stmt|;
break|break;
case|case
name|_RopeRep
operator|::
name|_S_substringfn
case|:
name|__kind
operator|=
literal|"Function representing substring"
expr_stmt|;
break|break;
default|default:
name|__kind
operator|=
literal|"(corrupted kind field!)"
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__GC
name|printf
argument_list|(
literal|"%s %p (depth = %d, len = %ld) "
argument_list|,
name|__kind
argument_list|,
name|__r
argument_list|,
name|__r
operator|->
name|_M_depth
argument_list|,
name|__r
operator|->
name|_M_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s %p (rc = %ld, depth = %d, len = %ld) "
argument_list|,
name|__kind
argument_list|,
name|__r
argument_list|,
name|__r
operator|->
name|_M_refcount
argument_list|,
name|__r
operator|->
name|_M_depth
argument_list|,
name|__r
operator|->
name|_M_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|_S_is_one_byte_char_type
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
specifier|const
name|int
name|__max_len
init|=
literal|40
decl_stmt|;
name|_Self_destruct_ptr
name|__prefix
argument_list|(
name|_S_substring
argument_list|(
name|__r
argument_list|,
literal|0
argument_list|,
name|__max_len
argument_list|)
argument_list|)
decl_stmt|;
name|_CharT
name|__buffer
index|[
name|__max_len
operator|+
literal|1
index|]
decl_stmt|;
name|bool
name|__too_big
init|=
name|__r
operator|->
name|_M_size
operator|>
name|__prefix
operator|->
name|_M_size
decl_stmt|;
name|_S_flatten
argument_list|(
name|__prefix
argument_list|,
name|__buffer
argument_list|)
expr_stmt|;
name|__buffer
index|[
name|__prefix
operator|->
name|_M_size
index|]
operator|=
name|_S_eos
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|__buffer
argument_list|,
name|__too_big
condition|?
literal|"...\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|const
name|unsigned
name|long
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_min_len
index|[
name|_Rope_RopeRep
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_max_rope_depth
operator|+
literal|1
index|]
operator|=
block|{
comment|/* 0 */
literal|1
block|,
comment|/* 1 */
literal|2
block|,
comment|/* 2 */
literal|3
block|,
comment|/* 3 */
literal|5
block|,
comment|/* 4 */
literal|8
block|,
comment|/* 5 */
literal|13
block|,
comment|/* 6 */
literal|21
block|,
comment|/* 7 */
literal|34
block|,
comment|/* 8 */
literal|55
block|,
comment|/* 9 */
literal|89
block|,
comment|/* 10 */
literal|144
block|,
comment|/* 11 */
literal|233
block|,
comment|/* 12 */
literal|377
block|,
comment|/* 13 */
literal|610
block|,
comment|/* 14 */
literal|987
block|,
comment|/* 15 */
literal|1597
block|,
comment|/* 16 */
literal|2584
block|,
comment|/* 17 */
literal|4181
block|,
comment|/* 18 */
literal|6765
block|,
comment|/* 19 */
literal|10946
block|,
comment|/* 20 */
literal|17711
block|,
comment|/* 21 */
literal|28657
block|,
comment|/* 22 */
literal|46368
block|,
comment|/* 23 */
literal|75025
block|,
comment|/* 24 */
literal|121393
block|,
comment|/* 25 */
literal|196418
block|,
comment|/* 26 */
literal|317811
block|,
comment|/* 27 */
literal|514229
block|,
comment|/* 28 */
literal|832040
block|,
comment|/* 29 */
literal|1346269
block|,
comment|/* 30 */
literal|2178309
block|,
comment|/* 31 */
literal|3524578
block|,
comment|/* 32 */
literal|5702887
block|,
comment|/* 33 */
literal|9227465
block|,
comment|/* 34 */
literal|14930352
block|,
comment|/* 35 */
literal|24157817
block|,
comment|/* 36 */
literal|39088169
block|,
comment|/* 37 */
literal|63245986
block|,
comment|/* 38 */
literal|102334155
block|,
comment|/* 39 */
literal|165580141
block|,
comment|/* 40 */
literal|267914296
block|,
comment|/* 41 */
literal|433494437
block|,
comment|/* 42 */
literal|701408733
block|,
comment|/* 43 */
literal|1134903170
block|,
comment|/* 44 */
literal|1836311903
block|,
comment|/* 45 */
literal|2971215073u
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|// These are Fibonacci numbers< 2**32.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_RopeRep
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_balance
argument_list|(
argument|_RopeRep* __r
argument_list|)
block|{
name|_RopeRep
operator|*
name|__forest
index|[
name|_RopeRep
operator|::
name|_S_max_rope_depth
operator|+
literal|1
index|]
block|;
name|_RopeRep
operator|*
name|__result
operator|=
literal|0
block|;
name|int
name|__i
block|;
comment|// Invariant:
comment|// The concatenation of forest in descending order is equal to __r.
comment|// __forest[__i]._M_size>= _S_min_len[__i]
comment|// __forest[__i]._M_depth = __i
comment|// References from forest are included in refcount.
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__i
operator|<=
name|_RopeRep
operator|::
name|_S_max_rope_depth
condition|;
operator|++
name|__i
control|)
name|__forest
index|[
name|__i
index|]
operator|=
literal|0
expr_stmt|;
name|__STL_TRY
block|{
name|_S_add_to_forest
argument_list|(
name|__r
argument_list|,
name|__forest
argument_list|)
block|;
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__i
operator|<=
name|_RopeRep
operator|::
name|_S_max_rope_depth
condition|;
operator|++
name|__i
control|)
if|if
condition|(
literal|0
operator|!=
name|__forest
index|[
name|__i
index|]
condition|)
block|{
ifndef|#
directive|ifndef
name|__GC
name|_Self_destruct_ptr
name|__old
parameter_list|(
name|__result
parameter_list|)
function_decl|;
endif|#
directive|endif
name|__result
operator|=
name|_S_concat
argument_list|(
name|__forest
index|[
name|__i
index|]
argument_list|,
name|__result
argument_list|)
expr_stmt|;
name|__forest
index|[
name|__i
index|]
operator|->
name|_M_unref_nonnil
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__STL_USE_EXCEPTIONS
argument_list|)
name|__forest
index|[
name|__i
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_expr_stmt

begin_expr_stmt
unit|}     __STL_UNWIND
operator|(
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__i
operator|<=
name|_RopeRep
operator|::
name|_S_max_rope_depth
condition|;
name|__i
operator|++
control|)
name|_S_unref
argument_list|(
name|__forest
index|[
name|__i
index|]
argument_list|)
operator|)
end_expr_stmt

begin_if
if|if
condition|(
name|__result
operator|->
name|_M_depth
operator|>
name|_RopeRep
operator|::
name|_S_max_rope_depth
condition|)
name|abort
argument_list|()
expr_stmt|;
end_if

begin_return
return|return
operator|(
name|__result
operator|)
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_add_to_forest
argument_list|(
argument|_RopeRep* __r
argument_list|,
argument|_RopeRep** __forest
argument_list|)
block|{
if|if
condition|(
name|__r
operator|->
name|_M_is_balanced
condition|)
block|{
name|_S_add_leaf_to_forest
argument_list|(
name|__r
argument_list|,
name|__forest
argument_list|)
expr_stmt|;
return|return;
block|}
name|__stl_assert
argument_list|(
name|__r
operator|->
name|_M_tag
operator|==
name|_RopeRep
operator|::
name|_S_concat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|_RopeConcatenation
modifier|*
name|__c
init|=
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
decl_stmt|;
name|_S_add_to_forest
argument_list|(
name|__c
operator|->
name|_M_left
argument_list|,
name|__forest
argument_list|)
expr_stmt|;
name|_S_add_to_forest
argument_list|(
name|__c
operator|->
name|_M_right
argument_list|,
name|__forest
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
unit|}   template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_add_leaf_to_forest
argument_list|(
argument|_RopeRep* __r
argument_list|,
argument|_RopeRep** __forest
argument_list|)
block|{
name|_RopeRep
operator|*
name|__insertee
block|;
comment|// included in refcount
name|_RopeRep
operator|*
name|__too_tiny
operator|=
literal|0
block|;
comment|// included in refcount
name|int
name|__i
block|;
comment|// forest[0..__i-1] is empty
name|size_t
name|__s
operator|=
name|__r
operator|->
name|_M_size
block|;
for|for
control|(
name|__i
operator|=
literal|0
init|;
name|__s
operator|>=
name|_S_min_len
index|[
name|__i
operator|+
literal|1
index|]
comment|/* not this bucket */
condition|;
operator|++
name|__i
control|)
block|{
if|if
condition|(
literal|0
operator|!=
name|__forest
index|[
name|__i
index|]
condition|)
block|{
ifndef|#
directive|ifndef
name|__GC
name|_Self_destruct_ptr
name|__old
parameter_list|(
name|__too_tiny
parameter_list|)
function_decl|;
endif|#
directive|endif
name|__too_tiny
operator|=
name|_S_concat_and_set_balanced
argument_list|(
name|__forest
index|[
name|__i
index|]
argument_list|,
name|__too_tiny
argument_list|)
expr_stmt|;
name|__forest
index|[
name|__i
index|]
operator|->
name|_M_unref_nonnil
argument_list|()
expr_stmt|;
name|__forest
index|[
name|__i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_ifndef
unit|}     {
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_function_decl
name|_Self_destruct_ptr
name|__old
parameter_list|(
name|__too_tiny
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|__insertee
operator|=
name|_S_concat_and_set_balanced
argument_list|(
name|__too_tiny
argument_list|,
name|__r
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Too_tiny dead, and no longer included in refcount.
end_comment

begin_comment
comment|// Insertee is live and included.
end_comment

begin_expr_stmt
unit|__stl_assert
operator|(
name|_S_is_almost_balanced
argument_list|(
name|__insertee
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__stl_assert
argument_list|(
name|__insertee
operator|->
name|_M_depth
operator|<=
name|__r
operator|->
name|_M_depth
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
operator|++
name|__i
control|)
block|{
if|if
condition|(
literal|0
operator|!=
name|__forest
index|[
name|__i
index|]
condition|)
block|{
ifndef|#
directive|ifndef
name|__GC
name|_Self_destruct_ptr
name|__old
parameter_list|(
name|__insertee
parameter_list|)
function_decl|;
endif|#
directive|endif
name|__insertee
operator|=
name|_S_concat_and_set_balanced
argument_list|(
name|__forest
index|[
name|__i
index|]
argument_list|,
name|__insertee
argument_list|)
expr_stmt|;
name|__forest
index|[
name|__i
index|]
operator|->
name|_M_unref_nonnil
argument_list|()
expr_stmt|;
name|__forest
index|[
name|__i
index|]
operator|=
literal|0
expr_stmt|;
name|__stl_assert
argument_list|(
name|_S_is_almost_balanced
argument_list|(
name|__insertee
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|__stl_assert
argument_list|(
name|_S_min_len
index|[
name|__i
index|]
operator|<=
name|__insertee
operator|->
name|_M_size
argument_list|)
expr_stmt|;
name|__stl_assert
argument_list|(
name|__forest
index|[
name|__i
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|__i
operator|==
name|_RopeRep
operator|::
name|_S_max_rope_depth
operator|||
name|__insertee
operator|->
name|_M_size
operator|<
name|_S_min_len
index|[
name|__i
operator|+
literal|1
index|]
condition|)
block|{
name|__forest
index|[
name|__i
index|]
operator|=
name|__insertee
expr_stmt|;
comment|// refcount is OK since __insertee is now dead.
return|return;
block|}
block|}
end_for

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|_CharT
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_fetch
argument_list|(
argument|_RopeRep* __r
argument_list|,
argument|size_type __i
argument_list|)
block|{
name|__GC_CONST
name|_CharT
operator|*
name|__cstr
operator|=
name|__r
operator|->
name|_M_c_string
block|;
name|__stl_assert
argument_list|(
name|__i
operator|<
name|__r
operator|->
name|_M_size
argument_list|)
block|;
if|if
condition|(
literal|0
operator|!=
name|__cstr
condition|)
return|return
name|__cstr
index|[
name|__i
index|]
return|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|__r
operator|->
name|_M_tag
condition|)
block|{
case|case
name|_RopeRep
operator|::
name|_S_concat
case|:
block|{
name|_RopeConcatenation
modifier|*
name|__c
init|=
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
decl_stmt|;
name|_RopeRep
modifier|*
name|__left
init|=
name|__c
operator|->
name|_M_left
decl_stmt|;
name|size_t
name|__left_len
init|=
name|__left
operator|->
name|_M_size
decl_stmt|;
if|if
condition|(
name|__i
operator|>=
name|__left_len
condition|)
block|{
name|__i
operator|-=
name|__left_len
expr_stmt|;
name|__r
operator|=
name|__c
operator|->
name|_M_right
expr_stmt|;
block|}
else|else
block|{
name|__r
operator|=
name|__left
expr_stmt|;
block|}
block|}
break|break;
case|case
name|_RopeRep
operator|::
name|_S_leaf
case|:
block|{
name|_RopeLeaf
modifier|*
name|__l
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__r
decl_stmt|;
return|return
name|__l
operator|->
name|_M_data
index|[
name|__i
index|]
return|;
block|}
case|case
name|_RopeRep
operator|::
name|_S_function
case|:
case|case
name|_RopeRep
operator|::
name|_S_substringfn
case|:
block|{
name|_RopeFunction
modifier|*
name|__f
init|=
operator|(
name|_RopeFunction
operator|*
operator|)
name|__r
decl_stmt|;
name|_CharT
name|__result
decl_stmt|;
operator|(
operator|*
operator|(
name|__f
operator|->
name|_M_fn
operator|)
operator|)
operator|(
name|__i
operator|,
literal|1
operator|,
operator|&
name|__result
operator|)
expr_stmt|;
return|return
name|__result
return|;
block|}
block|}
block|}
end_for

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_comment
comment|// Return a uniquely referenced character slot for the given
end_comment

begin_comment
comment|// position, or 0 if that's not possible.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|_CharT
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_fetch_ptr
argument_list|(
argument|_RopeRep* __r
argument_list|,
argument|size_type __i
argument_list|)
block|{
name|_RopeRep
operator|*
name|__clrstack
index|[
name|_RopeRep
operator|::
name|_S_max_rope_depth
index|]
block|;
name|size_t
name|__csptr
operator|=
literal|0
block|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|__r
operator|->
name|_M_refcount
operator|>
literal|1
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|__r
operator|->
name|_M_tag
condition|)
block|{
case|case
name|_RopeRep
operator|::
name|_S_concat
case|:
block|{
name|_RopeConcatenation
modifier|*
name|__c
init|=
operator|(
name|_RopeConcatenation
operator|*
operator|)
name|__r
decl_stmt|;
name|_RopeRep
modifier|*
name|__left
init|=
name|__c
operator|->
name|_M_left
decl_stmt|;
name|size_t
name|__left_len
init|=
name|__left
operator|->
name|_M_size
decl_stmt|;
if|if
condition|(
name|__c
operator|->
name|_M_c_string
operator|!=
literal|0
condition|)
name|__clrstack
index|[
name|__csptr
operator|++
index|]
operator|=
name|__c
expr_stmt|;
if|if
condition|(
name|__i
operator|>=
name|__left_len
condition|)
block|{
name|__i
operator|-=
name|__left_len
expr_stmt|;
name|__r
operator|=
name|__c
operator|->
name|_M_right
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|__r
operator|=
name|__left
expr_stmt|;
block|}
end_else

begin_empty_stmt
unit|} 	    break
empty_stmt|;
end_empty_stmt

begin_case
case|case
name|_RopeRep
operator|::
name|_S_leaf
case|:
end_case

begin_block
block|{
name|_RopeLeaf
modifier|*
name|__l
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__r
decl_stmt|;
if|if
condition|(
name|__l
operator|->
name|_M_c_string
operator|!=
name|__l
operator|->
name|_M_data
operator|&&
name|__l
operator|->
name|_M_c_string
operator|!=
literal|0
condition|)
name|__clrstack
index|[
name|__csptr
operator|++
index|]
operator|=
name|__l
expr_stmt|;
while|while
condition|(
name|__csptr
operator|>
literal|0
condition|)
block|{
operator|--
name|__csptr
expr_stmt|;
name|_RopeRep
modifier|*
name|__d
init|=
name|__clrstack
index|[
name|__csptr
index|]
decl_stmt|;
name|__d
operator|->
name|_M_free_c_string
argument_list|()
expr_stmt|;
name|__d
operator|->
name|_M_c_string
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|__l
operator|->
name|_M_data
operator|+
name|__i
return|;
block|}
end_block

begin_case
case|case
name|_RopeRep
operator|::
name|_S_function
case|:
end_case

begin_case
case|case
name|_RopeRep
operator|::
name|_S_substringfn
case|:
end_case

begin_return
return|return
literal|0
return|;
end_return

begin_endif
unit|}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GC */
end_comment

begin_comment
comment|// The following could be implemented trivially using
end_comment

begin_comment
comment|// lexicographical_compare_3way.
end_comment

begin_comment
comment|// We do a little more work to avoid dealing with rope iterators for
end_comment

begin_comment
comment|// flat strings.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|int
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_compare
argument_list|(
argument|const _RopeRep* __left
argument_list|,
argument|const _RopeRep* __right
argument_list|)
block|{
name|size_t
name|__left_len
block|;
name|size_t
name|__right_len
block|;
if|if
condition|(
literal|0
operator|==
name|__right
condition|)
return|return
literal|0
operator|!=
name|__left
return|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
name|__left
condition|)
return|return
operator|-
literal|1
return|;
end_if

begin_expr_stmt
name|__left_len
operator|=
name|__left
operator|->
name|_M_size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__right_len
operator|=
name|__right
operator|->
name|_M_size
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|_RopeRep
operator|::
name|_S_leaf
operator|==
name|__left
operator|->
name|_M_tag
condition|)
block|{
name|_RopeLeaf
modifier|*
name|__l
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__left
decl_stmt|;
if|if
condition|(
name|_RopeRep
operator|::
name|_S_leaf
operator|==
name|__right
operator|->
name|_M_tag
condition|)
block|{
name|_RopeLeaf
modifier|*
name|__r
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__right
decl_stmt|;
return|return
name|lexicographical_compare_3way
argument_list|(
name|__l
operator|->
name|_M_data
argument_list|,
name|__l
operator|->
name|_M_data
operator|+
name|__left_len
argument_list|,
name|__r
operator|->
name|_M_data
argument_list|,
name|__r
operator|->
name|_M_data
operator|+
name|__right_len
argument_list|)
return|;
block|}
else|else
block|{
name|const_iterator
name|__rstart
argument_list|(
name|__right
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|const_iterator
name|__rend
parameter_list|(
name|__right
parameter_list|,
name|__right_len
parameter_list|)
function_decl|;
return|return
name|lexicographical_compare_3way
argument_list|(
name|__l
operator|->
name|_M_data
argument_list|,
name|__l
operator|->
name|_M_data
operator|+
name|__left_len
argument_list|,
name|__rstart
argument_list|,
name|__rend
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|const_iterator
name|__lstart
argument_list|(
name|__left
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|const_iterator
name|__lend
parameter_list|(
name|__left
parameter_list|,
name|__left_len
parameter_list|)
function_decl|;
if|if
condition|(
name|_RopeRep
operator|::
name|_S_leaf
operator|==
name|__right
operator|->
name|_M_tag
condition|)
block|{
name|_RopeLeaf
modifier|*
name|__r
init|=
operator|(
name|_RopeLeaf
operator|*
operator|)
name|__right
decl_stmt|;
return|return
name|lexicographical_compare_3way
argument_list|(
name|__lstart
argument_list|,
name|__lend
argument_list|,
name|__r
operator|->
name|_M_data
argument_list|,
name|__r
operator|->
name|_M_data
operator|+
name|__right_len
argument_list|)
return|;
block|}
else|else
block|{
name|const_iterator
name|__rstart
argument_list|(
name|__right
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|const_iterator
name|__rend
parameter_list|(
name|__right
parameter_list|,
name|__right_len
parameter_list|)
function_decl|;
return|return
name|lexicographical_compare_3way
argument_list|(
name|__lstart
argument_list|,
name|__lend
argument_list|,
name|__rstart
argument_list|,
name|__rend
argument_list|)
return|;
block|}
block|}
end_if

begin_comment
unit|}
comment|// Assignment to reference proxies.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|&
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|operator
operator|=
operator|(
name|_CharT
name|__c
operator|)
block|{
name|_RopeRep
operator|*
name|__old
operator|=
name|_M_root
operator|->
name|_M_tree_ptr
block|;
ifndef|#
directive|ifndef
name|__GC
comment|// First check for the case in which everything is uniquely
comment|// referenced.  In that case we can do this destructively.
name|_CharT
operator|*
name|__ptr
operator|=
name|_My_rope
operator|::
name|_S_fetch_ptr
argument_list|(
name|__old
argument_list|,
name|_M_pos
argument_list|)
block|;
if|if
condition|(
literal|0
operator|!=
name|__ptr
condition|)
block|{
operator|*
name|__ptr
operator|=
name|__c
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
endif|#
directive|endif
name|_Self_destruct_ptr
name|__left
argument_list|(
name|_My_rope
operator|::
name|_S_substring
argument_list|(
name|__old
argument_list|,
literal|0
argument_list|,
name|_M_pos
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_Self_destruct_ptr
name|__right
argument_list|(
name|_My_rope
operator|::
name|_S_substring
argument_list|(
name|__old
argument_list|,
name|_M_pos
operator|+
literal|1
argument_list|,
name|__old
operator|->
name|_M_size
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Self_destruct_ptr
name|__result_left
argument_list|(
name|_My_rope
operator|::
name|_S_destr_concat_char_iter
argument_list|(
name|__left
argument_list|,
operator|&
name|__c
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
name|__stl_assert
argument_list|(
name|__left
operator|==
name|__result_left
operator|||
literal|1
operator|==
name|__result_left
operator|->
name|_M_refcount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|_RopeRep
modifier|*
name|__result
init|=
name|_My_rope
operator|::
name|_S_concat
argument_list|(
name|__result_left
argument_list|,
name|__right
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GC
end_ifndef

begin_expr_stmt
name|__stl_assert
argument_list|(
literal|1
operator|<=
name|__result
operator|->
name|_M_refcount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_RopeRep
operator|::
name|_S_unref
argument_list|(
name|__old
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|_M_root
operator|->
name|_M_tree_ptr
operator|=
name|__result
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|inline
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|operator
name|_CharT
argument_list|()
specifier|const
block|{
if|if
condition|(
name|_M_current_valid
condition|)
block|{
return|return
name|_M_current
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
name|_My_rope
operator|::
name|_S_fetch
argument_list|(
name|_M_root
operator|->
name|_M_tree_ptr
argument_list|,
name|_M_pos
argument_list|)
return|;
block|}
end_else

begin_expr_stmt
unit|} template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|_Rope_char_ptr_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
name|_Rope_char_ref_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|operator
operator|&
operator|(
operator|)
specifier|const
block|{
return|return
name|_Rope_char_ptr_proxy
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|rope
argument_list|(
argument|size_t __n
argument_list|,
argument|_CharT __c
argument_list|,
argument|const allocator_type& __a
argument_list|)
operator|:
name|_Base
argument_list|(
argument|__a
argument_list|)
block|{
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
name|__result
block|;
specifier|const
name|size_t
name|__exponentiate_threshold
operator|=
literal|32
block|;
name|size_t
name|__exponent
block|;
name|size_t
name|__rest
block|;
name|_CharT
operator|*
name|__rest_buffer
block|;
name|_RopeRep
operator|*
name|__remainder
block|;
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
name|__remainder_rope
block|;
if|if
condition|(
literal|0
operator|==
name|__n
condition|)
return|return;
name|__exponent
operator|=
name|__n
operator|/
name|__exponentiate_threshold
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__rest
operator|=
name|__n
operator|%
name|__exponentiate_threshold
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
name|__rest
condition|)
block|{
name|__remainder
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|__rest_buffer
operator|=
name|_Data_allocate
argument_list|(
name|_S_rounded_up_size
argument_list|(
name|__rest
argument_list|)
argument_list|)
expr_stmt|;
name|uninitialized_fill_n
argument_list|(
name|__rest_buffer
argument_list|,
name|__rest
argument_list|,
name|__c
argument_list|)
expr_stmt|;
name|_S_cond_store_eos
argument_list|(
name|__rest_buffer
index|[
name|__rest
index|]
argument_list|)
expr_stmt|;
name|__STL_TRY
block|{
name|__remainder
operator|=
name|_S_new_RopeLeaf
argument_list|(
name|__rest_buffer
argument_list|,
name|__rest
argument_list|,
name|__a
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|_RopeRep::__STL_FREE_STRING(__rest_buffer, __rest, __a)
argument_list|)
block|}
end_if

begin_expr_stmt
name|__remainder_rope
operator|.
name|_M_tree_ptr
operator|=
name|__remainder
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__exponent
operator|!=
literal|0
condition|)
block|{
name|_CharT
modifier|*
name|__base_buffer
init|=
name|_Data_allocate
argument_list|(
name|_S_rounded_up_size
argument_list|(
name|__exponentiate_threshold
argument_list|)
argument_list|)
decl_stmt|;
name|_RopeLeaf
modifier|*
name|__base_leaf
decl_stmt|;
name|rope
name|__base_rope
decl_stmt|;
name|uninitialized_fill_n
argument_list|(
name|__base_buffer
argument_list|,
name|__exponentiate_threshold
argument_list|,
name|__c
argument_list|)
expr_stmt|;
name|_S_cond_store_eos
argument_list|(
name|__base_buffer
index|[
name|__exponentiate_threshold
index|]
argument_list|)
expr_stmt|;
name|__STL_TRY
block|{
name|__base_leaf
operator|=
name|_S_new_RopeLeaf
argument_list|(
name|__base_buffer
argument_list|,
name|__exponentiate_threshold
argument_list|,
name|__a
argument_list|)
expr_stmt|;
block|}
name|__STL_UNWIND
argument_list|(
argument|_RopeRep::__STL_FREE_STRING(__base_buffer,  	                                         __exponentiate_threshold, __a)
argument_list|)
name|__base_rope
operator|.
name|_M_tree_ptr
operator|=
name|__base_leaf
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|__exponent
condition|)
block|{
name|__result
operator|=
name|__base_rope
expr_stmt|;
ifndef|#
directive|ifndef
name|__GC
name|__stl_assert
argument_list|(
literal|2
operator|==
name|__result
operator|.
name|_M_tree_ptr
operator|->
name|_M_refcount
argument_list|)
expr_stmt|;
comment|// One each for base_rope and __result
endif|#
directive|endif
block|}
else|else
block|{
comment|// XXX what is power()?
name|__result
operator|=
name|power
argument_list|(
name|__base_rope
argument_list|,
name|__exponent
argument_list|,
name|_Concat_fn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|!=
name|__remainder
condition|)
block|{
name|__result
operator|+=
name|__remainder_rope
expr_stmt|;
block|}
block|}
else|else
block|{
name|__result
operator|=
name|__remainder_rope
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|_M_tree_ptr
operator|=
name|__result
operator|.
name|_M_tree_ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_M_tree_ptr
operator|->
name|_M_ref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|_CharT
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_empty_c_str
index|[
literal|1
index|]
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STL_PTHREADS
end_ifdef

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|pthread_mutex_t
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|_S_swap_lock
operator|=
name|PTHREAD_MUTEX_INITIALIZER
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|const
name|_CharT
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|c_str
argument_list|()
specifier|const
block|{
if|if
condition|(
literal|0
operator|==
name|_M_tree_ptr
condition|)
block|{
name|_S_empty_c_str
index|[
literal|0
index|]
operator|=
name|_S_eos
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|// Possibly redundant,
comment|// but probably fast.
return|return
name|_S_empty_c_str
return|;
block|}
name|__GC_CONST
name|_CharT
operator|*
name|__old_c_string
operator|=
name|_M_tree_ptr
operator|->
name|_M_c_string
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|!=
name|__old_c_string
condition|)
return|return
operator|(
name|__old_c_string
operator|)
return|;
end_if

begin_decl_stmt
name|size_t
name|__s
init|=
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_CharT
modifier|*
name|__result
init|=
name|_Data_allocate
argument_list|(
name|__s
operator|+
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_S_flatten
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__result
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__result
index|[
name|__s
index|]
operator|=
name|_S_eos
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GC
end_ifdef

begin_expr_stmt
name|_M_tree_ptr
operator|->
name|_M_c_string
operator|=
name|__result
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
operator|(
name|__old_c_string
operator|=
name|_S_atomic_swap
argument_list|(
operator|&
operator|(
name|_M_tree_ptr
operator|->
name|_M_c_string
operator|)
argument_list|,
name|__result
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// It must have been added in the interim.  Hence it had to have been
comment|// separately allocated.  Deallocate the old copy, since we just
comment|// replaced it.
name|destroy
argument_list|(
name|__old_c_string
argument_list|,
name|__old_c_string
operator|+
name|__s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|_Data_deallocate
argument_list|(
name|__old_c_string
argument_list|,
name|__s
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
operator|(
name|__result
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
specifier|const
name|_CharT
operator|*
name|rope
operator|<
name|_CharT
operator|,
name|_Alloc
operator|>
operator|::
name|replace_with_c_str
argument_list|()
block|{
if|if
condition|(
literal|0
operator|==
name|_M_tree_ptr
condition|)
block|{
name|_S_empty_c_str
index|[
literal|0
index|]
operator|=
name|_S_eos
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|_S_empty_c_str
return|;
block|}
name|__GC_CONST
name|_CharT
operator|*
name|__old_c_string
operator|=
name|_M_tree_ptr
operator|->
name|_M_c_string
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|_RopeRep
operator|::
name|_S_leaf
operator|==
name|_M_tree_ptr
operator|->
name|_M_tag
operator|&&
literal|0
operator|!=
name|__old_c_string
condition|)
block|{
return|return
operator|(
name|__old_c_string
operator|)
return|;
block|}
end_if

begin_decl_stmt
name|size_t
name|__s
init|=
name|size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_CharT
modifier|*
name|__result
init|=
name|_Data_allocate
argument_list|(
name|_S_rounded_up_size
argument_list|(
name|__s
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_S_flatten
argument_list|(
name|_M_tree_ptr
argument_list|,
name|__result
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__result
index|[
name|__s
index|]
operator|=
name|_S_eos
argument_list|(
operator|(
name|_CharT
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_M_tree_ptr
operator|->
name|_M_unref_nonnil
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_M_tree_ptr
operator|=
name|_S_new_RopeLeaf
argument_list|(
name|__result
argument_list|,
name|__s
argument_list|,
name|get_allocator
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|__result
operator|)
return|;
end_return

begin_comment
unit|}
comment|// Algorithm specializations.  More should be added.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_MSC_VER
end_ifndef

begin_comment
comment|// I couldn't get this to work with VC++
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|_CharT
operator|,
name|class
name|_Alloc
operator|>
name|void
name|_Rope_rotate
argument_list|(
argument|_Rope_iterator<_CharT
argument_list|,
argument|_Alloc> __first
argument_list|,
argument|_Rope_iterator<_CharT
argument_list|,
argument|_Alloc> __middle
argument_list|,
argument|_Rope_iterator<_CharT
argument_list|,
argument|_Alloc> __last
argument_list|)
block|{
name|__stl_assert
argument_list|(
name|__first
operator|.
name|container
argument_list|()
operator|==
name|__middle
operator|.
name|container
argument_list|()
operator|&&
name|__middle
operator|.
name|container
argument_list|()
operator|==
name|__last
operator|.
name|container
argument_list|()
argument_list|)
block|;
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
operator|&
name|__r
argument_list|(
name|__first
operator|.
name|container
argument_list|()
argument_list|)
block|;
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
name|__prefix
operator|=
name|__r
operator|.
name|substr
argument_list|(
literal|0
argument_list|,
name|__first
operator|.
name|index
argument_list|()
argument_list|)
block|;
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
name|__suffix
operator|=
name|__r
operator|.
name|substr
argument_list|(
name|__last
operator|.
name|index
argument_list|()
argument_list|,
name|__r
operator|.
name|size
argument_list|()
operator|-
name|__last
operator|.
name|index
argument_list|()
argument_list|)
block|;
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
name|__part1
operator|=
name|__r
operator|.
name|substr
argument_list|(
name|__middle
operator|.
name|index
argument_list|()
argument_list|,
name|__last
operator|.
name|index
argument_list|()
operator|-
name|__middle
operator|.
name|index
argument_list|()
argument_list|)
block|;
name|rope
operator|<
name|_CharT
block|,
name|_Alloc
operator|>
name|__part2
operator|=
name|__r
operator|.
name|substr
argument_list|(
name|__first
operator|.
name|index
argument_list|()
argument_list|,
name|__middle
operator|.
name|index
argument_list|()
operator|-
name|__first
operator|.
name|index
argument_list|()
argument_list|)
block|;
name|__r
operator|=
name|__prefix
block|;
name|__r
operator|+=
name|__part1
block|;
name|__r
operator|+=
name|__part2
block|;
name|__r
operator|+=
name|__suffix
block|; }
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
comment|// Appears to confuse g++
specifier|inline
name|void
name|rotate
argument_list|(
argument|_Rope_iterator<char
argument_list|,
argument|__STL_DEFAULT_ALLOCATOR(char)> __first
argument_list|,
argument|_Rope_iterator<char
argument_list|,
argument|__STL_DEFAULT_ALLOCATOR(char)> __middle
argument_list|,
argument|_Rope_iterator<char
argument_list|,
argument|__STL_DEFAULT_ALLOCATOR(char)> __last
argument_list|)
block|{
name|_Rope_rotate
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|)
block|; }
endif|#
directive|endif
if|#
directive|if
literal|0
comment|// Probably not useful for several reasons:
comment|// - for SGIs 7.1 compiler and probably some others,
comment|//   this forces lots of rope<wchar_t, ...> instantiations, creating a
comment|//   code bloat and compile time problem.  (Fixed in 7.2.)
comment|// - wchar_t is 4 bytes wide on most UNIX platforms, making it unattractive
comment|//   for unicode strings.  Unsigned short may be a better character
comment|//   type.
expr|inline void rotate( 		_Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __first,                 _Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __middle,                 _Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __last) {     _Rope_rotate(__first, __middle, __last); }
endif|#
directive|endif
endif|#
directive|endif
comment|/* _MSC_VER */
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|_MIPS_SIM
operator|!=
name|_MIPS_SIM_ABI32
operator|)
pragma|#
directive|pragma
name|reset
name|woff
name|1174
endif|#
directive|endif
name|__STL_END_NAMESPACE
end_expr_stmt

begin_comment
comment|// Local Variables:
end_comment

begin_comment
comment|// mode:C++
end_comment

begin_comment
comment|// End:
end_comment

end_unit

